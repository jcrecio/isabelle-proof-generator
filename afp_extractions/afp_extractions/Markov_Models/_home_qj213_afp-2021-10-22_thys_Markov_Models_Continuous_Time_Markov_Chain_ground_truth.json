{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/Continuous_Time_Markov_Chain.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma trace_at_simp[simp]: \"trace_at s ((t', s')##\\<omega>) j = (if t' \\<le> j then trace_at s' \\<omega> j else s)\"", "lemma trace_at_eq:\n  \"trace_at s \\<omega> j = (case sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> of \\<infinity> \\<Rightarrow> undefined | enat i \\<Rightarrow> (s ## smap snd \\<omega>) !! i)\"", "lemma trace_at_shift: \"trace_at s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) t = trace_at s \\<omega> (t - t')\"", "lemma merge_at_simp[simp]: \"merge_at (x##\\<omega>) j \\<omega>' = (if fst x \\<le> j then x##merge_at \\<omega> j \\<omega>' else \\<omega>')\"", "lemma space_exponential: \"space (exponential l) = UNIV\"", "lemma sets_exponential[measurable_cong]: \"sets (exponential l) = sets borel\"", "lemma prob_space_exponential: \"0 < l \\<Longrightarrow> prob_space (exponential l)\"", "lemma AE_exponential: \"0 < l \\<Longrightarrow> AE x in exponential l. 0 < x\"", "lemma emeasure_exponential_Ioi_cutoff:\n  assumes \"0 < l\"\n  shows \"emeasure (exponential l) {x <..} = exp (- (max 0 x) * l)\"", "lemma emeasure_exponential_Ioi:\n  \"0 < l \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> emeasure (exponential l) {x <..} = exp (- x * l)\"", "lemma exponential_eq_stretch:\n  assumes \"0 < l\"\n  shows \"exponential l = distr (exponential 1) borel (\\<lambda>x. (1/l) * x)\"", "lemma uniform_measure_exponential:\n  assumes \"0 < l\" \"0 \\<le> t\"\n  shows \"uniform_measure (exponential l) {t <..} = distr (exponential l) borel ((+) t)\" (is \"?L = ?R\")", "lemma emeasure_PiM_exponential_Ioi_finite:\n  assumes \"J \\<subseteq> I\" \"finite J\" \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 < R i\" \"0 \\<le> x\"\n  shows \"emeasure (\\<Pi>\\<^sub>M i\\<in>I. exponential (R i)) (prod_emb I (\\<lambda>i. exponential (R i)) J (\\<Pi>\\<^sub>E j\\<in>J. {x<..})) = exp (- x * (\\<Sum>i\\<in>J. R i))\"", "lemma emeasure_PiM_exponential_Ioi_sequence:\n  assumes R: \"summable R\" \"\\<And>i. 0 < R i\" \"0 \\<le> x\"\n  shows \"emeasure (\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R i)) (\\<Pi> i\\<in>UNIV. {x<..}) = exp (- x * suminf R)\"", "lemma emeasure_PiM_exponential_Ioi_countable:\n  assumes R: \"J \\<subseteq> I\" \"countable J\" \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 < R i\" \"0 \\<le> x\" and finite: \"integrable (count_space J) R\"\n  shows \"emeasure (\\<Pi>\\<^sub>M i\\<in>I. exponential (R i)) (prod_emb I (\\<lambda>i. exponential (R i)) J (\\<Pi>\\<^sub>E j\\<in>J. {x<..})) =\n    exp (- x * (LINT i|count_space J. R i))\"", "lemma AE_PiM_exponential_suminf_infty:\n  fixes R :: \"nat \\<Rightarrow> real\"\n  assumes R: \"\\<And>n. 0 < R n\" and finite: \"(\\<Sum>n. ennreal (1 / R n)) = top\"\n  shows \"AE \\<omega> in \\<Pi>\\<^sub>M n\\<in>UNIV. exponential (R n). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>\"", "lemma I_countable: \"countable (I x)\"", "lemma ennreal_escape_rate: \"ennreal (escape_rate x) = (\\<integral>\\<^sup>+y. R x y \\<partial>count_space UNIV)\"", "lemma escape_rate_pos: \"0 < escape_rate x\"", "lemma nonneg_escape_rate[simp]: \"0 \\<le> escape_rate x\"", "lemma prob_space_exponential_escape_rate: \"prob_space (exponential (escape_rate x))\"", "lemma measurable_escape_rate[measurable]: \"escape_rate \\<in> count_space UNIV \\<rightarrow>\\<^sub>M borel\"", "lemma measurable_exponential_escape_rate[measurable]: \"(\\<lambda>x. exponential (escape_rate x)) \\<in> count_space UNIV \\<rightarrow>\\<^sub>M prob_algebra borel\"", "lemma set_pmf_J: \"set_pmf (J x) = I x\"", "lemma in_space_S[simp]: \"x \\<in> space S\"", "lemma in_space_T[simp]: \"x \\<in> space T\"", "lemma in_space_lim_stream: \"\\<omega> \\<in> space (K.lim_stream x)\"", "lemma prob_space_K_lim: \"prob_space (K.lim_stream x)\"", "lemma select_firstD1: \"select_first x p y \\<Longrightarrow> y \\<in> I x\"", "lemma select_first_unique:\n  assumes y: \"select_first x p y1\" \" select_first x p y2\" shows \"y1 = y2\"", "lemma The_select_first[simp]: \"select_first x p y \\<Longrightarrow> The (select_first x p) = y\"", "lemma select_first_INF:\n  \"select_first x p y \\<Longrightarrow> (INF x\\<in>I x. p x) = p y\"", "lemma measurable_select_first[measurable]:\n  \"(\\<lambda>p. select_first x p y) \\<in> (\\<Pi>\\<^sub>M y\\<in>I x. borel) \\<rightarrow>\\<^sub>M count_space UNIV\"", "lemma measurable_THE_select_first[measurable]:\n  \"(\\<lambda>p. The (select_first x p)) \\<in> (\\<Pi>\\<^sub>M y\\<in>I x. borel) \\<rightarrow>\\<^sub>M count_space UNIV\"", "lemma sets_S_eq: \"sets S = sigma_sets UNIV { {t ..} \\<times> A | t A. A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s}) }\"", "lemma PAR_least:\n  assumes y: \"y \\<in> I x\"\n  shows \"PAR x {p\\<in>space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n     emeasure (exponential (escape_rate x)) {t ..} * ennreal (pmf (J x) y)\"", "lemma AE_PAR_least: \"AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y\"", "lemma K_alt: \"K (t, x) = distr (\\<Pi>\\<^sub>M y\\<in>I x. exponential (R x y)) S (\\<lambda>p. (t + (INF y\\<in>I x. p y), The (select_first x p)))\" (is \"_ = ?R\")", "lemma AE_K: \"AE y in K x. fst x < fst y \\<and> snd y \\<in> J (snd x)\"", "lemma AE_lim_stream:\n  \"AE \\<omega> in K.lim_stream x. \\<forall>i. snd ((x ## \\<omega>) !! i) \\<in> DTMC.acc``{snd x} \\<and> snd (\\<omega> !! i) \\<in> J (snd ((x ## \\<omega>) !! i)) \\<and> fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\"\n  (is \"AE \\<omega> in K.lim_stream x. \\<forall>i. ?P \\<omega> i\")", "lemma measurable_merge_at[measurable]: \"(\\<lambda>(\\<omega>, \\<omega>'). merge_at \\<omega> j \\<omega>') \\<in> (T \\<Otimes>\\<^sub>M T) \\<rightarrow>\\<^sub>M T\"", "lemma measurable_trace_at[measurable]: \"(\\<lambda>(s, \\<omega>). trace_at s \\<omega> j) \\<in> (count_space UNIV \\<Otimes>\\<^sub>M T) \\<rightarrow>\\<^sub>M count_space UNIV\"", "lemma measurable_trace_at': \"(\\<lambda>((s, j), \\<omega>). trace_at s \\<omega> j) \\<in> ((count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M T) \\<rightarrow>\\<^sub>M count_space UNIV\"", "lemma K_time_split:\n  assumes \"t \\<le> j\" and [measurable]: \"f \\<in> S \\<rightarrow>\\<^sub>M borel\"\n  shows \"(\\<integral>\\<^sup>+x. f x * indicator {j <..} (fst x) \\<partial>K (t, s)) = (\\<integral>\\<^sup>+x. f x \\<partial>K (j, s)) * exponential (escape_rate s) {j - t <..}\"", "lemma K_in_space[simp]: \"K x \\<in> space (prob_algebra S)\"", "lemma L_in_space[simp]: \"K.lim_stream x \\<in> space (prob_algebra T)\"", "lemma lim_time_split:\n  \"t \\<le> j \\<Longrightarrow> K.lim_stream (t, s) = do { \\<omega> \\<leftarrow> K.lim_stream (t, s) ; \\<omega>' \\<leftarrow> K.lim_stream (j, trace_at s \\<omega> j) ; return T (merge_at \\<omega> j \\<omega>')}\"\n    (is \"_ \\<Longrightarrow> _ = ?DO t s\")", "lemma K_eq: \"K (t, s) = distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M J s) S (\\<lambda>(t', s). (t + t', s))\"", "lemma K_shift: \"K (t + t', s) = distr (K (t, s)) S (\\<lambda>(t, s). (t + t', s))\"", "lemma K_not_empty: \"space (K x) \\<noteq> {}\"", "lemma lim_stream_not_empty: \"space (K.lim_stream x) \\<noteq> {}\"", "lemma lim_shift: \\<comment> \\<open>Generalize to bijective function on @{const K.lim_stream} invariant on @{const K}\\<close>\n  \"K.lim_stream (t + t', s) = distr (K.lim_stream (t, s)) T (smap (\\<lambda>(t, s). (t + t', s)))\"\n  (is \"_ = ?D t s\")", "lemma lim_0: \"K.lim_stream (t, s) = distr (K.lim_stream (0, s)) T (smap (\\<lambda>(t', s). (t' + t, s)))\"", "lemma ball_less_Suc_eq: \"(\\<forall>i<Suc n. P i) \\<longleftrightarrow> (P 0 \\<and> (\\<forall>i<n. P (Suc i)))\"", "lemma lim_stream_timediff_eq_exponential_1:\n  \"distr (K.lim_stream ts) (PiM UNIV (\\<lambda>_. borel))\n    (\\<lambda>\\<omega> i. escape_rate (snd ((ts##\\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((ts##\\<omega>) !! i))) =\n    PiM UNIV (\\<lambda>_. exponential 1)\"\n  (is \"?D = ?P\")", "lemma AE_explosion_infty:\n  assumes bdd: \"bdd_above (range escape_rate)\"\n  shows \"AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>\"", "lemma trace_in_simps[simp]:\n  \"trace_in ss t s (x##\\<omega>) = (if t < fst x then s \\<in> ss else trace_in ss t (snd x) \\<omega>)\"", "lemma trace_in_eq_lfp:\n  \"trace_in ss t = lfp (\\<lambda>F s. \\<lambda>(t', s')##\\<omega> \\<Rightarrow> if t < t' then s \\<in> ss else F s' \\<omega>)\"", "lemma trace_in_shiftD: \"trace_in ss t s \\<omega> \\<Longrightarrow> trace_in ss (t + t') s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>)\"", "lemma trace_in_shift[simp]: \"trace_in ss t s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) \\<longleftrightarrow> trace_in ss (t - t') s \\<omega>\"", "lemma measurable_trace_in':\n  \"Measurable.pred (borel \\<Otimes>\\<^sub>M count_space UNIV \\<Otimes>\\<^sub>M T) (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)\"\n    (is \"?M (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)\")", "lemma measurable_trace_in[measurable (raw)]:\n  assumes [measurable]: \"f \\<in> M \\<rightarrow>\\<^sub>M borel\" \"g \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV\" \"h \\<in> M \\<rightarrow>\\<^sub>M T\"\n  shows \"Measurable.pred M (\\<lambda>x. trace_in ss (f x) (g x) (h x))\"", "lemma p[measurable]: \"(\\<lambda>(s, t). p s s' t) \\<in> (count_space UNIV \\<Otimes>\\<^sub>M borel) \\<rightarrow>\\<^sub>M borel\"", "lemma p_nonpos: assumes \"t \\<le> 0\" shows \"p s s' t = of_bool (s = s')\"", "lemma p_0: \"p s s' 0 = of_bool (s = s')\"", "lemma in_sets_T[measurable (raw)]: \"Measurable.pred T P \\<Longrightarrow> {\\<omega>. P \\<omega>} \\<in> sets T\"", "lemma distr_id': \"sets M = sets N \\<Longrightarrow> distr M N (\\<lambda>x. x) = M\"", "lemma p_nonneg[simp]: \"0 \\<le> p s s' t\"", "lemma p_le_1[simp]: \"p s s' t \\<le> 1\"", "lemma p_eq:\n  assumes \"0 \\<le> t\"\n  shows \"p s s'' t = (of_bool (s = s'') + (LINT u:{0..t}|lborel. escape_rate s * exp (escape_rate s * u) * (LINT s'|J s. p s' s'' u))) / exp (t * escape_rate s)\"", "lemma continuous_on_p: \"continuous_on A (p s s')\"", "lemma p_vector_derivative: \\<comment> \\<open>Backward equation\\<close>\n  assumes \"0 \\<le> t\"\n  shows \"(p s s' has_vector_derivative (LINT s''|count_space UNIV. R s s'' * p s'' s' t) - escape_rate s * p s s' t)\n    (at t within {0..})\"\n    (is \"(_ has_vector_derivative ?A) _\")", "lemma wf_times_simp[simp]: \"wf_times t (x ## \\<omega>) \\<longleftrightarrow> t < fst x \\<and> wf_times (fst x) \\<omega>\"", "lemma trace_in_merge_at:\n  assumes \\<omega>': \"wf_times t' \\<omega>'\"\n  shows \"trace_in ss t x (merge_at \\<omega> t' \\<omega>') \\<longleftrightarrow>\n    (if t < t' then trace_in ss t x \\<omega> else \\<exists>y. trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>')\"\n    (is \"?merge \\<longleftrightarrow> ?cases\")", "lemma AE_lim_wf_times: \"AE \\<omega> in K.lim_stream (t, s). wf_times t \\<omega>\"", "lemma wf_times_shiftD: \"wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) \\<Longrightarrow> wf_times (t' - t) \\<omega>\"", "lemma wf_times_shift[simp]: \"wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) = wf_times (t' - t) \\<omega>\"", "lemma trace_in_unique: \"trace_in {y1} t x \\<omega> \\<Longrightarrow> trace_in {y2} t x \\<omega> \\<Longrightarrow> y1 = y2\"", "lemma trace_at_eq: \"trace_in {z} t x \\<omega> \\<Longrightarrow> trace_at x \\<omega> t = z\"", "lemma AE_lim_acc: \"AE \\<omega> in K.lim_stream (t, x). \\<forall>t z. trace_in {z} t x \\<omega> \\<longrightarrow> (x, z) \\<in> DTMC.acc\"", "lemma p_add:\n  assumes \"0 \\<le> t\" \"0 \\<le> t'\"\n  shows \"p x y (t + t') = (LINT z|count_space (DTMC.acc``{x}). p x z t * p z y t')\""], "translations": [["", "lemma trace_at_simp[simp]: \"trace_at s ((t', s')##\\<omega>) j = (if t' \\<le> j then trace_at s' \\<omega> j else s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_at s ((t', s') ## \\<omega>) j =\n    (if t' \\<le> j then trace_at s' \\<omega> j else s)", "by (subst trace_at.simps) simp"], ["", "lemma trace_at_eq:\n  \"trace_at s \\<omega> j = (case sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> of \\<infinity> \\<Rightarrow> undefined | enat i \\<Rightarrow> (s ## smap snd \\<omega>) !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_at s \\<omega> j =\n    (case sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> of\n     enat i \\<Rightarrow> (s ## smap snd \\<omega>) !! i)", "proof (split enat.split; safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat nat \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! nat\n 2. sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n    \\<infinity> \\<Longrightarrow>\n    trace_at s \\<omega> j = undefined", "assume \"sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = \\<infinity>\""], ["proof (state)\nthis:\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat nat \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! nat\n 2. sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n    \\<infinity> \\<Longrightarrow>\n    trace_at s \\<omega> j = undefined", "with sfirst_finite[of \"\\<lambda>x. j < fst (shd x)\" \\<omega>]"], ["proof (chain)\npicking this:\n  (sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> < \\<infinity>) =\n  ev (\\<lambda>x. j < fst (shd x)) \\<omega>\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = \\<infinity>", "have \"alw (\\<lambda>x. fst (shd x) \\<le> j) \\<omega>\""], ["proof (prove)\nusing this:\n  (sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> < \\<infinity>) =\n  ev (\\<lambda>x. j < fst (shd x)) \\<omega>\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = \\<infinity>\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>x. fst (shd x) \\<le> j) \\<omega>", "by (simp add: not_ev_iff not_less)"], ["proof (state)\nthis:\n  alw (\\<lambda>x. fst (shd x) \\<le> j) \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>nat.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat nat \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! nat\n 2. sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n    \\<infinity> \\<Longrightarrow>\n    trace_at s \\<omega> j = undefined", "then"], ["proof (chain)\npicking this:\n  alw (\\<lambda>x. fst (shd x) \\<le> j) \\<omega>", "show \"trace_at s \\<omega> j = undefined\""], ["proof (prove)\nusing this:\n  alw (\\<lambda>x. fst (shd x) \\<le> j) \\<omega>\n\ngoal (1 subgoal):\n 1. trace_at s \\<omega> j = undefined", "by (induction arbitrary: s \\<omega> rule: trace_at.fixp_induct) (auto split: stream.split)"], ["proof (state)\nthis:\n  trace_at s \\<omega> j = undefined\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat nat \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! nat", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat nat \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! nat", "show \"sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat n \\<Longrightarrow> trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat n \\<Longrightarrow>\n    trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n", "proof (induction n arbitrary: s \\<omega>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s \\<omega>.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat 0 \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! 0\n 2. \\<And>n s \\<omega>.\n       \\<lbrakk>\\<And>s \\<omega>.\n                   sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n                   enat n \\<Longrightarrow>\n                   trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n;\n        sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n        enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> trace_at s \\<omega> j =\n                         (s ## smap snd \\<omega>) !! Suc n", "case 0"], ["proof (state)\nthis:\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat 0\n\ngoal (2 subgoals):\n 1. \\<And>s \\<omega>.\n       sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n       enat 0 \\<Longrightarrow>\n       trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! 0\n 2. \\<And>n s \\<omega>.\n       \\<lbrakk>\\<And>s \\<omega>.\n                   sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n                   enat n \\<Longrightarrow>\n                   trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n;\n        sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n        enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> trace_at s \\<omega> j =\n                         (s ## smap snd \\<omega>) !! Suc n", "then"], ["proof (chain)\npicking this:\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat 0", "show ?case"], ["proof (prove)\nusing this:\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat 0\n\ngoal (1 subgoal):\n 1. trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! 0", "by (subst trace_at.simps) (auto simp add: enat_0 sfirst_eq_0 split: stream.split)"], ["proof (state)\nthis:\n  trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! 0\n\ngoal (1 subgoal):\n 1. \\<And>n s \\<omega>.\n       \\<lbrakk>\\<And>s \\<omega>.\n                   sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n                   enat n \\<Longrightarrow>\n                   trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n;\n        sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n        enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> trace_at s \\<omega> j =\n                         (s ## smap snd \\<omega>) !! Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n s \\<omega>.\n       \\<lbrakk>\\<And>s \\<omega>.\n                   sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n                   enat n \\<Longrightarrow>\n                   trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n;\n        sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n        enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> trace_at s \\<omega> j =\n                         (s ## smap snd \\<omega>) !! Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  sfirst (\\<lambda>x. j < fst (shd x)) ?\\<omega> = enat n \\<Longrightarrow>\n  trace_at ?s ?\\<omega> j = (?s ## smap snd ?\\<omega>) !! n\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n s \\<omega>.\n       \\<lbrakk>\\<And>s \\<omega>.\n                   sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n                   enat n \\<Longrightarrow>\n                   trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! n;\n        sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n        enat (Suc n)\\<rbrakk>\n       \\<Longrightarrow> trace_at s \\<omega> j =\n                         (s ## smap snd \\<omega>) !! Suc n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! Suc n", "using sfirst.simps[of \"\\<lambda>x. j < fst (shd x)\" \\<omega>] Suc.prems Suc.IH[of \"stl \\<omega>\" \"snd (shd \\<omega>)\"]"], ["proof (prove)\nusing this:\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> =\n  (if j < fst (shd \\<omega>) then 0\n   else eSuc (sfirst (\\<lambda>x. j < fst (shd x)) (stl \\<omega>)))\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat (Suc n)\n  sfirst (\\<lambda>x. j < fst (shd x)) (stl \\<omega>) =\n  enat n \\<Longrightarrow>\n  trace_at (snd (shd \\<omega>)) (stl \\<omega>) j =\n  (snd (shd \\<omega>) ## smap snd (stl \\<omega>)) !! n\n\ngoal (1 subgoal):\n 1. trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! Suc n", "by (cases \\<omega>) (auto simp add: eSuc_enat[symmetric] split: stream.split if_split_asm)"], ["proof (state)\nthis:\n  trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> = enat ?n \\<Longrightarrow>\n  trace_at s \\<omega> j = (s ## smap snd \\<omega>) !! ?n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trace_at_shift: \"trace_at s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) t = trace_at s \\<omega> (t - t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_at s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) t =\n    trace_at s \\<omega> (t - t')", "by (induction arbitrary: s \\<omega> rule: trace_at.fixp_induct) (auto split: stream.split)"], ["", "primcorec merge_at :: \"(real \\<times> 'a) stream \\<Rightarrow> real \\<Rightarrow> (real \\<times> 'a) stream \\<Rightarrow> (real \\<times> 'a) stream\"\nwhere\n  \"merge_at \\<omega> j \\<omega>' = (case \\<omega> of (t, s) ## \\<omega> \\<Rightarrow> if t \\<le> j then (t, s)##merge_at \\<omega> j \\<omega>' else \\<omega>')\""], ["", "lemma merge_at_simp[simp]: \"merge_at (x##\\<omega>) j \\<omega>' = (if fst x \\<le> j then x##merge_at \\<omega> j \\<omega>' else \\<omega>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_at (x ## \\<omega>) j \\<omega>' =\n    (if fst x \\<le> j then x ## merge_at \\<omega> j \\<omega>'\n     else \\<omega>')", "by (cases x) (subst merge_at.code; simp)"], ["", "subsection \\<open>Exponential Distribution\\<close>"], ["", "definition exponential :: \"real \\<Rightarrow> real measure\"\nwhere\n  \"exponential l = density lborel (exponential_density l)\""], ["", "lemma space_exponential: \"space (exponential l) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (exponential l) = UNIV", "by (simp add: exponential_def)"], ["", "lemma sets_exponential[measurable_cong]: \"sets (exponential l) = sets borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (exponential l) = sets borel", "by (simp add: exponential_def)"], ["", "lemma prob_space_exponential: \"0 < l \\<Longrightarrow> prob_space (exponential l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow> prob_space (exponential l)", "unfolding exponential_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow>\n    prob_space\n     (density lborel (\\<lambda>x. ennreal (exponential_density l x)))", "by (intro prob_space_exponential_density)"], ["", "lemma AE_exponential: \"0 < l \\<Longrightarrow> AE x in exponential l. 0 < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow> almost_everywhere (exponential l) ((<) 0)", "unfolding exponential_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow>\n    almost_everywhere\n     (density lborel (\\<lambda>x. ennreal (exponential_density l x)))\n     ((<) 0)", "using AE_lborel_singleton[of 0]"], ["proof (prove)\nusing this:\n  AE x in lborel. x \\<noteq> (0::?'a1)\n\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow>\n    almost_everywhere\n     (density lborel (\\<lambda>x. ennreal (exponential_density l x)))\n     ((<) 0)", "by (auto simp add: AE_density exponential_density_def)"], ["", "lemma emeasure_exponential_Ioi_cutoff:\n  assumes \"0 < l\"\n  shows \"emeasure (exponential l) {x <..} = exp (- (max 0 x) * l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "interpret prob_space \"exponential l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (exponential l)", "unfolding exponential_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (density lborel (\\<lambda>x. ennreal (exponential_density l x)))", "using \\<open>0<l\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. prob_space\n     (density lborel (\\<lambda>x. ennreal (exponential_density l x)))", "by (rule prob_space_exponential_density)"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "have *: \"prob {xa \\<in> space (exponential l). max 0 x < xa} = exp (- max 0 x * l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob {xa \\<in> space (exponential l). max 0 x < xa} =\n    exp (- max 0 x * l)", "apply (rule exponential_distributedD_gt[OF _ _ \\<open>0<l\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. distributed (exponential l) lborel (\\<lambda>x. x)\n     (\\<lambda>xa. ennreal (exponential_density l xa))\n 2. 0 \\<le> max 0 x", "apply (auto simp: exponential_def distributed_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (density lborel (\\<lambda>x. ennreal (exponential_density l x)))\n     lborel (\\<lambda>x. x) =\n    density lborel (\\<lambda>xa. ennreal (exponential_density l xa))", "apply (subst (6) distr_id[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (density lborel (\\<lambda>x. ennreal (exponential_density l x)))\n     lborel (\\<lambda>x. x) =\n    distr (density lborel (\\<lambda>xa. ennreal (exponential_density l xa)))\n     (density lborel (\\<lambda>xa. ennreal (exponential_density l xa)))\n     (\\<lambda>x. x)", "apply (subst (2) distr_cong)"], ["proof (prove)\ngoal (4 subgoals):\n 1. density lborel (\\<lambda>xa. ennreal (exponential_density l xa)) = ?K5\n 2. sets\n     (density lborel (\\<lambda>xa. ennreal (exponential_density l xa))) =\n    sets ?L5\n 3. \\<And>x.\n       x \\<in> space\n                (density lborel\n                  (\\<lambda>xa.\n                      ennreal (exponential_density l xa))) \\<Longrightarrow>\n       x = ?g5 x\n 4. distr (density lborel (\\<lambda>x. ennreal (exponential_density l x)))\n     lborel (\\<lambda>x. x) =\n    distr ?K5 ?L5 ?g5", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prob {xa \\<in> space (exponential l). max 0 x < xa} = exp (- max 0 x * l)\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "have \"emeasure (exponential l) {x <..} = emeasure (exponential l) {max 0 x <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = emeasure (exponential l) {max 0 x<..}", "using AE_exponential[OF \\<open>0<l\\<close>]"], ["proof (prove)\nusing this:\n  almost_everywhere (exponential l) ((<) 0)\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = emeasure (exponential l) {max 0 x<..}", "by (intro emeasure_eq_AE) auto"], ["proof (state)\nthis:\n  emeasure (exponential l) {x<..} = emeasure (exponential l) {max 0 x<..}\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "also"], ["proof (state)\nthis:\n  emeasure (exponential l) {x<..} = emeasure (exponential l) {max 0 x<..}\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "have \"\\<dots> = exp (- (max 0 x) * l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (exponential l) {max 0 x<..} = ennreal (exp (- max 0 x * l))", "using *"], ["proof (prove)\nusing this:\n  prob {xa \\<in> space (exponential l). max 0 x < xa} = exp (- max 0 x * l)\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {max 0 x<..} = ennreal (exp (- max 0 x * l))", "unfolding emeasure_eq_measure"], ["proof (prove)\nusing this:\n  prob {xa \\<in> space (exponential l). max 0 x < xa} = exp (- max 0 x * l)\n\ngoal (1 subgoal):\n 1. ennreal (prob {max 0 x<..}) = ennreal (exp (- max 0 x * l))", "by (simp add: space_exponential greaterThan_def)"], ["proof (state)\nthis:\n  emeasure (exponential l) {max 0 x<..} = ennreal (exp (- max 0 x * l))\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "finally"], ["proof (chain)\npicking this:\n  emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))", "."], ["proof (state)\nthis:\n  emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emeasure_exponential_Ioi:\n  \"0 < l \\<Longrightarrow> 0 \\<le> x \\<Longrightarrow> emeasure (exponential l) {x <..} = exp (- x * l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; 0 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> emeasure (exponential l) {x<..} =\n                      ennreal (exp (- x * l))", "using emeasure_exponential_Ioi_cutoff[of l x]"], ["proof (prove)\nusing this:\n  0 < l \\<Longrightarrow>\n  emeasure (exponential l) {x<..} = ennreal (exp (- max 0 x * l))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < l; 0 \\<le> x\\<rbrakk>\n    \\<Longrightarrow> emeasure (exponential l) {x<..} =\n                      ennreal (exp (- x * l))", "by simp"], ["", "lemma exponential_eq_stretch:\n  assumes \"0 < l\"\n  shows \"exponential l = distr (exponential 1) borel (\\<lambda>x. (1/l) * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exponential l = distr (exponential 1) borel ((*) (1 / l))", "proof (intro measure_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "fix A"], ["proof (state)\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "assume \"A \\<in> sets (exponential l)\""], ["proof (state)\nthis:\n  A \\<in> sets (exponential l)\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "then"], ["proof (chain)\npicking this:\n  A \\<in> sets (exponential l)", "have [measurable]: \"A \\<in> sets borel\""], ["proof (prove)\nusing this:\n  A \\<in> sets (exponential l)\n\ngoal (1 subgoal):\n 1. A \\<in> sets borel", "by (simp add: sets_exponential)"], ["proof (state)\nthis:\n  A \\<in> sets borel\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "then"], ["proof (chain)\npicking this:\n  A \\<in> sets borel", "have [measurable]: \"(\\<lambda>x. x / l) -` A \\<in> sets borel\""], ["proof (prove)\nusing this:\n  A \\<in> sets borel\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x / l) -` A \\<in> sets borel", "by (rule measurable_sets_borel[rotated]) simp"], ["proof (state)\nthis:\n  (\\<lambda>x. x / l) -` A \\<in> sets borel\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "have \"emeasure (exponential l) A =\n    (\\<integral>\\<^sup>+x. ennreal l * (indicator (((*) (1/l) -` A) \\<inter> {0 ..}) (l * x) * ennreal (exp (- (l * x)))) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (exponential l) A =\n    \\<integral>\\<^sup>+ x. ennreal l *\n                           (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                             (l * x) *\n                            ennreal (exp (- (l * x))))\n                       \\<partial>lborel", "using \\<open>0 < l\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) A =\n    \\<integral>\\<^sup>+ x. ennreal l *\n                           (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                             (l * x) *\n                            ennreal (exp (- (l * x))))\n                       \\<partial>lborel", "by (auto simp: ac_simps emeasure_distr exponential_def emeasure_density exponential_density_def\n                   ennreal_mult zero_le_mult_iff\n             intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  emeasure (exponential l) A =\n  \\<integral>\\<^sup>+ x. ennreal l *\n                         (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                           (l * x) *\n                          ennreal (exp (- (l * x))))\n                     \\<partial>lborel\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "also"], ["proof (state)\nthis:\n  emeasure (exponential l) A =\n  \\<integral>\\<^sup>+ x. ennreal l *\n                         (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                           (l * x) *\n                          ennreal (exp (- (l * x))))\n                     \\<partial>lborel\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "have \"\\<dots> = (\\<integral>\\<^sup>+x. indicator (((*) (1/l) -` A) \\<inter> {0 ..}) x * ennreal (exp (- x)) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal l *\n                           (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                             (l * x) *\n                            ennreal (exp (- (l * x))))\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                           ennreal (exp (- x))\n                       \\<partial>lborel", "using \\<open>0<l\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal l *\n                           (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                             (l * x) *\n                            ennreal (exp (- (l * x))))\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                           ennreal (exp (- x))\n                       \\<partial>lborel", "apply (subst nn_integral_stretch)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 < l \\<Longrightarrow>\n    (\\<lambda>a.\n        ennreal l *\n        (indicator ((*) (1 / l) -` A \\<inter> {0..}) a *\n         ennreal (exp (- a))))\n    \\<in> borel_measurable borel\n 2. 0 < l \\<Longrightarrow> l \\<noteq> 0\n 3. 0 < l \\<Longrightarrow>\n    ennreal (1 / \\<bar>l\\<bar>) *\n    \\<integral>\\<^sup>+ x. ennreal l *\n                           (indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                            ennreal (exp (- x)))\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                           ennreal (exp (- x))\n                       \\<partial>lborel", "apply (auto simp: nn_integral_cmult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < l \\<Longrightarrow>\n    ennreal (1 / l) *\n    (ennreal l *\n     \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                            ennreal (exp (- x))\n                        \\<partial>lborel) =\n    \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                           ennreal (exp (- x))\n                       \\<partial>lborel", "apply (simp add: ennreal_mult[symmetric] mult.assoc[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal l *\n                         (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                           (l * x) *\n                          ennreal (exp (- (l * x))))\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                         ennreal (exp (- x))\n                     \\<partial>lborel\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal l *\n                         (indicator ((*) (1 / l) -` A \\<inter> {0..})\n                           (l * x) *\n                          ennreal (exp (- (l * x))))\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                         ennreal (exp (- x))\n                     \\<partial>lborel\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "have \"\\<dots> = emeasure (distr (exponential 1) borel (\\<lambda>x. (1/l) * x)) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                           ennreal (exp (- x))\n                       \\<partial>lborel =\n    emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "by (auto simp add: emeasure_distr exponential_def emeasure_density exponential_density_def\n        intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. indicator ((*) (1 / l) -` A \\<inter> {0..}) x *\n                         ennreal (exp (- x))\n                     \\<partial>lborel =\n  emeasure (distr (exponential 1) borel ((*) (1 / l))) A\n\ngoal (2 subgoals):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))\n 2. \\<And>A.\n       A \\<in> sets (exponential l) \\<Longrightarrow>\n       emeasure (exponential l) A =\n       emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "finally"], ["proof (chain)\npicking this:\n  emeasure (exponential l) A =\n  emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "show \"emeasure (exponential l) A = emeasure (distr (exponential 1) borel (\\<lambda>x. (1/l) * x)) A\""], ["proof (prove)\nusing this:\n  emeasure (exponential l) A =\n  emeasure (distr (exponential 1) borel ((*) (1 / l))) A\n\ngoal (1 subgoal):\n 1. emeasure (exponential l) A =\n    emeasure (distr (exponential 1) borel ((*) (1 / l))) A", "."], ["proof (state)\nthis:\n  emeasure (exponential l) A =\n  emeasure (distr (exponential 1) borel ((*) (1 / l))) A\n\ngoal (1 subgoal):\n 1. sets (exponential l) = sets (distr (exponential 1) borel ((*) (1 / l)))", "qed (simp add: sets_exponential)"], ["", "lemma uniform_measure_exponential:\n  assumes \"0 < l\" \"0 \\<le> t\"\n  shows \"uniform_measure (exponential l) {t <..} = distr (exponential l) borel ((+) t)\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. uniform_measure (exponential l) {t<..} =\n    distr (exponential l) borel ((+) t)", "proof (rule measure_eqI_lessThan)"], ["proof (state)\ngoal (4 subgoals):\n 1. sets (uniform_measure (exponential l) {t<..}) = sets borel\n 2. sets (distr (exponential l) borel ((+) t)) = sets borel\n 3. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..}\n       < \\<infinity>\n 4. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n       emeasure (distr (exponential l) borel ((+) t)) {x<..}", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. sets (uniform_measure (exponential l) {t<..}) = sets borel\n 2. sets (distr (exponential l) borel ((+) t)) = sets borel\n 3. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..}\n       < \\<infinity>\n 4. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n       emeasure (distr (exponential l) borel ((+) t)) {x<..}", "have \"0 < emeasure (exponential l) {t<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < emeasure (exponential l) {t<..}", "unfolding emeasure_exponential_Ioi[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < ennreal (exp (- t * l))", "by simp"], ["proof (state)\nthis:\n  0 < emeasure (exponential l) {t<..}\n\ngoal (4 subgoals):\n 1. sets (uniform_measure (exponential l) {t<..}) = sets borel\n 2. sets (distr (exponential l) borel ((+) t)) = sets borel\n 3. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..}\n       < \\<infinity>\n 4. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n       emeasure (distr (exponential l) borel ((+) t)) {x<..}", "with assms"], ["proof (chain)\npicking this:\n  0 < l\n  0 \\<le> t\n  0 < emeasure (exponential l) {t<..}", "show \"?L {x<..} < \\<infinity>\""], ["proof (prove)\nusing this:\n  0 < l\n  0 \\<le> t\n  0 < emeasure (exponential l) {t<..}\n\ngoal (1 subgoal):\n 1. emeasure (uniform_measure (exponential l) {t<..}) {x<..} < \\<infinity>", "by (simp add: ennreal_divide_eq_top_iff less_top[symmetric] lessThan_Int_lessThan\n      emeasure_exponential_Ioi)"], ["proof (state)\nthis:\n  emeasure (uniform_measure (exponential l) {t<..}) {x<..} < \\<infinity>\n\ngoal (3 subgoals):\n 1. sets (uniform_measure (exponential l) {t<..}) = sets borel\n 2. sets (distr (exponential l) borel ((+) t)) = sets borel\n 3. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n       emeasure (distr (exponential l) borel ((+) t)) {x<..}", "have *: \"((+) t -` {x<..} \\<inter> space (exponential l)) = {x - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) t -` {x<..} \\<inter> space (exponential l) = {x - t<..}", "by (auto simp: space_exponential)"], ["proof (state)\nthis:\n  (+) t -` {x<..} \\<inter> space (exponential l) = {x - t<..}\n\ngoal (3 subgoals):\n 1. sets (uniform_measure (exponential l) {t<..}) = sets borel\n 2. sets (distr (exponential l) borel ((+) t)) = sets borel\n 3. \\<And>x.\n       emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n       emeasure (distr (exponential l) borel ((+) t)) {x<..}", "show \"?L {x<..} = ?R {x<..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n    emeasure (distr (exponential l) borel ((+) t)) {x<..}", "using assms"], ["proof (prove)\nusing this:\n  0 < l\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n    emeasure (distr (exponential l) borel ((+) t)) {x<..}", "by (simp add: lessThan_Int_lessThan emeasure_exponential_Ioi divide_ennreal\n      emeasure_distr * emeasure_exponential_Ioi_cutoff exp_diff[symmetric] field_simps split: split_max)"], ["proof (state)\nthis:\n  emeasure (uniform_measure (exponential l) {t<..}) {x<..} =\n  emeasure (distr (exponential l) borel ((+) t)) {x<..}\n\ngoal (2 subgoals):\n 1. sets (uniform_measure (exponential l) {t<..}) = sets borel\n 2. sets (distr (exponential l) borel ((+) t)) = sets borel", "qed (auto simp: sets_exponential)"], ["", "lemma emeasure_PiM_exponential_Ioi_finite:\n  assumes \"J \\<subseteq> I\" \"finite J\" \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 < R i\" \"0 \\<le> x\"\n  shows \"emeasure (\\<Pi>\\<^sub>M i\\<in>I. exponential (R i)) (prod_emb I (\\<lambda>i. exponential (R i)) J (\\<Pi>\\<^sub>E j\\<in>J. {x<..})) = exp (- x * (\\<Sum>i\\<in>J. R i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * sum R J))", "proof (subst emeasure_PiM_emb)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> prob_space (exponential (R i))\n 2. J \\<subseteq> I\n 3. finite J\n 4. \\<And>i.\n       i \\<in> J \\<Longrightarrow> {x<..} \\<in> sets (exponential (R i))\n 5. (\\<Prod>i\\<in>J. emeasure (exponential (R i)) {x<..}) =\n    ennreal (exp (- x * sum R J))", "from assms"], ["proof (chain)\npicking this:\n  J \\<subseteq> I\n  finite J\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x", "show \"(\\<Prod>i\\<in>J. emeasure (exponential (R i)) {x<..}) = ennreal (exp (- x * sum R J))\""], ["proof (prove)\nusing this:\n  J \\<subseteq> I\n  finite J\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>J. emeasure (exponential (R i)) {x<..}) =\n    ennreal (exp (- x * sum R J))", "by (subst prod.cong[OF refl emeasure_exponential_Ioi])\n       (auto simp add: prod_ennreal exp_sum sum_negf[symmetric] sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>J. emeasure (exponential (R i)) {x<..}) =\n  ennreal (exp (- x * sum R J))\n\ngoal (4 subgoals):\n 1. \\<And>i. i \\<in> I \\<Longrightarrow> prob_space (exponential (R i))\n 2. J \\<subseteq> I\n 3. finite J\n 4. \\<And>i.\n       i \\<in> J \\<Longrightarrow> {x<..} \\<in> sets (exponential (R i))", "qed (insert assms, auto intro!: prob_space_exponential)"], ["", "lemma emeasure_PiM_exponential_Ioi_sequence:\n  assumes R: \"summable R\" \"\\<And>i. 0 < R i\" \"0 \\<le> x\"\n  shows \"emeasure (\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R i)) (\\<Pi> i\\<in>UNIV. {x<..}) = exp (- x * suminf R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "let ?R = \"\\<lambda>i. exponential (R i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "let ?P = \"\\<Pi>\\<^sub>M i\\<in>UNIV. ?R i\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "let ?N = \"\\<lambda>n::nat. prod_emb UNIV ?R {..<n} (\\<Pi>\\<^sub>E i\\<in>{..<n}. {x<..})\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "interpret prob_space ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))", "by (intro prob_space_PiM prob_space_exponential R)"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "have \"(\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R i)) (\\<Inter>n. ?N n) = (INF n. (\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R i)) (?N n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (\\<Inter>n.\n         prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n          ({..<n} \\<rightarrow>\\<^sub>E {x<..})) =\n    (\\<Sqinter>n.\n        emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n         (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n           ({..<n} \\<rightarrow>\\<^sub>E {x<..})))", "by (intro INF_emeasure_decseq[symmetric] decseq_emb_PiE) (auto simp: incseq_def)"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n   (\\<Inter>n.\n       prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n        ({..<n} \\<rightarrow>\\<^sub>E {x<..})) =\n  (\\<Sqinter>n.\n      emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n       (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n         ({..<n} \\<rightarrow>\\<^sub>E {x<..})))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "also"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n   (\\<Inter>n.\n       prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n        ({..<n} \\<rightarrow>\\<^sub>E {x<..})) =\n  (\\<Sqinter>n.\n      emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n       (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n         ({..<n} \\<rightarrow>\\<^sub>E {x<..})))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "have \"\\<dots> = (INF n. ennreal (exp (- x * (\\<Sum>i<n. R i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n.\n        emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n         (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n           ({..<n} \\<rightarrow>\\<^sub>E {x<..}))) =\n    (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n})))", "using R"], ["proof (prove)\nusing this:\n  summable R\n  0 < R ?i\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n.\n        emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n         (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n           ({..<n} \\<rightarrow>\\<^sub>E {x<..}))) =\n    (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n})))", "by (intro INF_cong emeasure_PiM_exponential_Ioi_finite) auto"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n       (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n         ({..<n} \\<rightarrow>\\<^sub>E {x<..}))) =\n  (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n})))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n       (prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n         ({..<n} \\<rightarrow>\\<^sub>E {x<..}))) =\n  (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n})))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "have \"\\<dots> = ennreal (exp (- x * (SUP n. (\\<Sum>i<n. R i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n}))) =\n    ennreal (exp (- x * (\\<Squnion>n. sum R {..<n})))", "using R"], ["proof (prove)\nusing this:\n  summable R\n  0 < R ?i\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n}))) =\n    ennreal (exp (- x * (\\<Squnion>n. sum R {..<n})))", "by (subst continuous_at_Sup_antimono[where f=\"\\<lambda>r. ennreal (exp (- x * r))\"])\n       (auto intro!: bdd_aboveI2[where M=\"\\<Sum>i. R i\"] sum_le_suminf summable_mult mult_left_mono\n                     continuous_mult continuous_at_ennreal continuous_within_exp[THEN continuous_within_compose3] continuous_minus\n             simp: less_imp_le antimono_def image_comp)"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n}))) =\n  ennreal (exp (- x * (\\<Squnion>n. sum R {..<n})))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (exp (- x * sum R {..<n}))) =\n  ennreal (exp (- x * (\\<Squnion>n. sum R {..<n})))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "have \"\\<dots> = ennreal (exp (- x * (\\<Sum>i. R i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (exp (- x * (\\<Squnion>n. sum R {..<n}))) =\n    ennreal (exp (- x * (\\<Sum>i. R i)))", "using R"], ["proof (prove)\nusing this:\n  summable R\n  0 < R ?i\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. ennreal (exp (- x * (\\<Squnion>n. sum R {..<n}))) =\n    ennreal (exp (- x * (\\<Sum>i. R i)))", "by (subst suminf_eq_SUP_real) (auto simp: less_imp_le)"], ["proof (state)\nthis:\n  ennreal (exp (- x * (\\<Squnion>n. sum R {..<n}))) =\n  ennreal (exp (- x * (\\<Sum>i. R i)))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "also"], ["proof (state)\nthis:\n  ennreal (exp (- x * (\\<Squnion>n. sum R {..<n}))) =\n  ennreal (exp (- x * (\\<Sum>i. R i)))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "have \"(\\<Inter>n. ?N n) = (\\<Pi> i\\<in>UNIV. {x<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>n.\n        prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n         ({..<n} \\<rightarrow>\\<^sub>E {x<..})) =\n    UNIV \\<rightarrow> {x<..}", "by (fastforce simp: prod_emb_def Pi_iff PiE_iff space_exponential)"], ["proof (state)\nthis:\n  (\\<Inter>n.\n      prod_emb UNIV (\\<lambda>i. exponential (R i)) {..<n}\n       ({..<n} \\<rightarrow>\\<^sub>E {x<..})) =\n  UNIV \\<rightarrow> {x<..}\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "finally"], ["proof (chain)\npicking this:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n   (UNIV \\<rightarrow> {x<..}) =\n  ennreal (exp (- x * (\\<Sum>i. R i)))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n   (UNIV \\<rightarrow> {x<..}) =\n  ennreal (exp (- x * (\\<Sum>i. R i)))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "using R"], ["proof (prove)\nusing this:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n   (UNIV \\<rightarrow> {x<..}) =\n  ennreal (exp (- x * (\\<Sum>i. R i)))\n  summable R\n  0 < R ?i\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * suminf R))", "by simp"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R i)))\n   (UNIV \\<rightarrow> {x<..}) =\n  ennreal (exp (- x * suminf R))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emeasure_PiM_exponential_Ioi_countable:\n  assumes R: \"J \\<subseteq> I\" \"countable J\" \"\\<And>i. i \\<in> I \\<Longrightarrow> 0 < R i\" \"0 \\<le> x\" and finite: \"integrable (count_space J) R\"\n  shows \"emeasure (\\<Pi>\\<^sub>M i\\<in>I. exponential (R i)) (prod_emb I (\\<lambda>i. exponential (R i)) J (\\<Pi>\\<^sub>E j\\<in>J. {x<..})) =\n    exp (- x * (LINT i|count_space J. R i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "assume \"finite J\""], ["proof (state)\nthis:\n  finite J\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "with assms"], ["proof (chain)\npicking this:\n  J \\<subseteq> I\n  countable J\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x\n  integrable (count_space J) R\n  finite J", "show ?thesis"], ["proof (prove)\nusing this:\n  J \\<subseteq> I\n  countable J\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x\n  integrable (count_space J) R\n  finite J\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "by (subst emeasure_PiM_exponential_Ioi_finite)\n       (auto simp: lebesgue_integral_count_space_finite)"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   (prod_emb I (\\<lambda>i. exponential (R i)) J\n     (J \\<rightarrow>\\<^sub>E {x<..})) =\n  ennreal (exp (- x * integral\\<^sup>L (count_space J) R))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "assume \"infinite J\""], ["proof (state)\nthis:\n  infinite J\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "let ?R = \"\\<lambda>i. exponential (R i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "let ?P = \"\\<Pi>\\<^sub>M i\\<in>I. ?R i\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "define f where \"f = from_nat_into J\""], ["proof (state)\nthis:\n  f = from_nat_into J\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have J_eq: \"J = range f\" and f: \"inj f\" \"f \\<in> UNIV \\<rightarrow> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J = range f &&& inj f &&& f \\<in> UNIV \\<rightarrow> I", "using from_nat_into_inj_infinite[of J] range_from_nat_into[of J] \\<open>countable J\\<close> \\<open>infinite J\\<close> \\<open>J \\<subseteq> I\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>countable J; infinite J\\<rbrakk>\n  \\<Longrightarrow> (from_nat_into J ?m = from_nat_into J ?n) = (?m = ?n)\n  \\<lbrakk>J \\<noteq> {}; countable J\\<rbrakk>\n  \\<Longrightarrow> range (from_nat_into J) = J\n  countable J\n  infinite J\n  J \\<subseteq> I\n\ngoal (1 subgoal):\n 1. J = range f &&& inj f &&& f \\<in> UNIV \\<rightarrow> I", "by (auto simp: inj_on_def f_def simp del: range_from_nat_into)"], ["proof (state)\nthis:\n  J = range f\n  inj f\n  f \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have Bf: \"bij_betw f UNIV J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f UNIV J", "unfolding J_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw f UNIV (range f)", "using inj_on_imp_bij_betw[OF f(1)]"], ["proof (prove)\nusing this:\n  bij_betw f UNIV (range f)\n\ngoal (1 subgoal):\n 1. bij_betw f UNIV (range f)", "."], ["proof (state)\nthis:\n  bij_betw f UNIV J\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have summable_R: \"summable (\\<lambda>i. R (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. R (f i))", "using finite"], ["proof (prove)\nusing this:\n  integrable (count_space J) R\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. R (f i))", "unfolding integrable_bij_count_space[OF Bf, symmetric] integrable_count_space_nat_iff"], ["proof (prove)\nusing this:\n  summable (\\<lambda>x. norm (R (f x)))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. R (f i))", "by (rule summable_norm_cancel)"], ["proof (state)\nthis:\n  summable (\\<lambda>i. R (f i))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have \"emeasure (\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R (f i))) (\\<Pi> i\\<in>UNIV. {x<..}) = exp (- x * (\\<Sum>i. R (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * (\\<Sum>i. R (f i))))", "using finite assms"], ["proof (prove)\nusing this:\n  integrable (count_space J) R\n  J \\<subseteq> I\n  countable J\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x\n  integrable (count_space J) R\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * (\\<Sum>i. R (f i))))", "unfolding J_eq"], ["proof (prove)\nusing this:\n  integrable (count_space (range f)) R\n  range f \\<subseteq> I\n  countable (range f)\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x\n  integrable (count_space (range f)) R\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (UNIV \\<rightarrow> {x<..}) =\n    ennreal (exp (- x * (\\<Sum>i. R (f i))))", "by (intro emeasure_PiM_exponential_Ioi_sequence[OF summable_R]) auto"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n   (UNIV \\<rightarrow> {x<..}) =\n  ennreal (exp (- x * (\\<Sum>i. R (f i))))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "also"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n   (UNIV \\<rightarrow> {x<..}) =\n  ennreal (exp (- x * (\\<Sum>i. R (f i))))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have \"(\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R (f i))) = distr ?P (\\<Pi>\\<^sub>M i\\<in>UNIV. exponential (R (f i))) (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))) =\n    distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i))", "using R"], ["proof (prove)\nusing this:\n  J \\<subseteq> I\n  countable J\n  ?i \\<in> I \\<Longrightarrow> 0 < R ?i\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))) =\n    distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i))", "by (intro distr_PiM_reindex[symmetric, OF _ f] prob_space_exponential) auto"], ["proof (state)\nthis:\n  Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))) =\n  distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n   (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "also"], ["proof (state)\nthis:\n  Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))) =\n  distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n   (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have \"\\<dots> (\\<Pi> i\\<in>UNIV. {x<..}) = ?P ((\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -` (\\<Pi> i\\<in>UNIV. {x<..}) \\<inter> space ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n       (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n       (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     ((\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n      (UNIV \\<rightarrow> {x<..}) \\<inter>\n      space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))))", "using f(2)"], ["proof (prove)\nusing this:\n  f \\<in> UNIV \\<rightarrow> I\n\ngoal (1 subgoal):\n 1. emeasure\n     (distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n       (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n       (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)))\n     (UNIV \\<rightarrow> {x<..}) =\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     ((\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n      (UNIV \\<rightarrow> {x<..}) \\<inter>\n      space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))))", "by (intro emeasure_distr infprod_in_sets) (auto simp: Pi_iff)"], ["proof (state)\nthis:\n  emeasure\n   (distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)))\n   (UNIV \\<rightarrow> {x<..}) =\n  emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   ((\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n    (UNIV \\<rightarrow> {x<..}) \\<inter>\n    space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "also"], ["proof (state)\nthis:\n  emeasure\n   (distr (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (Pi\\<^sub>M UNIV (\\<lambda>i. exponential (R (f i))))\n     (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)))\n   (UNIV \\<rightarrow> {x<..}) =\n  emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   ((\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n    (UNIV \\<rightarrow> {x<..}) \\<inter>\n    space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))))\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have \"(\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -` (\\<Pi> i\\<in>UNIV. {x<..}) \\<inter> space ?P = prod_emb I ?R J (\\<Pi>\\<^sub>E j\\<in>J. {x<..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n    (UNIV \\<rightarrow> {x<..}) \\<inter>\n    space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))) =\n    prod_emb I (\\<lambda>i. exponential (R i)) J\n     (J \\<rightarrow>\\<^sub>E {x<..})", "by (auto simp: prod_emb_def space_PiM space_exponential Pi_iff J_eq)"], ["proof (state)\nthis:\n  (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n  (UNIV \\<rightarrow> {x<..}) \\<inter>\n  space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))) =\n  prod_emb I (\\<lambda>i. exponential (R i)) J\n   (J \\<rightarrow>\\<^sub>E {x<..})\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "also"], ["proof (state)\nthis:\n  (\\<lambda>\\<omega>. \\<lambda>i\\<in>UNIV. \\<omega> (f i)) -`\n  (UNIV \\<rightarrow> {x<..}) \\<inter>\n  space (Pi\\<^sub>M I (\\<lambda>i. exponential (R i))) =\n  prod_emb I (\\<lambda>i. exponential (R i)) J\n   (J \\<rightarrow>\\<^sub>E {x<..})\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "have \"(\\<Sum>i. R (f i)) = (LINT i|count_space J. R i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. R (f i)) = integral\\<^sup>L (count_space J) R", "using finite"], ["proof (prove)\nusing this:\n  integrable (count_space J) R\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. R (f i)) = integral\\<^sup>L (count_space J) R", "by (subst integral_count_space_nat[symmetric])\n       (auto simp: integrable_bij_count_space[OF Bf] integral_bij_count_space[OF Bf])"], ["proof (state)\nthis:\n  (\\<Sum>i. R (f i)) = integral\\<^sup>L (count_space J) R\n\ngoal (1 subgoal):\n 1. infinite J \\<Longrightarrow>\n    emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "finally"], ["proof (chain)\npicking this:\n  emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   (prod_emb I (\\<lambda>i. exponential (R i)) J\n     (J \\<rightarrow>\\<^sub>E {x<..})) =\n  ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   (prod_emb I (\\<lambda>i. exponential (R i)) J\n     (J \\<rightarrow>\\<^sub>E {x<..})) =\n  ennreal (exp (- x * integral\\<^sup>L (count_space J) R))\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n     (prod_emb I (\\<lambda>i. exponential (R i)) J\n       (J \\<rightarrow>\\<^sub>E {x<..})) =\n    ennreal (exp (- x * integral\\<^sup>L (count_space J) R))", "."], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M I (\\<lambda>i. exponential (R i)))\n   (prod_emb I (\\<lambda>i. exponential (R i)) J\n     (J \\<rightarrow>\\<^sub>E {x<..})) =\n  ennreal (exp (- x * integral\\<^sup>L (count_space J) R))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_PiM_exponential_suminf_infty:\n  fixes R :: \"nat \\<Rightarrow> real\"\n  assumes R: \"\\<And>n. 0 < R n\" and finite: \"(\\<Sum>n. ennreal (1 / R n)) = top\"\n  shows \"AE \\<omega> in \\<Pi>\\<^sub>M n\\<in>UNIV. exponential (R n). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "let ?P = \"\\<Pi>\\<^sub>M n\\<in>UNIV. exponential (R n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "interpret prob_space \"exponential (R n)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (exponential (R n))", "by (intro prob_space_exponential R)"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "interpret product_prob_space \"\\<lambda>n. exponential (R n)\" UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_prob_space (\\<lambda>n. exponential (R n))", "proof"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have AE_pos: \"AE \\<omega> in ?P. \\<forall>i. 0 < \\<omega> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential (R n)). \\<forall>i. 0 < \\<omega> i", "unfolding AE_all_countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       AE \\<omega> in Pi\\<^sub>M UNIV\n                       (\\<lambda>n. exponential (R n)). 0 < \\<omega> i", "by (intro AE_PiM_component allI prob_space_exponential R AE_exponential) simp"], ["proof (state)\nthis:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential (R n)). \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have indep: \"indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P.indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) UNIV", "using PiM_component"], ["proof (prove)\nusing this:\n  ?i \\<in> UNIV \\<Longrightarrow>\n  distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n   (exponential (R ?i)) (\\<lambda>\\<omega>. \\<omega> ?i) =\n  exponential (R ?i)\n\ngoal (1 subgoal):\n 1. P.indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) UNIV", "apply (subst P.indep_vars_iff_distr_eq_PiM)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>i.\n        i \\<in> UNIV \\<Longrightarrow>\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    UNIV \\<noteq> {}\n 2. \\<And>i.\n       (\\<And>i.\n           i \\<in> UNIV \\<Longrightarrow>\n           distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n            (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n           exponential (R i)) \\<Longrightarrow>\n       P.random_variable borel (\\<lambda>x. x i)\n 3. (\\<And>i.\n        i \\<in> UNIV \\<Longrightarrow>\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n     (Pi\\<^sub>M UNIV (\\<lambda>i. borel)) (\\<lambda>x. restrict x UNIV) =\n    Pi\\<^sub>M UNIV\n     (\\<lambda>i.\n         distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n))) borel\n          (\\<lambda>x. x i))", "apply (auto simp: restrict_UNIV distr_id2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n     (Pi\\<^sub>M UNIV (\\<lambda>i. borel)) (\\<lambda>x. x) =\n    Pi\\<^sub>M UNIV\n     (\\<lambda>i.\n         distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n))) borel\n          (\\<lambda>x. x i))", "apply (subst distr_id2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>i.\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    sets (Pi\\<^sub>M UNIV (\\<lambda>i. borel)) = P.events\n 2. (\\<And>i.\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)) =\n    Pi\\<^sub>M UNIV\n     (\\<lambda>i.\n         distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n))) borel\n          (\\<lambda>x. x i))", "apply (intro sets_PiM_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<And>i.\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    UNIV = UNIV\n 2. \\<And>i.\n       \\<lbrakk>\\<And>i.\n                   distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n                    (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n                   exponential (R i);\n        i \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> sets borel = ??.local.events i\n 3. (\\<And>i.\n        distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)))\n         (exponential (R i)) (\\<lambda>\\<omega>. \\<omega> i) =\n        exponential (R i)) \\<Longrightarrow>\n    Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n)) =\n    Pi\\<^sub>M UNIV\n     (\\<lambda>i.\n         distr (Pi\\<^sub>M UNIV (\\<lambda>n. exponential (R n))) borel\n          (\\<lambda>x. x i))", "apply (auto simp: sets_exponential cong: distr_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P.indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) UNIV\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have [simp]: \"0 \\<le> x + x * R i \\<longleftrightarrow> 0 \\<le> x\" for x i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> x + x * R i) = (0 \\<le> x)", "using zero_le_mult_iff[of x \"1 + R i\"] R[of i]"], ["proof (prove)\nusing this:\n  (0 \\<le> x * (1 + R i)) =\n  (0 \\<le> x \\<and> 0 \\<le> 1 + R i \\<or> x \\<le> 0 \\<and> 1 + R i \\<le> 0)\n  0 < R i\n\ngoal (1 subgoal):\n 1. (0 \\<le> x + x * R i) = (0 \\<le> x)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (0 \\<le> ?x1 + ?x1 * R ?i1) = (0 \\<le> ?x1)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"(\\<integral>\\<^sup>+\\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n)) \\<partial>?P) = (\\<integral>\\<^sup>+\\<omega>. (INF n. \\<Prod>i<n. eexp (- ereal (\\<omega> i))) \\<partial>?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                       \\<partial>Pi\\<^sub>M UNIV\n                                  (\\<lambda>n. exponential (R n)) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sqinter>n.\n                             \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                       \\<partial>Pi\\<^sub>M UNIV\n                                  (\\<lambda>n. exponential (R n))", "proof (intro nn_integral_cong_AE, use AE_pos in eventually_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i. 0 < x i \\<Longrightarrow>\n       eexp (\\<Sum>n. - ereal (x n)) =\n       (\\<Sqinter>n. \\<Prod>i<n. eexp (- ereal (x i)))", "fix \\<omega> :: \"nat \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i. 0 < x i \\<Longrightarrow>\n       eexp (\\<Sum>n. - ereal (x n)) =\n       (\\<Sqinter>n. \\<Prod>i<n. eexp (- ereal (x i)))", "assume \\<omega>: \"\\<forall>i. 0 < \\<omega> i\""], ["proof (state)\nthis:\n  \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>i. 0 < x i \\<Longrightarrow>\n       eexp (\\<Sum>n. - ereal (x n)) =\n       (\\<Sqinter>n. \\<Prod>i<n. eexp (- ereal (x i)))", "show \"eexp (\\<Sum>n. - ereal (\\<omega> n)) = (\\<Sqinter>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eexp (\\<Sum>n. - ereal (\\<omega> n)) =\n    (\\<Sqinter>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))", "proof (rule LIMSEQ_unique[OF _ LIMSEQ_INF])"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i)))\n    \\<longlonglongrightarrow> eexp (\\<Sum>n. - ereal (\\<omega> n))\n 2. decseq (\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i)))", "show \"(\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i))) \\<longlonglongrightarrow> eexp (\\<Sum>n. - ereal (\\<omega> n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i)))\n    \\<longlonglongrightarrow> eexp (\\<Sum>n. - ereal (\\<omega> n))", "using \\<omega>"], ["proof (prove)\nusing this:\n  \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i)))\n    \\<longlonglongrightarrow> eexp (\\<Sum>n. - ereal (\\<omega> n))", "by (intro eexp_suminf summable_minus_ereal summable_ereal_pos) (auto intro: less_imp_le)"], ["proof (state)\nthis:\n  (\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i)))\n  \\<longlonglongrightarrow> eexp (\\<Sum>n. - ereal (\\<omega> n))\n\ngoal (1 subgoal):\n 1. decseq (\\<lambda>i. \\<Prod>i<i. eexp (- ereal (\\<omega> i)))", "show \"decseq (\\<lambda>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decseq (\\<lambda>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))", "using \\<omega>"], ["proof (prove)\nusing this:\n  \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. decseq (\\<lambda>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))", "by (auto simp: decseq_def intro!: prod_mono3 intro: less_imp_le)"], ["proof (state)\nthis:\n  decseq (\\<lambda>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eexp (\\<Sum>n. - ereal (\\<omega> n)) =\n  (\\<Sqinter>n. \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sqinter>n.\n                           \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sqinter>n.\n                           \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. (\\<integral>\\<^sup>+\\<omega>. (\\<Prod>i<n. eexp (- ereal (\\<omega> i))) \\<partial>?P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sqinter>n.\n                             \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                       \\<partial>Pi\\<^sub>M UNIV\n                                  (\\<lambda>n. exponential (R n)) =\n    (\\<Sqinter>n.\n        \\<integral>\\<^sup>+ \\<omega>.\n                             (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                           \\<partial>Pi\\<^sub>M UNIV\n(\\<lambda>n. exponential (R n)))", "proof (intro nn_integral_monotone_convergence_INF_AE')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       AE \\<omega> in Pi\\<^sub>M UNIV\n                       (\\<lambda>n.\n                           exponential\n                            (R n)). (\\<Prod>i<Suc n.\n  eexp (- ereal (\\<omega> i)))\n                                    \\<le> (\\<Prod>i<n.\n        eexp (- ereal (\\<omega> i)))\n 2. \\<And>n.\n       P.random_variable borel\n        (\\<lambda>x. \\<Prod>i<n. eexp (- ereal (x i)))\n 3. \\<integral>\\<^sup>+ \\<omega>. (\\<Prod>i<0. eexp (- ereal (\\<omega> i)))\n                       \\<partial>Pi\\<^sub>M UNIV\n                                  (\\<lambda>n. exponential (R n))\n    < \\<infinity>", "show \"AE \\<omega> in ?P. (\\<Prod>i<Suc n. eexp (- ereal (\\<omega> i))) \\<le> (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Prod>i<Suc n.\n                                     eexp (- ereal (\\<omega> i)))\n                                 \\<le> (\\<Prod>i<n.\n     eexp (- ereal (\\<omega> i)))", "using AE_pos"], ["proof (prove)\nusing this:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential (R n)). \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Prod>i<Suc n.\n                                     eexp (- ereal (\\<omega> i)))\n                                 \\<le> (\\<Prod>i<n.\n     eexp (- ereal (\\<omega> i)))", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<forall>i. 0 < \\<omega> i \\<Longrightarrow>\n       (\\<Prod>i<Suc n. eexp (- ereal (\\<omega> i)))\n       \\<le> (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))", "case (elim \\<omega>)"], ["proof (state)\nthis:\n  \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<forall>i. 0 < \\<omega> i \\<Longrightarrow>\n       (\\<Prod>i<Suc n. eexp (- ereal (\\<omega> i)))\n       \\<le> (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<Suc n. eexp (- ereal (\\<omega> i)))\n    \\<le> (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))", "by (rule prod_mono3) (auto simp: elim le_less)"], ["proof (state)\nthis:\n  (\\<Prod>i<Suc n. eexp (- ereal (\\<omega> i)))\n  \\<le> (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential\n                       (R n)). (\\<Prod>i<Suc ?n1.\n                                   eexp (- ereal (\\<omega> i)))\n                               \\<le> (\\<Prod>i<?n1.\n   eexp (- ereal (\\<omega> i)))\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       P.random_variable borel\n        (\\<lambda>x. \\<Prod>i<n. eexp (- ereal (x i)))\n 2. \\<integral>\\<^sup>+ \\<omega>. (\\<Prod>i<0. eexp (- ereal (\\<omega> i)))\n                       \\<partial>Pi\\<^sub>M UNIV\n                                  (\\<lambda>n. exponential (R n))\n    < \\<infinity>", "qed (auto simp: less_top[symmetric])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sqinter>n.\n                           \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  (\\<Sqinter>n.\n      \\<integral>\\<^sup>+ \\<omega>.\n                           (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                         \\<partial>Pi\\<^sub>M UNIV\n                                    (\\<lambda>n. exponential (R n)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sqinter>n.\n                           \\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  (\\<Sqinter>n.\n      \\<integral>\\<^sup>+ \\<omega>.\n                           (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                         \\<partial>Pi\\<^sub>M UNIV\n                                    (\\<lambda>n. exponential (R n)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. (\\<Prod>i<n. (\\<integral>\\<^sup>+\\<omega>. eexp (- ereal (\\<omega> i)) \\<partial>?P)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n.\n        \\<integral>\\<^sup>+ \\<omega>.\n                             (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                           \\<partial>Pi\\<^sub>M UNIV\n(\\<lambda>n. exponential (R n))) =\n    (\\<Sqinter>n.\n        \\<Prod>i<n.\n           \\<integral>\\<^sup>+ \\<omega>. eexp (- ereal (\\<omega> i))\n                              \\<partial>Pi\\<^sub>M UNIV\n   (\\<lambda>n. exponential (R n)))", "proof (intro INF_cong refl indep_vars_nn_integral)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> finite {..<x}\n 2. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       P.indep_vars (\\<lambda>_. borel)\n        (\\<lambda>i \\<omega>. eexp (- ereal (\\<omega> i))) {..<x}\n 3. \\<And>x i \\<omega>.\n       \\<lbrakk>x \\<in> UNIV; i \\<in> {..<x}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> eexp (- ereal (\\<omega> i))", "show \"indep_vars (\\<lambda>_. borel) (\\<lambda>i \\<omega>. eexp (- ereal (\\<omega> i))) {..<n}\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. P.indep_vars (\\<lambda>_. borel)\n     (\\<lambda>i \\<omega>. eexp (- ereal (\\<omega> i))) {..<n}", "proof (rule indep_vars_compose2[of _ _ _ \"\\<lambda>i x. eexp(- ereal x)\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. P.indep_vars ?M' (\\<lambda>i x. x i) {..<n}\n 2. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       (\\<lambda>\\<omega>. eexp (- ereal \\<omega>))\n       \\<in> borel_measurable (?M' i)", "show \"indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P.indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) {..<n}", "by (rule indep_vars_subset[OF indep]) auto"], ["proof (state)\nthis:\n  P.indep_vars (\\<lambda>i. borel) (\\<lambda>i x. x i) {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> {..<n} \\<Longrightarrow>\n       (\\<lambda>\\<omega>. eexp (- ereal \\<omega>))\n       \\<in> borel_measurable borel", "qed auto"], ["proof (state)\nthis:\n  P.indep_vars (\\<lambda>_. borel)\n   (\\<lambda>i \\<omega>. eexp (- ereal (\\<omega> i))) {..<?n1}\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> finite {..<x}\n 2. \\<And>x i \\<omega>.\n       \\<lbrakk>x \\<in> UNIV; i \\<in> {..<x}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> eexp (- ereal (\\<omega> i))", "qed auto"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      \\<integral>\\<^sup>+ \\<omega>.\n                           (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                         \\<partial>Pi\\<^sub>M UNIV\n                                    (\\<lambda>n. exponential (R n))) =\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         \\<integral>\\<^sup>+ \\<omega>. eexp (- ereal (\\<omega> i))\n                            \\<partial>Pi\\<^sub>M UNIV\n (\\<lambda>n. exponential (R n)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      \\<integral>\\<^sup>+ \\<omega>.\n                           (\\<Prod>i<n. eexp (- ereal (\\<omega> i)))\n                         \\<partial>Pi\\<^sub>M UNIV\n                                    (\\<lambda>n. exponential (R n))) =\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         \\<integral>\\<^sup>+ \\<omega>. eexp (- ereal (\\<omega> i))\n                            \\<partial>Pi\\<^sub>M UNIV\n (\\<lambda>n. exponential (R n)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. (\\<Prod>i<n. R i * (\\<integral>\\<^sup>+x. indicator {0 ..} ((1 + R i) * x) * ennreal (exp (- ((1 + R i) * x))) \\<partial>lborel)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n.\n        \\<Prod>i<n.\n           \\<integral>\\<^sup>+ \\<omega>. eexp (- ereal (\\<omega> i))\n                              \\<partial>Pi\\<^sub>M UNIV\n   (\\<lambda>n. exponential (R n))) =\n    (\\<Sqinter>n.\n        \\<Prod>i<n.\n           ennreal (R i) *\n           \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                                  ennreal (exp (- ((1 + R i) * x)))\n                              \\<partial>lborel)", "by (subst product_nn_integral_component)\n       (auto simp: field_simps exponential_def nn_integral_density ennreal_mult'[symmetric] ennreal_mult''[symmetric]\n                   exponential_density_def exp_diff exp_minus nn_integral_cmult[symmetric]\n             intro!: INF_cong prod.cong nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         \\<integral>\\<^sup>+ \\<omega>. eexp (- ereal (\\<omega> i))\n                            \\<partial>Pi\\<^sub>M UNIV\n (\\<lambda>n. exponential (R n))) =\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         ennreal (R i) *\n         \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                                ennreal (exp (- ((1 + R i) * x)))\n                            \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         \\<integral>\\<^sup>+ \\<omega>. eexp (- ereal (\\<omega> i))\n                            \\<partial>Pi\\<^sub>M UNIV\n (\\<lambda>n. exponential (R n))) =\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         ennreal (R i) *\n         \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                                ennreal (exp (- ((1 + R i) * x)))\n                            \\<partial>lborel)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. (\\<Prod>i<n. ennreal (R i / (1 + R i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n.\n        \\<Prod>i<n.\n           ennreal (R i) *\n           \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                                  ennreal (exp (- ((1 + R i) * x)))\n                              \\<partial>lborel) =\n    (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i)))", "proof (intro INF_cong prod.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> UNIV; xa \\<in> {..<x}\\<rbrakk>\n       \\<Longrightarrow> ennreal (R xa) *\n                         \\<integral>\\<^sup>+ x.\n        indicator {0..} ((1 + R xa) * x) *\n        ennreal (exp (- ((1 + R xa) * x)))\n      \\<partial>lborel =\n                         ennreal (R xa / (1 + R xa))", "show \"R i * (\\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) * ennreal (exp (- ((1 + R i) * x))) \\<partial>lborel) =\n      ennreal (R i / (1 + R i))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (R i) *\n    \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                           ennreal (exp (- ((1 + R i) * x)))\n                       \\<partial>lborel =\n    ennreal (R i / (1 + R i))", "using nn_intergal_power_times_exp_Ici[of 0] \\<open>0 < R i\\<close>"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+x\\<in>{0..}. ennreal (x ^ 0 * exp (- x))\n  \\<partial>lborel =\n  ennreal (real (fact 0))\n  0 < R i\n\ngoal (1 subgoal):\n 1. ennreal (R i) *\n    \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                           ennreal (exp (- ((1 + R i) * x)))\n                       \\<partial>lborel =\n    ennreal (R i / (1 + R i))", "by (subst nn_integral_stretch[where c=\"1 + R i\"])\n         (auto simp: mult.assoc[symmetric] ennreal_mult''[symmetric] less_imp_le mult.commute)"], ["proof (state)\nthis:\n  ennreal (R ?i1) *\n  \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R ?i1) * x) *\n                         ennreal (exp (- ((1 + R ?i1) * x)))\n                     \\<partial>lborel =\n  ennreal (R ?i1 / (1 + R ?i1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         ennreal (R i) *\n         \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                                ennreal (exp (- ((1 + R i) * x)))\n                            \\<partial>lborel) =\n  (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n.\n      \\<Prod>i<n.\n         ennreal (R i) *\n         \\<integral>\\<^sup>+ x. indicator {0..} ((1 + R i) * x) *\n                                ennreal (exp (- ((1 + R i) * x)))\n                            \\<partial>lborel) =\n  (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. ennreal (\\<Prod>i<n. R i / (1 + R i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i))) =\n    (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i)))", "using R"], ["proof (prove)\nusing this:\n  0 < R ?n\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i))) =\n    (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i)))", "by (intro INF_cong refl prod_ennreal divide_nonneg_nonneg) (auto simp: less_imp_le)"], ["proof (state)\nthis:\n  (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i))) =\n  (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n. \\<Prod>i<n. ennreal (R i / (1 + R i))) =\n  (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i))) =\n    (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i)))", "by (subst prod_inversef[symmetric]) simp_all"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i))) =\n  (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (\\<Prod>i<n. R i / (1 + R i))) =\n  (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = (INF n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i))) =\n    (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i)))", "using R"], ["proof (prove)\nusing this:\n  0 < R ?n\n\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i))) =\n    (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i)))", "by (subst inverse_ennreal) (auto intro!: prod_pos divide_pos_pos simp: add_pos_pos)"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i))) =\n  (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n. ennreal (inverse (\\<Prod>i<n. (1 + R i) / R i))) =\n  (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"\\<dots> = inverse (SUP n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i))) =\n    inverse (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))", "by (subst continuous_at_Sup_antimono [where f = inverse])\n      (auto simp: antimono_def image_comp intro!: continuous_on_imp_continuous_within[OF continuous_on_inverse_ennreal'])"], ["proof (state)\nthis:\n  (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i))) =\n  inverse (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sqinter>n. inverse (ennreal (\\<Prod>i<n. (1 + R i) / R i))) =\n  inverse (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "have \"(SUP n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "proof (cases \"SUP n. ennreal (\\<Prod>i<n. (1 + R i) / R i)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "case (real r)"], ["proof (state)\nthis:\n  0 \\<le> r\n  (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = ennreal r\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "have \"(\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) \\<longlonglongrightarrow> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n    \\<longlonglongrightarrow> ennreal r", "using R"], ["proof (prove)\nusing this:\n  0 < R ?n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n    \\<longlonglongrightarrow> ennreal r", "unfolding real(2)[symmetric]"], ["proof (prove)\nusing this:\n  0 < R ?n\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n    \\<longlonglongrightarrow> (\\<Squnion>n.\n                                  ennreal (\\<Prod>i<n. (1 + R i) / R i))", "by (intro LIMSEQ_SUP monoI ennreal_leI prod_mono2) (auto intro!: divide_nonneg_nonneg add_nonneg_nonneg intro: less_imp_le)"], ["proof (state)\nthis:\n  (\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n  \\<longlonglongrightarrow> ennreal r\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n  \\<longlonglongrightarrow> ennreal r", "have \"(\\<lambda>n. (\\<Prod>i<n. (1 + R i) / R i)) \\<longlonglongrightarrow> r\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. ennreal (\\<Prod>i<n. (1 + R i) / R i))\n  \\<longlonglongrightarrow> ennreal r\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. \\<Prod>i<n. (1 + R i) / R i) \\<longlonglongrightarrow> r", "by (rule tendsto_ennrealD)\n         (use R real in \\<open>auto intro!: always_eventually prod_nonneg divide_nonneg_nonneg add_nonneg_nonneg intro: less_imp_le\\<close>)"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<Prod>i<n. (1 + R i) / R i) \\<longlonglongrightarrow> r\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. \\<Prod>i<n. (1 + R i) / R i) \\<longlonglongrightarrow> r\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "have \"(1 + R i) / R i = 1 / R i + 1\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + R i) / R i = 1 / R i + 1", "using \\<open>0 < R i\\<close>"], ["proof (prove)\nusing this:\n  0 < R i\n\ngoal (1 subgoal):\n 1. (1 + R i) / R i = 1 / R i + 1", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  (1 + R ?i1) / R ?i1 = 1 / R ?i1 + 1\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. \\<Prod>i<n. (1 + R i) / R i) \\<longlonglongrightarrow> r\n  (1 + R ?i1) / R ?i1 = 1 / R ?i1 + 1", "have \"convergent (\\<lambda>n. \\<Prod>i<n. 1 / R i + 1)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. \\<Prod>i<n. (1 + R i) / R i) \\<longlonglongrightarrow> r\n  (1 + R ?i1) / R ?i1 = 1 / R ?i1 + 1\n\ngoal (1 subgoal):\n 1. convergent (\\<lambda>n. \\<Prod>i<n. 1 / R i + 1)", "by (auto simp: convergent_def)"], ["proof (state)\nthis:\n  convergent (\\<lambda>n. \\<Prod>i<n. 1 / R i + 1)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "then"], ["proof (chain)\npicking this:\n  convergent (\\<lambda>n. \\<Prod>i<n. 1 / R i + 1)", "have \"summable (\\<lambda>i. 1 / R i)\""], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. \\<Prod>i<n. 1 / R i + 1)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. 1 / R i)", "using R"], ["proof (prove)\nusing this:\n  convergent (\\<lambda>n. \\<Prod>i<n. 1 / R i + 1)\n  0 < R ?n\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>i. 1 / R i)", "by (subst summable_iff_convergent_prod) (auto intro: less_imp_le)"], ["proof (state)\nthis:\n  summable (\\<lambda>i. 1 / R i)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "moreover"], ["proof (state)\nthis:\n  summable (\\<lambda>i. 1 / R i)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "have \"0 \\<le> 1 / R i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / R i", "using R"], ["proof (prove)\nusing this:\n  0 < R ?n\n\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / R i", "by (auto simp: less_imp_le)"], ["proof (state)\nthis:\n  0 \\<le> 1 / R ?i1\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r;\n        (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n        ennreal r\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion>n.\n                             ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n                         \\<top>\n 2. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "ultimately"], ["proof (chain)\npicking this:\n  summable (\\<lambda>i. 1 / R i)\n  0 \\<le> 1 / R ?i1", "show ?thesis"], ["proof (prove)\nusing this:\n  summable (\\<lambda>i. 1 / R i)\n  0 \\<le> 1 / R ?i1\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "using finite ennreal_suminf_neq_top[of \"\\<lambda>i. 1 / R i\"]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>i. 1 / R i)\n  0 \\<le> 1 / R ?i1\n  (\\<Sum>n. ennreal (1 / R n)) = \\<top>\n  \\<lbrakk>summable (\\<lambda>i. 1 / R i); \\<And>i. 0 \\<le> 1 / R i\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i. ennreal (1 / R i)) \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "by blast"], ["proof (state)\nthis:\n  (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) =\n    \\<top> \\<Longrightarrow>\n    (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>", "qed"], ["proof (state)\nthis:\n  (\\<Squnion>n. ennreal (\\<Prod>i<n. (1 + R i) / R i)) = \\<top>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  inverse \\<top>", "have \"(\\<integral>\\<^sup>+\\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n)) \\<partial>?P) = 0\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  inverse \\<top>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                       \\<partial>Pi\\<^sub>M UNIV\n                                  (\\<lambda>n. exponential (R n)) =\n    0", "by simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  0\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  0", "have \"AE \\<omega> in ?P. eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ \\<omega>. eexp (\\<Sum>n. - ereal (\\<omega> n))\n                     \\<partial>Pi\\<^sub>M UNIV\n                                (\\<lambda>n. exponential (R n)) =\n  0\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0", "by (subst (asm) nn_integral_0_iff_AE) auto"], ["proof (state)\nthis:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential\n                       (R n)). eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential\n                       (R n)). eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential\n                       (R n)). eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "using AE_pos"], ["proof (prove)\nusing this:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential\n                       (R n)). eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential (R n)). \\<forall>i. 0 < \\<omega> i\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>n.\n                        exponential\n                         (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0;\n        \\<forall>i. 0 < \\<omega> i\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "show \"(\\<forall>i. 0 < \\<omega> i) \\<Longrightarrow> eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0 \\<Longrightarrow> (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>\" for \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i. 0 < \\<omega> i;\n     eexp (\\<Sum>n. - ereal (\\<omega> n)) = 0\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "apply (auto simp del: uminus_ereal.simps simp add: uminus_ereal.simps[symmetric]\n                  intro!: summable_iff_suminf_neq_top intro: less_imp_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i. 0 < \\<omega> i;\n     (\\<Sum>n. - ereal (\\<omega> n)) = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "apply (subst (asm) suminf_minus_ereal)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>i. 0 < \\<omega> i \\<Longrightarrow>\n    \\<not> {- \\<infinity>, \\<infinity>}\n           \\<subseteq> range (\\<lambda>n. ereal (\\<omega> n))\n 2. \\<forall>i. 0 < \\<omega> i \\<Longrightarrow>\n    summable (\\<lambda>n. ereal (\\<omega> n))\n 3. \\<lbrakk>\\<forall>i. 0 < \\<omega> i;\n     - (\\<Sum>n. ereal (\\<omega> n)) = - \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>", "apply (auto intro!: summable_ereal_pos intro: less_imp_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i. 0 < ?\\<omega>1 i;\n   eexp (\\<Sum>n. - ereal (?\\<omega>1 n)) = 0\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>n. ereal (?\\<omega>1 n)) = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>n.\n                      exponential\n                       (R n)). (\\<Sum>n. ereal (\\<omega> n)) = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transition Rates\\<close>"], ["", "locale transition_rates =\n  fixes R :: \"'a \\<Rightarrow> 'a \\<Rightarrow> real\"\n  assumes R_nonneg[simp]: \"\\<And>x y. 0 \\<le> R x y\"\n  assumes R_diagonal_0[simp]: \"\\<And>x. R x x = 0\"\n  assumes finite_weight: \"\\<And>x. (\\<integral>\\<^sup>+y. R x y \\<partial>count_space UNIV) < \\<infinity>\"\n  assumes positive_weight: \"\\<And>x. 0 < (\\<integral>\\<^sup>+y. R x y \\<partial>count_space UNIV)\"\nbegin"], ["", "abbreviation S :: \"(real \\<times> 'a) measure\"\nwhere \"S \\<equiv> (borel \\<Otimes>\\<^sub>M count_space UNIV)\""], ["", "abbreviation T :: \"(real \\<times> 'a) stream measure\"\nwhere \"T \\<equiv> stream_space S\""], ["", "abbreviation I :: \"'a \\<Rightarrow> 'a set\"\nwhere \"I x \\<equiv> {y. 0 < R x y}\""], ["", "lemma I_countable: \"countable (I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (I x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (I x)", "let ?P = \"point_measure UNIV (R x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. countable (I x)", "interpret finite_measure ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_measure (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))\n     (space (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))) \\<noteq>\n    \\<infinity>", "show \"emeasure ?P (space ?P) \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))\n     (space (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))) \\<noteq>\n    \\<infinity>", "using finite_weight"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal (R ?x x) \\<partial>count_space UNIV\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. emeasure (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))\n     (space (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))) \\<noteq>\n    \\<infinity>", "by (simp add: emeasure_density point_measure_def less_top)"], ["proof (state)\nthis:\n  emeasure (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))\n   (space (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))) \\<noteq>\n  \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. countable (I x)", "from countable_support emeasure_point_measure_finite2[of \"{_}\" UNIV \"R x\"]"], ["proof (chain)\npicking this:\n  countable\n   {xa.\n    Sigma_Algebra.measure\n     (point_measure UNIV (\\<lambda>xa. ennreal (R x xa))) {xa} \\<noteq>\n    0}\n  \\<lbrakk>{?uu3} \\<subseteq> UNIV; finite {?uu3}\\<rbrakk>\n  \\<Longrightarrow> emeasure\n                     (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))\n                     {?uu3} =\n                    (\\<Sum>a\\<in>{?uu3}. ennreal (R x a))", "show ?thesis"], ["proof (prove)\nusing this:\n  countable\n   {xa.\n    Sigma_Algebra.measure\n     (point_measure UNIV (\\<lambda>xa. ennreal (R x xa))) {xa} \\<noteq>\n    0}\n  \\<lbrakk>{?uu3} \\<subseteq> UNIV; finite {?uu3}\\<rbrakk>\n  \\<Longrightarrow> emeasure\n                     (point_measure UNIV (\\<lambda>xa. ennreal (R x xa)))\n                     {?uu3} =\n                    (\\<Sum>a\\<in>{?uu3}. ennreal (R x a))\n\ngoal (1 subgoal):\n 1. countable (I x)", "by (simp add: emeasure_eq_measure less_le)"], ["proof (state)\nthis:\n  countable (I x)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition escape_rate :: \"'a \\<Rightarrow> real\" where\n  \"escape_rate x = \\<integral>y. R x y \\<partial>count_space UNIV\""], ["", "lemma ennreal_escape_rate: \"ennreal (escape_rate x) = (\\<integral>\\<^sup>+y. R x y \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (escape_rate x) =\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space UNIV", "using finite_weight[of x]"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space UNIV\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. ennreal (escape_rate x) =\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space UNIV", "unfolding escape_rate_def"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space UNIV\n  < \\<infinity>\n\ngoal (1 subgoal):\n 1. ennreal (integral\\<^sup>L (count_space UNIV) (R x)) =\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space UNIV", "by (intro nn_integral_eq_integral[symmetric]) (auto simp: integrable_iff_bounded)"], ["", "lemma escape_rate_pos: \"0 < escape_rate x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < escape_rate x", "using positive_weight"], ["proof (prove)\nusing this:\n  0 < \\<integral>\\<^sup>+ x. ennreal (R ?x x) \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. 0 < escape_rate x", "unfolding ennreal_escape_rate[symmetric]"], ["proof (prove)\nusing this:\n  0 < ennreal (escape_rate ?x)\n\ngoal (1 subgoal):\n 1. 0 < escape_rate x", "by simp"], ["", "lemma nonneg_escape_rate[simp]: \"0 \\<le> escape_rate x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> escape_rate x", "using escape_rate_pos[THEN less_imp_le]"], ["proof (prove)\nusing this:\n  0 \\<le> escape_rate ?x1\n\ngoal (1 subgoal):\n 1. 0 \\<le> escape_rate x", "."], ["", "lemma prob_space_exponential_escape_rate: \"prob_space (exponential (escape_rate x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (exponential (escape_rate x))", "using escape_rate_pos"], ["proof (prove)\nusing this:\n  0 < escape_rate ?x\n\ngoal (1 subgoal):\n 1. prob_space (exponential (escape_rate x))", "by (rule prob_space_exponential)"], ["", "lemma measurable_escape_rate[measurable]: \"escape_rate \\<in> count_space UNIV \\<rightarrow>\\<^sub>M borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. escape_rate \\<in> borel_measurable (count_space UNIV)", "by auto"], ["", "lemma measurable_exponential_escape_rate[measurable]: \"(\\<lambda>x. exponential (escape_rate x)) \\<in> count_space UNIV \\<rightarrow>\\<^sub>M prob_algebra borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. exponential (escape_rate x))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M prob_algebra borel", "by (auto simp: space_prob_algebra sets_exponential prob_space_exponential_escape_rate)"], ["", "interpretation pmf_as_function"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition J :: \"'a \\<Rightarrow> 'a pmf\" is \"\\<lambda>x y.  R x y / escape_rate x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       (\\<forall>x. 0 \\<le> R a x / escape_rate a) \\<and>\n       \\<integral>\\<^sup>+ x. ennreal (R a x / escape_rate a)\n                          \\<partial>count_space UNIV =\n       1", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a x. 0 \\<le> R a x / escape_rate a\n 2. \\<And>a.\n       \\<integral>\\<^sup>+ x. ennreal (R a x / escape_rate a)\n                          \\<partial>count_space UNIV =\n       1", "show \"0 \\<le> R x y / escape_rate x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> R x y / escape_rate x", "by (auto intro!: integral_nonneg_AE divide_nonneg_nonneg R_nonneg simp: escape_rate_def)"], ["proof (state)\nthis:\n  0 \\<le> R ?x ?y / escape_rate ?x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<integral>\\<^sup>+ x. ennreal (R a x / escape_rate a)\n                          \\<partial>count_space UNIV =\n       1", "show \"(\\<integral>\\<^sup>+y. R x y / escape_rate x \\<partial>count_space UNIV) = 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (R x xa / escape_rate x)\n                       \\<partial>count_space UNIV =\n    1", "using escape_rate_pos[of x]"], ["proof (prove)\nusing this:\n  0 < escape_rate x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (R x xa / escape_rate x)\n                       \\<partial>count_space UNIV =\n    1", "by (auto simp add: divide_ennreal[symmetric] nn_integral_divide ennreal_escape_rate[symmetric] intro!: ennreal_divide_self)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (R ?x x / escape_rate ?x)\n                     \\<partial>count_space UNIV =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_pmf_J: \"set_pmf (J x) = I x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (J x) = I x", "using escape_rate_pos[of x]"], ["proof (prove)\nusing this:\n  0 < escape_rate x\n\ngoal (1 subgoal):\n 1. set_pmf (J x) = I x", "by (auto simp: set_pmf_iff J.rep_eq less_le)"], ["", "interpretation exp_esc: pair_prob_space \"distr (exponential (escape_rate x)) borel ((+) t)\" \"J x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_prob_space (distr (exponential (escape_rate x)) borel ((+) t))\n     (measure_pmf (J x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_prob_space (distr (exponential (escape_rate x)) borel ((+) t))\n     (measure_pmf (J x))", "interpret prob_space \"distr (exponential (escape_rate x)) borel ((+) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (distr (exponential (escape_rate x)) borel ((+) t))", "by (intro prob_space.prob_space_distr prob_space_exponential_escape_rate) simp"], ["proof (state)\ngoal (1 subgoal):\n 1. pair_prob_space (distr (exponential (escape_rate x)) borel ((+) t))\n     (measure_pmf (J x))", "show \"pair_prob_space (distr (exponential (escape_rate x)) borel ((+) t)) (measure_pmf (J x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_prob_space (distr (exponential (escape_rate x)) borel ((+) t))\n     (measure_pmf (J x))", "by standard"], ["proof (state)\nthis:\n  pair_prob_space (distr (exponential (escape_rate x)) borel ((+) t))\n   (measure_pmf (J x))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Continuous-time Kernel\\<close>"], ["", "definition K :: \"(real \\<times> 'a) \\<Rightarrow> (real \\<times> 'a) measure\" where\n  \"K = (\\<lambda>(t, x). (distr (exponential (escape_rate x)) borel ((+) t)) \\<Otimes>\\<^sub>M J x)\""], ["", "interpretation K: discrete_Markov_process \"borel \\<Otimes>\\<^sub>M count_space UNIV\" K"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_Markov_process S K", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. K \\<in> S \\<rightarrow>\\<^sub>M prob_algebra S", "show \"K \\<in> borel \\<Otimes>\\<^sub>M count_space UNIV \\<rightarrow>\\<^sub>M prob_algebra (borel \\<Otimes>\\<^sub>M count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K \\<in> S \\<rightarrow>\\<^sub>M prob_algebra S", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(t, x).\n        distr (exponential (escape_rate x)) borel ((+) t) \\<Otimes>\\<^sub>M\n        measure_pmf (J x))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra S", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. measure_pmf (J (snd x)))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (count_space UNIV)", "apply (rule measurable_snd[THEN measurable_compose])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. measure_pmf (J a))\n    \\<in> count_space UNIV \\<rightarrow>\\<^sub>M\n          prob_algebra (count_space UNIV)", "apply (auto simp: space_prob_algebra prob_space_measure_pmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  K \\<in> S \\<rightarrow>\\<^sub>M prob_algebra S\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation DTMC: MC_syntax J"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma in_space_S[simp]: \"x \\<in> space S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space S", "by (simp add: space_pair_measure)"], ["", "lemma in_space_T[simp]: \"x \\<in> space T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space (stream_space S)", "by (simp add: space_pair_measure space_stream_space)"], ["", "lemma in_space_lim_stream: \"\\<omega> \\<in> space (K.lim_stream x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<in> space (K.lim_stream x)", "unfolding K.space_lim_stream space_stream_space[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<omega> \\<in> space (stream_space S)", "by simp"], ["", "lemma prob_space_K_lim: \"prob_space (K.lim_stream x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (K.lim_stream x)", "using K.lim_stream[THEN measurable_space]"], ["proof (prove)\nusing this:\n  ?x \\<in> space S \\<Longrightarrow>\n  K.lim_stream ?x \\<in> space (prob_algebra (stream_space S))\n\ngoal (1 subgoal):\n 1. prob_space (K.lim_stream x)", "by (simp add: space_prob_algebra)"], ["", "definition select_first :: \"'a \\<Rightarrow> ('a \\<Rightarrow> real) \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere \"select_first x p y = (y \\<in> I x \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y'))\""], ["", "lemma select_firstD1: \"select_first x p y \\<Longrightarrow> y \\<in> I x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_first x p y \\<Longrightarrow> y \\<in> I x", "by (simp add: select_first_def)"], ["", "lemma select_first_unique:\n  assumes y: \"select_first x p y1\" \" select_first x p y2\" shows \"y1 = y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y1 = y2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y1 = y2", "have \"y1 \\<noteq> y2 \\<Longrightarrow> p y1 < p y2\" \"y1 \\<noteq> y2 \\<Longrightarrow> p y2 < p y1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y1 \\<noteq> y2 \\<Longrightarrow> p y1 < p y2) &&&\n    (y1 \\<noteq> y2 \\<Longrightarrow> p y2 < p y1)", "using y"], ["proof (prove)\nusing this:\n  select_first x p y1\n  select_first x p y2\n\ngoal (1 subgoal):\n 1. (y1 \\<noteq> y2 \\<Longrightarrow> p y1 < p y2) &&&\n    (y1 \\<noteq> y2 \\<Longrightarrow> p y2 < p y1)", "by (auto simp: select_first_def)"], ["proof (state)\nthis:\n  y1 \\<noteq> y2 \\<Longrightarrow> p y1 < p y2\n  y1 \\<noteq> y2 \\<Longrightarrow> p y2 < p y1\n\ngoal (1 subgoal):\n 1. y1 = y2", "then"], ["proof (chain)\npicking this:\n  y1 \\<noteq> y2 \\<Longrightarrow> p y1 < p y2\n  y1 \\<noteq> y2 \\<Longrightarrow> p y2 < p y1", "show \"y1 = y2\""], ["proof (prove)\nusing this:\n  y1 \\<noteq> y2 \\<Longrightarrow> p y1 < p y2\n  y1 \\<noteq> y2 \\<Longrightarrow> p y2 < p y1\n\ngoal (1 subgoal):\n 1. y1 = y2", "by (rule_tac ccontr) auto"], ["proof (state)\nthis:\n  y1 = y2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma The_select_first[simp]: \"select_first x p y \\<Longrightarrow> The (select_first x p) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_first x p y \\<Longrightarrow> The (select_first x p) = y", "by (intro the_equality select_first_unique)"], ["", "lemma select_first_INF:\n  \"select_first x p y \\<Longrightarrow> (INF x\\<in>I x. p x) = p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_first x p y \\<Longrightarrow> \\<Sqinter> (p ` I x) = p y", "by (intro antisym cINF_greatest cINF_lower bdd_belowI2[where m=\"p y\"])\n     (auto simp: select_first_def le_less)"], ["", "lemma measurable_select_first[measurable]:\n  \"(\\<lambda>p. select_first x p y) \\<in> (\\<Pi>\\<^sub>M y\\<in>I x. borel) \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (Pi\\<^sub>M (I x) (\\<lambda>y. borel))\n     (\\<lambda>p. select_first x p y)", "using I_countable"], ["proof (prove)\nusing this:\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. Measurable.pred (Pi\\<^sub>M (I x) (\\<lambda>y. borel))\n     (\\<lambda>p. select_first x p y)", "unfolding select_first_def"], ["proof (prove)\nusing this:\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. Measurable.pred (Pi\\<^sub>M (I x) (\\<lambda>y. borel))\n     (\\<lambda>p.\n         y \\<in> I x \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y'))", "by (intro measurable_pred_countable pred_intros_conj1') measurable"], ["", "lemma measurable_THE_select_first[measurable]:\n  \"(\\<lambda>p. The (select_first x p)) \\<in> (\\<Pi>\\<^sub>M y\\<in>I x. borel) \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. The (select_first x p))\n    \\<in> Pi\\<^sub>M (I x) (\\<lambda>y. borel) \\<rightarrow>\\<^sub>M\n          count_space UNIV", "by (rule measurable_THE) (auto intro: select_first_unique I_countable dest: select_firstD1)"], ["", "lemma sets_S_eq: \"sets S = sigma_sets UNIV { {t ..} \\<times> A | t A. A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s}) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets S =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "proof (subst sets_pair_eq)"], ["proof (state)\ngoal (11 subgoals):\n 1. ?Ea \\<subseteq> Pow (space borel)\n 2. sets borel = sigma_sets (space borel) ?Ea\n 3. countable ?Ca\n 4. ?Ca \\<subseteq> ?Ea\n 5. \\<Union> ?Ca = space borel\n 6. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 7. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 8. countable ?Cb\n 9. ?Cb \\<subseteq> ?Eb\n 10. \\<Union> ?Cb = space (count_space UNIV)\nA total of 11 subgoals...", "let ?CI = \"\\<lambda>a::real. {a ..}\""], ["proof (state)\ngoal (11 subgoals):\n 1. ?Ea \\<subseteq> Pow (space borel)\n 2. sets borel = sigma_sets (space borel) ?Ea\n 3. countable ?Ca\n 4. ?Ca \\<subseteq> ?Ea\n 5. \\<Union> ?Ca = space borel\n 6. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 7. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 8. countable ?Cb\n 9. ?Cb \\<subseteq> ?Eb\n 10. \\<Union> ?Cb = space (count_space UNIV)\nA total of 11 subgoals...", "let ?Ea = \"range ?CI\""], ["proof (state)\ngoal (11 subgoals):\n 1. ?Ea \\<subseteq> Pow (space borel)\n 2. sets borel = sigma_sets (space borel) ?Ea\n 3. countable ?Ca\n 4. ?Ca \\<subseteq> ?Ea\n 5. \\<Union> ?Ca = space borel\n 6. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 7. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 8. countable ?Cb\n 9. ?Cb \\<subseteq> ?Eb\n 10. \\<Union> ?Cb = space (count_space UNIV)\nA total of 11 subgoals...", "show \"?Ea \\<subseteq> Pow (space borel)\" \"sets borel = sigma_sets (space borel) ?Ea\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range atLeast \\<subseteq> Pow (space borel) &&&\n    sets borel = sigma_sets (space borel) (range atLeast)", "unfolding borel_Ici"], ["proof (prove)\ngoal (1 subgoal):\n 1. range atLeast \\<subseteq> Pow (space (sigma UNIV (range atLeast))) &&&\n    sets (sigma UNIV (range atLeast)) =\n    sigma_sets (space (sigma UNIV (range atLeast))) (range atLeast)", "by auto"], ["proof (state)\nthis:\n  range atLeast \\<subseteq> Pow (space borel)\n  sets borel = sigma_sets (space borel) (range atLeast)\n\ngoal (9 subgoals):\n 1. countable ?Ca\n 2. ?Ca \\<subseteq> range atLeast\n 3. \\<Union> ?Ca = space borel\n 4. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 5. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 6. countable ?Cb\n 7. ?Cb \\<subseteq> ?Eb\n 8. \\<Union> ?Cb = space (count_space UNIV)\n 9. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b. a \\<in> range atLeast \\<and> b \\<in> ?Eb}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "show \"?CI`Rats \\<subseteq> ?Ea\" \"(\\<Union>i\\<in>Rats. ?CI i) = space borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atLeast ` \\<rat> \\<subseteq> range atLeast &&&\n    \\<Union> (atLeast ` \\<rat>) = space borel", "using Rats_dense_in_real[of \"x - 1\" \"x\" for x]"], ["proof (prove)\nusing this:\n  ?xa3 - 1 < ?xa3 \\<Longrightarrow>\n  \\<exists>r\\<in>\\<rat>. ?xa3 - 1 < r \\<and> r < ?xa3\n\ngoal (1 subgoal):\n 1. atLeast ` \\<rat> \\<subseteq> range atLeast &&&\n    \\<Union> (atLeast ` \\<rat>) = space borel", "by (auto intro: less_imp_le)"], ["proof (state)\nthis:\n  atLeast ` \\<rat> \\<subseteq> range atLeast\n  \\<Union> (atLeast ` \\<rat>) = space borel\n\ngoal (7 subgoals):\n 1. countable (atLeast ` \\<rat>)\n 2. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 3. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 4. countable ?Cb\n 5. ?Cb \\<subseteq> ?Eb\n 6. \\<Union> ?Cb = space (count_space UNIV)\n 7. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b. a \\<in> range atLeast \\<and> b \\<in> ?Eb}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "let ?Eb = \"Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\""], ["proof (state)\ngoal (7 subgoals):\n 1. countable (atLeast ` \\<rat>)\n 2. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 3. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 4. countable ?Cb\n 5. ?Cb \\<subseteq> ?Eb\n 6. \\<Union> ?Cb = space (count_space UNIV)\n 7. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b. a \\<in> range atLeast \\<and> b \\<in> ?Eb}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "have \"b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)\" for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "have \"b = (b - I x) \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = b - I x \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})", "by auto"], ["proof (state)\nthis:\n  b = b - I x \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})\n\ngoal (1 subgoal):\n 1. b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "also"], ["proof (state)\nthis:\n  b = b - I x \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})\n\ngoal (1 subgoal):\n 1. b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "have \"\\<dots> \\<in> sigma UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b - I x \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})\n    \\<in> sets (sigma UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x))", "using I_countable"], ["proof (prove)\nusing this:\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. b - I x \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})\n    \\<in> sets (sigma UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x))", "by (intro sets.Un sets.countable_UN') auto"], ["proof (state)\nthis:\n  b - I x \\<union> (\\<Union>x\\<in>b \\<inter> I x. {x})\n  \\<in> sets (sigma UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x))\n\ngoal (1 subgoal):\n 1. b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "finally"], ["proof (chain)\npicking this:\n  b \\<in> sets (sigma UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x))", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<in> sets (sigma UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x))\n\ngoal (1 subgoal):\n 1. b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "by simp"], ["proof (state)\nthis:\n  b \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?b1 \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)\n\ngoal (7 subgoals):\n 1. countable (atLeast ` \\<rat>)\n 2. ?Eb \\<subseteq> Pow (space (count_space UNIV))\n 3. sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\n 4. countable ?Cb\n 5. ?Cb \\<subseteq> ?Eb\n 6. \\<Union> ?Cb = space (count_space UNIV)\n 7. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b. a \\<in> range atLeast \\<and> b \\<in> ?Eb}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "then"], ["proof (chain)\npicking this:\n  ?b1 \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "show \"sets (count_space UNIV) = sigma_sets (space (count_space UNIV)) ?Eb\""], ["proof (prove)\nusing this:\n  ?b1 \\<in> sigma_sets UNIV (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)\n\ngoal (1 subgoal):\n 1. sets (count_space UNIV) =\n    sigma_sets (space (count_space UNIV))\n     (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)", "by auto"], ["proof (state)\nthis:\n  sets (count_space UNIV) =\n  sigma_sets (space (count_space UNIV))\n   (Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x)\n\ngoal (6 subgoals):\n 1. countable (atLeast ` \\<rat>)\n 2. Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\n    \\<subseteq> Pow (space (count_space UNIV))\n 3. countable ?Cb\n 4. ?Cb \\<subseteq> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\n 5. \\<Union> ?Cb = space (count_space UNIV)\n 6. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b.\n        a \\<in> range atLeast \\<and>\n        b \\<in> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "show \"countable ({- I x} \\<union> (\\<Union>s\\<in>I x. {{s}}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable ({- I x} \\<union> (\\<Union>s\\<in>I x. {{s}}))", "using I_countable"], ["proof (prove)\nusing this:\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. countable ({- I x} \\<union> (\\<Union>s\\<in>I x. {{s}}))", "by auto"], ["proof (state)\nthis:\n  countable ({- I x} \\<union> (\\<Union>s\\<in>I x. {{s}}))\n\ngoal (5 subgoals):\n 1. countable (atLeast ` \\<rat>)\n 2. Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\n    \\<subseteq> Pow (space (count_space UNIV))\n 3. {- I x} \\<union> (\\<Union>s\\<in>I x. {{s}})\n    \\<subseteq> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\n 4. \\<Union> ({- I x} \\<union> (\\<Union>s\\<in>I x. {{s}})) =\n    space (count_space UNIV)\n 5. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b.\n        a \\<in> range atLeast \\<and>\n        b \\<in> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "show \"sets (sigma (space borel \\<times> space (count_space UNIV)) {a \\<times> b |a b. a \\<in> ?Ea \\<and> b \\<in> ?Eb}) =\n    sigma_sets UNIV {{t ..} \\<times> A |t A. A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (sigma (space borel \\<times> space (count_space UNIV))\n       {a \\<times> b |a b.\n        a \\<in> range atLeast \\<and>\n        b \\<in> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x}) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_sets UNIV\n     {a \\<times> b |a b.\n      a \\<in> range atLeast \\<and>\n      (b \\<subseteq> - I x \\<or> b \\<in> (\\<lambda>s. {s}) ` I x)} =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s. 0 < R x s \\<and> A = {s})}", "apply (intro arg_cong[where f=\"sigma_sets _\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a \\<times> b |a b.\n     a \\<in> range atLeast \\<and>\n     (b \\<subseteq> - I x \\<or> b \\<in> (\\<lambda>s. {s}) ` I x)} =\n    {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s. 0 < R x s \\<and> A = {s})}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sets\n   (sigma (space borel \\<times> space (count_space UNIV))\n     {a \\<times> b |a b.\n      a \\<in> range atLeast \\<and>\n      b \\<in> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x}) =\n  sigma_sets UNIV\n   {{t..} \\<times> A |t A.\n    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n\ngoal (4 subgoals):\n 1. countable (atLeast ` \\<rat>)\n 2. Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\n    \\<subseteq> Pow (space (count_space UNIV))\n 3. {- I x} \\<union> (\\<Union>s\\<in>I x. {{s}})\n    \\<subseteq> Pow (- I x) \\<union> (\\<lambda>s. {s}) ` I x\n 4. \\<Union> ({- I x} \\<union> (\\<Union>s\\<in>I x. {{s}})) =\n    space (count_space UNIV)", "qed (auto intro: countable_rat)"], ["", "subsection \\<open>Kernel equals Parallel Choice\\<close>"], ["", "abbreviation PAR :: \"'a \\<Rightarrow> ('a \\<Rightarrow> real) measure\"\nwhere\n  \"PAR x \\<equiv> (\\<Pi>\\<^sub>M y\\<in>I x. exponential (R x y))\""], ["", "lemma PAR_least:\n  assumes y: \"y \\<in> I x\"\n  shows \"PAR x {p\\<in>space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n     emeasure (exponential (escape_rate x)) {t ..} * ennreal (pmf (J x) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "let ?E = \"\\<lambda>y. exponential (R x y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "let ?P' = \"\\<Pi>\\<^sub>M y\\<in>I x - {y}. ?E y\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "interpret P': prob_space ?P'"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))", "by (intro prob_space_PiM prob_space_exponential) simp"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have *: \"PAR x = (\\<Pi>\\<^sub>M y\\<in>insert y (I x - {y}). ?E y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PAR x =\n    Pi\\<^sub>M (insert y (I x - {y})) (\\<lambda>y. exponential (R x y))", "using y"], ["proof (prove)\nusing this:\n  y \\<in> I x\n\ngoal (1 subgoal):\n 1. PAR x =\n    Pi\\<^sub>M (insert y (I x - {y})) (\\<lambda>y. exponential (R x y))", "by (intro PiM_cong) auto"], ["proof (state)\nthis:\n  PAR x =\n  Pi\\<^sub>M (insert y (I x - {y})) (\\<lambda>y. exponential (R x y))\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have \"0 < R x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R x y", "using y"], ["proof (prove)\nusing this:\n  y \\<in> I x\n\ngoal (1 subgoal):\n 1. 0 < R x y", "by simp"], ["proof (state)\nthis:\n  0 < R x y\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have **: \"(\\<lambda>(x, X). X(y := x)) \\<in> exponential (R x y) \\<Otimes>\\<^sub>M Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)) \\<rightarrow>\\<^sub>M PAR x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, X). X(y := x))\n    \\<in> exponential (R x y) \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M (I x - {y})\n           (\\<lambda>i. exponential (R x i)) \\<rightarrow>\\<^sub>M\n          PAR x", "using y"], ["proof (prove)\nusing this:\n  y \\<in> I x\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, X). X(y := x))\n    \\<in> exponential (R x y) \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M (I x - {y})\n           (\\<lambda>i. exponential (R x i)) \\<rightarrow>\\<^sub>M\n          PAR x", "apply (subst measurable_cong_sets[OF sets_pair_measure_cong[OF sets_exponential sets_PiM_cong[OF refl sets_exponential]] sets_PiM_cong[OF refl sets_exponential]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> I x \\<Longrightarrow>\n    (\\<lambda>(x, X). X(y := x))\n    \\<in> borel \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M (I x - {y}) (\\<lambda>i. borel) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M (I x) (\\<lambda>i. borel)", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> I x \\<Longrightarrow>\n    (\\<lambda>x. (snd x)(y := fst x))\n    \\<in> borel \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M (I x - {y}) (\\<lambda>i. borel) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M (I x) (\\<lambda>i. borel)", "apply (rule measurable_fun_upd[where J=\"I x - {y}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. y \\<in> I x \\<Longrightarrow> I x = I x - {y} \\<union> {y}\n 2. y \\<in> I x \\<Longrightarrow>\n    snd\n    \\<in> borel \\<Otimes>\\<^sub>M\n          Pi\\<^sub>M (I x - {y}) (\\<lambda>i. borel) \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M (I x - {y}) (\\<lambda>i. borel)\n 3. y \\<in> I x \\<Longrightarrow>\n    fst\n    \\<in> borel_measurable\n           (borel \\<Otimes>\\<^sub>M\n            Pi\\<^sub>M (I x - {y}) (\\<lambda>i. borel))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>(x, X). X(y := x))\n  \\<in> exponential (R x y) \\<Otimes>\\<^sub>M\n        Pi\\<^sub>M (I x - {y})\n         (\\<lambda>i. exponential (R x i)) \\<rightarrow>\\<^sub>M\n        PAR x\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have \"PAR x {p\\<in>space (PAR x). t \\<le> p y \\<and> (\\<forall>y'\\<in>I x-{y}. p y < p y')} =\n    (\\<integral>\\<^sup>+ty. indicator {t..} ty * ?P' {p\\<in>space ?P'. \\<forall>y'\\<in>I x-{y}. ty < p y'} \\<partial>?E y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x).\n      t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (Pi\\<^sub>M (insert y (I x - {y})) (\\<lambda>y. exponential (R x y)))\n     {p \\<in> space\n               (Pi\\<^sub>M (insert y (I x - {y}))\n                 (\\<lambda>y. exponential (R x y))).\n      t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "using \\<open>y \\<in> I x\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> I x\n\ngoal (1 subgoal):\n 1. emeasure\n     (Pi\\<^sub>M (insert y (I x - {y})) (\\<lambda>y. exponential (R x y)))\n     {p \\<in> space\n               (Pi\\<^sub>M (insert y (I x - {y}))\n                 (\\<lambda>y. exponential (R x y))).\n      t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "apply (subst distr_pair_PiM_eq_PiM[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>y \\<in> I x; i \\<in> I x - {y}\\<rbrakk>\n       \\<Longrightarrow> prob_space (exponential (R x i))\n 2. y \\<in> I x \\<Longrightarrow> prob_space (exponential (R x y))\n 3. y \\<in> I x \\<Longrightarrow>\n    emeasure\n     (distr\n       (exponential (R x y) \\<Otimes>\\<^sub>M\n        Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n       (Pi\\<^sub>M (insert y (I x - {y})) (\\<lambda>i. exponential (R x i)))\n       (\\<lambda>(x, X). X(y := x)))\n     {p \\<in> space\n               (Pi\\<^sub>M (insert y (I x - {y}))\n                 (\\<lambda>y. exponential (R x y))).\n      t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "apply (auto intro!: prob_space_exponential simp: emeasure_distr insert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    emeasure\n     (distr\n       (exponential (R x y) \\<Otimes>\\<^sub>M\n        Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n       (PAR x) (\\<lambda>(x, X). X(y := x)))\n     {p \\<in> space (PAR x).\n      t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "apply (subst emeasure_distr[OF **])"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < R x y \\<Longrightarrow>\n    {p \\<in> space (PAR x).\n     t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')}\n    \\<in> sets (PAR x)\n 2. 0 < R x y \\<Longrightarrow>\n    emeasure\n     (exponential (R x y) \\<Otimes>\\<^sub>M\n      Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n     ((\\<lambda>(x, X). X(y := x)) -`\n      {p \\<in> space (PAR x).\n       t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} \\<inter>\n      space\n       (exponential (R x y) \\<Otimes>\\<^sub>M\n        Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))) =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    {p \\<in> space (PAR x).\n     t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')}\n    \\<in> sets (PAR x)", "using I_countable"], ["proof (prove)\nusing this:\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    {p \\<in> space (PAR x).\n     t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')}\n    \\<in> sets (PAR x)", "by (auto simp: pred_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    emeasure\n     (exponential (R x y) \\<Otimes>\\<^sub>M\n      Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n     ((\\<lambda>(x, X). X(y := x)) -`\n      {p \\<in> space (PAR x).\n       t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} \\<inter>\n      space\n       (exponential (R x y) \\<Otimes>\\<^sub>M\n        Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))) =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "apply (subst P'.emeasure_pair_measure_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < R x y \\<Longrightarrow>\n    (\\<lambda>(x, X). X(y := x)) -`\n    {p \\<in> space (PAR x).\n     t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} \\<inter>\n    space\n     (exponential (R x y) \\<Otimes>\\<^sub>M\n      Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n    \\<in> sets\n           (exponential (R x y) \\<Otimes>\\<^sub>M\n            Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n 2. 0 < R x y \\<Longrightarrow>\n    \\<integral>\\<^sup>+ xa. emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             (Pair xa -`\n                              ((\\<lambda>(x, X). X(y := x)) -`\n                               {p \\<in> space (PAR x).\n                                t \\<le> p y \\<and>\n                                (\\<forall>y'\\<in>I x - {y}.\n                                    p y < p y')} \\<inter>\n                               space\n                                (exponential (R x y) \\<Otimes>\\<^sub>M\n                                 Pi\\<^sub>M (I x - {y})\n                                  (\\<lambda>i. exponential (R x i)))))\n                       \\<partial>exponential (R x y) =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    (\\<lambda>(x, X). X(y := x)) -`\n    {p \\<in> space (PAR x).\n     t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} \\<inter>\n    space\n     (exponential (R x y) \\<Otimes>\\<^sub>M\n      Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n    \\<in> sets\n           (exponential (R x y) \\<Otimes>\\<^sub>M\n            Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))", "using I_countable[of x]"], ["proof (prove)\nusing this:\n  countable (I x)\n\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    (\\<lambda>(x, X). X(y := x)) -`\n    {p \\<in> space (PAR x).\n     t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} \\<inter>\n    space\n     (exponential (R x y) \\<Otimes>\\<^sub>M\n      Pi\\<^sub>M (I x - {y}) (\\<lambda>i. exponential (R x i)))\n    \\<in> sets\n           (exponential (R x y) \\<Otimes>\\<^sub>M\n            Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))", "apply (intro measurable_sets[OF **])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < R x y; countable (I x)\\<rbrakk>\n    \\<Longrightarrow> {p \\<in> space (PAR x).\n                       t \\<le> p y \\<and>\n                       (\\<forall>y'\\<in>I x - {y}. p y < p y')}\n                      \\<in> sets (PAR x)", "apply (auto simp: pred_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < R x y \\<Longrightarrow>\n    \\<integral>\\<^sup>+ xa. emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             (Pair xa -`\n                              ((\\<lambda>(x, X). X(y := x)) -`\n                               {p \\<in> space (PAR x).\n                                t \\<le> p y \\<and>\n                                (\\<forall>y'\\<in>I x - {y}.\n                                    p y < p y')} \\<inter>\n                               space\n                                (exponential (R x y) \\<Otimes>\\<^sub>M\n                                 Pi\\<^sub>M (I x - {y})\n                                  (\\<lambda>i. exponential (R x i)))))\n                       \\<partial>exponential (R x y) =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y)", "apply (auto intro!: nn_integral_cong arg_cong2[where f=emeasure] split: split_indicator if_split_asm\n      simp: space_exponential space_PiM space_pair_measure PiE_iff extensional_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x).\n    t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          emeasure\n                           (Pi\\<^sub>M (I x - {y})\n                             (\\<lambda>y. exponential (R x y)))\n                           {p \\<in> space\n                                     (Pi\\<^sub>M (I x - {y})\n (\\<lambda>y. exponential (R x y))).\n                            \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                     \\<partial>exponential (R x y)\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "also"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x).\n    t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          emeasure\n                           (Pi\\<^sub>M (I x - {y})\n                             (\\<lambda>y. exponential (R x y)))\n                           {p \\<in> space\n                                     (Pi\\<^sub>M (I x - {y})\n (\\<lambda>y. exponential (R x y))).\n                            \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                     \\<partial>exponential (R x y)\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have \"\\<dots> = (\\<integral>\\<^sup>+ty. indicator {t..} ty * ennreal (exp (- ty * (escape_rate x - R x y))) \\<partial>?E y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            emeasure\n                             (Pi\\<^sub>M (I x - {y})\n                               (\\<lambda>y. exponential (R x y)))\n                             {p \\<in> space\n (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n                              \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                       \\<partial>exponential (R x y) =\n    \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            ennreal (exp (- ty * (escape_rate x - R x y)))\n                       \\<partial>exponential (R x y)", "apply (intro nn_integral_cong_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE xa in exponential\n              (R x y). indicator {t..} xa *\n                       emeasure\n                        (Pi\\<^sub>M (I x - {y})\n                          (\\<lambda>y. exponential (R x y)))\n                        {p \\<in> space\n                                  (Pi\\<^sub>M (I x - {y})\n                                    (\\<lambda>y. exponential (R x y))).\n                         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n                       indicator {t..} xa *\n                       ennreal (exp (- xa * (escape_rate x - R x y)))", "using AE_exponential[OF \\<open>0 < R x y\\<close>]"], ["proof (prove)\nusing this:\n  almost_everywhere (exponential (R x y)) ((<) 0)\n\ngoal (1 subgoal):\n 1. AE xa in exponential\n              (R x y). indicator {t..} xa *\n                       emeasure\n                        (Pi\\<^sub>M (I x - {y})\n                          (\\<lambda>y. exponential (R x y)))\n                        {p \\<in> space\n                                  (Pi\\<^sub>M (I x - {y})\n                                    (\\<lambda>y. exponential (R x y))).\n                         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n                       indicator {t..} xa *\n                       ennreal (exp (- xa * (escape_rate x - R x y)))", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "fix ty :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "assume \"0 < ty\""], ["proof (state)\nthis:\n  0 < ty\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "have \"escape_rate x =\n      (\\<integral>\\<^sup>+y'. R x y' * indicator {y} y' \\<partial>count_space UNIV) + (\\<integral>\\<^sup>+y'. R x y' * indicator (I x - {y}) y' \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (escape_rate x) =\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real {y} xa)\n                       \\<partial>count_space UNIV +\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real (I x - {y}) xa)\n                       \\<partial>count_space UNIV", "unfolding ennreal_escape_rate"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real {y} xa)\n                       \\<partial>count_space UNIV +\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real (I x - {y}) xa)\n                       \\<partial>count_space UNIV", "by (subst nn_integral_add[symmetric]) (auto simp: less_le split: split_indicator intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  ennreal (escape_rate x) =\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real {y} xa)\n                     \\<partial>count_space UNIV +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real (I x - {y}) xa)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "also"], ["proof (state)\nthis:\n  ennreal (escape_rate x) =\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real {y} xa)\n                     \\<partial>count_space UNIV +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real (I x - {y}) xa)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "have \"\\<dots> = R x y + (\\<integral>\\<^sup>+y'. R x y' \\<partial>count_space (I x - {y}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real {y} xa)\n                       \\<partial>count_space UNIV +\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real (I x - {y}) xa)\n                       \\<partial>count_space UNIV =\n    ennreal (R x y) +\n    \\<integral>\\<^sup>+ xa. ennreal (R x xa)\n                       \\<partial>count_space (I x - {y})", "by (auto simp add: nn_integral_count_space_indicator less_le simp del: nn_integral_indicator_singleton\n               intro!: arg_cong2[where f=\"(+)\"] nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real {y} xa)\n                     \\<partial>count_space UNIV +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa * indicat_real (I x - {y}) xa)\n                     \\<partial>count_space UNIV =\n  ennreal (R x y) +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space (I x - {y})\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "finally"], ["proof (chain)\npicking this:\n  ennreal (escape_rate x) =\n  ennreal (R x y) +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space (I x - {y})", "have \"(\\<integral>\\<^sup>+y'. R x y' \\<partial>count_space (I x - {y})) = escape_rate x - R x y \\<and> R x y \\<le> escape_rate x\""], ["proof (prove)\nusing this:\n  ennreal (escape_rate x) =\n  ennreal (R x y) +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space (I x - {y})\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (R x xa)\n                       \\<partial>count_space (I x - {y}) =\n    ennreal (escape_rate x - R x y) \\<and>\n    R x y \\<le> escape_rate x", "using escape_rate_pos[THEN less_imp_le]"], ["proof (prove)\nusing this:\n  ennreal (escape_rate x) =\n  ennreal (R x y) +\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa) \\<partial>count_space (I x - {y})\n  0 \\<le> escape_rate ?x1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (R x xa)\n                       \\<partial>count_space (I x - {y}) =\n    ennreal (escape_rate x - R x y) \\<and>\n    R x y \\<le> escape_rate x", "by (cases \"(\\<integral>\\<^sup>+y'. R x y' \\<partial>count_space (I x - {y}))\")\n         (auto simp: add_top ennreal_plus[symmetric] simp del: ennreal_plus)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa)\n                     \\<partial>count_space (I x - {y}) =\n  ennreal (escape_rate x - R x y) \\<and>\n  R x y \\<le> escape_rate x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "then"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa)\n                     \\<partial>count_space (I x - {y}) =\n  ennreal (escape_rate x - R x y) \\<and>\n  R x y \\<le> escape_rate x", "have \"integrable (count_space (I x - {y})) (R x)\" \"(LINT y'|count_space (I x - {y}). R x y') = escape_rate x - R x y\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ xa. ennreal (R x xa)\n                     \\<partial>count_space (I x - {y}) =\n  ennreal (escape_rate x - R x y) \\<and>\n  R x y \\<le> escape_rate x\n\ngoal (1 subgoal):\n 1. integrable (count_space (I x - {y})) (R x) &&&\n    integral\\<^sup>L (count_space (I x - {y})) (R x) = escape_rate x - R x y", "by (auto simp: nn_integral_eq_integrable)"], ["proof (state)\nthis:\n  integrable (count_space (I x - {y})) (R x)\n  integral\\<^sup>L (count_space (I x - {y})) (R x) = escape_rate x - R x y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "then"], ["proof (chain)\npicking this:\n  integrable (count_space (I x - {y})) (R x)\n  integral\\<^sup>L (count_space (I x - {y})) (R x) = escape_rate x - R x y", "have \"?P' (prod_emb (I x-{y}) ?E (I x-{y}) (\\<Pi>\\<^sub>E j\\<in>(I x-{y}). {ty<..})) = exp (- ty * (escape_rate x - R x y))\""], ["proof (prove)\nusing this:\n  integrable (count_space (I x - {y})) (R x)\n  integral\\<^sup>L (count_space (I x - {y})) (R x) = escape_rate x - R x y\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n     (prod_emb (I x - {y}) (\\<lambda>y. exponential (R x y)) (I x - {y})\n       (I x - {y} \\<rightarrow>\\<^sub>E {ty<..})) =\n    ennreal (exp (- ty * (escape_rate x - R x y)))", "using I_countable \\<open>0 < ty\\<close>"], ["proof (prove)\nusing this:\n  integrable (count_space (I x - {y})) (R x)\n  integral\\<^sup>L (count_space (I x - {y})) (R x) = escape_rate x - R x y\n  countable (I ?x)\n  0 < ty\n\ngoal (1 subgoal):\n 1. emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n     (prod_emb (I x - {y}) (\\<lambda>y. exponential (R x y)) (I x - {y})\n       (I x - {y} \\<rightarrow>\\<^sub>E {ty<..})) =\n    ennreal (exp (- ty * (escape_rate x - R x y)))", "by (subst emeasure_PiM_exponential_Ioi_countable) auto"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n   (prod_emb (I x - {y}) (\\<lambda>y. exponential (R x y)) (I x - {y})\n     (I x - {y} \\<rightarrow>\\<^sub>E {ty<..})) =\n  ennreal (exp (- ty * (escape_rate x - R x y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "also"], ["proof (state)\nthis:\n  emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n   (prod_emb (I x - {y}) (\\<lambda>y. exponential (R x y)) (I x - {y})\n     (I x - {y} \\<rightarrow>\\<^sub>E {ty<..})) =\n  ennreal (exp (- ty * (escape_rate x - R x y)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "have \"prod_emb (I x-{y}) ?E (I x-{y}) (\\<Pi>\\<^sub>E j\\<in>(I x-{y}). {ty<..}) = {p\\<in>space ?P'. \\<forall>y'\\<in>I x-{y}. ty < p y'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_emb (I x - {y}) (\\<lambda>y. exponential (R x y)) (I x - {y})\n     (I x - {y} \\<rightarrow>\\<^sub>E {ty<..}) =\n    {p \\<in> space\n              (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n     \\<forall>y'\\<in>I x - {y}. ty < p y'}", "by (simp add: set_eq_iff prod_emb_def space_PiM space_exponential ac_simps Pi_iff)"], ["proof (state)\nthis:\n  prod_emb (I x - {y}) (\\<lambda>y. exponential (R x y)) (I x - {y})\n   (I x - {y} \\<rightarrow>\\<^sub>E {ty<..}) =\n  {p \\<in> space (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n   \\<forall>y'\\<in>I x - {y}. ty < p y'}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       0 < xa \\<Longrightarrow>\n       indicator {t..} xa *\n       emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n        {p \\<in> space\n                  (Pi\\<^sub>M (I x - {y})\n                    (\\<lambda>y. exponential (R x y))).\n         \\<forall>y'\\<in>I x - {y}. xa < p y'} =\n       indicator {t..} xa * ennreal (exp (- xa * (escape_rate x - R x y)))", "finally"], ["proof (chain)\npicking this:\n  emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n   {p \\<in> space\n             (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n    \\<forall>y'\\<in>I x - {y}. ty < p y'} =\n  ennreal (exp (- ty * (escape_rate x - R x y)))", "show \"indicator {t..} ty * ?P' {p\\<in>space ?P'. \\<forall>y'\\<in>I x-{y}. ty < p y'} =\n      indicator {t..} ty * ennreal (exp (- ty * (escape_rate x - R x y)))\""], ["proof (prove)\nusing this:\n  emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n   {p \\<in> space\n             (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n    \\<forall>y'\\<in>I x - {y}. ty < p y'} =\n  ennreal (exp (- ty * (escape_rate x - R x y)))\n\ngoal (1 subgoal):\n 1. indicator {t..} ty *\n    emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n     {p \\<in> space\n               (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n      \\<forall>y'\\<in>I x - {y}. ty < p y'} =\n    indicator {t..} ty * ennreal (exp (- ty * (escape_rate x - R x y)))", "by simp"], ["proof (state)\nthis:\n  indicator {t..} ty *\n  emeasure (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y)))\n   {p \\<in> space\n             (Pi\\<^sub>M (I x - {y}) (\\<lambda>y. exponential (R x y))).\n    \\<forall>y'\\<in>I x - {y}. ty < p y'} =\n  indicator {t..} ty * ennreal (exp (- ty * (escape_rate x - R x y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          emeasure\n                           (Pi\\<^sub>M (I x - {y})\n                             (\\<lambda>y. exponential (R x y)))\n                           {p \\<in> space\n                                     (Pi\\<^sub>M (I x - {y})\n (\\<lambda>y. exponential (R x y))).\n                            \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                     \\<partial>exponential (R x y) =\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          ennreal (exp (- ty * (escape_rate x - R x y)))\n                     \\<partial>exponential (R x y)\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          emeasure\n                           (Pi\\<^sub>M (I x - {y})\n                             (\\<lambda>y. exponential (R x y)))\n                           {p \\<in> space\n                                     (Pi\\<^sub>M (I x - {y})\n (\\<lambda>y. exponential (R x y))).\n                            \\<forall>y'\\<in>I x - {y}. ty < p y'}\n                     \\<partial>exponential (R x y) =\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          ennreal (exp (- ty * (escape_rate x - R x y)))\n                     \\<partial>exponential (R x y)\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have \"\\<dots> = (\\<integral>\\<^sup>+ty. ennreal (R x y) * (ennreal (exp (- ty * escape_rate x)) * indicator {max 0 t..} ty) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                            ennreal (exp (- ty * (escape_rate x - R x y)))\n                       \\<partial>exponential (R x y) =\n    \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                            (ennreal (exp (- ty * escape_rate x)) *\n                             indicator {max 0 t..} ty)\n                       \\<partial>lborel", "by (auto simp add: exponential_def exponential_density_def nn_integral_density ennreal_mult[symmetric] exp_add[symmetric] field_simps\n                intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          ennreal (exp (- ty * (escape_rate x - R x y)))\n                     \\<partial>exponential (R x y) =\n  \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                          (ennreal (exp (- ty * escape_rate x)) *\n                           indicator {max 0 t..} ty)\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ty. indicator {t..} ty *\n                          ennreal (exp (- ty * (escape_rate x - R x y)))\n                     \\<partial>exponential (R x y) =\n  \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                          (ennreal (exp (- ty * escape_rate x)) *\n                           indicator {max 0 t..} ty)\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have \"\\<dots> = (R x y / escape_rate x) * emeasure (exponential (escape_rate x)) {max 0 t..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                            (ennreal (exp (- ty * escape_rate x)) *\n                             indicator {max 0 t..} ty)\n                       \\<partial>lborel =\n    ennreal (R x y / escape_rate x) *\n    emeasure (exponential (escape_rate x)) {max 0 t..}", "using escape_rate_pos[of x]"], ["proof (prove)\nusing this:\n  0 < escape_rate x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                            (ennreal (exp (- ty * escape_rate x)) *\n                             indicator {max 0 t..} ty)\n                       \\<partial>lborel =\n    ennreal (R x y / escape_rate x) *\n    emeasure (exponential (escape_rate x)) {max 0 t..}", "by (auto simp: exponential_def exponential_density_def emeasure_density nn_integral_cmult[symmetric] ennreal_mult[symmetric]\n             split: split_indicator intro!: nn_integral_cong )"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                          (ennreal (exp (- ty * escape_rate x)) *\n                           indicator {max 0 t..} ty)\n                     \\<partial>lborel =\n  ennreal (R x y / escape_rate x) *\n  emeasure (exponential (escape_rate x)) {max 0 t..}\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ty. ennreal (R x y) *\n                          (ennreal (exp (- ty * escape_rate x)) *\n                           indicator {max 0 t..} ty)\n                     \\<partial>lborel =\n  ennreal (R x y / escape_rate x) *\n  emeasure (exponential (escape_rate x)) {max 0 t..}\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "have \"\\<dots> = pmf (J x) y * emeasure (exponential (escape_rate x)) {t..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (R x y / escape_rate x) *\n    emeasure (exponential (escape_rate x)) {max 0 t..} =\n    ennreal (pmf (J x) y) * emeasure (exponential (escape_rate x)) {t..}", "using AE_exponential[OF escape_rate_pos[of x]]"], ["proof (prove)\nusing this:\n  almost_everywhere (exponential (escape_rate x)) ((<) 0)\n\ngoal (1 subgoal):\n 1. ennreal (R x y / escape_rate x) *\n    emeasure (exponential (escape_rate x)) {max 0 t..} =\n    ennreal (pmf (J x) y) * emeasure (exponential (escape_rate x)) {t..}", "by (intro arg_cong2[where f=\"(*)\"] emeasure_eq_AE) (auto simp: J.rep_eq )"], ["proof (state)\nthis:\n  ennreal (R x y / escape_rate x) *\n  emeasure (exponential (escape_rate x)) {max 0 t..} =\n  ennreal (pmf (J x) y) * emeasure (exponential (escape_rate x)) {t..}\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "finally"], ["proof (chain)\npicking this:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x).\n    t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n  ennreal (pmf (J x) y) * emeasure (exponential (escape_rate x)) {t..}", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x).\n    t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n  ennreal (pmf (J x) y) * emeasure (exponential (escape_rate x)) {t..}\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "using assms"], ["proof (prove)\nusing this:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x).\n    t \\<le> p y \\<and> (\\<forall>y'\\<in>I x - {y}. p y < p y')} =\n  ennreal (pmf (J x) y) * emeasure (exponential (escape_rate x)) {t..}\n  y \\<in> I x\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n    emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)", "by (simp add: mult_ac select_first_def)"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x). t \\<le> p y \\<and> select_first x p y} =\n  emeasure (exponential (escape_rate x)) {t..} * ennreal (pmf (J x) y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_PAR_least: \"AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have D: \"disjoint_family_on (\\<lambda>y. {p \\<in> space (PAR x). select_first x p y}) (I x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_family_on\n     (\\<lambda>y. {p \\<in> space (PAR x). select_first x p y}) (I x)", "by (auto simp: disjoint_family_on_def dest: select_first_unique)"], ["proof (state)\nthis:\n  disjoint_family_on\n   (\\<lambda>y. {p \\<in> space (PAR x). select_first x p y}) (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have \"PAR x {p\\<in>space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n    PAR x (\\<Union>y\\<in>I x. {p\\<in>space (PAR x). select_first x p y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     {p \\<in> space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n    emeasure (PAR x)\n     (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y})", "by (auto intro!: arg_cong2[where f=emeasure])"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n  emeasure (PAR x)\n   (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y})\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "also"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n  emeasure (PAR x)\n   (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y})\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have \"\\<dots> = (\\<integral>\\<^sup>+y. PAR x {p\\<in>space (PAR x). select_first x p y} \\<partial>count_space (I x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y}) =\n    \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                            {p \\<in> space (PAR x). select_first x p y}\n                       \\<partial>count_space (I x)", "using I_countable"], ["proof (prove)\nusing this:\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y}) =\n    \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                            {p \\<in> space (PAR x). select_first x p y}\n                       \\<partial>count_space (I x)", "by (intro emeasure_UN_countable D) auto"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y}) =\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x). select_first x p y}\n                     \\<partial>count_space (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "also"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   (\\<Union>y\\<in>I x. {p \\<in> space (PAR x). select_first x p y}) =\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x). select_first x p y}\n                     \\<partial>count_space (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have \"\\<dots> = (\\<integral>\\<^sup>+y. PAR x {p\\<in>space (PAR x). 0 \\<le> p y \\<and> select_first x p y} \\<partial>count_space (I x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                            {p \\<in> space (PAR x). select_first x p y}\n                       \\<partial>count_space (I x) =\n    \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                            {p \\<in> space (PAR x).\n                             0 \\<le> p y \\<and> select_first x p y}\n                       \\<partial>count_space (I x)", "proof (intro nn_integral_cong emeasure_eq_AE, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       AE xb in PAR x. (xb \\<in> {p \\<in> space (PAR x).\n                                  select_first x p xa}) =\n                       (xb \\<in> {p \\<in> space (PAR x).\n                                  0 \\<le> p xa \\<and> select_first x p xa})\n 2. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       {p \\<in> space (PAR x). select_first x p xa} \\<in> sets (PAR x)\n 3. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       {p \\<in> space (PAR x). 0 \\<le> p xa \\<and> select_first x p xa}\n       \\<in> sets (PAR x)", "case (1 y)"], ["proof (state)\nthis:\n  y \\<in> space (count_space (I x))\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       AE xb in PAR x. (xb \\<in> {p \\<in> space (PAR x).\n                                  select_first x p xa}) =\n                       (xb \\<in> {p \\<in> space (PAR x).\n                                  0 \\<le> p xa \\<and> select_first x p xa})\n 2. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       {p \\<in> space (PAR x). select_first x p xa} \\<in> sets (PAR x)\n 3. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       {p \\<in> space (PAR x). 0 \\<le> p xa \\<and> select_first x p xa}\n       \\<in> sets (PAR x)", "with AE_PiM_component[of \"I x\" \"\\<lambda>y. exponential (R x y)\" y \"(<) 0\"] AE_exponential[of \"R x y\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>i.\n              i \\<in> I x \\<Longrightarrow>\n              prob_space (exponential (R x i));\n   y \\<in> I x; almost_everywhere (exponential (R x y)) ((<) 0)\\<rbrakk>\n  \\<Longrightarrow> AE x in PAR x. 0 < x y\n  0 < R x y \\<Longrightarrow>\n  almost_everywhere (exponential (R x y)) ((<) 0)\n  y \\<in> space (count_space (I x))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>i.\n              i \\<in> I x \\<Longrightarrow>\n              prob_space (exponential (R x i));\n   y \\<in> I x; almost_everywhere (exponential (R x y)) ((<) 0)\\<rbrakk>\n  \\<Longrightarrow> AE x in PAR x. 0 < x y\n  0 < R x y \\<Longrightarrow>\n  almost_everywhere (exponential (R x y)) ((<) 0)\n  y \\<in> space (count_space (I x))\n\ngoal (1 subgoal):\n 1. AE xa in PAR x. (xa \\<in> {p \\<in> space (PAR x). select_first x p y}) =\n                    (xa \\<in> {p \\<in> space (PAR x).\n                               0 \\<le> p y \\<and> select_first x p y})", "by (auto simp: prob_space_exponential)"], ["proof (state)\nthis:\n  AE xa in PAR x. (xa \\<in> {p \\<in> space (PAR x). select_first x p y}) =\n                  (xa \\<in> {p \\<in> space (PAR x).\n                             0 \\<le> p y \\<and> select_first x p y})\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       {p \\<in> space (PAR x). select_first x p xa} \\<in> sets (PAR x)\n 2. \\<And>xa.\n       xa \\<in> space (count_space (I x)) \\<Longrightarrow>\n       {p \\<in> space (PAR x). 0 \\<le> p xa \\<and> select_first x p xa}\n       \\<in> sets (PAR x)", "qed (insert I_countable, auto)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x). select_first x p y}\n                     \\<partial>count_space (I x) =\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x).\n                           0 \\<le> p y \\<and> select_first x p y}\n                     \\<partial>count_space (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x). select_first x p y}\n                     \\<partial>count_space (I x) =\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x).\n                           0 \\<le> p y \\<and> select_first x p y}\n                     \\<partial>count_space (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have \"\\<dots> = (\\<integral>\\<^sup>+y. emeasure (exponential (escape_rate x)) {0 ..} * ennreal (pmf (J x) y) \\<partial>count_space (I x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                            {p \\<in> space (PAR x).\n                             0 \\<le> p y \\<and> select_first x p y}\n                       \\<partial>count_space (I x) =\n    \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..} *\n                           ennreal (pmf (J x) y)\n                       \\<partial>count_space (I x)", "by (auto simp add: PAR_least intro!: nn_integral_cong)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x).\n                           0 \\<le> p y \\<and> select_first x p y}\n                     \\<partial>count_space (I x) =\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..} *\n                         ennreal (pmf (J x) y)\n                     \\<partial>count_space (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (PAR x)\n                          {p \\<in> space (PAR x).\n                           0 \\<le> p y \\<and> select_first x p y}\n                     \\<partial>count_space (I x) =\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..} *\n                         ennreal (pmf (J x) y)\n                     \\<partial>count_space (I x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have \"\\<dots> = (\\<integral>\\<^sup>+y. emeasure (exponential (escape_rate x)) {0 ..} \\<partial>J x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..} *\n                           ennreal (pmf (J x) y)\n                       \\<partial>count_space (I x) =\n    \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..}\n                       \\<partial>measure_pmf (J x)", "by (auto simp: nn_integral_measure_pmf nn_integral_count_space_indicator ac_simps pmf_eq_0_set_pmf set_pmf_J\n             simp del: nn_integral_const intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..} *\n                         ennreal (pmf (J x) y)\n                     \\<partial>count_space (I x) =\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..}\n                     \\<partial>measure_pmf (J x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..} *\n                         ennreal (pmf (J x) y)\n                     \\<partial>count_space (I x) =\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..}\n                     \\<partial>measure_pmf (J x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..}\n                       \\<partial>measure_pmf (J x) =\n    1", "using AE_exponential[of \"escape_rate x\"]"], ["proof (prove)\nusing this:\n  0 < escape_rate x \\<Longrightarrow>\n  almost_everywhere (exponential (escape_rate x)) ((<) 0)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..}\n                       \\<partial>measure_pmf (J x) =\n    1", "by (auto intro!: prob_space.emeasure_eq_1_AE prob_space_exponential simp: escape_rate_pos less_imp_le)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (exponential (escape_rate x)) {0..}\n                     \\<partial>measure_pmf (J x) =\n  1\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "finally"], ["proof (chain)\npicking this:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n  1\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "using I_countable"], ["proof (prove)\nusing this:\n  emeasure (PAR x)\n   {p \\<in> space (PAR x). \\<exists>y\\<in>I x. select_first x p y} =\n  1\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y", "by (subst prob_space.AE_iff_emeasure_eq_1 prob_space_PiM prob_space_exponential)\n       (auto intro!: prob_space_PiM prob_space_exponential simp del: Set.bex_simps(6))"], ["proof (state)\nthis:\n  AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_alt: \"K (t, x) = distr (\\<Pi>\\<^sub>M y\\<in>I x. exponential (R x y)) S (\\<lambda>p. (t + (INF y\\<in>I x. p y), The (select_first x p)))\" (is \"_ = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, x) =\n    distr (PAR x) S\n     (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))", "proof (rule measure_eqI_generator_eq_countable)"], ["proof (state)\ngoal (9 subgoals):\n 1. Int_stable ?E\n 2. ?E \\<subseteq> Pow ?\\<Omega>\n 3. \\<And>X.\n       X \\<in> ?E \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 4. sets (K (t, x)) = sigma_sets ?\\<Omega> ?E\n 5. sets\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n    sigma_sets ?\\<Omega> ?E\n 6. ?A \\<subseteq> ?E\n 7. \\<Union> ?A = ?\\<Omega>\n 8. countable ?A\n 9. \\<And>a.\n       a \\<in> ?A \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "let ?E = \"{ {t ..} \\<times> A | (t::real) A. A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s}) }\""], ["proof (state)\ngoal (9 subgoals):\n 1. Int_stable ?E\n 2. ?E \\<subseteq> Pow ?\\<Omega>\n 3. \\<And>X.\n       X \\<in> ?E \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 4. sets (K (t, x)) = sigma_sets ?\\<Omega> ?E\n 5. sets\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n    sigma_sets ?\\<Omega> ?E\n 6. ?A \\<subseteq> ?E\n 7. \\<Union> ?A = ?\\<Omega>\n 8. countable ?A\n 9. \\<And>a.\n       a \\<in> ?A \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "show \"Int_stable ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Int_stable\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "apply (auto simp: Int_stable_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t A ta Aa.\n       \\<lbrakk>A \\<subseteq> - I x; Aa \\<subseteq> - I x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tb Ab.\n                            {t..} \\<times> A \\<inter> {ta..} \\<times> Aa =\n                            {tb..} \\<times> Ab \\<and>\n                            (Ab \\<subseteq> - I x \\<or>\n                             (\\<exists>s. 0 < R x s \\<and> Ab = {s}))\n 2. \\<And>t ta s sa.\n       \\<lbrakk>0 < R x s; 0 < R x sa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tb A.\n                            {t..} \\<times> {s} \\<inter>\n                            {ta..} \\<times> {sa} =\n                            {tb..} \\<times> A \\<and>\n                            (A \\<subseteq> - I x \\<or>\n                             (\\<exists>s. 0 < R x s \\<and> A = {s}))", "subgoal for t1 A1 t2 A2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A1 \\<subseteq> - I x; A2 \\<subseteq> - I x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t A.\n                         {t1..} \\<times> A1 \\<inter> {t2..} \\<times> A2 =\n                         {t..} \\<times> A \\<and>\n                         (A \\<subseteq> - I x \\<or>\n                          (\\<exists>s. 0 < R x s \\<and> A = {s}))", "by (intro exI[of _ \"max t1 t2\"] exI[of _ \"A1 \\<inter> A2\"]) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t ta s sa.\n       \\<lbrakk>0 < R x s; 0 < R x sa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tb A.\n                            {t..} \\<times> {s} \\<inter>\n                            {ta..} \\<times> {sa} =\n                            {tb..} \\<times> A \\<and>\n                            (A \\<subseteq> - I x \\<or>\n                             (\\<exists>s. 0 < R x s \\<and> A = {s}))", "subgoal for t1 t2 y1 y2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < R x y1; 0 < R x y2\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t A.\n                         {t1..} \\<times> {y1} \\<inter>\n                         {t2..} \\<times> {y2} =\n                         {t..} \\<times> A \\<and>\n                         (A \\<subseteq> - I x \\<or>\n                          (\\<exists>s. 0 < R x s \\<and> A = {s}))", "by (intro exI[of _ \"max t1 t2\"] exI[of _ \"{y1} \\<inter> {y2}\"]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Int_stable\n   {{t..} \\<times> A |t A.\n    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n\ngoal (8 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow ?\\<Omega>\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. sets (K (t, x)) =\n    sigma_sets ?\\<Omega>\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. sets\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n    sigma_sets ?\\<Omega>\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 5. ?A \\<subseteq> {{t..} \\<times> A |t A.\n                    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 6. \\<Union> ?A = ?\\<Omega>\n 7. countable ?A\n 8. \\<And>a.\n       a \\<in> ?A \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "show \"sets (K (t, x)) = sigma_sets UNIV ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (K (t, x)) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "unfolding K.sets_K[OF in_space_S]"], ["proof (prove)\ngoal (1 subgoal):\n 1. sets S =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "by (subst sets_S_eq) rule"], ["proof (state)\nthis:\n  sets (K (t, x)) =\n  sigma_sets UNIV\n   {{t..} \\<times> A |t A.\n    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n\ngoal (7 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. sets\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. ?A \\<subseteq> {{t..} \\<times> A |t A.\n                    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 5. \\<Union> ?A = UNIV\n 6. countable ?A\n 7. \\<And>a.\n       a \\<in> ?A \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "show \"sets ?R = sigma_sets UNIV ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "using sets_S_eq"], ["proof (prove)\nusing this:\n  sets S =\n  sigma_sets UNIV\n   {{t..} \\<times> A |t A.\n    A \\<subseteq> - I ?x \\<or> (\\<exists>s\\<in>I ?x. A = {s})}\n\ngoal (1 subgoal):\n 1. sets\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n    sigma_sets UNIV\n     {{t..} \\<times> A |t A.\n      A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "by simp"], ["proof (state)\nthis:\n  sets\n   (distr (PAR x) S\n     (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p)))) =\n  sigma_sets UNIV\n   {{t..} \\<times> A |t A.\n    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n\ngoal (6 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. ?A \\<subseteq> {{t..} \\<times> A |t A.\n                    A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. \\<Union> ?A = UNIV\n 5. countable ?A\n 6. \\<And>a.\n       a \\<in> ?A \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "show \"countable ((\\<lambda>(t, A). {t ..} \\<times> A) ` (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable\n     ((\\<lambda>(t, A). {t..} \\<times> A) `\n      (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x)))", "by (intro countable_image countable_SIGMA countable_rat countable_Un I_countable) auto"], ["proof (state)\nthis:\n  countable\n   ((\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x)))\n\ngoal (5 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 5. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "have *: \"(+) t -` {t'..} \\<inter> space (exponential (escape_rate x)) = {t' - t..}\" for t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) t -` {t'..} \\<inter> space (exponential (escape_rate x)) =\n    {t' - t..}", "by (auto simp: space_exponential)"], ["proof (state)\nthis:\n  (+) t -` {?t'2..} \\<inter> space (exponential (escape_rate x)) =\n  {?t'2 - t..}\n\ngoal (5 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 5. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "{"], ["proof (state)\nthis:\n  (+) t -` {?t'2..} \\<inter> space (exponential (escape_rate x)) =\n  {?t'2 - t..}\n\ngoal (5 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 5. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "fix X"], ["proof (state)\ngoal (5 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 5. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "assume \"X \\<in> ?E\""], ["proof (state)\nthis:\n  X \\<in> {{t..} \\<times> A |t A.\n           A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n\ngoal (5 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 5. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  X \\<in> {{t..} \\<times> A |t A.\n           A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}", "consider\n        t' s where \"s \\<in> I x\" \"X = {t' ..} \\<times> {s}\"\n      | t' A where \"A \\<subseteq> - I x\" \"X = {t' ..} \\<times> A\""], ["proof (prove)\nusing this:\n  X \\<in> {{t..} \\<times> A |t A.\n           A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s t'.\n                \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>A t'.\n        \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>t' s.\n              \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n              \\<Longrightarrow> ?thesis2;\n   \\<And>t' A.\n      \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n      \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (5 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. \\<And>X.\n       X \\<in> {{t..} \\<times> A |t A.\n                A \\<subseteq> - I x \\<or>\n                (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n       emeasure (K (t, x)) X =\n       emeasure\n        (distr (PAR x) S\n          (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n        X\n 3. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 4. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 5. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>t' s.\n              \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n              \\<Longrightarrow> ?thesis2;\n   \\<And>t' A.\n      \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n      \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2", "show \"K (t, x) X = ?R X\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>t' s.\n              \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n              \\<Longrightarrow> ?thesis2;\n   \\<And>t' A.\n      \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n      \\<Longrightarrow> ?thesis2\\<rbrakk>\n  \\<Longrightarrow> ?thesis2\n\ngoal (1 subgoal):\n 1. emeasure (K (t, x)) X =\n    emeasure\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n     X", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t' s.\n       \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X\n 2. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "case 1"], ["proof (state)\nthis:\n  s \\<in> I x\n  X = {t'..} \\<times> {s}\n\ngoal (2 subgoals):\n 1. \\<And>t' s.\n       \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X\n 2. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "have \"AE p in PAR x. (t' - t \\<le> p s \\<and> select_first x p s) =\n              (t' \\<le> t + (\\<Sqinter>x\\<in>I x. p x) \\<and> The (select_first x p) = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE p in PAR x. (t' - t \\<le> p s \\<and> select_first x p s) =\n                   (t' \\<le> t + \\<Sqinter> (p ` I x) \\<and>\n                    The (select_first x p) = s)", "using AE_PAR_least"], ["proof (prove)\nusing this:\n  AE p in PAR ?x. \\<exists>y\\<in>I ?x. select_first ?x p y\n\ngoal (1 subgoal):\n 1. AE p in PAR x. (t' - t \\<le> p s \\<and> select_first x p s) =\n                   (t' \\<le> t + \\<Sqinter> (p ` I x) \\<and>\n                    The (select_first x p) = s)", "by eventually_elim (auto dest: select_first_unique simp: select_first_INF)"], ["proof (state)\nthis:\n  AE p in PAR x. (t' - t \\<le> p s \\<and> select_first x p s) =\n                 (t' \\<le> t + \\<Sqinter> (p ` I x) \\<and>\n                  The (select_first x p) = s)\n\ngoal (2 subgoals):\n 1. \\<And>t' s.\n       \\<lbrakk>s \\<in> I x; X = {t'..} \\<times> {s}\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X\n 2. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "with 1 I_countable"], ["proof (chain)\npicking this:\n  s \\<in> I x\n  X = {t'..} \\<times> {s}\n  countable (I ?x)\n  AE p in PAR x. (t' - t \\<le> p s \\<and> select_first x p s) =\n                 (t' \\<le> t + \\<Sqinter> (p ` I x) \\<and>\n                  The (select_first x p) = s)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> I x\n  X = {t'..} \\<times> {s}\n  countable (I ?x)\n  AE p in PAR x. (t' - t \\<le> p s \\<and> select_first x p s) =\n                 (t' \\<le> t + \\<Sqinter> (p ` I x) \\<and>\n                  The (select_first x p) = s)\n\ngoal (1 subgoal):\n 1. emeasure (K (t, x)) X =\n    emeasure\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n     X", "by (auto simp add: K_def measure_pmf.emeasure_pair_measure_Times emeasure_distr emeasure_pmf_single *\n          PAR_least[symmetric] intro!: emeasure_eq_AE)"], ["proof (state)\nthis:\n  emeasure (K (t, x)) X =\n  emeasure\n   (distr (PAR x) S\n     (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n   X\n\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "case 2"], ["proof (state)\nthis:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A\n\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "moreover"], ["proof (state)\nthis:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A\n\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A", "have \"emeasure (measure_pmf (J x)) A = 0\""], ["proof (prove)\nusing this:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (J x)) A = 0", "by (subst AE_iff_measurable[symmetric, where P=\"\\<lambda>x. x \\<notin> A\"])\n           (auto simp: AE_measure_pmf_iff set_pmf_J subset_eq)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (J x)) A = 0\n\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "moreover"], ["proof (state)\nthis:\n  emeasure (measure_pmf (J x)) A = 0\n\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "have \"PAR x ((\\<lambda>p. (t + \\<Sqinter>(p ` (I x)), The (select_first x p))) -` ({t'..} \\<times> A) \\<inter> space (PAR x)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     ((\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))) -`\n      ({t'..} \\<times> A) \\<inter>\n      space (PAR x)) =\n    0", "using \\<open>A \\<subseteq> - I x\\<close> AE_PAR_least[of x] I_countable"], ["proof (prove)\nusing this:\n  A \\<subseteq> - I x\n  AE p in PAR x. \\<exists>y\\<in>I x. select_first x p y\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. emeasure (PAR x)\n     ((\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))) -`\n      ({t'..} \\<times> A) \\<inter>\n      space (PAR x)) =\n    0", "by (subst AE_iff_measurable[symmetric, where P=\"\\<lambda>p. (t + \\<Sqinter>(p ` (I x)), The (select_first x p)) \\<notin> {t'..} \\<times> A\"])\n           (auto simp del: all_simps(5) simp add: imp_ex imp_conjL subset_eq)"], ["proof (state)\nthis:\n  emeasure (PAR x)\n   ((\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))) -`\n    ({t'..} \\<times> A) \\<inter>\n    space (PAR x)) =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>t' A.\n       \\<lbrakk>A \\<subseteq> - I x; X = {t'..} \\<times> A\\<rbrakk>\n       \\<Longrightarrow> emeasure (K (t, x)) X =\n                         emeasure\n                          (distr (PAR x) S\n                            (\\<lambda>p.\n                                (t + \\<Sqinter> (p ` I x),\n                                 The (select_first x p))))\n                          X", "ultimately"], ["proof (chain)\npicking this:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A\n  emeasure (measure_pmf (J x)) A = 0\n  emeasure (PAR x)\n   ((\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))) -`\n    ({t'..} \\<times> A) \\<inter>\n    space (PAR x)) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A\n  emeasure (measure_pmf (J x)) A = 0\n  emeasure (PAR x)\n   ((\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))) -`\n    ({t'..} \\<times> A) \\<inter>\n    space (PAR x)) =\n  0\n\ngoal (1 subgoal):\n 1. emeasure (K (t, x)) X =\n    emeasure\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n     X", "using I_countable"], ["proof (prove)\nusing this:\n  A \\<subseteq> - I x\n  X = {t'..} \\<times> A\n  emeasure (measure_pmf (J x)) A = 0\n  emeasure (PAR x)\n   ((\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))) -`\n    ({t'..} \\<times> A) \\<inter>\n    space (PAR x)) =\n  0\n  countable (I ?x)\n\ngoal (1 subgoal):\n 1. emeasure (K (t, x)) X =\n    emeasure\n     (distr (PAR x) S\n       (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n     X", "by (simp add: K_def measure_pmf.emeasure_pair_measure_Times emeasure_distr *)"], ["proof (state)\nthis:\n  emeasure (K (t, x)) X =\n  emeasure\n   (distr (PAR x) S\n     (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n   X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (K (t, x)) X =\n  emeasure\n   (distr (PAR x) S\n     (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n   X\n\ngoal (4 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 3. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 4. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "}"], ["proof (state)\nthis:\n  ?X4\n  \\<in> {{t..} \\<times> A |t A.\n         A \\<subseteq> - I x \\<or>\n         (\\<exists>s\\<in>I x. A = {s})} \\<Longrightarrow>\n  emeasure (K (t, x)) ?X4 =\n  emeasure\n   (distr (PAR x) S\n     (\\<lambda>p. (t + \\<Sqinter> (p ` I x), The (select_first x p))))\n   ?X4\n\ngoal (4 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 3. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 4. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "interpret prob_space \"K ts\" for ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (K ts)", "by (rule K.prob_space_K) simp"], ["proof (state)\ngoal (4 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 3. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV\n 4. \\<And>a.\n       a \\<in> (\\<lambda>(t, A). {t..} \\<times> A) `\n               (\\<rat> \\<times>\n                ({- I x} \\<union>\n                 (\\<lambda>s. {s}) ` I x)) \\<Longrightarrow>\n       emeasure (K (t, x)) a \\<noteq> \\<infinity>", "show \"emeasure (K (t, x)) a \\<noteq> \\<infinity>\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K (t, x)) a \\<noteq> \\<infinity>", "using emeasure_finite"], ["proof (prove)\nusing this:\n  emeasure (K ?ts) ?A \\<noteq> \\<top>\n\ngoal (1 subgoal):\n 1. emeasure (K (t, x)) a \\<noteq> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  emeasure (K (t, x)) ?a2 \\<noteq> \\<infinity>\n\ngoal (3 subgoals):\n 1. {{t..} \\<times> A |t A.\n     A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n    \\<subseteq> Pow UNIV\n 2. (\\<lambda>(t, A). {t..} \\<times> A) `\n    (\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x))\n    \\<subseteq> {{t..} \\<times> A |t A.\n                 A \\<subseteq> - I x \\<or> (\\<exists>s\\<in>I x. A = {s})}\n 3. (\\<Union>(t,\n        A)\\<in>\\<rat> \\<times> ({- I x} \\<union> (\\<lambda>s. {s}) ` I x).\n        {t..} \\<times> A) =\n    UNIV", "qed (insert  Rats_dense_in_real[of \"x - 1\" x for x], auto, blast intro: less_imp_le)"], ["", "lemma AE_K: \"AE y in K x. fst x < fst y \\<and> snd y \\<in> J (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in K x. fst x < fst y \\<and> snd y \\<in> set_pmf (J (snd x))", "unfolding K_def split_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in distr (exponential (escape_rate (snd x))) borel\n             ((+) (fst x)) \\<Otimes>\\<^sub>M\n            measure_pmf\n             (J (snd x)). fst x < fst y \\<and>\n                          snd y \\<in> set_pmf (J (snd x))", "apply (subst exp_esc.AE_pair_iff[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. {xa \\<in> space\n               (distr (exponential (escape_rate (snd x))) borel\n                 ((+) (fst x)) \\<Otimes>\\<^sub>M\n                measure_pmf (J (snd x))).\n     fst x < fst xa \\<and> snd xa \\<in> set_pmf (J (snd x))}\n    \\<in> exp_esc.events (snd x) (fst x)\n 2. AE xa in distr (exponential (escape_rate (snd x))) borel\n              ((+) (fst x)). AE y in measure_pmf\n(J (snd x)). fst x < xa \\<and> y \\<in> set_pmf (J (snd x))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE xa in distr (exponential (escape_rate (snd x))) borel\n              ((+) (fst x)). AE y in measure_pmf\n(J (snd x)). fst x < xa \\<and> y \\<in> set_pmf (J (snd x))", "apply (simp_all add: AE_distr_iff AE_measure_pmf_iff exponential_def AE_density exponential_density_def cong del: AE_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE xa in lborel. \\<not> xa < 0 \\<longrightarrow>\n                     0 < escape_rate (snd x) *\n                         exp (- (xa *\n                                 escape_rate (snd x))) \\<longrightarrow>\n                     0 < xa", "using AE_lborel_singleton[of 0]"], ["proof (prove)\nusing this:\n  AE x in lborel. x \\<noteq> (0::?'b1)\n\ngoal (1 subgoal):\n 1. AE xa in lborel. \\<not> xa < 0 \\<longrightarrow>\n                     0 < escape_rate (snd x) *\n                         exp (- (xa *\n                                 escape_rate (snd x))) \\<longrightarrow>\n                     0 < xa", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<noteq> 0 \\<Longrightarrow>\n       \\<not> xa < 0 \\<longrightarrow>\n       0 < escape_rate (snd x) *\n           exp (- (xa * escape_rate (snd x))) \\<longrightarrow>\n       0 < xa", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma AE_lim_stream:\n  \"AE \\<omega> in K.lim_stream x. \\<forall>i. snd ((x ## \\<omega>) !! i) \\<in> DTMC.acc``{snd x} \\<and> snd (\\<omega> !! i) \\<in> J (snd ((x ## \\<omega>) !! i)) \\<and> fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\"\n  (is \"AE \\<omega> in K.lim_stream x. \\<forall>i. ?P \\<omega> i\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    x. \\<forall>i.\n                          snd ((x ## \\<omega>) !! i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                          fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "unfolding AE_all_countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                          fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                          fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "let ?F = \"\\<lambda>i x \\<omega>. fst ((x ## \\<omega>) !! i)\" and ?S = \"\\<lambda>i x \\<omega>. snd ((x ## \\<omega>) !! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                          fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                          fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "show \"AE \\<omega> in K.lim_stream x. ?P \\<omega> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    x. snd ((x ## \\<omega>) !! i)\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                             {snd x} \\<and>\n                       snd (\\<omega> !! i)\n                       \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                       fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "proof (induction i arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! 0)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! 0)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! 0))) \\<and>\n                          fst ((x ## \\<omega>) !! 0) < fst (\\<omega> !! 0)\n 2. \\<And>i x.\n       (\\<And>x.\n           AE \\<omega> in K.lim_stream\n                           x. snd ((x ## \\<omega>) !! i)\n                              \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                    {snd x} \\<and>\n                              snd (\\<omega> !! i)\n                              \\<in> set_pmf\n                                     (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                              fst ((x ## \\<omega>) !! i)\n                              < fst (\\<omega> !! i)) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! Suc i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! Suc i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                          fst ((x ## \\<omega>) !! Suc i)\n                          < fst (\\<omega> !! Suc i)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! 0)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! 0)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! 0))) \\<and>\n                          fst ((x ## \\<omega>) !! 0) < fst (\\<omega> !! 0)\n 2. \\<And>i x.\n       (\\<And>x.\n           AE \\<omega> in K.lim_stream\n                           x. snd ((x ## \\<omega>) !! i)\n                              \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                    {snd x} \\<and>\n                              snd (\\<omega> !! i)\n                              \\<in> set_pmf\n                                     (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                              fst ((x ## \\<omega>) !! i)\n                              < fst (\\<omega> !! i)) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! Suc i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! Suc i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                          fst ((x ## \\<omega>) !! Suc i)\n                          < fst (\\<omega> !! Suc i)", "with AE_K[of x]"], ["proof (chain)\npicking this:\n  AE y in K x. fst x < fst y \\<and> snd y \\<in> set_pmf (J (snd x))", "show ?case"], ["proof (prove)\nusing this:\n  AE y in K x. fst x < fst y \\<and> snd y \\<in> set_pmf (J (snd x))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    x. snd ((x ## \\<omega>) !! 0)\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                             {snd x} \\<and>\n                       snd (\\<omega> !! 0)\n                       \\<in> set_pmf (J (snd ((x ## \\<omega>) !! 0))) \\<and>\n                       fst ((x ## \\<omega>) !! 0) < fst (\\<omega> !! 0)", "by (subst K.AE_lim_stream) (auto simp add: space_pair_measure cong del: AE_cong)"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream\n                  x. snd ((x ## \\<omega>) !! 0)\n                     \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                           {snd x} \\<and>\n                     snd (\\<omega> !! 0)\n                     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! 0))) \\<and>\n                     fst ((x ## \\<omega>) !! 0) < fst (\\<omega> !! 0)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       (\\<And>x.\n           AE \\<omega> in K.lim_stream\n                           x. snd ((x ## \\<omega>) !! i)\n                              \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                    {snd x} \\<and>\n                              snd (\\<omega> !! i)\n                              \\<in> set_pmf\n                                     (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                              fst ((x ## \\<omega>) !! i)\n                              < fst (\\<omega> !! i)) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! Suc i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! Suc i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                          fst ((x ## \\<omega>) !! Suc i)\n                          < fst (\\<omega> !! Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       (\\<And>x.\n           AE \\<omega> in K.lim_stream\n                           x. snd ((x ## \\<omega>) !! i)\n                              \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                    {snd x} \\<and>\n                              snd (\\<omega> !! i)\n                              \\<in> set_pmf\n                                     (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                              fst ((x ## \\<omega>) !! i)\n                              < fst (\\<omega> !! i)) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! Suc i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! Suc i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                          fst ((x ## \\<omega>) !! Suc i)\n                          < fst (\\<omega> !! Suc i)", "case (Suc i)"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream\n                  ?x2. snd ((?x2 ## \\<omega>) !! i)\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                             {snd ?x2} \\<and>\n                       snd (\\<omega> !! i)\n                       \\<in> set_pmf\n                              (J (snd ((?x2 ## \\<omega>) !! i))) \\<and>\n                       fst ((?x2 ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. \\<And>i x.\n       (\\<And>x.\n           AE \\<omega> in K.lim_stream\n                           x. snd ((x ## \\<omega>) !! i)\n                              \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                    {snd x} \\<and>\n                              snd (\\<omega> !! i)\n                              \\<in> set_pmf\n                                     (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                              fst ((x ## \\<omega>) !! i)\n                              < fst (\\<omega> !! i)) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       x. snd ((x ## \\<omega>) !! Suc i)\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                {snd x} \\<and>\n                          snd (\\<omega> !! Suc i)\n                          \\<in> set_pmf\n                                 (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                          fst ((x ## \\<omega>) !! Suc i)\n                          < fst (\\<omega> !! Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    x. snd ((x ## \\<omega>) !! Suc i)\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                             {snd x} \\<and>\n                       snd (\\<omega> !! Suc i)\n                       \\<in> set_pmf\n                              (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                       fst ((x ## \\<omega>) !! Suc i)\n                       < fst (\\<omega> !! Suc i)", "proof (subst K.AE_lim_stream, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<in> space S\n 2. Measurable.pred (stream_space S)\n     (\\<lambda>\\<omega>.\n         snd ((x ## \\<omega>) !! Suc i)\n         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd x} \\<and>\n         snd (\\<omega> !! Suc i)\n         \\<in> set_pmf (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n         fst ((x ## \\<omega>) !! Suc i) < fst (\\<omega> !! Suc i))\n 3. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {snd x} \\<and>\n                                    snd ((y ## \\<omega>) !! Suc i)\n                                    \\<in> set_pmf\n     (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                    fst ((x ## y ## \\<omega>) !! Suc i)\n                                    < fst ((y ## \\<omega>) !! Suc i)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. x \\<in> space S\n 2. Measurable.pred (stream_space S)\n     (\\<lambda>\\<omega>.\n         snd ((x ## \\<omega>) !! Suc i)\n         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd x} \\<and>\n         snd (\\<omega> !! Suc i)\n         \\<in> set_pmf (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n         fst ((x ## \\<omega>) !! Suc i) < fst (\\<omega> !! Suc i))\n 3. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {snd x} \\<and>\n                                    snd ((y ## \\<omega>) !! Suc i)\n                                    \\<in> set_pmf\n     (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                    fst ((x ## y ## \\<omega>) !! Suc i)\n                                    < fst ((y ## \\<omega>) !! Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space S)\n     (\\<lambda>\\<omega>.\n         snd ((x ## \\<omega>) !! Suc i)\n         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd x} \\<and>\n         snd (\\<omega> !! Suc i)\n         \\<in> set_pmf (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n         fst ((x ## \\<omega>) !! Suc i) < fst (\\<omega> !! Suc i))", "using DTMC.countable_reachable"], ["proof (prove)\nusing this:\n  countable ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {?s})\n\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space S)\n     (\\<lambda>\\<omega>.\n         snd ((x ## \\<omega>) !! Suc i)\n         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd x} \\<and>\n         snd (\\<omega> !! Suc i)\n         \\<in> set_pmf (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n         fst ((x ## \\<omega>) !! Suc i) < fst (\\<omega> !! Suc i))", "by (intro measurable_compose_countable_restrict[where f=\"?S (Suc i) x\"])\n           (simp_all del: Image_singleton_iff)"], ["proof (state)\nthis:\n  Measurable.pred (stream_space S)\n   (\\<lambda>\\<omega>.\n       snd ((x ## \\<omega>) !! Suc i)\n       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd x} \\<and>\n       snd (\\<omega> !! Suc i)\n       \\<in> set_pmf (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n       fst ((x ## \\<omega>) !! Suc i) < fst (\\<omega> !! Suc i))\n\ngoal (2 subgoals):\n 1. x \\<in> space S\n 2. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {snd x} \\<and>\n                                    snd ((y ## \\<omega>) !! Suc i)\n                                    \\<in> set_pmf\n     (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                    fst ((x ## y ## \\<omega>) !! Suc i)\n                                    < fst ((y ## \\<omega>) !! Suc i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> space S\n 2. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {snd x} \\<and>\n                                    snd ((y ## \\<omega>) !! Suc i)\n                                    \\<in> set_pmf\n     (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                    fst ((x ## y ## \\<omega>) !! Suc i)\n                                    < fst ((y ## \\<omega>) !! Suc i)", "case 3"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. x \\<in> space S\n 2. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {snd x} \\<and>\n                                    snd ((y ## \\<omega>) !! Suc i)\n                                    \\<in> set_pmf\n     (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                    fst ((x ## y ## \\<omega>) !! Suc i)\n                                    < fst ((y ## \\<omega>) !! Suc i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {snd x} \\<and>\n                                    snd ((y ## \\<omega>) !! Suc i)\n                                    \\<in> set_pmf\n     (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                    fst ((x ## y ## \\<omega>) !! Suc i)\n                                    < fst ((y ## \\<omega>) !! Suc i)", "apply (simp del: AE_conj_iff cong del: AE_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. (snd x, snd ((y ## \\<omega>) !! i))\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* \\<and>\n                                    snd (\\<omega> !! i)\n                                    \\<in> set_pmf\n     (J (snd ((y ## \\<omega>) !! i))) \\<and>\n                                    fst ((y ## \\<omega>) !! i)\n                                    < fst (\\<omega> !! i)", "using AE_K[of x]"], ["proof (prove)\nusing this:\n  AE y in K x. fst x < fst y \\<and> snd y \\<in> set_pmf (J (snd x))\n\ngoal (1 subgoal):\n 1. AE y in K x. AE \\<omega> in K.lim_stream\n                                 y. (snd x, snd ((y ## \\<omega>) !! i))\n                                    \\<in> (SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* \\<and>\n                                    snd (\\<omega> !! i)\n                                    \\<in> set_pmf\n     (J (snd ((y ## \\<omega>) !! i))) \\<and>\n                                    fst ((y ## \\<omega>) !! i)\n                                    < fst (\\<omega> !! i)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       fst x < fst y \\<and>\n       snd y \\<in> set_pmf (J (snd x)) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       y. (snd x, snd ((y ## \\<omega>) !! i))\n                          \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* \\<and>\n                          snd (\\<omega> !! i)\n                          \\<in> set_pmf\n                                 (J (snd ((y ## \\<omega>) !! i))) \\<and>\n                          fst ((y ## \\<omega>) !! i) < fst (\\<omega> !! i)", "subgoal premises K_prems for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    y. (snd x, snd ((y ## \\<omega>) !! i))\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* \\<and>\n                       snd (\\<omega> !! i)\n                       \\<in> set_pmf (J (snd ((y ## \\<omega>) !! i))) \\<and>\n                       fst ((y ## \\<omega>) !! i) < fst (\\<omega> !! i)", "using Suc"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream\n                  ?x2. snd ((?x2 ## \\<omega>) !! i)\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                             {snd ?x2} \\<and>\n                       snd (\\<omega> !! i)\n                       \\<in> set_pmf\n                              (J (snd ((?x2 ## \\<omega>) !! i))) \\<and>\n                       fst ((?x2 ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    y. (snd x, snd ((y ## \\<omega>) !! i))\n                       \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* \\<and>\n                       snd (\\<omega> !! i)\n                       \\<in> set_pmf (J (snd ((y ## \\<omega>) !! i))) \\<and>\n                       fst ((y ## \\<omega>) !! i) < fst (\\<omega> !! i)", "by eventually_elim (insert K_prems, auto intro: converse_rtrancl_into_rtrancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AE y in K x. AE \\<omega> in K.lim_stream\n                               y. snd ((x ## y ## \\<omega>) !! Suc i)\n                                  \\<in> (SIGMA x:UNIV.\n      set_pmf (J x))\\<^sup>* ``\n  {snd x} \\<and>\n                                  snd ((y ## \\<omega>) !! Suc i)\n                                  \\<in> set_pmf\n   (J (snd ((x ## y ## \\<omega>) !! Suc i))) \\<and>\n                                  fst ((x ## y ## \\<omega>) !! Suc i)\n                                  < fst ((y ## \\<omega>) !! Suc i)\n\ngoal (1 subgoal):\n 1. x \\<in> space S", "qed (simp add: space_pair_measure)"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream\n                  x. snd ((x ## \\<omega>) !! Suc i)\n                     \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                           {snd x} \\<and>\n                     snd (\\<omega> !! Suc i)\n                     \\<in> set_pmf\n                            (J (snd ((x ## \\<omega>) !! Suc i))) \\<and>\n                     fst ((x ## \\<omega>) !! Suc i)\n                     < fst (\\<omega> !! Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream\n                  x. snd ((x ## \\<omega>) !! i)\n                     \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                           {snd x} \\<and>\n                     snd (\\<omega> !! i)\n                     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n                     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_merge_at[measurable]: \"(\\<lambda>(\\<omega>, \\<omega>'). merge_at \\<omega> j \\<omega>') \\<in> (T \\<Otimes>\\<^sub>M T) \\<rightarrow>\\<^sub>M T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(\\<omega>, \\<omega>'). merge_at \\<omega> j \\<omega>')\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          stream_space S", "proof (rule measurable_stream_space2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           (case x of\n            (\\<omega>, \\<omega>') \\<Rightarrow>\n              merge_at \\<omega> j \\<omega>') !!\n           n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "define F where \"F x n = (case x of (\\<omega>::(real \\<times> 'a) stream, \\<omega>') \\<Rightarrow> merge_at \\<omega> j \\<omega>') !! n\" for x n"], ["proof (state)\nthis:\n  F ?x ?n =\n  (case ?x of\n   (\\<omega>, \\<omega>') \\<Rightarrow> merge_at \\<omega> j \\<omega>') !!\n  ?n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           (case x of\n            (\\<omega>, \\<omega>') \\<Rightarrow>\n              merge_at \\<omega> j \\<omega>') !!\n           n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           (case x of\n            (\\<omega>, \\<omega>') \\<Rightarrow>\n              merge_at \\<omega> j \\<omega>') !!\n           n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "have \"(\\<lambda>x. F x n) \\<in> stream_space S \\<Otimes>\\<^sub>M stream_space S \\<rightarrow>\\<^sub>M S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. F x n)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x. F x 0)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S\n 2. \\<And>n.\n       (\\<lambda>x. F x n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S \\<Longrightarrow>\n       (\\<lambda>x. F x (Suc n))\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (\\<lambda>x. F x 0)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S\n 2. \\<And>n.\n       (\\<lambda>x. F x n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S \\<Longrightarrow>\n       (\\<lambda>x. F x (Suc n))\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. F x 0)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S", "by (simp add: F_def split_beta' stream.case_eq_if)"], ["proof (state)\nthis:\n  (\\<lambda>x. F x 0)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x. F x n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S \\<Longrightarrow>\n       (\\<lambda>x. F x (Suc n))\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x. F x n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S \\<Longrightarrow>\n       (\\<lambda>x. F x (Suc n))\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "case (Suc n)"], ["proof (state)\nthis:\n  (\\<lambda>x. F x n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x. F x n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S \\<Longrightarrow>\n       (\\<lambda>x. F x (Suc n))\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "from Suc[measurable]"], ["proof (chain)\npicking this:\n  (\\<lambda>x. F x n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S", "have eq: \"F x (Suc n) = (case fst x of (t, s) ## \\<omega> \\<Rightarrow> if t \\<le> j then F (\\<omega>, snd x) n else snd x !! Suc n)\" for x"], ["proof (prove)\nusing this:\n  (\\<lambda>x. F x n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal (1 subgoal):\n 1. F x (Suc n) =\n    (case fst x of\n     (t, s) ## \\<omega> \\<Rightarrow>\n       if t \\<le> j then F (\\<omega>, snd x) n else snd x !! Suc n)", "by (auto simp: F_def split: prod.split stream.split)"], ["proof (state)\nthis:\n  F ?x1 (Suc n) =\n  (case fst ?x1 of\n   (t, s) ## \\<omega> \\<Rightarrow>\n     if t \\<le> j then F (\\<omega>, snd ?x1) n else snd ?x1 !! Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x. F x n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S \\<Longrightarrow>\n       (\\<lambda>x. F x (Suc n))\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. F x (Suc n))\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S", "unfolding eq stream.case_eq_if"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case shd (fst x) of\n        (t, s) \\<Rightarrow>\n          if t \\<le> j then F (stl (fst x), snd x) n else snd x !! Suc n)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S", "by measurable"], ["proof (state)\nthis:\n  (\\<lambda>x. F x (Suc n))\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. F x n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (\\<lambda>x.\n           (case x of\n            (\\<omega>, \\<omega>') \\<Rightarrow>\n              merge_at \\<omega> j \\<omega>') !!\n           n)\n       \\<in> stream_space S \\<Otimes>\\<^sub>M\n             stream_space S \\<rightarrow>\\<^sub>M\n             S", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. F x n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S", "show \"(\\<lambda>x. (case x of (\\<omega>, \\<omega>') \\<Rightarrow> merge_at \\<omega> j \\<omega>') !! n) \\<in> stream_space S \\<Otimes>\\<^sub>M stream_space S \\<rightarrow>\\<^sub>M S\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. F x n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (case x of\n         (\\<omega>, \\<omega>') \\<Rightarrow>\n           merge_at \\<omega> j \\<omega>') !!\n        n)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S", "unfolding F_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      (case x of (\\<omega>, x) \\<Rightarrow> merge_at \\<omega> j x) !! n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        (case x of\n         (\\<omega>, \\<omega>') \\<Rightarrow>\n           merge_at \\<omega> j \\<omega>') !!\n        n)\n    \\<in> stream_space S \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          S", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      (case x of\n       (\\<omega>, \\<omega>') \\<Rightarrow> merge_at \\<omega> j \\<omega>') !!\n      n)\n  \\<in> stream_space S \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_trace_at[measurable]: \"(\\<lambda>(s, \\<omega>). trace_at s \\<omega> j) \\<in> (count_space UNIV \\<Otimes>\\<^sub>M T) \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, \\<omega>). trace_at s \\<omega> j)\n    \\<in> count_space UNIV \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          count_space UNIV", "unfolding trace_at_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, \\<omega>).\n        case sfirst (\\<lambda>x. j < fst (shd x)) \\<omega> of\n        enat x \\<Rightarrow> (s ## smap snd \\<omega>) !! x)\n    \\<in> count_space UNIV \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          count_space UNIV", "by measurable"], ["", "lemma measurable_trace_at': \"(\\<lambda>((s, j), \\<omega>). trace_at s \\<omega> j) \\<in> ((count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M T) \\<rightarrow>\\<^sub>M count_space UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>((s, j), \\<omega>). trace_at s \\<omega> j)\n    \\<in> (count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          count_space UNIV", "unfolding trace_at_eq split_beta'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case sfirst (\\<lambda>xa. snd (fst x) < fst (shd xa)) (snd x) of\n        enat xa \\<Rightarrow> (fst (fst x) ## smap snd (snd x)) !! xa)\n    \\<in> (count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M\n          stream_space S \\<rightarrow>\\<^sub>M\n          count_space UNIV", "by measurable"], ["", "lemma K_time_split:\n  assumes \"t \\<le> j\" and [measurable]: \"f \\<in> S \\<rightarrow>\\<^sub>M borel\"\n  shows \"(\\<integral>\\<^sup>+x. f x * indicator {j <..} (fst x) \\<partial>K (t, s)) = (\\<integral>\\<^sup>+x. f x \\<partial>K (j, s)) * exponential (escape_rate s) {j - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "have \"(\\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y) * indicator {j<..} (t + x) \\<partial>exponential (escape_rate s) \\<partial>J s) =\n    (\\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y) * indicator {j - t<..} x \\<partial>exponential (escape_rate s) \\<partial>J s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n          f (t + x, y) * indicator {j<..} (t + x)\n        \\<partial>exponential (escape_rate s)\n                       \\<partial>measure_pmf (J s) =\n    \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}.\n         f (t + x, y)\n                            \\<partial>exponential (escape_rate s))\n                       \\<partial>measure_pmf (J s)", "by (intro nn_integral_cong) (auto split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n        f (t + x, y) * indicator {j<..} (t + x)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) =\n  \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}. f (t + x, y)\n                          \\<partial>exponential (escape_rate s))\n                     \\<partial>measure_pmf (J s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n        f (t + x, y) * indicator {j<..} (t + x)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) =\n  \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}. f (t + x, y)\n                          \\<partial>exponential (escape_rate s))\n                     \\<partial>measure_pmf (J s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "have \"\\<dots> = (\\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y) \\<partial>uniform_measure (exponential (escape_rate s)) {j-t <..} \\<partial>J s) *\n      emeasure (exponential (escape_rate s)) {j - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}.\n         f (t + x, y)\n                            \\<partial>exponential (escape_rate s))\n                       \\<partial>measure_pmf (J s) =\n    \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n        \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                       \\<partial>measure_pmf (J s) *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "using \\<open>t \\<le> j\\<close> escape_rate_pos"], ["proof (prove)\nusing this:\n  t \\<le> j\n  0 < escape_rate ?x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}.\n         f (t + x, y)\n                            \\<partial>exponential (escape_rate s))\n                       \\<partial>measure_pmf (J s) =\n    \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n        \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                       \\<partial>measure_pmf (J s) *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "by (subst nn_integral_uniform_measure)\n       (auto simp: nn_integral_divide ennreal_divide_times emeasure_exponential_Ioi)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}. f (t + x, y)\n                          \\<partial>exponential (escape_rate s))\n                     \\<partial>measure_pmf (J s) =\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n      \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                     \\<partial>measure_pmf (J s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. (\\<integral>\\<^sup>+x\\<in>{j - t<..}. f (t + x, y)\n                          \\<partial>exponential (escape_rate s))\n                     \\<partial>measure_pmf (J s) =\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n      \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                     \\<partial>measure_pmf (J s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "have \"\\<dots> = (\\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (j + x, y) \\<partial>exponential (escape_rate s) \\<partial>J s) *\n      emeasure (exponential (escape_rate s)) {j - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n        \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                       \\<partial>measure_pmf (J s) *\n    emeasure (exponential (escape_rate s)) {j - t<..} =\n    \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (j + x, y)\n        \\<partial>exponential (escape_rate s)\n                       \\<partial>measure_pmf (J s) *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "using \\<open>t \\<le> j\\<close> escape_rate_pos"], ["proof (prove)\nusing this:\n  t \\<le> j\n  0 < escape_rate ?x\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n        \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                       \\<partial>measure_pmf (J s) *\n    emeasure (exponential (escape_rate s)) {j - t<..} =\n    \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (j + x, y)\n        \\<partial>exponential (escape_rate s)\n                       \\<partial>measure_pmf (J s) *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "by (simp add: uniform_measure_exponential nn_integral_distr)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (t + x, y)\n      \\<partial>uniform_measure (exponential (escape_rate s)) {j - t<..}\n                     \\<partial>measure_pmf (J s) *\n  emeasure (exponential (escape_rate s)) {j - t<..} =\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (j + x, y)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n        f (t + x, y) * indicator {j<..} (t + x)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) =\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (j + x, y)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x.\n        f (t + x, y) * indicator {j<..} (t + x)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) =\n  \\<integral>\\<^sup>+ y. \\<integral>\\<^sup>+ x. f (j + x, y)\n      \\<partial>exponential (escape_rate s)\n                     \\<partial>measure_pmf (J s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    integral\\<^sup>N (K (j, s)) f *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "by (simp add: K_def exp_esc.nn_integral_snd[symmetric] nn_integral_distr)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. f x * indicator {j<..} (fst x) \\<partial>K (t, s) =\n  integral\\<^sup>N (K (j, s)) f *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_in_space[simp]: \"K x \\<in> space (prob_algebra S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K x \\<in> space (prob_algebra S)", "by (rule measurable_space [OF K.K]) simp"], ["", "lemma L_in_space[simp]: \"K.lim_stream x \\<in> space (prob_algebra T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K.lim_stream x \\<in> space (prob_algebra (stream_space S))", "by (rule measurable_space [OF K.lim_stream]) simp"], ["", "subsection \\<open>Markov Chain Property\\<close>"], ["", "lemma lim_time_split:\n  \"t \\<le> j \\<Longrightarrow> K.lim_stream (t, s) = do { \\<omega> \\<leftarrow> K.lim_stream (t, s) ; \\<omega>' \\<leftarrow> K.lim_stream (j, trace_at s \\<omega> j) ; return T (merge_at \\<omega> j \\<omega>')}\"\n    (is \"_ \\<Longrightarrow> _ = ?DO t s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> j \\<Longrightarrow>\n    K.lim_stream (t, s) =\n    K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>')))", "proof (coinduction arbitrary: t s rule: K.lim_stream_eq_coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (t, s) \\<in> space S\n 2. \\<And>t s.\n       t \\<le> j \\<Longrightarrow>\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t, s). (\\<exists>t s.\n                                 y = (t, s) \\<and>\n                                 B' y =\n                                 K.lim_stream (t, s) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     K.lim_stream\n(j, trace_at s \\<omega> j) \\<bind>\n                                     (\\<lambda>\\<omega>'.\n   return (stream_space S) (merge_at \\<omega> j \\<omega>'))) \\<and>\n                                 t \\<le> j) \\<or>\n                             K.lim_stream y = B' y) \\<and>\n          K.lim_stream (t, s) \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at \\<omega> j \\<omega>'))) =\n          K (t, s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "case step"], ["proof (state)\nthis:\n  t \\<le> j\n\ngoal (2 subgoals):\n 1. (t, s) \\<in> space S\n 2. \\<And>t s.\n       t \\<le> j \\<Longrightarrow>\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t, s). (\\<exists>t s.\n                                 y = (t, s) \\<and>\n                                 B' y =\n                                 K.lim_stream (t, s) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     K.lim_stream\n(j, trace_at s \\<omega> j) \\<bind>\n                                     (\\<lambda>\\<omega>'.\n   return (stream_space S) (merge_at \\<omega> j \\<omega>'))) \\<and>\n                                 t \\<le> j) \\<or>\n                             K.lim_stream y = B' y) \\<and>\n          K.lim_stream (t, s) \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at \\<omega> j \\<omega>'))) =\n          K (t, s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "let ?L = K.lim_stream"], ["proof (state)\ngoal (2 subgoals):\n 1. (t, s) \\<in> space S\n 2. \\<And>t s.\n       t \\<le> j \\<Longrightarrow>\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t, s). (\\<exists>t s.\n                                 y = (t, s) \\<and>\n                                 B' y =\n                                 K.lim_stream (t, s) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     K.lim_stream\n(j, trace_at s \\<omega> j) \\<bind>\n                                     (\\<lambda>\\<omega>'.\n   return (stream_space S) (merge_at \\<omega> j \\<omega>'))) \\<and>\n                                 t \\<le> j) \\<or>\n                             K.lim_stream y = B' y) \\<and>\n          K.lim_stream (t, s) \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at \\<omega> j \\<omega>'))) =\n          K (t, s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "note measurable_compose[OF measurable_prob_algebraD measurable_emeasure_subprob_algebra, measurable (raw)]"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> ?M \\<rightarrow>\\<^sub>M prob_algebra ?A1;\n   ?a1 \\<in> sets ?A1\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>x. emeasure (?f x) ?a1)\n                    \\<in> borel_measurable ?M\n\ngoal (2 subgoals):\n 1. (t, s) \\<in> space S\n 2. \\<And>t s.\n       t \\<le> j \\<Longrightarrow>\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t, s). (\\<exists>t s.\n                                 y = (t, s) \\<and>\n                                 B' y =\n                                 K.lim_stream (t, s) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     K.lim_stream\n(j, trace_at s \\<omega> j) \\<bind>\n                                     (\\<lambda>\\<omega>'.\n   return (stream_space S) (merge_at \\<omega> j \\<omega>'))) \\<and>\n                                 t \\<le> j) \\<or>\n                             K.lim_stream y = B' y) \\<and>\n          K.lim_stream (t, s) \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at \\<omega> j \\<omega>'))) =\n          K (t, s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "define B' where \"B' = (\\<lambda>(t', s). if t' \\<le> j then ?DO t' s else ?L (t', s))\""], ["proof (state)\nthis:\n  B' =\n  (\\<lambda>(t', s).\n      if t' \\<le> j\n      then K.lim_stream (t', s) \\<bind>\n           (\\<lambda>\\<omega>.\n               K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n               (\\<lambda>\\<omega>'.\n                   return (stream_space S) (merge_at \\<omega> j \\<omega>')))\n      else K.lim_stream (t', s))\n\ngoal (2 subgoals):\n 1. (t, s) \\<in> space S\n 2. \\<And>t s.\n       t \\<le> j \\<Longrightarrow>\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t, s). (\\<exists>t s.\n                                 y = (t, s) \\<and>\n                                 B' y =\n                                 K.lim_stream (t, s) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     K.lim_stream\n(j, trace_at s \\<omega> j) \\<bind>\n                                     (\\<lambda>\\<omega>'.\n   return (stream_space S) (merge_at \\<omega> j \\<omega>'))) \\<and>\n                                 t \\<le> j) \\<or>\n                             K.lim_stream y = B' y) \\<and>\n          K.lim_stream (t, s) \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at \\<omega> j \\<omega>'))) =\n          K (t, s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S).\n       (AE y in K (t, s). (\\<exists>t s.\n                              y = (t, s) \\<and>\n                              B' y =\n                              K.lim_stream (t, s) \\<bind>\n                              (\\<lambda>\\<omega>.\n                                  K.lim_stream\n                                   (j, trace_at s \\<omega> j) \\<bind>\n                                  (\\<lambda>\\<omega>'.\nreturn (stream_space S) (merge_at \\<omega> j \\<omega>'))) \\<and>\n                              t \\<le> j) \\<or>\n                          K.lim_stream y = B' y) \\<and>\n       K.lim_stream (t, s) \\<bind>\n       (\\<lambda>\\<omega>.\n           K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n           (\\<lambda>\\<omega>'.\n               return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n       K (t, s) \\<bind>\n       (\\<lambda>y.\n           B' y \\<bind>\n           (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "proof (intro bexI conjI AE_I2)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> space (K (t, s)) \\<Longrightarrow>\n       (\\<exists>t s.\n           y = (t, s) \\<and>\n           ?B' y =\n           K.lim_stream (t, s) \\<bind>\n           (\\<lambda>\\<omega>.\n               K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n               (\\<lambda>\\<omega>'.\n                   return (stream_space S)\n                    (merge_at \\<omega> j \\<omega>'))) \\<and>\n           t \\<le> j) \\<or>\n       K.lim_stream y = ?B' y\n 2. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        ?B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n 3. ?B' \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S)", "show [measurable]: \"B' \\<in> S \\<rightarrow>\\<^sub>M prob_algebra T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B' \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S)", "unfolding B'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(t', s).\n        if t' \\<le> j\n        then K.lim_stream (t', s) \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at \\<omega> j \\<omega>')))\n        else K.lim_stream (t', s))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S)", "by measurable"], ["proof (state)\nthis:\n  B' \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> space (K (t, s)) \\<Longrightarrow>\n       (\\<exists>t s.\n           y = (t, s) \\<and>\n           B' y =\n           K.lim_stream (t, s) \\<bind>\n           (\\<lambda>\\<omega>.\n               K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n               (\\<lambda>\\<omega>'.\n                   return (stream_space S)\n                    (merge_at \\<omega> j \\<omega>'))) \\<and>\n           t \\<le> j) \\<or>\n       K.lim_stream y = B' y\n 2. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "show \"(\\<exists>t s. y = (t, s) \\<and> B' y = ?DO t s \\<and> t \\<le> j) \\<or> ?L y = B' y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t s.\n        y = (t, s) \\<and>\n        B' y =\n        K.lim_stream (t, s) \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at \\<omega> j \\<omega>'))) \\<and>\n        t \\<le> j) \\<or>\n    K.lim_stream y = B' y", "by (cases y; cases \"fst y \\<le> j\") (auto simp: B'_def)"], ["proof (state)\nthis:\n  (\\<exists>t s.\n      ?y1 = (t, s) \\<and>\n      B' ?y1 =\n      K.lim_stream (t, s) \\<bind>\n      (\\<lambda>\\<omega>.\n          K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n          (\\<lambda>\\<omega>'.\n              return (stream_space S)\n               (merge_at \\<omega> j \\<omega>'))) \\<and>\n      t \\<le> j) \\<or>\n  K.lim_stream ?y1 = B' ?y1\n\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "let ?C = \"\\<lambda>x. do { \\<omega> \\<leftarrow> ?L x; \\<omega>' \\<leftarrow> ?L (j, trace_at s (x##\\<omega>) j); return T (merge_at (x##\\<omega>) j \\<omega>') }\""], ["proof (state)\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "have \"?DO t s = do { x \\<leftarrow> K (t, s); ?C x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply (subst K.lim_stream_eq[OF in_space_S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) \\<bind>\n    (\\<lambda>y.\n        K.lim_stream y \\<bind>\n        (\\<lambda>\\<omega>.\n            return (stream_space S) (y ## \\<omega>))) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply (subst bind_assoc[OF measurable_prob_algebraD measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        K.lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n    \\<in> K (t, s) \\<rightarrow>\\<^sub>M prob_algebra ?N\n 2. (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>')))\n    \\<in> ?N \\<rightarrow>\\<^sub>M prob_algebra ?R\n 3. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)) \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S) (merge_at \\<omega> j \\<omega>')))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply (subst measurable_cong_sets[OF K.sets_K[OF in_space_S] refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        K.lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra ?N\n 2. (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>')))\n    \\<in> ?N \\<rightarrow>\\<^sub>M prob_algebra ?R\n 3. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)) \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S) (merge_at \\<omega> j \\<omega>')))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)) \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S) (merge_at \\<omega> j \\<omega>')))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply (subst bind_assoc[OF measurable_prob_algebraD measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>))\n       \\<in> K.lim_stream x \\<rightarrow>\\<^sub>M prob_algebra ?N26\n 2. \\<And>x.\n       (\\<lambda>\\<omega>.\n           K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n           (\\<lambda>\\<omega>'.\n               return (stream_space S) (merge_at \\<omega> j \\<omega>')))\n       \\<in> ?N26 \\<rightarrow>\\<^sub>M prob_algebra ?R26\n 3. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>xa.\n            return (stream_space S) (x ## xa) \\<bind>\n            (\\<lambda>\\<omega>.\n                K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n                (\\<lambda>\\<omega>'.\n                    return (stream_space S)\n                     (merge_at \\<omega> j \\<omega>'))))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>xa.\n            return (stream_space S) (x ## xa) \\<bind>\n            (\\<lambda>\\<omega>.\n                K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n                (\\<lambda>\\<omega>'.\n                    return (stream_space S)\n                     (merge_at \\<omega> j \\<omega>'))))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply (subst bind_cong[OF refl bind_cong[OF refl bind_return[OF measurable_prob_algebraD]]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> space (K (t, s));\n        xa \\<in> space (K.lim_stream x)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at \\<omega> j \\<omega>')))\n                         \\<in> stream_space S \\<rightarrow>\\<^sub>M\n                               prob_algebra (?N47 x xa)\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<in> space (K (t, s));\n        xa \\<in> space (K.lim_stream x)\\<rbrakk>\n       \\<Longrightarrow> x ## xa \\<in> space (stream_space S)\n 3. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>xa.\n            K.lim_stream (j, trace_at s (x ## xa) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## xa) j \\<omega>')))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))", "apply measurable"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  K.lim_stream (t, s) \\<bind>\n  (\\<lambda>\\<omega>.\n      K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n      (\\<lambda>\\<omega>'.\n          return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n  K (t, s) \\<bind>\n  (\\<lambda>x.\n      K.lim_stream x \\<bind>\n      (\\<lambda>\\<omega>.\n          K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n          (\\<lambda>\\<omega>'.\n              return (stream_space S)\n               (merge_at (x ## \\<omega>) j \\<omega>'))))\n\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "also"], ["proof (state)\nthis:\n  K.lim_stream (t, s) \\<bind>\n  (\\<lambda>\\<omega>.\n      K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n      (\\<lambda>\\<omega>'.\n          return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n  K (t, s) \\<bind>\n  (\\<lambda>x.\n      K.lim_stream x \\<bind>\n      (\\<lambda>\\<omega>.\n          K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n          (\\<lambda>\\<omega>'.\n              return (stream_space S)\n               (merge_at (x ## \\<omega>) j \\<omega>'))))\n\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "have \"\\<dots> = K (t, s) \\<bind> (\\<lambda>y. B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>)))\" (is \"?DO' = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>')))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "proof (rule measure_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n    sets\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n 2. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"sets ?DO' = sets T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n    sets (stream_space S)", "by (intro sets_bind'[OF K_in_space]) measurable"], ["proof (state)\nthis:\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n  sets (stream_space S)\n\ngoal (2 subgoals):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n    sets\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n 2. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "moreover"], ["proof (state)\nthis:\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n  sets (stream_space S)\n\ngoal (2 subgoals):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n    sets\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n 2. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"sets ?R = sets T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))) =\n    sets (stream_space S)", "by (intro sets_bind'[OF K_in_space]) measurable"], ["proof (state)\nthis:\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))) =\n  sets (stream_space S)\n\ngoal (2 subgoals):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n    sets\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n 2. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "ultimately"], ["proof (chain)\npicking this:\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n  sets (stream_space S)\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))) =\n  sets (stream_space S)", "show \"sets ?DO' = sets ?R\""], ["proof (prove)\nusing this:\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n  sets (stream_space S)\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))) =\n  sets (stream_space S)\n\ngoal (1 subgoal):\n 1. sets\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n    sets\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))", "by simp"], ["proof (state)\nthis:\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>'))))) =\n  sets\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "assume \"A \\<in> sets ?DO'\""], ["proof (state)\nthis:\n  A \\<in> sets\n           (K (t, s) \\<bind>\n            (\\<lambda>x.\n                K.lim_stream x \\<bind>\n                (\\<lambda>\\<omega>.\n                    K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                    (\\<lambda>\\<omega>'.\n                        return (stream_space S)\n                         (merge_at (x ## \\<omega>) j \\<omega>')))))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "then"], ["proof (chain)\npicking this:\n  A \\<in> sets\n           (K (t, s) \\<bind>\n            (\\<lambda>x.\n                K.lim_stream x \\<bind>\n                (\\<lambda>\\<omega>.\n                    K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                    (\\<lambda>\\<omega>'.\n                        return (stream_space S)\n                         (merge_at (x ## \\<omega>) j \\<omega>')))))", "have A[measurable]: \"A \\<in> T\""], ["proof (prove)\nusing this:\n  A \\<in> sets\n           (K (t, s) \\<bind>\n            (\\<lambda>x.\n                K.lim_stream x \\<bind>\n                (\\<lambda>\\<omega>.\n                    K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                    (\\<lambda>\\<omega>'.\n                        return (stream_space S)\n                         (merge_at (x ## \\<omega>) j \\<omega>')))))\n\ngoal (1 subgoal):\n 1. A \\<in> sets (stream_space S)", "unfolding \\<open>sets ?DO' = sets T\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> sets (stream_space S)\n\ngoal (1 subgoal):\n 1. A \\<in> sets (stream_space S)", "."], ["proof (state)\nthis:\n  A \\<in> sets (stream_space S)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"?DO' A = (\\<integral>\\<^sup>+x. ?C x A \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>')))))\n     A =\n    \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A\n                       \\<partial>K (t, s)", "by (subst emeasure_bind_prob_algebra[OF K_in_space]) measurable"], ["proof (state)\nthis:\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>')))))\n   A =\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "also"], ["proof (state)\nthis:\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>')))))\n   A =\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"\\<dots> = (\\<integral>\\<^sup>+x. ?C x A * indicator {.. j} (fst x) \\<partial>K (t, s)) +\n        (\\<integral>\\<^sup>+x. ?C x A * indicator {j <..} (fst x) \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {..j} (fst x)\n                       \\<partial>K (t, s) +\n    \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s)", "by (subst nn_integral_add[symmetric]) (auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {..j} (fst x)\n                     \\<partial>K (t, s) +\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {..j} (fst x)\n                     \\<partial>K (t, s) +\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"(\\<integral>\\<^sup>+x. ?C x A * indicator {.. j} (fst x) \\<partial>K (t, s)) =\n        (\\<integral>\\<^sup>+y. emeasure (B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A * indicator {.. j} (fst y) \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {..j} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {..j} (fst y)\n                       \\<partial>K (t, s)", "proof (intro nn_integral_cong ennreal_mult_right_cong refl arg_cong2[where f=emeasure])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (K (t, s));\n        indicator {..j} (fst x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream\n                              (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at (x ## \\<omega>) j \\<omega>'))) =\n                         B' x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             return (stream_space S) (x ## \\<omega>))", "fix x :: \"real \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (K (t, s));\n        indicator {..j} (fst x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream\n                              (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at (x ## \\<omega>) j \\<omega>'))) =\n                         B' x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             return (stream_space S) (x ## \\<omega>))", "assume \"indicator {..j} (fst x) \\<noteq> (0::ennreal)\""], ["proof (state)\nthis:\n  indicator {..j} (fst x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (K (t, s));\n        indicator {..j} (fst x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream\n                              (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at (x ## \\<omega>) j \\<omega>'))) =\n                         B' x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             return (stream_space S) (x ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  indicator {..j} (fst x) \\<noteq> 0", "have \"fst x \\<le> j\""], ["proof (prove)\nusing this:\n  indicator {..j} (fst x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fst x \\<le> j", "by (auto split: split_indicator_asm)"], ["proof (state)\nthis:\n  fst x \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (K (t, s));\n        indicator {..j} (fst x) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream\n                              (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at (x ## \\<omega>) j \\<omega>'))) =\n                         B' x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             return (stream_space S) (x ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  fst x \\<le> j", "show \"?C x = (B' x \\<bind> (\\<lambda>\\<omega>. return T (x ## \\<omega>)))\""], ["proof (prove)\nusing this:\n  fst x \\<le> j\n\ngoal (1 subgoal):\n 1. K.lim_stream x \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S)\n             (merge_at (x ## \\<omega>) j \\<omega>'))) =\n    B' x \\<bind>\n    (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>))", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fst x \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream\n                              (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at (x ## \\<omega>) j \\<omega>'))) =\n                         B' x \\<bind>\n                         (\\<lambda>\\<omega>.\n                             return (stream_space S) (x ## \\<omega>))", "apply (simp add: B'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  ((a, b) ##\n                                   merge_at \\<omega> j \\<omega>'))) =\n                         K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at \\<omega> j \\<omega>'))) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             return (stream_space S) ((a, b) ## \\<omega>))", "apply (subst bind_assoc[OF measurable_prob_algebraD measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at \\<omega> j \\<omega>')))\n                         \\<in> K.lim_stream (a, b) \\<rightarrow>\\<^sub>M\n                               prob_algebra (?N2 a b)\n 2. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>.\n                             return (stream_space S) ((a, b) ## \\<omega>))\n                         \\<in> ?N2 a b \\<rightarrow>\\<^sub>M\n                               prob_algebra (?R2 a b)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  ((a, b) ##\n                                   merge_at \\<omega> j \\<omega>'))) =\n                         K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>x.\n                             K.lim_stream (j, trace_at b x j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at x j \\<omega>')) \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S)\n                                  ((a, b) ## \\<omega>)))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  ((a, b) ##\n                                   merge_at \\<omega> j \\<omega>'))) =\n                         K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>x.\n                             K.lim_stream (j, trace_at b x j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  (merge_at x j \\<omega>')) \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S)\n                                  ((a, b) ## \\<omega>)))", "apply (subst bind_assoc[OF measurable_prob_algebraD measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at xa j \\<omega>'))\n                         \\<in> K.lim_stream\n                                (j, trace_at b xa j) \\<rightarrow>\\<^sub>M\n                               prob_algebra (?N29 a b)\n 2. \\<And>a b xa.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>.\n                             return (stream_space S) ((a, b) ## \\<omega>))\n                         \\<in> ?N29 a b \\<rightarrow>\\<^sub>M\n                               prob_algebra (?R29 a b)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  ((a, b) ##\n                                   merge_at \\<omega> j \\<omega>'))) =\n                         K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>x.\n                             K.lim_stream (j, trace_at b x j) \\<bind>\n                             (\\<lambda>xa.\n                                 return (stream_space S)\n                                  (merge_at x j xa) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     return (stream_space S)\n((a, b) ## \\<omega>))))", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  ((a, b) ##\n                                   merge_at \\<omega> j \\<omega>'))) =\n                         K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>x.\n                             K.lim_stream (j, trace_at b x j) \\<bind>\n                             (\\<lambda>xa.\n                                 return (stream_space S)\n                                  (merge_at x j xa) \\<bind>\n                                 (\\<lambda>\\<omega>.\n                                     return (stream_space S)\n((a, b) ## \\<omega>))))", "apply (subst bind_return)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b xa xb.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>\\<omega>.\n                             return (stream_space S) ((a, b) ## \\<omega>))\n                         \\<in> stream_space S \\<rightarrow>\\<^sub>M\n                               subprob_algebra (?N41 a b)\n 2. \\<And>a b xa xb.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> merge_at xb j xa \\<in> space (stream_space S)\n 3. \\<And>a b.\n       \\<lbrakk>a \\<le> j; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>\\<omega>.\n                             K.lim_stream (j, trace_at b \\<omega> j) \\<bind>\n                             (\\<lambda>\\<omega>'.\n                                 return (stream_space S)\n                                  ((a, b) ##\n                                   merge_at \\<omega> j \\<omega>'))) =\n                         K.lim_stream (a, b) \\<bind>\n                         (\\<lambda>x.\n                             K.lim_stream (j, trace_at b x j) \\<bind>\n                             (\\<lambda>xa.\n                                 return (stream_space S)\n                                  ((a, b) ## merge_at x j xa)))", "apply measurable"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  K.lim_stream x \\<bind>\n  (\\<lambda>\\<omega>.\n      K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n      (\\<lambda>\\<omega>'.\n          return (stream_space S) (merge_at (x ## \\<omega>) j \\<omega>'))) =\n  B' x \\<bind> (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {..j} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {..j} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {..j} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {..j} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"(\\<integral>\\<^sup>+x. ?C x A * indicator {j <..} (fst x) \\<partial>K (t, s)) =\n        (\\<integral>\\<^sup>+y. emeasure (B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A * indicator {j <..} (fst y) \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "have *: \"(+) t -` {j<..} = {j - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) t -` {j<..} = {j - t<..}", "by auto"], ["proof (state)\nthis:\n  (+) t -` {j<..} = {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "have \"(\\<integral>\\<^sup>+x. ?C x A * indicator {j <..} (fst x) \\<partial>K (t, s)) =\n          (\\<integral>\\<^sup>+x. ?L (j, s) A * indicator {j <..} (fst x) \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ x. emeasure (K.lim_stream (j, s)) A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s)", "by (intro nn_integral_cong ennreal_mult_right_cong refl arg_cong2[where f=emeasure])\n             (auto simp: K.sets_lim_stream bind_return'' bind_const' prob_space_K_lim prob_space_imp_subprob_space split: split_indicator_asm)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ x. emeasure (K.lim_stream (j, s)) A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ x. emeasure (K.lim_stream (j, s)) A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "have \"\\<dots> = ?L (j, s) A * exponential (escape_rate s) {j - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure (K.lim_stream (j, s)) A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    emeasure (K.lim_stream (j, s)) A *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "by (subst nn_integral_cmult) (simp_all add: K_def exp_esc.nn_integral_snd[symmetric] emeasure_distr space_exponential *)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure (K.lim_stream (j, s)) A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  emeasure (K.lim_stream (j, s)) A *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure (K.lim_stream (j, s)) A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  emeasure (K.lim_stream (j, s)) A *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "have \"\\<dots> = (\\<integral>\\<^sup>+x. emeasure (?L x \\<bind> (\\<lambda>\\<omega>. return T (x ## \\<omega>))) A \\<partial>K (j, s)) * exponential (escape_rate s) {j - t <..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream (j, s)) A *\n    emeasure (exponential (escape_rate s)) {j - t<..} =\n    \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (x ## \\<omega>)))\n                            A\n                       \\<partial>K (j, s) *\n    emeasure (exponential (escape_rate s)) {j - t<..}", "by (subst K.lim_stream_eq) (auto simp: emeasure_bind_prob_algebra[OF K_in_space _ A])"], ["proof (state)\nthis:\n  emeasure (K.lim_stream (j, s)) A *\n  emeasure (exponential (escape_rate s)) {j - t<..} =\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (x ## \\<omega>)))\n                          A\n                     \\<partial>K (j, s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "also"], ["proof (state)\nthis:\n  emeasure (K.lim_stream (j, s)) A *\n  emeasure (exponential (escape_rate s)) {j - t<..} =\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (x ## \\<omega>)))\n                          A\n                     \\<partial>K (j, s) *\n  emeasure (exponential (escape_rate s)) {j - t<..}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "have \"\\<dots> = (\\<integral>\\<^sup>+y. emeasure (?L y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A * indicator {j <..} (fst y) \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (x ## \\<omega>)))\n                            A\n                       \\<partial>K (j, s) *\n    emeasure (exponential (escape_rate s)) {j - t<..} =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (K.lim_stream y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "using \\<open>t \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  t \\<le> j\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (x ## \\<omega>)))\n                            A\n                       \\<partial>K (j, s) *\n    emeasure (exponential (escape_rate s)) {j - t<..} =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (K.lim_stream y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "by (rule K_time_split[symmetric]) measurable"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (x ## \\<omega>)))\n                          A\n                     \\<partial>K (j, s) *\n  emeasure (exponential (escape_rate s)) {j - t<..} =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (K.lim_stream y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (x ## \\<omega>)))\n                          A\n                     \\<partial>K (j, s) *\n  emeasure (exponential (escape_rate s)) {j - t<..} =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (K.lim_stream y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "have \"\\<dots> = (\\<integral>\\<^sup>+y. emeasure (B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A * indicator {j <..} (fst y) \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure\n                            (K.lim_stream y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "by (intro nn_integral_cong ennreal_mult_right_cong refl arg_cong2[where f=emeasure])\n             (auto simp add: B'_def split: split_indicator_asm)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (K.lim_stream y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 K.lim_stream\n                                  (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                                 (\\<lambda>\\<omega>'.\n                                     return (stream_space S)\n(merge_at (x ## \\<omega>) j \\<omega>'))))\n                            A *\n                           indicator {j<..} (fst x)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s)", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure\n                          (K.lim_stream x \\<bind>\n                           (\\<lambda>\\<omega>.\n                               K.lim_stream\n                                (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                               (\\<lambda>\\<omega>'.\n                                   return (stream_space S)\n                                    (merge_at (x ## \\<omega>) j\n\\<omega>'))))\n                          A *\n                         indicator {j<..} (fst x)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"(\\<integral>\\<^sup>+y. emeasure (B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A * indicator {.. j} (fst y) \\<partial>K (t, s)) +\n        (\\<integral>\\<^sup>+y. emeasure (B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A * indicator {j <..} (fst y) \\<partial>K (t, s)) =\n        (\\<integral>\\<^sup>+y. emeasure (B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>))) A \\<partial>K (t, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {..j} (fst y)\n                       \\<partial>K (t, s) +\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A *\n                           indicator {j<..} (fst y)\n                       \\<partial>K (t, s) =\n    \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A\n                       \\<partial>K (t, s)", "by (subst nn_integral_add[symmetric]) (auto intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {..j} (fst y)\n                     \\<partial>K (t, s) +\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {..j} (fst y)\n                     \\<partial>K (t, s) +\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A *\n                         indicator {j<..} (fst y)\n                     \\<partial>K (t, s) =\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A\n                     \\<partial>K (t, s)\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "have \"\\<dots> = emeasure (K (t, s) \\<bind> (\\<lambda>y. B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>)))) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure\n                            (B' y \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (y ## \\<omega>)))\n                            A\n                       \\<partial>K (t, s) =\n    emeasure\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n     A", "by (rule emeasure_bind_prob_algebra[symmetric, OF K_in_space _ A]) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure\n                          (B' y \\<bind>\n                           (\\<lambda>\\<omega>.\n                               return (stream_space S) (y ## \\<omega>)))\n                          A\n                     \\<partial>K (t, s) =\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n   A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       A \\<in> sets\n                (K (t, s) \\<bind>\n                 (\\<lambda>x.\n                     K.lim_stream x \\<bind>\n                     (\\<lambda>\\<omega>.\n                         K.lim_stream\n                          (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                         (\\<lambda>\\<omega>'.\n                             return (stream_space S)\n                              (merge_at (x ## \\<omega>) j\n                                \\<omega>'))))) \\<Longrightarrow>\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>x.\n             K.lim_stream x \\<bind>\n             (\\<lambda>\\<omega>.\n                 K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n                 (\\<lambda>\\<omega>'.\n                     return (stream_space S)\n                      (merge_at (x ## \\<omega>) j \\<omega>')))))\n        A =\n       emeasure\n        (K (t, s) \\<bind>\n         (\\<lambda>y.\n             B' y \\<bind>\n             (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n        A", "finally"], ["proof (chain)\npicking this:\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>')))))\n   A =\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n   A", "show \"?DO' A = emeasure (K (t, s) \\<bind> (\\<lambda>y. B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>)))) A\""], ["proof (prove)\nusing this:\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>')))))\n   A =\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n   A\n\ngoal (1 subgoal):\n 1. emeasure\n     (K (t, s) \\<bind>\n      (\\<lambda>x.\n          K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>.\n              K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n              (\\<lambda>\\<omega>'.\n                  return (stream_space S)\n                   (merge_at (x ## \\<omega>) j \\<omega>')))))\n     A =\n    emeasure\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          B' y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n     A", "."], ["proof (state)\nthis:\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>x.\n        K.lim_stream x \\<bind>\n        (\\<lambda>\\<omega>.\n            K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n            (\\<lambda>\\<omega>'.\n                return (stream_space S)\n                 (merge_at (x ## \\<omega>) j \\<omega>')))))\n   A =\n  emeasure\n   (K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n   A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  K (t, s) \\<bind>\n  (\\<lambda>x.\n      K.lim_stream x \\<bind>\n      (\\<lambda>\\<omega>.\n          K.lim_stream (j, trace_at s (x ## \\<omega>) j) \\<bind>\n          (\\<lambda>\\<omega>'.\n              return (stream_space S)\n               (merge_at (x ## \\<omega>) j \\<omega>')))) =\n  K (t, s) \\<bind>\n  (\\<lambda>y.\n      B' y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "finally"], ["proof (chain)\npicking this:\n  K.lim_stream (t, s) \\<bind>\n  (\\<lambda>\\<omega>.\n      K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n      (\\<lambda>\\<omega>'.\n          return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n  K (t, s) \\<bind>\n  (\\<lambda>y.\n      B' y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "show \"?DO t s = K (t, s) \\<bind> (\\<lambda>y. B' y \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>)))\""], ["proof (prove)\nusing this:\n  K.lim_stream (t, s) \\<bind>\n  (\\<lambda>\\<omega>.\n      K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n      (\\<lambda>\\<omega>'.\n          return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n  K (t, s) \\<bind>\n  (\\<lambda>y.\n      B' y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) \\<bind>\n    (\\<lambda>\\<omega>.\n        K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n    K (t, s) \\<bind>\n    (\\<lambda>y.\n        B' y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "."], ["proof (state)\nthis:\n  K.lim_stream (t, s) \\<bind>\n  (\\<lambda>\\<omega>.\n      K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n      (\\<lambda>\\<omega>'.\n          return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n  K (t, s) \\<bind>\n  (\\<lambda>y.\n      B' y \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S).\n     (AE y in K (t, s). (\\<exists>t s.\n                            y = (t, s) \\<and>\n                            B' y =\n                            K.lim_stream (t, s) \\<bind>\n                            (\\<lambda>\\<omega>.\n                                K.lim_stream\n                                 (j, trace_at s \\<omega> j) \\<bind>\n                                (\\<lambda>\\<omega>'.\n                                    return (stream_space S)\n                                     (merge_at \\<omega> j\n \\<omega>'))) \\<and>\n                            t \\<le> j) \\<or>\n                        K.lim_stream y = B' y) \\<and>\n     K.lim_stream (t, s) \\<bind>\n     (\\<lambda>\\<omega>.\n         K.lim_stream (j, trace_at s \\<omega> j) \\<bind>\n         (\\<lambda>\\<omega>'.\n             return (stream_space S) (merge_at \\<omega> j \\<omega>'))) =\n     K (t, s) \\<bind>\n     (\\<lambda>y.\n         B' y \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. (t, s) \\<in> space S", "qed (simp add: space_pair_measure)"], ["", "lemma K_eq: \"K (t, s) = distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M J s) S (\\<lambda>(t', s). (t + t', s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t', s). (t + t', s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. K (t, s) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t', s). (t + t', s))", "have \"distr (exponential (escape_rate s)) borel ((+) t) \\<Otimes>\\<^sub>M distr (J s) (J s) (\\<lambda>x. x) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M J s) (borel \\<Otimes>\\<^sub>M J s) (\\<lambda>(x, y). (t + x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (exponential (escape_rate s)) borel ((+) t) \\<Otimes>\\<^sub>M\n    distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     (borel \\<Otimes>\\<^sub>M measure_pmf (J s))\n     (\\<lambda>(x, y). (t + x, y))", "proof (intro pair_measure_distr)"], ["proof (state)\ngoal (3 subgoals):\n 1. (+) t \\<in> borel_measurable (exponential (escape_rate s))\n 2. measure_pmf.random_variable (J s) (measure_pmf (J s)) (\\<lambda>x. x)\n 3. sigma_finite_measure\n     (distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x))", "interpret prob_space \"distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x))", "by (intro measure_pmf.prob_space_distr) simp"], ["proof (state)\ngoal (3 subgoals):\n 1. (+) t \\<in> borel_measurable (exponential (escape_rate s))\n 2. measure_pmf.random_variable (J s) (measure_pmf (J s)) (\\<lambda>x. x)\n 3. sigma_finite_measure\n     (distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x))", "show \"sigma_finite_measure (distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure\n     (distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x))", "by unfold_locales"], ["proof (state)\nthis:\n  sigma_finite_measure\n   (distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x))\n\ngoal (2 subgoals):\n 1. (+) t \\<in> borel_measurable (exponential (escape_rate s))\n 2. measure_pmf.random_variable (J s) (measure_pmf (J s)) (\\<lambda>x. x)", "qed auto"], ["proof (state)\nthis:\n  distr (exponential (escape_rate s)) borel ((+) t) \\<Otimes>\\<^sub>M\n  distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x) =\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n   (borel \\<Otimes>\\<^sub>M measure_pmf (J s)) (\\<lambda>(x, y). (t + x, y))\n\ngoal (1 subgoal):\n 1. K (t, s) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t', s). (t + t', s))", "also"], ["proof (state)\nthis:\n  distr (exponential (escape_rate s)) borel ((+) t) \\<Otimes>\\<^sub>M\n  distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x) =\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n   (borel \\<Otimes>\\<^sub>M measure_pmf (J s)) (\\<lambda>(x, y). (t + x, y))\n\ngoal (1 subgoal):\n 1. K (t, s) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t', s). (t + t', s))", "have \"\\<dots> = distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M J s) S (\\<lambda>(x, y). (t + x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     (borel \\<Otimes>\\<^sub>M measure_pmf (J s))\n     (\\<lambda>(x, y). (t + x, y)) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(x, y). (t + x, y))", "by (intro distr_cong refl sets_pair_measure_cong) simp"], ["proof (state)\nthis:\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n   (borel \\<Otimes>\\<^sub>M measure_pmf (J s))\n   (\\<lambda>(x, y). (t + x, y)) =\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s)) S\n   (\\<lambda>(x, y). (t + x, y))\n\ngoal (1 subgoal):\n 1. K (t, s) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t', s). (t + t', s))", "finally"], ["proof (chain)\npicking this:\n  distr (exponential (escape_rate s)) borel ((+) t) \\<Otimes>\\<^sub>M\n  distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x) =\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s)) S\n   (\\<lambda>(x, y). (t + x, y))", "show ?thesis"], ["proof (prove)\nusing this:\n  distr (exponential (escape_rate s)) borel ((+) t) \\<Otimes>\\<^sub>M\n  distr (measure_pmf (J s)) (measure_pmf (J s)) (\\<lambda>x. x) =\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s)) S\n   (\\<lambda>(x, y). (t + x, y))\n\ngoal (1 subgoal):\n 1. K (t, s) =\n    distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t', s). (t + t', s))", "by (simp add: K_def)"], ["proof (state)\nthis:\n  K (t, s) =\n  distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s)) S\n   (\\<lambda>(t', s). (t + t', s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma K_shift: \"K (t + t', s) = distr (K (t, s)) S (\\<lambda>(t, s). (t + t', s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t + t', s) = distr (K (t, s)) S (\\<lambda>(t, s). (t + t', s))", "unfolding K_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s))\n     S (\\<lambda>(t'a, y). (t + t' + t'a, y)) =\n    distr\n     (distr\n       (exponential (escape_rate s) \\<Otimes>\\<^sub>M measure_pmf (J s)) S\n       (\\<lambda>(t', y). (t + t', y)))\n     S (\\<lambda>(t, s). (t + t', s))", "by (subst distr_distr) (auto simp: comp_def split_beta' ac_simps)"], ["", "lemma K_not_empty: \"space (K x) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (K x) \\<noteq> {}", "by (simp add: K_def space_pair_measure split: prod.split)"], ["", "lemma lim_stream_not_empty: \"space (K.lim_stream x) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (K.lim_stream x) \\<noteq> {}", "by (simp add: K.space_lim_stream space_pair_measure split: prod.split)"], ["", "lemma lim_shift: \\<comment> \\<open>Generalize to bijective function on @{const K.lim_stream} invariant on @{const K}\\<close>\n  \"K.lim_stream (t + t', s) = distr (K.lim_stream (t, s)) T (smap (\\<lambda>(t, s). (t + t', s)))\"\n  (is \"_ = ?D t s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. K.lim_stream (t + t', s) =\n    distr (K.lim_stream (t, s)) (stream_space S)\n     (smap (\\<lambda>(t, s). (t + t', s)))", "proof (coinduction arbitrary: t s rule: K.lim_stream_eq_coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (t + t', s) \\<in> space S\n 2. \\<And>t s.\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t + t',\n                      s). (\\<exists>t s.\n                              y = (t + t', s) \\<and>\n                              B' y =\n                              distr (K.lim_stream (t, s)) (stream_space S)\n                               (smap (\\<lambda>(t, y). (t + t', y)))) \\<or>\n                          K.lim_stream y = B' y) \\<and>\n          distr (K.lim_stream (t, s)) (stream_space S)\n           (smap (\\<lambda>(t, y). (t + t', y))) =\n          K (t + t', s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "case step"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (t + t', s) \\<in> space S\n 2. \\<And>t s.\n       \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M\n                       prob_algebra (stream_space S).\n          (AE y in K (t + t',\n                      s). (\\<exists>t s.\n                              y = (t + t', s) \\<and>\n                              B' y =\n                              distr (K.lim_stream (t, s)) (stream_space S)\n                               (smap (\\<lambda>(t, y). (t + t', y)))) \\<or>\n                          K.lim_stream y = B' y) \\<and>\n          distr (K.lim_stream (t, s)) (stream_space S)\n           (smap (\\<lambda>(t, y). (t + t', y))) =\n          K (t + t', s) \\<bind>\n          (\\<lambda>y.\n              B' y \\<bind>\n              (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S).\n       (AE y in K (t + t',\n                   s). (\\<exists>t s.\n                           y = (t + t', s) \\<and>\n                           B' y =\n                           distr (K.lim_stream (t, s)) (stream_space S)\n                            (smap (\\<lambda>(t, y). (t + t', y)))) \\<or>\n                       K.lim_stream y = B' y) \\<and>\n       distr (K.lim_stream (t, s)) (stream_space S)\n        (smap (\\<lambda>(t, y). (t + t', y))) =\n       K (t + t', s) \\<bind>\n       (\\<lambda>y.\n           B' y \\<bind>\n           (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "proof (intro bexI[of _ \"\\<lambda>(t, s). ?D (t - t') s\"] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. AE y in K (t + t',\n               s). (\\<exists>t s.\n                       y = (t + t', s) \\<and>\n                       (case y of\n                        (t, s) \\<Rightarrow>\n                          distr (K.lim_stream (t - t', s)) (stream_space S)\n                           (smap\n                             (\\<lambda>a.\n                                 case a of\n                                 (t, s) \\<Rightarrow> (t + t', s)))) =\n                       distr (K.lim_stream (t, s)) (stream_space S)\n                        (smap (\\<lambda>(t, y). (t + t', y)))) \\<or>\n                   K.lim_stream y =\n                   (case y of\n                    (t, s) \\<Rightarrow>\n                      distr (K.lim_stream (t - t', s)) (stream_space S)\n                       (smap\n                         (\\<lambda>a.\n                             case a of (t, s) \\<Rightarrow> (t + t', s))))\n 2. distr (K.lim_stream (t, s)) (stream_space S)\n     (smap (\\<lambda>(t, y). (t + t', y))) =\n    K (t + t', s) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap\n              (\\<lambda>a.\n                  case a of (t, s) \\<Rightarrow> (t + t', s)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n 3. (\\<lambda>(t, s).\n        distr (K.lim_stream (t - t', s)) (stream_space S)\n         (smap (\\<lambda>a. case a of (t, s) \\<Rightarrow> (t + t', s))))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S)", "show \"?D t s = K (t + t', s) \\<bind> (\\<lambda>y. (case y of (t, s) \\<Rightarrow> ?D (t - t') s) \\<bind> (\\<lambda>\\<omega>. return T (y ## \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.lim_stream (t, s)) (stream_space S)\n     (smap (\\<lambda>a. case a of (t, s) \\<Rightarrow> (t + t', s))) =\n    K (t + t', s) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap\n              (\\<lambda>a.\n                  case a of (t, s) \\<Rightarrow> (t + t', s)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "apply (subst K.lim_stream_eq[OF in_space_S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          K.lim_stream y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n     (stream_space S) (smap (\\<lambda>(t, y). (t + t', y))) =\n    K (t + t', s) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "apply (subst K_shift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr\n     (K (t, s) \\<bind>\n      (\\<lambda>y.\n          K.lim_stream y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n     (stream_space S) (smap (\\<lambda>(t, y). (t + t', y))) =\n    distr (K (t, s)) S (\\<lambda>(t, y). (t + t', y)) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "apply (subst distr_bind[OF measurable_prob_algebraD K_not_empty])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        K.lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n    \\<in> K (t, s) \\<rightarrow>\\<^sub>M prob_algebra ?K\n 2. smap (\\<lambda>(t, y). (t + t', y))\n    \\<in> ?K \\<rightarrow>\\<^sub>M stream_space S\n 3. K (t, s) \\<bind>\n    (\\<lambda>x.\n        distr\n         (K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n         (stream_space S) (smap (\\<lambda>(t, y). (t + t', y)))) =\n    distr (K (t, s)) S (\\<lambda>(t, y). (t + t', y)) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. smap (\\<lambda>(t, y). (t + t', y))\n    \\<in> stream_space S \\<rightarrow>\\<^sub>M stream_space S\n 2. K (t, s) \\<bind>\n    (\\<lambda>x.\n        distr\n         (K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n         (stream_space S) (smap (\\<lambda>(t, y). (t + t', y)))) =\n    distr (K (t, s)) S (\\<lambda>(t, y). (t + t', y)) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) \\<bind>\n    (\\<lambda>x.\n        distr\n         (K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n         (stream_space S) (smap (\\<lambda>(t, y). (t + t', y)))) =\n    distr (K (t, s)) S (\\<lambda>(t, y). (t + t', y)) \\<bind>\n    (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))", "apply (subst bind_distr[OF _ measurable_prob_algebraD K_not_empty])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>(t, y). (t + t', y)) \\<in> K (t, s) \\<rightarrow>\\<^sub>M S\n 2. (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra ?K28\n 3. K (t, s) \\<bind>\n    (\\<lambda>x.\n        distr\n         (K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n         (stream_space S) (smap (\\<lambda>(t, y). (t + t', y)))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>.\n            return (stream_space S)\n             ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>)))", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>y.\n        (case y of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra ?K28\n 2. K (t, s) \\<bind>\n    (\\<lambda>x.\n        distr\n         (K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n         (stream_space S) (smap (\\<lambda>(t, y). (t + t', y)))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>.\n            return (stream_space S)\n             ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>)))", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. K (t, s) \\<bind>\n    (\\<lambda>x.\n        distr\n         (K.lim_stream x \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n         (stream_space S) (smap (\\<lambda>(t, y). (t + t', y)))) =\n    K (t, s) \\<bind>\n    (\\<lambda>x.\n        (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n         (t, s) \\<Rightarrow>\n           distr (K.lim_stream (t - t', s)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n        (\\<lambda>\\<omega>.\n            return (stream_space S)\n             ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>)))", "apply (intro bind_cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       distr\n        (K.lim_stream x \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>)))\n        (stream_space S) (smap (\\<lambda>(t, y). (t + t', y))) =\n       (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n        (t, s) \\<Rightarrow>\n          distr (K.lim_stream (t - t', s)) (stream_space S)\n           (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n       (\\<lambda>\\<omega>.\n           return (stream_space S)\n            ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>))", "apply (subst distr_bind[OF measurable_prob_algebraD lim_stream_not_empty])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       (\\<lambda>\\<omega>. return (stream_space S) (x ## \\<omega>))\n       \\<in> K.lim_stream x \\<rightarrow>\\<^sub>M prob_algebra (?K78 x)\n 2. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       smap (\\<lambda>(t, y). (t + t', y))\n       \\<in> ?K78 x \\<rightarrow>\\<^sub>M stream_space S\n 3. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           distr (return (stream_space S) (x ## xa)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) =\n       (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n        (t, s) \\<Rightarrow>\n          distr (K.lim_stream (t - t', s)) (stream_space S)\n           (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n       (\\<lambda>\\<omega>.\n           return (stream_space S)\n            ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>))", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       smap (\\<lambda>(t, y). (t + t', y))\n       \\<in> stream_space S \\<rightarrow>\\<^sub>M stream_space S\n 2. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           distr (return (stream_space S) (x ## xa)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) =\n       (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n        (t, s) \\<Rightarrow>\n          distr (K.lim_stream (t - t', s)) (stream_space S)\n           (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n       (\\<lambda>\\<omega>.\n           return (stream_space S)\n            ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>))", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           distr (return (stream_space S) (x ## xa)) (stream_space S)\n            (smap (\\<lambda>(t, y). (t + t', y)))) =\n       (case case x of (t, x) \\<Rightarrow> (t + t', x) of\n        (t, s) \\<Rightarrow>\n          distr (K.lim_stream (t - t', s)) (stream_space S)\n           (smap (\\<lambda>(t, y). (t + t', y)))) \\<bind>\n       (\\<lambda>\\<omega>.\n           return (stream_space S)\n            ((case x of (t, x) \\<Rightarrow> (t + t', x)) ## \\<omega>))", "apply (simp add: distr_return split_beta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ##\n             smap (\\<lambda>z. (fst z + t', snd z)) xa)) =\n       distr (K.lim_stream x) (stream_space S)\n        (smap (\\<lambda>(t, y). (t + t', y))) \\<bind>\n       (\\<lambda>\\<omega>.\n           return (stream_space S) ((fst x + t', snd x) ## \\<omega>))", "apply (subst bind_distr[OF _ measurable_prob_algebraD lim_stream_not_empty])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       smap (\\<lambda>(t, y). (t + t', y))\n       \\<in> K.lim_stream x \\<rightarrow>\\<^sub>M stream_space S\n 2. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       (\\<lambda>\\<omega>.\n           return (stream_space S) ((fst x + t', snd x) ## \\<omega>))\n       \\<in> stream_space S \\<rightarrow>\\<^sub>M prob_algebra (?K95 x)\n 3. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ##\n             smap (\\<lambda>z. (fst z + t', snd z)) xa)) =\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ## smap (\\<lambda>(t, y). (t + t', y)) xa))", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       (\\<lambda>\\<omega>.\n           return (stream_space S) ((fst x + t', snd x) ## \\<omega>))\n       \\<in> stream_space S \\<rightarrow>\\<^sub>M prob_algebra (?K95 x)\n 2. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ##\n             smap (\\<lambda>z. (fst z + t', snd z)) xa)) =\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ## smap (\\<lambda>(t, y). (t + t', y)) xa))", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (K (t, s)) \\<Longrightarrow>\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ##\n             smap (\\<lambda>z. (fst z + t', snd z)) xa)) =\n       K.lim_stream x \\<bind>\n       (\\<lambda>xa.\n           return (stream_space S)\n            ((fst x + t', snd x) ## smap (\\<lambda>(t, y). (t + t', y)) xa))", "apply (simp add: split_beta')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distr (K.lim_stream (t, s)) (stream_space S)\n   (smap (\\<lambda>a. case a of (t, s) \\<Rightarrow> (t + t', s))) =\n  K (t + t', s) \\<bind>\n  (\\<lambda>y.\n      (case y of\n       (t, s) \\<Rightarrow>\n         distr (K.lim_stream (t - t', s)) (stream_space S)\n          (smap\n            (\\<lambda>a.\n                case a of (t, s) \\<Rightarrow> (t + t', s)))) \\<bind>\n      (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n\ngoal (2 subgoals):\n 1. AE y in K (t + t',\n               s). (\\<exists>t s.\n                       y = (t + t', s) \\<and>\n                       (case y of\n                        (t, s) \\<Rightarrow>\n                          distr (K.lim_stream (t - t', s)) (stream_space S)\n                           (smap\n                             (\\<lambda>a.\n                                 case a of\n                                 (t, s) \\<Rightarrow> (t + t', s)))) =\n                       distr (K.lim_stream (t, s)) (stream_space S)\n                        (smap (\\<lambda>(t, y). (t + t', y)))) \\<or>\n                   K.lim_stream y =\n                   (case y of\n                    (t, s) \\<Rightarrow>\n                      distr (K.lim_stream (t - t', s)) (stream_space S)\n                       (smap\n                         (\\<lambda>a.\n                             case a of (t, s) \\<Rightarrow> (t + t', s))))\n 2. (\\<lambda>(t, s).\n        distr (K.lim_stream (t - t', s)) (stream_space S)\n         (smap (\\<lambda>a. case a of (t, s) \\<Rightarrow> (t + t', s))))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S)", "qed (auto cong: conj_cong intro!: exI[of _ \"_ - t'\"])"], ["proof (state)\nthis:\n  \\<exists>B'\\<in>S \\<rightarrow>\\<^sub>M prob_algebra (stream_space S).\n     (AE y in K (t + t',\n                 s). (\\<exists>t s.\n                         y = (t + t', s) \\<and>\n                         B' y =\n                         distr (K.lim_stream (t, s)) (stream_space S)\n                          (smap (\\<lambda>(t, y). (t + t', y)))) \\<or>\n                     K.lim_stream y = B' y) \\<and>\n     distr (K.lim_stream (t, s)) (stream_space S)\n      (smap (\\<lambda>(t, y). (t + t', y))) =\n     K (t + t', s) \\<bind>\n     (\\<lambda>y.\n         B' y \\<bind>\n         (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. (t + t', s) \\<in> space S", "qed simp"], ["", "lemma lim_0: \"K.lim_stream (t, s) = distr (K.lim_stream (0, s)) T (smap (\\<lambda>(t', s). (t' + t, s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) =\n    distr (K.lim_stream (0, s)) (stream_space S)\n     (smap (\\<lambda>(t', s). (t' + t, s)))", "using lim_shift[of 0 t s]"], ["proof (prove)\nusing this:\n  K.lim_stream (0 + t, s) =\n  distr (K.lim_stream (0, s)) (stream_space S)\n   (smap (\\<lambda>(ta, s). (ta + t, s)))\n\ngoal (1 subgoal):\n 1. K.lim_stream (t, s) =\n    distr (K.lim_stream (0, s)) (stream_space S)\n     (smap (\\<lambda>(t', s). (t' + t, s)))", "by simp"], ["", "subsection \\<open>Explosion time\\<close>"], ["", "definition explosion :: \"(real \\<times> 'a) stream \\<Rightarrow> ereal\"\n  where \"explosion \\<omega> = (SUP i. ereal (fst (\\<omega> !! i)))\""], ["", "lemma ball_less_Suc_eq: \"(\\<forall>i<Suc n. P i) \\<longleftrightarrow> (P 0 \\<and> (\\<forall>i<n. P (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<Suc n. P i) = (P 0 \\<and> (\\<forall>i<n. P (Suc i)))", "using less_Suc_eq_0_disj"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m = 0 \\<or> (\\<exists>j. ?m = Suc j \\<and> j < ?n))\n\ngoal (1 subgoal):\n 1. (\\<forall>i<Suc n. P i) = (P 0 \\<and> (\\<forall>i<n. P (Suc i)))", "by auto"], ["", "lemma lim_stream_timediff_eq_exponential_1:\n  \"distr (K.lim_stream ts) (PiM UNIV (\\<lambda>_. borel))\n    (\\<lambda>\\<omega> i. escape_rate (snd ((ts##\\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((ts##\\<omega>) !! i))) =\n    PiM UNIV (\\<lambda>_. exponential 1)\"\n  (is \"?D = ?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))) =\n    Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1)", "proof (rule measure_eqI_PiM_sequence)"], ["proof (state)\ngoal (4 subgoals):\n 1. sets\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i)))) =\n    sets (Pi\\<^sub>M UNIV ?M)\n 2. sets (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1)) =\n    sets (Pi\\<^sub>M UNIV ?M)\n 3. \\<And>A n.\n       (\\<And>i. A i \\<in> sets (?M i)) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV ?M {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV ?M {..n} (Pi\\<^sub>E {..n} A))\n 4. finite_measure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "show \"sets ?D = sets (PiM UNIV (\\<lambda>_. borel))\" \"sets ?P = sets (PiM UNIV (\\<lambda>_. borel))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i)))) =\n    sets (Pi\\<^sub>M UNIV (\\<lambda>_. borel)) &&&\n    sets (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1)) =\n    sets (Pi\\<^sub>M UNIV (\\<lambda>_. borel))", "by (auto intro!: sets_PiM_cong simp: sets_exponential)"], ["proof (state)\nthis:\n  sets\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i)))) =\n  sets (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n  sets (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1)) =\n  sets (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n\ngoal (2 subgoals):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))\n 2. finite_measure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "have [measurable]: \"ts \\<in> space S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<in> space S", "by auto"], ["proof (state)\nthis:\n  ts \\<in> space S\n\ngoal (2 subgoals):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))\n 2. finite_measure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "{"], ["proof (state)\nthis:\n  ts \\<in> space S\n\ngoal (2 subgoals):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))\n 2. finite_measure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "interpret prob_space ?D"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "by (intro prob_space.prob_space_distr K.prob_space_lim_stream measurable_abs_UNIV) auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))\n 2. finite_measure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "show \"finite_measure ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_measure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))", "by unfold_locales"], ["proof (state)\nthis:\n  finite_measure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "}"], ["proof (state)\nthis:\n  finite_measure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "interpret E: prob_space \"exponential 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (exponential 1)", "by (rule prob_space_exponential) simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "interpret P: product_prob_space \"\\<lambda>_. exponential 1\" UNIV"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_prob_space (\\<lambda>_. exponential 1)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "let \"distr _ _ (?f ts)\" = ?D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "fix A :: \"nat \\<Rightarrow> real set\" and n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "assume A[measurable]: \"\\<And>i. A i \\<in> sets borel\""], ["proof (state)\nthis:\n  A ?i1 \\<in> sets borel\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "define n' where \"n' = Suc n\""], ["proof (state)\nthis:\n  n' = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "have \"emeasure ?D (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n    emeasure (K.lim_stream ts) {\\<omega>\\<in>space (stream_space S). \\<forall>i<n'. ?f ts \\<omega> i \\<in> A i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n     (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n    emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<n'.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i}", "apply (subst emeasure_distr)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>\\<omega> i.\n        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i)))\n    \\<in> K.lim_stream ts \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M UNIV (\\<lambda>_. borel)\n 2. prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)\n    \\<in> sets (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n 3. emeasure (K.lim_stream ts)\n     ((\\<lambda>\\<omega> i.\n          escape_rate (snd ((ts ## \\<omega>) !! i)) *\n          (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))) -`\n      prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A) \\<inter>\n      space (K.lim_stream ts)) =\n    emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<n'.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i}", "apply (auto intro!: measurable_abs_UNIV arg_cong[where f=\"emeasure _\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x i.\n       \\<lbrakk>x \\<in> space (K.lim_stream ts);\n        (\\<lambda>i.\n            escape_rate (snd ((ts ## x) !! i)) *\n            (fst (x !! i) - fst ((ts ## x) !! i)))\n        \\<in> prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A);\n        i < n'\\<rbrakk>\n       \\<Longrightarrow> escape_rate (snd ((ts ## x) !! i)) *\n                         (fst (x !! i) - fst ((ts ## x) !! i))\n                         \\<in> A i\n 2. \\<And>x.\n       \\<forall>i<n'.\n          escape_rate (snd ((ts ## x) !! i)) *\n          (fst (x !! i) - fst ((ts ## x) !! i))\n          \\<in> A i \\<Longrightarrow>\n       (\\<lambda>i.\n           escape_rate (snd ((ts ## x) !! i)) *\n           (fst (x !! i) - fst ((ts ## x) !! i)))\n       \\<in> prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)\n 3. \\<And>x.\n       \\<forall>i<n'.\n          escape_rate (snd ((ts ## x) !! i)) *\n          (fst (x !! i) - fst ((ts ## x) !! i))\n          \\<in> A i \\<Longrightarrow>\n       x \\<in> space (K.lim_stream ts)", "apply (auto simp: prod_emb_def K.space_lim_stream space_pair_measure n'_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n   (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<n'.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i}\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "also"], ["proof (state)\nthis:\n  emeasure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n   (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<n'.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i}\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "have \"\\<dots> = (\\<Prod>i<n'. emeasure (exponential 1) (A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<n'.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i} =\n    (\\<Prod>i<n'. emeasure (exponential 1) (A i))", "using A"], ["proof (prove)\nusing this:\n  A ?i1 \\<in> sets borel\n\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<n'.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i} =\n    (\\<Prod>i<n'. emeasure (exponential 1) (A i))", "proof (induction n' arbitrary: A ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A ts.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure (K.lim_stream ts)\n        {\\<omega> \\<in> space (stream_space S).\n         \\<forall>i<0.\n            escape_rate (snd ((ts ## \\<omega>) !! i)) *\n            (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n            \\<in> A i} =\n       (\\<Prod>i<0. emeasure (exponential 1) (A i))\n 2. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "case 0"], ["proof (state)\nthis:\n  A ?i1 \\<in> sets borel\n\ngoal (2 subgoals):\n 1. \\<And>A ts.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure (K.lim_stream ts)\n        {\\<omega> \\<in> space (stream_space S).\n         \\<forall>i<0.\n            escape_rate (snd ((ts ## \\<omega>) !! i)) *\n            (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n            \\<in> A i} =\n       (\\<Prod>i<0. emeasure (exponential 1) (A i))\n 2. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "then"], ["proof (chain)\npicking this:\n  A ?i1 \\<in> sets borel", "show ?case"], ["proof (prove)\nusing this:\n  A ?i1 \\<in> sets borel\n\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<0.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i} =\n    (\\<Prod>i<0. emeasure (exponential 1) (A i))", "using prob_space.emeasure_space_1[OF prob_space_K_lim]"], ["proof (prove)\nusing this:\n  A ?i1 \\<in> sets borel\n  emeasure (K.lim_stream ?x1) (space (K.lim_stream ?x1)) = 1\n\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<0.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i} =\n    (\\<Prod>i<0. emeasure (exponential 1) (A i))", "by (simp add: K.space_lim_stream space_pair_measure)"], ["proof (state)\nthis:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<0.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  (\\<Prod>i<0. emeasure (exponential 1) (A i))\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "case (Suc n A ts)"], ["proof (state)\nthis:\n  (\\<And>i. ?A1 i \\<in> sets borel) \\<Longrightarrow>\n  emeasure (K.lim_stream ?ts1)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<n.\n       escape_rate (snd ((?ts1 ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((?ts1 ## \\<omega>) !! i))\n       \\<in> ?A1 i} =\n  (\\<Prod>i<n. emeasure (exponential 1) (?A1 i))\n  A ?i1 \\<in> sets borel\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "from Suc.prems[measurable]"], ["proof (chain)\npicking this:\n  A ?i1 \\<in> sets borel", "have [measurable]: \"ts \\<in> space S\""], ["proof (prove)\nusing this:\n  A ?i1 \\<in> sets borel\n\ngoal (1 subgoal):\n 1. ts \\<in> space S", "by auto"], ["proof (state)\nthis:\n  ts \\<in> space S\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "have \"emeasure (K.lim_stream ts) {\\<omega> \\<in> space (stream_space S). \\<forall>i<Suc n. ?f ts \\<omega> i \\<in> A i} =\n      (\\<integral>\\<^sup>+ts'. indicator (A 0) (escape_rate (snd ts) * (fst ts' - fst ts)) *\n        emeasure (K.lim_stream ts') {\\<omega> \\<in> space (stream_space S). \\<forall>i<n. ?f ts' \\<omega> i \\<in> A (Suc i)} \\<partial>K ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<Suc n.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i} =\n    \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                         emeasure (K.lim_stream ts')\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<n.\n                              escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts' ## \\<omega>) !! i))\n                              \\<in> A (Suc i)}\n                       \\<partial>K ts", "apply (subst K.emeasure_lim_stream)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ts \\<in> space S\n 2. {\\<omega> \\<in> space (stream_space S).\n     \\<forall>i<Suc n.\n        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n        \\<in> A i}\n    \\<in> sets (stream_space S)\n 3. \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            ((##) y -`\n                             {\\<omega> \\<in> space (stream_space S).\n                              \\<forall>i<Suc n.\n                                 escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                                 (fst (\\<omega> !! i) -\n                                  fst ((ts ## \\<omega>) !! i))\n                                 \\<in> A i} \\<inter>\n                             space (stream_space S))\n                       \\<partial>K ts =\n    \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                         emeasure (K.lim_stream ts')\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<n.\n                              escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts' ## \\<omega>) !! i))\n                              \\<in> A (Suc i)}\n                       \\<partial>K ts", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<omega> \\<in> space (stream_space S).\n     \\<forall>i<Suc n.\n        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n        \\<in> A i}\n    \\<in> sets (stream_space S)\n 2. \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            ((##) y -`\n                             {\\<omega> \\<in> space (stream_space S).\n                              \\<forall>i<Suc n.\n                                 escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                                 (fst (\\<omega> !! i) -\n                                  fst ((ts ## \\<omega>) !! i))\n                                 \\<in> A i} \\<inter>\n                             space (stream_space S))\n                       \\<partial>K ts =\n    \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                         emeasure (K.lim_stream ts')\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<n.\n                              escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts' ## \\<omega>) !! i))\n                              \\<in> A (Suc i)}\n                       \\<partial>K ts", "apply measurable"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            ((##) y -`\n                             {\\<omega> \\<in> space (stream_space S).\n                              \\<forall>i<Suc n.\n                                 escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                                 (fst (\\<omega> !! i) -\n                                  fst ((ts ## \\<omega>) !! i))\n                                 \\<in> A i} \\<inter>\n                             space (stream_space S))\n                       \\<partial>K ts =\n    \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                         emeasure (K.lim_stream ts')\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<n.\n                              escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts' ## \\<omega>) !! i))\n                              \\<in> A (Suc i)}\n                       \\<partial>K ts", "apply (auto intro!: nn_integral_cong arg_cong2[where f=emeasure] split: split_indicator\n        simp: ball_less_Suc_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<Suc n.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                       emeasure (K.lim_stream ts')\n                        {\\<omega> \\<in> space (stream_space S).\n                         \\<forall>i<n.\n                            escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                            (fst (\\<omega> !! i) -\n                             fst ((ts' ## \\<omega>) !! i))\n                            \\<in> A (Suc i)}\n                     \\<partial>K ts\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "also"], ["proof (state)\nthis:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<Suc n.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                       emeasure (K.lim_stream ts')\n                        {\\<omega> \\<in> space (stream_space S).\n                         \\<forall>i<n.\n                            escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                            (fst (\\<omega> !! i) -\n                             fst ((ts' ## \\<omega>) !! i))\n                            \\<in> A (Suc i)}\n                     \\<partial>K ts\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "have \"\\<dots> = (\\<integral>\\<^sup>+ts'. indicator (A 0) (escape_rate (snd ts) * (fst ts' - fst ts)) \\<partial>K ts) *\n      (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                         emeasure (K.lim_stream ts')\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<n.\n                              escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts' ## \\<omega>) !! i))\n                              \\<in> A (Suc i)}\n                       \\<partial>K ts =\n    \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts))\n                       \\<partial>K ts *\n    (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i)))", "by (subst Suc.IH) (simp_all add: nn_integral_multc)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                       emeasure (K.lim_stream ts')\n                        {\\<omega> \\<in> space (stream_space S).\n                         \\<forall>i<n.\n                            escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                            (fst (\\<omega> !! i) -\n                             fst ((ts' ## \\<omega>) !! i))\n                            \\<in> A (Suc i)}\n                     \\<partial>K ts =\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts))\n                     \\<partial>K ts *\n  (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts)) *\n                       emeasure (K.lim_stream ts')\n                        {\\<omega> \\<in> space (stream_space S).\n                         \\<forall>i<n.\n                            escape_rate (snd ((ts' ## \\<omega>) !! i)) *\n                            (fst (\\<omega> !! i) -\n                             fst ((ts' ## \\<omega>) !! i))\n                            \\<in> A (Suc i)}\n                     \\<partial>K ts =\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts))\n                     \\<partial>K ts *\n  (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i)))\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "have \"(\\<integral>\\<^sup>+ts'. indicator (A 0) (escape_rate (snd ts) * (fst ts' - fst ts)) \\<partial>K ts) =\n      (\\<integral>\\<^sup>+t. indicator (A 0) (escape_rate (snd ts) * t) \\<partial>exponential (escape_rate (snd ts)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ ts'.\n                         indicator (A 0)\n                          (escape_rate (snd ts) * (fst ts' - fst ts))\n                       \\<partial>K ts =\n    \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                       \\<partial>exponential (escape_rate (snd ts))", "by (simp add: K_def exp_esc.nn_integral_snd[symmetric] nn_integral_distr split: prod.split)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts))\n                     \\<partial>K ts =\n  \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                     \\<partial>exponential (escape_rate (snd ts))\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ ts'.\n                       indicator (A 0)\n                        (escape_rate (snd ts) * (fst ts' - fst ts))\n                     \\<partial>K ts =\n  \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                     \\<partial>exponential (escape_rate (snd ts))\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "have \"\\<dots> = emeasure (exponential 1) (A 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                       \\<partial>exponential (escape_rate (snd ts)) =\n    emeasure (exponential 1) (A 0)", "using escape_rate_pos[of \"snd ts\"]"], ["proof (prove)\nusing this:\n  0 < escape_rate (snd ts)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                       \\<partial>exponential (escape_rate (snd ts)) =\n    emeasure (exponential 1) (A 0)", "by (subst exponential_eq_stretch) (simp_all add: nn_integral_distr)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                     \\<partial>exponential (escape_rate (snd ts)) =\n  emeasure (exponential 1) (A 0)\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. indicator (A 0) (escape_rate (snd ts) * t)\n                     \\<partial>exponential (escape_rate (snd ts)) =\n  emeasure (exponential 1) (A 0)\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "have \"emeasure (exponential 1) (A 0) * (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i))) =\n      (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (exponential 1) (A 0) *\n    (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i))) =\n    (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))", "by (rule prod.lessThan_Suc_shift[symmetric])"], ["proof (state)\nthis:\n  emeasure (exponential 1) (A 0) *\n  (\\<Prod>i<n. emeasure (exponential 1) (A (Suc i))) =\n  (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))\n\ngoal (1 subgoal):\n 1. \\<And>n' A ts.\n       \\<lbrakk>\\<And>A ts.\n                   (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n                   emeasure (K.lim_stream ts)\n                    {\\<omega> \\<in> space (stream_space S).\n                     \\<forall>i<n'.\n                        escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n                        \\<in> A i} =\n                   (\\<Prod>i<n'. emeasure (exponential 1) (A i));\n        \\<And>i. A i \\<in> sets borel\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream ts)\n                          {\\<omega> \\<in> space (stream_space S).\n                           \\<forall>i<Suc n'.\n                              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n                              (fst (\\<omega> !! i) -\n                               fst ((ts ## \\<omega>) !! i))\n                              \\<in> A i} =\n                         (\\<Prod>i<Suc n'. emeasure (exponential 1) (A i))", "finally"], ["proof (chain)\npicking this:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<Suc n.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))", "show ?case"], ["proof (prove)\nusing this:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<Suc n.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))\n\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream ts)\n     {\\<omega> \\<in> space (stream_space S).\n      \\<forall>i<Suc n.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n         \\<in> A i} =\n    (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))", "."], ["proof (state)\nthis:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<Suc n.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  (\\<Prod>i<Suc n. emeasure (exponential 1) (A i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<n'.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  (\\<Prod>i<n'. emeasure (exponential 1) (A i))\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "also"], ["proof (state)\nthis:\n  emeasure (K.lim_stream ts)\n   {\\<omega> \\<in> space (stream_space S).\n    \\<forall>i<n'.\n       escape_rate (snd ((ts ## \\<omega>) !! i)) *\n       (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))\n       \\<in> A i} =\n  (\\<Prod>i<n'. emeasure (exponential 1) (A i))\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "have \"\\<dots> = emeasure ?P (prod_emb UNIV (\\<lambda>_. borel) {..<n'} (Pi\\<^sub>E {..<n'} A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n'. emeasure (exponential 1) (A i)) =\n    emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n     (prod_emb UNIV (\\<lambda>_. borel) {..<n'} (Pi\\<^sub>E {..<n'} A))", "using P.emeasure_PiM_emb[of \"{..<n'}\" A]"], ["proof (prove)\nusing this:\n  \\<lbrakk>{..<n'} \\<subseteq> UNIV; finite {..<n'};\n   \\<And>i. i \\<in> {..<n'} \\<Longrightarrow> A i \\<in> E.events\\<rbrakk>\n  \\<Longrightarrow> emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n                     (P.emb UNIV {..<n'} (Pi\\<^sub>E {..<n'} A)) =\n                    (\\<Prod>i<n'. emeasure (exponential 1) (A i))\n\ngoal (1 subgoal):\n 1. (\\<Prod>i<n'. emeasure (exponential 1) (A i)) =\n    emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n     (prod_emb UNIV (\\<lambda>_. borel) {..<n'} (Pi\\<^sub>E {..<n'} A))", "by (simp add: prod_emb_def space_exponential)"], ["proof (state)\nthis:\n  (\\<Prod>i<n'. emeasure (exponential 1) (A i)) =\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n   (prod_emb UNIV (\\<lambda>_. borel) {..<n'} (Pi\\<^sub>E {..<n'} A))\n\ngoal (1 subgoal):\n 1. \\<And>A n.\n       (\\<And>i. A i \\<in> sets borel) \\<Longrightarrow>\n       emeasure\n        (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n          (\\<lambda>\\<omega> i.\n              escape_rate (snd ((ts ## \\<omega>) !! i)) *\n              (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n       emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n        (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "finally"], ["proof (chain)\npicking this:\n  emeasure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n   (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n   (prod_emb UNIV (\\<lambda>_. borel) {..<n'} (Pi\\<^sub>E {..<n'} A))", "show \"emeasure ?D (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n    emeasure ?P (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))\""], ["proof (prove)\nusing this:\n  emeasure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n   (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n   (prod_emb UNIV (\\<lambda>_. borel) {..<n'} (Pi\\<^sub>E {..<n'} A))\n\ngoal (1 subgoal):\n 1. emeasure\n     (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n       (\\<lambda>\\<omega> i.\n           escape_rate (snd ((ts ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n     (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n    emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n     (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))", "by (simp add: n'_def lessThan_Suc_atMost)"], ["proof (state)\nthis:\n  emeasure\n   (distr (K.lim_stream ts) (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n     (\\<lambda>\\<omega> i.\n         escape_rate (snd ((ts ## \\<omega>) !! i)) *\n         (fst (\\<omega> !! i) - fst ((ts ## \\<omega>) !! i))))\n   (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A)) =\n  emeasure (Pi\\<^sub>M UNIV (\\<lambda>_. exponential 1))\n   (prod_emb UNIV (\\<lambda>_. borel) {..n} (Pi\\<^sub>E {..n} A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_explosion_infty:\n  assumes bdd: \"bdd_above (range escape_rate)\"\n  shows \"AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "have \"escape_rate undefined \\<le> (SUP x. escape_rate x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. escape_rate undefined \\<le> \\<Squnion> range escape_rate", "using bdd"], ["proof (prove)\nusing this:\n  bdd_above (range escape_rate)\n\ngoal (1 subgoal):\n 1. escape_rate undefined \\<le> \\<Squnion> range escape_rate", "by (intro cSUP_upper) auto"], ["proof (state)\nthis:\n  escape_rate undefined \\<le> \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  escape_rate undefined \\<le> \\<Squnion> range escape_rate", "have SUP_escape_pos: \"0 < (SUP x. escape_rate x)\""], ["proof (prove)\nusing this:\n  escape_rate undefined \\<le> \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. 0 < \\<Squnion> range escape_rate", "using escape_rate_pos[of undefined]"], ["proof (prove)\nusing this:\n  escape_rate undefined \\<le> \\<Squnion> range escape_rate\n  0 < escape_rate undefined\n\ngoal (1 subgoal):\n 1. 0 < \\<Squnion> range escape_rate", "by simp"], ["proof (state)\nthis:\n  0 < \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  0 < \\<Squnion> range escape_rate", "have SUP_escape_nonneg: \"0 \\<le> (SUP x. escape_rate x)\""], ["proof (prove)\nusing this:\n  0 < \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Squnion> range escape_rate", "by (rule less_imp_le)"], ["proof (state)\nthis:\n  0 \\<le> \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "have [measurable]: \"x \\<in> space S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> space S", "by auto"], ["proof (state)\nthis:\n  x \\<in> space S\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "have \"(\\<Sum>i. 1::ennreal) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. 1) = \\<top>", "by (rule sums_unique[symmetric]) (auto simp: sums_def of_nat_tendsto_top_ennreal)"], ["proof (state)\nthis:\n  (\\<Sum>i. 1) = \\<top>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i. 1) = \\<top>", "have \"AE \\<omega> in (PiM UNIV (\\<lambda>_. exponential 1)). (\\<Sum>i. ereal (\\<omega> i)) = \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<Sum>i. 1) = \\<top>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in Pi\\<^sub>M UNIV\n                    (\\<lambda>_.\n                        exponential\n                         1). (\\<Sum>i. ereal (\\<omega> i)) = \\<infinity>", "by (intro AE_PiM_exponential_suminf_infty) auto"], ["proof (state)\nthis:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>_.\n                      exponential\n                       1). (\\<Sum>i. ereal (\\<omega> i)) = \\<infinity>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>_.\n                      exponential\n                       1). (\\<Sum>i. ereal (\\<omega> i)) = \\<infinity>", "have \"AE \\<omega> in K.lim_stream x.\n    (\\<Sum>i. ereal (escape_rate (snd ((x##\\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((x##\\<omega>) !! i)))) = \\<infinity>\""], ["proof (prove)\nusing this:\n  AE \\<omega> in Pi\\<^sub>M UNIV\n                  (\\<lambda>_.\n                      exponential\n                       1). (\\<Sum>i. ereal (\\<omega> i)) = \\<infinity>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    x. (\\<Sum>i.\n                           ereal\n                            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                             (fst (\\<omega> !! i) -\n                              fst ((x ## \\<omega>) !! i)))) =\n                       \\<infinity>", "apply (subst (asm) lim_stream_timediff_eq_exponential_1[symmetric, of x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in distr (K.lim_stream x)\n                    (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n                    (\\<lambda>\\<omega> i.\n                        escape_rate (snd ((x ## \\<omega>) !! i)) *\n                        (fst (\\<omega> !! i) -\n                         fst ((x ## \\<omega>) !!\n                              i))). (\\<Sum>i. ereal (\\<omega> i)) =\n                                    \\<infinity> \\<Longrightarrow>\n    AE \\<omega> in K.lim_stream\n                    x. (\\<Sum>i.\n                           ereal\n                            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                             (fst (\\<omega> !! i) -\n                              fst ((x ## \\<omega>) !! i)))) =\n                       \\<infinity>", "apply (subst (asm) AE_distr_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>\\<omega> i.\n        escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))\n    \\<in> K.lim_stream x \\<rightarrow>\\<^sub>M\n          Pi\\<^sub>M UNIV (\\<lambda>_. borel)\n 2. {x \\<in> space (Pi\\<^sub>M UNIV (\\<lambda>_. borel)).\n     (\\<Sum>i. ereal (x i)) = \\<infinity>}\n    \\<in> sets (Pi\\<^sub>M UNIV (\\<lambda>_. borel))\n 3. AE xa in K.lim_stream\n              x. (\\<Sum>i.\n                     ereal\n                      (escape_rate (snd ((x ## xa) !! i)) *\n                       (fst (xa !! i) - fst ((x ## xa) !! i)))) =\n                 \\<infinity> \\<Longrightarrow>\n    AE \\<omega> in K.lim_stream\n                    x. (\\<Sum>i.\n                           ereal\n                            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                             (fst (\\<omega> !! i) -\n                              fst ((x ## \\<omega>) !! i)))) =\n                       \\<infinity>", "apply (auto intro!: measurable_abs_UNIV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream\n                  x. (\\<Sum>i.\n                         ereal\n                          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                           (fst (\\<omega> !! i) -\n                            fst ((x ## \\<omega>) !! i)))) =\n                     \\<infinity>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in K.lim_stream\n                  x. (\\<Sum>i.\n                         ereal\n                          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                           (fst (\\<omega> !! i) -\n                            fst ((x ## \\<omega>) !! i)))) =\n                     \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream\n                  x. (\\<Sum>i.\n                         ereal\n                          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                           (fst (\\<omega> !! i) -\n                            fst ((x ## \\<omega>) !! i)))) =\n                     \\<infinity>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "using AE_lim_stream"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream\n                  x. (\\<Sum>i.\n                         ereal\n                          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                           (fst (\\<omega> !! i) -\n                            fst ((x ## \\<omega>) !! i)))) =\n                     \\<infinity>\n  AE \\<omega> in K.lim_stream\n                  ?x. \\<forall>i.\n                         snd ((?x ## \\<omega>) !! i)\n                         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                               {snd ?x} \\<and>\n                         snd (\\<omega> !! i)\n                         \\<in> set_pmf\n                                (J (snd ((?x ## \\<omega>) !! i))) \\<and>\n                         fst ((?x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "case (elim \\<omega>)"], ["proof (state)\nthis:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)", "have le: \"fst ((x##\\<omega>) !! n) \\<le> fst ((x ## \\<omega>) !! m)\" if \"n \\<le> m\" for n m"], ["proof (prove)\nusing this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. fst ((x ## \\<omega>) !! n) \\<le> fst ((x ## \\<omega>) !! m)", "by (intro lift_Suc_mono_le[OF _ \\<open>n \\<le> m\\<close>, of \"\\<lambda>i. fst ((x ## \\<omega>) !! i)\"]) (auto intro: less_imp_le)"], ["proof (state)\nthis:\n  ?n1 \\<le> ?m1 \\<Longrightarrow>\n  fst ((x ## \\<omega>) !! ?n1) \\<le> fst ((x ## \\<omega>) !! ?m1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "have [simp]: \"fst x \\<le> fst ((x##\\<omega>) !! i)\" \"fst ((x##\\<omega>) !! i) \\<le> fst (\\<omega> !! i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst x \\<le> fst ((x ## \\<omega>) !! i) &&&\n    fst ((x ## \\<omega>) !! i) \\<le> fst (\\<omega> !! i)", "using le[of \"i\" \"Suc i\"] le[of 0 i]"], ["proof (prove)\nusing this:\n  i \\<le> Suc i \\<Longrightarrow>\n  fst ((x ## \\<omega>) !! i) \\<le> fst ((x ## \\<omega>) !! Suc i)\n  0 \\<le> i \\<Longrightarrow>\n  fst ((x ## \\<omega>) !! 0) \\<le> fst ((x ## \\<omega>) !! i)\n\ngoal (1 subgoal):\n 1. fst x \\<le> fst ((x ## \\<omega>) !! i) &&&\n    fst ((x ## \\<omega>) !! i) \\<le> fst (\\<omega> !! i)", "by auto"], ["proof (state)\nthis:\n  fst x \\<le> fst ((x ## \\<omega>) !! ?i1)\n  fst ((x ## \\<omega>) !! ?i1) \\<le> fst (\\<omega> !! ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "have \"(\\<Sum>i. ereal (escape_rate (snd ((x ## \\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n      (SUP n. \\<Sum>i<n. ereal (escape_rate (snd ((x ## \\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i.\n        ereal\n         (escape_rate (snd ((x ## \\<omega>) !! i)) *\n          (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n    (\\<Squnion>n.\n        \\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))", "by (intro suminf_ereal_eq_SUP) (auto intro!: mult_nonneg_nonneg)"], ["proof (state)\nthis:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  (\\<Squnion>n.\n      \\<Sum>i<n.\n         ereal\n          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  (\\<Squnion>n.\n      \\<Sum>i<n.\n         ereal\n          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "have \"\\<dots> \\<le> (SUP n. (SUP x. escape_rate x) * (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        \\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n    \\<le> (\\<Squnion>n.\n              ereal (\\<Squnion> range escape_rate) *\n              (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x)))", "proof (intro SUP_least SUP_upper2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "have \"(\\<Sum>i<n. ereal (escape_rate (snd ((x ## \\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) \\<le>\n        (\\<Sum>i<n. ereal ((SUP i. escape_rate i) * (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        ereal\n         (escape_rate (snd ((x ## \\<omega>) !! i)) *\n          (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n    \\<le> (\\<Sum>i<n.\n              ereal\n               (\\<Squnion> range escape_rate *\n                (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))", "using elim bdd"], ["proof (prove)\nusing this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n  bdd_above (range escape_rate)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        ereal\n         (escape_rate (snd ((x ## \\<omega>) !! i)) *\n          (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n    \\<le> (\\<Sum>i<n.\n              ereal\n               (\\<Squnion> range escape_rate *\n                (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))", "by (intro sum_mono) (auto intro!: cSUP_upper)"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> (\\<Sum>i<n.\n            ereal\n             (\\<Squnion> range escape_rate *\n              (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> (\\<Sum>i<n.\n            ereal\n             (\\<Squnion> range escape_rate *\n              (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "have \"\\<dots> = (SUP i. escape_rate i) * (\\<Sum>i<n. fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        ereal\n         (\\<Squnion> range escape_rate *\n          (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n    ereal\n     (\\<Squnion> range escape_rate *\n      (\\<Sum>i<n.\n          fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i)))", "using elim bdd"], ["proof (prove)\nusing this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n  bdd_above (range escape_rate)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        ereal\n         (\\<Squnion> range escape_rate *\n          (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n    ereal\n     (\\<Squnion> range escape_rate *\n      (\\<Sum>i<n.\n          fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i)))", "by (subst sum_ereal) (auto simp: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      ereal\n       (\\<Squnion> range escape_rate *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  ereal\n   (\\<Squnion> range escape_rate *\n    (\\<Sum>i<n.\n        fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i)))\n\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      ereal\n       (\\<Squnion> range escape_rate *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  ereal\n   (\\<Squnion> range escape_rate *\n    (\\<Sum>i<n.\n        fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i)))\n\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "have \"\\<dots> = (SUP i. escape_rate i) * (fst ((x ## \\<omega>) !! n) - fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ereal\n     (\\<Squnion> range escape_rate *\n      (\\<Sum>i<n.\n          fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i))) =\n    ereal\n     (\\<Squnion> range escape_rate * (fst ((x ## \\<omega>) !! n) - fst x))", "by (subst sum_lessThan_telescope) simp"], ["proof (state)\nthis:\n  ereal\n   (\\<Squnion> range escape_rate *\n    (\\<Sum>i<n.\n        fst ((x ## \\<omega>) !! Suc i) - fst ((x ## \\<omega>) !! i))) =\n  ereal\n   (\\<Squnion> range escape_rate * (fst ((x ## \\<omega>) !! n) - fst x))\n\ngoal (2 subgoals):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> ?n1 n \\<in> UNIV\n 2. \\<And>n.\n       n \\<in> UNIV \\<Longrightarrow>\n       (\\<Sum>i<n.\n           ereal\n            (escape_rate (snd ((x ## \\<omega>) !! i)) *\n             (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n       \\<le> ereal (\\<Squnion> range escape_rate) *\n             (ereal (fst ((x ## \\<omega>) !! ?n1 n)) - ereal (fst x))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i<n.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> ereal\n         (\\<Squnion> range escape_rate *\n          (fst ((x ## \\<omega>) !! n) - fst x))", "show \"(\\<Sum>i<n. ereal (escape_rate (snd ((x ## \\<omega>) !! i)) * (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n         \\<le> (SUP x. escape_rate x) * (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))\""], ["proof (prove)\nusing this:\n  (\\<Sum>i<n.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> ereal\n         (\\<Squnion> range escape_rate *\n          (fst ((x ## \\<omega>) !! n) - fst x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        ereal\n         (escape_rate (snd ((x ## \\<omega>) !! i)) *\n          (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n    \\<le> ereal (\\<Squnion> range escape_rate) *\n          (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> ereal (\\<Squnion> range escape_rate) *\n        (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))\n\ngoal (1 subgoal):\n 1. \\<And>n. n \\<in> UNIV \\<Longrightarrow> n \\<in> UNIV", "qed simp"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      \\<Sum>i<n.\n         ereal\n          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> (\\<Squnion>n.\n            ereal (\\<Squnion> range escape_rate) *\n            (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      \\<Sum>i<n.\n         ereal\n          (escape_rate (snd ((x ## \\<omega>) !! i)) *\n           (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> (\\<Squnion>n.\n            ereal (\\<Squnion> range escape_rate) *\n            (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "have \"\\<dots> = (SUP x. escape_rate x) * ((SUP n. ereal (fst ((x ## \\<omega>) !! n))) - ereal (fst x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        ereal (\\<Squnion> range escape_rate) *\n        (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))) =\n    ereal (\\<Squnion> range escape_rate) *\n    ((\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) - ereal (fst x))", "using elim SUP_escape_nonneg"], ["proof (prove)\nusing this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n  0 \\<le> \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. (\\<Squnion>n.\n        ereal (\\<Squnion> range escape_rate) *\n        (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))) =\n    ereal (\\<Squnion> range escape_rate) *\n    ((\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) - ereal (fst x))", "by (subst SUP_ereal_mult_left) (auto simp: SUP_ereal_minus_left[symmetric])"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      ereal (\\<Squnion> range escape_rate) *\n      (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))) =\n  ereal (\\<Squnion> range escape_rate) *\n  ((\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) - ereal (fst x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "also"], ["proof (state)\nthis:\n  (\\<Squnion>n.\n      ereal (\\<Squnion> range escape_rate) *\n      (ereal (fst ((x ## \\<omega>) !! n)) - ereal (fst x))) =\n  ereal (\\<Squnion> range escape_rate) *\n  ((\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) - ereal (fst x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "have \"(SUP n. ereal (fst ((x ## \\<omega>) !! n))) = explosion \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) = explosion \\<omega>", "unfolding explosion_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) =\n    (\\<Squnion>i. ereal (fst (\\<omega> !! i)))", "apply (intro SUP_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> UNIV \\<Longrightarrow>\n       \\<exists>j\\<in>UNIV.\n          ereal (fst ((x ## \\<omega>) !! i))\n          \\<le> ereal (fst (\\<omega> !! j))\n 2. \\<And>j.\n       j \\<in> UNIV \\<Longrightarrow>\n       \\<exists>i\\<in>UNIV.\n          ereal (fst (\\<omega> !! j))\n          \\<le> ereal (fst ((x ## \\<omega>) !! i))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> UNIV \\<Longrightarrow>\n    \\<exists>j\\<in>UNIV.\n       ereal (fst ((x ## \\<omega>) !! i)) \\<le> ereal (fst (\\<omega> !! j))", "by (intro bexI[of _ i]) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       j \\<in> UNIV \\<Longrightarrow>\n       \\<exists>i\\<in>UNIV.\n          ereal (fst (\\<omega> !! j))\n          \\<le> ereal (fst ((x ## \\<omega>) !! i))", "subgoal for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> UNIV \\<Longrightarrow>\n    \\<exists>ia\\<in>UNIV.\n       ereal (fst (\\<omega> !! i)) \\<le> ereal (fst ((x ## \\<omega>) !! ia))", "by (intro bexI[of _ \"Suc i\"]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Squnion>n. ereal (fst ((x ## \\<omega>) !! n))) = explosion \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>(\\<Sum>i.\n                    ereal\n                     (escape_rate (snd ((x ## \\<omega>) !! i)) *\n                      (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n                \\<infinity>;\n        \\<forall>i.\n           snd ((x ## \\<omega>) !! i)\n           \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                 {snd x} \\<and>\n           snd (\\<omega> !! i)\n           \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n           fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\\<rbrakk>\n       \\<Longrightarrow> explosion \\<omega> = \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> ereal (\\<Squnion> range escape_rate) *\n        (explosion \\<omega> - ereal (fst x))", "show \"explosion \\<omega> = \\<infinity>\""], ["proof (prove)\nusing this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> ereal (\\<Squnion> range escape_rate) *\n        (explosion \\<omega> - ereal (fst x))\n\ngoal (1 subgoal):\n 1. explosion \\<omega> = \\<infinity>", "using elim SUP_escape_pos"], ["proof (prove)\nusing this:\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i))))\n  \\<le> ereal (\\<Squnion> range escape_rate) *\n        (explosion \\<omega> - ereal (fst x))\n  (\\<Sum>i.\n      ereal\n       (escape_rate (snd ((x ## \\<omega>) !! i)) *\n        (fst (\\<omega> !! i) - fst ((x ## \\<omega>) !! i)))) =\n  \\<infinity>\n  \\<forall>i.\n     snd ((x ## \\<omega>) !! i)\n     \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n           {snd x} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd ((x ## \\<omega>) !! i))) \\<and>\n     fst ((x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n  0 < \\<Squnion> range escape_rate\n\ngoal (1 subgoal):\n 1. explosion \\<omega> = \\<infinity>", "by (cases \"explosion \\<omega>\") (auto split: if_splits)"], ["proof (state)\nthis:\n  explosion \\<omega> = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream x. explosion \\<omega> = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transition probability $p_t$\\<close>"], ["", "context\nbegin"], ["", "declare [[inductive_internals = true]]"], ["", "inductive trace_in :: \"'a set \\<Rightarrow> real \\<Rightarrow> 'a \\<Rightarrow> (real \\<times> 'a) stream \\<Rightarrow> bool\" for S t\nwhere\n  \"t < t' \\<Longrightarrow> s \\<in> S \\<Longrightarrow> trace_in S t s ((t', s')##\\<omega>)\"\n| \"t \\<ge> t' \\<Longrightarrow> trace_in S t s' \\<omega> \\<Longrightarrow> trace_in S t s ((t', s')##\\<omega>)\""], ["", "end"], ["", "lemma trace_in_simps[simp]:\n  \"trace_in ss t s (x##\\<omega>) = (if t < fst x then s \\<in> ss else trace_in ss t (snd x) \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in ss t s (x ## \\<omega>) =\n    (if t < fst x then s \\<in> ss else trace_in ss t (snd x) \\<omega>)", "by (cases x) (subst trace_in.simps; auto)"], ["", "lemma trace_in_eq_lfp:\n  \"trace_in ss t = lfp (\\<lambda>F s. \\<lambda>(t', s')##\\<omega> \\<Rightarrow> if t < t' then s \\<in> ss else F s' \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in ss t =\n    lfp (\\<lambda>F s x.\n            case x of\n            (t', s') ## \\<omega> \\<Rightarrow>\n              if t < t' then s \\<in> ss else F s' \\<omega>)", "unfolding trace_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>p x1 x2.\n            (\\<exists>t' s s' \\<omega>.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t < t' \\<and> s \\<in> ss) \\<or>\n            (\\<exists>t' s' \\<omega> s.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t' \\<le> t \\<and> p s' \\<omega>)) =\n    lfp (\\<lambda>F s x.\n            case x of\n            (t', s') ## \\<omega> \\<Rightarrow>\n              if t < t' then s \\<in> ss else F s' \\<omega>)", "by (intro arg_cong[where f=lfp] ext) (auto split: stream.splits)"], ["", "lemma trace_in_shiftD: \"trace_in ss t s \\<omega> \\<Longrightarrow> trace_in ss (t + t') s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in ss t s \\<omega> \\<Longrightarrow>\n    trace_in ss (t + t') s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>)", "by (induction rule: trace_in.induct) auto"], ["", "lemma trace_in_shift[simp]: \"trace_in ss t s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) \\<longleftrightarrow> trace_in ss (t - t') s \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in ss t s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) =\n    trace_in ss (t - t') s \\<omega>", "using trace_in_shiftD[of ss t s \"smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>\" \"- t'\"]\n    trace_in_shiftD[of ss \"t - t'\" s \\<omega> t']"], ["proof (prove)\nusing this:\n  trace_in ss t s\n   (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) \\<Longrightarrow>\n  trace_in ss (t + - t') s\n   (smap (\\<lambda>(t, s'). (t + - t', s'))\n     (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>))\n  trace_in ss (t - t') s \\<omega> \\<Longrightarrow>\n  trace_in ss (t - t' + t') s\n   (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>)\n\ngoal (1 subgoal):\n 1. trace_in ss t s (smap (\\<lambda>(t, s'). (t + t', s')) \\<omega>) =\n    trace_in ss (t - t') s \\<omega>", "by (auto simp add: stream.map_comp prod.case_eq_if)"], ["", "lemma measurable_trace_in':\n  \"Measurable.pred (borel \\<Otimes>\\<^sub>M count_space UNIV \\<Otimes>\\<^sub>M T) (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)\"\n    (is \"?M (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "let ?F = \"\\<lambda>F. \\<lambda>(t, s, (t', s')##\\<omega>) \\<Rightarrow> if t < t' then s \\<in> ss else F (t, s', \\<omega>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "have [measurable]: \"Measurable.pred (count_space UNIV) (\\<lambda>x. x \\<in> ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (count_space UNIV) (\\<lambda>x. x \\<in> ss)", "by simp"], ["proof (state)\nthis:\n  Measurable.pred (count_space UNIV) (\\<lambda>x. x \\<in> ss)\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "have \"trace_in ss = (\\<lambda>t s \\<omega>. lfp ?F (t, s, \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in ss =\n    (\\<lambda>t s \\<omega>.\n        lfp (\\<lambda>F x.\n                case x of\n                (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n                  if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n         (t, s, \\<omega>))", "unfolding trace_in_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t.\n        lfp (\\<lambda>p x1 x2.\n                (\\<exists>t' s s' \\<omega>.\n                    x1 = s \\<and>\n                    x2 = (t', s') ## \\<omega> \\<and>\n                    t < t' \\<and> s \\<in> ss) \\<or>\n                (\\<exists>t' s' \\<omega> s.\n                    x1 = s \\<and>\n                    x2 = (t', s') ## \\<omega> \\<and>\n                    t' \\<le> t \\<and> p s' \\<omega>))) =\n    (\\<lambda>t s \\<omega>.\n        lfp (\\<lambda>F x.\n                case x of\n                (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n                  if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n         (t, s, \\<omega>))", "apply (subst lfp_arg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x t x1 x2.\n            (\\<exists>t' s s' \\<omega>.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t < t' \\<and> s \\<in> ss) \\<or>\n            (\\<exists>t' s' \\<omega> s.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t' \\<le> t \\<and> x t s' \\<omega>)) =\n    (\\<lambda>t s \\<omega>.\n        lfp (\\<lambda>F (t, s, y).\n                case_stream\n                 (\\<lambda>a \\<omega>.\n                     case a of\n                     (t', s') \\<Rightarrow>\n                       if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n                 y)\n         (t, s, \\<omega>))", "apply (subst lfp_rolling[where g=\"\\<lambda>F t s \\<omega>. F (t, s, \\<omega>)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. mono (\\<lambda>F t s \\<omega>. F (t, s, \\<omega>))\n 2. mono\n     (\\<lambda>a (t, s, y).\n         case_stream\n          (\\<lambda>aa \\<omega>.\n              case aa of\n              (t', s') \\<Rightarrow>\n                if t < t' then s \\<in> ss else a t s' \\<omega>)\n          y)\n 3. lfp (\\<lambda>x t x1 x2.\n            (\\<exists>t' s s' \\<omega>.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t < t' \\<and> s \\<in> ss) \\<or>\n            (\\<exists>t' s' \\<omega> s.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t' \\<le> t \\<and> x t s' \\<omega>)) =\n    lfp (\\<lambda>x t s \\<omega>.\n            case (t, s, \\<omega>) of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else x t s' \\<omega>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>F t s \\<omega>. F (t, s, \\<omega>))", "by (auto simp: mono_def le_fun_def split: stream.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mono\n     (\\<lambda>a (t, s, y).\n         case_stream\n          (\\<lambda>aa \\<omega>.\n              case aa of\n              (t', s') \\<Rightarrow>\n                if t < t' then s \\<in> ss else a t s' \\<omega>)\n          y)\n 2. lfp (\\<lambda>x t x1 x2.\n            (\\<exists>t' s s' \\<omega>.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t < t' \\<and> s \\<in> ss) \\<or>\n            (\\<exists>t' s' \\<omega> s.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t' \\<le> t \\<and> x t s' \\<omega>)) =\n    lfp (\\<lambda>x t s \\<omega>.\n            case (t, s, \\<omega>) of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else x t s' \\<omega>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>a (t, s, y).\n         case_stream\n          (\\<lambda>aa \\<omega>.\n              case aa of\n              (t', s') \\<Rightarrow>\n                if t < t' then s \\<in> ss else a t s' \\<omega>)\n          y)", "by (auto simp: mono_def le_fun_def split: stream.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x t x1 x2.\n            (\\<exists>t' s s' \\<omega>.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t < t' \\<and> s \\<in> ss) \\<or>\n            (\\<exists>t' s' \\<omega> s.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t' \\<le> t \\<and> x t s' \\<omega>)) =\n    lfp (\\<lambda>x t s \\<omega>.\n            case (t, s, \\<omega>) of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else x t s' \\<omega>)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x t x1 x2.\n            (\\<exists>t' s s' \\<omega>.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t < t' \\<and> s \\<in> ss) \\<or>\n            (\\<exists>t' s' \\<omega> s.\n                x1 = s \\<and>\n                x2 = (t', s') ## \\<omega> \\<and>\n                t' \\<le> t \\<and> x t s' \\<omega>)) =\n    lfp (\\<lambda>x t s \\<omega>.\n            case (t, s, \\<omega>) of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else x t s' \\<omega>)", "by (intro arg_cong[where f=lfp])\n         (auto simp: mono_def le_fun_def split_beta' not_less fun_eq_iff split: stream.splits intro!: arg_cong[where f=lfp])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  trace_in ss =\n  (\\<lambda>t s \\<omega>.\n      lfp (\\<lambda>F x.\n              case x of\n              (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n                if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n       (t, s, \\<omega>))\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "then"], ["proof (chain)\npicking this:\n  trace_in ss =\n  (\\<lambda>t s \\<omega>.\n      lfp (\\<lambda>F x.\n              case x of\n              (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n                if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n       (t, s, \\<omega>))", "have eq: \"(\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>) = lfp ?F\""], ["proof (prove)\nusing this:\n  trace_in ss =\n  (\\<lambda>t s \\<omega>.\n      lfp (\\<lambda>F x.\n              case x of\n              (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n                if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n       (t, s, \\<omega>))\n\ngoal (1 subgoal):\n 1. (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>) =\n    lfp (\\<lambda>F x.\n            case x of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else F (t, s', \\<omega>))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>) =\n  lfp (\\<lambda>F x.\n          case x of\n          (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n            if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "have \"sup_continuous ?F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_continuous\n     (\\<lambda>F x.\n         case x of\n         (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n           if t < t' then s \\<in> ss else F (t, s', \\<omega>))", "by (auto simp: sup_continuous_def fun_eq_iff split: stream.splits)"], ["proof (state)\nthis:\n  sup_continuous\n   (\\<lambda>F x.\n       case x of\n       (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n         if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "then"], ["proof (chain)\npicking this:\n  sup_continuous\n   (\\<lambda>F x.\n       case x of\n       (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n         if t < t' then s \\<in> ss else F (t, s', \\<omega>))", "show ?thesis"], ["proof (prove)\nusing this:\n  sup_continuous\n   (\\<lambda>F x.\n       case x of\n       (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n         if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)", "unfolding eq"], ["proof (prove)\nusing this:\n  sup_continuous\n   (\\<lambda>F x.\n       case x of\n       (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n         if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (lfp (\\<lambda>F (t, s, y).\n              case_stream\n               (\\<lambda>a \\<omega>.\n                   case a of\n                   (t', s') \\<Rightarrow>\n                     if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n               y))", "proof (rule measurable_lfp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       Measurable.pred\n        (borel \\<Otimes>\\<^sub>M\n         count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n        A \\<Longrightarrow>\n       Measurable.pred\n        (borel \\<Otimes>\\<^sub>M\n         count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n        (\\<lambda>x.\n            case x of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else A (t, s', \\<omega>))", "fix F"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       Measurable.pred\n        (borel \\<Otimes>\\<^sub>M\n         count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n        A \\<Longrightarrow>\n       Measurable.pred\n        (borel \\<Otimes>\\<^sub>M\n         count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n        (\\<lambda>x.\n            case x of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else A (t, s', \\<omega>))", "assume \"?M F\""], ["proof (state)\nthis:\n  Measurable.pred\n   (borel \\<Otimes>\\<^sub>M\n    count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n   F\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       Measurable.pred\n        (borel \\<Otimes>\\<^sub>M\n         count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n        A \\<Longrightarrow>\n       Measurable.pred\n        (borel \\<Otimes>\\<^sub>M\n         count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n        (\\<lambda>x.\n            case x of\n            (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n              if t < t' then s \\<in> ss else A (t, s', \\<omega>))", "then"], ["proof (chain)\npicking this:\n  Measurable.pred\n   (borel \\<Otimes>\\<^sub>M\n    count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n   F", "show \"?M (?F F)\""], ["proof (prove)\nusing this:\n  Measurable.pred\n   (borel \\<Otimes>\\<^sub>M\n    count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n   F\n\ngoal (1 subgoal):\n 1. Measurable.pred\n     (borel \\<Otimes>\\<^sub>M\n      count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n     (\\<lambda>a.\n         case a of\n         (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n           if t < t' then s \\<in> ss else F (t, s', \\<omega>))", "by measurable"], ["proof (state)\nthis:\n  Measurable.pred\n   (borel \\<Otimes>\\<^sub>M\n    count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n   (\\<lambda>a.\n       case a of\n       (t, s, (t', s') ## \\<omega>) \\<Rightarrow>\n         if t < t' then s \\<in> ss else F (t, s', \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Measurable.pred\n   (borel \\<Otimes>\\<^sub>M\n    count_space UNIV \\<Otimes>\\<^sub>M stream_space S)\n   (\\<lambda>(t, s, \\<omega>). trace_in ss t s \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_trace_in[measurable (raw)]:\n  assumes [measurable]: \"f \\<in> M \\<rightarrow>\\<^sub>M borel\" \"g \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV\" \"h \\<in> M \\<rightarrow>\\<^sub>M T\"\n  shows \"Measurable.pred M (\\<lambda>x. trace_in ss (f x) (g x) (h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. trace_in ss (f x) (g x) (h x))", "using measurable_compose[of \"\\<lambda>x. (f x, g x, h x)\" M, OF _ measurable_trace_in'[of ss]]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x, h x))\n  \\<in> M \\<rightarrow>\\<^sub>M\n        borel \\<Otimes>\\<^sub>M\n        count_space UNIV \\<Otimes>\\<^sub>M stream_space S \\<Longrightarrow>\n  Measurable.pred M\n   (\\<lambda>x.\n       case (f x, g x, h x) of\n       (t, s, \\<omega>) \\<Rightarrow> trace_in ss t s \\<omega>)\n\ngoal (1 subgoal):\n 1. Measurable.pred M (\\<lambda>x. trace_in ss (f x) (g x) (h x))", "by simp"], ["", "definition p :: \"'a \\<Rightarrow> 'a \\<Rightarrow> real \\<Rightarrow> real\"\nwhere \"p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega>)\""], ["", "lemma p[measurable]: \"(\\<lambda>(s, t). p s s' t) \\<in> (count_space UNIV \\<Otimes>\\<^sub>M borel) \\<rightarrow>\\<^sub>M borel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, t). p s s' t)\n    \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, t). p s s' t)\n    \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)", "have *: \"(SIGMA x:space (count_space UNIV \\<Otimes>\\<^sub>M borel). {\\<omega> \\<in> streams (space S). trace_in {s'} (snd x) (fst x) \\<omega>}) =\n    {x\\<in>space ((count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M T). trace_in {s'} (snd (fst x)) (fst (fst x)) (snd x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMA x:space (count_space UNIV \\<Otimes>\\<^sub>M borel).\n        {\\<omega> \\<in> streams (space S).\n         trace_in {s'} (snd x) (fst x) \\<omega>}) =\n    {x \\<in> space\n              ((count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M\n               stream_space S).\n     trace_in {s'} (snd (fst x)) (fst (fst x)) (snd x)}", "by (auto simp: space_pair_measure)"], ["proof (state)\nthis:\n  (SIGMA x:space (count_space UNIV \\<Otimes>\\<^sub>M borel).\n      {\\<omega> \\<in> streams (space S).\n       trace_in {s'} (snd x) (fst x) \\<omega>}) =\n  {x \\<in> space\n            ((count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M\n             stream_space S).\n   trace_in {s'} (snd (fst x)) (fst (fst x)) (snd x)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>(s, t). p s s' t)\n    \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)", "note measurable_trace_at'[measurable]"], ["proof (state)\nthis:\n  (\\<lambda>((s, j), \\<omega>). trace_at s \\<omega> j)\n  \\<in> (count_space UNIV \\<Otimes>\\<^sub>M borel) \\<Otimes>\\<^sub>M\n        stream_space S \\<rightarrow>\\<^sub>M\n        count_space UNIV\n\ngoal (1 subgoal):\n 1. (\\<lambda>(s, t). p s s' t)\n    \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(s, t). p s s' t)\n    \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)", "unfolding p_def[abs_def] split_beta'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        \\<P>(\\<omega> in K.lim_stream (0, fst x).\n             trace_in {s'} (snd x) (fst x) \\<omega>))\n    \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)", "by (rule measure_measurable_prob_algebra2[where N=T])\n       (auto simp: K.space_lim_stream * pred_def[symmetric]\n                intro!: pred_count_space_const1 measurable_trace_at'[unfolded split_beta'])"], ["proof (state)\nthis:\n  (\\<lambda>(s, t). p s s' t)\n  \\<in> borel_measurable (count_space UNIV \\<Otimes>\\<^sub>M borel)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_nonpos: assumes \"t \\<le> 0\" shows \"p s s' t = of_bool (s = s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s s' t = of_bool (s = s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p s s' t = of_bool (s = s')", "have \"AE \\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega> = (s = s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    (0, s). trace_in {s'} t s \\<omega> = (s = s')", "proof (subst K.AE_lim_stream)"], ["proof (state)\ngoal (3 subgoals):\n 1. (0, s) \\<in> space S\n 2. Measurable.pred (stream_space S)\n     (\\<lambda>\\<omega>. trace_in {s'} t s \\<omega> = (s = s'))\n 3. AE y in K (0, s). AE \\<omega> in K.lim_stream\ny. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "show \"AE y in K (0, s). AE \\<omega> in K.lim_stream y. trace_in {s'} t s (y ## \\<omega>) = (s = s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE y in K (0, s). AE \\<omega> in K.lim_stream\ny. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "using AE_K"], ["proof (prove)\nusing this:\n  AE y in K ?x. fst ?x < fst y \\<and> snd y \\<in> set_pmf (J (snd ?x))\n\ngoal (1 subgoal):\n 1. AE y in K (0, s). AE \\<omega> in K.lim_stream\ny. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       fst (0, s) < fst y \\<and>\n       snd y \\<in> set_pmf (J (snd (0, s))) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       y. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "fix y :: \"real \\<times> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       fst (0, s) < fst y \\<and>\n       snd y \\<in> set_pmf (J (snd (0, s))) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       y. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "assume \"fst (0, s) < fst y \\<and> snd y \\<in> set_pmf (J (snd (0, s)))\""], ["proof (state)\nthis:\n  fst (0, s) < fst y \\<and> snd y \\<in> set_pmf (J (snd (0::'b, s)))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       fst (0, s) < fst y \\<and>\n       snd y \\<in> set_pmf (J (snd (0, s))) \\<Longrightarrow>\n       AE \\<omega> in K.lim_stream\n                       y. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "with \\<open>t\\<le>0\\<close>"], ["proof (chain)\npicking this:\n  t \\<le> 0\n  fst (0, s) < fst y \\<and> snd y \\<in> set_pmf (J (snd (0::'b, s)))", "show \"AE \\<omega> in K.lim_stream y. trace_in {s'} t s (y ## \\<omega>) = (s = s')\""], ["proof (prove)\nusing this:\n  t \\<le> 0\n  fst (0, s) < fst y \\<and> snd y \\<in> set_pmf (J (snd (0::'b, s)))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    y. trace_in {s'} t s (y ## \\<omega>) = (s = s')", "by (cases y) auto"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream\n                  y. trace_in {s'} t s (y ## \\<omega>) = (s = s')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE y in K (0, s). AE \\<omega> in K.lim_stream\n                                    y. trace_in {s'} t s (y ## \\<omega>) =\n (s = s')\n\ngoal (2 subgoals):\n 1. (0, s) \\<in> space S\n 2. Measurable.pred (stream_space S)\n     (\\<lambda>\\<omega>. trace_in {s'} t s \\<omega> = (s = s'))", "qed auto"], ["proof (state)\nthis:\n  AE \\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega> = (s = s')\n\ngoal (1 subgoal):\n 1. p s s' t = of_bool (s = s')", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega> = (s = s')", "have \"p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). s = s')\""], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega> = (s = s')\n\ngoal (1 subgoal):\n 1. p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). s = s')", "unfolding p_def"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega> = (s = s')\n\ngoal (1 subgoal):\n 1. \\<P>(\\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega>) =\n    \\<P>(\\<omega> in K.lim_stream (0, s). s = s')", "by (intro prob_space.prob_eq_AE K.prob_space_lim_stream) auto"], ["proof (state)\nthis:\n  p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). s = s')\n\ngoal (1 subgoal):\n 1. p s s' t = of_bool (s = s')", "then"], ["proof (chain)\npicking this:\n  p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). s = s')", "show ?thesis"], ["proof (prove)\nusing this:\n  p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). s = s')\n\ngoal (1 subgoal):\n 1. p s s' t = of_bool (s = s')", "using prob_space.prob_space[OF K.prob_space_lim_stream]"], ["proof (prove)\nusing this:\n  p s s' t = \\<P>(\\<omega> in K.lim_stream (0, s). s = s')\n  ?x1 \\<in> space S \\<Longrightarrow>\n  Sigma_Algebra.measure (K.lim_stream ?x1) (space (K.lim_stream ?x1)) = 1\n\ngoal (1 subgoal):\n 1. p s s' t = of_bool (s = s')", "by simp"], ["proof (state)\nthis:\n  p s s' t = of_bool (s = s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_0: \"p s s' 0 = of_bool (s = s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s s' 0 = of_bool (s = s')", "using p_nonpos[of 0]"], ["proof (prove)\nusing this:\n  0 \\<le> 0 \\<Longrightarrow> p ?s ?s' 0 = of_bool (?s = ?s')\n\ngoal (1 subgoal):\n 1. p s s' 0 = of_bool (s = s')", "by simp"], ["", "lemma in_sets_T[measurable (raw)]: \"Measurable.pred T P \\<Longrightarrow> {\\<omega>. P \\<omega>} \\<in> sets T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space S) P \\<Longrightarrow>\n    {\\<omega>. P \\<omega>} \\<in> sets (stream_space S)", "unfolding pred_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> space (stream_space S). P x}\n    \\<in> sets (stream_space S) \\<Longrightarrow>\n    {\\<omega>. P \\<omega>} \\<in> sets (stream_space S)", "by simp"], ["", "lemma distr_id': \"sets M = sets N \\<Longrightarrow> distr M N (\\<lambda>x. x) = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets M = sets N \\<Longrightarrow> distr M N (\\<lambda>x. x) = M", "by (subst distr_cong[of M M N M _ \"\\<lambda>x. x\"] ) simp_all"], ["", "lemma p_nonneg[simp]: \"0 \\<le> p s s' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p s s' t", "by (simp add: p_def)"], ["", "lemma p_le_1[simp]: \"p s s' t \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s s' t \\<le> 1", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<P>(\\<omega> in K.lim_stream (0, s). trace_in {s'} t s \\<omega>)\n    \\<le> 1", "by (intro prob_space.prob_le_1 K.prob_space_lim_stream) simp"], ["", "lemma p_eq:\n  assumes \"0 \\<le> t\"\n  shows \"p s s'' t = (of_bool (s = s'') + (LINT u:{0..t}|lborel. escape_rate s * exp (escape_rate s * u) * (LINT s'|J s. p s' s'' u))) / exp (t * escape_rate s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have *: \"(+) 0 = (\\<lambda>x::real. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (+) 0 = (\\<lambda>x. x)", "by auto"], ["proof (state)\nthis:\n  (+) 0 = (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "interpret L: prob_space \"K.lim_stream x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (K.lim_stream x)", "by (rule K.prob_space_lim_stream) simp"], ["proof (state)\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "interpret E: prob_space \"exponential (escape_rate s)\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (exponential (escape_rate s))", "by (intro escape_rate_pos prob_space_exponential)"], ["proof (state)\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"p s s'' t = emeasure (K.lim_stream (0, s)) {\\<omega>\\<in>space T. trace_in {s''} t s \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p s s'' t) =\n    emeasure (K.lim_stream (0, s))\n     {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>}", "by (simp add: p_def L.emeasure_eq_measure K.space_lim_stream space_stream_space del: in_space_T)"], ["proof (state)\nthis:\n  ennreal (p s s'' t) =\n  emeasure (K.lim_stream (0, s))\n   {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>}\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  ennreal (p s s'' t) =\n  emeasure (K.lim_stream (0, s))\n   {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>}\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = (\\<integral>\\<^sup>+y. emeasure (K.lim_stream y) {\\<omega>\\<in>space T. trace_in {s''} t s (y##\\<omega>) } \\<partial>K (0, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream (0, s))\n     {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>} =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (subst K.lim_stream_eq[OF in_space_S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (K (0, s) \\<bind>\n      (\\<lambda>y.\n          K.lim_stream y \\<bind>\n          (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>))))\n     {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>} =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (subst emeasure_bind_prob_algebra[OF K_in_space])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>y.\n        K.lim_stream y \\<bind>\n        (\\<lambda>\\<omega>. return (stream_space S) (y ## \\<omega>)))\n    \\<in> S \\<rightarrow>\\<^sub>M prob_algebra ?L\n 2. {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>}\n    \\<in> sets ?L\n 3. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (x ## \\<omega>)))\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s \\<omega>}\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>}\n    \\<in> sets (stream_space S)\n 2. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (x ## \\<omega>)))\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s \\<omega>}\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (K.lim_stream x \\<bind>\n                             (\\<lambda>\\<omega>.\n                                 return (stream_space S) (x ## \\<omega>)))\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s \\<omega>}\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (subst bind_return_distr'[OF lim_stream_not_empty])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa. L.random_variable xa (stream_space S) ((##) xa)\n 2. \\<integral>\\<^sup>+ x. emeasure\n                            (distr (K.lim_stream x) (stream_space S)\n                              ((##) x))\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s \\<omega>}\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure\n                            (distr (K.lim_stream x) (stream_space S)\n                              ((##) x))\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s \\<omega>}\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s)", "apply (simp add: emeasure_distr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (K.lim_stream (0, s))\n   {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>} =\n  \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {s''} t s (y ## \\<omega>)}\n                     \\<partial>K (0, s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  emeasure (K.lim_stream (0, s))\n   {\\<omega> \\<in> space (stream_space S). trace_in {s''} t s \\<omega>} =\n  \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {s''} t s (y ## \\<omega>)}\n                     \\<partial>K (0, s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = (\\<integral>\\<^sup>+y. indicator {t <..} (fst y) * of_bool (s = s'') + indicator {0<..t} (fst y) * p (snd y) s'' (t - fst y) \\<partial>K (0, s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                            {\\<omega> \\<in> space (stream_space S).\n                             trace_in {s''} t s (y ## \\<omega>)}\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {t<..} (fst x) *\n                             of_bool (s = s'') +\n                             indicat_real {0<..t} (fst x) *\n                             p (snd x) s'' (t - fst x))\n                       \\<partial>K (0, s)", "apply (intro nn_integral_cong_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in K (0, s). emeasure (K.lim_stream x)\n                       {\\<omega> \\<in> space (stream_space S).\n                        trace_in {s''} t s (x ## \\<omega>)} =\n                      ennreal\n                       (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n                        indicat_real {0<..t} (fst x) *\n                        p (snd x) s'' (t - fst x))", "using AE_K"], ["proof (prove)\nusing this:\n  AE y in K ?x. fst ?x < fst y \\<and> snd y \\<in> set_pmf (J (snd ?x))\n\ngoal (1 subgoal):\n 1. AE x in K (0, s). emeasure (K.lim_stream x)\n                       {\\<omega> \\<in> space (stream_space S).\n                        trace_in {s''} t s (x ## \\<omega>)} =\n                      ennreal\n                       (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n                        indicat_real {0<..t} (fst x) *\n                        p (snd x) s'' (t - fst x))", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       fst (0, s) < fst x \\<and>\n       snd x \\<in> set_pmf (J (snd (0, s))) \\<Longrightarrow>\n       emeasure (K.lim_stream x)\n        {\\<omega> \\<in> space (stream_space S).\n         trace_in {s''} t s (x ## \\<omega>)} =\n       ennreal\n        (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n         indicat_real {0<..t} (fst x) * p (snd x) s'' (t - fst x))", "subgoal for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (0, s) < fst y \\<and>\n    snd y \\<in> set_pmf (J (snd (0, s))) \\<Longrightarrow>\n    emeasure (K.lim_stream y)\n     {\\<omega> \\<in> space (stream_space S).\n      trace_in {s''} t s (y ## \\<omega>)} =\n    ennreal\n     (indicat_real {t<..} (fst y) * of_bool (s = s'') +\n      indicat_real {0<..t} (fst y) * p (snd y) s'' (t - fst y))", "using L.emeasure_space_1"], ["proof (prove)\nusing this:\n  emeasure (K.lim_stream ?x) (space (K.lim_stream ?x)) = 1\n\ngoal (1 subgoal):\n 1. fst (0, s) < fst y \\<and>\n    snd y \\<in> set_pmf (J (snd (0, s))) \\<Longrightarrow>\n    emeasure (K.lim_stream y)\n     {\\<omega> \\<in> space (stream_space S).\n      trace_in {s''} t s (y ## \\<omega>)} =\n    ennreal\n     (indicat_real {t<..} (fst y) * of_bool (s = s'') +\n      indicat_real {0<..t} (fst y) * p (snd y) s'' (t - fst y))", "apply (cases y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>fst (0, s) < fst y \\<and>\n                snd y \\<in> set_pmf (J (snd (0, s)));\n        \\<And>x. emeasure (K.lim_stream x) (space (K.lim_stream x)) = 1;\n        y = (a, b)\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream y)\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {s''} t s (y ## \\<omega>)} =\n                         ennreal\n                          (indicat_real {t<..} (fst y) * of_bool (s = s'') +\n                           indicat_real {0<..t} (fst y) *\n                           p (snd y) s'' (t - fst y))", "apply (auto split: split_indicator simp del: in_space_T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b.\n                   emeasure (K.lim_stream (a, b))\n                    (space (K.lim_stream (a, b))) =\n                   1;\n        y = (a, b); 0 < a; b \\<in> set_pmf (J s); a \\<le> t\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream (a, b))\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {s''} t b \\<omega>} =\n                         ennreal (p b s'' (t - a))\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>a b.\n                   emeasure (K.lim_stream (a, b))\n                    (space (K.lim_stream (a, b))) =\n                   1;\n        y = (a, b); 0 < a; b \\<in> set_pmf (J s''); \\<not> a \\<le> t;\n        s = s''\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream (a, b))\n                          (space (stream_space S)) =\n                         1", "subgoal for t' s2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a b.\n                emeasure (K.lim_stream (a, b))\n                 (space (K.lim_stream (a, b))) =\n                1;\n     y = (t', s2); 0 < t'; s2 \\<in> set_pmf (J s); t' \\<le> t\\<rbrakk>\n    \\<Longrightarrow> emeasure (K.lim_stream (t', s2))\n                       {\\<omega> \\<in> space (stream_space S).\n                        trace_in {s''} t s2 \\<omega>} =\n                      ennreal (p s2 s'' (t - t'))", "unfolding p_def L.emeasure_eq_measure[symmetric] K.space_lim_stream space_stream_space[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a b.\n                emeasure (K.lim_stream (a, b)) (space (stream_space S)) = 1;\n     y = (t', s2); 0 < t'; s2 \\<in> set_pmf (J s); t' \\<le> t\\<rbrakk>\n    \\<Longrightarrow> emeasure (K.lim_stream (t', s2))\n                       {\\<omega> \\<in> space (stream_space S).\n                        trace_in {s''} t s2 \\<omega>} =\n                      emeasure (K.lim_stream (0, s2))\n                       {\\<omega> \\<in> space (stream_space S).\n                        trace_in {s''} (t - t') s2 \\<omega>}", "by (subst lim_0) (simp add: emeasure_distr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a b.\n                   emeasure (K.lim_stream (a, b))\n                    (space (K.lim_stream (a, b))) =\n                   1;\n        y = (a, b); 0 < a; b \\<in> set_pmf (J s''); \\<not> a \\<le> t;\n        s = s''\\<rbrakk>\n       \\<Longrightarrow> emeasure (K.lim_stream (a, b))\n                          (space (stream_space S)) =\n                         1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a b.\n                emeasure (K.lim_stream (a, b))\n                 (space (K.lim_stream (a, b))) =\n                1;\n     y = (a_, b_); 0 < a_; b_ \\<in> set_pmf (J s''); \\<not> a_ \\<le> t;\n     s = s''\\<rbrakk>\n    \\<Longrightarrow> emeasure (K.lim_stream (a_, b_))\n                       (space (stream_space S)) =\n                      1", "by (auto split: split_indicator cong: rev_conj_cong simp add: K.space_lim_stream space_stream_space simp del: in_space_T)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {s''} t s (y ## \\<omega>)}\n                     \\<partial>K (0, s) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n                           indicat_real {0<..t} (fst x) *\n                           p (snd x) s'' (t - fst x))\n                     \\<partial>K (0, s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ y. emeasure (K.lim_stream y)\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {s''} t s (y ## \\<omega>)}\n                     \\<partial>K (0, s) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n                           indicat_real {0<..t} (fst x) *\n                           p (snd x) s'' (t - fst x))\n                     \\<partial>K (0, s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = (\\<integral>\\<^sup>+u. \\<integral>\\<^sup>+s'. indicator {t <..} u * of_bool (s = s'') +\n    indicator {0<..t} u * p s' s'' (t - u) \\<partial>J s \\<partial>exponential (escape_rate s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {t<..} (fst x) *\n                             of_bool (s = s'') +\n                             indicat_real {0<..t} (fst x) *\n                             p (snd x) s'' (t - fst x))\n                       \\<partial>K (0, s) =\n    \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n          ennreal\n           (indicat_real {t<..} u * of_bool (s = s'') +\n            indicat_real {0<..t} u * p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s)", "unfolding K_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {t<..} (fst x) *\n                             of_bool (s = s'') +\n                             indicat_real {0<..t} (fst x) *\n                             p (snd x) s'' (t - fst x))\n                       \\<partial>case (0, s) of\n                                 (t, x) \\<Rightarrow>\n                                   distr (exponential (escape_rate x)) borel\n                                    ((+) t) \\<Otimes>\\<^sub>M\n                                   measure_pmf (J x) =\n    \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n          ennreal\n           (indicat_real {t<..} u * of_bool (s = s'') +\n            indicat_real {0<..t} u * p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s)", "by (simp add: K_def measure_pmf.nn_integral_fst[symmetric] * distr_id' sets_exponential)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n                           indicat_real {0<..t} (fst x) *\n                           p (snd x) s'' (t - fst x))\n                     \\<partial>K (0, s) =\n  \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n        ennreal\n         (indicat_real {t<..} u * of_bool (s = s'') +\n          indicat_real {0<..t} u * p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {t<..} (fst x) * of_bool (s = s'') +\n                           indicat_real {0<..t} (fst x) *\n                           p (snd x) s'' (t - fst x))\n                     \\<partial>K (0, s) =\n  \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n        ennreal\n         (indicat_real {t<..} u * of_bool (s = s'') +\n          indicat_real {0<..t} u * p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n      (\\<integral>\\<^sup>+u. indicator {0<..t} u * \\<integral>\\<^sup>+s'. p s' s'' (t - u) \\<partial>J s \\<partial>exponential (escape_rate s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n          ennreal\n           (indicat_real {t<..} u * of_bool (s = s'') +\n            indicat_real {0<..t} u * p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s) =\n    ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n    \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                           \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s)", "using \\<open>0\\<le>t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n          ennreal\n           (indicat_real {t<..} u * of_bool (s = s'') +\n            indicat_real {0<..t} u * p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s) =\n    ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n    \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                           \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s)", "by (simp add: nn_integral_add nn_integral_cmult ennreal_indicator ennreal_mult emeasure_exponential_Ioi escape_rate_pos)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n        ennreal\n         (indicat_real {t<..} u * of_bool (s = s'') +\n          indicat_real {0<..t} u * p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s) =\n  ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n  \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                         \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ u. \\<integral>\\<^sup>+ x.\n        ennreal\n         (indicat_real {t<..} u * of_bool (s = s'') +\n          indicat_real {0<..t} u * p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s) =\n  ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n  \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                         \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"(\\<integral>\\<^sup>+u. indicator {0<..t} u * \\<integral>\\<^sup>+s'. p s' s'' (t - u) \\<partial>J s \\<partial>exponential (escape_rate s)) =\n      (\\<integral>\\<^sup>+u. indicator {0<..t} u *\\<^sub>R (LINT s'|J s. p s' s'' (t - u)) \\<partial>exponential (escape_rate s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                           \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n        \\<partial>measure_pmf (J s)\n                       \\<partial>exponential (escape_rate s) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {0<..t} x *\\<^sub>R\n                             measure_pmf.expectation (J s)\n                              (\\<lambda>s'. p s' s'' (t - x)))\n                       \\<partial>exponential (escape_rate s)", "by (simp add: measure_pmf.integrable_const_bound[of _ 1] nn_integral_eq_integral ennreal_mult ennreal_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                         \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0<..t} x *\\<^sub>R\n                           measure_pmf.expectation (J s)\n                            (\\<lambda>s'. p s' s'' (t - x)))\n                     \\<partial>exponential (escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ u. indicator {0<..t} u *\n                         \\<integral>\\<^sup>+ x. ennreal (p x s'' (t - u))\n      \\<partial>measure_pmf (J s)\n                     \\<partial>exponential (escape_rate s) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0<..t} x *\\<^sub>R\n                           measure_pmf.expectation (J s)\n                            (\\<lambda>s'. p s' s'' (t - x)))\n                     \\<partial>exponential (escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = (LINT u:{0<..t}|exponential (escape_rate s). (LINT s'|J s. p s' s'' (t - u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {0<..t} x *\\<^sub>R\n                             measure_pmf.expectation (J s)\n                              (\\<lambda>s'. p s' s'' (t - x)))\n                       \\<partial>exponential (escape_rate s) =\n    ennreal\n     (\\<integral>u\\<in>{0<..t}.\n                 measure_pmf.expectation (J s)\n                  (\\<lambda>s'. p s' s'' (t - u))\n      \\<partial>exponential (escape_rate s))", "unfolding set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {0<..t} x *\\<^sub>R\n                             measure_pmf.expectation (J s)\n                              (\\<lambda>s'. p s' s'' (t - x)))\n                       \\<partial>exponential (escape_rate s) =\n    ennreal\n     (E.expectation s\n       (\\<lambda>x.\n           indicat_real {0<..t} x *\\<^sub>R\n           measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - x))))", "by (intro nn_integral_eq_integral E.integrable_const_bound[of _ 1] AE_I2)\n       (auto intro!: mult_le_one measure_pmf.integral_le_const measure_pmf.integrable_const_bound[of _ 1])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0<..t} x *\\<^sub>R\n                           measure_pmf.expectation (J s)\n                            (\\<lambda>s'. p s' s'' (t - x)))\n                     \\<partial>exponential (escape_rate s) =\n  ennreal\n   (\\<integral>u\\<in>{0<..t}.\n               measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))\n    \\<partial>exponential (escape_rate s))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0<..t} x *\\<^sub>R\n                           measure_pmf.expectation (J s)\n                            (\\<lambda>s'. p s' s'' (t - x)))\n                     \\<partial>exponential (escape_rate s) =\n  ennreal\n   (\\<integral>u\\<in>{0<..t}.\n               measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))\n    \\<partial>exponential (escape_rate s))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = (LINT u:{0<..t}|lborel. escape_rate s * exp (- escape_rate s * u) * (LINT s'|J s. p s' s'' (t - u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (\\<integral>u\\<in>{0<..t}.\n                 measure_pmf.expectation (J s)\n                  (\\<lambda>s'. p s' s'' (t - u))\n      \\<partial>exponential (escape_rate s)) =\n    ennreal\n     (LBINT u:{0<..t}.\n         escape_rate s * exp (- escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u)))", "unfolding exponential_def set_lebesgue_integral_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (LINT x|density lborel\n              (\\<lambda>x. ennreal (exponential_density (escape_rate s) x)).\n         indicat_real {0<..t} x *\\<^sub>R\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - x))) =\n    ennreal\n     (LBINT x.\n        indicat_real {0<..t} x *\\<^sub>R\n        (escape_rate s * exp (- escape_rate s * x) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - x))))", "by (subst integral_density)\n       (auto simp: ac_simps exponential_density_def fun_eq_iff split: split_indicator\n             simp del: integral_mult_right integral_mult_right_zero intro!: arg_cong2[where f=\"integral\\<^sup>L\"])"], ["proof (state)\nthis:\n  ennreal\n   (\\<integral>u\\<in>{0<..t}.\n               measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))\n    \\<partial>exponential (escape_rate s)) =\n  ennreal\n   (LBINT u:{0<..t}.\n       escape_rate s * exp (- escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u)))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  ennreal\n   (\\<integral>u\\<in>{0<..t}.\n               measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))\n    \\<partial>exponential (escape_rate s)) =\n  ennreal\n   (LBINT u:{0<..t}.\n       escape_rate s * exp (- escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u)))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = (LINT u:{0..t}|lborel. escape_rate s * exp (- escape_rate s * (t - u)) * (LINT s'|J s. p s' s'' u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (LBINT u:{0<..t}.\n         escape_rate s * exp (- escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))) =\n    ennreal\n     (LBINT u:{0..t}.\n         escape_rate s * exp (- escape_rate s * (t - u)) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))", "using AE_lborel_singleton[of 0] AE_lborel_singleton[of t]"], ["proof (prove)\nusing this:\n  AE x in lborel. x \\<noteq> (0::?'c1)\n  AE x in lborel. x \\<noteq> t\n\ngoal (1 subgoal):\n 1. ennreal\n     (LBINT u:{0<..t}.\n         escape_rate s * exp (- escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))) =\n    ennreal\n     (LBINT u:{0..t}.\n         escape_rate s * exp (- escape_rate s * (t - u)) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))", "unfolding set_lebesgue_integral_def"], ["proof (prove)\nusing this:\n  AE x in lborel. x \\<noteq> (0::?'c1)\n  AE x in lborel. x \\<noteq> t\n\ngoal (1 subgoal):\n 1. ennreal\n     (LBINT x.\n        indicat_real {0<..t} x *\\<^sub>R\n        (escape_rate s * exp (- escape_rate s * x) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - x)))) =\n    ennreal\n     (LBINT x.\n        indicat_real {0..t} x *\\<^sub>R\n        (escape_rate s * exp (- escape_rate s * (t - x)) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' x)))", "by (subst lborel_integral_real_affine[where t=t and c=\"-1\"])\n       (auto intro!: integral_cong_AE split: split_indicator)"], ["proof (state)\nthis:\n  ennreal\n   (LBINT u:{0<..t}.\n       escape_rate s * exp (- escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))) =\n  ennreal\n   (LBINT u:{0..t}.\n       escape_rate s * exp (- escape_rate s * (t - u)) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "also"], ["proof (state)\nthis:\n  ennreal\n   (LBINT u:{0<..t}.\n       escape_rate s * exp (- escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' (t - u))) =\n  ennreal\n   (LBINT u:{0..t}.\n       escape_rate s * exp (- escape_rate s * (t - u)) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "have \"\\<dots> = exp (- t * escape_rate s) * escape_rate s * (LINT u:{0..t}|lborel. exp (escape_rate s * u) * (LINT s'|J s. p s' s'' u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (LBINT u:{0..t}.\n         escape_rate s * exp (- escape_rate s * (t - u)) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u)) =\n    ennreal\n     (exp (- t * escape_rate s) * escape_rate s *\n      (LBINT u:{0..t}.\n          exp (escape_rate s * u) *\n          measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u)))", "by (simp add: field_simps exp_diff exp_minus)"], ["proof (state)\nthis:\n  ennreal\n   (LBINT u:{0..t}.\n       escape_rate s * exp (- escape_rate s * (t - u)) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u)) =\n  ennreal\n   (exp (- t * escape_rate s) * escape_rate s *\n    (LBINT u:{0..t}.\n        exp (escape_rate s * u) *\n        measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u)))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "finally"], ["proof (chain)\npicking this:\n  ennreal (p s s'' t) =\n  ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n  ennreal\n   (exp (- t * escape_rate s) * escape_rate s *\n    (LBINT u:{0..t}.\n        exp (escape_rate s * u) *\n        measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u)))", "show \"p s s'' t = (of_bool (s = s'') + (LBINT u:{0..t}. escape_rate s * exp (escape_rate s * u) * (LINT s'|J s. p s' s'' u))) / exp (t * escape_rate s)\""], ["proof (prove)\nusing this:\n  ennreal (p s s'' t) =\n  ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n  ennreal\n   (exp (- t * escape_rate s) * escape_rate s *\n    (LBINT u:{0..t}.\n        exp (escape_rate s * u) *\n        measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u)))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n    exp (t * escape_rate s)", "unfolding set_lebesgue_integral_def"], ["proof (prove)\nusing this:\n  ennreal (p s s'' t) =\n  ennreal (exp (- t * escape_rate s) * of_bool (s = s'')) +\n  ennreal\n   (exp (- t * escape_rate s) * escape_rate s *\n    (LBINT x.\n       indicat_real {0..t} x *\\<^sub>R\n       (exp (escape_rate s * x) *\n        measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' x))))\n\ngoal (1 subgoal):\n 1. p s s'' t =\n    (of_bool (s = s'') +\n     (LBINT x.\n        indicat_real {0..t} x *\\<^sub>R\n        (escape_rate s * exp (escape_rate s * x) *\n         measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' x)))) /\n    exp (t * escape_rate s)", "by (simp del: ennreal_plus add: ennreal_plus[symmetric] exp_minus field_simps)"], ["proof (state)\nthis:\n  p s s'' t =\n  (of_bool (s = s'') +\n   (LBINT u:{0..t}.\n       escape_rate s * exp (escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s'. p s' s'' u))) /\n  exp (t * escape_rate s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma continuous_on_p: \"continuous_on A (p s s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "interpret E: prob_space \"exponential (escape_rate s'')\" for s''"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (exponential (escape_rate s''))", "by (intro escape_rate_pos prob_space_exponential)"], ["proof (state)\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "have \"continuous_on {..0} (p s s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {..0} (p s s')", "by (simp add: p_nonpos continuous_on_const cong: continuous_on_cong_simp)"], ["proof (state)\nthis:\n  continuous_on {..0} (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "moreover"], ["proof (state)\nthis:\n  continuous_on {..0} (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "have \"continuous_on {0..} (p s s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..} (p s s')", "proof (subst continuous_on_cong[OF refl p_eq])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {0..} \\<Longrightarrow> 0 \\<le> x\n 2. continuous_on {0..}\n     (\\<lambda>x.\n         (of_bool (s = s') +\n          (LBINT u:{0..x}.\n              escape_rate s * exp (escape_rate s * u) *\n              measure_pmf.expectation (J s) (\\<lambda>s'a. p s'a s' u))) /\n         exp (x * escape_rate s))", "let ?I = \"\\<lambda>t. escape_rate s * exp (escape_rate s * t) * (LINT s''|J s. p s'' s' t)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> {0..} \\<Longrightarrow> 0 \\<le> x\n 2. continuous_on {0..}\n     (\\<lambda>x.\n         (of_bool (s = s') +\n          (LBINT u:{0..x}.\n              escape_rate s * exp (escape_rate s * u) *\n              measure_pmf.expectation (J s) (\\<lambda>s'a. p s'a s' u))) /\n         exp (x * escape_rate s))", "show \"continuous_on {0..} (\\<lambda>t. (of_bool (s = s') + (LBINT u:{0..t}. ?I u)) / exp (t * escape_rate s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..}\n     (\\<lambda>t.\n         (of_bool (s = s') +\n          (LBINT u:{0..t}.\n              escape_rate s * exp (escape_rate s * u) *\n              measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u))) /\n         exp (t * escape_rate s))", "proof (intro continuous_intros continuous_on_LBINT[THEN continuous_on_subset])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       set_integrable lborel {0..x}\n        (\\<lambda>x.\n            escape_rate s * exp (escape_rate s * x) *\n            measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x))\n 2. {0..} \\<subseteq> UNIV\n 3. \\<forall>t\\<in>{0..}. exp (t * escape_rate s) \\<noteq> 0", "fix t :: real"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       set_integrable lborel {0..x}\n        (\\<lambda>x.\n            escape_rate s * exp (escape_rate s * x) *\n            measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x))\n 2. {0..} \\<subseteq> UNIV\n 3. \\<forall>t\\<in>{0..}. exp (t * escape_rate s) \\<noteq> 0", "assume t: \"0 \\<le> t\""], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       set_integrable lborel {0..x}\n        (\\<lambda>x.\n            escape_rate s * exp (escape_rate s * x) *\n            measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x))\n 2. {0..} \\<subseteq> UNIV\n 3. \\<forall>t\\<in>{0..}. exp (t * escape_rate s) \\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  0 \\<le> t", "have \"0 \\<le> x \\<Longrightarrow> x \\<le> t \\<Longrightarrow> exp (x * escape_rate s) * (LINT s''|J s. p s'' s' x) \\<le> exp (t * escape_rate s) * 1\" for x"], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> t\\<rbrakk>\n    \\<Longrightarrow> exp (x * escape_rate s) *\n                      measure_pmf.expectation (J s)\n                       (\\<lambda>s''. p s'' s' x)\n                      \\<le> exp (t * escape_rate s) * 1", "by (intro mult_mono) (auto intro!: mult_mono measure_pmf.integral_le_const measure_pmf.integrable_const_bound[of _ 1])"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       set_integrable lborel {0..x}\n        (\\<lambda>x.\n            escape_rate s * exp (escape_rate s * x) *\n            measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x))\n 2. {0..} \\<subseteq> UNIV\n 3. \\<forall>t\\<in>{0..}. exp (t * escape_rate s) \\<noteq> 0", "with t"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1", "show \"set_integrable lborel {0..t} ?I\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..t}\n     (\\<lambda>t.\n         escape_rate s * exp (escape_rate s * t) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))", "using escape_rate_pos[of s]"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n  0 < escape_rate s\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..t}\n     (\\<lambda>t.\n         escape_rate s * exp (escape_rate s * t) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))", "unfolding set_integrable_def"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n  0 < escape_rate s\n\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x.\n         indicat_real {0..t} x *\\<^sub>R\n         (escape_rate s * exp (escape_rate s * x) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x)))", "by (intro integrableI_bounded_set_indicator[where B=\"escape_rate s * exp (escape_rate s * t)\"])\n           (auto simp: field_simps)"], ["proof (state)\nthis:\n  set_integrable lborel {0..t}\n   (\\<lambda>t.\n       escape_rate s * exp (escape_rate s * t) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))\n\ngoal (2 subgoals):\n 1. {0..} \\<subseteq> UNIV\n 2. \\<forall>t\\<in>{0..}. exp (t * escape_rate s) \\<noteq> 0", "qed auto"], ["proof (state)\nthis:\n  continuous_on {0..}\n   (\\<lambda>t.\n       (of_bool (s = s') +\n        (LBINT u:{0..t}.\n            escape_rate s * exp (escape_rate s * u) *\n            measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u))) /\n       exp (t * escape_rate s))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {0..} \\<Longrightarrow> 0 \\<le> x", "qed simp"], ["proof (state)\nthis:\n  continuous_on {0..} (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "ultimately"], ["proof (chain)\npicking this:\n  continuous_on {..0} (p s s')\n  continuous_on {0..} (p s s')", "have \"continuous_on ({0..} \\<union> {..0}) (p s s')\""], ["proof (prove)\nusing this:\n  continuous_on {..0} (p s s')\n  continuous_on {0..} (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on ({0..} \\<union> {..0}) (p s s')", "by (intro continuous_on_closed_Un) auto"], ["proof (state)\nthis:\n  continuous_on ({0..} \\<union> {..0}) (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "also"], ["proof (state)\nthis:\n  continuous_on ({0..} \\<union> {..0}) (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "have \"{0..} \\<union> {..0::real} = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {0..} \\<union> {..0} = UNIV", "by auto"], ["proof (state)\nthis:\n  {0..} \\<union> {..0} = UNIV\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "finally"], ["proof (chain)\npicking this:\n  continuous_on UNIV (p s s')", "show ?thesis"], ["proof (prove)\nusing this:\n  continuous_on UNIV (p s s')\n\ngoal (1 subgoal):\n 1. continuous_on A (p s s')", "by (rule continuous_on_subset) simp"], ["proof (state)\nthis:\n  continuous_on A (p s s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_vector_derivative: \\<comment> \\<open>Backward equation\\<close>\n  assumes \"0 \\<le> t\"\n  shows \"(p s s' has_vector_derivative (LINT s''|count_space UNIV. R s s'' * p s'' s' t) - escape_rate s * p s s' t)\n    (at t within {0..})\"\n    (is \"(_ has_vector_derivative ?A) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "let ?I = \"\\<lambda>t. escape_rate s * exp (escape_rate s * t) * (LINT s''|J s. p s'' s' t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "let ?p = \"\\<lambda>t. (of_bool (s = s') + integral {0..t} ?I) * exp (t *\\<^sub>R - escape_rate s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "fix t :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "assume \"0 \\<le> t\""], ["proof (state)\nthis:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "have \"p s s' t = (of_bool (s = s') + (LBINT u:{0..t}. ?I u)) * exp (- t * escape_rate s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p s s' t =\n    (of_bool (s = s') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u))) *\n    exp (- t * escape_rate s)", "using p_eq[OF \\<open>0 \\<le> t\\<close>, of s s']"], ["proof (prove)\nusing this:\n  p s s' t =\n  (of_bool (s = s') +\n   (LBINT u:{0..t}.\n       escape_rate s * exp (escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s'a. p s'a s' u))) /\n  exp (t * escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s' t =\n    (of_bool (s = s') +\n     (LBINT u:{0..t}.\n         escape_rate s * exp (escape_rate s * u) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u))) *\n    exp (- t * escape_rate s)", "by (simp add: exp_minus field_simps)"], ["proof (state)\nthis:\n  p s s' t =\n  (of_bool (s = s') +\n   (LBINT u:{0..t}.\n       escape_rate s * exp (escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u))) *\n  exp (- t * escape_rate s)\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "also"], ["proof (state)\nthis:\n  p s s' t =\n  (of_bool (s = s') +\n   (LBINT u:{0..t}.\n       escape_rate s * exp (escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u))) *\n  exp (- t * escape_rate s)\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "have \"(LBINT u:{0..t}. ?I u) = integral {0..t} ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT u:{0..t}.\n       escape_rate s * exp (escape_rate s * u) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u) =\n    integral {0..t}\n     (\\<lambda>t.\n         escape_rate s * exp (escape_rate s * t) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))", "proof (intro set_borel_integral_eq_integral)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..t}\n     (\\<lambda>x.\n         escape_rate s * exp (escape_rate s * x) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x))", "have \"0 \\<le> x \\<Longrightarrow> x \\<le> t \\<Longrightarrow> exp (x * escape_rate s) * (LINT s''|J s. p s'' s' x) \\<le> exp (t * escape_rate s) * 1\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> t\\<rbrakk>\n    \\<Longrightarrow> exp (x * escape_rate s) *\n                      measure_pmf.expectation (J s)\n                       (\\<lambda>s''. p s'' s' x)\n                      \\<le> exp (t * escape_rate s) * 1", "by (intro mult_mono) (auto intro!: mult_mono measure_pmf.integral_le_const measure_pmf.integrable_const_bound[of _ 1])"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..t}\n     (\\<lambda>x.\n         escape_rate s * exp (escape_rate s * x) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x))", "with \\<open>0\\<le>t\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1", "show \"set_integrable lborel {0..t} ?I\""], ["proof (prove)\nusing this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..t}\n     (\\<lambda>t.\n         escape_rate s * exp (escape_rate s * t) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))", "using escape_rate_pos[of s]"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n  0 < escape_rate s\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..t}\n     (\\<lambda>t.\n         escape_rate s * exp (escape_rate s * t) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))", "unfolding set_integrable_def"], ["proof (prove)\nusing this:\n  0 \\<le> t\n  \\<lbrakk>0 \\<le> ?x1; ?x1 \\<le> t\\<rbrakk>\n  \\<Longrightarrow> exp (?x1 * escape_rate s) *\n                    measure_pmf.expectation (J s)\n                     (\\<lambda>s''. p s'' s' ?x1)\n                    \\<le> exp (t * escape_rate s) * 1\n  0 < escape_rate s\n\ngoal (1 subgoal):\n 1. integrable lborel\n     (\\<lambda>x.\n         indicat_real {0..t} x *\\<^sub>R\n         (escape_rate s * exp (escape_rate s * x) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' x)))", "by (intro integrableI_bounded_set_indicator[where B=\"escape_rate s * exp (escape_rate s * t)\"])\n           (auto simp: field_simps)"], ["proof (state)\nthis:\n  set_integrable lborel {0..t}\n   (\\<lambda>t.\n       escape_rate s * exp (escape_rate s * t) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LBINT u:{0..t}.\n     escape_rate s * exp (escape_rate s * u) *\n     measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' u) =\n  integral {0..t}\n   (\\<lambda>t.\n       escape_rate s * exp (escape_rate s * t) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "finally"], ["proof (chain)\npicking this:\n  p s s' t =\n  (of_bool (s = s') +\n   integral {0..t}\n    (\\<lambda>t.\n        escape_rate s * exp (escape_rate s * t) *\n        measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n  exp (- t * escape_rate s)", "have \"p s s' t = ?p t\""], ["proof (prove)\nusing this:\n  p s s' t =\n  (of_bool (s = s') +\n   integral {0..t}\n    (\\<lambda>t.\n        escape_rate s * exp (escape_rate s * t) *\n        measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n  exp (- t * escape_rate s)\n\ngoal (1 subgoal):\n 1. p s s' t =\n    (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    exp (t *\\<^sub>R - escape_rate s)", "by simp"], ["proof (state)\nthis:\n  p s s' t =\n  (of_bool (s = s') +\n   integral {0..t}\n    (\\<lambda>t.\n        escape_rate s * exp (escape_rate s * t) *\n        measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n  exp (t *\\<^sub>R - escape_rate s)\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "}"], ["proof (state)\nthis:\n  0 \\<le> ?ta3 \\<Longrightarrow>\n  p s s' ?ta3 =\n  (of_bool (s = s') +\n   integral {0..?ta3}\n    (\\<lambda>t.\n        escape_rate s * exp (escape_rate s * t) *\n        measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n  exp (?ta3 *\\<^sub>R - escape_rate s)\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "note p_eq = this"], ["proof (state)\nthis:\n  0 \\<le> ?ta3 \\<Longrightarrow>\n  p s s' ?ta3 =\n  (of_bool (s = s') +\n   integral {0..?ta3}\n    (\\<lambda>t.\n        escape_rate s * exp (escape_rate s * t) *\n        measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n  exp (?ta3 *\\<^sub>R - escape_rate s)\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "have at_eq: \"at t within {0..} = at t within {0 .. t + 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. at t within {0..} = at t within {0..t + 1}", "by (intro at_within_nhd[where S=\"{..< t+1}\"]) auto"], ["proof (state)\nthis:\n  at t within {0..} = at t within {0..t + 1}\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "have c_I: \"continuous_on {0..t + 1} ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on {0..t + 1}\n     (\\<lambda>t.\n         escape_rate s * exp (escape_rate s * t) *\n         measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))", "by (intro continuous_intros continuous_on_LINT_pmf[where B=1] continuous_on_p) simp"], ["proof (state)\nthis:\n  continuous_on {0..t + 1}\n   (\\<lambda>t.\n       escape_rate s * exp (escape_rate s * t) *\n       measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))\n\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p s s' has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "proof (subst has_vector_derivative_cong_ev)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in nhds t.\n       x \\<in> {0..} \\<longrightarrow> p s s' x = ?g x\n 2. p s s' t = ?g t\n 3. (?g has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "show \"\\<forall>\\<^sub>F u in nhds t. u \\<in> {0..} \\<longrightarrow> p s s' u = ?p u\" \"p s s' t = ?p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F u in nhds t.\n       u \\<in> {0..} \\<longrightarrow>\n       p s s' u =\n       (of_bool (s = s') +\n        integral {0..u}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (u *\\<^sub>R - escape_rate s) &&&\n    p s s' t =\n    (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    exp (t *\\<^sub>R - escape_rate s)", "using \\<open>0\\<le>t\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> t\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F u in nhds t.\n       u \\<in> {0..} \\<longrightarrow>\n       p s s' u =\n       (of_bool (s = s') +\n        integral {0..u}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (u *\\<^sub>R - escape_rate s) &&&\n    p s s' t =\n    (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    exp (t *\\<^sub>R - escape_rate s)", "by (simp_all add: p_eq)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F u in nhds t.\n     u \\<in> {0..} \\<longrightarrow>\n     p s s' u =\n     (of_bool (s = s') +\n      integral {0..u}\n       (\\<lambda>t.\n           escape_rate s * exp (escape_rate s * t) *\n           measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n     exp (u *\\<^sub>R - escape_rate s)\n  p s s' t =\n  (of_bool (s = s') +\n   integral {0..t}\n    (\\<lambda>t.\n        escape_rate s * exp (escape_rate s * t) *\n        measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n  exp (t *\\<^sub>R - escape_rate s)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>u.\n         (of_bool (s = s') +\n          integral {0..u}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (u *\\<^sub>R - escape_rate s)) has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "have \"(?p has_vector_derivative escape_rate s * ((LINT s''|J s. p s'' s' t) - p s s' t)) (at t within {0..})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         (of_bool (s = s') +\n          integral {0..t}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n     escape_rate s *\n     (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t))\n     (at t within {0..})", "unfolding at_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         (of_bool (s = s') +\n          integral {0..t}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n     escape_rate s *\n     (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t))\n     (at t within {0..t + 1})", "apply (intro refl derivative_eq_intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. 0 = ?f'3\n 2. ((\\<lambda>x.\n         integral {0..x}\n          (\\<lambda>t.\n              escape_rate s * exp (escape_rate s * t) *\n              measure_pmf.expectation (J s)\n               (\\<lambda>s''. p s'' s' t))) has_vector_derivative\n     ?g'3)\n     (at t within {0..t + 1})\n 3. ?f'3 + ?g'3 = ?f'1\n 4. ((\\<lambda>x. exp (x *\\<^sub>R - escape_rate s)) has_vector_derivative\n     ?g'1)\n     (at t within {0..t + 1})\n 5. (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    ?g'1 +\n    ?f'1 * exp (t *\\<^sub>R - escape_rate s) =\n    escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t)", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. ((\\<lambda>x.\n         integral {0..x}\n          (\\<lambda>t.\n              escape_rate s * exp (escape_rate s * t) *\n              measure_pmf.expectation (J s)\n               (\\<lambda>s''. p s'' s' t))) has_vector_derivative\n     ?g'3)\n     (at t within {0..t + 1})\n 2. 0 + ?g'3 = ?f'1\n 3. ((\\<lambda>x. exp (x *\\<^sub>R - escape_rate s)) has_vector_derivative\n     ?g'1)\n     (at t within {0..t + 1})\n 4. (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    ?g'1 +\n    ?f'1 * exp (t *\\<^sub>R - escape_rate s) =\n    escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t)", "apply (rule integral_has_vector_derivative[OF c_I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. t \\<in> {0..t + 1}\n 2. 0 +\n    escape_rate s * exp (escape_rate s * t) *\n    measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) =\n    ?f'1\n 3. ((\\<lambda>x. exp (x *\\<^sub>R - escape_rate s)) has_vector_derivative\n     ?g'1)\n     (at t within {0..t + 1})\n 4. (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    ?g'1 +\n    ?f'1 * exp (t *\\<^sub>R - escape_rate s) =\n    escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t)", "apply (simp add: \\<open>0 \\<le> t\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. 0 +\n    escape_rate s * exp (escape_rate s * t) *\n    measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) =\n    ?f'1\n 2. ((\\<lambda>x. exp (x *\\<^sub>R - escape_rate s)) has_vector_derivative\n     ?g'1)\n     (at t within {0..t + 1})\n 3. (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    ?g'1 +\n    ?f'1 * exp (t *\\<^sub>R - escape_rate s) =\n    escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. ((\\<lambda>x. exp (x *\\<^sub>R - escape_rate s)) has_vector_derivative\n     ?g'1)\n     (at t within {0..t + 1})\n 2. (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    ?g'1 +\n    (0 +\n     escape_rate s * exp (escape_rate s * t) *\n     measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t)) *\n    exp (t *\\<^sub>R - escape_rate s) =\n    escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t)", "apply (rule exp_scaleR_has_vector_derivative_right)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_bool (s = s') +\n     integral {0..t}\n      (\\<lambda>t.\n          escape_rate s * exp (escape_rate s * t) *\n          measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n    (exp (t *\\<^sub>R - escape_rate s) * - escape_rate s) +\n    (0 +\n     escape_rate s * exp (escape_rate s * t) *\n     measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t)) *\n    exp (t *\\<^sub>R - escape_rate s) =\n    escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t)", "apply (simp add: field_simps exp_minus p_eq \\<open>0\\<le>t\\<close> split del: split_of_bool)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       (of_bool (s = s') +\n        integral {0..t}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n   escape_rate s *\n   (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>u.\n         (of_bool (s = s') +\n          integral {0..u}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (u *\\<^sub>R - escape_rate s)) has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "also"], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       (of_bool (s = s') +\n        integral {0..t}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n   escape_rate s *\n   (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t))\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>u.\n         (of_bool (s = s') +\n          integral {0..u}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (u *\\<^sub>R - escape_rate s)) has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "have \"escape_rate s * ((LINT s''|J s. p s'' s' t) - p s s' t) =\n        (LINT s''|count_space UNIV. R s s'' * p s'' s' t) - escape_rate s * p s s' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t) =\n    (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n    escape_rate s * p s s' t", "using escape_rate_pos[of s]"], ["proof (prove)\nusing this:\n  0 < escape_rate s\n\ngoal (1 subgoal):\n 1. escape_rate s *\n    (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t) =\n    (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n    escape_rate s * p s s' t", "by (simp add: measure_pmf_eq_density integral_density J.rep_eq field_simps)"], ["proof (state)\nthis:\n  escape_rate s *\n  (measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t) - p s s' t) =\n  (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n  escape_rate s * p s s' t\n\ngoal (1 subgoal):\n 1. ((\\<lambda>u.\n         (of_bool (s = s') +\n          integral {0..u}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (u *\\<^sub>R - escape_rate s)) has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>t.\n       (of_bool (s = s') +\n        integral {0..t}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n   (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n   escape_rate s * p s s' t)\n   (at t within {0..})", "show \"(?p has_vector_derivative  ?A) (at t within {0..})\""], ["proof (prove)\nusing this:\n  ((\\<lambda>t.\n       (of_bool (s = s') +\n        integral {0..t}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n   (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n   escape_rate s * p s s' t)\n   (at t within {0..})\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t.\n         (of_bool (s = s') +\n          integral {0..t}\n           (\\<lambda>t.\n               escape_rate s * exp (escape_rate s * t) *\n               measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n         exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n     (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n     escape_rate s * p s s' t)\n     (at t within {0..})", "."], ["proof (state)\nthis:\n  ((\\<lambda>t.\n       (of_bool (s = s') +\n        integral {0..t}\n         (\\<lambda>t.\n             escape_rate s * exp (escape_rate s * t) *\n             measure_pmf.expectation (J s) (\\<lambda>s''. p s'' s' t))) *\n       exp (t *\\<^sub>R - escape_rate s)) has_vector_derivative\n   (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n   escape_rate s * p s s' t)\n   (at t within {0..})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p s s' has_vector_derivative\n   (LINT s''|count_space UNIV. R s s'' * p s'' s' t) -\n   escape_rate s * p s s' t)\n   (at t within {0..})\n\ngoal:\nNo subgoals!", "qed"], ["", "coinductive wf_times :: \"real \\<Rightarrow> (real \\<times> 'a) stream \\<Rightarrow> bool\"\nwhere\n  \"t < t' \\<Longrightarrow> wf_times t' \\<omega> \\<Longrightarrow> wf_times t ((t', s') ## \\<omega>)\""], ["", "lemma wf_times_simp[simp]: \"wf_times t (x ## \\<omega>) \\<longleftrightarrow> t < fst x \\<and> wf_times (fst x) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_times t (x ## \\<omega>) =\n    (t < fst x \\<and> wf_times (fst x) \\<omega>)", "by (cases x) (subst wf_times.simps; simp)"], ["", "lemma trace_in_merge_at:\n  assumes \\<omega>': \"wf_times t' \\<omega>'\"\n  shows \"trace_in ss t x (merge_at \\<omega> t' \\<omega>') \\<longleftrightarrow>\n    (if t < t' then trace_in ss t x \\<omega> else \\<exists>y. trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>')\"\n    (is \"?merge \\<longleftrightarrow> ?cases\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in ss t x (merge_at \\<omega> t' \\<omega>') =\n    (if t < t' then trace_in ss t x \\<omega>\n     else \\<exists>y.\n             trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>')", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. trace_in ss t x (merge_at \\<omega> t' \\<omega>') \\<Longrightarrow>\n    if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n 2. if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and>\n            trace_in ss t y \\<omega>' \\<Longrightarrow>\n    trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "assume ?merge"], ["proof (state)\nthis:\n  trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n\ngoal (2 subgoals):\n 1. trace_in ss t x (merge_at \\<omega> t' \\<omega>') \\<Longrightarrow>\n    if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n 2. if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and>\n            trace_in ss t y \\<omega>' \\<Longrightarrow>\n    trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "from this \\<omega>'"], ["proof (chain)\npicking this:\n  trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n  wf_times t' \\<omega>'", "show ?cases"], ["proof (prove)\nusing this:\n  trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n  wf_times t' \\<omega>'\n\ngoal (1 subgoal):\n 1. if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'", "proof (induction \\<omega>\\<equiv>\"merge_at \\<omega> t' \\<omega>'\" arbitrary: \\<omega> \\<omega>')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'a s s' \\<omega> \\<omega>' \\<omega>''.\n       \\<lbrakk>t < t'a; s \\<in> ss;\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''\n 2. \\<And>t'a s' \\<omega> s \\<omega>' \\<omega>''.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<And>\\<omega>' \\<omega>''.\n           \\<lbrakk>\\<omega> = merge_at \\<omega>' t' \\<omega>'';\n            wf_times t' \\<omega>''\\<rbrakk>\n           \\<Longrightarrow> if t < t' then trace_in ss t s' \\<omega>'\n                             else \\<exists>y.\n                                     trace_in {y} t' s' \\<omega>' \\<and>\n                                     trace_in ss t y \\<omega>'';\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''", "case (1 j s' y \\<omega>'')"], ["proof (state)\nthis:\n  t < j\n  s' \\<in> ss\n  (j, y) ## \\<omega>'' = merge_at \\<omega> t' \\<omega>'\n  wf_times t' \\<omega>'\n\ngoal (2 subgoals):\n 1. \\<And>t'a s s' \\<omega> \\<omega>' \\<omega>''.\n       \\<lbrakk>t < t'a; s \\<in> ss;\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''\n 2. \\<And>t'a s' \\<omega> s \\<omega>' \\<omega>''.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<And>\\<omega>' \\<omega>''.\n           \\<lbrakk>\\<omega> = merge_at \\<omega>' t' \\<omega>'';\n            wf_times t' \\<omega>''\\<rbrakk>\n           \\<Longrightarrow> if t < t' then trace_in ss t s' \\<omega>'\n                             else \\<exists>y.\n                                     trace_in {y} t' s' \\<omega>' \\<and>\n                                     trace_in ss t y \\<omega>'';\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''", "then"], ["proof (chain)\npicking this:\n  t < j\n  s' \\<in> ss\n  (j, y) ## \\<omega>'' = merge_at \\<omega> t' \\<omega>'\n  wf_times t' \\<omega>'", "show ?case"], ["proof (prove)\nusing this:\n  t < j\n  s' \\<in> ss\n  (j, y) ## \\<omega>'' = merge_at \\<omega> t' \\<omega>'\n  wf_times t' \\<omega>'\n\ngoal (1 subgoal):\n 1. if t < t' then trace_in ss t s' \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' s' \\<omega> \\<and> trace_in ss t y \\<omega>'", "by (cases \\<omega>) (auto split: if_splits)"], ["proof (state)\nthis:\n  if t < t' then trace_in ss t s' \\<omega>\n  else \\<exists>y.\n          trace_in {y} t' s' \\<omega> \\<and> trace_in ss t y \\<omega>'\n\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s \\<omega>' \\<omega>''.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<And>\\<omega>' \\<omega>''.\n           \\<lbrakk>\\<omega> = merge_at \\<omega>' t' \\<omega>'';\n            wf_times t' \\<omega>''\\<rbrakk>\n           \\<Longrightarrow> if t < t' then trace_in ss t s' \\<omega>'\n                             else \\<exists>y.\n                                     trace_in {y} t' s' \\<omega>' \\<and>\n                                     trace_in ss t y \\<omega>'';\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s \\<omega>' \\<omega>''.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<And>\\<omega>' \\<omega>''.\n           \\<lbrakk>\\<omega> = merge_at \\<omega>' t' \\<omega>'';\n            wf_times t' \\<omega>''\\<rbrakk>\n           \\<Longrightarrow> if t < t' then trace_in ss t s' \\<omega>'\n                             else \\<exists>y.\n                                     trace_in {y} t' s' \\<omega>' \\<and>\n                                     trace_in ss t y \\<omega>'';\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''", "case (2 j x \\<omega>' s' \\<omega> \\<omega>'')"], ["proof (state)\nthis:\n  j \\<le> t\n  trace_in ss t x \\<omega>'\n  \\<lbrakk>\\<omega>' = merge_at ?\\<omega>1 t' ?\\<omega>'1;\n   wf_times t' ?\\<omega>'1\\<rbrakk>\n  \\<Longrightarrow> if t < t' then trace_in ss t x ?\\<omega>1\n                    else \\<exists>y.\n                            trace_in {y} t' x ?\\<omega>1 \\<and>\n                            trace_in ss t y ?\\<omega>'1\n  (j, x) ## \\<omega>' = merge_at \\<omega> t' \\<omega>''\n  wf_times t' \\<omega>''\n\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s \\<omega>' \\<omega>''.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<And>\\<omega>' \\<omega>''.\n           \\<lbrakk>\\<omega> = merge_at \\<omega>' t' \\<omega>'';\n            wf_times t' \\<omega>''\\<rbrakk>\n           \\<Longrightarrow> if t < t' then trace_in ss t s' \\<omega>'\n                             else \\<exists>y.\n                                     trace_in {y} t' s' \\<omega>' \\<and>\n                                     trace_in ss t y \\<omega>'';\n        (t'a, s') ## \\<omega> = merge_at \\<omega>' t' \\<omega>'';\n        wf_times t' \\<omega>''\\<rbrakk>\n       \\<Longrightarrow> if t < t' then trace_in ss t s \\<omega>'\n                         else \\<exists>y.\n                                 trace_in {y} t' s \\<omega>' \\<and>\n                                 trace_in ss t y \\<omega>''", "then"], ["proof (chain)\npicking this:\n  j \\<le> t\n  trace_in ss t x \\<omega>'\n  \\<lbrakk>\\<omega>' = merge_at ?\\<omega>1 t' ?\\<omega>'1;\n   wf_times t' ?\\<omega>'1\\<rbrakk>\n  \\<Longrightarrow> if t < t' then trace_in ss t x ?\\<omega>1\n                    else \\<exists>y.\n                            trace_in {y} t' x ?\\<omega>1 \\<and>\n                            trace_in ss t y ?\\<omega>'1\n  (j, x) ## \\<omega>' = merge_at \\<omega> t' \\<omega>''\n  wf_times t' \\<omega>''", "show ?case"], ["proof (prove)\nusing this:\n  j \\<le> t\n  trace_in ss t x \\<omega>'\n  \\<lbrakk>\\<omega>' = merge_at ?\\<omega>1 t' ?\\<omega>'1;\n   wf_times t' ?\\<omega>'1\\<rbrakk>\n  \\<Longrightarrow> if t < t' then trace_in ss t x ?\\<omega>1\n                    else \\<exists>y.\n                            trace_in {y} t' x ?\\<omega>1 \\<and>\n                            trace_in ss t y ?\\<omega>'1\n  (j, x) ## \\<omega>' = merge_at \\<omega> t' \\<omega>''\n  wf_times t' \\<omega>''\n\ngoal (1 subgoal):\n 1. if t < t' then trace_in ss t s' \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' s' \\<omega> \\<and> trace_in ss t y \\<omega>''", "by (cases \\<omega>) (auto split: if_splits)"], ["proof (state)\nthis:\n  if t < t' then trace_in ss t s' \\<omega>\n  else \\<exists>y.\n          trace_in {y} t' s' \\<omega> \\<and> trace_in ss t y \\<omega>''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if t < t' then trace_in ss t x \\<omega>\n  else \\<exists>y.\n          trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n\ngoal (1 subgoal):\n 1. if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and>\n            trace_in ss t y \\<omega>' \\<Longrightarrow>\n    trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and>\n            trace_in ss t y \\<omega>' \\<Longrightarrow>\n    trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "assume ?cases"], ["proof (state)\nthis:\n  if t < t' then trace_in ss t x \\<omega>\n  else \\<exists>y.\n          trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n\ngoal (1 subgoal):\n 1. if t < t' then trace_in ss t x \\<omega>\n    else \\<exists>y.\n            trace_in {y} t' x \\<omega> \\<and>\n            trace_in ss t y \\<omega>' \\<Longrightarrow>\n    trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "then"], ["proof (chain)\npicking this:\n  if t < t' then trace_in ss t x \\<omega>\n  else \\<exists>y.\n          trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'", "show ?merge"], ["proof (prove)\nusing this:\n  if t < t' then trace_in ss t x \\<omega>\n  else \\<exists>y.\n          trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n\ngoal (1 subgoal):\n 1. trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "proof (split if_split_asm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t < t'; trace_in ss t x \\<omega>\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n 2. \\<lbrakk>\\<not> t < t';\n     \\<exists>y.\n        trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "assume \"trace_in ss t x \\<omega>\" \"t < t'\""], ["proof (state)\nthis:\n  trace_in ss t x \\<omega>\n  t < t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t < t'; trace_in ss t x \\<omega>\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n 2. \\<lbrakk>\\<not> t < t';\n     \\<exists>y.\n        trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "from this \\<omega>'"], ["proof (chain)\npicking this:\n  trace_in ss t x \\<omega>\n  t < t'\n  wf_times t' \\<omega>'", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_in ss t x \\<omega>\n  t < t'\n  wf_times t' \\<omega>'\n\ngoal (1 subgoal):\n 1. trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'a s s' \\<omega>.\n       \\<lbrakk>t < t'a; s \\<in> ss; t < t'; wf_times t' \\<omega>'\\<rbrakk>\n       \\<Longrightarrow> trace_in ss t s\n                          (merge_at ((t'a, s') ## \\<omega>) t' \\<omega>')\n 2. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<lbrakk>t < t'; wf_times t' \\<omega>'\\<rbrakk>\n        \\<Longrightarrow> trace_in ss t s' (merge_at \\<omega> t' \\<omega>');\n        t < t'; wf_times t' \\<omega>'\\<rbrakk>\n       \\<Longrightarrow> trace_in ss t s\n                          (merge_at ((t'a, s') ## \\<omega>) t' \\<omega>')", "case 1"], ["proof (state)\nthis:\n  t < t'_\n  s_ \\<in> ss\n  t < t'\n  wf_times t' \\<omega>'\n\ngoal (2 subgoals):\n 1. \\<And>t'a s s' \\<omega>.\n       \\<lbrakk>t < t'a; s \\<in> ss; t < t'; wf_times t' \\<omega>'\\<rbrakk>\n       \\<Longrightarrow> trace_in ss t s\n                          (merge_at ((t'a, s') ## \\<omega>) t' \\<omega>')\n 2. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<lbrakk>t < t'; wf_times t' \\<omega>'\\<rbrakk>\n        \\<Longrightarrow> trace_in ss t s' (merge_at \\<omega> t' \\<omega>');\n        t < t'; wf_times t' \\<omega>'\\<rbrakk>\n       \\<Longrightarrow> trace_in ss t s\n                          (merge_at ((t'a, s') ## \\<omega>) t' \\<omega>')", "then"], ["proof (chain)\npicking this:\n  t < t'_\n  s_ \\<in> ss\n  t < t'\n  wf_times t' \\<omega>'", "show ?case"], ["proof (prove)\nusing this:\n  t < t'_\n  s_ \\<in> ss\n  t < t'\n  wf_times t' \\<omega>'\n\ngoal (1 subgoal):\n 1. trace_in ss t s_ (merge_at ((t'_, s'_) ## \\<omega>_) t' \\<omega>')", "by (cases \\<omega>') auto"], ["proof (state)\nthis:\n  trace_in ss t s_ (merge_at ((t'_, s'_) ## \\<omega>_) t' \\<omega>')\n\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t; trace_in ss t s' \\<omega>;\n        \\<lbrakk>t < t'; wf_times t' \\<omega>'\\<rbrakk>\n        \\<Longrightarrow> trace_in ss t s' (merge_at \\<omega> t' \\<omega>');\n        t < t'; wf_times t' \\<omega>'\\<rbrakk>\n       \\<Longrightarrow> trace_in ss t s\n                          (merge_at ((t'a, s') ## \\<omega>) t' \\<omega>')", "qed auto"], ["proof (state)\nthis:\n  trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> t < t';\n     \\<exists>y.\n        trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> t < t';\n     \\<exists>y.\n        trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "assume \"\\<exists>y. trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\" \"\\<not> t < t'\""], ["proof (state)\nthis:\n  \\<exists>y. trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n  \\<not> t < t'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> t < t';\n     \\<exists>y.\n        trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n  \\<not> t < t'", "obtain y where \"trace_in {y} t' x \\<omega>\" \"trace_in ss t y \\<omega>'\" \"t' \\<le> t\""], ["proof (prove)\nusing this:\n  \\<exists>y. trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\n  \\<not> t < t'\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>trace_in {y} t' x \\<omega>; trace_in ss t y \\<omega>';\n         t' \\<le> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  trace_in {y} t' x \\<omega>\n  trace_in ss t y \\<omega>'\n  t' \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> t < t';\n     \\<exists>y.\n        trace_in {y} t' x \\<omega> \\<and> trace_in ss t y \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "from this \\<omega>'"], ["proof (chain)\npicking this:\n  trace_in {y} t' x \\<omega>\n  trace_in ss t y \\<omega>'\n  t' \\<le> t\n  wf_times t' \\<omega>'", "show ?thesis"], ["proof (prove)\nusing this:\n  trace_in {y} t' x \\<omega>\n  trace_in ss t y \\<omega>'\n  t' \\<le> t\n  wf_times t' \\<omega>'\n\ngoal (1 subgoal):\n 1. trace_in ss t x (merge_at \\<omega> t' \\<omega>')", "by induction auto"], ["proof (state)\nthis:\n  trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trace_in ss t x (merge_at \\<omega> t' \\<omega>')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_lim_wf_times: \"AE \\<omega> in K.lim_stream (t, s). wf_times t \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (K.lim_stream (t, s)) (wf_times t)", "using AE_lim_stream"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream\n                  ?x. \\<forall>i.\n                         snd ((?x ## \\<omega>) !! i)\n                         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                               {snd ?x} \\<and>\n                         snd (\\<omega> !! i)\n                         \\<in> set_pmf\n                                (J (snd ((?x ## \\<omega>) !! i))) \\<and>\n                         fst ((?x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. almost_everywhere (K.lim_stream (t, s)) (wf_times t)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<forall>i.\n          snd (((t, s) ## \\<omega>) !! i)\n          \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                {snd (t, s)} \\<and>\n          snd (\\<omega> !! i)\n          \\<in> set_pmf (J (snd (((t, s) ## \\<omega>) !! i))) \\<and>\n          fst (((t, s) ## \\<omega>) !! i)\n          < fst (\\<omega> !! i) \\<Longrightarrow>\n       wf_times t \\<omega>", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<forall>i.\n          snd (((t, s) ## \\<omega>) !! i)\n          \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                {snd (t, s)} \\<and>\n          snd (\\<omega> !! i)\n          \\<in> set_pmf (J (snd (((t, s) ## \\<omega>) !! i))) \\<and>\n          fst (((t, s) ## \\<omega>) !! i)\n          < fst (\\<omega> !! i) \\<Longrightarrow>\n       wf_times t \\<omega>", "assume *: \"\\<forall>i. snd (((t, s) ## \\<omega>) !! i) \\<in> DTMC.acc `` {snd (t, s)} \\<and>\n             snd (\\<omega> !! i) \\<in> J (snd (((t, s) ## \\<omega>) !! i)) \\<and>\n             fst (((t, s) ## \\<omega>) !! i) < fst (\\<omega> !! i)\""], ["proof (state)\nthis:\n  \\<forall>i.\n     snd (((t, s) ## \\<omega>) !! i)\n     \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (t, s)} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd (((t, s) ## \\<omega>) !! i))) \\<and>\n     fst (((t, s) ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<forall>i.\n          snd (((t, s) ## \\<omega>) !! i)\n          \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                {snd (t, s)} \\<and>\n          snd (\\<omega> !! i)\n          \\<in> set_pmf (J (snd (((t, s) ## \\<omega>) !! i))) \\<and>\n          fst (((t, s) ## \\<omega>) !! i)\n          < fst (\\<omega> !! i) \\<Longrightarrow>\n       wf_times t \\<omega>", "have \"(t ## smap fst \\<omega>) !! i < fst (\\<omega> !! i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (t ## smap fst \\<omega>) !! i < fst (\\<omega> !! i)", "using *[THEN spec, of i]"], ["proof (prove)\nusing this:\n  snd (((t, s) ## \\<omega>) !! i)\n  \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (t, s)} \\<and>\n  snd (\\<omega> !! i)\n  \\<in> set_pmf (J (snd (((t, s) ## \\<omega>) !! i))) \\<and>\n  fst (((t, s) ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. (t ## smap fst \\<omega>) !! i < fst (\\<omega> !! i)", "by (cases i) auto"], ["proof (state)\nthis:\n  (t ## smap fst \\<omega>) !! ?i1 < fst (\\<omega> !! ?i1)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<forall>i.\n          snd (((t, s) ## \\<omega>) !! i)\n          \\<in> (SIGMA \\<omega>:UNIV. set_pmf (J \\<omega>))\\<^sup>* ``\n                {snd (t, s)} \\<and>\n          snd (\\<omega> !! i)\n          \\<in> set_pmf (J (snd (((t, s) ## \\<omega>) !! i))) \\<and>\n          fst (((t, s) ## \\<omega>) !! i)\n          < fst (\\<omega> !! i) \\<Longrightarrow>\n       wf_times t \\<omega>", "then"], ["proof (chain)\npicking this:\n  (t ## smap fst \\<omega>) !! ?i1 < fst (\\<omega> !! ?i1)", "show \"wf_times t \\<omega>\""], ["proof (prove)\nusing this:\n  (t ## smap fst \\<omega>) !! ?i1 < fst (\\<omega> !! ?i1)\n\ngoal (1 subgoal):\n 1. wf_times t \\<omega>", "proof (coinduction arbitrary: t \\<omega>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t \\<omega>.\n       \\<forall>i.\n          (t ## smap fst \\<omega>) !! i\n          < fst (\\<omega> !! i) \\<Longrightarrow>\n       \\<exists>ta t' \\<omega>' s'.\n          t = ta \\<and>\n          \\<omega> = (t', s') ## \\<omega>' \\<and>\n          ta < t' \\<and>\n          ((\\<exists>t \\<omega>.\n               t' = t \\<and>\n               \\<omega>' = \\<omega> \\<and>\n               (\\<forall>i.\n                   (t ## smap fst \\<omega>) !! i\n                   < fst (\\<omega> !! i))) \\<or>\n           wf_times t' \\<omega>')", "case wf_times"], ["proof (state)\nthis:\n  \\<forall>i. (t ## smap fst \\<omega>) !! i < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. \\<And>t \\<omega>.\n       \\<forall>i.\n          (t ## smap fst \\<omega>) !! i\n          < fst (\\<omega> !! i) \\<Longrightarrow>\n       \\<exists>ta t' \\<omega>' s'.\n          t = ta \\<and>\n          \\<omega> = (t', s') ## \\<omega>' \\<and>\n          ta < t' \\<and>\n          ((\\<exists>t \\<omega>.\n               t' = t \\<and>\n               \\<omega>' = \\<omega> \\<and>\n               (\\<forall>i.\n                   (t ## smap fst \\<omega>) !! i\n                   < fst (\\<omega> !! i))) \\<or>\n           wf_times t' \\<omega>')", "from this[THEN spec, of 0] this[THEN spec, of \"Suc i\" for i]"], ["proof (chain)\npicking this:\n  (t ## smap fst \\<omega>) !! 0 < fst (\\<omega> !! 0)\n  (t ## smap fst \\<omega>) !! Suc ?i3 < fst (\\<omega> !! Suc ?i3)", "show ?case"], ["proof (prove)\nusing this:\n  (t ## smap fst \\<omega>) !! 0 < fst (\\<omega> !! 0)\n  (t ## smap fst \\<omega>) !! Suc ?i3 < fst (\\<omega> !! Suc ?i3)\n\ngoal (1 subgoal):\n 1. \\<exists>t t' \\<omega> s'.\n       t = t \\<and>\n       \\<omega> = (t', s') ## \\<omega> \\<and>\n       t < t' \\<and>\n       ((\\<exists>t \\<omega>'.\n            t' = t \\<and>\n            \\<omega> = \\<omega>' \\<and>\n            (\\<forall>i.\n                (t ## smap fst \\<omega>') !! i\n                < fst (\\<omega>' !! i))) \\<or>\n        wf_times t' \\<omega>)", "by (cases \\<omega>) auto"], ["proof (state)\nthis:\n  \\<exists>t t' \\<omega> s'.\n     t = t \\<and>\n     \\<omega> = (t', s') ## \\<omega> \\<and>\n     t < t' \\<and>\n     ((\\<exists>t \\<omega>'.\n          t' = t \\<and>\n          \\<omega> = \\<omega>' \\<and>\n          (\\<forall>i.\n              (t ## smap fst \\<omega>') !! i < fst (\\<omega>' !! i))) \\<or>\n      wf_times t' \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_times t \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_times_shiftD: \"wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) \\<Longrightarrow> wf_times (t' - t) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_times t'\n     (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) \\<Longrightarrow>\n    wf_times (t' - t) \\<omega>", "apply (coinduction arbitrary: t' t \\<omega>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t' t \\<omega>.\n       wf_times t'\n        (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) \\<Longrightarrow>\n       \\<exists>ta t'a \\<omega>' s'.\n          t' - t = ta \\<and>\n          \\<omega> = (t'a, s') ## \\<omega>' \\<and>\n          ta < t'a \\<and>\n          ((\\<exists>t' t \\<omega>.\n               t'a = t' - t \\<and>\n               \\<omega>' = \\<omega> \\<and>\n               wf_times t'\n                (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>)) \\<or>\n           wf_times t'a \\<omega>')", "subgoal for t' t \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_times t'\n     (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) \\<Longrightarrow>\n    \\<exists>t t' \\<omega> s'.\n       t' - t = t \\<and>\n       \\<omega> = (t', s') ## \\<omega> \\<and>\n       t < t' \\<and>\n       ((\\<exists>t'a t \\<omega>'.\n            t' = t'a - t \\<and>\n            \\<omega> = \\<omega>' \\<and>\n            wf_times t'a\n             (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>')) \\<or>\n        wf_times t' \\<omega>)", "apply (cases \\<omega>; cases \"shd \\<omega>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a b.\n       \\<lbrakk>wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>);\n        \\<omega> = x1 ## x2; shd \\<omega> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t t' \\<omega> s'.\n                            t' - t = t \\<and>\n                            \\<omega> = (t', s') ## \\<omega> \\<and>\n                            t < t' \\<and>\n                            ((\\<exists>t'a t \\<omega>'.\n                                 t' = t'a - t \\<and>\n                                 \\<omega> = \\<omega>' \\<and>\n                                 wf_times t'a\n                                  (smap (\\<lambda>(t', y). (t' + t, y))\n                                    \\<omega>')) \\<or>\n                             wf_times t' \\<omega>)", "apply (auto simp: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 aa ba.\n       \\<lbrakk>\\<omega> = (aa, ba) ## x2; t' < aa + t;\n        wf_times (aa + t)\n         (smap (\\<lambda>z. case z of (t', x) \\<Rightarrow> (t' + t, x))\n           x2);\n        \\<not> wf_times aa x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t' t.\n                            aa = t' - t \\<and>\n                            wf_times t'\n                             (smap\n                               (\\<lambda>z.\n                                   case z of\n                                   (t', x) \\<Rightarrow> (t' + t, x))\n                               x2)", "subgoal for \\<omega>' j x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<omega> = (j, x) ## \\<omega>'; t' < j + t;\n     wf_times (j + t)\n      (smap (\\<lambda>z. case z of (t', x) \\<Rightarrow> (t' + t, x))\n        \\<omega>');\n     \\<not> wf_times j \\<omega>'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t' t.\n                         j = t' - t \\<and>\n                         wf_times t'\n                          (smap\n                            (\\<lambda>z.\n                                case z of (t', x) \\<Rightarrow> (t' + t, x))\n                            \\<omega>')", "by (rule exI[of _ \"j + t\"]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_times_shift[simp]: \"wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) = wf_times (t' - t) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) =\n    wf_times (t' - t) \\<omega>", "using wf_times_shiftD[of \"t' - t\" \"-t\" \"smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>\"]"], ["proof (prove)\nusing this:\n  wf_times (t' - t)\n   (smap (\\<lambda>(t', y). (t' + - t, y))\n     (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>)) \\<Longrightarrow>\n  wf_times (t' - t - - t) (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>)\n\ngoal (1 subgoal):\n 1. wf_times t' (smap (\\<lambda>(t', y). (t' + t, y)) \\<omega>) =\n    wf_times (t' - t) \\<omega>", "by (auto simp: stream.map_comp stream.case_eq_if prod.case_eq_if wf_times_shiftD)"], ["", "lemma trace_in_unique: \"trace_in {y1} t x \\<omega> \\<Longrightarrow> trace_in {y2} t x \\<omega> \\<Longrightarrow> y1 = y2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>trace_in {y1} t x \\<omega>; trace_in {y2} t x \\<omega>\\<rbrakk>\n    \\<Longrightarrow> y1 = y2", "by (induction rule: trace_in.induct) auto"], ["", "lemma trace_at_eq: \"trace_in {z} t x \\<omega> \\<Longrightarrow> trace_at x \\<omega> t = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace_in {z} t x \\<omega> \\<Longrightarrow> trace_at x \\<omega> t = z", "by (induction rule: trace_in.induct) auto"], ["", "lemma AE_lim_acc: \"AE \\<omega> in K.lim_stream (t, x). \\<forall>t z. trace_in {z} t x \\<omega> \\<longrightarrow> (x, z) \\<in> DTMC.acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    (t, x). \\<forall>t z.\n                               trace_in {z} t x \\<omega> \\<longrightarrow>\n                               (x, z)\n                               \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "using AE_lim_stream"], ["proof (prove)\nusing this:\n  AE \\<omega> in K.lim_stream\n                  ?x. \\<forall>i.\n                         snd ((?x ## \\<omega>) !! i)\n                         \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                               {snd ?x} \\<and>\n                         snd (\\<omega> !! i)\n                         \\<in> set_pmf\n                                (J (snd ((?x ## \\<omega>) !! i))) \\<and>\n                         fst ((?x ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in K.lim_stream\n                    (t, x). \\<forall>t z.\n                               trace_in {z} t x \\<omega> \\<longrightarrow>\n                               (x, z)\n                               \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "proof (eventually_elim, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega> ta z.\n       \\<lbrakk>\\<forall>i.\n                   snd (((t, x) ## \\<omega>) !! i)\n                   \\<in> (SIGMA \\<omega>:UNIV.\n                             set_pmf (J \\<omega>))\\<^sup>* ``\n                         {snd (t, x)} \\<and>\n                   snd (\\<omega> !! i)\n                   \\<in> set_pmf\n                          (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n                   fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        \\<And>a b.\n           AE \\<omega> in K.lim_stream\n                           (a, b). \\<forall>i.\nsnd (((a, b) ## \\<omega>) !! i)\n\\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (a, b)} \\<and>\nsnd (\\<omega> !! i)\n\\<in> set_pmf (J (snd (((a, b) ## \\<omega>) !! i))) \\<and>\nfst (((a, b) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        trace_in {z} ta x \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "fix t' z \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega> ta z.\n       \\<lbrakk>\\<forall>i.\n                   snd (((t, x) ## \\<omega>) !! i)\n                   \\<in> (SIGMA \\<omega>:UNIV.\n                             set_pmf (J \\<omega>))\\<^sup>* ``\n                         {snd (t, x)} \\<and>\n                   snd (\\<omega> !! i)\n                   \\<in> set_pmf\n                          (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n                   fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        \\<And>a b.\n           AE \\<omega> in K.lim_stream\n                           (a, b). \\<forall>i.\nsnd (((a, b) ## \\<omega>) !! i)\n\\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (a, b)} \\<and>\nsnd (\\<omega> !! i)\n\\<in> set_pmf (J (snd (((a, b) ## \\<omega>) !! i))) \\<and>\nfst (((a, b) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        trace_in {z} ta x \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "assume *: \"\\<forall>i. snd (((t, x) ## \\<omega>) !! i) \\<in> DTMC.acc `` {snd (t, x)} \\<and>\n    snd (\\<omega> !! i) \\<in> J (snd (((t, x) ## \\<omega>) !! i)) \\<and> fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i)\"\n    and t: \"trace_in {z} t' x \\<omega>\""], ["proof (state)\nthis:\n  \\<forall>i.\n     snd (((t, x) ## \\<omega>) !! i)\n     \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (t, x)} \\<and>\n     snd (\\<omega> !! i)\n     \\<in> set_pmf (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n     fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i)\n  trace_in {z} t' x \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> ta z.\n       \\<lbrakk>\\<forall>i.\n                   snd (((t, x) ## \\<omega>) !! i)\n                   \\<in> (SIGMA \\<omega>:UNIV.\n                             set_pmf (J \\<omega>))\\<^sup>* ``\n                         {snd (t, x)} \\<and>\n                   snd (\\<omega> !! i)\n                   \\<in> set_pmf\n                          (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n                   fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        \\<And>a b.\n           AE \\<omega> in K.lim_stream\n                           (a, b). \\<forall>i.\nsnd (((a, b) ## \\<omega>) !! i)\n\\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (a, b)} \\<and>\nsnd (\\<omega> !! i)\n\\<in> set_pmf (J (snd (((a, b) ## \\<omega>) !! i))) \\<and>\nfst (((a, b) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        trace_in {z} ta x \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "define X where \"X = DTMC.acc `` {x}\""], ["proof (state)\nthis:\n  X = (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> ta z.\n       \\<lbrakk>\\<forall>i.\n                   snd (((t, x) ## \\<omega>) !! i)\n                   \\<in> (SIGMA \\<omega>:UNIV.\n                             set_pmf (J \\<omega>))\\<^sup>* ``\n                         {snd (t, x)} \\<and>\n                   snd (\\<omega> !! i)\n                   \\<in> set_pmf\n                          (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n                   fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        \\<And>a b.\n           AE \\<omega> in K.lim_stream\n                           (a, b). \\<forall>i.\nsnd (((a, b) ## \\<omega>) !! i)\n\\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (a, b)} \\<and>\nsnd (\\<omega> !! i)\n\\<in> set_pmf (J (snd (((a, b) ## \\<omega>) !! i))) \\<and>\nfst (((a, b) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        trace_in {z} ta x \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "have \"(x ## smap snd \\<omega>) !! i \\<in> X\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ## smap snd \\<omega>) !! i \\<in> X", "using *[THEN spec, of i]"], ["proof (prove)\nusing this:\n  snd (((t, x) ## \\<omega>) !! i)\n  \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (t, x)} \\<and>\n  snd (\\<omega> !! i)\n  \\<in> set_pmf (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n  fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i)\n\ngoal (1 subgoal):\n 1. (x ## smap snd \\<omega>) !! i \\<in> X", "by (cases i) (auto simp: X_def)"], ["proof (state)\nthis:\n  (x ## smap snd \\<omega>) !! ?i1 \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> ta z.\n       \\<lbrakk>\\<forall>i.\n                   snd (((t, x) ## \\<omega>) !! i)\n                   \\<in> (SIGMA \\<omega>:UNIV.\n                             set_pmf (J \\<omega>))\\<^sup>* ``\n                         {snd (t, x)} \\<and>\n                   snd (\\<omega> !! i)\n                   \\<in> set_pmf\n                          (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n                   fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        \\<And>a b.\n           AE \\<omega> in K.lim_stream\n                           (a, b). \\<forall>i.\nsnd (((a, b) ## \\<omega>) !! i)\n\\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (a, b)} \\<and>\nsnd (\\<omega> !! i)\n\\<in> set_pmf (J (snd (((a, b) ## \\<omega>) !! i))) \\<and>\nfst (((a, b) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        trace_in {z} ta x \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "from t this"], ["proof (chain)\npicking this:\n  trace_in {z} t' x \\<omega>\n  (x ## smap snd \\<omega>) !! ?i1 \\<in> X", "have \"z \\<in> X\""], ["proof (prove)\nusing this:\n  trace_in {z} t' x \\<omega>\n  (x ## smap snd \\<omega>) !! ?i1 \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> X", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t'a s s' \\<omega>.\n       \\<lbrakk>t' < t'a; s \\<in> {z};\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X\n 2. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t'; trace_in {z} t' s' \\<omega>;\n        (\\<And>i. (s' ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n        z \\<in> X;\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X", "case (1 j y x \\<omega>)"], ["proof (state)\nthis:\n  t' < j\n  y \\<in> {z}\n  (y ## smap snd ((j, x) ## \\<omega>)) !! ?i1 \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>t'a s s' \\<omega>.\n       \\<lbrakk>t' < t'a; s \\<in> {z};\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X\n 2. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t'; trace_in {z} t' s' \\<omega>;\n        (\\<And>i. (s' ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n        z \\<in> X;\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X", "with \"1.prems\"[of 0]"], ["proof (chain)\npicking this:\n  (y ## smap snd ((j, x) ## \\<omega>)) !! 0 \\<in> X\n  t' < j\n  y \\<in> {z}\n  (y ## smap snd ((j, x) ## \\<omega>)) !! ?i1 \\<in> X", "show ?case"], ["proof (prove)\nusing this:\n  (y ## smap snd ((j, x) ## \\<omega>)) !! 0 \\<in> X\n  t' < j\n  y \\<in> {z}\n  (y ## smap snd ((j, x) ## \\<omega>)) !! ?i1 \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> X", "by simp"], ["proof (state)\nthis:\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t'; trace_in {z} t' s' \\<omega>;\n        (\\<And>i. (s' ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n        z \\<in> X;\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t'; trace_in {z} t' s' \\<omega>;\n        (\\<And>i. (s' ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n        z \\<in> X;\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X", "case (2 j y \\<omega> x)"], ["proof (state)\nthis:\n  j \\<le> t'\n  trace_in {z} t' y \\<omega>\n  (\\<And>i. (y ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n  z \\<in> X\n  (x ## smap snd ((j, y) ## \\<omega>)) !! ?i1 \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>t'a s' \\<omega> s.\n       \\<lbrakk>t'a \\<le> t'; trace_in {z} t' s' \\<omega>;\n        (\\<And>i. (s' ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n        z \\<in> X;\n        \\<And>i.\n           (s ## smap snd ((t'a, s') ## \\<omega>)) !! i \\<in> X\\<rbrakk>\n       \\<Longrightarrow> z \\<in> X", "with \"2.prems\"[of \"Suc i\" for i]"], ["proof (chain)\npicking this:\n  (x ## smap snd ((j, y) ## \\<omega>)) !! Suc ?i3 \\<in> X\n  j \\<le> t'\n  trace_in {z} t' y \\<omega>\n  (\\<And>i. (y ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n  z \\<in> X\n  (x ## smap snd ((j, y) ## \\<omega>)) !! ?i1 \\<in> X", "show ?case"], ["proof (prove)\nusing this:\n  (x ## smap snd ((j, y) ## \\<omega>)) !! Suc ?i3 \\<in> X\n  j \\<le> t'\n  trace_in {z} t' y \\<omega>\n  (\\<And>i. (y ## smap snd \\<omega>) !! i \\<in> X) \\<Longrightarrow>\n  z \\<in> X\n  (x ## smap snd ((j, y) ## \\<omega>)) !! ?i1 \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> X", "by simp"], ["proof (state)\nthis:\n  z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> ta z.\n       \\<lbrakk>\\<forall>i.\n                   snd (((t, x) ## \\<omega>) !! i)\n                   \\<in> (SIGMA \\<omega>:UNIV.\n                             set_pmf (J \\<omega>))\\<^sup>* ``\n                         {snd (t, x)} \\<and>\n                   snd (\\<omega> !! i)\n                   \\<in> set_pmf\n                          (J (snd (((t, x) ## \\<omega>) !! i))) \\<and>\n                   fst (((t, x) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        \\<And>a b.\n           AE \\<omega> in K.lim_stream\n                           (a, b). \\<forall>i.\nsnd (((a, b) ## \\<omega>) !! i)\n\\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {snd (a, b)} \\<and>\nsnd (\\<omega> !! i)\n\\<in> set_pmf (J (snd (((a, b) ## \\<omega>) !! i))) \\<and>\nfst (((a, b) ## \\<omega>) !! i) < fst (\\<omega> !! i);\n        trace_in {z} ta x \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  z \\<in> X", "show \"(x, z) \\<in> DTMC.acc\""], ["proof (prove)\nusing this:\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*", "by (simp add: X_def)"], ["proof (state)\nthis:\n  (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_add:\n  assumes \"0 \\<le> t\" \"0 \\<le> t'\"\n  shows \"p x y (t + t') = (LINT z|count_space (DTMC.acc``{x}). p x z t * p z y t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "interpret L: prob_space \"K.lim_stream xy\" for xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (K.lim_stream xy)", "by (rule K.prob_space_lim_stream) simp"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "interpret A: sigma_finite_measure \"count_space (DTMC.acc``{x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sigma_finite_measure\n     (count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}))", "by (intro sigma_finite_measure_count_space_countable DTMC.countable_acc) simp"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "interpret LA: pair_sigma_finite \"count_space (DTMC.acc``{x})\" \"K.lim_stream xy\" for xy"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_sigma_finite\n     (count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}))\n     (K.lim_stream xy)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"p x y (t + t') = (\\<integral>\\<^sup>+ \\<omega>. \\<integral>\\<^sup>+\\<omega>'. indicator {\\<omega>\\<in>space T. trace_in {y} (t + t') x \\<omega>} (merge_at \\<omega> t \\<omega>')\n    \\<partial>K.lim_stream (t, trace_at x \\<omega> t) \\<partial>K.lim_stream (0, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y (t + t')) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "unfolding p_def L.emeasure_eq_measure[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (K.lim_stream (0, x))\n     {\\<omega> \\<in> space (K.lim_stream (0, x)).\n      trace_in {y} (t + t') x \\<omega>} =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "apply (subst lim_time_split[OF \\<open>0 \\<le> t\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure\n     (K.lim_stream (0, x) \\<bind>\n      (\\<lambda>\\<omega>.\n          K.lim_stream (t, trace_at x \\<omega> t) \\<bind>\n          (\\<lambda>\\<omega>'.\n              return (stream_space S) (merge_at \\<omega> t \\<omega>'))))\n     {\\<omega> \\<in> space (K.lim_stream (0, x)).\n      trace_in {y} (t + t') x \\<omega>} =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "apply (subst emeasure_bind[OF lim_stream_not_empty measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. L.random_variable (0, x) (prob_algebra ?N)\n     (\\<lambda>\\<omega>.\n         K.lim_stream (t, trace_at x \\<omega> t) \\<bind>\n         (\\<lambda>\\<omega>'.\n             return (stream_space S) (merge_at \\<omega> t \\<omega>')))\n 2. {\\<omega> \\<in> space (K.lim_stream (0, x)).\n     trace_in {y} (t + t') x \\<omega>}\n    \\<in> sets ?N\n 3. \\<integral>\\<^sup>+ xa. emeasure\n                             (K.lim_stream (t, trace_at x xa t) \\<bind>\n                              (\\<lambda>\\<omega>'.\n                                  return (stream_space S)\n                                   (merge_at xa t \\<omega>')))\n                             {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                              trace_in {y} (t + t') x \\<omega>}\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<omega> \\<in> space (K.lim_stream (0, x)).\n     trace_in {y} (t + t') x \\<omega>}\n    \\<in> sets (stream_space S)\n 2. \\<integral>\\<^sup>+ xa. emeasure\n                             (K.lim_stream (t, trace_at x xa t) \\<bind>\n                              (\\<lambda>\\<omega>'.\n                                  return (stream_space S)\n                                   (merge_at xa t \\<omega>')))\n                             {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                              trace_in {y} (t + t') x \\<omega>}\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. emeasure\n                             (K.lim_stream (t, trace_at x xa t) \\<bind>\n                              (\\<lambda>\\<omega>'.\n                                  return (stream_space S)\n                                   (merge_at xa t \\<omega>')))\n                             {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                              trace_in {y} (t + t') x \\<omega>}\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "apply (intro nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       emeasure\n        (K.lim_stream (t, trace_at x xa t) \\<bind>\n         (\\<lambda>\\<omega>'.\n             return (stream_space S) (merge_at xa t \\<omega>')))\n        {\\<omega> \\<in> space (K.lim_stream (0, x)).\n         trace_in {y} (t + t') x \\<omega>} =\n       \\<integral>\\<^sup>+ \\<omega>'.\n                            indicator\n                             {\\<omega> \\<in> space (stream_space S).\n                              trace_in {y} (t + t') x \\<omega>}\n                             (merge_at xa t \\<omega>')\n                          \\<partial>K.lim_stream (t, trace_at x xa t)", "apply (subst emeasure_bind[OF lim_stream_not_empty measurable_prob_algebraD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       L.random_variable (t, trace_at x xa t) (prob_algebra (?N38 xa))\n        (\\<lambda>\\<omega>'.\n            return (stream_space S) (merge_at xa t \\<omega>'))\n 2. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       {\\<omega> \\<in> space (K.lim_stream (0, x)).\n        trace_in {y} (t + t') x \\<omega>}\n       \\<in> sets (?N38 xa)\n 3. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ xb. emeasure\n                                (return (stream_space S) (merge_at xa t xb))\n                                {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                                 trace_in {y} (t + t') x \\<omega>}\n                          \\<partial>K.lim_stream (t, trace_at x xa t) =\n       \\<integral>\\<^sup>+ \\<omega>'.\n                            indicator\n                             {\\<omega> \\<in> space (stream_space S).\n                              trace_in {y} (t + t') x \\<omega>}\n                             (merge_at xa t \\<omega>')\n                          \\<partial>K.lim_stream (t, trace_at x xa t)", "apply (measurable; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       {\\<omega> \\<in> space (K.lim_stream (0, x)).\n        trace_in {y} (t + t') x \\<omega>}\n       \\<in> sets (stream_space S)\n 2. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ xb. emeasure\n                                (return (stream_space S) (merge_at xa t xb))\n                                {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                                 trace_in {y} (t + t') x \\<omega>}\n                          \\<partial>K.lim_stream (t, trace_at x xa t) =\n       \\<integral>\\<^sup>+ \\<omega>'.\n                            indicator\n                             {\\<omega> \\<in> space (stream_space S).\n                              trace_in {y} (t + t') x \\<omega>}\n                             (merge_at xa t \\<omega>')\n                          \\<partial>K.lim_stream (t, trace_at x xa t)", "apply (measurable; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (K.lim_stream (0, x)) \\<Longrightarrow>\n       \\<integral>\\<^sup>+ xb. emeasure\n                                (return (stream_space S) (merge_at xa t xb))\n                                {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                                 trace_in {y} (t + t') x \\<omega>}\n                          \\<partial>K.lim_stream (t, trace_at x xa t) =\n       \\<integral>\\<^sup>+ \\<omega>'.\n                            indicator\n                             {\\<omega> \\<in> space (stream_space S).\n                              trace_in {y} (t + t') x \\<omega>}\n                             (merge_at xa t \\<omega>')\n                          \\<partial>K.lim_stream (t, trace_at x xa t)", "apply (simp add: in_space_lim_stream)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ennreal (p x y (t + t')) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t \\<omega>')\n    \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  ennreal (p x y (t + t')) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t \\<omega>')\n    \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+ \\<omega>. \\<integral>\\<^sup>+\\<omega>'. indicator {\\<omega>\\<in>space T. trace_in {y} (t + t') x \\<omega>} (merge_at \\<omega> t (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t) \\<partial>K.lim_stream (0, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t\n           (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "unfolding lim_0[of t]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t \\<omega>')\n      \\<partial>distr (K.lim_stream (0, trace_at x \\<omega> t))\n                 (stream_space S) (smap (\\<lambda>(t', y). (t' + t, y)))\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t\n           (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "by (subst nn_integral_distr) (measurable; fail)+"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t \\<omega>')\n    \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t\n         (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t \\<omega>')\n    \\<partial>K.lim_stream (t, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t\n         (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+ \\<omega>. \\<integral>\\<^sup>+\\<omega>'. of_bool (\\<exists>z\\<in>DTMC.acc``{x}. trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t) \\<partial>K.lim_stream (0, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at \\<omega> t\n           (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        of_bool\n         (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n             trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "apply (rule nn_integral_cong_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE xa in K.lim_stream\n              (0, x). \\<integral>\\<^sup>+ \\<omega>'.\n     indicator\n      {\\<omega> \\<in> space (stream_space S).\n       trace_in {y} (t + t') x \\<omega>}\n      (merge_at xa t (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n   \\<partial>K.lim_stream (0, trace_at x xa t) =\n                      \\<integral>\\<^sup>+ \\<omega>'.\n     of_bool\n      (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n          trace_in {z} t x xa \\<and> trace_in {y} t' z \\<omega>')\n   \\<partial>K.lim_stream (0, trace_at x xa t)", "using AE_lim_wf_times AE_lim_acc"], ["proof (prove)\nusing this:\n  almost_everywhere (K.lim_stream (?t, ?s)) (wf_times ?t)\n  AE \\<omega> in K.lim_stream\n                  (?t,\n                   ?x). \\<forall>t z.\n                           trace_in {z} t ?x \\<omega> \\<longrightarrow>\n                           (?x, z)\n                           \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. AE xa in K.lim_stream\n              (0, x). \\<integral>\\<^sup>+ \\<omega>'.\n     indicator\n      {\\<omega> \\<in> space (stream_space S).\n       trace_in {y} (t + t') x \\<omega>}\n      (merge_at xa t (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n   \\<partial>K.lim_stream (0, trace_at x xa t) =\n                      \\<integral>\\<^sup>+ \\<omega>'.\n     of_bool\n      (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n          trace_in {z} t x xa \\<and> trace_in {y} t' z \\<omega>')\n   \\<partial>K.lim_stream (0, trace_at x xa t)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>wf_times 0 xa;\n        \\<forall>t z.\n           trace_in {z} t x xa \\<longrightarrow>\n           (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>'.\n        indicator\n         {\\<omega> \\<in> space (stream_space S).\n          trace_in {y} (t + t') x \\<omega>}\n         (merge_at xa t (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n      \\<partial>K.lim_stream (0, trace_at x xa t) =\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        of_bool\n         (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n             trace_in {z} t x xa \\<and> trace_in {y} t' z \\<omega>')\n      \\<partial>K.lim_stream (0, trace_at x xa t)", "subgoal premises \\<omega> for \\<omega>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>'.\n                         indicator\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {y} (t + t') x \\<omega>}\n                          (merge_at \\<omega> t\n                            (smap (\\<lambda>(t'', s). (t'' + t, s))\n                              \\<omega>'))\n                       \\<partial>K.lim_stream (0, trace_at x \\<omega> t) =\n    \\<integral>\\<^sup>+ \\<omega>'.\n                         of_bool\n                          (\\<exists>z\\<in>(SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {x}.\n                              trace_in {z} t x \\<omega> \\<and>\n                              trace_in {y} t' z \\<omega>')\n                       \\<partial>K.lim_stream (0, trace_at x \\<omega> t)", "apply (rule nn_integral_cong_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE xa in K.lim_stream\n              (0, trace_at x \\<omega>\n                   t). indicator\n                        {\\<omega> \\<in> space (stream_space S).\n                         trace_in {y} (t + t') x \\<omega>}\n                        (merge_at \\<omega> t\n                          (smap (\\<lambda>(t'', s). (t'' + t, s)) xa)) =\n                       of_bool\n                        (\\<exists>z\\<in>(SIGMA x:UNIV.\n      set_pmf (J x))\\<^sup>* ``\n  {x}.\n                            trace_in {z} t x \\<omega> \\<and>\n                            trace_in {y} t' z xa)", "using AE_lim_wf_times AE_lim_acc"], ["proof (prove)\nusing this:\n  almost_everywhere (K.lim_stream (?t, ?s)) (wf_times ?t)\n  AE \\<omega> in K.lim_stream\n                  (?t,\n                   ?x). \\<forall>t z.\n                           trace_in {z} t ?x \\<omega> \\<longrightarrow>\n                           (?x, z)\n                           \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. AE xa in K.lim_stream\n              (0, trace_at x \\<omega>\n                   t). indicator\n                        {\\<omega> \\<in> space (stream_space S).\n                         trace_in {y} (t + t') x \\<omega>}\n                        (merge_at \\<omega> t\n                          (smap (\\<lambda>(t'', s). (t'' + t, s)) xa)) =\n                       of_bool\n                        (\\<exists>z\\<in>(SIGMA x:UNIV.\n      set_pmf (J x))\\<^sup>* ``\n  {x}.\n                            trace_in {z} t x \\<omega> \\<and>\n                            trace_in {y} t' z xa)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>wf_times 0 xa;\n        \\<forall>ta z.\n           trace_in {z} ta (trace_at x \\<omega> t) xa \\<longrightarrow>\n           (trace_at x \\<omega> t, z)\n           \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> indicator\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {y} (t + t') x \\<omega>}\n                          (merge_at \\<omega> t\n                            (smap (\\<lambda>(t'', s). (t'' + t, s)) xa)) =\n                         of_bool\n                          (\\<exists>z\\<in>(SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {x}.\n                              trace_in {z} t x \\<omega> \\<and>\n                              trace_in {y} t' z xa)", "using \\<omega> assms"], ["proof (prove)\nusing this:\n  wf_times 0 \\<omega>\n  \\<forall>t z.\n     trace_in {z} t x \\<omega> \\<longrightarrow>\n     (x, z) \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\n  0 \\<le> t\n  0 \\<le> t'\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>wf_times 0 xa;\n        \\<forall>ta z.\n           trace_in {z} ta (trace_at x \\<omega> t) xa \\<longrightarrow>\n           (trace_at x \\<omega> t, z)\n           \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> indicator\n                          {\\<omega> \\<in> space (stream_space S).\n                           trace_in {y} (t + t') x \\<omega>}\n                          (merge_at \\<omega> t\n                            (smap (\\<lambda>(t'', s). (t'' + t, s)) xa)) =\n                         of_bool\n                          (\\<exists>z\\<in>(SIGMA x:UNIV.\n        set_pmf (J x))\\<^sup>* ``\n    {x}.\n                              trace_in {z} t x \\<omega> \\<and>\n                              trace_in {y} t' z xa)", "apply (auto simp add: trace_in_merge_at indicator_def Bex_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t\n         (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      of_bool\n       (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n           trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      indicator\n       {\\<omega> \\<in> space (stream_space S).\n        trace_in {y} (t + t') x \\<omega>}\n       (merge_at \\<omega> t\n         (smap (\\<lambda>(t'', s). (t'' + t, s)) \\<omega>'))\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      of_bool\n       (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n           trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+ \\<omega>. \\<integral>\\<^sup>+\\<omega>'. \\<integral>\\<^sup>+z. of_bool (trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>count_space (DTMC.acc``{x}) \\<partial>K.lim_stream (0, trace_at x \\<omega> t) \\<partial>K.lim_stream (0, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        of_bool\n         (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n             trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        \\<integral>\\<^sup>+ z. of_bool\n                                (trace_in {z} t x \\<omega> \\<and>\n                                 trace_in {y} t' z \\<omega>')\n                           \\<partial>count_space\n((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x)", "by (intro nn_integral_cong of_bool_Bex_eq_nn_integral) (auto dest: trace_in_unique)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      of_bool\n       (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n           trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      \\<integral>\\<^sup>+ z. of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                         \\<partial>count_space\n                                    ((SIGMA x:UNIV.\n   set_pmf (J x))\\<^sup>* ``\n                                     {x})\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      of_bool\n       (\\<exists>z\\<in>(SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}.\n           trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      \\<integral>\\<^sup>+ z. of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                         \\<partial>count_space\n                                    ((SIGMA x:UNIV.\n   set_pmf (J x))\\<^sup>* ``\n                                     {x})\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+ \\<omega>. \\<integral>\\<^sup>+z. \\<integral>\\<^sup>+\\<omega>'. of_bool (trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t) \\<partial>count_space (DTMC.acc``{x}) \\<partial>K.lim_stream (0, x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        \\<integral>\\<^sup>+ z. of_bool\n                                (trace_in {z} t x \\<omega> \\<and>\n                                 trace_in {y} t' z \\<omega>')\n                           \\<partial>count_space\n((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n      \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ z.\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x)", "apply (subst LA.Fubini')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       (\\<lambda>(z, \\<omega>').\n           of_bool\n            (trace_in {z} t x \\<omega> \\<and> trace_in {y} t' z \\<omega>'))\n       \\<in> borel_measurable\n              (count_space\n                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                 {x}) \\<Otimes>\\<^sub>M\n               K.lim_stream (0, trace_at x \\<omega> t))\n 2. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ xa.\n        \\<integral>\\<^sup>+ ya. of_bool\n                                 (trace_in {xa} t x \\<omega> \\<and>\n                                  trace_in {y} t' xa ya)\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ z.\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x)", "apply (subst measurable_split_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       (\\<lambda>xa.\n           of_bool\n            (trace_in {fst xa} t x \\<omega> \\<and>\n             trace_in {y} t' (fst xa) (snd xa)))\n       \\<in> borel_measurable\n              (count_space\n                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                 {x}) \\<Otimes>\\<^sub>M\n               K.lim_stream (0, trace_at x \\<omega> t))\n 2. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ xa.\n        \\<integral>\\<^sup>+ ya. of_bool\n                                 (trace_in {xa} t x \\<omega> \\<and>\n                                  trace_in {y} t' xa ya)\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ z.\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x)", "apply (rule measurable_compose_countable'[OF _ measurable_fst])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<omega> i.\n       i \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x} \\<Longrightarrow>\n       (\\<lambda>xa.\n           of_bool\n            (trace_in {i} t x \\<omega> \\<and> trace_in {y} t' i (snd xa)))\n       \\<in> borel_measurable\n              (count_space\n                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                 {x}) \\<Otimes>\\<^sub>M\n               K.lim_stream (0, trace_at x \\<omega> t))\n 2. \\<And>\\<omega>. countable ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n 3. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ xa.\n        \\<integral>\\<^sup>+ ya. of_bool\n                                 (trace_in {xa} t x \\<omega> \\<and>\n                                  trace_in {y} t' xa ya)\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ z.\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x)", "apply (auto simp: DTMC.countable_acc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      \\<integral>\\<^sup>+ z. of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                         \\<partial>count_space\n                                    ((SIGMA x:UNIV.\n   set_pmf (J x))\\<^sup>* ``\n                                     {x})\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ z.\n      \\<integral>\\<^sup>+ \\<omega>'.\n                           of_bool\n                            (trace_in {z} t x \\<omega> \\<and>\n                             trace_in {y} t' z \\<omega>')\n                         \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n    \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ \\<omega>'.\n      \\<integral>\\<^sup>+ z. of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                         \\<partial>count_space\n                                    ((SIGMA x:UNIV.\n   set_pmf (J x))\\<^sup>* ``\n                                     {x})\n    \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ z.\n      \\<integral>\\<^sup>+ \\<omega>'.\n                           of_bool\n                            (trace_in {z} t x \\<omega> \\<and>\n                             trace_in {y} t' z \\<omega>')\n                         \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n    \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                     \\<partial>K.lim_stream (0, x)\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+z. \\<integral>\\<^sup>+ \\<omega>. of_bool (trace_in {z} t x \\<omega>) * \\<integral>\\<^sup>+\\<omega>'. of_bool (trace_in {y} t' z \\<omega>')\n    \\<partial>K.lim_stream (0, z) \\<partial>K.lim_stream (0, x) \\<partial>count_space (DTMC.acc``{x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         \\<integral>\\<^sup>+ z.\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n      \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                       \\<partial>K.lim_stream (0, x) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (subst LA.Fubini')"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>(z, \\<omega>).\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {z} t x \\<omega> \\<and>\n                               trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream\n(0, trace_at x \\<omega> t))\n    \\<in> borel_measurable\n           (count_space\n             ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n              {x}) \\<Otimes>\\<^sub>M\n            K.lim_stream (0, x))\n 2. \\<integral>\\<^sup>+ xa. \\<integral>\\<^sup>+ ya.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {xa} t x ya \\<and>\n                                  trace_in {y} t' xa \\<omega>')\n                              \\<partial>K.lim_stream (0, trace_at x ya t)\n         \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (subst measurable_split_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>xa.\n        \\<integral>\\<^sup>+ \\<omega>'.\n                             of_bool\n                              (trace_in {fst xa} t x (snd xa) \\<and>\n                               trace_in {y} t' (fst xa) \\<omega>')\n                           \\<partial>K.lim_stream\n(0, trace_at x (snd xa) t))\n    \\<in> borel_measurable\n           (count_space\n             ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n              {x}) \\<Otimes>\\<^sub>M\n            K.lim_stream (0, x))\n 2. \\<integral>\\<^sup>+ xa. \\<integral>\\<^sup>+ ya.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {xa} t x ya \\<and>\n                                  trace_in {y} t' xa \\<omega>')\n                              \\<partial>K.lim_stream (0, trace_at x ya t)\n         \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (rule measurable_compose_countable'[OF _ measurable_fst])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x} \\<Longrightarrow>\n       (\\<lambda>xa.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {i} t x (snd xa) \\<and>\n                                  trace_in {y} t' i \\<omega>')\n                              \\<partial>K.lim_stream\n   (0, trace_at x (snd xa) t))\n       \\<in> borel_measurable\n              (count_space\n                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                 {x}) \\<Otimes>\\<^sub>M\n               K.lim_stream (0, x))\n 2. countable ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n 3. \\<integral>\\<^sup>+ xa. \\<integral>\\<^sup>+ ya.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {xa} t x ya \\<and>\n                                  trace_in {y} t' xa \\<omega>')\n                              \\<partial>K.lim_stream (0, trace_at x ya t)\n         \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (rule nn_integral_measurable_subprob_algebra2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>i.\n       i \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x} \\<Longrightarrow>\n       (\\<lambda>(xa, ya).\n           of_bool (trace_in {i} t x (snd xa) \\<and> trace_in {y} t' i ya))\n       \\<in> borel_measurable\n              ((count_space\n                 ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                  {x}) \\<Otimes>\\<^sub>M\n                K.lim_stream (0, x)) \\<Otimes>\\<^sub>M\n               ?N7 i)\n 2. \\<And>i.\n       i \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x} \\<Longrightarrow>\n       (\\<lambda>xa. K.lim_stream (0, trace_at x (snd xa) t))\n       \\<in> count_space\n              ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x}) \\<Otimes>\\<^sub>M\n             K.lim_stream (0, x) \\<rightarrow>\\<^sub>M\n             subprob_algebra (?N7 i)\n 3. countable ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n 4. \\<integral>\\<^sup>+ xa. \\<integral>\\<^sup>+ ya.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {xa} t x ya \\<and>\n                                  trace_in {y} t' xa \\<omega>')\n                              \\<partial>K.lim_stream (0, trace_at x ya t)\n         \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (measurable; fail)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x} \\<Longrightarrow>\n       (\\<lambda>xa. K.lim_stream (0, trace_at x (snd xa) t))\n       \\<in> count_space\n              ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x}) \\<Otimes>\\<^sub>M\n             K.lim_stream (0, x) \\<rightarrow>\\<^sub>M\n             subprob_algebra (stream_space S)\n 2. countable ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n 3. \\<integral>\\<^sup>+ xa. \\<integral>\\<^sup>+ ya.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {xa} t x ya \\<and>\n                                  trace_in {y} t' xa \\<omega>')\n                              \\<partial>K.lim_stream (0, trace_at x ya t)\n         \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (rule measurable_prob_algebraD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       i \\<in> (SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x} \\<Longrightarrow>\n       (\\<lambda>xa. K.lim_stream (0, trace_at x (snd xa) t))\n       \\<in> count_space\n              ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n               {x}) \\<Otimes>\\<^sub>M\n             K.lim_stream (0, x) \\<rightarrow>\\<^sub>M\n             prob_algebra (stream_space S)\n 2. countable ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n 3. \\<integral>\\<^sup>+ xa. \\<integral>\\<^sup>+ ya.\n           \\<integral>\\<^sup>+ \\<omega>'.\n                                of_bool\n                                 (trace_in {xa} t x ya \\<and>\n                                  trace_in {y} t' xa \\<omega>')\n                              \\<partial>K.lim_stream (0, trace_at x ya t)\n         \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "apply (auto simp: DTMC.countable_acc trace_at_eq intro!: nn_integral_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ z.\n      \\<integral>\\<^sup>+ \\<omega>'.\n                           of_bool\n                            (trace_in {z} t x \\<omega> \\<and>\n                             trace_in {y} t' z \\<omega>')\n                         \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n    \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>) *\n        \\<integral>\\<^sup>+ \\<omega>'. of_bool (trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, z)\n      \\<partial>K.lim_stream (0, x)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       \\<integral>\\<^sup>+ z.\n      \\<integral>\\<^sup>+ \\<omega>'.\n                           of_bool\n                            (trace_in {z} t x \\<omega> \\<and>\n                             trace_in {y} t' z \\<omega>')\n                         \\<partial>K.lim_stream (0, trace_at x \\<omega> t)\n    \\<partial>count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x})\n                     \\<partial>K.lim_stream (0, x) =\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>) *\n        \\<integral>\\<^sup>+ \\<omega>'. of_bool (trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, z)\n      \\<partial>K.lim_stream (0, x)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+z. (\\<integral>\\<^sup>+ \\<omega>. of_bool (trace_in {z} t x \\<omega>)\\<partial>K.lim_stream (0, x)) *\n      (\\<integral>\\<^sup>+\\<omega>'. of_bool (trace_in {y} t' z \\<omega>') \\<partial>K.lim_stream (0, z)) \\<partial>count_space (DTMC.acc``{x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>) *\n          \\<integral>\\<^sup>+ \\<omega>'.\n                               of_bool (trace_in {y} t' z \\<omega>')\n                             \\<partial>K.lim_stream (0, z)\n        \\<partial>K.lim_stream (0, x)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>)\n        \\<partial>K.lim_stream (0, x) *\n                           \\<integral>\\<^sup>+ \\<omega>'.\n          of_bool (trace_in {y} t' z \\<omega>')\n        \\<partial>K.lim_stream (0, z)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "by (auto intro!: nn_integral_cong simp: nn_integral_multc)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>) *\n        \\<integral>\\<^sup>+ \\<omega>'. of_bool (trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, z)\n      \\<partial>K.lim_stream (0, x)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x}) =\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>)\n      \\<partial>K.lim_stream (0, x) *\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        of_bool (trace_in {y} t' z \\<omega>')\n      \\<partial>K.lim_stream (0, z)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>) *\n        \\<integral>\\<^sup>+ \\<omega>'. of_bool (trace_in {y} t' z \\<omega>')\n                           \\<partial>K.lim_stream (0, z)\n      \\<partial>K.lim_stream (0, x)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x}) =\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>)\n      \\<partial>K.lim_stream (0, x) *\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        of_bool (trace_in {y} t' z \\<omega>')\n      \\<partial>K.lim_stream (0, z)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "have \"\\<dots> = (\\<integral>\\<^sup>+z. ennreal (p x z t) * ennreal (p z y t') \\<partial>count_space (DTMC.acc``{x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>)\n        \\<partial>K.lim_stream (0, x) *\n                           \\<integral>\\<^sup>+ \\<omega>'.\n          of_bool (trace_in {y} t' z \\<omega>')\n        \\<partial>K.lim_stream (0, z)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. ennreal (p x z t) * ennreal (p z y t')\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "unfolding p_def L.emeasure_eq_measure[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n          of_bool (trace_in {z} t x \\<omega>)\n        \\<partial>K.lim_stream (0, x) *\n                           \\<integral>\\<^sup>+ \\<omega>'.\n          of_bool (trace_in {y} t' z \\<omega>')\n        \\<partial>K.lim_stream (0, z)\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    \\<integral>\\<^sup>+ z. emeasure (K.lim_stream (0, x))\n                            {\\<omega> \\<in> space (K.lim_stream (0, x)).\n                             trace_in {z} t x \\<omega>} *\n                           emeasure (K.lim_stream (0, z))\n                            {\\<omega> \\<in> space (K.lim_stream (0, z)).\n                             trace_in {y} t' z \\<omega>}\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x})", "by (auto intro!: nn_integral_cong arg_cong2[where f=\"(*)\"]\n             simp: nn_integral_indicator[symmetric] simp del: nn_integral_indicator )"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ z. \\<integral>\\<^sup>+ \\<omega>.\n        of_bool (trace_in {z} t x \\<omega>)\n      \\<partial>K.lim_stream (0, x) *\n                         \\<integral>\\<^sup>+ \\<omega>'.\n        of_bool (trace_in {y} t' z \\<omega>')\n      \\<partial>K.lim_stream (0, z)\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x}) =\n  \\<integral>\\<^sup>+ z. ennreal (p x z t) * ennreal (p z y t')\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "finally"], ["proof (chain)\npicking this:\n  ennreal (p x y (t + t')) =\n  \\<integral>\\<^sup>+ z. ennreal (p x z t) * ennreal (p z y t')\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})", "have \"(\\<integral>\\<^sup>+z. p x z t * p z y t' \\<partial>count_space (DTMC.acc``{x})) = p x y (t + t')\""], ["proof (prove)\nusing this:\n  ennreal (p x y (t + t')) =\n  \\<integral>\\<^sup>+ z. ennreal (p x z t) * ennreal (p z y t')\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x})\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal (p x xa t * p xa y t')\n                       \\<partial>count_space\n                                  ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                   {x}) =\n    ennreal (p x y (t + t'))", "by (simp add: ennreal_mult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ xa. ennreal (p x xa t * p xa y t')\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x}) =\n  ennreal (p x y (t + t'))\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "then"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ xa. ennreal (p x xa t * p xa y t')\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x}) =\n  ennreal (p x y (t + t'))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ xa. ennreal (p x xa t * p xa y t')\n                     \\<partial>count_space\n                                ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* ``\n                                 {x}) =\n  ennreal (p x y (t + t'))\n\ngoal (1 subgoal):\n 1. p x y (t + t') =\n    LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n       p x z t * p z y t'", "by (subst (asm) nn_integral_eq_integrable) auto"], ["proof (state)\nthis:\n  p x y (t + t') =\n  LINT z|count_space ((SIGMA x:UNIV. set_pmf (J x))\\<^sup>* `` {x}).\n     p x z t * p z y t'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}