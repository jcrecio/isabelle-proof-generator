{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/Gossip_Broadcast.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma inj_on_upd_PiE:\n  assumes \"i \\<notin> I\" shows \"inj_on (\\<lambda>(x,f). f(i := x)) (M \\<times> (\\<Pi>\\<^sub>E i\\<in>I. A i))\"", "lemma sum_folded_product:\n  fixes I :: \"'i set\" and f :: \"'s \\<Rightarrow> 'i \\<Rightarrow> 'a::{semiring_0, comm_monoid_mult}\"\n  assumes \"finite I\" \"\\<And>i. i \\<in> I \\<Longrightarrow> finite (S i)\"\n  shows \"(\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) = (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)\"", "lemma state_UNIV: \"UNIV = {listening, sending, sleeping}\"", "lemma node_trans_sum_eq_1[simp]:\n  \"node_trans g x s' listening + (node_trans g x s' sending + node_trans g x s' sleeping) = 1\"", "lemma node_trans_nonneg[simp]: \"0 \\<le> node_trans s x i j\""], "translations": [["", "lemma inj_on_upd_PiE:\n  assumes \"i \\<notin> I\" shows \"inj_on (\\<lambda>(x,f). f(i := x)) (M \\<times> (\\<Pi>\\<^sub>E i\\<in>I. A i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, f). f(i := x)) (M \\<times> Pi\\<^sub>E I A)", "unfolding PiE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(x, f). f(i := x))\n     (M \\<times> (Pi I A \\<inter> extensional I))", "proof (safe intro!: inj_onI ext)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba x.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> b x = ba x", "fix f g :: \"'a \\<Rightarrow> 'b\" and x y :: 'b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba x.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> b x = ba x", "assume *: \"f(i := x) = g(i := y)\" \"f \\<in> extensional I\" \"g \\<in> extensional I\""], ["proof (state)\nthis:\n  f(i := x) = g(i := y)\n  f \\<in> extensional I\n  g \\<in> extensional I\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> a = aa\n 2. \\<And>a b aa ba x.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> b x = ba x", "then"], ["proof (chain)\npicking this:\n  f(i := x) = g(i := y)\n  f \\<in> extensional I\n  g \\<in> extensional I", "show \"x = y\""], ["proof (prove)\nusing this:\n  f(i := x) = g(i := y)\n  f \\<in> extensional I\n  g \\<in> extensional I\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: fun_eq_iff split: if_split_asm)"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<And>a b aa ba x.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> b x = ba x", "fix i'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba x.\n       \\<lbrakk>b(i := a) = ba(i := aa); a \\<in> M; b \\<in> Pi I A;\n        b \\<in> extensional I; aa \\<in> M; ba \\<in> Pi I A;\n        ba \\<in> extensional I\\<rbrakk>\n       \\<Longrightarrow> b x = ba x", "from * \\<open>i \\<notin> I\\<close>"], ["proof (chain)\npicking this:\n  f(i := x) = g(i := y)\n  f \\<in> extensional I\n  g \\<in> extensional I\n  i \\<notin> I", "show \"f i' = g i'\""], ["proof (prove)\nusing this:\n  f(i := x) = g(i := y)\n  f \\<in> extensional I\n  g \\<in> extensional I\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. f i' = g i'", "by (cases \"i' = i\") (auto simp: fun_eq_iff extensional_def split: if_split_asm)"], ["proof (state)\nthis:\n  f i' = g i'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_folded_product:\n  fixes I :: \"'i set\" and f :: \"'s \\<Rightarrow> 'i \\<Rightarrow> 'a::{semiring_0, comm_monoid_mult}\"\n  assumes \"finite I\" \"\\<And>i. i \\<in> I \\<Longrightarrow> finite (S i)\"\n  shows \"(\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) = (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) =\n    (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)", "using assms"], ["proof (prove)\nusing this:\n  finite I\n  ?i \\<in> I \\<Longrightarrow> finite (S ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) =\n    (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)", "proof (induct I)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Pi\\<^sub>E {} S. \\<Prod>i\\<in>{}. f (x i) i) =\n    (\\<Prod>i\\<in>{}. \\<Sum>s\\<in>S i. f s i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "case empty"], ["proof (state)\nthis:\n  ?i \\<in> {} \\<Longrightarrow> finite (S ?i)\n\ngoal (2 subgoals):\n 1. (\\<And>i. i \\<in> {} \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n    (\\<Sum>x\\<in>Pi\\<^sub>E {} S. \\<Prod>i\\<in>{}. f (x i) i) =\n    (\\<Prod>i\\<in>{}. \\<Sum>s\\<in>S i. f s i)\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "then"], ["proof (chain)\npicking this:\n  ?i \\<in> {} \\<Longrightarrow> finite (S ?i)", "show ?case"], ["proof (prove)\nusing this:\n  ?i \\<in> {} \\<Longrightarrow> finite (S ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pi\\<^sub>E {} S. \\<Prod>i\\<in>{}. f (x i) i) =\n    (\\<Prod>i\\<in>{}. \\<Sum>s\\<in>S i. f s i)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Pi\\<^sub>E {} S. \\<Prod>i\\<in>{}. f (x i) i) =\n  (\\<Prod>i\\<in>{}. \\<Sum>s\\<in>S i. f s i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "case (insert i I)"], ["proof (state)\nthis:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n  (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) =\n  (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)\n  ?i \\<in> insert i I \\<Longrightarrow> finite (S ?i)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "have *: \"Pi\\<^sub>E (insert i I) S = (\\<lambda>(x, f). f(i := x)) ` (S i \\<times> Pi\\<^sub>E I S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pi\\<^sub>E (insert i I) S =\n    (\\<lambda>(x, f). f(i := x)) ` (S i \\<times> Pi\\<^sub>E I S)", "by (auto simp: PiE_def intro!: image_eqI ext dest: extensional_arb)"], ["proof (state)\nthis:\n  Pi\\<^sub>E (insert i I) S =\n  (\\<lambda>(x, f). f(i := x)) ` (S i \\<times> Pi\\<^sub>E I S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "have \"(\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S. \\<Prod>i\\<in>insert i I. f (x i) i) =\n    sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ> ((\\<lambda>(x, f). f(i := x)))) (S i \\<times> Pi\\<^sub>E I S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n       \\<Prod>i\\<in>insert i I. f (x i) i) =\n    sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n         (\\<lambda>(x, f). f(i := x)))\n     (S i \\<times> Pi\\<^sub>E I S)", "unfolding *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(\\<lambda>(x, f). f(i := x)) `\n                 (S i \\<times> Pi\\<^sub>E I S).\n       \\<Prod>i\\<in>insert i I. f (x i) i) =\n    sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n         (\\<lambda>(x, f). f(i := x)))\n     (S i \\<times> Pi\\<^sub>E I S)", "using insert"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n  (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) =\n  (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)\n  ?i \\<in> insert i I \\<Longrightarrow> finite (S ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>(\\<lambda>(x, f). f(i := x)) `\n                 (S i \\<times> Pi\\<^sub>E I S).\n       \\<Prod>i\\<in>insert i I. f (x i) i) =\n    sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n         (\\<lambda>(x, f). f(i := x)))\n     (S i \\<times> Pi\\<^sub>E I S)", "by (intro sum.reindex) (auto intro!: inj_on_upd_PiE)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n     \\<Prod>i\\<in>insert i I. f (x i) i) =\n  sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n       (\\<lambda>(x, f). f(i := x)))\n   (S i \\<times> Pi\\<^sub>E I S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n     \\<Prod>i\\<in>insert i I. f (x i) i) =\n  sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n       (\\<lambda>(x, f). f(i := x)))\n   (S i \\<times> Pi\\<^sub>E I S)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "have \"\\<dots> = (\\<Sum>(a, x)\\<in>(S i \\<times> Pi\\<^sub>E I S). f a i * (\\<Prod>i\\<in>I. f (x i) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n         (\\<lambda>(x, f). f(i := x)))\n     (S i \\<times> Pi\\<^sub>E I S) =\n    (\\<Sum>(a, x)\\<in>S i \\<times> Pi\\<^sub>E I S.\n       f a i * (\\<Prod>i\\<in>I. f (x i) i))", "using insert"], ["proof (prove)\nusing this:\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n  (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) =\n  (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)\n  ?i \\<in> insert i I \\<Longrightarrow> finite (S ?i)\n\ngoal (1 subgoal):\n 1. sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n         (\\<lambda>(x, f). f(i := x)))\n     (S i \\<times> Pi\\<^sub>E I S) =\n    (\\<Sum>(a, x)\\<in>S i \\<times> Pi\\<^sub>E I S.\n       f a i * (\\<Prod>i\\<in>I. f (x i) i))", "by (force intro!: sum.cong prod.cong arg_cong2[where f=\"(*)\"])"], ["proof (state)\nthis:\n  sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n       (\\<lambda>(x, f). f(i := x)))\n   (S i \\<times> Pi\\<^sub>E I S) =\n  (\\<Sum>(a, x)\\<in>S i \\<times> Pi\\<^sub>E I S.\n     f a i * (\\<Prod>i\\<in>I. f (x i) i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "also"], ["proof (state)\nthis:\n  sum ((\\<lambda>x. \\<Prod>i\\<in>insert i I. f (x i) i) \\<circ>\n       (\\<lambda>(x, f). f(i := x)))\n   (S i \\<times> Pi\\<^sub>E I S) =\n  (\\<Sum>(a, x)\\<in>S i \\<times> Pi\\<^sub>E I S.\n     f a i * (\\<Prod>i\\<in>I. f (x i) i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "have \"\\<dots> = (\\<Sum>a\\<in>S i. f a i * (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, x)\\<in>S i \\<times> Pi\\<^sub>E I S.\n       f a i * (\\<Prod>i\\<in>I. f (x i) i)) =\n    (\\<Sum>a\\<in>S i.\n       f a i * (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i))", "by (simp add: sum.cartesian_product sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>(a, x)\\<in>S i \\<times> Pi\\<^sub>E I S.\n     f a i * (\\<Prod>i\\<in>I. f (x i) i)) =\n  (\\<Sum>a\\<in>S i.\n     f a i * (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i))\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        (\\<And>i.\n            i \\<in> F \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n        (\\<Sum>x\\<in>Pi\\<^sub>E F S. \\<Prod>i\\<in>F. f (x i) i) =\n        (\\<Prod>i\\<in>F. \\<Sum>s\\<in>S i. f s i);\n        \\<And>i. i \\<in> insert x F \\<Longrightarrow> finite (S i)\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>xa\\<in>Pi\\<^sub>E (insert x F) S.\n                            \\<Prod>i\\<in>insert x F. f (xa i) i) =\n                         (\\<Prod>i\\<in>insert x F. \\<Sum>s\\<in>S i. f s i)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n     \\<Prod>i\\<in>insert i I. f (x i) i) =\n  (\\<Sum>a\\<in>S i.\n     f a i * (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n     \\<Prod>i\\<in>insert i I. f (x i) i) =\n  (\\<Sum>a\\<in>S i.\n     f a i * (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n       \\<Prod>i\\<in>insert i I. f (x i) i) =\n    (\\<Prod>i\\<in>insert i I. \\<Sum>s\\<in>S i. f s i)", "using insert"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n     \\<Prod>i\\<in>insert i I. f (x i) i) =\n  (\\<Sum>a\\<in>S i.\n     f a i * (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i))\n  finite I\n  i \\<notin> I\n  (\\<And>i. i \\<in> I \\<Longrightarrow> finite (S i)) \\<Longrightarrow>\n  (\\<Sum>x\\<in>Pi\\<^sub>E I S. \\<Prod>i\\<in>I. f (x i) i) =\n  (\\<Prod>i\\<in>I. \\<Sum>s\\<in>S i. f s i)\n  ?i \\<in> insert i I \\<Longrightarrow> finite (S ?i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n       \\<Prod>i\\<in>insert i I. f (x i) i) =\n    (\\<Prod>i\\<in>insert i I. \\<Sum>s\\<in>S i. f s i)", "by (simp add: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Pi\\<^sub>E (insert i I) S.\n     \\<Prod>i\\<in>insert i I. f (x i) i) =\n  (\\<Prod>i\\<in>insert i I. \\<Sum>s\\<in>S i. f s i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition of the Gossip-Broadcast\\<close>"], ["", "datatype state = listening | sending | sleeping"], ["", "type_synonym sys_state = \"(nat \\<times> nat) \\<Rightarrow> state\""], ["", "lemma state_UNIV: \"UNIV = {listening, sending, sleeping}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {listening, sending, sleeping}", "by (auto intro: state.exhaust)"], ["", "locale gossip_broadcast =\n  fixes size :: nat and p :: real\n  assumes size: \"0 < size\"\n  assumes p: \"0 < p\" \"p < 1\"\nbegin"], ["", "interpretation pmf_as_function"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition states :: \"sys_state set\" where\n  \"states = ({..< size} \\<times> {..< size}) \\<rightarrow>\\<^sub>E {listening, sending, sleeping}\""], ["", "definition start :: sys_state where\n  \"start = (\\<lambda>x\\<in>{..< size}\\<times>{..< size}. listening)((0, 0) := sending)\""], ["", "definition neighbour_sending where\n  \"neighbour_sending s = (\\<lambda>(x,y).\n    (x > 0 \\<and> s (x - 1, y) = sending) \\<or>\n    (x < size \\<and> s (x + 1, y) = sending) \\<or>\n    (y > 0 \\<and> s (x, y - 1) = sending) \\<or>\n    (y < size \\<and> s (x, y + 1) = sending))\""], ["", "definition node_trans :: \"sys_state \\<Rightarrow> (nat \\<times> nat) \\<Rightarrow> state \\<Rightarrow> state \\<Rightarrow> real\" where\n\"node_trans g x s = (case s of\n  listening \\<Rightarrow> (if neighbour_sending g x\n    then (\\<lambda>_.0) (sending := p, sleeping := 1 - p)\n    else (\\<lambda>_.0) (listening := 1))\n| sending   \\<Rightarrow> (\\<lambda>_.0) (sleeping := 1)\n| sleeping  \\<Rightarrow> (\\<lambda>_.0) (sleeping := 1))\""], ["", "lemma node_trans_sum_eq_1[simp]:\n  \"node_trans g x s' listening + (node_trans g x s' sending + node_trans g x s' sleeping) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_trans g x s' listening +\n    (node_trans g x s' sending + node_trans g x s' sleeping) =\n    1", "by (simp add: node_trans_def split: state.split)"], ["", "lemma node_trans_nonneg[simp]: \"0 \\<le> node_trans s x i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> node_trans s x i j", "using p"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> node_trans s x i j", "by (auto simp: node_trans_def split: state.split)"], ["", "lift_definition proto_trans :: \"sys_state \\<Rightarrow> sys_state pmf\" is\n  \"\\<lambda>s s'. if s' \\<in> states then (\\<Prod>x\\<in>{..< size}\\<times>{..< size}. node_trans s x (s x) (s' x)) else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun.\n       (\\<forall>x.\n           0 \\<le> (if x \\<in> states\n                    then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                           node_trans fun xa (fun xa) (x xa)\n                    else 0)) \\<and>\n       \\<integral>\\<^sup>+ x. ennreal\n                               (if x \\<in> states\n                                then \\<Prod>xa\n      \\<in>{..<size} \\<times> {..<size}.\n node_trans fun xa (fun xa) (x xa)\n                                else 0)\n                          \\<partial>count_space UNIV =\n       1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun.\n       \\<forall>x.\n          0 \\<le> (if x \\<in> states\n                   then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                          node_trans fun xa (fun xa) (x xa)\n                   else 0)\n 2. \\<And>fun.\n       \\<integral>\\<^sup>+ x. ennreal\n                               (if x \\<in> states\n                                then \\<Prod>xa\n      \\<in>{..<size} \\<times> {..<size}.\n node_trans fun xa (fun xa) (x xa)\n                                else 0)\n                          \\<partial>count_space UNIV =\n       1", "let ?f = \"\\<lambda>s s'. if s' \\<in> states then (\\<Prod>x\\<in>{..< size}\\<times>{..< size}. node_trans s x (s x) (s' x)) else 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun.\n       \\<forall>x.\n          0 \\<le> (if x \\<in> states\n                   then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                          node_trans fun xa (fun xa) (x xa)\n                   else 0)\n 2. \\<And>fun.\n       \\<integral>\\<^sup>+ x. ennreal\n                               (if x \\<in> states\n                                then \\<Prod>xa\n      \\<in>{..<size} \\<times> {..<size}.\n node_trans fun xa (fun xa) (x xa)\n                                else 0)\n                          \\<partial>count_space UNIV =\n       1", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>fun.\n       \\<forall>x.\n          0 \\<le> (if x \\<in> states\n                   then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                          node_trans fun xa (fun xa) (x xa)\n                   else 0)\n 2. \\<And>fun.\n       \\<integral>\\<^sup>+ x. ennreal\n                               (if x \\<in> states\n                                then \\<Prod>xa\n      \\<in>{..<size} \\<times> {..<size}.\n node_trans fun xa (fun xa) (x xa)\n                                else 0)\n                          \\<partial>count_space UNIV =\n       1", "show \"\\<forall>t. 0 \\<le> ?f s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 \\<le> (if t \\<in> states\n                then \\<Prod>x\\<in>{..<size} \\<times> {..<size}.\n                       node_trans s x (s x) (t x)\n                else 0)", "using p"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       0 \\<le> (if t \\<in> states\n                then \\<Prod>x\\<in>{..<size} \\<times> {..<size}.\n                       node_trans s x (s x) (t x)\n                else 0)", "by (auto intro!: prod_nonneg simp: node_trans_def split: state.split)"], ["proof (state)\nthis:\n  \\<forall>t.\n     0 \\<le> (if t \\<in> states\n              then \\<Prod>x\\<in>{..<size} \\<times> {..<size}.\n                     node_trans s x (s x) (t x)\n              else 0)\n\ngoal (1 subgoal):\n 1. \\<And>fun.\n       \\<integral>\\<^sup>+ x. ennreal\n                               (if x \\<in> states\n                                then \\<Prod>xa\n      \\<in>{..<size} \\<times> {..<size}.\n node_trans fun xa (fun xa) (x xa)\n                                else 0)\n                          \\<partial>count_space UNIV =\n       1", "show \"(\\<integral>\\<^sup>+t. ?f s t \\<partial>count_space UNIV) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (if x \\<in> states\n                             then \\<Prod>xa\n   \\<in>{..<size} \\<times> {..<size}.\n                                    node_trans s xa (s xa) (x xa)\n                             else 0)\n                       \\<partial>count_space UNIV =\n    1", "apply (subst nn_integral_count_space'[of states])"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite states\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> UNIV; x \\<notin> states\\<rbrakk>\n       \\<Longrightarrow> ennreal\n                          (if x \\<in> states\n                           then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                                  node_trans s xa (s xa) (x xa)\n                           else 0) =\n                         0\n 3. states \\<subseteq> UNIV\n 4. (\\<Sum>x\\<in>states.\n       ennreal\n        (if x \\<in> states\n         then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                node_trans s xa (s xa) (x xa)\n         else 0)) =\n    1", "apply (simp_all add: prod_nonneg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite states\n 2. (\\<Sum>x\\<in>states.\n       \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n         node_trans s xa (s xa) (x xa)) =\n    1", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite states\n 2. (\\<Sum>x\\<in>states.\n       \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n         node_trans s xa (s xa) (x xa)) =\n    1", "show \"(\\<Sum>x\\<in>states. \\<Prod>xa\\<in>{..<size} \\<times> {..<size}. node_trans s xa (s xa) (x xa)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>states.\n       \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n         node_trans s xa (s xa) (x xa)) =\n    1", "unfolding states_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>{..<size} \\<times> {..<size} \\<rightarrow>\\<^sub>E\n                 {listening, sending, sleeping}.\n       \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n         node_trans s xa (s xa) (x xa)) =\n    1", "by (subst sum_folded_product) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>states.\n     \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n       node_trans s xa (s xa) (x xa)) =\n  1\n\ngoal (1 subgoal):\n 1. finite states", "show \"finite states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite states", "by (auto simp: states_def intro!: finite_PiE)"], ["proof (state)\nthis:\n  finite states\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (if x \\<in> states\n                           then \\<Prod>xa\\<in>{..<size} \\<times> {..<size}.\n                                  node_trans s xa (s xa) (x xa)\n                           else 0)\n                     \\<partial>count_space UNIV =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The Gossip-Broadcast forms a DTMC\\<close>"], ["", "sublocale gossip_broadcast \\<subseteq> MC_syntax proto_trans"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"]]}