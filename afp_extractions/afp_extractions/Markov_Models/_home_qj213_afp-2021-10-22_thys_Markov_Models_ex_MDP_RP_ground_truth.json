{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/MDP_RP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma INF_Union_eq: \"(INF x\\<in>\\<Union>A. f x) = (INF a\\<in>A. INF x\\<in>a. f x)\" for f :: \"_ \\<Rightarrow> 'a::complete_lattice\"", "lemma lift_option_eq_None: \"lift_option f A B = None \\<longleftrightarrow> (A \\<noteq> None \\<longrightarrow> B = None)\"", "lemma lift_option_eq_Some: \"lift_option f A B = Some y \\<longleftrightarrow> (\\<exists>a b. A = Some a \\<and> B = Some b \\<and> y = f a b)\"", "lemma ord_option_Some1_iff: \"ord_option R (Some a) y \\<longleftrightarrow> (\\<exists>b. y = Some b \\<and> R a b)\"", "lemma ord_option_Some2_iff: \"ord_option R x (Some b) \\<longleftrightarrow> (\\<forall>a. x = Some a \\<longrightarrow> R a b)\"", "lemma sym_Restr: \"sym A \\<Longrightarrow> sym (Restr A S)\"", "lemma trans_Restr: \"trans A \\<Longrightarrow> trans (Restr A S)\"", "lemma image_eq_singleton_iff: \"inj_on f S \\<Longrightarrow> f ` S = {y} \\<longleftrightarrow> (\\<exists>x. S = {x} \\<and> y = f x)\"", "lemma quotient_eq_singleton: \"equiv A r \\<Longrightarrow> A // r = {B} \\<Longrightarrow> B = A\"", "lemma UN_singleton_image: \"(\\<Union>x\\<in>A. {f x}) = f ` A\"", "lemma image_eq_singeltonD: \"f ` A = {x} \\<Longrightarrow> \\<forall>a\\<in>A. f a = x\"", "lemma fun_ord_refl: \"reflp ord  \\<Longrightarrow> reflp (fun_ord ord)\"", "lemma fun_ord_trans: \"transp ord  \\<Longrightarrow> transp (fun_ord ord)\"", "lemma fun_ord_antisym: \"antisymp ord  \\<Longrightarrow> antisymp (fun_ord ord)\"", "lemma fun_ord_combine:\n  \"fun_ord ord a b \\<Longrightarrow> fun_ord ord c d \\<Longrightarrow> (\\<And>s. ord (a s) (b s) \\<Longrightarrow> ord (c s) (d s) \\<Longrightarrow> ord (e s) (f s)) \\<Longrightarrow> fun_ord ord e f\"", "lemma not_all_eq: \"~ (\\<forall>y. x \\<noteq> y)\"", "lemma ball_vimage_iff: \"(\\<forall>x\\<in>f -` X. P x) \\<longleftrightarrow> (\\<forall>x. f x \\<in> X \\<longrightarrow> P x)\"", "lemma UN_If_cases: \"(\\<Union>x\\<in>X. if P x then A x else B x) = (\\<Union>x\\<in>{x\\<in>X. P x}. A x) \\<union> (\\<Union>x\\<in>{x\\<in>X. \\<not> P x}. B x)\"", "lemma (in Reachability_Problem) n_eq_0_closed:\n  assumes s: \"s \\<in> S'\" and S': \"S' \\<subseteq> S\" \"S' \\<inter> S2 = {}\" and closed: \"\\<And>s. s \\<in> S' \\<Longrightarrow> \\<exists>D\\<in>K s. D \\<subseteq> S'\"\n  shows \"n s = 0\"", "lemma (in Reachability_Problem) n_lb_ennreal:\n  fixes x\n  assumes \"s \\<in> S\"\n  assumes solution: \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> x s \\<le> (\\<Sum>t\\<in>S. ennreal (pmf D t) * x t)\"\n  assumes solution_n0: \"\\<And>s. s \\<in> S \\<Longrightarrow> n s = 0 \\<Longrightarrow> x s = 0\"\n  assumes solution_S2: \"\\<And>s. s \\<in> S2 \\<Longrightarrow> x s = 1\"\n    and le_1:  \"\\<And>s. s \\<in> S \\<Longrightarrow> x s \\<le> 1\"\n  shows \"x s \\<le> n s\" (is \"_ \\<le> ?y s\")", "lemma in_states: \"actions \\<phi> s \\<noteq> {} \\<Longrightarrow> s \\<in> states \\<phi>\"", "lemma mdpc_eqI: \"states \\<phi> = states \\<psi> \\<Longrightarrow> (\\<And>s. s \\<in> states \\<phi> \\<Longrightarrow> actions \\<phi> s = actions \\<psi> s) \\<Longrightarrow> \\<phi> = \\<psi>\"", "lemma states_map_mdpc: \"states (map_mdpc f M) = f ` (states M)\"", "lemma actions_map_mdpc_eq_Collect: \"actions (map_mdpc f M) s = {map_pmf f d | d t. f t = s \\<and> d \\<in> actions M t}\"", "lemma actions_map_mdpc: \"actions (map_mdpc f M) s = map_pmf f ` (\\<Union>t\\<in>f -` {s}. actions M t)\"", "lemma map_mdpc_compose: \"map_mdpc f (map_mdpc g M) = map_mdpc (f \\<circ> g) M\"", "lemma map_mdpc_id: \"map_mdpc id = id\"", "lemma finite_states_map: \"finite (states M) \\<Longrightarrow> finite (map_mdpc f M)\"", "lemma finite_actions_map:\n  assumes \"finite (states M)\" \"\\<And>s. finite (actions M s)\" shows \"finite (actions (map_mdpc f M) s)\"", "lemma states_fix_loop[simp]: \"states (fix_loop s M) = insert s (states M)\"", "lemma actions_fix_loop[simp]: \"actions (fix_loop s M) t = (if s = t then {return_pmf s} else actions M t)\"", "lemma fix_loop_idem: \"fix_loop s (fix_loop s M) = fix_loop s M\"", "lemma fix_loop_commute: \"fix_loop s (fix_loop t M) = fix_loop t (fix_loop s M)\"", "lemma map_fix_loop:\n  assumes f_s: \"\\<And>t. f s = f t \\<Longrightarrow> t = s\"\n  shows \"map_mdpc f (fix_loop s M) = fix_loop (f s) (map_mdpc f M)\"", "lemma state_map_actions[simp]: \"states (map_actions f \\<phi>) = states \\<phi>\"", "lemma actions_map_actions[simp]: \"(s \\<notin> states \\<phi> \\<Longrightarrow> f s {} = {}) \\<Longrightarrow> actions (map_actions f \\<phi>) s = f s (actions \\<phi> s)\"", "lemma state_restrict_states[simp]: \"states (restrict_states S \\<phi>) = states \\<phi> \\<inter> S\"", "lemma actions_restrict_states[simp]: \"actions (restrict_states S \\<phi>) s = (if s \\<in> S then actions \\<phi> s else {})\"", "lemma restrict_states_idem: \"states \\<phi> \\<subseteq> A \\<Longrightarrow> restrict_states A \\<phi> = \\<phi>\"", "lemma states_sup[simp]: \"states (\\<phi> \\<squnion> \\<psi>) = states \\<phi> \\<union> states \\<psi>\"", "lemma states_SUP[simp]: \"states (\\<Squnion>A) = (\\<Union>a\\<in>A. states a)\"", "lemma states_inf[simp]: \"states (\\<phi> \\<sqinter> \\<psi>) = states \\<phi> \\<inter> states \\<psi>\"", "lemma states_mono: \"\\<phi> \\<le> \\<psi> \\<Longrightarrow> states \\<phi> \\<subseteq> states \\<psi>\"", "lemma actions_sup[simp]: \"actions (\\<phi> \\<squnion> \\<psi>) = actions \\<phi> \\<squnion> actions \\<psi>\"", "lemma actions_SUP[simp]: \"actions (\\<Squnion>A) s = (\\<Union>a\\<in>A. actions a s)\"", "lemma actions_inf[simp]: \"actions (\\<phi> \\<sqinter> \\<psi>) = actions \\<phi> \\<sqinter> actions \\<psi>\"", "lemma actions_mono: assumes *: \"\\<phi> \\<le> \\<psi>\" shows \"actions \\<phi> \\<le> actions \\<psi>\"", "lemma le_mdpcI: \"states M \\<subseteq> states N \\<Longrightarrow> (\\<And>s. s \\<in> states M \\<Longrightarrow> actions M s \\<subseteq> actions N s) \\<Longrightarrow> M \\<le> N\"", "lemma le_mdpc_iff: \"M \\<le> N \\<longleftrightarrow> states M \\<subseteq> states N \\<and> (\\<forall>s. actions M s \\<subseteq> actions N s)\"", "lemma map_actions_le: \"(\\<And>s A. s \\<in> states \\<phi> \\<Longrightarrow> f s A \\<subseteq> A) \\<Longrightarrow> map_actions f \\<phi> \\<le> \\<phi>\"", "lemma restrict_states_mono: \"A \\<subseteq> B \\<Longrightarrow> \\<phi> \\<le> \\<psi> \\<Longrightarrow> restrict_states A \\<phi> \\<le> restrict_states B \\<psi>\"", "lemma restrict_states_le: \"restrict_states A M \\<le> M\"", "lemma eq_bot_iff_states: \"\\<phi> = bot \\<longleftrightarrow> states \\<phi> = {}\"", "lemma fix_loop_neq_bot: \"fix_loop s N \\<noteq> bot\"", "lemma\n  shows states_bot[simp]: \"states bot = {}\"\n    and actions_bot[simp]: \"actions bot = (\\<lambda>s. {})\"", "lemma inf_eq_bot_eq_disjnt_states: \"A \\<sqinter> B = bot \\<longleftrightarrow> disjnt (states A) (states B)\"", "lemma en_sup[simp]: \"en (\\<phi> \\<squnion> \\<psi>) = en \\<phi> \\<union> en \\<psi>\"", "lemma en_SUP[simp]: \"en (Sup A) = (\\<Union>a\\<in>A. en a)\"", "lemma en_mono: \"\\<phi> \\<le> \\<psi> \\<Longrightarrow> en \\<phi> \\<subseteq> en \\<psi>\"", "lemma en_states: \"(s, t) \\<in> en M \\<Longrightarrow> s \\<in> states M\"", "lemma en_bot[simp]: \"en bot = {}\"", "lemma en_fix_loop[simp]: \"en (fix_loop s M) = insert (s, s) (en M - {s} \\<times> UNIV)\"", "lemma states_trivial[simp]: \"states (trivial s) = {s}\"", "lemma actions_trivial[simp]: \"actions (trivial s) = (\\<lambda>_. {})\"", "lemma en_trivial[simp]: \"en (trivial s) = {}\"", "lemma trivial_le_iff: \"trivial x \\<le> \\<phi> \\<longleftrightarrow> x \\<in> states \\<phi>\"", "lemma trivial_le: \"x \\<in> states \\<phi> \\<Longrightarrow> trivial x \\<le> \\<phi>\"", "lemma trivial_neq_bot: \"trivial x \\<noteq> bot\"", "lemma states_loop[simp]: \"states (loop s) = {s}\"", "lemma actions_loop: \"actions (loop s) = ((\\<lambda>_. {})(s := {return_pmf s}))\"", "lemma\n  shows actions_loop_self[simp]: \"actions (loop s) s = {return_pmf s}\"\n    and actions_loop_neq[simp]: \"s \\<noteq> t \\<Longrightarrow> actions (loop s) t = {}\"", "lemma en_loop[simp]: \"en (loop s) = {(s, s)}\"", "lemma loop_neq_bot: \"loop s \\<noteq> bot\"", "lemma loop_le: \"loop x \\<le> M \\<longleftrightarrow> (x \\<in> states M \\<and> return_pmf x \\<in> actions M x)\"", "lemma le_loop: \"M \\<le> loop x \\<longleftrightarrow> (states M \\<subseteq> {x} \\<and> actions M x \\<subseteq> {return_pmf x})\"", "lemma scD: \"sc \\<phi> \\<Longrightarrow> x \\<in> states \\<phi> \\<Longrightarrow> y \\<in> states \\<phi> \\<Longrightarrow> (x, y) \\<in> (en \\<phi>)\\<^sup>*\"", "lemma scI: \"(\\<And>x y. x \\<in> states \\<phi> \\<Longrightarrow> y \\<in> states \\<phi> \\<Longrightarrow> (x, y) \\<in> (en \\<phi>)\\<^sup>*) \\<Longrightarrow> sc \\<phi>\"", "lemma sc_trivial[simp]: \"sc (trivial s)\"", "lemma sc_loop[simp]: \"sc (loop s)\"", "lemma sc_bot[simp]: \"sc bot\"", "lemma sc_SupI_directed:\n  assumes A: \"\\<And>a. a \\<in> A \\<Longrightarrow> sc a\"\n    and directed: \"\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> A \\<Longrightarrow> \\<exists>c\\<in>A. a \\<le> c \\<and> b \\<le> c\"\n  shows \"sc (Sup A)\"", "lemma sc_supI:\n  assumes \\<phi>: \"sc \\<phi>\" and \\<psi>: \"sc \\<psi>\" and not_disjoint: \"\\<phi> \\<sqinter> \\<psi> \\<noteq> bot\"\n  shows \"sc (\\<phi> \\<squnion> \\<psi>)\"", "lemma sc_eq_loop:\n  assumes M: \"sc M\" and s: \"s \\<in> M\" \"actions M s = {return_pmf s}\" shows \"M = loop s\"", "lemma sc_eq_trivial:\n  assumes M: \"sc M\" and s: \"s \\<in> M\" \"actions M s = {}\" shows \"M = trivial s\"", "lemma closed_mdpcD: \"closed_mdpc \\<phi> \\<Longrightarrow> D \\<in> actions \\<phi> x \\<Longrightarrow> y \\<in> D \\<Longrightarrow> y \\<in> states \\<phi>\"", "lemma closed_mdpc_supI: \"closed_mdpc \\<phi> \\<Longrightarrow> closed_mdpc \\<psi> \\<Longrightarrow> closed_mdpc (\\<phi> \\<squnion> \\<psi>)\"", "lemma closed_mdpc_SupI: \"(\\<And>a. a \\<in> A \\<Longrightarrow> closed_mdpc a) \\<Longrightarrow> closed_mdpc (\\<Squnion>A)\"", "lemma closed_mdpc_infI: \"closed_mdpc \\<phi> \\<Longrightarrow> closed_mdpc \\<psi> \\<Longrightarrow> closed_mdpc (\\<phi> \\<sqinter> \\<psi>)\"", "lemma closed_mdpc_trivial[simp]: \"closed_mdpc (trivial s)\"", "lemma closed_mdpc_bot[simp]: \"closed_mdpc bot\"", "lemma closed_mdpc_loop[simp]: \"closed_mdpc (loop s)\"", "lemma closed_mdpc_fix_loop: \"closed_mdpc M \\<Longrightarrow> closed_mdpc (fix_loop s M)\"", "lemma closed_mdpc_map: assumes M: \"closed_mdpc M\" shows \"closed_mdpc (map_mdpc f M)\"", "lemma\n  shows states_close[simp]: \"states (close \\<phi>) = states \\<phi>\"\n    and actions_close[simp]: \"actions (close \\<phi>) s = {a\\<in>actions \\<phi> s. a \\<subseteq> states \\<phi>}\"", "lemma closed_close: \"closed_mdpc (close \\<phi>)\"", "lemma close_closed: \"closed_mdpc \\<phi> \\<Longrightarrow> close \\<phi> = \\<phi>\"", "lemma close_close: \"close (close \\<phi>) = close \\<phi>\"", "lemma close_le: \"close M \\<le> M\"", "lemma close_mono: \"\\<phi> \\<le> \\<psi> \\<Longrightarrow> close \\<phi> \\<le> close \\<psi>\"", "lemma ec_trivial[simp]: \"ec (trivial s)\"", "lemma ec_bot[simp]: \"ec bot\"", "lemma ec_loop[simp]: \"ec (loop s)\"", "lemma ec_sup: \"ec \\<phi> \\<Longrightarrow> ec \\<psi> \\<Longrightarrow> \\<phi> \\<sqinter> \\<psi> \\<noteq> bot \\<Longrightarrow> ec (\\<phi> \\<squnion> \\<psi>)\"", "lemma ec_Sup_directed:\n  \"(\\<And>a. a \\<in> A \\<Longrightarrow> ec a) \\<Longrightarrow> (\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> A \\<Longrightarrow> \\<exists>c\\<in>A. a \\<le> c \\<and> b \\<le> c) \\<Longrightarrow> ec (\\<Squnion>A)\"", "lemma mec_refl: \"ec M \\<Longrightarrow> mec M M\"", "lemma mec_le: \"mec M \\<phi> \\<Longrightarrow> \\<phi> \\<le> M\"", "lemma mec_ec: \"mec M \\<phi> \\<Longrightarrow> ec \\<phi>\"", "lemma mec_least: \"mec M \\<phi> \\<Longrightarrow> \\<psi> \\<le> M \\<Longrightarrow> \\<phi> \\<le> \\<psi> \\<Longrightarrow> ec \\<psi> \\<Longrightarrow> \\<phi> \\<ge> \\<psi>\"", "lemma mec_bot_imp_bot: assumes \"mec \\<phi> bot\" shows \"\\<phi> = bot\"", "lemma mec_imp_bot_eq_bot: \"mec \\<phi> \\<psi> \\<Longrightarrow> \\<phi> = bot \\<longleftrightarrow> \\<psi> = bot\"", "lemma mec_unique: assumes \\<phi>: \"mec M \\<phi>\" and \\<psi>: \"mec M \\<psi>\" and \"\\<phi> \\<sqinter> \\<psi> \\<noteq> bot\" shows \"\\<phi> = \\<psi>\"", "lemma mec_exists: assumes \\<phi>: \"\\<phi> \\<noteq> bot\" \"ec \\<phi>\" and M: \"\\<phi> \\<le> M\" shows \"\\<exists>\\<psi>\\<ge>\\<phi>. mec M \\<psi>\"", "lemma mec_exists': \"x \\<in> states M \\<Longrightarrow> \\<exists>\\<psi>. x \\<in> states \\<psi> \\<and> mec M \\<psi>\"", "lemma mec_loop: \"x \\<in> states M \\<Longrightarrow> actions M x = {return_pmf x} \\<Longrightarrow> mec M (loop x)\"", "lemma mec_fix_loop: \"mec (fix_loop s M) (loop s)\"", "lemma trivials_subset_states: \"trivials M \\<subseteq> states M\"", "lemma closed_mdpcD':\n  \"closed_mdpc M \\<Longrightarrow> s \\<in> states M \\<Longrightarrow> (\\<Union>D\\<in>actions' M s. set_pmf D) \\<subseteq> states M\"", "lemma Finite_MDP_map_loop: \"Finite_MDP (map_mdpc f M \\<squnion> loop s)\"", "lemma Finite_MDP_map_fix_loop: \"Finite_MDP (fix_loop s (map_mdpc f M))\"", "lemma finite_F[simp]: \"finite F\"", "lemma r_eq_None[simp]: \"r s = None \\<longleftrightarrow> s \\<in> F\"", "lemma r_eq_Some[simp]: \"r s = Some t \\<longleftrightarrow> (s \\<notin> F \\<and> s = t)\"", "lemma r_in_Some_image: \"r s \\<in> Some ` X \\<longleftrightarrow> (s \\<notin> F \\<and> s \\<in> X)\"", "lemma r_inj: \"s \\<notin> F \\<or> t \\<notin> F \\<Longrightarrow> r s = r t \\<longleftrightarrow> s = t\"", "lemma shows r_F: \"s \\<in> F \\<Longrightarrow> r s = None\" and r_nF: \"s \\<notin> F \\<Longrightarrow> r s = Some s\"", "lemma closed_R: \"closed_mdpc R\"", "lemma states_R[simp]: \"states R = Some ` (states M - F) \\<union> {None}\"", "lemma actions_R_None[simp]:\n  \"actions R None = {return_pmf None}\"", "lemma actions_R_Some[simp]:\n  \"actions R (Some s) = (if s \\<in> F then {} else map_pmf r ` actions M s)\"", "lemma mec_R_loop: \"mec R (loop None)\"", "lemma F_not_trivial: \"s \\<in> F \\<Longrightarrow> Some s \\<notin> trivials R\"", "lemma min_state_eq_Inl: \"min_state s = Inl t \\<longleftrightarrow> (Some t \\<in> trivials R \\<and> s = Some t)\"", "lemma min_state_eq_Inr: \"min_state s = Inr b \\<longleftrightarrow> (if b then s = None else s \\<noteq> None \\<and> s \\<notin> trivials R)\"", "lemma map_min_state_R: \"map_mdpc min_state R = fix_loop (Inr True) (map_mdpc (min_state \\<circ> r) M)\"", "lemma states_min_mdpc: \"states min_mdpc = {Inl t | t. Some t \\<in> trivials R} \\<union> {Inr True, Inr False}\"", "lemma actions_min_mdpc_Inl:\n  \"actions min_mdpc (Inl t) = (if Some t \\<in> trivials R then map_pmf (min_state \\<circ> r) ` actions M t else {})\"", "lemma actions_min_mdpc_Inr: \"actions min_mdpc (Inr b) = {return_pmf (Inr b)}\"", "lemma M_n_eq_0_not_trivials:\n  assumes \"s \\<in> states M\" \"s \\<notin> F\" \"Some s \\<notin> trivials R\"\n  shows \"M.n s = 0\"", "lemma min_state_r_in_min_mdpc[simp]: \"s \\<in> M \\<Longrightarrow> min_state (r s) \\<in> min_mdpc\""], "translations": [["", "lemma INF_Union_eq: \"(INF x\\<in>\\<Union>A. f x) = (INF a\\<in>A. INF x\\<in>a. f x)\" for f :: \"_ \\<Rightarrow> 'a::complete_lattice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter> (f ` \\<Union> A) = (\\<Sqinter>a\\<in>A. \\<Sqinter> (f ` a))", "by (auto intro!: antisym INF_greatest intro: INF_lower2)"], ["", "lemma lift_option_eq_None: \"lift_option f A B = None \\<longleftrightarrow> (A \\<noteq> None \\<longrightarrow> B = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift_option f A B = None) =\n    (A \\<noteq> None \\<longrightarrow> B = None)", "by (cases A; cases B; auto)"], ["", "lemma lift_option_eq_Some: \"lift_option f A B = Some y \\<longleftrightarrow> (\\<exists>a b. A = Some a \\<and> B = Some b \\<and> y = f a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift_option f A B = Some y) =\n    (\\<exists>a b. A = Some a \\<and> B = Some b \\<and> y = f a b)", "by (cases A; cases B; auto)"], ["", "lemma ord_option_Some1_iff: \"ord_option R (Some a) y \\<longleftrightarrow> (\\<exists>b. y = Some b \\<and> R a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_option R (Some a) y = (\\<exists>b. y = Some b \\<and> R a b)", "by (cases y; auto)"], ["", "lemma ord_option_Some2_iff: \"ord_option R x (Some b) \\<longleftrightarrow> (\\<forall>a. x = Some a \\<longrightarrow> R a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_option R x (Some b) =\n    (\\<forall>a. x = Some a \\<longrightarrow> R a b)", "by (cases x; auto)"], ["", "lemma sym_Restr: \"sym A \\<Longrightarrow> sym (Restr A S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym A \\<Longrightarrow> sym (Restr A S)", "by (auto simp: sym_def)"], ["", "lemma trans_Restr: \"trans A \\<Longrightarrow> trans (Restr A S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans A \\<Longrightarrow> trans (Restr A S)", "by (auto simp: trans_def)"], ["", "lemma image_eq_singleton_iff: \"inj_on f S \\<Longrightarrow> f ` S = {y} \\<longleftrightarrow> (\\<exists>x. S = {x} \\<and> y = f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on f S \\<Longrightarrow>\n    (f ` S = {y}) = (\\<exists>x. S = {x} \\<and> y = f x)", "by (auto elim: inj_img_insertE)"], ["", "lemma quotient_eq_singleton: \"equiv A r \\<Longrightarrow> A // r = {B} \\<Longrightarrow> B = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv A r; A // r = {B}\\<rbrakk> \\<Longrightarrow> B = A", "using Union_quotient[of A r]"], ["proof (prove)\nusing this:\n  equiv A r \\<Longrightarrow> \\<Union> (A // r) = A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv A r; A // r = {B}\\<rbrakk> \\<Longrightarrow> B = A", "by auto"], ["", "lemma UN_singleton_image: \"(\\<Union>x\\<in>A. {f x}) = f ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. {f x}) = f ` A", "by auto"], ["", "lemma image_eq_singeltonD: \"f ` A = {x} \\<Longrightarrow> \\<forall>a\\<in>A. f a = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` A = {x} \\<Longrightarrow> \\<forall>a\\<in>A. f a = x", "by auto"], ["", "lemma fun_ord_refl: \"reflp ord  \\<Longrightarrow> reflp (fun_ord ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp ord \\<Longrightarrow> reflp (fun_ord ord)", "by (auto simp: fun_ord_def reflp_def)"], ["", "lemma fun_ord_trans: \"transp ord  \\<Longrightarrow> transp (fun_ord ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp ord \\<Longrightarrow> transp (fun_ord ord)", "by (fastforce simp: fun_ord_def transp_def)"], ["", "lemma fun_ord_antisym: \"antisymp ord  \\<Longrightarrow> antisymp (fun_ord ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymp ord \\<Longrightarrow> antisymp (fun_ord ord)", "by (fastforce simp: fun_ord_def antisymp_def)"], ["", "lemma fun_ord_combine:\n  \"fun_ord ord a b \\<Longrightarrow> fun_ord ord c d \\<Longrightarrow> (\\<And>s. ord (a s) (b s) \\<Longrightarrow> ord (c s) (d s) \\<Longrightarrow> ord (e s) (f s)) \\<Longrightarrow> fun_ord ord e f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fun_ord ord a b; fun_ord ord c d;\n     \\<And>s.\n        \\<lbrakk>ord (a s) (b s); ord (c s) (d s)\\<rbrakk>\n        \\<Longrightarrow> ord (e s) (f s)\\<rbrakk>\n    \\<Longrightarrow> fun_ord ord e f", "by (auto simp: fun_ord_def)"], ["", "lemma not_all_eq: \"~ (\\<forall>y. x \\<noteq> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>y. x \\<noteq> y)", "by auto"], ["", "lemma ball_vimage_iff: \"(\\<forall>x\\<in>f -` X. P x) \\<longleftrightarrow> (\\<forall>x. f x \\<in> X \\<longrightarrow> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>f -` X. P x) =\n    (\\<forall>x. f x \\<in> X \\<longrightarrow> P x)", "by auto"], ["", "lemma UN_If_cases: \"(\\<Union>x\\<in>X. if P x then A x else B x) = (\\<Union>x\\<in>{x\\<in>X. P x}. A x) \\<union> (\\<Union>x\\<in>{x\\<in>X. \\<not> P x}. B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>X. if P x then A x else B x) =\n    \\<Union> (A ` {x \\<in> X. P x}) \\<union>\n    \\<Union> (B ` {x \\<in> X. \\<not> P x})", "by (auto split: if_splits)"], ["", "lemma (in Reachability_Problem) n_eq_0_closed:\n  assumes s: \"s \\<in> S'\" and S': \"S' \\<subseteq> S\" \"S' \\<inter> S2 = {}\" and closed: \"\\<And>s. s \\<in> S' \\<Longrightarrow> \\<exists>D\\<in>K s. D \\<subseteq> S'\"\n  shows \"n s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n s = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n s = 0", "from closed"], ["proof (chain)\npicking this:\n  ?s1 \\<in> S' \\<Longrightarrow>\n  \\<exists>x\\<in>K ?s1. set_pmf x \\<subseteq> S'", "obtain ct where ct: \"\\<And>s. s \\<in> S' \\<Longrightarrow> ct s \\<in> K s\" \"\\<And>s. s \\<in> S' \\<Longrightarrow> ct s \\<subseteq> S'\""], ["proof (prove)\nusing this:\n  ?s1 \\<in> S' \\<Longrightarrow>\n  \\<exists>x\\<in>K ?s1. set_pmf x \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. (\\<And>ct.\n        \\<lbrakk>\\<And>s. s \\<in> S' \\<Longrightarrow> ct s \\<in> K s;\n         \\<And>s.\n            s \\<in> S' \\<Longrightarrow>\n            set_pmf (ct s) \\<subseteq> S'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?s1 \\<in> S' \\<Longrightarrow> ct ?s1 \\<in> K ?s1\n  ?s1 \\<in> S' \\<Longrightarrow> set_pmf (ct ?s1) \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. n s = 0", "define cfg where \"cfg = memoryless_on (\\<lambda>s. if s \\<in> S' then ct s else arb_act s)\""], ["proof (state)\nthis:\n  cfg = memoryless_on (\\<lambda>s. if s \\<in> S' then ct s else arb_act s)\n\ngoal (1 subgoal):\n 1. n s = 0", "have cfg_on: \"cfg s \\<in> cfg_on s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. cfg s \\<in> cfg_on s", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. memoryless_on (\\<lambda>s. if s \\<in> S' then ct s else arb_act s) s\n    \\<in> cfg_on s", "using ct"], ["proof (prove)\nusing this:\n  ?s1 \\<in> S' \\<Longrightarrow> ct ?s1 \\<in> K ?s1\n  ?s1 \\<in> S' \\<Longrightarrow> set_pmf (ct ?s1) \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. memoryless_on (\\<lambda>s. if s \\<in> S' then ct s else arb_act s) s\n    \\<in> cfg_on s", "by (intro memoryless_on_cfg_onI) auto"], ["proof (state)\nthis:\n  cfg ?s1 \\<in> cfg_on ?s1\n\ngoal (1 subgoal):\n 1. n s = 0", "have state_cfg[simp]: \"state (cfg s) = s\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. state (cfg s) = s", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. state\n     (memoryless_on (\\<lambda>s. if s \\<in> S' then ct s else arb_act s)\n       s) =\n    s", "by (intro state_memoryless_on)"], ["proof (state)\nthis:\n  state (cfg ?s1) = ?s1\n\ngoal (1 subgoal):\n 1. n s = 0", "have action_cfg[simp]: \"action (cfg s) = (if s \\<in> S' then ct s else arb_act s)\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. action (cfg s) = (if s \\<in> S' then ct s else arb_act s)", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. action\n     (memoryless_on (\\<lambda>s. if s \\<in> S' then ct s else arb_act s)\n       s) =\n    (if s \\<in> S' then ct s else arb_act s)", "by (intro action_memoryless_on)"], ["proof (state)\nthis:\n  action (cfg ?s1) = (if ?s1 \\<in> S' then ct ?s1 else arb_act ?s1)\n\ngoal (1 subgoal):\n 1. n s = 0", "have cont_cfg[simp]: \"s \\<in> S' \\<Longrightarrow> t \\<in> ct s \\<Longrightarrow> cont (cfg s) t = cfg t\" for s t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S'; t \\<in> set_pmf (ct s)\\<rbrakk>\n    \\<Longrightarrow> Markov_Decision_Process.cont (cfg s) t = cfg t", "unfolding cfg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S'; t \\<in> set_pmf (ct s)\\<rbrakk>\n    \\<Longrightarrow> Markov_Decision_Process.cont\n                       (memoryless_on\n                         (\\<lambda>s.\n                             if s \\<in> S' then ct s else arb_act s)\n                         s)\n                       t =\n                      memoryless_on\n                       (\\<lambda>s. if s \\<in> S' then ct s else arb_act s)\n                       t", "by (intro cont_memoryless_on) auto"], ["proof (state)\nthis:\n  \\<lbrakk>?s1 \\<in> S'; ?t1 \\<in> set_pmf (ct ?s1)\\<rbrakk>\n  \\<Longrightarrow> Markov_Decision_Process.cont (cfg ?s1) ?t1 = cfg ?t1\n\ngoal (1 subgoal):\n 1. n s = 0", "from s"], ["proof (chain)\npicking this:\n  s \\<in> S'", "have \"v (cfg s) = 0\""], ["proof (prove)\nusing this:\n  s \\<in> S'\n\ngoal (1 subgoal):\n 1. v (cfg s) = 0", "proof (coinduction arbitrary: s rule: v_eq_0_coinduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> cfga \\<in> valid_cfg\n 2. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> state cfga \\<notin> S2\n 3. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "case (valid cfg')"], ["proof (state)\nthis:\n  s \\<in> S'\n  \\<exists>s. cfg' = cfg s \\<and> s \\<in> S'\n\ngoal (3 subgoals):\n 1. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> cfga \\<in> valid_cfg\n 2. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> state cfga \\<notin> S2\n 3. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "with cfg_on s S'"], ["proof (chain)\npicking this:\n  cfg ?s1 \\<in> cfg_on ?s1\n  s \\<in> S'\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n  s \\<in> S'\n  \\<exists>s. cfg' = cfg s \\<and> s \\<in> S'", "show ?case"], ["proof (prove)\nusing this:\n  cfg ?s1 \\<in> cfg_on ?s1\n  s \\<in> S'\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n  s \\<in> S'\n  \\<exists>s. cfg' = cfg s \\<and> s \\<in> S'\n\ngoal (1 subgoal):\n 1. cfg' \\<in> valid_cfg", "by (auto simp: valid_cfg_def)"], ["proof (state)\nthis:\n  cfg' \\<in> valid_cfg\n\ngoal (2 subgoals):\n 1. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> state cfga \\<notin> S2\n 2. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> state cfga \\<notin> S2\n 2. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "case (nS2 cfg')"], ["proof (state)\nthis:\n  s \\<in> S'\n  \\<exists>s. cfg' = cfg s \\<and> s \\<in> S'\n\ngoal (2 subgoals):\n 1. \\<And>cfga.\n       \\<lbrakk>s \\<in> S';\n        \\<exists>s. cfga = cfg s \\<and> s \\<in> S'\\<rbrakk>\n       \\<Longrightarrow> state cfga \\<notin> S2\n 2. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "with S'"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n  s \\<in> S'\n  \\<exists>s. cfg' = cfg s \\<and> s \\<in> S'", "show ?case"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n  s \\<in> S'\n  \\<exists>s. cfg' = cfg s \\<and> s \\<in> S'\n\ngoal (1 subgoal):\n 1. state cfg' \\<notin> S2", "by auto"], ["proof (state)\nthis:\n  state cfg' \\<notin> S2\n\ngoal (1 subgoal):\n 1. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "case (cont cfg')"], ["proof (state)\nthis:\n  s \\<in> S'\n  state (cfg s) \\<in> S1\n  cfg' \\<in> set_pmf (K_cfg (cfg s))\n\ngoal (1 subgoal):\n 1. \\<And>cfg' s.\n       \\<lbrakk>s \\<in> S'; state (cfg s) \\<in> S1;\n        cfg' \\<in> set_pmf (K_cfg (cfg s))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or>\n                         v cfg' = 0", "with S' ct"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n  ?s1 \\<in> S' \\<Longrightarrow> ct ?s1 \\<in> K ?s1\n  ?s1 \\<in> S' \\<Longrightarrow> set_pmf (ct ?s1) \\<subseteq> S'\n  s \\<in> S'\n  state (cfg s) \\<in> S1\n  cfg' \\<in> set_pmf (K_cfg (cfg s))", "show ?case"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n  ?s1 \\<in> S' \\<Longrightarrow> ct ?s1 \\<in> K ?s1\n  ?s1 \\<in> S' \\<Longrightarrow> set_pmf (ct ?s1) \\<subseteq> S'\n  s \\<in> S'\n  state (cfg s) \\<in> S1\n  cfg' \\<in> set_pmf (K_cfg (cfg s))\n\ngoal (1 subgoal):\n 1. (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or> v cfg' = 0", "by (force simp: set_K_cfg)"], ["proof (state)\nthis:\n  (\\<exists>s. cfg' = cfg s \\<and> s \\<in> S') \\<or> v cfg' = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v (cfg s) = 0\n\ngoal (1 subgoal):\n 1. n s = 0", "show \"n s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n s = 0", "proof (rule n_eq_0)"], ["proof (state)\ngoal (3 subgoals):\n 1. s \\<in> S\n 2. ?cfg \\<in> cfg_on s\n 3. v ?cfg = 0", "show \"s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S", "using s S'"], ["proof (prove)\nusing this:\n  s \\<in> S'\n  S' \\<subseteq> S\n  S' \\<inter> S2 = {}\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. ?cfg \\<in> cfg_on s\n 2. v ?cfg = 0", "qed fact+"], ["proof (state)\nthis:\n  n s = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Reachability_Problem) n_lb_ennreal:\n  fixes x\n  assumes \"s \\<in> S\"\n  assumes solution: \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> x s \\<le> (\\<Sum>t\\<in>S. ennreal (pmf D t) * x t)\"\n  assumes solution_n0: \"\\<And>s. s \\<in> S \\<Longrightarrow> n s = 0 \\<Longrightarrow> x s = 0\"\n  assumes solution_S2: \"\\<And>s. s \\<in> S2 \\<Longrightarrow> x s = 1\"\n    and le_1:  \"\\<And>s. s \\<in> S \\<Longrightarrow> x s \\<le> 1\"\n  shows \"x s \\<le> n s\" (is \"_ \\<le> ?y s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. x s \\<le> n s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x s \\<le> n s", "have x_less_top[simp]: \"s \\<in> S \\<Longrightarrow> x s < top\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> x s < \\<top>", "using le_1[of s]"], ["proof (prove)\nusing this:\n  s \\<in> S \\<Longrightarrow> x s \\<le> 1\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> x s < \\<top>", "by (auto simp: less_top[symmetric] top_unique)"], ["proof (state)\nthis:\n  ?s1 \\<in> S \\<Longrightarrow> x ?s1 < \\<top>\n\ngoal (1 subgoal):\n 1. x s \\<le> n s", "have \"enn2real (x s) \\<le> enn2real (n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (x s) \\<le> enn2real (n s)", "apply (rule n_lb[OF \\<open>s\\<in>S\\<close>])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> enn2real (x s)\n                         \\<le> (\\<Sum>t\\<in>S. pmf D t * enn2real (x t))\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; n s = 0\\<rbrakk>\n       \\<Longrightarrow> enn2real (x s) = 0\n 3. \\<And>s. s \\<in> S2 \\<Longrightarrow> enn2real (x s) = 1", "subgoal for s D"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n    \\<Longrightarrow> enn2real (x s)\n                      \\<le> (\\<Sum>t\\<in>S. pmf D t * enn2real (x t))", "by (rule ennreal_le_iff[THEN iffD1])\n          (use S1 in \\<open>auto intro!: sum_nonneg simp add: subset_eq solution sum_ennreal[symmetric] ennreal_mult simp del: sum_ennreal\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; n s = 0\\<rbrakk>\n       \\<Longrightarrow> enn2real (x s) = 0\n 2. \\<And>s. s \\<in> S2 \\<Longrightarrow> enn2real (x s) = 1", "apply (auto simp: solution_n0 solution_S2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enn2real (x s) \\<le> enn2real (n s)\n\ngoal (1 subgoal):\n 1. x s \\<le> n s", "with \\<open>s\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  enn2real (x s) \\<le> enn2real (n s)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> S\n  enn2real (x s) \\<le> enn2real (n s)\n\ngoal (1 subgoal):\n 1. x s \\<le> n s", "by (subst (asm) ennreal_le_iff[symmetric]) (simp_all add: real_n)"], ["proof (state)\nthis:\n  x s \\<le> n s\n\ngoal:\nNo subgoals!", "qed"], ["", "lifting_forget pmf_as_function.pmf.lifting"], ["", "text \\<open>\n  Type to describe MDP components. The support (i.e. elements which are not mapped to an empty\nset) is the set of states of the component.\n\nMost of this is from:\n  Formal verification of probabilistic systems\n  Luca de Alfaro (PhD thesis, 1997)\nand\n  Reachability in MDPs: Refining Convergence of Value Iteration\n  Serge Haddad and Benjamin Monmege (2014)\n\\<close>"], ["", "typedef 's mdpc = \"UNIV :: ('s \\<rightharpoonup> 's pmf set) set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> UNIV", "by auto"], ["", "setup_lifting type_definition_mdpc"], ["", "lift_definition states :: \"'s mdpc \\<Rightarrow> 's set\"\n  is dom"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare [[coercion states]]"], ["", "lift_definition actions :: \"'s mdpc \\<Rightarrow> 's \\<Rightarrow> 's pmf set\"\n  is \"\\<lambda>f s. case f s of None \\<Rightarrow> {} | Some a \\<Rightarrow> a\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma in_states: \"actions \\<phi> s \\<noteq> {} \\<Longrightarrow> s \\<in> states \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions \\<phi> s \\<noteq> {} \\<Longrightarrow> s \\<in> states \\<phi>", "by transfer auto"], ["", "lemma mdpc_eqI: \"states \\<phi> = states \\<psi> \\<Longrightarrow> (\\<And>s. s \\<in> states \\<phi> \\<Longrightarrow> actions \\<phi> s = actions \\<psi> s) \\<Longrightarrow> \\<phi> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>states \\<phi> = states \\<psi>;\n     \\<And>s.\n        s \\<in> states \\<phi> \\<Longrightarrow>\n        actions \\<phi> s = actions \\<psi> s\\<rbrakk>\n    \\<Longrightarrow> \\<phi> = \\<psi>", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<psi>.\n       \\<lbrakk>dom \\<phi> = dom \\<psi>;\n        \\<And>s.\n           s \\<in> dom \\<phi> \\<Longrightarrow>\n           (case \\<phi> s of None \\<Rightarrow> {}\n            | Some a \\<Rightarrow> a) =\n           (case \\<psi> s of None \\<Rightarrow> {}\n            | Some a \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> = \\<psi>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<psi> x.\n       \\<lbrakk>dom \\<phi> = dom \\<psi>;\n        \\<And>s.\n           s \\<in> dom \\<phi> \\<Longrightarrow>\n           (case \\<phi> s of None \\<Rightarrow> {}\n            | Some a \\<Rightarrow> a) =\n           (case \\<psi> s of None \\<Rightarrow> {}\n            | Some a \\<Rightarrow> a)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> x = \\<psi> x", "subgoal premises prems for \\<phi> \\<psi> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> x = \\<psi> x", "using prems(1) prems(2)[of x]"], ["proof (prove)\nusing this:\n  dom \\<phi> = dom \\<psi>\n  x \\<in> dom \\<phi> \\<Longrightarrow>\n  (case \\<phi> x of None \\<Rightarrow> {} | Some a \\<Rightarrow> a) =\n  (case \\<psi> x of None \\<Rightarrow> {} | Some a \\<Rightarrow> a)\n\ngoal (1 subgoal):\n 1. \\<phi> x = \\<psi> x", "by (cases \"x \\<in> dom \\<phi>\") (auto simp: fun_eq_iff split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition map_mdpc :: \"('s \\<Rightarrow> 't) \\<Rightarrow> 's mdpc \\<Rightarrow> 't mdpc\"\n  is \"\\<lambda>m f s. if f ` (m -` {s}) \\<subseteq> {None} then None else Some {map_pmf m d | d A t. m t = s \\<and> f t = Some A \\<and> d \\<in> A}\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma states_map_mdpc: \"states (map_mdpc f M) = f ` (states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (map_mdpc f M) = f ` states M", "by (transfer fixing: f) (auto simp: subset_eq image_iff dom_def split: if_splits)"], ["", "lemma actions_map_mdpc_eq_Collect: \"actions (map_mdpc f M) s = {map_pmf f d | d t. f t = s \\<and> d \\<in> actions M t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (map_mdpc f M) s =\n    {uu_.\n     \\<exists>d t.\n        uu_ = map_pmf f d \\<and> f t = s \\<and> d \\<in> actions M t}", "by transfer (force simp: subset_eq split: option.splits)"], ["", "lemma actions_map_mdpc: \"actions (map_mdpc f M) s = map_pmf f ` (\\<Union>t\\<in>f -` {s}. actions M t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (map_mdpc f M) s = map_pmf f ` \\<Union> (actions M ` f -` {s})", "by (auto simp: actions_map_mdpc_eq_Collect)"], ["", "lemma map_mdpc_compose: \"map_mdpc f (map_mdpc g M) = map_mdpc (f \\<circ> g) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mdpc f (map_mdpc g M) = map_mdpc (f \\<circ> g) M", "by (intro mdpc_eqI)\n     (auto simp add: states_map_mdpc image_comp actions_map_mdpc image_UN map_pmf_compose[symmetric]\n                     vimage_comp[symmetric])"], ["", "lemma map_mdpc_id: \"map_mdpc id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mdpc id = id", "by (auto simp: fun_eq_iff states_map_mdpc actions_map_mdpc intro!: mdpc_eqI)"], ["", "lemma finite_states_map: \"finite (states M) \\<Longrightarrow> finite (map_mdpc f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (states M) \\<Longrightarrow> finite (states (map_mdpc f M))", "by (simp add: states_map_mdpc)"], ["", "lemma finite_actions_map:\n  assumes \"finite (states M)\" \"\\<And>s. finite (actions M s)\" shows \"finite (actions (map_mdpc f M) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (actions (map_mdpc f M) s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (actions (map_mdpc f M) s)", "have \"(\\<Union>x\\<in>f -` {s}. actions M x) = (\\<Union>x\\<in>f -` {s} \\<inter> states M. actions M x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (actions M ` f -` {s}) =\n    \\<Union> (actions M ` (f -` {s} \\<inter> states M))", "using in_states[of M]"], ["proof (prove)\nusing this:\n  actions M ?s \\<noteq> {} \\<Longrightarrow> ?s \\<in> states M\n\ngoal (1 subgoal):\n 1. \\<Union> (actions M ` f -` {s}) =\n    \\<Union> (actions M ` (f -` {s} \\<inter> states M))", "by auto"], ["proof (state)\nthis:\n  \\<Union> (actions M ` f -` {s}) =\n  \\<Union> (actions M ` (f -` {s} \\<inter> states M))\n\ngoal (1 subgoal):\n 1. finite (actions (map_mdpc f M) s)", "with assms"], ["proof (chain)\npicking this:\n  finite (states M)\n  finite (actions M ?s)\n  \\<Union> (actions M ` f -` {s}) =\n  \\<Union> (actions M ` (f -` {s} \\<inter> states M))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (states M)\n  finite (actions M ?s)\n  \\<Union> (actions M ` f -` {s}) =\n  \\<Union> (actions M ` (f -` {s} \\<inter> states M))\n\ngoal (1 subgoal):\n 1. finite (actions (map_mdpc f M) s)", "by (auto simp add: actions_map_mdpc)"], ["proof (state)\nthis:\n  finite (actions (map_mdpc f M) s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition fix_loop :: \"'s \\<Rightarrow> 's mdpc \\<Rightarrow> 's mdpc\"\n  is \"\\<lambda>s M t. if s = t then Some {return_pmf s} else M t\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma states_fix_loop[simp]: \"states (fix_loop s M) = insert s (states M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (fix_loop s M) = insert s (states M)", "by transfer (auto simp: subset_eq image_iff dom_def split: if_splits)"], ["", "lemma actions_fix_loop[simp]: \"actions (fix_loop s M) t = (if s = t then {return_pmf s} else actions M t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (fix_loop s M) t =\n    (if s = t then {return_pmf s} else actions M t)", "by transfer auto"], ["", "lemma fix_loop_idem: \"fix_loop s (fix_loop s M) = fix_loop s M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix_loop s (fix_loop s M) = fix_loop s M", "by (auto intro!: mdpc_eqI)"], ["", "lemma fix_loop_commute: \"fix_loop s (fix_loop t M) = fix_loop t (fix_loop s M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix_loop s (fix_loop t M) = fix_loop t (fix_loop s M)", "by (auto intro!: mdpc_eqI)"], ["", "lemma map_fix_loop:\n  assumes f_s: \"\\<And>t. f s = f t \\<Longrightarrow> t = s\"\n  shows \"map_mdpc f (fix_loop s M) = fix_loop (f s) (map_mdpc f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mdpc f (fix_loop s M) = fix_loop (f s) (map_mdpc f M)", "by (auto simp: states_map_mdpc actions_map_mdpc_eq_Collect split: if_splits intro!: mdpc_eqI dest!: f_s f_s[OF sym]) force+"], ["", "lift_definition map_actions :: \"('s \\<Rightarrow> 's pmf set \\<Rightarrow> 's pmf set) \\<Rightarrow> 's mdpc \\<Rightarrow> 's mdpc\"\n  is \"\\<lambda>m f s. map_option (m s) (f s)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma state_map_actions[simp]: \"states (map_actions f \\<phi>) = states \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (map_actions f \\<phi>) = states \\<phi>", "by transfer auto"], ["", "lemma actions_map_actions[simp]: \"(s \\<notin> states \\<phi> \\<Longrightarrow> f s {} = {}) \\<Longrightarrow> actions (map_actions f \\<phi>) s = f s (actions \\<phi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<notin> states \\<phi> \\<Longrightarrow>\n     f s {} = {}) \\<Longrightarrow>\n    actions (map_actions f \\<phi>) s = f s (actions \\<phi> s)", "by transfer (auto split: option.splits)"], ["", "lift_definition restrict_states :: \"'s set \\<Rightarrow> 's mdpc \\<Rightarrow> 's mdpc\"\n  is \"\\<lambda>S f s. if s \\<in> S then f s else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma state_restrict_states[simp]: \"states (restrict_states S \\<phi>) = states \\<phi> \\<inter> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (restrict_states S \\<phi>) = states \\<phi> \\<inter> S", "by transfer (auto split: if_splits)"], ["", "lemma actions_restrict_states[simp]: \"actions (restrict_states S \\<phi>) s = (if s \\<in> S then actions \\<phi> s else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (restrict_states S \\<phi>) s =\n    (if s \\<in> S then actions \\<phi> s else {})", "by transfer (auto split: if_splits)"], ["", "lemma restrict_states_idem: \"states \\<phi> \\<subseteq> A \\<Longrightarrow> restrict_states A \\<phi> = \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states \\<phi> \\<subseteq> A \\<Longrightarrow>\n    restrict_states A \\<phi> = \\<phi>", "by transfer (force simp: fun_eq_iff subset_eq dom_def)"], ["", "instantiation mdpc :: (type) lattice\nbegin"], ["", "lift_definition less_eq_mdpc :: \"'s mdpc \\<Rightarrow> 's mdpc \\<Rightarrow> bool\"\n  is \"fun_ord (ord_option (\\<subseteq>))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition less_mdpc :: \"'s mdpc \\<Rightarrow> 's mdpc \\<Rightarrow> bool\"\n  where \"less_mdpc f g \\<longleftrightarrow> (f \\<le> g \\<and> \\<not> g \\<le> f)\""], ["", "lift_definition inf_mdpc :: \"'s mdpc \\<Rightarrow> 's mdpc \\<Rightarrow> 's mdpc\"\n  is \"\\<lambda>f g s. lift_option (\\<inter>) (f s) (g s)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition sup_mdpc :: \"'s mdpc \\<Rightarrow> 's mdpc \\<Rightarrow> 's mdpc\"\n  is \"\\<lambda>f g s. combine_options (\\<union>) (f s) (g s)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mdpc, lattice_class)", "proof"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x", "fix x y z :: \"'s mdpc\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"(x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)", "by (rule less_mdpc_def)"], ["proof (state)\nthis:\n  (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n\ngoal (9 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "note ord =\n    fun_ord_refl[where 'b=\"'s\", OF reflp_ord_option[where 'a=\"'s pmf set\"], of \"(\\<subseteq>)\"]\n    fun_ord_trans[where 'b=\"'s\", OF transp_ord_option[where 'a=\"'s pmf set\"], of \"(\\<subseteq>)\"]\n    fun_ord_antisym[where 'b=\"'s\", OF antisymp_ord_option[where 'a=\"'s pmf set\"], of \"(\\<subseteq>)\"]"], ["proof (state)\nthis:\n  reflp (\\<subseteq>) \\<Longrightarrow>\n  reflp (fun_ord (ord_option (\\<subseteq>)))\n  transp (\\<subseteq>) \\<Longrightarrow>\n  transp (fun_ord (ord_option (\\<subseteq>)))\n  antisymp (\\<subseteq>) \\<Longrightarrow>\n  antisymp (fun_ord (ord_option (\\<subseteq>)))\n\ngoal (9 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show  \"x \\<le> x\" \"x \\<le> y \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> z\" \"x \\<le> y \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x &&&\n    (\\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z) &&&\n    (\\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y)", "by (transfer; insert ord; auto simp: transp_def antisymp_def reflp_def)+"], ["proof (state)\nthis:\n  x \\<le> x\n  \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n  \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n\ngoal (6 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"x \\<sqinter> y \\<le> x\" \"x \\<sqinter> y \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<le> x &&& x \\<sqinter> y \\<le> y", "by (transfer; auto simp: fun_ord_def ord_option.simps lift_option_def split: Option.bind_split)+"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<le> x\n  x \\<sqinter> y \\<le> y\n\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"x \\<le> y \\<Longrightarrow> x \\<le> z \\<Longrightarrow> x \\<le> y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> y \\<sqinter> z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>fun_ord (ord_option (\\<subseteq>)) x y;\n        fun_ord (ord_option (\\<subseteq>)) x z\\<rbrakk>\n       \\<Longrightarrow> fun_ord (ord_option (\\<subseteq>)) x\n                          (\\<lambda>s. lift_option (\\<inter>) (y s) (z s))", "subgoal premises prems for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_ord (ord_option (\\<subseteq>)) a\n     (\\<lambda>s. lift_option (\\<inter>) (b s) (c s))", "using prems"], ["proof (prove)\nusing this:\n  fun_ord (ord_option (\\<subseteq>)) a b\n  fun_ord (ord_option (\\<subseteq>)) a c\n\ngoal (1 subgoal):\n 1. fun_ord (ord_option (\\<subseteq>)) a\n     (\\<lambda>s. lift_option (\\<inter>) (b s) (c s))", "by (rule fun_ord_combine) (auto simp: ord_option.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n  \\<Longrightarrow> x \\<le> y \\<sqinter> z\n\ngoal (3 subgoals):\n 1. \\<And>x y. x \\<le> x \\<squnion> y\n 2. \\<And>y x. y \\<le> x \\<squnion> y\n 3. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"x \\<le> x \\<squnion> y\" \"y \\<le> x \\<squnion> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x \\<squnion> y &&& y \\<le> x \\<squnion> y", "by (transfer; auto simp: fun_ord_def ord_option.simps combine_options_def not_all_eq split: option.splits)+"], ["proof (state)\nthis:\n  x \\<le> x \\<squnion> y\n  y \\<le> x \\<squnion> y\n\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x", "show \"y \\<le> x \\<Longrightarrow> z \\<le> x \\<Longrightarrow> y \\<squnion> z \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n    \\<Longrightarrow> y \\<squnion> z \\<le> x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x z.\n       \\<lbrakk>fun_ord (ord_option (\\<subseteq>)) y x;\n        fun_ord (ord_option (\\<subseteq>)) z x\\<rbrakk>\n       \\<Longrightarrow> fun_ord (ord_option (\\<subseteq>))\n                          (\\<lambda>s.\n                              combine_options (\\<union>) (y s) (z s))\n                          x", "subgoal premises prems for a b c"], ["proof (prove)\ngoal (1 subgoal):\n 1. fun_ord (ord_option (\\<subseteq>))\n     (\\<lambda>s. combine_options (\\<union>) (a s) (c s)) b", "using prems"], ["proof (prove)\nusing this:\n  fun_ord (ord_option (\\<subseteq>)) a b\n  fun_ord (ord_option (\\<subseteq>)) c b\n\ngoal (1 subgoal):\n 1. fun_ord (ord_option (\\<subseteq>))\n     (\\<lambda>s. combine_options (\\<union>) (a s) (c s)) b", "by (rule fun_ord_combine) (auto simp: ord_option.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n  \\<Longrightarrow> y \\<squnion> z \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation mdpc :: (type) complete_lattice\nbegin"], ["", "lift_definition bot_mdpc :: \"'a mdpc\" is \"\\<lambda>_. None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition top_mdpc :: \"'a mdpc\" is \"\\<lambda>_. Some UNIV\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Sup_mdpc :: \"'a mdpc set \\<Rightarrow> 'a mdpc\"\n  is \"\\<lambda>M s. if \\<exists>m\\<in>M. m s \\<noteq> None then Some (\\<Union>{ d | m d. m \\<in> M \\<and> m s = Some d}) else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition Inf_mdpc :: \"'a mdpc set \\<Rightarrow> 'a mdpc\"\n  is \"\\<lambda>M s. if \\<exists>m\\<in>M. m s = None then None else Some (\\<Inter>{ d | m d. m \\<in> M \\<and> m s = Some d})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a mdpc, complete_lattice_class)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> \\<Sqinter> A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 5. \\<Sqinter> {} = \\<top>\n 6. \\<Squnion> {} = \\<bottom>", "fix x :: \"'a mdpc\" and X :: \"'a mdpc set\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x A. x \\<in> A \\<Longrightarrow> \\<Sqinter> A \\<le> x\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 3. \\<And>x A. x \\<in> A \\<Longrightarrow> x \\<le> \\<Squnion> A\n 4. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 5. \\<Sqinter> {} = \\<top>\n 6. \\<Squnion> {} = \\<bottom>", "show \"x \\<in> X \\<Longrightarrow> \\<Sqinter>X \\<le> x\" \"x \\<in> X \\<Longrightarrow> x \\<le> \\<Squnion>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x) &&&\n    (x \\<in> X \\<Longrightarrow> x \\<le> \\<Squnion> X)", "by (transfer; force simp: fun_ord_def ord_option_Some1_iff ord_option_Some2_iff)+"], ["proof (state)\nthis:\n  x \\<in> X \\<Longrightarrow> \\<Sqinter> X \\<le> x\n  x \\<in> X \\<Longrightarrow> x \\<le> \\<Squnion> X\n\ngoal (4 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 2. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 3. \\<Sqinter> {} = \\<top>\n 4. \\<Squnion> {} = \\<bottom>", "show \"(\\<And>y. y \\<in> X \\<Longrightarrow> x \\<le> y) \\<Longrightarrow> x \\<le> \\<Sqinter>X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> X \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n    x \\<le> \\<Sqinter> X", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       (\\<And>y.\n           y \\<in> X \\<Longrightarrow>\n           fun_ord (ord_option (\\<subseteq>)) x y) \\<Longrightarrow>\n       fun_ord (ord_option (\\<subseteq>)) x\n        (\\<lambda>s.\n            if \\<exists>m\\<in>X. m s = None then None\n            else Some\n                  (\\<Inter>\n                    {uu_.\n                     \\<exists>m d.\n                        uu_ = d \\<and> m \\<in> X \\<and> m s = Some d}))", "apply (clarsimp simp: fun_ord_def ord_option.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x xa.\n       (\\<And>y.\n           y \\<in> X \\<Longrightarrow>\n           \\<forall>xa.\n              x xa = None \\<or>\n              (\\<exists>xb.\n                  x xa = Some xb \\<and>\n                  (\\<exists>ya.\n                      y xa = Some ya \\<and>\n                      xb \\<subseteq> ya))) \\<Longrightarrow>\n       ((\\<exists>m\\<in>X. m xa = None) \\<longrightarrow>\n        x xa = None) \\<and>\n       ((\\<forall>m\\<in>X. \\<exists>y. m xa = Some y) \\<longrightarrow>\n        x xa = None \\<or>\n        (\\<exists>xb.\n            x xa = Some xb \\<and>\n            xb \\<subseteq> \\<Inter>\n                            {uu_.\n                             \\<exists>m. m \\<in> X \\<and> m xa = Some uu_}))", "subgoal premises P for X m x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>m\\<in>X. m x = None) \\<longrightarrow> m x = None) \\<and>\n    ((\\<forall>m\\<in>X. \\<exists>y. m x = Some y) \\<longrightarrow>\n     m x = None \\<or>\n     (\\<exists>x.\n         m x = Some x \\<and>\n         x \\<subseteq> \\<Inter>\n                        {uu_. \\<exists>m. m \\<in> X \\<and> m x = Some uu_}))", "using P[rule_format, of _ x]"], ["proof (prove)\nusing this:\n  ?y \\<in> X \\<Longrightarrow>\n  m x = None \\<or>\n  (\\<exists>x.\n      m x = Some x \\<and>\n      (\\<exists>y. ?y x = Some y \\<and> x \\<subseteq> y))\n\ngoal (1 subgoal):\n 1. ((\\<exists>m\\<in>X. m x = None) \\<longrightarrow> m x = None) \\<and>\n    ((\\<forall>m\\<in>X. \\<exists>y. m x = Some y) \\<longrightarrow>\n     m x = None \\<or>\n     (\\<exists>x.\n         m x = Some x \\<and>\n         x \\<subseteq> \\<Inter>\n                        {uu_. \\<exists>m. m \\<in> X \\<and> m x = Some uu_}))", "by (cases \"m x\") fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<And>y. y \\<in> X \\<Longrightarrow> x \\<le> y) \\<Longrightarrow>\n  x \\<le> \\<Sqinter> X\n\ngoal (3 subgoals):\n 1. \\<And>A z.\n       (\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n       \\<Squnion> A \\<le> z\n 2. \\<Sqinter> {} = \\<top>\n 3. \\<Squnion> {} = \\<bottom>", "show \"(\\<And>y. y \\<in> X \\<Longrightarrow> y \\<le> x) \\<Longrightarrow> \\<Squnion>X \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> X \\<Longrightarrow> y \\<le> x) \\<Longrightarrow>\n    \\<Squnion> X \\<le> x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       (\\<And>y.\n           y \\<in> X \\<Longrightarrow>\n           fun_ord (ord_option (\\<subseteq>)) y x) \\<Longrightarrow>\n       fun_ord (ord_option (\\<subseteq>))\n        (\\<lambda>s.\n            if \\<exists>m\\<in>X. m s \\<noteq> None\n            then Some\n                  (\\<Union>\n                    {uu_.\n                     \\<exists>m d.\n                        uu_ = d \\<and> m \\<in> X \\<and> m s = Some d})\n            else None)\n        x", "apply (clarsimp simp: fun_ord_def ord_option.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x xa m y.\n       \\<lbrakk>\\<And>y.\n                   y \\<in> X \\<Longrightarrow>\n                   \\<forall>xa.\n                      y xa = None \\<or>\n                      (\\<exists>xb.\n                          y xa = Some xb \\<and>\n                          (\\<exists>y.\n                              x xa = Some y \\<and> xb \\<subseteq> y));\n        m \\<in> X; m xa = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            x xa = Some y \\<and>\n                            \\<Union>\n                             {uu_.\n                              \\<exists>m. m \\<in> X \\<and> m xa = Some uu_}\n                            \\<subseteq> y", "subgoal premises P for X m x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y.\n       m x = Some y \\<and>\n       \\<Union> {uu_. \\<exists>m. m \\<in> X \\<and> m x = Some uu_}\n       \\<subseteq> y", "using P(1)[rule_format, of _ x] P(1)[rule_format, of y x] P(2,3)"], ["proof (prove)\nusing this:\n  ?y \\<in> X \\<Longrightarrow>\n  ?y x = None \\<or>\n  (\\<exists>x.\n      ?y x = Some x \\<and>\n      (\\<exists>y. m x = Some y \\<and> x \\<subseteq> y))\n  y \\<in> X \\<Longrightarrow>\n  y x = None \\<or>\n  (\\<exists>x.\n      y x = Some x \\<and> (\\<exists>y. m x = Some y \\<and> x \\<subseteq> y))\n  y \\<in> X\n  y x = Some z\n\ngoal (1 subgoal):\n 1. \\<exists>y.\n       m x = Some y \\<and>\n       \\<Union> {uu_. \\<exists>m. m \\<in> X \\<and> m x = Some uu_}\n       \\<subseteq> y", "by auto force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<And>y. y \\<in> X \\<Longrightarrow> y \\<le> x) \\<Longrightarrow>\n  \\<Squnion> X \\<le> x\n\ngoal (2 subgoals):\n 1. \\<Sqinter> {} = \\<top>\n 2. \\<Squnion> {} = \\<bottom>", "qed (transfer; auto)+"], ["", "end"], ["", "lemma states_sup[simp]: \"states (\\<phi> \\<squnion> \\<psi>) = states \\<phi> \\<union> states \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (\\<phi> \\<squnion> \\<psi>) = states \\<phi> \\<union> states \\<psi>", "by transfer (auto simp: combine_options_def split: option.splits)"], ["", "lemma states_SUP[simp]: \"states (\\<Squnion>A) = (\\<Union>a\\<in>A. states a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (\\<Squnion> A) = \\<Union> (states ` A)", "by transfer (auto simp: dom_def split: option.splits if_splits)"], ["", "lemma states_inf[simp]: \"states (\\<phi> \\<sqinter> \\<psi>) = states \\<phi> \\<inter> states \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (\\<phi> \\<sqinter> \\<psi>) = states \\<phi> \\<inter> states \\<psi>", "by transfer (auto simp: lift_option_eq_Some split: option.splits)"], ["", "lemma states_mono: \"\\<phi> \\<le> \\<psi> \\<Longrightarrow> states \\<phi> \\<subseteq> states \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n    states \\<phi> \\<subseteq> states \\<psi>", "using states_sup[of \\<phi> \\<psi>]"], ["proof (prove)\nusing this:\n  states (\\<phi> \\<squnion> \\<psi>) = states \\<phi> \\<union> states \\<psi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n    states \\<phi> \\<subseteq> states \\<psi>", "by (auto simp del: states_sup simp add: sup_absorb2)"], ["", "lemma actions_sup[simp]: \"actions (\\<phi> \\<squnion> \\<psi>) = actions \\<phi> \\<squnion> actions \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (\\<phi> \\<squnion> \\<psi>) =\n    actions \\<phi> \\<squnion> actions \\<psi>", "by transfer (auto simp: combine_options_def split: option.splits)"], ["", "lemma actions_SUP[simp]: \"actions (\\<Squnion>A) s = (\\<Union>a\\<in>A. actions a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (\\<Squnion> A) s = (\\<Union>a\\<in>A. actions a s)", "by transfer (auto simp: dom_def split: option.splits if_splits, blast)"], ["", "lemma actions_inf[simp]: \"actions (\\<phi> \\<sqinter> \\<psi>) = actions \\<phi> \\<sqinter> actions \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (\\<phi> \\<sqinter> \\<psi>) =\n    actions \\<phi> \\<sqinter> actions \\<psi>", "by transfer (auto simp: fun_eq_iff split: option.splits)"], ["", "lemma actions_mono: assumes *: \"\\<phi> \\<le> \\<psi>\" shows \"actions \\<phi> \\<le> actions \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<psi>", "have \"actions \\<phi> \\<le> actions \\<phi> \\<squnion> actions \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<phi> \\<squnion> actions \\<psi>", "by auto"], ["proof (state)\nthis:\n  actions \\<phi> \\<le> actions \\<phi> \\<squnion> actions \\<psi>\n\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<psi>", "also"], ["proof (state)\nthis:\n  actions \\<phi> \\<le> actions \\<phi> \\<squnion> actions \\<psi>\n\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<psi>", "have \"\\<dots> = actions \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions \\<phi> \\<squnion> actions \\<psi> = actions \\<psi>", "using * actions_sup[of \\<phi> \\<psi>]"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> \\<psi>\n  actions (\\<phi> \\<squnion> \\<psi>) =\n  actions \\<phi> \\<squnion> actions \\<psi>\n\ngoal (1 subgoal):\n 1. actions \\<phi> \\<squnion> actions \\<psi> = actions \\<psi>", "by (auto simp add: sup_absorb2)"], ["proof (state)\nthis:\n  actions \\<phi> \\<squnion> actions \\<psi> = actions \\<psi>\n\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<psi>", "finally"], ["proof (chain)\npicking this:\n  actions \\<phi> \\<le> actions \\<psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  actions \\<phi> \\<le> actions \\<psi>\n\ngoal (1 subgoal):\n 1. actions \\<phi> \\<le> actions \\<psi>", "."], ["proof (state)\nthis:\n  actions \\<phi> \\<le> actions \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_mdpcI: \"states M \\<subseteq> states N \\<Longrightarrow> (\\<And>s. s \\<in> states M \\<Longrightarrow> actions M s \\<subseteq> actions N s) \\<Longrightarrow> M \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>states M \\<subseteq> states N;\n     \\<And>s.\n        s \\<in> states M \\<Longrightarrow>\n        actions M s \\<subseteq> actions N s\\<rbrakk>\n    \\<Longrightarrow> M \\<le> N", "by transfer\n     (force simp: fun_ord_def ord_option.simps subset_eq split: option.splits)"], ["", "lemma le_mdpc_iff: \"M \\<le> N \\<longleftrightarrow> states M \\<subseteq> states N \\<and> (\\<forall>s. actions M s \\<subseteq> actions N s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M \\<le> N) =\n    (states M \\<subseteq> states N \\<and>\n     (\\<forall>s. actions M s \\<subseteq> actions N s))", "using states_mono[of M N] actions_mono[of M N]"], ["proof (prove)\nusing this:\n  M \\<le> N \\<Longrightarrow> states M \\<subseteq> states N\n  M \\<le> N \\<Longrightarrow> actions M \\<le> actions N\n\ngoal (1 subgoal):\n 1. (M \\<le> N) =\n    (states M \\<subseteq> states N \\<and>\n     (\\<forall>s. actions M s \\<subseteq> actions N s))", "by (auto simp: le_fun_def intro!: le_mdpcI)"], ["", "lemma map_actions_le: \"(\\<And>s A. s \\<in> states \\<phi> \\<Longrightarrow> f s A \\<subseteq> A) \\<Longrightarrow> map_actions f \\<phi> \\<le> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s A.\n        s \\<in> states \\<phi> \\<Longrightarrow>\n        f s A \\<subseteq> A) \\<Longrightarrow>\n    map_actions f \\<phi> \\<le> \\<phi>", "apply (intro le_mdpcI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>s A.\n        s \\<in> states \\<phi> \\<Longrightarrow>\n        f s A \\<subseteq> A) \\<Longrightarrow>\n    states (map_actions f \\<phi>) \\<subseteq> states \\<phi>\n 2. \\<And>s.\n       \\<lbrakk>\\<And>s A.\n                   s \\<in> states \\<phi> \\<Longrightarrow>\n                   f s A \\<subseteq> A;\n        s \\<in> states (map_actions f \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> actions (map_actions f \\<phi>) s\n                         \\<subseteq> actions \\<phi> s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s A.\n        s \\<in> states \\<phi> \\<Longrightarrow>\n        f s A \\<subseteq> A) \\<Longrightarrow>\n    states (map_actions f \\<phi>) \\<subseteq> states \\<phi>", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>s A.\n                   s \\<in> states \\<phi> \\<Longrightarrow>\n                   f s A \\<subseteq> A;\n        s \\<in> states (map_actions f \\<phi>)\\<rbrakk>\n       \\<Longrightarrow> actions (map_actions f \\<phi>) s\n                         \\<subseteq> actions \\<phi> s", "subgoal premises p for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (map_actions f \\<phi>) s \\<subseteq> actions \\<phi> s", "using p(1)[of s] p(1)[of s \"{}\"] p(2) actions_map_actions"], ["proof (prove)\nusing this:\n  s \\<in> states \\<phi> \\<Longrightarrow> f s ?A \\<subseteq> ?A\n  s \\<in> states \\<phi> \\<Longrightarrow> f s {} \\<subseteq> {}\n  s \\<in> states (map_actions f \\<phi>)\n  (?s \\<notin> states ?\\<phi> \\<Longrightarrow>\n   ?f ?s {} = {}) \\<Longrightarrow>\n  actions (map_actions ?f ?\\<phi>) ?s = ?f ?s (actions ?\\<phi> ?s)\n\ngoal (1 subgoal):\n 1. actions (map_actions f \\<phi>) s \\<subseteq> actions \\<phi> s", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_states_mono: \"A \\<subseteq> B \\<Longrightarrow> \\<phi> \\<le> \\<psi> \\<Longrightarrow> restrict_states A \\<phi> \\<le> restrict_states B \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B; \\<phi> \\<le> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> restrict_states A \\<phi>\n                      \\<le> restrict_states B \\<psi>", "using states_mono[of \\<phi> \\<psi>] actions_mono[of \\<phi> \\<psi>]"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n  states \\<phi> \\<subseteq> states \\<psi>\n  \\<phi> \\<le> \\<psi> \\<Longrightarrow> actions \\<phi> \\<le> actions \\<psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B; \\<phi> \\<le> \\<psi>\\<rbrakk>\n    \\<Longrightarrow> restrict_states A \\<phi>\n                      \\<le> restrict_states B \\<psi>", "by (intro le_mdpcI) (auto simp: le_fun_def)"], ["", "lemma restrict_states_le: \"restrict_states A M \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_states A M \\<le> M", "by (intro le_mdpcI) auto"], ["", "lemma eq_bot_iff_states: \"\\<phi> = bot \\<longleftrightarrow> states \\<phi> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> = \\<bottom>) = (states \\<phi> = {})", "by transfer auto"], ["", "lemma fix_loop_neq_bot: \"fix_loop s N \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fix_loop s N \\<noteq> \\<bottom>", "unfolding eq_bot_iff_states"], ["proof (prove)\ngoal (1 subgoal):\n 1. states (fix_loop s N) \\<noteq> {}", "by simp"], ["", "lemma\n  shows states_bot[simp]: \"states bot = {}\"\n    and actions_bot[simp]: \"actions bot = (\\<lambda>s. {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states \\<bottom> = {} &&& actions \\<bottom> = (\\<lambda>s. {})", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. states \\<bottom> = {} &&& \\<forall>x. actions \\<bottom> x = {}", "by (transfer; auto)+"], ["", "lemma inf_eq_bot_eq_disjnt_states: \"A \\<sqinter> B = bot \\<longleftrightarrow> disjnt (states A) (states B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<sqinter> B = \\<bottom>) = disjnt (states A) (states B)", "unfolding disjnt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<sqinter> B = \\<bottom>) = (states A \\<inter> states B = {})", "by transfer  (auto simp: fun_eq_iff lift_option_eq_None)"], ["", "text \\<open>Enabled States\\<close>"], ["", "definition en :: \"'s mdpc \\<Rightarrow> 's rel\"\n  where \"en \\<phi> = {(s, t) | d s t. d \\<in> actions \\<phi> s \\<and> t \\<in> set_pmf d}\""], ["", "lemma en_sup[simp]: \"en (\\<phi> \\<squnion> \\<psi>) = en \\<phi> \\<union> en \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. en (\\<phi> \\<squnion> \\<psi>) = en \\<phi> \\<union> en \\<psi>", "by (auto simp: en_def)"], ["", "lemma en_SUP[simp]: \"en (Sup A) = (\\<Union>a\\<in>A. en a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. en (\\<Squnion> A) = \\<Union> (en ` A)", "by (auto simp: en_def)"], ["", "lemma en_mono: \"\\<phi> \\<le> \\<psi> \\<Longrightarrow> en \\<phi> \\<subseteq> en \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow> en \\<phi> \\<subseteq> en \\<psi>", "unfolding en_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n    {uu_.\n     \\<exists>d s t.\n        uu_ = (s, t) \\<and>\n        d \\<in> actions \\<phi> s \\<and> t \\<in> set_pmf d}\n    \\<subseteq> {uu_.\n                 \\<exists>d s t.\n                    uu_ = (s, t) \\<and>\n                    d \\<in> actions \\<psi> s \\<and> t \\<in> set_pmf d}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<psi>.\n       fun_ord (ord_option (\\<subseteq>)) \\<phi> \\<psi> \\<Longrightarrow>\n       {uu_.\n        \\<exists>d s t.\n           uu_ = (s, t) \\<and>\n           d \\<in> (case \\<phi> s of None \\<Rightarrow> {}\n                    | Some a \\<Rightarrow> a) \\<and>\n           t \\<in> set_pmf d}\n       \\<subseteq> {uu_.\n                    \\<exists>d s t.\n                       uu_ = (s, t) \\<and>\n                       d \\<in> (case \\<psi> s of None \\<Rightarrow> {}\n                                | Some a \\<Rightarrow> a) \\<and>\n                       t \\<in> set_pmf d}", "apply (auto simp: fun_ord_def split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<psi> a b d y.\n       \\<lbrakk>\\<forall>x. ord_option (\\<subseteq>) (\\<phi> x) (\\<psi> x);\n        \\<phi> a = Some y; d \\<in> y; b \\<in> set_pmf d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d s.\n                            (\\<exists>y. \\<psi> s = Some y) \\<and>\n                            (\\<forall>x2.\n                                \\<psi> s = Some x2 \\<longrightarrow>\n                                a = s \\<and>\n                                d \\<in> x2 \\<and> b \\<in> set_pmf d)", "apply (auto simp add: ord_option.simps subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi> \\<psi> a b d y.\n       \\<lbrakk>\\<forall>x.\n                   \\<phi> x = None \\<or>\n                   (\\<exists>xa.\n                       \\<phi> x = Some xa \\<and>\n                       (\\<exists>y.\n                           \\<psi> x = Some y \\<and>\n                           (\\<forall>t.\n                               t \\<in> xa \\<longrightarrow> t \\<in> y)));\n        \\<phi> a = Some y; d \\<in> y; b \\<in> set_pmf d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d s.\n                            (\\<exists>y. \\<psi> s = Some y) \\<and>\n                            (\\<forall>x2.\n                                \\<psi> s = Some x2 \\<longrightarrow>\n                                a = s \\<and>\n                                d \\<in> x2 \\<and> b \\<in> set_pmf d)", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma en_states: \"(s, t) \\<in> en M \\<Longrightarrow> s \\<in> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> en M \\<Longrightarrow> s \\<in> states M", "using in_states[of M s]"], ["proof (prove)\nusing this:\n  actions M s \\<noteq> {} \\<Longrightarrow> s \\<in> states M\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> en M \\<Longrightarrow> s \\<in> states M", "by (auto simp: en_def)"], ["", "lemma en_bot[simp]: \"en bot = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. en \\<bottom> = {}", "by (simp add: en_def)"], ["", "lemma en_fix_loop[simp]: \"en (fix_loop s M) = insert (s, s) (en M - {s} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. en (fix_loop s M) = insert (s, s) (en M - {s} \\<times> UNIV)", "by (force simp add: en_def )"], ["", "lift_definition trivial :: \"'s \\<Rightarrow> 's mdpc\" is \"\\<lambda>s. (\\<lambda>_. None)(s := Some {})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma states_trivial[simp]: \"states (trivial s) = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (trivial s) = {s}", "by transfer auto"], ["", "lemma actions_trivial[simp]: \"actions (trivial s) = (\\<lambda>_. {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (trivial s) = (\\<lambda>_. {})", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma en_trivial[simp]: \"en (trivial s) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. en (trivial s) = {}", "by (simp add: en_def)"], ["", "lemma trivial_le_iff: \"trivial x \\<le> \\<phi> \\<longleftrightarrow> x \\<in> states \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trivial x \\<le> \\<phi>) = (x \\<in> states \\<phi>)", "by transfer (auto simp: ord_option.simps fun_ord_def)"], ["", "lemma trivial_le: \"x \\<in> states \\<phi> \\<Longrightarrow> trivial x \\<le> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> states \\<phi> \\<Longrightarrow> trivial x \\<le> \\<phi>", "unfolding trivial_le_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> states \\<phi> \\<Longrightarrow> x \\<in> states \\<phi>", "."], ["", "lemma trivial_neq_bot: \"trivial x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivial x \\<noteq> \\<bottom>", "by transfer auto"], ["", "lift_definition loop :: \"'s \\<Rightarrow> 's mdpc\"\n  is \"\\<lambda>s. (\\<lambda>_. None)(s := Some {return_pmf s})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma states_loop[simp]: \"states (loop s) = {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (loop s) = {s}", "by transfer auto"], ["", "lemma actions_loop: \"actions (loop s) = ((\\<lambda>_. {})(s := {return_pmf s}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (loop s) = (\\<lambda>_. {})(s := {return_pmf s})", "by transfer (auto simp: fun_eq_iff)"], ["", "lemma\n  shows actions_loop_self[simp]: \"actions (loop s) s = {return_pmf s}\"\n    and actions_loop_neq[simp]: \"s \\<noteq> t \\<Longrightarrow> actions (loop s) t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions (loop s) s = {return_pmf s} &&&\n    (s \\<noteq> t \\<Longrightarrow> actions (loop s) t = {})", "by (simp_all add: actions_loop)"], ["", "lemma en_loop[simp]: \"en (loop s) = {(s, s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. en (loop s) = {(s, s)}", "by (auto simp: en_def actions_loop)"], ["", "lemma loop_neq_bot: \"loop s \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop s \\<noteq> \\<bottom>", "unfolding eq_bot_iff_states"], ["proof (prove)\ngoal (1 subgoal):\n 1. states (loop s) \\<noteq> {}", "by simp"], ["", "lemma loop_le: \"loop x \\<le> M \\<longleftrightarrow> (x \\<in> states M \\<and> return_pmf x \\<in> actions M x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (loop x \\<le> M) =\n    (x \\<in> states M \\<and> return_pmf x \\<in> actions M x)", "by (auto simp: le_mdpc_iff actions_loop)"], ["", "lemma le_loop: \"M \\<le> loop x \\<longleftrightarrow> (states M \\<subseteq> {x} \\<and> actions M x \\<subseteq> {return_pmf x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M \\<le> loop x) =\n    (states M \\<subseteq> {x} \\<and> actions M x \\<subseteq> {return_pmf x})", "using in_states[of M]"], ["proof (prove)\nusing this:\n  actions M ?s \\<noteq> {} \\<Longrightarrow> ?s \\<in> states M\n\ngoal (1 subgoal):\n 1. (M \\<le> loop x) =\n    (states M \\<subseteq> {x} \\<and> actions M x \\<subseteq> {return_pmf x})", "by (auto simp: le_mdpc_iff actions_loop)"], ["", "text \\<open>Strongly Connected (SC)\\<close>"], ["", "definition sc :: \"'s mdpc \\<Rightarrow> bool\"\n  where \"sc \\<phi> \\<longleftrightarrow> states \\<phi> \\<times> states \\<phi> \\<subseteq> (en \\<phi>)\\<^sup>*\""], ["", "lemma scD: \"sc \\<phi> \\<Longrightarrow> x \\<in> states \\<phi> \\<Longrightarrow> y \\<in> states \\<phi> \\<Longrightarrow> (x, y) \\<in> (en \\<phi>)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sc \\<phi>; x \\<in> states \\<phi>;\n     y \\<in> states \\<phi>\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> (en \\<phi>)\\<^sup>*", "by (auto simp: sc_def)"], ["", "lemma scI: \"(\\<And>x y. x \\<in> states \\<phi> \\<Longrightarrow> y \\<in> states \\<phi> \\<Longrightarrow> (x, y) \\<in> (en \\<phi>)\\<^sup>*) \\<Longrightarrow> sc \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> states \\<phi>; y \\<in> states \\<phi>\\<rbrakk>\n        \\<Longrightarrow> (x, y)\n                          \\<in> (en \\<phi>)\\<^sup>*) \\<Longrightarrow>\n    sc \\<phi>", "by (auto simp: sc_def)"], ["", "lemma sc_trivial[simp]: \"sc (trivial s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc (trivial s)", "by (simp add: sc_def)"], ["", "lemma sc_loop[simp]: \"sc (loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc (loop s)", "by (auto simp: sc_def)"], ["", "lemma sc_bot[simp]: \"sc bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc \\<bottom>", "by (simp add: sc_def)"], ["", "lemma sc_SupI_directed:\n  assumes A: \"\\<And>a. a \\<in> A \\<Longrightarrow> sc a\"\n    and directed: \"\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> A \\<Longrightarrow> \\<exists>c\\<in>A. a \\<le> c \\<and> b \\<le> c\"\n  shows \"sc (Sup A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc (\\<Squnion> A)", "unfolding sc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. states (\\<Squnion> A) \\<times> states (\\<Squnion> A)\n    \\<subseteq> (en (\\<Squnion> A))\\<^sup>*", "proof clarsimp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>x \\<in> A; a \\<in> states x; xa \\<in> A;\n        b \\<in> states xa\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (\\<Union> (en ` A))\\<^sup>*", "fix x y a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>x \\<in> A; a \\<in> states x; xa \\<in> A;\n        b \\<in> states xa\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (\\<Union> (en ` A))\\<^sup>*", "assume \"a \\<in> A\" \"b \\<in> A\" and xy: \"x \\<in> states a\" \"y \\<in> states b\""], ["proof (state)\nthis:\n  a \\<in> A\n  b \\<in> A\n  x \\<in> states a\n  y \\<in> states b\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>x \\<in> A; a \\<in> states x; xa \\<in> A;\n        b \\<in> states xa\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (\\<Union> (en ` A))\\<^sup>*", "with directed"], ["proof (chain)\npicking this:\n  \\<lbrakk>?a \\<in> A; ?b \\<in> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>A. ?a \\<le> c \\<and> ?b \\<le> c\n  a \\<in> A\n  b \\<in> A\n  x \\<in> states a\n  y \\<in> states b", "obtain c where \"c \\<in> A\" \"a \\<le> c\" \"b \\<le> c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> A; ?b \\<in> A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>A. ?a \\<le> c \\<and> ?b \\<le> c\n  a \\<in> A\n  b \\<in> A\n  x \\<in> states a\n  y \\<in> states b\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> A; a \\<le> c; b \\<le> c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> A\n  a \\<le> c\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>x \\<in> A; a \\<in> states x; xa \\<in> A;\n        b \\<in> states xa\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (\\<Union> (en ` A))\\<^sup>*", "with xy"], ["proof (chain)\npicking this:\n  x \\<in> states a\n  y \\<in> states b\n  c \\<in> A\n  a \\<le> c\n  b \\<le> c", "have \"x \\<in> states c\" \"y \\<in> states c\""], ["proof (prove)\nusing this:\n  x \\<in> states a\n  y \\<in> states b\n  c \\<in> A\n  a \\<le> c\n  b \\<le> c\n\ngoal (1 subgoal):\n 1. x \\<in> states c &&& y \\<in> states c", "using states_mono[of a c] states_mono[of b c]"], ["proof (prove)\nusing this:\n  x \\<in> states a\n  y \\<in> states b\n  c \\<in> A\n  a \\<le> c\n  b \\<le> c\n  a \\<le> c \\<Longrightarrow> states a \\<subseteq> states c\n  b \\<le> c \\<Longrightarrow> states b \\<subseteq> states c\n\ngoal (1 subgoal):\n 1. x \\<in> states c &&& y \\<in> states c", "by auto"], ["proof (state)\nthis:\n  x \\<in> states c\n  y \\<in> states c\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>x \\<in> A; a \\<in> states x; xa \\<in> A;\n        b \\<in> states xa\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (\\<Union> (en ` A))\\<^sup>*", "with A[OF \\<open>c \\<in> A\\<close>] \\<open>c \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  sc c\n  c \\<in> A\n  x \\<in> states c\n  y \\<in> states c", "have \"(x, y) \\<in> (en c)\\<^sup>*\""], ["proof (prove)\nusing this:\n  sc c\n  c \\<in> A\n  x \\<in> states c\n  y \\<in> states c\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (en c)\\<^sup>*", "by (auto simp: sc_def subset_eq)"], ["proof (state)\nthis:\n  (x, y) \\<in> (en c)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>x \\<in> A; a \\<in> states x; xa \\<in> A;\n        b \\<in> states xa\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (\\<Union> (en ` A))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (en c)\\<^sup>*", "show \"(x, y) \\<in> (\\<Union>x\\<in>A. en x)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (en c)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (\\<Union> (en ` A))\\<^sup>*", "using rtrancl_mono[of \"en c\" \"\\<Union>a\\<in>A. en a\"] \\<open>c\\<in>A\\<close>"], ["proof (prove)\nusing this:\n  (x, y) \\<in> (en c)\\<^sup>*\n  en c \\<subseteq> \\<Union> (en ` A) \\<Longrightarrow>\n  (en c)\\<^sup>* \\<subseteq> (\\<Union> (en ` A))\\<^sup>*\n  c \\<in> A\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (\\<Union> (en ` A))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> (\\<Union> (en ` A))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sc_supI:\n  assumes \\<phi>: \"sc \\<phi>\" and \\<psi>: \"sc \\<psi>\" and not_disjoint: \"\\<phi> \\<sqinter> \\<psi> \\<noteq> bot\"\n  shows \"sc (\\<phi> \\<squnion> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc (\\<phi> \\<squnion> \\<psi>)", "unfolding sc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. states (\\<phi> \\<squnion> \\<psi>) \\<times>\n    states (\\<phi> \\<squnion> \\<psi>)\n    \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "assume \"x \\<in> states (\\<phi> \\<squnion> \\<psi>)\" \"y \\<in> states (\\<phi> \\<squnion> \\<psi>)\""], ["proof (state)\nthis:\n  x \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  y \\<in> states (\\<phi> \\<squnion> \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  x \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  y \\<in> states (\\<phi> \\<squnion> \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "obtain z where \"z \\<in> states \\<phi>\" \"z \\<in> states \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> states \\<phi>; z \\<in> states \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_disjoint"], ["proof (prove)\nusing this:\n  \\<phi> \\<sqinter> \\<psi> \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> states \\<phi>; z \\<in> states \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: inf_eq_bot_eq_disjnt_states disjnt_def)"], ["proof (state)\nthis:\n  z \\<in> states \\<phi>\n  z \\<in> states \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  z \\<in> states \\<phi>\n  z \\<in> states \\<psi>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "have \"(en \\<phi>)\\<^sup>* \\<union> (en \\<psi>)\\<^sup>* \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (en \\<phi>)\\<^sup>* \\<union> (en \\<psi>)\\<^sup>*\n    \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "by (metis rtrancl_Un_subset en_sup)"], ["proof (state)\nthis:\n  (en \\<phi>)\\<^sup>* \\<union> (en \\<psi>)\\<^sup>*\n  \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  y \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  z \\<in> states \\<phi>\n  z \\<in> states \\<psi>\n  (en \\<phi>)\\<^sup>* \\<union> (en \\<psi>)\\<^sup>*\n  \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "have \"(x, z) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\" \"(z, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\""], ["proof (prove)\nusing this:\n  x \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  y \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  z \\<in> states \\<phi>\n  z \\<in> states \\<psi>\n  (en \\<phi>)\\<^sup>* \\<union> (en \\<psi>)\\<^sup>*\n  \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>* &&&\n    (z, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "using \\<phi> \\<psi>"], ["proof (prove)\nusing this:\n  x \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  y \\<in> states (\\<phi> \\<squnion> \\<psi>)\n  z \\<in> states \\<phi>\n  z \\<in> states \\<psi>\n  (en \\<phi>)\\<^sup>* \\<union> (en \\<psi>)\\<^sup>*\n  \\<subseteq> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n  sc \\<phi>\n  sc \\<psi>\n\ngoal (1 subgoal):\n 1. (x, z) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>* &&&\n    (z, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "by (auto dest: scD)"], ["proof (state)\nthis:\n  (x, z) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n  (z, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> states (\\<phi> \\<squnion> \\<psi>);\n        b \\<in> states (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  (x, z) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n  (z, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "show \"(x, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, z) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n  (z, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> (en (\\<phi> \\<squnion> \\<psi>))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sc_eq_loop:\n  assumes M: \"sc M\" and s: \"s \\<in> M\" \"actions M s = {return_pmf s}\" shows \"M = loop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = loop s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M = loop s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. M = loop s", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. M = loop s", "assume \"t \\<in> M\""], ["proof (state)\nthis:\n  t \\<in> states M\n\ngoal (1 subgoal):\n 1. M = loop s", "then"], ["proof (chain)\npicking this:\n  t \\<in> states M", "have \"(s, t) \\<in> (en M)\\<^sup>*\""], ["proof (prove)\nusing this:\n  t \\<in> states M\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> (en M)\\<^sup>*", "using M[THEN scD, OF \\<open>s \\<in> M\\<close> \\<open>t \\<in> M\\<close>]"], ["proof (prove)\nusing this:\n  t \\<in> states M\n  (s, t) \\<in> (en M)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> (en M)\\<^sup>*", "by simp"], ["proof (state)\nthis:\n  (s, t) \\<in> (en M)\\<^sup>*\n\ngoal (1 subgoal):\n 1. M = loop s", "from this"], ["proof (chain)\npicking this:\n  (s, t) \\<in> (en M)\\<^sup>*", "have \"t = s\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> (en M)\\<^sup>*\n\ngoal (1 subgoal):\n 1. t = s", "by (induction rule: rtrancl_induct) (auto simp: en_def \\<open>actions M s = {return_pmf s}\\<close>)"], ["proof (state)\nthis:\n  t = s\n\ngoal (1 subgoal):\n 1. M = loop s", "}"], ["proof (state)\nthis:\n  ?t2 \\<in> states M \\<Longrightarrow> ?t2 = s\n\ngoal (1 subgoal):\n 1. M = loop s", "then"], ["proof (chain)\npicking this:\n  ?t2 \\<in> states M \\<Longrightarrow> ?t2 = s", "have \"states M = {s}\""], ["proof (prove)\nusing this:\n  ?t2 \\<in> states M \\<Longrightarrow> ?t2 = s\n\ngoal (1 subgoal):\n 1. states M = {s}", "using \\<open>s \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  ?t2 \\<in> states M \\<Longrightarrow> ?t2 = s\n  s \\<in> states M\n\ngoal (1 subgoal):\n 1. states M = {s}", "by blast"], ["proof (state)\nthis:\n  states M = {s}\n\ngoal (1 subgoal):\n 1. M = loop s", "then"], ["proof (chain)\npicking this:\n  states M = {s}", "show ?thesis"], ["proof (prove)\nusing this:\n  states M = {s}\n\ngoal (1 subgoal):\n 1. M = loop s", "by (intro mdpc_eqI) (auto simp: \\<open>actions M s = {return_pmf s}\\<close>)"], ["proof (state)\nthis:\n  M = loop s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sc_eq_trivial:\n  assumes M: \"sc M\" and s: \"s \\<in> M\" \"actions M s = {}\" shows \"M = trivial s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M = trivial s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M = trivial s", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. M = trivial s", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. M = trivial s", "assume \"t \\<in> M\" \"t \\<noteq> s\""], ["proof (state)\nthis:\n  t \\<in> states M\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. M = trivial s", "then"], ["proof (chain)\npicking this:\n  t \\<in> states M\n  t \\<noteq> s", "have \"(s, t) \\<in> (en M)\\<^sup>+\""], ["proof (prove)\nusing this:\n  t \\<in> states M\n  t \\<noteq> s\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> (en M)\\<^sup>+", "using M[THEN scD, OF \\<open>s \\<in> M\\<close> \\<open>t \\<in> M\\<close>]"], ["proof (prove)\nusing this:\n  t \\<in> states M\n  t \\<noteq> s\n  (s, t) \\<in> (en M)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> (en M)\\<^sup>+", "by (simp add: rtrancl_eq_or_trancl)"], ["proof (state)\nthis:\n  (s, t) \\<in> (en M)\\<^sup>+\n\ngoal (1 subgoal):\n 1. M = trivial s", "from tranclD[OF this] \\<open>actions M s = {}\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>z. (s, z) \\<in> en M \\<and> (z, t) \\<in> (en M)\\<^sup>*\n  actions M s = {}", "have False"], ["proof (prove)\nusing this:\n  \\<exists>z. (s, z) \\<in> en M \\<and> (z, t) \\<in> (en M)\\<^sup>*\n  actions M s = {}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: en_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M = trivial s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?t2 \\<in> states M; ?t2 \\<noteq> s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. M = trivial s", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?t2 \\<in> states M; ?t2 \\<noteq> s\\<rbrakk>\n  \\<Longrightarrow> False", "have \"states M = {s}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?t2 \\<in> states M; ?t2 \\<noteq> s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. states M = {s}", "using \\<open>s \\<in> M\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t2 \\<in> states M; ?t2 \\<noteq> s\\<rbrakk>\n  \\<Longrightarrow> False\n  s \\<in> states M\n\ngoal (1 subgoal):\n 1. states M = {s}", "by auto"], ["proof (state)\nthis:\n  states M = {s}\n\ngoal (1 subgoal):\n 1. M = trivial s", "then"], ["proof (chain)\npicking this:\n  states M = {s}", "show ?thesis"], ["proof (prove)\nusing this:\n  states M = {s}\n\ngoal (1 subgoal):\n 1. M = trivial s", "by (intro mdpc_eqI) (auto simp: \\<open>actions M s = {}\\<close>)"], ["proof (state)\nthis:\n  M = trivial s\n\ngoal:\nNo subgoals!", "qed"], ["", "definition closed_mdpc :: \"'s mdpc \\<Rightarrow> bool\"\n  where \"closed_mdpc \\<phi> \\<longleftrightarrow> en \\<phi> \\<subseteq> states \\<phi> \\<times> states \\<phi>\""], ["", "lemma closed_mdpcD: \"closed_mdpc \\<phi> \\<Longrightarrow> D \\<in> actions \\<phi> x \\<Longrightarrow> y \\<in> D \\<Longrightarrow> y \\<in> states \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_mdpc \\<phi>; D \\<in> actions \\<phi> x;\n     y \\<in> set_pmf D\\<rbrakk>\n    \\<Longrightarrow> y \\<in> states \\<phi>", "by (auto simp: closed_mdpc_def en_def)"], ["", "lemma closed_mdpc_supI: \"closed_mdpc \\<phi> \\<Longrightarrow> closed_mdpc \\<psi> \\<Longrightarrow> closed_mdpc (\\<phi> \\<squnion> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_mdpc \\<phi>; closed_mdpc \\<psi>\\<rbrakk>\n    \\<Longrightarrow> closed_mdpc (\\<phi> \\<squnion> \\<psi>)", "by (auto simp: closed_mdpc_def)"], ["", "lemma closed_mdpc_SupI: \"(\\<And>a. a \\<in> A \\<Longrightarrow> closed_mdpc a) \\<Longrightarrow> closed_mdpc (\\<Squnion>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> closed_mdpc a) \\<Longrightarrow>\n    closed_mdpc (\\<Squnion> A)", "by (auto simp: closed_mdpc_def)"], ["", "lemma closed_mdpc_infI: \"closed_mdpc \\<phi> \\<Longrightarrow> closed_mdpc \\<psi> \\<Longrightarrow> closed_mdpc (\\<phi> \\<sqinter> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_mdpc \\<phi>; closed_mdpc \\<psi>\\<rbrakk>\n    \\<Longrightarrow> closed_mdpc (\\<phi> \\<sqinter> \\<psi>)", "using en_mono[of \"\\<phi> \\<sqinter> \\<psi>\" \\<phi>] en_mono[of \"\\<phi> \\<sqinter> \\<psi>\" \\<psi>]"], ["proof (prove)\nusing this:\n  \\<phi> \\<sqinter> \\<psi> \\<le> \\<phi> \\<Longrightarrow>\n  en (\\<phi> \\<sqinter> \\<psi>) \\<subseteq> en \\<phi>\n  \\<phi> \\<sqinter> \\<psi> \\<le> \\<psi> \\<Longrightarrow>\n  en (\\<phi> \\<sqinter> \\<psi>) \\<subseteq> en \\<psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_mdpc \\<phi>; closed_mdpc \\<psi>\\<rbrakk>\n    \\<Longrightarrow> closed_mdpc (\\<phi> \\<sqinter> \\<psi>)", "by (auto simp: closed_mdpc_def lift_option_eq_Some)"], ["", "lemma closed_mdpc_trivial[simp]: \"closed_mdpc (trivial s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (trivial s)", "by (simp add: closed_mdpc_def)"], ["", "lemma closed_mdpc_bot[simp]: \"closed_mdpc bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc \\<bottom>", "by (simp add: closed_mdpc_def)"], ["", "lemma closed_mdpc_loop[simp]: \"closed_mdpc (loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (loop s)", "by (auto simp: closed_mdpc_def)"], ["", "lemma closed_mdpc_fix_loop: \"closed_mdpc M \\<Longrightarrow> closed_mdpc (fix_loop s M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc M \\<Longrightarrow> closed_mdpc (fix_loop s M)", "by (auto simp: closed_mdpc_def)"], ["", "lemma closed_mdpc_map: assumes M: \"closed_mdpc M\" shows \"closed_mdpc (map_mdpc f M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (map_mdpc f M)", "using closed_mdpcD[OF M]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?D \\<in> actions M ?x; ?y \\<in> set_pmf ?D\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> states M\n\ngoal (1 subgoal):\n 1. closed_mdpc (map_mdpc f M)", "by (auto simp: closed_mdpc_def en_def actions_map_mdpc states_map_mdpc intro!: imageI intro: in_states)"], ["", "definition close :: \"'s mdpc \\<Rightarrow> 's mdpc\"\n  where \"close \\<phi> = map_actions (\\<lambda>s A. {a\\<in>A. set_pmf a \\<subseteq> states \\<phi>}) \\<phi>\""], ["", "lemma\n  shows states_close[simp]: \"states (close \\<phi>) = states \\<phi>\"\n    and actions_close[simp]: \"actions (close \\<phi>) s = {a\\<in>actions \\<phi> s. a \\<subseteq> states \\<phi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states (close \\<phi>) = states \\<phi> &&&\n    actions (close \\<phi>) s =\n    {a \\<in> actions \\<phi> s. set_pmf a \\<subseteq> states \\<phi>}", "by (auto simp: close_def)"], ["", "lemma closed_close: \"closed_mdpc (close \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (close \\<phi>)", "by (auto simp add: closed_mdpc_def en_def intro: in_states)"], ["", "lemma close_closed: \"closed_mdpc \\<phi> \\<Longrightarrow> close \\<phi> = \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc \\<phi> \\<Longrightarrow> close \\<phi> = \\<phi>", "unfolding closed_mdpc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. en \\<phi>\n    \\<subseteq> states \\<phi> \\<times> states \\<phi> \\<Longrightarrow>\n    close \\<phi> = \\<phi>", "by (intro mdpc_eqI) (auto simp: en_def)"], ["", "lemma close_close: \"close (close \\<phi>) = close \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close (close \\<phi>) = close \\<phi>", "by (simp add: closed_close close_closed)"], ["", "lemma close_le: \"close M \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close M \\<le> M", "unfolding close_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_actions (\\<lambda>s A. {a \\<in> A. set_pmf a \\<subseteq> states M})\n     M\n    \\<le> M", "by (intro map_actions_le) auto"], ["", "lemma close_mono: \"\\<phi> \\<le> \\<psi> \\<Longrightarrow> close \\<phi> \\<le> close \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow> close \\<phi> \\<le> close \\<psi>", "using states_mono[of \\<phi> \\<psi>] actions_mono[of \\<phi> \\<psi>]"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n  states \\<phi> \\<subseteq> states \\<psi>\n  \\<phi> \\<le> \\<psi> \\<Longrightarrow> actions \\<phi> \\<le> actions \\<psi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow> close \\<phi> \\<le> close \\<psi>", "unfolding close_def"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n  states \\<phi> \\<subseteq> states \\<psi>\n  \\<phi> \\<le> \\<psi> \\<Longrightarrow> actions \\<phi> \\<le> actions \\<psi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<le> \\<psi> \\<Longrightarrow>\n    map_actions\n     (\\<lambda>s A. {a \\<in> A. set_pmf a \\<subseteq> states \\<phi>}) \\<phi>\n    \\<le> map_actions\n           (\\<lambda>s A. {a \\<in> A. set_pmf a \\<subseteq> states \\<psi>})\n           \\<psi>", "by (intro le_mdpcI) (auto simp: le_fun_def)"], ["", "text \\<open>End Component (EC)\\<close>"], ["", "definition ec :: \"'s mdpc \\<Rightarrow> bool\"\n  where \"ec \\<phi> \\<longleftrightarrow> sc \\<phi> \\<and> closed_mdpc \\<phi>\""], ["", "lemma ec_trivial[simp]: \"ec (trivial s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ec (trivial s)", "by (auto simp: ec_def)"], ["", "lemma ec_bot[simp]: \"ec bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ec \\<bottom>", "by (auto simp: ec_def)"], ["", "lemma ec_loop[simp]: \"ec (loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ec (loop s)", "by (auto simp: ec_def)"], ["", "lemma ec_sup: \"ec \\<phi> \\<Longrightarrow> ec \\<psi> \\<Longrightarrow> \\<phi> \\<sqinter> \\<psi> \\<noteq> bot \\<Longrightarrow> ec (\\<phi> \\<squnion> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ec \\<phi>; ec \\<psi>;\n     \\<phi> \\<sqinter> \\<psi> \\<noteq> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> ec (\\<phi> \\<squnion> \\<psi>)", "by (simp add: ec_def sc_supI closed_mdpc_supI)"], ["", "lemma ec_Sup_directed:\n  \"(\\<And>a. a \\<in> A \\<Longrightarrow> ec a) \\<Longrightarrow> (\\<And>a b. a \\<in> A \\<Longrightarrow> b \\<in> A \\<Longrightarrow> \\<exists>c\\<in>A. a \\<le> c \\<and> b \\<le> c) \\<Longrightarrow> ec (\\<Squnion>A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>a. a \\<in> A \\<Longrightarrow> ec a;\n     \\<And>a b.\n        \\<lbrakk>a \\<in> A; b \\<in> A\\<rbrakk>\n        \\<Longrightarrow> \\<exists>c\\<in>A.\n                             a \\<le> c \\<and> b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> ec (\\<Squnion> A)", "by (auto simp: ec_def closed_mdpc_SupI sc_SupI_directed)"], ["", "text \\<open>Maximal End Component (MEC) relative to @{term M}\\<close>"], ["", "definition mec :: \"'s mdpc \\<Rightarrow> 's mdpc \\<Rightarrow> bool\"\n  where \"mec M \\<phi> \\<longleftrightarrow> ec \\<phi> \\<and> \\<phi> \\<le> M \\<and> (\\<forall>\\<psi>\\<le>M. ec \\<psi> \\<longrightarrow> \\<phi> \\<le> \\<psi> \\<longrightarrow> \\<phi> = \\<psi>)\""], ["", "lemma mec_refl: \"ec M \\<Longrightarrow> mec M M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ec M \\<Longrightarrow> mec M M", "by (auto simp: mec_def)"], ["", "lemma mec_le: \"mec M \\<phi> \\<Longrightarrow> \\<phi> \\<le> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec M \\<phi> \\<Longrightarrow> \\<phi> \\<le> M", "by (auto simp: mec_def)"], ["", "lemma mec_ec: \"mec M \\<phi> \\<Longrightarrow> ec \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec M \\<phi> \\<Longrightarrow> ec \\<phi>", "by (auto simp: mec_def)"], ["", "lemma mec_least: \"mec M \\<phi> \\<Longrightarrow> \\<psi> \\<le> M \\<Longrightarrow> \\<phi> \\<le> \\<psi> \\<Longrightarrow> ec \\<psi> \\<Longrightarrow> \\<phi> \\<ge> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mec M \\<phi>; \\<psi> \\<le> M; \\<phi> \\<le> \\<psi>;\n     ec \\<psi>\\<rbrakk>\n    \\<Longrightarrow> \\<psi> \\<le> \\<phi>", "by (auto simp: mec_def)"], ["", "lemma mec_bot_imp_bot: assumes \"mec \\<phi> bot\" shows \"\\<phi> = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> = \\<bottom>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> \\<bottom> \\<Longrightarrow> False", "assume \"\\<phi> \\<noteq> bot\""], ["proof (state)\nthis:\n  \\<phi> \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> \\<bottom> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<phi> \\<noteq> \\<bottom>", "obtain x where \"x \\<in> states \\<phi>\""], ["proof (prove)\nusing this:\n  \\<phi> \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> states \\<phi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq_bot_iff_states"], ["proof (prove)\nusing this:\n  states \\<phi> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> states \\<phi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> states \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> \\<bottom> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> states \\<phi>", "have \"ec (trivial x)\" \"trivial x \\<le> \\<phi>\""], ["proof (prove)\nusing this:\n  x \\<in> states \\<phi>\n\ngoal (1 subgoal):\n 1. ec (trivial x) &&& trivial x \\<le> \\<phi>", "by (auto intro: trivial_le)"], ["proof (state)\nthis:\n  ec (trivial x)\n  trivial x \\<le> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> \\<bottom> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ec (trivial x)\n  trivial x \\<le> \\<phi>", "have \"trivial x = bot\""], ["proof (prove)\nusing this:\n  ec (trivial x)\n  trivial x \\<le> \\<phi>\n\ngoal (1 subgoal):\n 1. trivial x = \\<bottom>", "using \\<open>mec \\<phi> bot\\<close>"], ["proof (prove)\nusing this:\n  ec (trivial x)\n  trivial x \\<le> \\<phi>\n  mec \\<phi> \\<bottom>\n\ngoal (1 subgoal):\n 1. trivial x = \\<bottom>", "by (auto simp: mec_def)"], ["proof (state)\nthis:\n  trivial x = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<phi> \\<noteq> \\<bottom> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  trivial x = \\<bottom>", "show False"], ["proof (prove)\nusing this:\n  trivial x = \\<bottom>\n\ngoal (1 subgoal):\n 1. False", "by (simp add: trivial_neq_bot)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mec_imp_bot_eq_bot: \"mec \\<phi> \\<psi> \\<Longrightarrow> \\<phi> = bot \\<longleftrightarrow> \\<psi> = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec \\<phi> \\<psi> \\<Longrightarrow>\n    (\\<phi> = \\<bottom>) = (\\<psi> = \\<bottom>)", "using mec_bot_imp_bot[of \\<phi>]"], ["proof (prove)\nusing this:\n  mec \\<phi> \\<bottom> \\<Longrightarrow> \\<phi> = \\<bottom>\n\ngoal (1 subgoal):\n 1. mec \\<phi> \\<psi> \\<Longrightarrow>\n    (\\<phi> = \\<bottom>) = (\\<psi> = \\<bottom>)", "by (auto simp: mec_def)"], ["", "lemma mec_unique: assumes \\<phi>: \"mec M \\<phi>\" and \\<psi>: \"mec M \\<psi>\" and \"\\<phi> \\<sqinter> \\<psi> \\<noteq> bot\" shows \"\\<phi> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> = \\<psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> = \\<psi>", "have \"mec M (\\<phi> \\<squnion> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec M (\\<phi> \\<squnion> \\<psi>)", "using assms"], ["proof (prove)\nusing this:\n  mec M \\<phi>\n  mec M \\<psi>\n  \\<phi> \\<sqinter> \\<psi> \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. mec M (\\<phi> \\<squnion> \\<psi>)", "by (auto intro!: mec_def[THEN iffD2] ec_sup antisym dest: mec_ec mec_le)\n       (blast intro: le_supI1 mec_least[of M])"], ["proof (state)\nthis:\n  mec M (\\<phi> \\<squnion> \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<phi> = \\<psi>", "with mec_least[OF \\<phi>, of \"\\<phi> \\<squnion> \\<psi>\"] mec_least[OF \\<psi>,  of \"\\<phi> \\<squnion> \\<psi>\"] mec_le[OF this] mec_ec[OF this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<phi> \\<squnion> \\<psi> \\<le> M;\n   \\<phi> \\<le> \\<phi> \\<squnion> \\<psi>;\n   ec (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n  \\<Longrightarrow> \\<phi> \\<squnion> \\<psi> \\<le> \\<phi>\n  \\<lbrakk>\\<phi> \\<squnion> \\<psi> \\<le> M;\n   \\<psi> \\<le> \\<phi> \\<squnion> \\<psi>;\n   ec (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n  \\<Longrightarrow> \\<phi> \\<squnion> \\<psi> \\<le> \\<psi>\n  \\<phi> \\<squnion> \\<psi> \\<le> M\n  ec (\\<phi> \\<squnion> \\<psi>)\n  mec M (\\<phi> \\<squnion> \\<psi>)", "show \"\\<phi> = \\<psi>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<phi> \\<squnion> \\<psi> \\<le> M;\n   \\<phi> \\<le> \\<phi> \\<squnion> \\<psi>;\n   ec (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n  \\<Longrightarrow> \\<phi> \\<squnion> \\<psi> \\<le> \\<phi>\n  \\<lbrakk>\\<phi> \\<squnion> \\<psi> \\<le> M;\n   \\<psi> \\<le> \\<phi> \\<squnion> \\<psi>;\n   ec (\\<phi> \\<squnion> \\<psi>)\\<rbrakk>\n  \\<Longrightarrow> \\<phi> \\<squnion> \\<psi> \\<le> \\<psi>\n  \\<phi> \\<squnion> \\<psi> \\<le> M\n  ec (\\<phi> \\<squnion> \\<psi>)\n  mec M (\\<phi> \\<squnion> \\<psi>)\n\ngoal (1 subgoal):\n 1. \\<phi> = \\<psi>", "by auto"], ["proof (state)\nthis:\n  \\<phi> = \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mec_exists: assumes \\<phi>: \"\\<phi> \\<noteq> bot\" \"ec \\<phi>\" and M: \"\\<phi> \\<le> M\" shows \"\\<exists>\\<psi>\\<ge>\\<phi>. mec M \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<psi>\\<ge>\\<phi>. mec M \\<psi>", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> \\<le> ?\\<psi>\n 2. mec M ?\\<psi>", "show \"\\<phi> \\<le> \\<Squnion>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n    \\<le> \\<Squnion> {\\<psi>.\n                      \\<phi> \\<le> \\<psi> \\<and>\n                      \\<psi> \\<le> M \\<and> ec \\<psi>}", "using \\<phi> M"], ["proof (prove)\nusing this:\n  \\<phi> \\<noteq> \\<bottom>\n  ec \\<phi>\n  \\<phi> \\<le> M\n\ngoal (1 subgoal):\n 1. \\<phi>\n    \\<le> \\<Squnion> {\\<psi>.\n                      \\<phi> \\<le> \\<psi> \\<and>\n                      \\<psi> \\<le> M \\<and> ec \\<psi>}", "by (intro Sup_upper) auto"], ["proof (state)\nthis:\n  \\<phi>\n  \\<le> \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n\ngoal (1 subgoal):\n 1. mec M\n     (\\<Squnion> {\\<psi>.\n                  \\<phi> \\<le> \\<psi> \\<and>\n                  \\<psi> \\<le> M \\<and> ec \\<psi>})", "show \"mec M (\\<Squnion>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec M\n     (\\<Squnion> {\\<psi>.\n                  \\<phi> \\<le> \\<psi> \\<and>\n                  \\<psi> \\<le> M \\<and> ec \\<psi>})", "unfolding mec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ec (\\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}) \\<and>\n    \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M \\<and>\n    (\\<forall>\\<psi>\\<le>M.\n        ec \\<psi> \\<longrightarrow>\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi> \\<longrightarrow>\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>} =\n        \\<psi>)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. ec (\\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>})\n 2. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 3. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "show \"ec (\\<Squnion>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ec (\\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>})", "proof (safe intro!: ec_Sup_directed)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<phi> \\<le> a; \\<phi> \\<le> b; a \\<le> M; ec a; b \\<le> M;\n        ec b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>{\\<psi>.\n   \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}.\n                            a \\<le> c \\<and> b \\<le> c", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<phi> \\<le> a; \\<phi> \\<le> b; a \\<le> M; ec a; b \\<le> M;\n        ec b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>{\\<psi>.\n   \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}.\n                            a \\<le> c \\<and> b \\<le> c", "assume *: \"\\<phi> \\<le> a\" \"\\<phi> \\<le> b\" and \"a \\<le> M\" \"b \\<le> M\" \"ec a\" \"ec b\""], ["proof (state)\nthis:\n  \\<phi> \\<le> a\n  \\<phi> \\<le> b\n  a \\<le> M\n  b \\<le> M\n  ec a\n  ec b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<phi> \\<le> a; \\<phi> \\<le> b; a \\<le> M; ec a; b \\<le> M;\n        ec b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>{\\<psi>.\n   \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}.\n                            a \\<le> c \\<and> b \\<le> c", "moreover"], ["proof (state)\nthis:\n  \\<phi> \\<le> a\n  \\<phi> \\<le> b\n  a \\<le> M\n  b \\<le> M\n  ec a\n  ec b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<phi> \\<le> a; \\<phi> \\<le> b; a \\<le> M; ec a; b \\<le> M;\n        ec b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>{\\<psi>.\n   \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}.\n                            a \\<le> c \\<and> b \\<le> c", "have \"a \\<sqinter> b \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<sqinter> b \\<noteq> \\<bottom>", "using * \\<phi> bot_unique[of \"\\<phi>\"] le_inf_iff[of \\<phi> a b]"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> a\n  \\<phi> \\<le> b\n  \\<phi> \\<noteq> \\<bottom>\n  ec \\<phi>\n  (\\<phi> \\<le> \\<bottom>) = (\\<phi> = \\<bottom>)\n  (\\<phi> \\<le> a \\<sqinter> b) = (\\<phi> \\<le> a \\<and> \\<phi> \\<le> b)\n\ngoal (1 subgoal):\n 1. a \\<sqinter> b \\<noteq> \\<bottom>", "by (auto simp del: inf.bounded_iff)"], ["proof (state)\nthis:\n  a \\<sqinter> b \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<phi> \\<le> a; \\<phi> \\<le> b; a \\<le> M; ec a; b \\<le> M;\n        ec b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<in>{\\<psi>.\n   \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}.\n                            a \\<le> c \\<and> b \\<le> c", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> \\<le> a\n  \\<phi> \\<le> b\n  a \\<le> M\n  b \\<le> M\n  ec a\n  ec b\n  a \\<sqinter> b \\<noteq> \\<bottom>", "show \"\\<exists>c\\<in>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}. a \\<le> c \\<and> b \\<le> c\""], ["proof (prove)\nusing this:\n  \\<phi> \\<le> a\n  \\<phi> \\<le> b\n  a \\<le> M\n  b \\<le> M\n  ec a\n  ec b\n  a \\<sqinter> b \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>{\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}.\n       a \\<le> c \\<and> b \\<le> c", "by (intro bexI[of _ \"sup a b\"]) (auto intro: le_supI1 intro!: ec_sup)"], ["proof (state)\nthis:\n  \\<exists>c\\<in>{\\<psi>.\n                  \\<phi> \\<le> \\<psi> \\<and>\n                  \\<psi> \\<le> M \\<and> ec \\<psi>}.\n     a \\<le> c \\<and> b \\<le> c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ec (\\<Squnion> {\\<psi>.\n                  \\<phi> \\<le> \\<psi> \\<and>\n                  \\<psi> \\<le> M \\<and> ec \\<psi>})\n\ngoal (2 subgoals):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 2. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "fix \\<psi>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 2. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "assume \\<psi>: \"\\<psi> \\<le> M\" \"ec \\<psi>\" \"\\<Squnion>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>} \\<le> \\<psi>\""], ["proof (state)\nthis:\n  \\<psi> \\<le> M\n  ec \\<psi>\n  \\<Squnion> {\\<psi>.\n              \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n  \\<le> \\<psi>\n\ngoal (2 subgoals):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 2. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "have \"\\<phi> \\<le> \\<Squnion>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi>\n    \\<le> \\<Squnion> {\\<psi>.\n                      \\<phi> \\<le> \\<psi> \\<and>\n                      \\<psi> \\<le> M \\<and> ec \\<psi>}", "using assms"], ["proof (prove)\nusing this:\n  \\<phi> \\<noteq> \\<bottom>\n  ec \\<phi>\n  \\<phi> \\<le> M\n\ngoal (1 subgoal):\n 1. \\<phi>\n    \\<le> \\<Squnion> {\\<psi>.\n                      \\<phi> \\<le> \\<psi> \\<and>\n                      \\<psi> \\<le> M \\<and> ec \\<psi>}", "by (auto intro!: Sup_upper)"], ["proof (state)\nthis:\n  \\<phi>\n  \\<le> \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n\ngoal (2 subgoals):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 2. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "also"], ["proof (state)\nthis:\n  \\<phi>\n  \\<le> \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n\ngoal (2 subgoals):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 2. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "have \"\\<dots> \\<le> \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> \\<psi>", "by fact"], ["proof (state)\nthis:\n  \\<Squnion> {\\<psi>.\n              \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n  \\<le> \\<psi>\n\ngoal (2 subgoals):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M\n 2. \\<And>\\<psi>.\n       \\<lbrakk>\\<psi> \\<le> M; ec \\<psi>;\n        \\<Squnion> {\\<psi>.\n                    \\<phi> \\<le> \\<psi> \\<and>\n                    \\<psi> \\<le> M \\<and> ec \\<psi>}\n        \\<le> \\<psi>\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> {\\<psi>.\n                                     \\<phi> \\<le> \\<psi> \\<and>\n                                     \\<psi> \\<le> M \\<and> ec \\<psi>} =\n                         \\<psi>", "finally"], ["proof (chain)\npicking this:\n  \\<phi> \\<le> \\<psi>", "show \"\\<Squnion>{\\<psi>. \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>} = \\<psi>\""], ["proof (prove)\nusing this:\n  \\<phi> \\<le> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and>\n                \\<psi> \\<le> M \\<and> ec \\<psi>} =\n    \\<psi>", "using \\<psi>"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> \\<psi>\n  \\<psi> \\<le> M\n  ec \\<psi>\n  \\<Squnion> {\\<psi>.\n              \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n  \\<le> \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and>\n                \\<psi> \\<le> M \\<and> ec \\<psi>} =\n    \\<psi>", "by (intro antisym Sup_upper) auto"], ["proof (state)\nthis:\n  \\<Squnion> {\\<psi>.\n              \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>} =\n  \\<psi>\n\ngoal (1 subgoal):\n 1. \\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>}\n    \\<le> M", "qed (auto intro!: Sup_least)"], ["proof (state)\nthis:\n  mec M\n   (\\<Squnion> {\\<psi>.\n                \\<phi> \\<le> \\<psi> \\<and> \\<psi> \\<le> M \\<and> ec \\<psi>})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mec_exists': \"x \\<in> states M \\<Longrightarrow> \\<exists>\\<psi>. x \\<in> states \\<psi> \\<and> mec M \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> states M \\<Longrightarrow>\n    \\<exists>\\<psi>. x \\<in> states \\<psi> \\<and> mec M \\<psi>", "using mec_exists[of \"trivial x\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>trivial x \\<noteq> \\<bottom>; ec (trivial x);\n   trivial x \\<le> ?M\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<psi>\\<ge>trivial x. mec ?M \\<psi>\n\ngoal (1 subgoal):\n 1. x \\<in> states M \\<Longrightarrow>\n    \\<exists>\\<psi>. x \\<in> states \\<psi> \\<and> mec M \\<psi>", "by (auto simp: trivial_neq_bot trivial_le_iff)"], ["", "lemma mec_loop: \"x \\<in> states M \\<Longrightarrow> actions M x = {return_pmf x} \\<Longrightarrow> mec M (loop x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> states M; actions M x = {return_pmf x}\\<rbrakk>\n    \\<Longrightarrow> mec M (loop x)", "apply (auto simp: mec_def loop_le ec_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<psi>.\n       \\<lbrakk>x \\<in> states M; actions M x = {return_pmf x};\n        \\<psi> \\<le> M; sc \\<psi>; closed_mdpc \\<psi>;\n        x \\<in> states \\<psi>; return_pmf x \\<in> actions \\<psi> x\\<rbrakk>\n       \\<Longrightarrow> loop x = \\<psi>", "subgoal for \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> states M; actions M x = {return_pmf x}; \\<phi> \\<le> M;\n     sc \\<phi>; closed_mdpc \\<phi>; x \\<in> states \\<phi>;\n     return_pmf x \\<in> actions \\<phi> x\\<rbrakk>\n    \\<Longrightarrow> loop x = \\<phi>", "using sc_eq_loop[of \\<phi> x] actions_mono[of \\<phi> M, THEN le_funD, of x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>sc \\<phi>; x \\<in> states \\<phi>;\n   actions \\<phi> x = {return_pmf x}\\<rbrakk>\n  \\<Longrightarrow> \\<phi> = loop x\n  \\<phi> \\<le> M \\<Longrightarrow> actions \\<phi> x \\<subseteq> actions M x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> states M; actions M x = {return_pmf x}; \\<phi> \\<le> M;\n     sc \\<phi>; closed_mdpc \\<phi>; x \\<in> states \\<phi>;\n     return_pmf x \\<in> actions \\<phi> x\\<rbrakk>\n    \\<Longrightarrow> loop x = \\<phi>", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mec_fix_loop: \"mec (fix_loop s M) (loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec (fix_loop s M) (loop s)", "by (intro mec_loop) auto"], ["", "definition trivials :: \"'s mdpc \\<Rightarrow> 's set\"\n  where \"trivials M = {x. mec M (trivial x)}\""], ["", "lemma trivials_subset_states: \"trivials M \\<subseteq> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trivials M \\<subseteq> states M", "by (auto simp: trivials_def mec_def trivial_le_iff)"], ["", "text \\<open>Bottom MEC (BEMC) in @{term M}\\<close>"], ["", "definition bmec :: \"'s mdpc \\<Rightarrow> 's mdpc \\<Rightarrow> bool\"\n  where \"bmec M \\<phi> \\<longleftrightarrow> mec \\<phi> M \\<and> (\\<forall>s\\<in>states \\<phi>. actions \\<phi> s = actions M s)\""], ["", "definition actions' :: \"'s mdpc \\<Rightarrow> 's \\<Rightarrow> 's pmf set\"\n  where \"actions' M s = (if s \\<in> states M then actions M s else {return_pmf s})\""], ["", "lemma closed_mdpcD':\n  \"closed_mdpc M \\<Longrightarrow> s \\<in> states M \\<Longrightarrow> (\\<Union>D\\<in>actions' M s. set_pmf D) \\<subseteq> states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed_mdpc M; s \\<in> states M\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set_pmf ` actions' M s) \\<subseteq> states M", "by (auto simp: actions'_def dest: closed_mdpcD)"], ["", "locale Finite_MDP =\n  fixes M :: \"'s mdpc\"\n  assumes closed_M: \"closed_mdpc M\" and M_neq_bot: \"M \\<noteq> bot\"\n    and actions_neq_empty_M: \"\\<And>s. s \\<in> states M \\<Longrightarrow> actions M s \\<noteq> {}\"\n    and finite_states_M: \"finite M\"\n    and finite_actions_M: \"\\<And>s. finite (actions M s)\"\nbegin"], ["", "sublocale Finite_Markov_Decision_Process \"actions' M\" \"states M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Markov_Decision_Process (actions' M) (states M)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>s. actions' M s \\<noteq> {}\n 2. states M \\<noteq> {}\n 3. finite (states M)\n 4. \\<And>s.\n       s \\<in> states M \\<Longrightarrow>\n       \\<Union> (set_pmf ` actions' M s) \\<subseteq> states M\n 5. \\<And>s. s \\<in> states M \\<Longrightarrow> finite (actions' M s)", "show \"actions' M s \\<noteq> {}\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. actions' M s \\<noteq> {}", "using actions_neq_empty_M"], ["proof (prove)\nusing this:\n  ?s \\<in> states M \\<Longrightarrow> actions M ?s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. actions' M s \\<noteq> {}", "by (auto simp: actions'_def )"], ["proof (state)\nthis:\n  actions' M ?s \\<noteq> {}\n\ngoal (4 subgoals):\n 1. states M \\<noteq> {}\n 2. finite (states M)\n 3. \\<And>s.\n       s \\<in> states M \\<Longrightarrow>\n       \\<Union> (set_pmf ` actions' M s) \\<subseteq> states M\n 4. \\<And>s. s \\<in> states M \\<Longrightarrow> finite (actions' M s)", "show \"states M \\<noteq> {}\" \"finite M\" \"\\<And>s. finite (actions' M s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states M \\<noteq> {} &&&\n    finite (states M) &&& (\\<And>s. finite (actions' M s))", "using M_neq_bot finite_states_M finite_actions_M"], ["proof (prove)\nusing this:\n  M \\<noteq> \\<bottom>\n  finite (states M)\n  finite (actions M ?s)\n\ngoal (1 subgoal):\n 1. states M \\<noteq> {} &&&\n    finite (states M) &&& (\\<And>s. finite (actions' M s))", "by (auto simp: eq_bot_iff_states actions'_def)"], ["proof (state)\nthis:\n  states M \\<noteq> {}\n  finite (states M)\n  finite (actions' M ?s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> states M \\<Longrightarrow>\n       \\<Union> (set_pmf ` actions' M s) \\<subseteq> states M", "show \"s \\<in> states M \\<Longrightarrow> (\\<Union>D\\<in>actions' M s. set_pmf D) \\<subseteq> states M\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> states M \\<Longrightarrow>\n    \\<Union> (set_pmf ` actions' M s) \\<subseteq> states M", "using closed_M"], ["proof (prove)\nusing this:\n  closed_mdpc M\n\ngoal (1 subgoal):\n 1. s \\<in> states M \\<Longrightarrow>\n    \\<Union> (set_pmf ` actions' M s) \\<subseteq> states M", "by (rule closed_mdpcD')"], ["proof (state)\nthis:\n  ?s \\<in> states M \\<Longrightarrow>\n  \\<Union> (set_pmf ` actions' M ?s) \\<subseteq> states M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Finite_MDP_map_loop: \"Finite_MDP (map_mdpc f M \\<squnion> loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP (map_mdpc f M \\<squnion> loop s)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. closed_mdpc (map_mdpc f M \\<squnion> loop s)\n 2. map_mdpc f M \\<squnion> loop s \\<noteq> \\<bottom>\n 3. \\<And>sa.\n       sa \\<in> states (map_mdpc f M \\<squnion> loop s) \\<Longrightarrow>\n       actions (map_mdpc f M \\<squnion> loop s) sa \\<noteq> {}\n 4. finite (states (map_mdpc f M \\<squnion> loop s))\n 5. \\<And>sa. finite (actions (map_mdpc f M \\<squnion> loop s) sa)", "show \"closed_mdpc (map_mdpc f M \\<squnion> loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (map_mdpc f M \\<squnion> loop s)", "by (intro closed_mdpc_supI closed_mdpc_map closed_M closed_mdpc_loop)"], ["proof (state)\nthis:\n  closed_mdpc (map_mdpc f M \\<squnion> loop s)\n\ngoal (4 subgoals):\n 1. map_mdpc f M \\<squnion> loop s \\<noteq> \\<bottom>\n 2. \\<And>sa.\n       sa \\<in> states (map_mdpc f M \\<squnion> loop s) \\<Longrightarrow>\n       actions (map_mdpc f M \\<squnion> loop s) sa \\<noteq> {}\n 3. finite (states (map_mdpc f M \\<squnion> loop s))\n 4. \\<And>sa. finite (actions (map_mdpc f M \\<squnion> loop s) sa)", "show \"finite (actions (map_mdpc f M \\<squnion> loop s) t)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (actions (map_mdpc f M \\<squnion> loop s) t)", "by (auto simp: actions_loop intro!: finite_actions_map finite_states_M finite_actions_M)"], ["proof (state)\nthis:\n  finite (actions (map_mdpc f M \\<squnion> loop s) ?t1)\n\ngoal (3 subgoals):\n 1. map_mdpc f M \\<squnion> loop s \\<noteq> \\<bottom>\n 2. \\<And>sa.\n       sa \\<in> states (map_mdpc f M \\<squnion> loop s) \\<Longrightarrow>\n       actions (map_mdpc f M \\<squnion> loop s) sa \\<noteq> {}\n 3. finite (states (map_mdpc f M \\<squnion> loop s))", "show \"finite (map_mdpc f M \\<squnion> loop s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (states (map_mdpc f M \\<squnion> loop s))", "by (auto intro!: finite_states_M finite_states_map)"], ["proof (state)\nthis:\n  finite (states (map_mdpc f M \\<squnion> loop s))\n\ngoal (2 subgoals):\n 1. map_mdpc f M \\<squnion> loop s \\<noteq> \\<bottom>\n 2. \\<And>sa.\n       sa \\<in> states (map_mdpc f M \\<squnion> loop s) \\<Longrightarrow>\n       actions (map_mdpc f M \\<squnion> loop s) sa \\<noteq> {}", "qed (auto simp: loop_neq_bot states_map_mdpc actions_loop actions_map_mdpc dest: actions_neq_empty_M)"], ["", "lemma Finite_MDP_map_fix_loop: \"Finite_MDP (fix_loop s (map_mdpc f M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP (fix_loop s (map_mdpc f M))", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. closed_mdpc (fix_loop s (map_mdpc f M))\n 2. fix_loop s (map_mdpc f M) \\<noteq> \\<bottom>\n 3. \\<And>sa.\n       sa \\<in> states (fix_loop s (map_mdpc f M)) \\<Longrightarrow>\n       actions (fix_loop s (map_mdpc f M)) sa \\<noteq> {}\n 4. finite (states (fix_loop s (map_mdpc f M)))\n 5. \\<And>sa. finite (actions (fix_loop s (map_mdpc f M)) sa)", "show \"closed_mdpc (fix_loop s (map_mdpc f M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (fix_loop s (map_mdpc f M))", "by (intro closed_mdpc_supI closed_mdpc_map closed_M closed_mdpc_fix_loop)"], ["proof (state)\nthis:\n  closed_mdpc (fix_loop s (map_mdpc f M))\n\ngoal (4 subgoals):\n 1. fix_loop s (map_mdpc f M) \\<noteq> \\<bottom>\n 2. \\<And>sa.\n       sa \\<in> states (fix_loop s (map_mdpc f M)) \\<Longrightarrow>\n       actions (fix_loop s (map_mdpc f M)) sa \\<noteq> {}\n 3. finite (states (fix_loop s (map_mdpc f M)))\n 4. \\<And>sa. finite (actions (fix_loop s (map_mdpc f M)) sa)", "show \"finite (actions (fix_loop s (map_mdpc f M)) t)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (actions (fix_loop s (map_mdpc f M)) t)", "by (auto simp: actions_loop intro!: finite_actions_map finite_states_M finite_actions_M)"], ["proof (state)\nthis:\n  finite (actions (fix_loop s (map_mdpc f M)) ?t1)\n\ngoal (3 subgoals):\n 1. fix_loop s (map_mdpc f M) \\<noteq> \\<bottom>\n 2. \\<And>sa.\n       sa \\<in> states (fix_loop s (map_mdpc f M)) \\<Longrightarrow>\n       actions (fix_loop s (map_mdpc f M)) sa \\<noteq> {}\n 3. finite (states (fix_loop s (map_mdpc f M)))", "show \"finite (fix_loop s (map_mdpc f M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (states (fix_loop s (map_mdpc f M)))", "by (auto intro!: finite_states_M finite_states_map)"], ["proof (state)\nthis:\n  finite (states (fix_loop s (map_mdpc f M)))\n\ngoal (2 subgoals):\n 1. fix_loop s (map_mdpc f M) \\<noteq> \\<bottom>\n 2. \\<And>sa.\n       sa \\<in> states (fix_loop s (map_mdpc f M)) \\<Longrightarrow>\n       actions (fix_loop s (map_mdpc f M)) sa \\<noteq> {}", "qed (auto simp: fix_loop_neq_bot states_map_mdpc actions_map_mdpc dest: actions_neq_empty_M)"], ["", "end"], ["", "context\n  fixes M :: \"'s mdpc\"\n    and F :: \"'s set\"\n  assumes M_neq_bot: \"M \\<noteq> bot\"\n    and closed_M: \"closed_mdpc M\"\n    and actions_neq_empty_M: \"\\<And>s. s \\<in> states M \\<Longrightarrow> actions M s \\<noteq> {}\"\n    and finite_states_M: \"finite M\"\n    and finite_actions_M: \"\\<And>s. finite (actions M s)\"\n    and F_subset: \"F \\<subseteq> states M\"\nbegin"], ["", "lemma finite_F[simp]: \"finite F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite F", "using F_subset finite_states_M"], ["proof (prove)\nusing this:\n  F \\<subseteq> states M\n  finite (states M)\n\ngoal (1 subgoal):\n 1. finite F", "by (auto dest: finite_subset)"], ["", "interpretation M: Finite_MDP M"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP M", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. closed_mdpc M\n 2. M \\<noteq> \\<bottom>\n 3. \\<And>s. s \\<in> states M \\<Longrightarrow> actions M s \\<noteq> {}\n 4. finite (states M)\n 5. \\<And>s. finite (actions M s)", "qed fact+"], ["", "interpretation M: Reachability_Problem \"actions' M\" \"states M\" \"states M - F\" F"], ["proof (prove)\ngoal (1 subgoal):\n 1. Reachability_Problem (actions' M) (states M) (states M - F) F", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. states M - F \\<subseteq> states M\n 2. F \\<subseteq> states M\n 3. (states M - F) \\<inter> F = {}", "qed (insert F_subset, auto)"], ["", "definition r :: \"'s \\<Rightarrow> 's option\"\n  where \"r s = (if s \\<in> F then None else Some s)\""], ["", "lemma r_eq_None[simp]: \"r s = None \\<longleftrightarrow> s \\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.r s = None) = (s \\<in> F)", "by (simp add: r_def)"], ["", "lemma r_eq_Some[simp]: \"r s = Some t \\<longleftrightarrow> (s \\<notin> F \\<and> s = t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.r s = Some t) = (s \\<notin> F \\<and> s = t)", "by (simp add: r_def)"], ["", "lemma r_in_Some_image: \"r s \\<in> Some ` X \\<longleftrightarrow> (s \\<notin> F \\<and> s \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.r s \\<in> Some ` X) = (s \\<notin> F \\<and> s \\<in> X)", "by (auto simp: r_def)"], ["", "lemma r_inj: \"s \\<notin> F \\<or> t \\<notin> F \\<Longrightarrow> r s = r t \\<longleftrightarrow> s = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> F \\<or> t \\<notin> F \\<Longrightarrow>\n    (local.r s = local.r t) = (s = t)", "by (auto simp: r_def)"], ["", "lemma shows r_F: \"s \\<in> F \\<Longrightarrow> r s = None\" and r_nF: \"s \\<notin> F \\<Longrightarrow> r s = Some s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> F \\<Longrightarrow> local.r s = None) &&&\n    (s \\<notin> F \\<Longrightarrow> local.r s = Some s)", "by auto"], ["", "definition R :: \"'s option mdpc\"\n  where \"R = fix_loop None (map_mdpc r M)\""], ["", "lemma closed_R: \"closed_mdpc R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc local.R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_mdpc (fix_loop None (map_mdpc local.r M))", "by (intro closed_mdpc_map closed_M closed_mdpc_fix_loop)"], ["", "lemma states_R[simp]: \"states R = Some ` (states M - F) \\<union> {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states local.R = Some ` (states M - F) \\<union> {None}", "by (auto simp add: R_def r_def[abs_def] states_map_mdpc)"], ["", "lemma actions_R_None[simp]:\n  \"actions R None = {return_pmf None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions local.R None = {return_pmf None}", "by (auto simp add: R_def)"], ["", "lemma actions_R_Some[simp]:\n  \"actions R (Some s) = (if s \\<in> F then {} else map_pmf r ` actions M s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions local.R (Some s) =\n    (if s \\<in> F then {} else map_pmf local.r ` actions M s)", "by (auto simp add: R_def actions_map_mdpc split: if_splits intro!: imageI)"], ["", "lemma mec_R_loop: \"mec R (loop None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mec local.R (loop None)", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mec (fix_loop None (map_mdpc local.r M)) (loop None)", "by (intro mec_fix_loop)"], ["", "interpretation R: Finite_MDP R"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP local.R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP (fix_loop None (map_mdpc local.r M))", "by (rule M.Finite_MDP_map_fix_loop)"], ["", "interpretation R: Reachability_Problem \"actions' R\" \"states R\" \"{None}\" \"{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Reachability_Problem (actions' local.R) (states local.R) {None} {}", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. {None} \\<subseteq> states local.R\n 2. {} \\<subseteq> states local.R\n 3. {None} \\<inter> {} = {}", "qed auto"], ["", "lemma F_not_trivial: \"s \\<in> F \\<Longrightarrow> Some s \\<notin> trivials R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> F \\<Longrightarrow> Some s \\<notin> trivials local.R", "by (auto simp: trivials_def mec_def trivial_le_iff)"], ["", "primrec min_state :: \"'s option \\<Rightarrow> 's + bool\"\n  where\n    \"min_state None = Inr True\"\n  | \"min_state (Some s) = (if Some s \\<in> trivials R then Inl s else Inr False)\""], ["", "lemma min_state_eq_Inl: \"min_state s = Inl t \\<longleftrightarrow> (Some t \\<in> trivials R \\<and> s = Some t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.min_state s = Inl t) =\n    (Some t \\<in> trivials local.R \\<and> s = Some t)", "by (cases s) auto"], ["", "lemma min_state_eq_Inr: \"min_state s = Inr b \\<longleftrightarrow> (if b then s = None else s \\<noteq> None \\<and> s \\<notin> trivials R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.min_state s = Inr b) =\n    (if b then s = None\n     else s \\<noteq> None \\<and> s \\<notin> trivials local.R)", "by (cases s) auto"], ["", "lemma map_min_state_R: \"map_mdpc min_state R = fix_loop (Inr True) (map_mdpc (min_state \\<circ> r) M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mdpc local.min_state local.R =\n    fix_loop (Inr True) (map_mdpc (local.min_state \\<circ> local.r) M)", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_mdpc local.min_state (fix_loop None (map_mdpc local.r M)) =\n    fix_loop (Inr True) (map_mdpc (local.min_state \\<circ> local.r) M)", "by (subst map_fix_loop)\n     (auto simp: map_mdpc_compose min_state_eq_Inr eq_commute[of \"Inr True\"])"], ["", "definition min_mdpc :: \"('s + bool) mdpc\"\n  where \"min_mdpc = fix_loop (Inr False) (map_mdpc min_state R)\""], ["", "lemma states_min_mdpc: \"states min_mdpc = {Inl t | t. Some t \\<in> trivials R} \\<union> {Inr True, Inr False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. states local.min_mdpc =\n    {Inl t |t. Some t \\<in> trivials local.R} \\<union> {Inr True, Inr False}", "using trivials_subset_states[of R]"], ["proof (prove)\nusing this:\n  trivials local.R \\<subseteq> states local.R\n\ngoal (1 subgoal):\n 1. states local.min_mdpc =\n    {Inl t |t. Some t \\<in> trivials local.R} \\<union> {Inr True, Inr False}", "by (auto simp add: min_mdpc_def states_map_mdpc image_comp split: if_splits)"], ["", "lemma actions_min_mdpc_Inl:\n  \"actions min_mdpc (Inl t) = (if Some t \\<in> trivials R then map_pmf (min_state \\<circ> r) ` actions M t else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions local.min_mdpc (Inl t) =\n    (if Some t \\<in> trivials local.R\n     then map_pmf (local.min_state \\<circ> local.r) ` actions M t else {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. actions local.min_mdpc (Inl t) =\n    (if Some t \\<in> trivials local.R\n     then map_pmf (local.min_state \\<circ> local.r) ` actions M t else {})", "have eq: \"min_state -` {Inl t} = (if Some t \\<in> trivials R then {Some t} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min_state -` {Inl t} =\n    (if Some t \\<in> trivials local.R then {Some t} else {})", "by (auto simp: min_state_eq_Inl)"], ["proof (state)\nthis:\n  local.min_state -` {Inl t} =\n  (if Some t \\<in> trivials local.R then {Some t} else {})\n\ngoal (1 subgoal):\n 1. actions local.min_mdpc (Inl t) =\n    (if Some t \\<in> trivials local.R\n     then map_pmf (local.min_state \\<circ> local.r) ` actions M t else {})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. actions local.min_mdpc (Inl t) =\n    (if Some t \\<in> trivials local.R\n     then map_pmf (local.min_state \\<circ> local.r) ` actions M t else {})", "using F_not_trivial[of t]"], ["proof (prove)\nusing this:\n  t \\<in> F \\<Longrightarrow> Some t \\<notin> trivials local.R\n\ngoal (1 subgoal):\n 1. actions local.min_mdpc (Inl t) =\n    (if Some t \\<in> trivials local.R\n     then map_pmf (local.min_state \\<circ> local.r) ` actions M t else {})", "by (simp add: min_mdpc_def actions_map_mdpc eq image_comp map_pmf_compose[symmetric])"], ["proof (state)\nthis:\n  actions local.min_mdpc (Inl t) =\n  (if Some t \\<in> trivials local.R\n   then map_pmf (local.min_state \\<circ> local.r) ` actions M t else {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma actions_min_mdpc_Inr: \"actions min_mdpc (Inr b) = {return_pmf (Inr b)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. actions local.min_mdpc (Inr b) = {return_pmf (Inr b)}", "by (simp add: min_mdpc_def map_min_state_R)"], ["", "interpretation min: Finite_MDP min_mdpc"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP local.min_mdpc", "unfolding min_mdpc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_MDP (fix_loop (Inr False) (map_mdpc local.min_state local.R))", "by (rule R.Finite_MDP_map_fix_loop)"], ["", "interpretation min: Reachability_Problem \"actions' min_mdpc\" \"states min_mdpc\" \"states min_mdpc - {Inr True}\" \"{Inr True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Reachability_Problem (actions' local.min_mdpc) (states local.min_mdpc)\n     (states local.min_mdpc - {Inr True}) {Inr True}", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. states local.min_mdpc - {Inr True} \\<subseteq> states local.min_mdpc\n 2. {Inr True} \\<subseteq> states local.min_mdpc\n 3. (states local.min_mdpc - {Inr True}) \\<inter> {Inr True} = {}", "qed (auto simp: states_min_mdpc)"], ["", "lemma M_n_eq_0_not_trivials:\n  assumes \"s \\<in> states M\" \"s \\<notin> F\" \"Some s \\<notin> trivials R\"\n  shows \"M.n s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M.n s = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. M.n s = 0", "have \"Some s \\<in> states R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some s \\<in> states local.R", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> states M\n  s \\<notin> F\n  Some s \\<notin> trivials local.R\n\ngoal (1 subgoal):\n 1. Some s \\<in> states local.R", "by auto"], ["proof (state)\nthis:\n  Some s \\<in> states local.R\n\ngoal (1 subgoal):\n 1. M.n s = 0", "obtain \\<phi> where \"mec R \\<phi>\" \"s \\<in> Some -` \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>mec local.R \\<phi>; s \\<in> Some -` states \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using mec_exists'[OF \\<open>Some s \\<in> states R\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>\\<psi>. Some s \\<in> states \\<psi> \\<and> mec local.R \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<lbrakk>mec local.R \\<phi>; s \\<in> Some -` states \\<phi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  mec local.R \\<phi>\n  s \\<in> Some -` states \\<phi>\n\ngoal (1 subgoal):\n 1. M.n s = 0", "then"], ["proof (chain)\npicking this:\n  mec local.R \\<phi>\n  s \\<in> Some -` states \\<phi>", "have action_\\<phi>: \"Some t \\<in> \\<phi> \\<Longrightarrow> actions \\<phi> (Some t) \\<noteq> {}\" for t"], ["proof (prove)\nusing this:\n  mec local.R \\<phi>\n  s \\<in> Some -` states \\<phi>\n\ngoal (1 subgoal):\n 1. Some t \\<in> states \\<phi> \\<Longrightarrow>\n    actions \\<phi> (Some t) \\<noteq> {}", "using mec_ec[OF \\<open>mec R \\<phi>\\<close>] \\<open>Some s \\<notin> trivials R\\<close> sc_eq_trivial[of \\<phi> \"Some t\"]"], ["proof (prove)\nusing this:\n  mec local.R \\<phi>\n  s \\<in> Some -` states \\<phi>\n  ec \\<phi>\n  Some s \\<notin> trivials local.R\n  \\<lbrakk>sc \\<phi>; Some t \\<in> states \\<phi>;\n   actions \\<phi> (Some t) = {}\\<rbrakk>\n  \\<Longrightarrow> \\<phi> = trivial (Some t)\n\ngoal (1 subgoal):\n 1. Some t \\<in> states \\<phi> \\<Longrightarrow>\n    actions \\<phi> (Some t) \\<noteq> {}", "by (auto simp: ec_def trivials_def)"], ["proof (state)\nthis:\n  Some ?t1 \\<in> states \\<phi> \\<Longrightarrow>\n  actions \\<phi> (Some ?t1) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. M.n s = 0", "have None_notin_states: \"None \\<notin> states \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None \\<notin> states \\<phi>", "using mec_R_loop \\<open>mec R \\<phi>\\<close> \\<open>s \\<in> Some -` \\<phi>\\<close> mec_unique[of R \"loop None\" \\<phi>]"], ["proof (prove)\nusing this:\n  mec local.R (loop None)\n  mec local.R \\<phi>\n  s \\<in> Some -` states \\<phi>\n  \\<lbrakk>mec local.R (loop None); mec local.R \\<phi>;\n   loop None \\<sqinter> \\<phi> \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> loop None = \\<phi>\n\ngoal (1 subgoal):\n 1. None \\<notin> states \\<phi>", "by (auto simp: inf_eq_bot_eq_disjnt_states disjnt_def)"], ["proof (state)\nthis:\n  None \\<notin> states \\<phi>\n\ngoal (1 subgoal):\n 1. M.n s = 0", "from \\<open>s \\<in> Some -` \\<phi>\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> Some -` states \\<phi>", "show \"M.n s = 0\""], ["proof (prove)\nusing this:\n  s \\<in> Some -` states \\<phi>\n\ngoal (1 subgoal):\n 1. M.n s = 0", "proof (rule M.n_eq_0_closed)"], ["proof (state)\ngoal (3 subgoals):\n 1. Some -` states \\<phi> \\<subseteq> states M\n 2. Some -` states \\<phi> \\<inter> F = {}\n 3. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "show \"Some -` states \\<phi> \\<subseteq> states M\" \"Some -` states \\<phi> \\<inter> F = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some -` states \\<phi> \\<subseteq> states M &&&\n    Some -` states \\<phi> \\<inter> F = {}", "using mec_le[OF \\<open>mec R \\<phi>\\<close>]"], ["proof (prove)\nusing this:\n  \\<phi> \\<le> local.R\n\ngoal (1 subgoal):\n 1. Some -` states \\<phi> \\<subseteq> states M &&&\n    Some -` states \\<phi> \\<inter> F = {}", "by (auto simp: r_def le_mdpc_iff)"], ["proof (state)\nthis:\n  Some -` states \\<phi> \\<subseteq> states M\n  Some -` states \\<phi> \\<inter> F = {}\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "assume \"s \\<in> Some -` \\<phi>\""], ["proof (state)\nthis:\n  s \\<in> Some -` states \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "then"], ["proof (chain)\npicking this:\n  s \\<in> Some -` states \\<phi>", "have s: \"s \\<in> states M\" \"s \\<notin> F\" \"actions \\<phi> (Some s) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  s \\<in> Some -` states \\<phi>\n\ngoal (1 subgoal):\n 1. s \\<in> states M &&&\n    s \\<notin> F &&& actions \\<phi> (Some s) \\<noteq> {}", "using mec_le[OF \\<open>mec R \\<phi>\\<close>]"], ["proof (prove)\nusing this:\n  s \\<in> Some -` states \\<phi>\n  \\<phi> \\<le> local.R\n\ngoal (1 subgoal):\n 1. s \\<in> states M &&&\n    s \\<notin> F &&& actions \\<phi> (Some s) \\<noteq> {}", "by (auto simp: le_mdpc_iff action_\\<phi>)"], ["proof (state)\nthis:\n  s \\<in> states M\n  s \\<notin> F\n  actions \\<phi> (Some s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "then"], ["proof (chain)\npicking this:\n  s \\<in> states M\n  s \\<notin> F\n  actions \\<phi> (Some s) \\<noteq> {}", "obtain D where D: \"D \\<in> actions \\<phi> (Some s)\""], ["proof (prove)\nusing this:\n  s \\<in> states M\n  s \\<notin> F\n  actions \\<phi> (Some s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        D \\<in> actions \\<phi> (Some s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D \\<in> actions \\<phi> (Some s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "then"], ["proof (chain)\npicking this:\n  D \\<in> actions \\<phi> (Some s)", "have \"D \\<in> actions R (Some s)\""], ["proof (prove)\nusing this:\n  D \\<in> actions \\<phi> (Some s)\n\ngoal (1 subgoal):\n 1. D \\<in> actions local.R (Some s)", "using mec_le[OF \\<open>mec R \\<phi>\\<close>, THEN actions_mono] s"], ["proof (prove)\nusing this:\n  D \\<in> actions \\<phi> (Some s)\n  actions \\<phi> \\<le> actions local.R\n  s \\<in> states M\n  s \\<notin> F\n  actions \\<phi> (Some s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. D \\<in> actions local.R (Some s)", "by (auto simp add: le_fun_def simp del: actions_R_Some)"], ["proof (state)\nthis:\n  D \\<in> actions local.R (Some s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "with s"], ["proof (chain)\npicking this:\n  s \\<in> states M\n  s \\<notin> F\n  actions \\<phi> (Some s) \\<noteq> {}\n  D \\<in> actions local.R (Some s)", "obtain D' where D_eq: \"D = map_pmf r D'\" and D': \"D' \\<in> actions M s\""], ["proof (prove)\nusing this:\n  s \\<in> states M\n  s \\<notin> F\n  actions \\<phi> (Some s) \\<noteq> {}\n  D \\<in> actions local.R (Some s)\n\ngoal (1 subgoal):\n 1. (\\<And>D'.\n        \\<lbrakk>D = map_pmf local.r D'; D' \\<in> actions M s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D = map_pmf local.r D'\n  D' \\<in> actions M s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "have \"set_pmf D \\<subseteq> states \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf D \\<subseteq> states \\<phi>", "using closed_mdpcD[OF _ D] mec_ec[OF \\<open>mec R \\<phi>\\<close>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed_mdpc \\<phi>; ?y \\<in> set_pmf D\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> states \\<phi>\n  ec \\<phi>\n\ngoal (1 subgoal):\n 1. set_pmf D \\<subseteq> states \\<phi>", "by (auto simp: ec_def)"], ["proof (state)\nthis:\n  set_pmf D \\<subseteq> states \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "then"], ["proof (chain)\npicking this:\n  set_pmf D \\<subseteq> states \\<phi>", "have \"set_pmf D = Some ` set_pmf D'\""], ["proof (prove)\nusing this:\n  set_pmf D \\<subseteq> states \\<phi>\n\ngoal (1 subgoal):\n 1. set_pmf D = Some ` set_pmf D'", "using closed_mdpcD[of \\<phi>, OF _ \\<open>D \\<in> actions \\<phi> (Some s)\\<close>] None_notin_states\n        mec_ec[OF \\<open>mec R \\<phi>\\<close>]"], ["proof (prove)\nusing this:\n  set_pmf D \\<subseteq> states \\<phi>\n  \\<lbrakk>closed_mdpc \\<phi>; ?y \\<in> set_pmf D\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> states \\<phi>\n  None \\<notin> states \\<phi>\n  ec \\<phi>\n\ngoal (1 subgoal):\n 1. set_pmf D = Some ` set_pmf D'", "unfolding D_eq"], ["proof (prove)\nusing this:\n  set_pmf (map_pmf local.r D') \\<subseteq> states \\<phi>\n  \\<lbrakk>closed_mdpc \\<phi>;\n   ?y \\<in> set_pmf (map_pmf local.r D')\\<rbrakk>\n  \\<Longrightarrow> ?y \\<in> states \\<phi>\n  None \\<notin> states \\<phi>\n  ec \\<phi>\n\ngoal (1 subgoal):\n 1. set_pmf (map_pmf local.r D') = Some ` set_pmf D'", "by (auto intro!: image_cong simp: r_def ec_def)"], ["proof (state)\nthis:\n  set_pmf D = Some ` set_pmf D'\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Some -` states \\<phi> \\<Longrightarrow>\n       \\<exists>x\\<in>actions' M s.\n          set_pmf x \\<subseteq> Some -` states \\<phi>", "then"], ["proof (chain)\npicking this:\n  set_pmf D = Some ` set_pmf D'", "show \"\\<exists>x\\<in>actions' M s. set_pmf x \\<subseteq> Some -` states \\<phi>\""], ["proof (prove)\nusing this:\n  set_pmf D = Some ` set_pmf D'\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>actions' M s. set_pmf x \\<subseteq> Some -` states \\<phi>", "using \\<open>s \\<in> states M\\<close> \\<open>set_pmf D \\<subseteq> states \\<phi>\\<close> D'"], ["proof (prove)\nusing this:\n  set_pmf D = Some ` set_pmf D'\n  s \\<in> states M\n  set_pmf D \\<subseteq> states \\<phi>\n  D' \\<in> actions M s\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>actions' M s. set_pmf x \\<subseteq> Some -` states \\<phi>", "by (intro bexI[of _ D']) (auto simp: actions'_def)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>actions' M s. set_pmf x \\<subseteq> Some -` states \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M.n s = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_state_r_in_min_mdpc[simp]: \"s \\<in> M \\<Longrightarrow> min_state (r s) \\<in> min_mdpc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> states M \\<Longrightarrow>\n    local.min_state (local.r s) \\<in> states local.min_mdpc", "by (auto simp add: states_min_mdpc min_state_eq_Inr min_state_eq_Inl r_def)"], ["", "end"], ["", "end"]]}