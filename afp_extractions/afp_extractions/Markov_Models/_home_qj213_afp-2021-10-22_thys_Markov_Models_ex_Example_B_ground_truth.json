{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/Example_B.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma B_E_eq: \"set_pmf (K x) = {x - 1, x + 1}\"", "lemma B_E_Suc: \"Suc x \\<in> set_pmf (K x)\" \"x \\<in> set_pmf (K (Suc x))\"", "lemma B_accessible[intro]: \"(i, j) \\<in> B.acc\"", "lemma B_communicating[intro]: \"(i, j) \\<in> B.communicating\"", "lemma B_essential: \"B.essential_class UNIV\"", "lemma B_aperiodic: \"B.aperiodic UNIV\"", "lemma stationary_distribution_N: \"B.stationary_distribution N\"", "lemma limit: \"(B.p i j) \\<longlonglongrightarrow> (1/2)^Suc j\"", "lemma pos_recurrent: \"B.pos_recurrent i\"", "lemma recurrence_time: \"B.U' i i = 2^Suc i\""], "translations": [["", "lemma B_E_eq: \"set_pmf (K x) = {x - 1, x + 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (K x) = {x - 1, x + 1}", "by (auto simp: set_pmf_bernoulli K_def split: bool.split)"], ["", "lemma B_E_Suc: \"Suc x \\<in> set_pmf (K x)\" \"x \\<in> set_pmf (K (Suc x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc x \\<in> set_pmf (K x) &&& x \\<in> set_pmf (K (Suc x))", "unfolding B_E_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc x \\<in> {x - 1, x + 1} &&& x \\<in> {Suc x - 1, Suc x + 1}", "by auto"], ["", "lemma B_accessible[intro]: \"(i, j) \\<in> B.acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j) \\<in> B.acc", "proof (cases i j rule: linorder_le_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> (i, j) \\<in> B.acc\n 2. j \\<le> i \\<Longrightarrow> (i, j) \\<in> B.acc", "assume \"i \\<le> j\""], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. i \\<le> j \\<Longrightarrow> (i, j) \\<in> B.acc\n 2. j \\<le> i \\<Longrightarrow> (i, j) \\<in> B.acc", "then"], ["proof (chain)\npicking this:\n  i \\<le> j", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> B.acc", "by (induct rule: inc_induct) (auto intro: B_E_Suc converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (i, j) \\<in> B.acc\n\ngoal (1 subgoal):\n 1. j \\<le> i \\<Longrightarrow> (i, j) \\<in> B.acc", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<le> i \\<Longrightarrow> (i, j) \\<in> B.acc", "assume \"j \\<le> i\""], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. j \\<le> i \\<Longrightarrow> (i, j) \\<in> B.acc", "then"], ["proof (chain)\npicking this:\n  j \\<le> i", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> B.acc", "by (induct rule: dec_induct) (auto intro: B_E_Suc converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (i, j) \\<in> B.acc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma B_communicating[intro]: \"(i, j) \\<in> B.communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i, j) \\<in> B.communicating", "by (simp add: B.communicating_def B_accessible)"], ["", "lemma B_essential: \"B.essential_class UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.essential_class UNIV", "by (rule B.essential_classI2) auto"], ["", "subsection \\<open>B is aperiodic\\<close>"], ["", "lemma B_aperiodic: \"B.aperiodic UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.aperiodic UNIV", "unfolding B.aperiodic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> UNIV // B.communicating \\<and> B.period UNIV = 1", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. UNIV \\<in> UNIV // B.communicating\n 2. B.period UNIV = 1", "have eq: \"\\<And>x'. (if x' = 0 then 1 else 0) = indicator {0} x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       (if x' = (0::'a) then 1::'b else (0::'b)) = indicator {0::'a} x'", "by auto"], ["proof (state)\nthis:\n  (if ?x' = (0::?'a1) then 1::?'b1 else (0::?'b1)) = indicator {0::?'a1} ?x'\n\ngoal (2 subgoals):\n 1. UNIV \\<in> UNIV // B.communicating\n 2. B.period UNIV = 1", "show \"UNIV \\<in> UNIV // B.communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<in> UNIV // B.communicating", "using B_essential"], ["proof (prove)\nusing this:\n  B.essential_class UNIV\n\ngoal (1 subgoal):\n 1. UNIV \\<in> UNIV // B.communicating", "by (simp add: B.essential_class_def)"], ["proof (state)\nthis:\n  UNIV \\<in> UNIV // B.communicating\n\ngoal (1 subgoal):\n 1. B.period UNIV = 1", "then"], ["proof (chain)\npicking this:\n  UNIV \\<in> UNIV // B.communicating", "have \"B.period UNIV = Gcd (B.period_set 0)\""], ["proof (prove)\nusing this:\n  UNIV \\<in> UNIV // B.communicating\n\ngoal (1 subgoal):\n 1. B.period UNIV = Gcd (B.period_set 0)", "by (rule B.period_eq) simp"], ["proof (state)\nthis:\n  B.period UNIV = Gcd (B.period_set 0)\n\ngoal (1 subgoal):\n 1. B.period UNIV = 1", "also"], ["proof (state)\nthis:\n  B.period UNIV = Gcd (B.period_set 0)\n\ngoal (1 subgoal):\n 1. B.period UNIV = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd (B.period_set 0) = 1", "by (rule Gcd_nat_eq_one) (simp add: B.period_set_def B.p_Suc' B.p_0 eq measure_pmf_single pmf_positive_iff K_def set_pmf_bernoulli UNIV_bool)"], ["proof (state)\nthis:\n  Gcd (B.period_set 0) = 1\n\ngoal (1 subgoal):\n 1. B.period UNIV = 1", "finally"], ["proof (chain)\npicking this:\n  B.period UNIV = 1", "show \"B.period UNIV = 1\""], ["proof (prove)\nusing this:\n  B.period UNIV = 1\n\ngoal (1 subgoal):\n 1. B.period UNIV = 1", "."], ["proof (state)\nthis:\n  B.period UNIV = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The stationary distribution \\<open>N\\<close>\\<close>"], ["", "abbreviation N :: \"nat pmf\" where\n  \"N \\<equiv> geometric_pmf (1 / 2)\""], ["", "lemma stationary_distribution_N: \"B.stationary_distribution N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.stationary_distribution N", "unfolding B.stationary_distribution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N = N \\<bind> K", "proof (rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i = pmf (N \\<bind> K) i", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i = pmf (N \\<bind> K) i", "show \"pmf N a = pmf (bind_pmf N K) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf N a = pmf (N \\<bind> K) a", "apply (simp add: pmf_bind K_def map_pmf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) ^ a =\n    measure_pmf.expectation N\n     (\\<lambda>x.\n         indicat_real {a} (Suc x) / 3 +\n         indicat_real {a} (x - Suc 0) * 2 / 3) *\n    2", "apply (subst integral_measure_pmf[of \"{a - 1, a + 1}\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {a - 1, a + 1}\n 2. \\<And>aa.\n       \\<lbrakk>aa \\<in> set_pmf N;\n        indicat_real {a} (Suc aa) / 3 +\n        indicat_real {a} (aa - Suc 0) * 2 / 3 \\<noteq>\n        0\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> {a - 1, a + 1}\n 3. (1 / 2) ^ a =\n    (\\<Sum>aa\\<in>{a - 1, a + 1}.\n       pmf N aa *\\<^sub>R\n       (indicat_real {a} (Suc aa) / 3 +\n        indicat_real {a} (aa - Suc 0) * 2 / 3)) *\n    2", "apply (auto split: split_indicator_asm nat.splits simp: minus_nat.diff_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pmf N a = pmf (N \\<bind> K) a\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Limit behavior and recurrence times\\<close>"], ["", "lemma limit: \"(B.p i j) \\<longlonglongrightarrow> (1/2)^Suc j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.p i j \\<longlonglongrightarrow> (1 / 2) ^ Suc j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B.p i j \\<longlonglongrightarrow> (1 / 2) ^ Suc j", "have \"B.p i j \\<longlonglongrightarrow> pmf N j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.p i j \\<longlonglongrightarrow> pmf N j", "by (rule B.stationary_distribution_imp_p_limit[OF B_aperiodic B_essential _ stationary_distribution_N])\n       auto"], ["proof (state)\nthis:\n  B.p i j \\<longlonglongrightarrow> pmf N j\n\ngoal (1 subgoal):\n 1. B.p i j \\<longlonglongrightarrow> (1 / 2) ^ Suc j", "then"], ["proof (chain)\npicking this:\n  B.p i j \\<longlonglongrightarrow> pmf N j", "show ?thesis"], ["proof (prove)\nusing this:\n  B.p i j \\<longlonglongrightarrow> pmf N j\n\ngoal (1 subgoal):\n 1. B.p i j \\<longlonglongrightarrow> (1 / 2) ^ Suc j", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  B.p i j \\<longlonglongrightarrow> (1 / 2) ^ Suc j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_recurrent: \"B.pos_recurrent i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.pos_recurrent i", "using B.stationary_distributionD(1)[OF B_essential _ stationary_distribution_N _]"], ["proof (prove)\nusing this:\n  \\<lbrakk>countable UNIV; set_pmf N \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> Ball UNIV B.pos_recurrent\n\ngoal (1 subgoal):\n 1. B.pos_recurrent i", "by auto"], ["", "lemma recurrence_time: \"B.U' i i = 2^Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "have \"B.stat UNIV = N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.stat UNIV = measure_pmf N", "using B.stationary_distributionD(2)[OF B_essential _ stationary_distribution_N _]"], ["proof (prove)\nusing this:\n  \\<lbrakk>countable UNIV; set_pmf N \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> measure_pmf N = B.stat UNIV\n\ngoal (1 subgoal):\n 1. B.stat UNIV = measure_pmf N", "by simp"], ["proof (state)\nthis:\n  B.stat UNIV = measure_pmf N\n\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "then"], ["proof (chain)\npicking this:\n  B.stat UNIV = measure_pmf N", "have \"2^Suc i = 1 / emeasure (B.stat UNIV) {i}\""], ["proof (prove)\nusing this:\n  B.stat UNIV = measure_pmf N\n\ngoal (1 subgoal):\n 1. 2 ^ Suc i = 1 / emeasure (B.stat UNIV) {i}", "apply (simp add: field_simps emeasure_pmf_single pmf_positive)"], ["proof (prove)\ngoal (1 subgoal):\n 1. B.stat UNIV = measure_pmf N \\<Longrightarrow>\n    2 * 2 ^ i = 1 / ennreal (1 / (2 * 2 ^ i))", "apply (subst divide_ennreal[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. B.stat UNIV = measure_pmf N \\<Longrightarrow> 0 \\<le> 1\n 2. B.stat UNIV = measure_pmf N \\<Longrightarrow> 0 < 2 * 2 ^ i\n 3. B.stat UNIV = measure_pmf N \\<Longrightarrow>\n    2 * 2 ^ i = 1 / (ennreal 1 / ennreal (2 * 2 ^ i))", "apply (auto simp: ennreal_mult ennreal_power[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ Suc i = 1 / emeasure (B.stat UNIV) {i}\n\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "also"], ["proof (state)\nthis:\n  2 ^ Suc i = 1 / emeasure (B.stat UNIV) {i}\n\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "have \"\\<dots> = B.U' i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / emeasure (B.stat UNIV) {i} = B.U' i i", "unfolding B.stat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 /\n    emeasure (point_measure UNIV (\\<lambda>x. indicator UNIV x / B.U' x x))\n     {i} =\n    B.U' i i", "by (subst emeasure_point_measure_finite2)\n       (simp_all add: B.U'_def)"], ["proof (state)\nthis:\n  1 / emeasure (B.stat UNIV) {i} = B.U' i i\n\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "finally"], ["proof (chain)\npicking this:\n  2 ^ Suc i = B.U' i i", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ Suc i = B.U' i i\n\ngoal (1 subgoal):\n 1. B.U' i i = 2 ^ Suc i", "by simp"], ["proof (state)\nthis:\n  B.U' i i = 2 ^ Suc i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}