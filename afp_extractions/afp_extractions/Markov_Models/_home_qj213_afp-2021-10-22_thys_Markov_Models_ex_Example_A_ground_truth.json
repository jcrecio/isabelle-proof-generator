{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/Example_A.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma UNIV_state: \"UNIV = {A, B, C1, C2, C3}\"", "lemma A_E_eq:\n  \"set_pmf (K x) = (case x of A \\<Rightarrow> {B, C1} | B \\<Rightarrow> {B, C1} | _ \\<Rightarrow> {C1, C2, C3})\"", "lemma A_essential: \"A.essential_class {C1, C2, C3}\"", "lemma A_aperiodic: \"A.aperiodic {C1, C2, C3}\"", "lemma stationary_distribution_N: \"A.stationary_distribution n\"", "lemma exclusive_N[simp]: \"set_pmf n = {C1, C2, C3}\"", "lemma n_is_limit:\n  assumes x: \"x \\<in> {C1, C2, C3}\" and y: \"y \\<in> {C1, C2, C3}\"\n  shows \"(A.p x y) \\<longlonglongrightarrow> pmf n y\"", "lemma C_is_pos_recurrent: \"x \\<in> {C1, C2, C3} \\<Longrightarrow> A.pos_recurrent x\"", "lemma C_recurrence_time:\n  assumes x: \"x \\<in> {C1, C2, C3}\"\n  shows \"A.U' x x = 1 / pmf n x\""], "translations": [["", "lemma UNIV_state: \"UNIV = {A, B, C1, C2, C3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {A, B, C1, C2, C3}", "using state.nchotomy"], ["proof (prove)\nusing this:\n  \\<forall>state.\n     state = A \\<or>\n     state = B \\<or> state = C1 \\<or> state = C2 \\<or> state = C3\n\ngoal (1 subgoal):\n 1. UNIV = {A, B, C1, C2, C3}", "by auto"], ["", "instance state :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(state, finite_class)", "by standard (simp add: UNIV_state)"], ["", "text \\<open>The transition function \\<open>tau\\<close> is easily defined using the case statement, this allows\nus to give a sparse specification as all \\<open>0\\<close> cases are collected at the end.\\<close>"], ["", "definition tau :: \"state \\<Rightarrow> state \\<Rightarrow> real\" where\n  \"tau s t = (case (s, t) of\n      (A,  B)  \\<Rightarrow> 1 / 2 | (A,  C1) \\<Rightarrow> 1 / 2\n    | (B,  B)  \\<Rightarrow> 1 / 2 | (B,  C1) \\<Rightarrow> 1 / 2\n    | (C1, C1) \\<Rightarrow> 1 / 3 | (C1, C2) \\<Rightarrow> 1 / 3 | (C1, C3) \\<Rightarrow> 1 / 3\n    | (C2, C1) \\<Rightarrow> 1 / 3 | (C2, C2) \\<Rightarrow> 1 / 3 | (C2, C3) \\<Rightarrow> 1 / 3\n    | (C3, C1) \\<Rightarrow> 1 / 4 | (C3, C2) \\<Rightarrow> 1 / 4 | (C3, C3) \\<Rightarrow> 1 / 2\n    | _ \\<Rightarrow> 0)\""], ["", "lift_definition K :: \"state \\<Rightarrow> state pmf\" is tau"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>state.\n       (\\<forall>x. 0 \\<le> tau state x) \\<and>\n       \\<integral>\\<^sup>+ x. ennreal (tau state x)\n                          \\<partial>count_space UNIV =\n       1", "by (auto simp: tau_def nn_integral_count_space_finite UNIV_state split: state.split simp del: ennreal_plus)"], ["", "text \\<open>We use the \\<open>finite_pmf\\<close>-locale which introduces the point measure \\<open>tau.M\\<close>, and\n  provides us with the necessary simplifier setup.\\<close>"], ["", "interpretation A: MC_syntax K"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subsection \\<open>The essential classs @{term \"{C1, C2, C3}\"}\\<close>"], ["", "context\nbegin"], ["", "interpretation pmf_as_function"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma A_E_eq:\n  \"set_pmf (K x) = (case x of A \\<Rightarrow> {B, C1} | B \\<Rightarrow> {B, C1} | _ \\<Rightarrow> {C1, C2, C3})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (K x) =\n    (case x of A \\<Rightarrow> {B, C1} | B \\<Rightarrow> {B, C1}\n     | _ \\<Rightarrow> {C1, C2, C3})", "using state.nchotomy"], ["proof (prove)\nusing this:\n  \\<forall>state.\n     state = A \\<or>\n     state = B \\<or> state = C1 \\<or> state = C2 \\<or> state = C3\n\ngoal (1 subgoal):\n 1. set_pmf (K x) =\n    (case x of A \\<Rightarrow> {B, C1} | B \\<Rightarrow> {B, C1}\n     | _ \\<Rightarrow> {C1, C2, C3})", "by transfer (auto simp: tau_def split: prod.split state.split)"], ["", "lemma A_essential: \"A.essential_class {C1, C2, C3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.essential_class {C1, C2, C3}", "by (rule A.essential_classI2) (auto simp: A_E_eq)"], ["", "lemma A_aperiodic: \"A.aperiodic {C1, C2, C3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.aperiodic {C1, C2, C3}", "unfolding A.aperiodic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {C1, C2, C3} \\<in> UNIV // A.communicating \\<and>\n    A.period {C1, C2, C3} = 1", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. {C1, C2, C3} \\<in> UNIV // A.communicating\n 2. A.period {C1, C2, C3} = 1", "have eq: \"\\<And>x'. (if x' = C1 then 1 else 0) = indicator {C1} x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'. (if x' = C1 then 1::'a else (0::'a)) = indicator {C1} x'", "by auto"], ["proof (state)\nthis:\n  (if ?x' = C1 then 1::?'a1 else (0::?'a1)) = indicator {C1} ?x'\n\ngoal (2 subgoals):\n 1. {C1, C2, C3} \\<in> UNIV // A.communicating\n 2. A.period {C1, C2, C3} = 1", "show \"{C1, C2, C3} \\<in> UNIV // A.communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {C1, C2, C3} \\<in> UNIV // A.communicating", "using A_essential"], ["proof (prove)\nusing this:\n  A.essential_class {C1, C2, C3}\n\ngoal (1 subgoal):\n 1. {C1, C2, C3} \\<in> UNIV // A.communicating", "by (simp add: A.essential_class_def)"], ["proof (state)\nthis:\n  {C1, C2, C3} \\<in> UNIV // A.communicating\n\ngoal (1 subgoal):\n 1. A.period {C1, C2, C3} = 1", "then"], ["proof (chain)\npicking this:\n  {C1, C2, C3} \\<in> UNIV // A.communicating", "have \"A.period {C1, C2, C3} = Gcd (A.period_set C1)\""], ["proof (prove)\nusing this:\n  {C1, C2, C3} \\<in> UNIV // A.communicating\n\ngoal (1 subgoal):\n 1. A.period {C1, C2, C3} = Gcd (A.period_set C1)", "by (rule A.period_eq) simp"], ["proof (state)\nthis:\n  A.period {C1, C2, C3} = Gcd (A.period_set C1)\n\ngoal (1 subgoal):\n 1. A.period {C1, C2, C3} = 1", "also"], ["proof (state)\nthis:\n  A.period {C1, C2, C3} = Gcd (A.period_set C1)\n\ngoal (1 subgoal):\n 1. A.period {C1, C2, C3} = 1", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd (A.period_set C1) = 1", "by (rule Gcd_nat_eq_one) (simp add: A_E_eq A.period_set_def A.p_Suc' A.p_0 eq measure_pmf_single pmf_positive)"], ["proof (state)\nthis:\n  Gcd (A.period_set C1) = 1\n\ngoal (1 subgoal):\n 1. A.period {C1, C2, C3} = 1", "finally"], ["proof (chain)\npicking this:\n  A.period {C1, C2, C3} = 1", "show \"A.period {C1, C2, C3} = 1\""], ["proof (prove)\nusing this:\n  A.period {C1, C2, C3} = 1\n\ngoal (1 subgoal):\n 1. A.period {C1, C2, C3} = 1", "."], ["proof (state)\nthis:\n  A.period {C1, C2, C3} = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The stationary distribution \\<open>n\\<close>\\<close>"], ["", "text \\<open>Similar to \\<open>tau\\<close> we introduce \\<open>n\\<close> using the \\<open>finite_pmf\\<close>-locale.\\<close>"], ["", "lift_definition n :: \"state pmf\" is \"\\<lambda>C1 \\<Rightarrow> 0.3 | C2 \\<Rightarrow> 0.3 | C3 \\<Rightarrow> 0.4 | _ \\<Rightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        0 \\<le> (case x of C1 \\<Rightarrow> 3 / 10 | C2 \\<Rightarrow> 3 / 10\n                 | C3 \\<Rightarrow> 4 / 10 | _ \\<Rightarrow> 0)) \\<and>\n    \\<integral>\\<^sup>+ x. ennreal\n                            (case x of C1 \\<Rightarrow> 3 / 10\n                             | C2 \\<Rightarrow> 3 / 10\n                             | C3 \\<Rightarrow> 4 / 10 | _ \\<Rightarrow> 0)\n                       \\<partial>count_space UNIV =\n    1", "by (auto simp: UNIV_state nn_integral_count_space_finite split: state.split)"], ["", "lemma stationary_distribution_N: \"A.stationary_distribution n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.stationary_distribution n", "unfolding A.stationary_distribution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = n \\<bind> K", "apply (auto intro!: pmf_eqI simp: pmf_bind integral_measure_pmf[of UNIV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. pmf n i = (\\<Sum>a\\<in>UNIV. pmf n a * pmf (K a) i)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       (case i of C1 \\<Rightarrow> 3 / 10 | C2 \\<Rightarrow> 3 / 10\n        | C3 \\<Rightarrow> 4 / 10 | _ \\<Rightarrow> 0) =\n       (\\<Sum>a\\<in>UNIV.\n          (case a of C1 \\<Rightarrow> 3 / 10 | C2 \\<Rightarrow> 3 / 10\n           | C3 \\<Rightarrow> 4 / 10 | _ \\<Rightarrow> 0) *\n          tau a i)", "apply (auto simp: UNIV_state tau_def split: state.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exclusive_N[simp]: \"set_pmf n = {C1, C2, C3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf n = {C1, C2, C3}", "using state.nchotomy"], ["proof (prove)\nusing this:\n  \\<forall>state.\n     state = A \\<or>\n     state = B \\<or> state = C1 \\<or> state = C2 \\<or> state = C3\n\ngoal (1 subgoal):\n 1. set_pmf n = {C1, C2, C3}", "by transfer (auto split: state.splits)"], ["", "end"], ["", "lemma n_is_limit:\n  assumes x: \"x \\<in> {C1, C2, C3}\" and y: \"y \\<in> {C1, C2, C3}\"\n  shows \"(A.p x y) \\<longlonglongrightarrow> pmf n y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.p x y \\<longlonglongrightarrow> pmf n y", "using A.stationary_distribution_imp_p_limit[OF A_aperiodic A_essential _ stationary_distribution_N _ x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>countable {C1, C2, C3};\n   set_pmf n \\<subseteq> {C1, C2, C3}\\<rbrakk>\n  \\<Longrightarrow> A.p x y \\<longlonglongrightarrow> pmf n y\n\ngoal (1 subgoal):\n 1. A.p x y \\<longlonglongrightarrow> pmf n y", "by simp"], ["", "lemma C_is_pos_recurrent: \"x \\<in> {C1, C2, C3} \\<Longrightarrow> A.pos_recurrent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {C1, C2, C3} \\<Longrightarrow> A.pos_recurrent x", "using A.stationary_distributionD(1)[OF A_essential _ stationary_distribution_N]"], ["proof (prove)\nusing this:\n  \\<lbrakk>countable {C1, C2, C3};\n   set_pmf n \\<subseteq> {C1, C2, C3}\\<rbrakk>\n  \\<Longrightarrow> Ball {C1, C2, C3} A.pos_recurrent\n\ngoal (1 subgoal):\n 1. x \\<in> {C1, C2, C3} \\<Longrightarrow> A.pos_recurrent x", "by auto"], ["", "lemma C_recurrence_time:\n  assumes x: \"x \\<in> {C1, C2, C3}\"\n  shows \"A.U' x x = 1 / pmf n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", "from A.stationary_distributionD(2)[OF A_essential _ stationary_distribution_N _]"], ["proof (chain)\npicking this:\n  \\<lbrakk>countable {C1, C2, C3};\n   set_pmf n \\<subseteq> {C1, C2, C3}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf n = A.stat {C1, C2, C3}", "have \"A.stat {C1, C2, C3} = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>countable {C1, C2, C3};\n   set_pmf n \\<subseteq> {C1, C2, C3}\\<rbrakk>\n  \\<Longrightarrow> measure_pmf n = A.stat {C1, C2, C3}\n\ngoal (1 subgoal):\n 1. A.stat {C1, C2, C3} = measure_pmf n", "by simp"], ["proof (state)\nthis:\n  A.stat {C1, C2, C3} = measure_pmf n\n\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", "with x"], ["proof (chain)\npicking this:\n  x \\<in> {C1, C2, C3}\n  A.stat {C1, C2, C3} = measure_pmf n", "have \"1 / pmf n x = 1 / emeasure (A.stat {C1, C2, C3}) {x}\""], ["proof (prove)\nusing this:\n  x \\<in> {C1, C2, C3}\n  A.stat {C1, C2, C3} = measure_pmf n\n\ngoal (1 subgoal):\n 1. ennreal (1 / pmf n x) = 1 / emeasure (A.stat {C1, C2, C3}) {x}", "by (simp add: emeasure_pmf_single pmf_positive divide_ennreal ennreal_1[symmetric] del: ennreal_1)"], ["proof (state)\nthis:\n  ennreal (1 / pmf n x) = 1 / emeasure (A.stat {C1, C2, C3}) {x}\n\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", "also"], ["proof (state)\nthis:\n  ennreal (1 / pmf n x) = 1 / emeasure (A.stat {C1, C2, C3}) {x}\n\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", "have \"\\<dots> = A.U' x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / emeasure (A.stat {C1, C2, C3}) {x} = A.U' x x", "unfolding A.stat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 /\n    emeasure\n     (point_measure UNIV (\\<lambda>x. indicator {C1, C2, C3} x / A.U' x x))\n     {x} =\n    A.U' x x", "using x"], ["proof (prove)\nusing this:\n  x \\<in> {C1, C2, C3}\n\ngoal (1 subgoal):\n 1. 1 /\n    emeasure\n     (point_measure UNIV (\\<lambda>x. indicator {C1, C2, C3} x / A.U' x x))\n     {x} =\n    A.U' x x", "by (subst emeasure_point_measure_finite) (simp_all add:  A.U'_def)"], ["proof (state)\nthis:\n  1 / emeasure (A.stat {C1, C2, C3}) {x} = A.U' x x\n\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", "finally"], ["proof (chain)\npicking this:\n  ennreal (1 / pmf n x) = A.U' x x", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (1 / pmf n x) = A.U' x x\n\ngoal (1 subgoal):\n 1. A.U' x x = ennreal (1 / pmf n x)", ".."], ["proof (state)\nthis:\n  A.U' x x = ennreal (1 / pmf n x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}