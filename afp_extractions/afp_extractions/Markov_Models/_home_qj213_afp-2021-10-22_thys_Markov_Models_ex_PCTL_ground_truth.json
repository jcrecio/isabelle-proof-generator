{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/PCTL.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma measurable_\\<iota>'[measurable (raw)]:\n  \"f \\<in> measurable M (count_space UNIV) \\<Longrightarrow> g \\<in> measurable M (count_space UNIV) \\<Longrightarrow>\n    (\\<lambda>x. \\<iota> (f x) (g x)) \\<in> borel_measurable M\"", "lemma measurable_\\<rho>[measurable]: \"\\<rho> \\<in> borel_measurable (count_space UNIV)\"", "lemma single_l:\n  fixes s and x :: real assumes \"s \\<in> S\"\n  shows \"(\\<Sum>s'\\<in>S. (if s' = s then 1 else 0) * l s') = x \\<longleftrightarrow> l s = x\"", "lemma\n  shows bij_order[simp]: \"bij_betw order {..< card S} S\"\n    and inj_order[simp]: \"inj_on order {..<card S}\"\n    and image_order[simp]: \"order ` {..<card S} = S\"\n    and order_S[simp, intro]: \"\\<And>i. i < card S \\<Longrightarrow> order i \\<in> S\"", "lemma order_Ex:\n  assumes \"s \\<in> S\" obtains i where \"i < card S\" \"s = order i\"", "lemma bij_iorder: \"bij_betw iorder S {..<card S}\"", "lemma iorder_image_eq: \"iorder ` S = {..<card S}\"\n  and inj_iorder: \"inj_on iorder S\"", "lemma order_iorder: \"\\<And>s. s \\<in> S \\<Longrightarrow> order (iorder s) = s\"", "lemma gauss_jordan'_correct:\n  assumes \"gauss_jordan' M a = Some f\"\n  shows \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s\"", "lemma gauss_jordan'_complete:\n  assumes exists: \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x s') = a s\"\n  assumes unique: \"\\<And>y. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * y s') = a s \\<Longrightarrow> \\<forall>s\\<in>S. y s = x s\"\n  shows \"\\<exists>y. gauss_jordan' M a = Some y\"", "lemma measurable_bound_until[measurable]:\n  assumes [measurable]: \"Measurable.pred (stream_space M) \\<phi>\" \"Measurable.pred (stream_space M) \\<psi>\"\n  shows \"Measurable.pred (stream_space M) (bound_until n \\<phi> \\<psi>)\"", "lemma svalid_subset_S: \"svalid F \\<subseteq> S\"", "lemma finite_svalid[simp, intro]: \"finite (svalid F)\"", "lemma svalid_sets[measurable]: \"svalid F \\<in> sets (count_space S)\"", "lemma pvalid_sets[measurable]: \"Measurable.pred R.S (pvalid F)\"", "lemma reward_measurable[measurable]: \"reward F \\<in> borel_measurable R.S\"", "lemma Prob0_subset_S: \"Prob0 \\<Phi> \\<Psi> \\<subseteq> S\"", "lemma Prob0_iff_reachable:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\"\n  shows \"Prob0 \\<Phi> \\<Psi> = {s \\<in> S. ((SIGMA x:\\<Phi>. E x)\\<^sup>* `` {s}) \\<inter> \\<Psi> = {}}\" (is \"_ = ?U\")", "lemma Prob0_iff:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\"\n  shows \"Prob0 \\<Phi> \\<Psi> = {s\\<in>S. AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\" (is \"_ = ?U\")", "lemma E_rtrancl_closed:\n  assumes \"s \\<in> S\" \"(s, t) \\<in> (SIGMA x:A. B x)\\<^sup>*\" \"\\<And>x. x \\<in> A \\<Longrightarrow> B x \\<subseteq> E x\" shows \"t \\<in> S\"", "lemma Prob1_iff:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\"\n  shows \"Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> = {s\\<in>S. AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\"\n    (is \"Prob1 ?P0 _ _ = {s\\<in>S. ?pU s}\")", "lemma prob_sum:\n  \"s \\<in> S \\<Longrightarrow> Measurable.pred R.S P \\<Longrightarrow> \\<P>(\\<omega> in T s. P \\<omega>) = (\\<Sum>t\\<in>S. \\<tau> s t * \\<P>(\\<omega> in T t. P (t ## \\<omega>)))\"", "lemma nn_integral_eq_sum:\n  \"s \\<in> S \\<Longrightarrow> f \\<in> borel_measurable R.S \\<Longrightarrow> (\\<integral>\\<^sup>+x. f x \\<partial>T s) = (\\<Sum>t\\<in>S. \\<tau> s t * (\\<integral>\\<^sup>+x. f (t ## x) \\<partial>T t))\"", "lemma T_space[simp]: \"measure (T s) (space R.S) = 1\"", "lemma emeasure_T_space[simp]: \"emeasure (T s) (space R.S) = 1\"", "lemma \\<tau>_distr[simp]: \"s \\<in> S \\<Longrightarrow> (\\<Sum>t\\<in>S. \\<tau> s t) = 1\"", "lemma ProbU:\n  \"q \\<in> S \\<Longrightarrow> ProbU q k (svalid F1) (svalid F2) = \\<P>(\\<omega> in T q. pvalid (U k F1 F2) (q ## \\<omega>))\"", "lemma Prob0_imp_not_Psi:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\" \"s \\<in> Prob0 \\<Phi> \\<Psi>\" shows \"s \\<notin> \\<Psi>\"", "lemma Psi_imp_not_Prob0:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\" shows \"s \\<in> \\<Psi> \\<Longrightarrow> s \\<notin> Prob0 \\<Phi> \\<Psi>\"", "lemma s0_in_S: \"s0 \\<in> S\"", "lemma nn_integral_reward_finite:\n  assumes \"s \\<in> S\"\n  assumes until: \"AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\"\n  shows \"(\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) \\<noteq> \\<infinity>\"", "lemma unique:\n  assumes in_S: \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\" \"N \\<subseteq> S\" \"Prob0 \\<Phi> \\<Psi> \\<subseteq> N\" \"\\<Psi> \\<subseteq> N\"\n  assumes l1: \"\\<And>s. s \\<in> S \\<Longrightarrow> s \\<notin> N \\<Longrightarrow> l1 s - c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l1 s')\"\n  assumes l2: \"\\<And>s. s \\<in> S \\<Longrightarrow> s \\<notin> N \\<Longrightarrow> l2 s - c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l2 s')\"\n  assumes eq: \"\\<And>s. s \\<in> N \\<Longrightarrow> l1 s = l2 s\"\n  shows \"\\<forall>s\\<in>S. l1 s = l2 s\"", "lemma uniqueness_of_ProbU:\n  assumes sol:\n    \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' * l s') =\n      (if s \\<in> svalid F2 then 1 else 0)\"\n  shows \"\\<forall>s\\<in>S. l s = \\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\"", "lemma infinite_reward:\n  fixes s F\n  defines \"N \\<equiv> Prob0 S (svalid F)\" (is \"_ \\<equiv> Prob0 S ?F\")\n  defines \"Y \\<equiv> Prob1 N S (svalid F)\"\n  assumes s: \"s \\<in> S\" \"s \\<notin> Y\"\n  shows \"(\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) = \\<infinity>\"", "lemma existence_of_ExpFuture:\n  fixes s F\n  assumes N_def: \"N \\<equiv> Prob0 S (svalid F)\" (is \"_ \\<equiv> Prob0 S ?F\")\n  assumes Y_def: \"Y \\<equiv> Prob1 N S (svalid F)\"\n  assumes s: \"s \\<in> S\" \"s \\<notin> S - (Y - ?F)\"\n  shows \"enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s' ## \\<omega>) \\<partial>T s'))\"", "lemma uniqueness_of_ExpFuture:\n  fixes F\n  assumes N_def: \"N \\<equiv> Prob0 S (svalid F)\" (is \"_ \\<equiv> Prob0 S ?F\")\n  assumes Y_def: \"Y \\<equiv> Prob1 N S (svalid F)\"\n  assumes const_def: \"const \\<equiv> \\<lambda>s. if s \\<in> Y \\<and> s \\<notin> svalid F then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0\"\n  assumes sol: \"\\<And>s. s\\<in>S \\<Longrightarrow> (\\<Sum>s'\\<in>S. LES (S - Y \\<union> ?F) s s' * l s') = const s\"\n  shows \"\\<forall>s\\<in>S. l s = enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s)\"\n    (is \"\\<forall>s\\<in>S. l s = enn2real (\\<integral>\\<^sup>+\\<omega>. ?R (s ## \\<omega>) \\<partial>T s)\")", "theorem Sat_sound:\n  \"Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\"", "theorem Sat_complete:\n  \"Sat F \\<noteq> None\""], "translations": [["", "lemma measurable_\\<iota>'[measurable (raw)]:\n  \"f \\<in> measurable M (count_space UNIV) \\<Longrightarrow> g \\<in> measurable M (count_space UNIV) \\<Longrightarrow>\n    (\\<lambda>x. \\<iota> (f x) (g x)) \\<in> borel_measurable M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV;\n     g \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. \\<iota> (f x) (g x))\n                      \\<in> borel_measurable M", "using measurable_compose[OF _ measurable_\\<iota>, of \"\\<lambda>x. (f x, g x)\" M]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. (f x, g x))\n  \\<in> M \\<rightarrow>\\<^sub>M\n        count_space UNIV \\<Otimes>\\<^sub>M\n        count_space UNIV \\<Longrightarrow>\n  (\\<lambda>x. case (f x, g x) of (a, b) \\<Rightarrow> \\<iota> a b)\n  \\<in> borel_measurable M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV;\n     g \\<in> M \\<rightarrow>\\<^sub>M count_space UNIV\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. \\<iota> (f x) (g x))\n                      \\<in> borel_measurable M", "by simp"], ["", "lemma measurable_\\<rho>[measurable]: \"\\<rho> \\<in> borel_measurable (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<rho> \\<in> borel_measurable (count_space UNIV)", "by simp"], ["", "sublocale R?: MC_with_rewards K \\<iota> \\<rho>"], ["proof (prove)\ngoal (1 subgoal):\n 1. MC_with_rewards (\\<lambda>x xa. ennreal (\\<iota> x xa))\n     (\\<lambda>x. ennreal (\\<rho> x))", "by standard (auto intro: \\<iota>_nonneg \\<rho>_nonneg)"], ["", "lemma single_l:\n  fixes s and x :: real assumes \"s \\<in> S\"\n  shows \"(\\<Sum>s'\\<in>S. (if s' = s then 1 else 0) * l s') = x \\<longleftrightarrow> l s = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>s'\\<in>S. (if s' = s then 1 else 0) * l s') = x) = (l s = x)", "by (simp add: assms if_distrib [of \"\\<lambda>x. x * a\" for a] cong: if_cong)"], ["", "definition \"order = (SOME f. bij_betw f {..< card S} S)\""], ["", "lemma\n  shows bij_order[simp]: \"bij_betw order {..< card S} S\"\n    and inj_order[simp]: \"inj_on order {..<card S}\"\n    and image_order[simp]: \"order ` {..<card S} = S\"\n    and order_S[simp, intro]: \"\\<And>i. i < card S \\<Longrightarrow> order i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bij_betw order {..<card S} S &&& inj_on order {..<card S}) &&&\n    order ` {..<card S} = S &&&\n    (\\<And>i. i < card S \\<Longrightarrow> order i \\<in> S)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. bij_betw order {..<card S} S\n 2. inj_on order {..<card S}\n 3. order ` {..<card S} = S\n 4. \\<And>i. i < card S \\<Longrightarrow> order i \\<in> S", "from finite_same_card_bij[OF _ finite_S]"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite ?A; card ?A = card S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>h. bij_betw h ?A S", "show \"bij_betw order {..< card S} S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; card ?A = card S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>h. bij_betw h ?A S\n\ngoal (1 subgoal):\n 1. bij_betw order {..<card S} S", "unfolding order_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?A; card ?A = card S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>h. bij_betw h ?A S\n\ngoal (1 subgoal):\n 1. bij_betw (SOME f. bij_betw f {..<card S} S) {..<card S} S", "by (rule someI_ex) auto"], ["proof (state)\nthis:\n  bij_betw order {..<card S} S\n\ngoal (3 subgoals):\n 1. inj_on order {..<card S}\n 2. order ` {..<card S} = S\n 3. \\<And>i. i < card S \\<Longrightarrow> order i \\<in> S", "then"], ["proof (chain)\npicking this:\n  bij_betw order {..<card S} S", "show \"inj_on order {..<card S}\" \"order ` {..<card S} = S\""], ["proof (prove)\nusing this:\n  bij_betw order {..<card S} S\n\ngoal (1 subgoal):\n 1. inj_on order {..<card S} &&& order ` {..<card S} = S", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on order {..<card S} \\<and> order ` {..<card S} = S\n\ngoal (1 subgoal):\n 1. inj_on order {..<card S} &&& order ` {..<card S} = S", "by auto"], ["proof (state)\nthis:\n  inj_on order {..<card S}\n  order ` {..<card S} = S\n\ngoal (1 subgoal):\n 1. \\<And>i. i < card S \\<Longrightarrow> order i \\<in> S", "then"], ["proof (chain)\npicking this:\n  inj_on order {..<card S}\n  order ` {..<card S} = S", "show \"\\<And>i. i < card S \\<Longrightarrow> order i \\<in> S\""], ["proof (prove)\nusing this:\n  inj_on order {..<card S}\n  order ` {..<card S} = S\n\ngoal (1 subgoal):\n 1. \\<And>i. i < card S \\<Longrightarrow> order i \\<in> S", "by auto"], ["proof (state)\nthis:\n  ?i1 < card S \\<Longrightarrow> order ?i1 \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma order_Ex:\n  assumes \"s \\<in> S\" obtains i where \"i < card S\" \"s = order i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < card S; s = order i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < card S; s = order i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"s \\<in> order ` {..<card S}\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<in> order ` {..<card S}", "by simp"], ["proof (state)\nthis:\n  s \\<in> order ` {..<card S}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < card S; s = order i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i1 < card S; s = order ?i1\\<rbrakk> \\<Longrightarrow> thesis\n  s \\<in> order ` {..<card S}", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i1 < card S; s = order ?i1\\<rbrakk> \\<Longrightarrow> thesis\n  s \\<in> order ` {..<card S}\n\ngoal (1 subgoal):\n 1. thesis", "by (auto simp del: image_order)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"iorder = the_inv_into {..<card S} order\""], ["", "lemma bij_iorder: \"bij_betw iorder S {..<card S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw iorder S {..<card S}", "unfolding iorder_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into {..<card S} order) S {..<card S}", "by (rule bij_betw_the_inv_into bij_order)+"], ["", "lemma iorder_image_eq: \"iorder ` S = {..<card S}\"\n  and inj_iorder: \"inj_on iorder S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iorder ` S = {..<card S} &&& inj_on iorder S", "using bij_iorder"], ["proof (prove)\nusing this:\n  bij_betw iorder S {..<card S}\n\ngoal (1 subgoal):\n 1. iorder ` S = {..<card S} &&& inj_on iorder S", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on iorder S \\<and> iorder ` S = {..<card S}\n\ngoal (1 subgoal):\n 1. iorder ` S = {..<card S} &&& inj_on iorder S", "by auto"], ["", "lemma order_iorder: \"\\<And>s. s \\<in> S \\<Longrightarrow> order (iorder s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> order (iorder s) = s", "unfolding iorder_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       order (the_inv_into {..<card S} order s) = s", "using bij_order"], ["proof (prove)\nusing this:\n  bij_betw order {..<card S} S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       order (the_inv_into {..<card S} order s) = s", "by (intro f_the_inv_into_f) (auto simp: bij_betw_def)"], ["", "definition gauss_jordan' :: \"('s \\<Rightarrow> 's \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real) \\<Rightarrow> ('s \\<Rightarrow> real) option\" where\n  \"gauss_jordan' M a = do {\n     let M' = (\\<lambda>i j. if j = card S then a (order i) else M (order i) (order j)) ;\n     sol \\<leftarrow> gauss_jordan M' (card S) ;\n     Some (\\<lambda>i. sol (iorder i) (card S))\n  }\""], ["", "lemma gauss_jordan'_correct:\n  assumes \"gauss_jordan' M a = Some f\"\n  shows \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "note \\<open>gauss_jordan' M a = Some f\\<close>"], ["proof (state)\nthis:\n  gauss_jordan' M a = Some f\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "moreover"], ["proof (state)\nthis:\n  gauss_jordan' M a = Some f\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "define M' where \"M' = (\\<lambda>i j. if j = card S then\n    a (order i) else M (order i) (order j))\""], ["proof (state)\nthis:\n  M' =\n  (\\<lambda>i j. if j = card S then a (order i) else M (order i) (order j))\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "ultimately"], ["proof (chain)\npicking this:\n  gauss_jordan' M a = Some f\n  M' =\n  (\\<lambda>i j. if j = card S then a (order i) else M (order i) (order j))", "obtain sol where sol: \"gauss_jordan M' (card S) = Some sol\"\n    and f: \"f = (\\<lambda>i. sol (iorder i) (card S))\""], ["proof (prove)\nusing this:\n  gauss_jordan' M a = Some f\n  M' =\n  (\\<lambda>i j. if j = card S then a (order i) else M (order i) (order j))\n\ngoal (1 subgoal):\n 1. (\\<And>sol.\n        \\<lbrakk>gauss_jordan M' (card S) = Some sol;\n         f = (\\<lambda>i. sol (iorder i) (card S))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: gauss_jordan'_def Let_def split: bind_split_asm)"], ["proof (state)\nthis:\n  gauss_jordan M' (card S) = Some sol\n  f = (\\<lambda>i. sol (iorder i) (card S))\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "from gauss_jordan_correct[OF sol]"], ["proof (chain)\npicking this:\n  solution M' (card S) (\\<lambda>j. sol j (card S))", "have \"\\<forall>i\\<in>{..<card S}. (\\<Sum>j<card S. M (order i) (order j) * sol j (card S)) = a (order i)\""], ["proof (prove)\nusing this:\n  solution M' (card S) (\\<lambda>j. sol j (card S))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..<card S}.\n       (\\<Sum>j<card S. M (order i) (order j) * sol j (card S)) =\n       a (order i)", "unfolding solution_def M'_def"], ["proof (prove)\nusing this:\n  \\<forall>i<card S.\n     (\\<Sum>j = 0..<card S.\n         (if j = card S then a (order i) else M (order i) (order j)) *\n         sol j (card S)) =\n     (if card S = card S then a (order i) else M (order i) (order (card S)))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..<card S}.\n       (\\<Sum>j<card S. M (order i) (order j) * sol j (card S)) =\n       a (order i)", "by (simp add: atLeast0LessThan)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{..<card S}.\n     (\\<Sum>j<card S. M (order i) (order j) * sol j (card S)) = a (order i)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{..<card S}.\n     (\\<Sum>j<card S. M (order i) (order j) * sol j (card S)) = a (order i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{..<card S}.\n     (\\<Sum>j<card S. M (order i) (order j) * sol j (card S)) = a (order i)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s", "unfolding iorder_image_eq[symmetric] f"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>iorder ` S.\n     (\\<Sum>j\\<in>iorder ` S. M (order i) (order j) * sol j (card S)) =\n     a (order i)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S. M s s' * sol (iorder s') (card S)) = a s", "using inj_iorder"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>iorder ` S.\n     (\\<Sum>j\\<in>iorder ` S. M (order i) (order j) * sol j (card S)) =\n     a (order i)\n  inj_on iorder S\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S. M s s' * sol (iorder s') (card S)) = a s", "by (subst (asm) sum.reindex) (auto simp: order_iorder)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * f s') = a s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gauss_jordan'_complete:\n  assumes exists: \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x s') = a s\"\n  assumes unique: \"\\<And>y. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * y s') = a s \\<Longrightarrow> \\<forall>s\\<in>S. y s = x s\"\n  shows \"\\<exists>y. gauss_jordan' M a = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "define M' where \"M' = (\\<lambda>i j. if j = card S then\n    a (order i) else M (order i) (order j))\""], ["proof (state)\nthis:\n  M' =\n  (\\<lambda>i j. if j = card S then a (order i) else M (order i) (order j))\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "{"], ["proof (state)\nthis:\n  M' =\n  (\\<lambda>i j. if j = card S then a (order i) else M (order i) (order j))\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "have iorder_neq_card_S: \"\\<And>s. s \\<in> S \\<Longrightarrow> iorder s \\<noteq> card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> iorder s \\<noteq> card S", "using iorder_image_eq"], ["proof (prove)\nusing this:\n  iorder ` S = {..<card S}\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> iorder s \\<noteq> card S", "by (auto simp: set_eq_iff less_le)"], ["proof (state)\nthis:\n  ?s1 \\<in> S \\<Longrightarrow> iorder ?s1 \\<noteq> card S\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "have \"solution2 M' (card S) (card S) x \\<longleftrightarrow>\n      (\\<forall>s\\<in>{..<card S}. (\\<Sum>s'\\<in>{..<card S}. M' s s' * x s') = M' s (card S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution2 M' (card S) (card S) x =\n    (\\<forall>s\\<in>{..<card S}.\n        (\\<Sum>s'<card S. M' s s' * x s') = M' s (card S))", "unfolding solution2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<card S.\n        (\\<Sum>j = 0..<card S. M' i j * x j) = M' i (card S)) =\n    (\\<forall>s\\<in>{..<card S}.\n        (\\<Sum>s'<card S. M' s s' * x s') = M' s (card S))", "by (auto simp: atLeast0LessThan)"], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) x =\n  (\\<forall>s\\<in>{..<card S}.\n      (\\<Sum>s'<card S. M' s s' * x s') = M' s (card S))\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "also"], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) x =\n  (\\<forall>s\\<in>{..<card S}.\n      (\\<Sum>s'<card S. M' s s' * x s') = M' s (card S))\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "have \"\\<dots> \\<longleftrightarrow> (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>{..<card S}.\n        (\\<Sum>s'<card S. M' s s' * x s') = M' s (card S)) =\n    (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)", "unfolding iorder_image_eq[symmetric] M'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>iorder ` S.\n        (\\<Sum>s'\\<in>iorder ` S.\n           (if s' = card S then a (order s) else M (order s) (order s')) *\n           x s') =\n        (if card S = card S then a (order s)\n         else M (order s) (order (card S)))) =\n    (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)", "using inj_iorder iorder_neq_card_S"], ["proof (prove)\nusing this:\n  inj_on iorder S\n  ?s1 \\<in> S \\<Longrightarrow> iorder ?s1 \\<noteq> card S\n\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>iorder ` S.\n        (\\<Sum>s'\\<in>iorder ` S.\n           (if s' = card S then a (order s) else M (order s) (order s')) *\n           x s') =\n        (if card S = card S then a (order s)\n         else M (order s) (order (card S)))) =\n    (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)", "by (simp add: sum.reindex order_iorder)"], ["proof (state)\nthis:\n  (\\<forall>s\\<in>{..<card S}.\n      (\\<Sum>s'<card S. M' s s' * x s') = M' s (card S)) =\n  (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "finally"], ["proof (chain)\npicking this:\n  solution2 M' (card S) (card S) x =\n  (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)", "have \"solution2 M' (card S) (card S) x \\<longleftrightarrow>\n      (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)\""], ["proof (prove)\nusing this:\n  solution2 M' (card S) (card S) x =\n  (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)\n\ngoal (1 subgoal):\n 1. solution2 M' (card S) (card S) x =\n    (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)", "."], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) x =\n  (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x (iorder s')) = a s)\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "}"], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) ?xa3 =\n  (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * ?xa3 (iorder s')) = a s)\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "note sol2_eq = this"], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) ?xa3 =\n  (\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * ?xa3 (iorder s')) = a s)\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "have \"usolution M' (card S) (card S) (\\<lambda>i. x (order i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. usolution M' (card S) (card S) (\\<lambda>i. x (order i))", "unfolding usolution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. solution2 M' (card S) (card S) (\\<lambda>i. x (order i)) \\<and>\n    (\\<forall>y.\n        solution2 M' (card S) (card S) y \\<longrightarrow>\n        (\\<forall>j<card S. y j = x (order j)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. solution2 M' (card S) (card S) (\\<lambda>i. x (order i))\n 2. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "from exists"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x s') = a s", "show \"solution2 M' (card S) (card S) (\\<lambda>i. x (order i))\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * x s') = a s\n\ngoal (1 subgoal):\n 1. solution2 M' (card S) (card S) (\\<lambda>i. x (order i))", "by (simp add: sol2_eq order_iorder)"], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) (\\<lambda>i. x (order i))\n\ngoal (1 subgoal):\n 1. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "fix y j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "assume y: \"solution2 M' (card S) (card S) y\" and \"j < card S\""], ["proof (state)\nthis:\n  solution2 M' (card S) (card S) y\n  j < card S\n\ngoal (1 subgoal):\n 1. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "then"], ["proof (chain)\npicking this:\n  solution2 M' (card S) (card S) y\n  j < card S", "have \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * y (iorder s')) = a s\""], ["proof (prove)\nusing this:\n  solution2 M' (card S) (card S) y\n  j < card S\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * y (iorder s')) = a s", "by (simp add: sol2_eq)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. M s s' * y (iorder s')) = a s\n\ngoal (1 subgoal):\n 1. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "from unique[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>S. y (iorder s) = x s", "have \"\\<forall>i\\<in>{..<card S}. y i = x (order i)\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S. y (iorder s) = x s\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..<card S}. y i = x (order i)", "unfolding iorder_image_eq[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S. y (iorder s) = x s\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>iorder ` S. y i = x (order i)", "by (simp add: order_iorder)"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{..<card S}. y i = x (order i)\n\ngoal (1 subgoal):\n 1. \\<And>y j.\n       \\<lbrakk>solution2 M' (card S) (card S) y; j < card S\\<rbrakk>\n       \\<Longrightarrow> y j = x (order j)", "with \\<open>j < card S\\<close>"], ["proof (chain)\npicking this:\n  j < card S\n  \\<forall>i\\<in>{..<card S}. y i = x (order i)", "show \"y j = x (order j)\""], ["proof (prove)\nusing this:\n  j < card S\n  \\<forall>i\\<in>{..<card S}. y i = x (order i)\n\ngoal (1 subgoal):\n 1. y j = x (order j)", "by simp"], ["proof (state)\nthis:\n  y j = x (order j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  usolution M' (card S) (card S) (\\<lambda>i. x (order i))\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "from gauss_jordan_complete[OF _ this]"], ["proof (chain)\npicking this:\n  card S \\<le> card S \\<Longrightarrow>\n  \\<exists>B. gauss_jordan M' (card S) = Some B", "show ?thesis"], ["proof (prove)\nusing this:\n  card S \\<le> card S \\<Longrightarrow>\n  \\<exists>B. gauss_jordan M' (card S) = Some B\n\ngoal (1 subgoal):\n 1. \\<exists>y. gauss_jordan' M a = Some y", "by (auto simp: gauss_jordan'_def simp: M'_def)"], ["proof (state)\nthis:\n  \\<exists>y. gauss_jordan' M a = Some y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \\<open>pCTL model checking\\<close>"], ["", "subsection \\<open>Syntax\\<close>"], ["", "datatype realrel = LessEqual | Less | Greater | GreaterEqual | Equal"], ["", "datatype 's sform = \"true\"\n                  | \"Label\" \"'s set\"\n                  | \"Neg\" \"'s sform\"\n                  | \"And\" \"'s sform\" \"'s sform\"\n                  | \"Prob\" \"realrel\" \"real\" \"'s pform\"\n                  | \"Exp\" \"realrel\" \"real\" \"'s eform\"\n     and 's pform = \"X\" \"'s sform\"\n                  | \"U\" \"nat\" \"'s sform\" \"'s sform\"\n                  | \"UInfinity\" \"'s sform\" \"'s sform\" (\"U\\<^sup>\\<infinity>\")\n     and 's eform = \"Cumm\" \"nat\" (\"C\\<^sup>\\<le>\")\n                  | \"State\" \"nat\" (\"I\\<^sup>=\")\n                  | \"Future\" \"'s sform\""], ["", "primrec bound_until where\n  \"bound_until 0 \\<phi> \\<psi> = \\<psi>\"\n| \"bound_until (Suc n) \\<phi> \\<psi> = \\<psi> or (\\<phi> aand nxt (bound_until n \\<phi> \\<psi>))\""], ["", "lemma measurable_bound_until[measurable]:\n  assumes [measurable]: \"Measurable.pred (stream_space M) \\<phi>\" \"Measurable.pred (stream_space M) \\<psi>\"\n  shows \"Measurable.pred (stream_space M) (bound_until n \\<phi> \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space M) (bound_until n \\<phi> \\<psi>)", "by (induct n) simp_all"], ["", "subsection \\<open>Semantics\\<close>"], ["", "primrec inrealrel :: \"realrel \\<Rightarrow> 'a \\<Rightarrow> ('a::linorder) \\<Rightarrow> bool\" where\n\"inrealrel LessEqual r q    \\<longleftrightarrow> q \\<le> r\" |\n\"inrealrel Less r q         \\<longleftrightarrow> q < r\" |\n\"inrealrel Greater r q      \\<longleftrightarrow> q > r\" |\n\"inrealrel GreaterEqual r q \\<longleftrightarrow> q \\<ge> r\" |\n\"inrealrel Equal r q        \\<longleftrightarrow> q = r\""], ["", "context Finite_DTMC\nbegin"], ["", "abbreviation \"prob s P \\<equiv> measure (T s) {x\\<in>space (T s). P x}\""], ["", "abbreviation \"E s \\<equiv> set_pmf (K s)\""], ["", "primrec svalid :: \"'s sform \\<Rightarrow> 's set\"\nand pvalid :: \"'s pform \\<Rightarrow> 's stream \\<Rightarrow> bool\"\nand reward :: \"'s eform \\<Rightarrow> 's stream \\<Rightarrow> ennreal\" where\n\"svalid true           = S\" |\n\"svalid (Label L)      = {s \\<in> S. s \\<in> L}\" |\n\"svalid (Neg F)        = S - svalid F\" |\n\"svalid (And F1 F2)    = svalid F1 \\<inter> svalid F2\" |\n\"svalid (Prob rel r F) = {s \\<in> S. inrealrel rel r \\<P>(\\<omega> in T s. pvalid F (s ## \\<omega>)) }\" |\n\"svalid (Exp rel r F)  = {s \\<in> S. inrealrel rel (ennreal r) (\\<integral>\\<^sup>+ \\<omega>. reward F (s ## \\<omega>) \\<partial>T s) }\" |\n\n\"pvalid (X F)        = nxt (HLD (svalid F))\" |\n\"pvalid (U k F1 F2)  = bound_until k (HLD (svalid F1)) (HLD (svalid F2))\" |\n\"pvalid (U\\<^sup>\\<infinity> F1 F2)   = HLD (svalid F1) suntil HLD (svalid F2)\" |\n\n\"reward (C\\<^sup>\\<le> k)         = (\\<lambda>\\<omega>. (\\<Sum>i<k. \\<rho> (\\<omega> !! i) + \\<iota> (\\<omega> !! i) (\\<omega> !! (Suc i))))\" |\n\"reward (I\\<^sup>= k)         = (\\<lambda>\\<omega>. \\<rho> (\\<omega> !! k))\" |\n\"reward (Future F)     = (\\<lambda>\\<omega>. if ev (HLD (svalid F)) \\<omega> then reward_until (svalid F) (shd \\<omega>) (stl \\<omega>) else \\<infinity>)\""], ["", "lemma svalid_subset_S: \"svalid F \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. svalid F \\<subseteq> S", "by (induct F) auto"], ["", "lemma finite_svalid[simp, intro]: \"finite (svalid F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (svalid F)", "using svalid_subset_S finite_S"], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n  finite S\n\ngoal (1 subgoal):\n 1. finite (svalid F)", "by (blast intro: finite_subset)"], ["", "lemma svalid_sets[measurable]: \"svalid F \\<in> sets (count_space S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. svalid F \\<in> sets (count_space S)", "using svalid_subset_S"], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. svalid F \\<in> sets (count_space S)", "by auto"], ["", "lemma pvalid_sets[measurable]: \"Measurable.pred R.S (pvalid F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (pvalid F)", "by (cases F) (auto intro!: svalid_sets)"], ["", "lemma reward_measurable[measurable]: \"reward F \\<in> borel_measurable R.S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reward F \\<in> borel_measurable (stream_space (count_space UNIV))", "by (cases F) auto"], ["", "subsection \\<open>Implementation of \\<open>Sat\\<close>\\<close>"], ["", "subsubsection \\<open>\\<open>Prob0\\<close>\\<close>"], ["", "definition Prob0 where\n  \"Prob0 \\<Phi> \\<Psi> = S - while (\\<lambda>R. \\<exists>s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R) (\\<lambda>R. R \\<union> {s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {}}) \\<Psi>\""], ["", "lemma Prob0_subset_S: \"Prob0 \\<Phi> \\<Psi> \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prob0 \\<Phi> \\<Psi> \\<subseteq> S", "unfolding Prob0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S -\n    while\n     (\\<lambda>R.\n         \\<exists>s\\<in>\\<Phi>.\n            R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\n     (\\<lambda>R. R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}})\n     \\<Psi>\n    \\<subseteq> S", "by auto"], ["", "lemma Prob0_iff_reachable:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\"\n  shows \"Prob0 \\<Phi> \\<Psi> = {s \\<in> S. ((SIGMA x:\\<Phi>. E x)\\<^sup>* `` {s}) \\<inter> \\<Psi> = {}}\" (is \"_ = ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prob0 \\<Phi> \\<Psi> =\n    {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "unfolding Prob0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S -\n    while\n     (\\<lambda>R.\n         \\<exists>s\\<in>\\<Phi>.\n            R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\n     (\\<lambda>R. R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}})\n     \\<Psi> =\n    {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "proof (intro while_rule[where Q=\"\\<lambda>R. S - R = ?U\" and P=\"\\<lambda>R. \\<Psi> \\<subseteq> R \\<and> R \\<subseteq> S - ?U\"] conjI)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<Psi>\n    \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 6. wf ?r\n 7. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> ?r", "show \"wf {(B, A). A \\<subset> B \\<and> B \\<subseteq> S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(B, A). A \\<subset> B \\<and> B \\<subseteq> S}", "by (rule wf_bounded_set[where ub=\"\\<lambda>_. S\" and f=\"\\<lambda>x. x\"]) auto"], ["proof (state)\nthis:\n  wf {(B, A). A \\<subset> B \\<and> B \\<subseteq> S}\n\ngoal (6 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<Psi>\n    \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 6. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> {(B, A).\n                                A \\<subset> B \\<and> B \\<subseteq> S}", "show \"\\<Psi> \\<subseteq> S - ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\n    \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "using assms"], ["proof (prove)\nusing this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<Psi>\n    \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "by auto"], ["proof (state)\nthis:\n  \\<Psi>\n  \\<subseteq> S -\n              {s \\<in> S.\n               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (5 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> {(B, A).\n                                A \\<subset> B \\<and> B \\<subseteq> S}", "let ?\\<Delta> = \"\\<lambda>R. {s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {}}\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> {(B, A).\n                                A \\<subset> B \\<and> B \\<subseteq> S}", "{"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> {(B, A).\n                                A \\<subset> B \\<and> B \\<subseteq> S}", "fix R"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> {(B, A).\n                                A \\<subset> B \\<and> B \\<subseteq> S}", "assume R: \"\\<Psi> \\<subseteq> R \\<and> R \\<subseteq> S - ?U\" and \"\\<exists>s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R\""], ["proof (state)\nthis:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<exists>s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R\n\ngoal (5 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> \\<Psi>\n                         \\<subseteq> s \\<union>\n                                     {sa \\<in> \\<Phi>.\ns \\<inter> E sa \\<noteq> {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 4. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}\n 5. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> (s \\<union>\n                          {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}},\n                          s)\n                         \\<in> {(B, A).\n                                A \\<subset> B \\<and> B \\<subseteq> S}", "with assms"], ["proof (chain)\npicking this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> S\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<exists>s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R", "show \"(R \\<union> ?\\<Delta> R, R) \\<in> {(B, A). A \\<subset> B \\<and> B \\<subseteq> S}\" \"\\<Psi> \\<subseteq> R \\<union> ?\\<Delta> R\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> S\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<exists>s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R\n\ngoal (1 subgoal):\n 1. (R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}, R)\n    \\<in> {(B, A). A \\<subset> B \\<and> B \\<subseteq> S} &&&\n    \\<Psi>\n    \\<subseteq> R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}", "by auto"], ["proof (state)\nthis:\n  (R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}, R)\n  \\<in> {(B, A). A \\<subset> B \\<and> B \\<subseteq> S}\n  \\<Psi> \\<subseteq> R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "{"], ["proof (state)\nthis:\n  (R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}, R)\n  \\<in> {(B, A). A \\<subset> B \\<and> B \\<subseteq> S}\n  \\<Psi> \\<subseteq> R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "fix s s'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "assume s: \"s \\<in> \\<Phi>\" \"s' \\<in> R\" \"s' \\<in> E s\" and r: \"(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\""], ["proof (state)\nthis:\n  s \\<in> \\<Phi>\n  s' \\<in> R\n  s' \\<in> E s\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "with R"], ["proof (chain)\npicking this:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  s \\<in> \\<Phi>\n  s' \\<in> R\n  s' \\<in> E s\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}", "have \"(s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\" \"s' \\<in> \\<Phi> - \\<Psi>\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  s \\<in> \\<Phi>\n  s' \\<in> R\n  s' \\<in> E s\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n\ngoal (1 subgoal):\n 1. (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>* &&& s' \\<in> \\<Phi> - \\<Psi>", "by (auto elim: converse_rtranclE)"], ["proof (state)\nthis:\n  (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s' \\<in> \\<Phi> - \\<Psi>\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "moreover"], ["proof (state)\nthis:\n  (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s' \\<in> \\<Phi> - \\<Psi>\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "with \\<open>s' \\<in> R\\<close> R"], ["proof (chain)\npicking this:\n  s' \\<in> R\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s' \\<in> \\<Phi> - \\<Psi>", "obtain s'' where \"(s', s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\" \"s'' \\<in> \\<Psi>\""], ["proof (prove)\nusing this:\n  s' \\<in> R\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s' \\<in> \\<Phi> - \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>(s', s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n         s'' \\<in> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (s', s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s'' \\<in> \\<Psi>\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "ultimately"], ["proof (chain)\npicking this:\n  (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s' \\<in> \\<Phi> - \\<Psi>\n  (s', s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s'' \\<in> \\<Psi>", "have \"(s, s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\" \"s'' \\<in> \\<Psi>\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s' \\<in> \\<Phi> - \\<Psi>\n  (s', s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s'' \\<in> \\<Psi>\n\ngoal (1 subgoal):\n 1. (s, s'') \\<in> (Sigma \\<Phi> E)\\<^sup>* &&& s'' \\<in> \\<Psi>", "by auto"], ["proof (state)\nthis:\n  (s, s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s'' \\<in> \\<Psi>\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "with r"], ["proof (chain)\npicking this:\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n  (s, s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s'' \\<in> \\<Psi>", "have False"], ["proof (prove)\nusing this:\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n  (s, s'') \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s'' \\<in> \\<Psi>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s3 \\<in> \\<Phi>; ?s'3 \\<in> R; ?s'3 \\<in> E ?s3;\n   (Sigma \\<Phi> E)\\<^sup>* `` {?s3} \\<inter> \\<Psi> = {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<exists>sa\\<in>\\<Phi>.\n           s \\<inter> E sa \\<noteq> {} \\<and> sa \\<notin> s\\<rbrakk>\n       \\<Longrightarrow> s \\<union>\n                         {sa \\<in> \\<Phi>. s \\<inter> E sa \\<noteq> {}}\n                         \\<subseteq> S -\n                                     {s \\<in> S.\n(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n 3. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "with \\<open>\\<Phi> \\<subseteq> S\\<close> R"], ["proof (chain)\npicking this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<lbrakk>?s3 \\<in> \\<Phi>; ?s'3 \\<in> R; ?s'3 \\<in> E ?s3;\n   (Sigma \\<Phi> E)\\<^sup>* `` {?s3} \\<inter> \\<Psi> = {}\\<rbrakk>\n  \\<Longrightarrow> False", "show \"R \\<union> ?\\<Delta> R \\<subseteq> S - ?U\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<lbrakk>?s3 \\<in> \\<Phi>; ?s'3 \\<in> R; ?s'3 \\<in> E ?s3;\n   (Sigma \\<Phi> E)\\<^sup>* `` {?s3} \\<inter> \\<Psi> = {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}\n    \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "by auto"], ["proof (state)\nthis:\n  R \\<union> {s \\<in> \\<Phi>. R \\<inter> E s \\<noteq> {}}\n  \\<subseteq> S -\n              {s \\<in> S.\n               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Psi> \\<subseteq> ?R3 \\<and>\n           ?R3\n           \\<subseteq> S -\n                       {s \\<in> S.\n                        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                        {}};\n   \\<exists>s\\<in>\\<Phi>.\n      ?R3 \\<inter> E s \\<noteq> {} \\<and> s \\<notin> ?R3\\<rbrakk>\n  \\<Longrightarrow> ?R3 \\<union>\n                    {s \\<in> \\<Phi>. ?R3 \\<inter> E s \\<noteq> {}}\n                    \\<subseteq> S -\n                                {s \\<in> S.\n                                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                                 \\<Psi> =\n                                 {}}\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Psi> \\<subseteq> ?R3 \\<and>\n           ?R3\n           \\<subseteq> S -\n                       {s \\<in> S.\n                        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                        {}};\n   \\<exists>s\\<in>\\<Phi>.\n      ?R3 \\<inter> E s \\<noteq> {} \\<and> s \\<notin> ?R3\\<rbrakk>\n  \\<Longrightarrow> ?R3 \\<union>\n                    {s \\<in> \\<Phi>. ?R3 \\<inter> E s \\<noteq> {}}\n                    \\<subseteq> S -\n                                {s \\<in> S.\n                                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                                 \\<Psi> =\n                                 {}}\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "fix R"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "assume R: \"\\<Psi> \\<subseteq> R \\<and> R \\<subseteq> S - ?U\" and dR: \"\\<not> (\\<exists>s\\<in>\\<Phi>. R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\""], ["proof (state)\nthis:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<not> (\\<exists>s\\<in>\\<Phi>.\n             R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "{"], ["proof (state)\nthis:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<not> (\\<exists>s\\<in>\\<Phi>.\n             R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "fix s t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "assume s: \"s \\<in> S - R\""], ["proof (state)\nthis:\n  s \\<in> S - R\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "assume s_t: \"(s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\""], ["proof (state)\nthis:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "then"], ["proof (chain)\npicking this:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*", "have \"t \\<in> S - R\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. t \\<in> S - R", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> S - R\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n        (y, z) \\<in> Sigma \\<Phi> E; y \\<in> S - R\\<rbrakk>\n       \\<Longrightarrow> z \\<in> S - R", "case (step t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  (t, u) \\<in> Sigma \\<Phi> E\n  t \\<in> S - R\n\ngoal (2 subgoals):\n 1. s \\<in> S - R\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n        (y, z) \\<in> Sigma \\<Phi> E; y \\<in> S - R\\<rbrakk>\n       \\<Longrightarrow> z \\<in> S - R", "with R dR E_closed"], ["proof (chain)\npicking this:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<not> (\\<exists>s\\<in>\\<Phi>.\n             R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\n  \\<Union> (E ` S) \\<subseteq> S\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  (t, u) \\<in> Sigma \\<Phi> E\n  t \\<in> S - R", "show ?case"], ["proof (prove)\nusing this:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<not> (\\<exists>s\\<in>\\<Phi>.\n             R \\<inter> E s \\<noteq> {} \\<and> s \\<notin> R)\n  \\<Union> (E ` S) \\<subseteq> S\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  (t, u) \\<in> Sigma \\<Phi> E\n  t \\<in> S - R\n\ngoal (1 subgoal):\n 1. u \\<in> S - R", "by auto"], ["proof (state)\nthis:\n  u \\<in> S - R\n\ngoal (1 subgoal):\n 1. s \\<in> S - R", "qed fact"], ["proof (state)\nthis:\n  t \\<in> S - R\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "then"], ["proof (chain)\npicking this:\n  t \\<in> S - R", "have \"t \\<notin> \\<Psi>\""], ["proof (prove)\nusing this:\n  t \\<in> S - R\n\ngoal (1 subgoal):\n 1. t \\<notin> \\<Psi>", "using R"], ["proof (prove)\nusing this:\n  t \\<in> S - R\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (1 subgoal):\n 1. t \\<notin> \\<Psi>", "by auto"], ["proof (state)\nthis:\n  t \\<notin> \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s3 \\<in> S - R;\n   (?s3, ?t3) \\<in> (Sigma \\<Phi> E)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?t3 \\<notin> \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<Psi> \\<subseteq> \\<Psi>\n 2. \\<And>s.\n       \\<lbrakk>\\<Psi> \\<subseteq> s \\<and>\n                s \\<subseteq> S -\n                              {s \\<in> S.\n                               (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter>\n                               \\<Psi> =\n                               {}};\n        \\<not> (\\<exists>sa\\<in>\\<Phi>.\n                   s \\<inter> E sa \\<noteq> {} \\<and>\n                   sa \\<notin> s)\\<rbrakk>\n       \\<Longrightarrow> S - s =\n                         {s \\<in> S.\n                          (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                          {}}", "with R"], ["proof (chain)\npicking this:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<lbrakk>?s3 \\<in> S - R;\n   (?s3, ?t3) \\<in> (Sigma \\<Phi> E)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?t3 \\<notin> \\<Psi>", "show \"S - R = ?U\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<subseteq> R \\<and>\n  R \\<subseteq> S -\n                {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<lbrakk>?s3 \\<in> S - R;\n   (?s3, ?t3) \\<in> (Sigma \\<Phi> E)\\<^sup>*\\<rbrakk>\n  \\<Longrightarrow> ?t3 \\<notin> \\<Psi>\n\ngoal (1 subgoal):\n 1. S - R =\n    {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "by auto"], ["proof (state)\nthis:\n  S - R = {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<subseteq> \\<Psi>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<Psi> \\<subseteq> ?R3 \\<and>\n           ?R3\n           \\<subseteq> S -\n                       {s \\<in> S.\n                        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                        {}};\n   \\<not> (\\<exists>s\\<in>\\<Phi>.\n              ?R3 \\<inter> E s \\<noteq> {} \\<and> s \\<notin> ?R3)\\<rbrakk>\n  \\<Longrightarrow> S - ?R3 =\n                    {s \\<in> S.\n                     (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<subseteq> \\<Psi>", "qed rule"], ["", "lemma Prob0_iff:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\"\n  shows \"Prob0 \\<Phi> \\<Psi> = {s\\<in>S. AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\" (is \"_ = ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prob0 \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                 (s ## \\<omega>)}", "unfolding Prob0_iff_reachable[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}} =\n    {s \\<in> S.\n     AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                 (s ## \\<omega>)}", "proof (intro Collect_cong conj_cong refl iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "assume s: \"s \\<in> S\" \"(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\""], ["proof (state)\nthis:\n  s \\<in> S\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "{"], ["proof (state)\nthis:\n  s \\<in> S\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "fix \\<omega>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "assume \"(HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\" \"enabled (shd \\<omega>) (stl \\<omega>)\" \"(Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\""], ["proof (state)\nthis:\n  (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "from this"], ["proof (chain)\npicking this:\n  (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}", "have False"], ["proof (prove)\nusing this:\n  (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n\ngoal (1 subgoal):\n 1. False", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Psi> \\<omega>; enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Phi> \\<omega>;\n        (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>);\n        \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n         (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n         {}\\<rbrakk>\n        \\<Longrightarrow> False;\n        enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "case (step \\<omega>)"], ["proof (state)\nthis:\n  HLD \\<Phi> \\<omega>\n  (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Psi> \\<omega>; enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Phi> \\<omega>;\n        (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>);\n        \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n         (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n         {}\\<rbrakk>\n        \\<Longrightarrow> False;\n        enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  HLD \\<Phi> \\<omega>\n  (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Psi> \\<omega>; enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Phi> \\<omega>;\n        (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>);\n        \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n         (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n         {}\\<rbrakk>\n        \\<Longrightarrow> False;\n        enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  HLD \\<Phi> \\<omega>\n  (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}", "have \"(shd \\<omega>, shd (stl \\<omega>)) \\<in> (Sigma \\<Phi> E)\\<^sup>*\""], ["proof (prove)\nusing this:\n  HLD \\<Phi> \\<omega>\n  (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n\ngoal (1 subgoal):\n 1. (shd \\<omega>, shd (stl \\<omega>)) \\<in> (Sigma \\<Phi> E)\\<^sup>*", "by (auto simp: enabled.simps[of _ \"stl \\<omega>\"] HLD_iff)"], ["proof (state)\nthis:\n  (shd \\<omega>, shd (stl \\<omega>)) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Psi> \\<omega>; enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Phi> \\<omega>;\n        (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>);\n        \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n         (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n         {}\\<rbrakk>\n        \\<Longrightarrow> False;\n        enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (shd \\<omega>, shd (stl \\<omega>)) \\<in> (Sigma \\<Phi> E)\\<^sup>*", "have \"(Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<subseteq> (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>}\""], ["proof (prove)\nusing this:\n  (shd \\<omega>, shd (stl \\<omega>)) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)}\n    \\<subseteq> (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>}", "by auto"], ["proof (state)\nthis:\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)}\n  \\<subseteq> (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>}\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Psi> \\<omega>; enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Phi> \\<omega>;\n        (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>);\n        \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n         (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n         {}\\<rbrakk>\n        \\<Longrightarrow> False;\n        enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  HLD \\<Phi> \\<omega>\n  (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)}\n  \\<subseteq> (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>}", "show ?case"], ["proof (prove)\nusing this:\n  HLD \\<Phi> \\<omega>\n  (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  \\<lbrakk>enabled (shd (stl \\<omega>)) (stl (stl \\<omega>));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  enabled (shd \\<omega>) (stl \\<omega>)\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> = {}\n  (Sigma \\<Phi> E)\\<^sup>* `` {shd (stl \\<omega>)}\n  \\<subseteq> (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>}\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: enabled.simps[of _ \"stl \\<omega>\"])"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD \\<Psi> \\<omega>; enabled (shd \\<omega>) (stl \\<omega>);\n        (Sigma \\<Phi> E)\\<^sup>* `` {shd \\<omega>} \\<inter> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False", "qed (auto simp: HLD_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD \\<Phi> suntil HLD \\<Psi>) ?\\<omega>3;\n   enabled (shd ?\\<omega>3) (stl ?\\<omega>3);\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd ?\\<omega>3} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "from s this[of \"s ## \\<omega>\" for \\<omega>]"], ["proof (chain)\npicking this:\n  s \\<in> S\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n  \\<lbrakk>(HLD \\<Phi> suntil HLD \\<Psi>) (s ## ?\\<omega>3);\n   enabled (shd (s ## ?\\<omega>3)) (stl (s ## ?\\<omega>3));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (s ## ?\\<omega>3)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False", "show \"AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n  \\<lbrakk>(HLD \\<Phi> suntil HLD \\<Psi>) (s ## ?\\<omega>3);\n   enabled (shd (s ## ?\\<omega>3)) (stl (s ## ?\\<omega>3));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (s ## ?\\<omega>3)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                (s ## \\<omega>)", "using AE_T_enabled[of s]"], ["proof (prove)\nusing this:\n  s \\<in> S\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n  \\<lbrakk>(HLD \\<Phi> suntil HLD \\<Psi>) (s ## ?\\<omega>3);\n   enabled (shd (s ## ?\\<omega>3)) (stl (s ## ?\\<omega>3));\n   (Sigma \\<Phi> E)\\<^sup>* `` {shd (s ## ?\\<omega>3)} \\<inter> \\<Psi> =\n   {}\\<rbrakk>\n  \\<Longrightarrow> False\n  almost_everywhere (T s) (enabled s)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                (s ## \\<omega>)", "by auto"], ["proof (state)\nthis:\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "assume s: \"AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\""], ["proof (state)\nthis:\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "{"], ["proof (state)\nthis:\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "assume \"(s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\""], ["proof (state)\nthis:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "from this s"], ["proof (chain)\npicking this:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)", "have \"t \\<notin> \\<Psi>\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. t \\<notin> \\<Psi>", "proof (induction rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. AE \\<omega> in T t. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                (t ## \\<omega>) \\<Longrightarrow>\n    t \\<notin> \\<Psi>\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> Sigma \\<Phi> E;\n        (z, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n        AE \\<omega> in T z. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (z ## \\<omega>) \\<Longrightarrow>\n        t \\<notin> \\<Psi>;\n        AE \\<omega> in T y. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (y ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> t \\<notin> \\<Psi>", "case (step s u)"], ["proof (state)\nthis:\n  (s, u) \\<in> Sigma \\<Phi> E\n  (u, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  AE \\<omega> in T u. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                              (u ## \\<omega>) \\<Longrightarrow>\n  t \\<notin> \\<Psi>\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (2 subgoals):\n 1. AE \\<omega> in T t. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                (t ## \\<omega>) \\<Longrightarrow>\n    t \\<notin> \\<Psi>\n 2. \\<And>y z.\n       \\<lbrakk>(y, z) \\<in> Sigma \\<Phi> E;\n        (z, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n        AE \\<omega> in T z. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (z ## \\<omega>) \\<Longrightarrow>\n        t \\<notin> \\<Psi>;\n        AE \\<omega> in T y. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (y ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> t \\<notin> \\<Psi>", "then"], ["proof (chain)\npicking this:\n  (s, u) \\<in> Sigma \\<Phi> E\n  (u, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  AE \\<omega> in T u. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                              (u ## \\<omega>) \\<Longrightarrow>\n  t \\<notin> \\<Psi>\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  (s, u) \\<in> Sigma \\<Phi> E\n  (u, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  AE \\<omega> in T u. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                              (u ## \\<omega>) \\<Longrightarrow>\n  t \\<notin> \\<Psi>\n  AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. t \\<notin> \\<Psi>", "by (simp add: AE_T_iff[where x=s] suntil_Stream[of _ _ s])"], ["proof (state)\nthis:\n  t \\<notin> \\<Psi>\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T t. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                (t ## \\<omega>) \\<Longrightarrow>\n    t \\<notin> \\<Psi>", "qed (simp add: suntil_Stream)"], ["proof (state)\nthis:\n  t \\<notin> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "}"], ["proof (state)\nthis:\n  (s, ?t3) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<Longrightarrow>\n  ?t3 \\<notin> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n                                    (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> =\n                         {}", "then"], ["proof (chain)\npicking this:\n  (s, ?t3) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<Longrightarrow>\n  ?t3 \\<notin> \\<Psi>", "show \"(Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\""], ["proof (prove)\nusing this:\n  (s, ?t3) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<Longrightarrow>\n  ?t3 \\<notin> \\<Psi>\n\ngoal (1 subgoal):\n 1. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}", "by auto"], ["proof (state)\nthis:\n  (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma E_rtrancl_closed:\n  assumes \"s \\<in> S\" \"(s, t) \\<in> (SIGMA x:A. B x)\\<^sup>*\" \"\\<And>x. x \\<in> A \\<Longrightarrow> B x \\<subseteq> E x\" shows \"t \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> S", "using assms(2,3,1) E_closed"], ["proof (prove)\nusing this:\n  (s, t) \\<in> (Sigma A B)\\<^sup>*\n  ?x1 \\<in> A \\<Longrightarrow> B ?x1 \\<subseteq> E ?x1\n  s \\<in> S\n  \\<Union> (E ` S) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. t \\<in> S", "by induction force+"], ["", "subsubsection \\<open>\\<open>Prob1\\<close>\\<close>"], ["", "definition Prob1 where\n  \"Prob1 Y \\<Phi> \\<Psi> = Prob0 (\\<Phi> - \\<Psi>) Y\""], ["", "lemma Prob1_iff:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\"\n  shows \"Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> = {s\\<in>S. AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\"\n    (is \"Prob1 ?P0 _ _ = {s\\<in>S. ?pU s}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "note P0 = Prob0_iff_reachable[OF assms]"], ["proof (state)\nthis:\n  Prob0 \\<Phi> \\<Psi> =\n  {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "have *: \"\\<Phi> - \\<Psi> \\<subseteq> S\" \"?P0 \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> - \\<Psi> \\<subseteq> S &&& Prob0 \\<Phi> \\<Psi> \\<subseteq> S", "using P0 assms"], ["proof (prove)\nusing this:\n  Prob0 \\<Phi> \\<Psi> =\n  {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<Phi> - \\<Psi> \\<subseteq> S &&& Prob0 \\<Phi> \\<Psi> \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  \\<Phi> - \\<Psi> \\<subseteq> S\n  Prob0 \\<Phi> \\<Psi> \\<subseteq> S\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "have P0_subset: \"S - \\<Phi> - \\<Psi> \\<subseteq> ?P0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S - \\<Phi> - \\<Psi> \\<subseteq> Prob0 \\<Phi> \\<Psi>", "unfolding P0"], ["proof (prove)\ngoal (1 subgoal):\n 1. S - \\<Phi> - \\<Psi>\n    \\<subseteq> {s \\<in> S.\n                 (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}", "by (auto elim: converse_rtranclE)"], ["proof (state)\nthis:\n  S - \\<Phi> - \\<Psi> \\<subseteq> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "have \"Prob1 ?P0 \\<Phi> \\<Psi> = {s \\<in> S. (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> ?P0 = {}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n     Prob0 \\<Phi> \\<Psi> =\n     {}}", "unfolding Prob0_iff_reachable[OF *] Prob1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {s \\<in> S.\n     (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n     Prob0 \\<Phi> \\<Psi> =\n     {}} =\n    {s \\<in> S.\n     (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n     Prob0 \\<Phi> \\<Psi> =\n     {}}", ".."], ["proof (state)\nthis:\n  Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n  {s \\<in> S.\n   (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n   {}}\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "also"], ["proof (state)\nthis:\n  Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n  {s \\<in> S.\n   (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n   {}}\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "have \"\\<dots> = {s\\<in>S. AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s \\<in> S.\n     (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n     Prob0 \\<Phi> \\<Psi> =\n     {}} =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "proof (intro Collect_cong conj_cong refl iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "assume s: \"s \\<in> S\" \"(Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> ?P0 = {}\""], ["proof (state)\nthis:\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}", "have \"s \\<notin> ?P0\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 \\<Phi> \\<Psi>", "by auto"], ["proof (state)\nthis:\n  s \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "then"], ["proof (chain)\npicking this:\n  s \\<notin> Prob0 \\<Phi> \\<Psi>", "have \"s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>\""], ["proof (prove)\nusing this:\n  s \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>", "using P0_subset \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<notin> Prob0 \\<Phi> \\<Psi>\n  S - \\<Phi> - \\<Psi> \\<subseteq> Prob0 \\<Phi> \\<Psi>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>", "by auto"], ["proof (state)\nthis:\n  s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "moreover"], ["proof (state)\nthis:\n  s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "{"], ["proof (state)\nthis:\n  s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "assume \"s \\<in> \\<Phi> - \\<Psi>\""], ["proof (state)\nthis:\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "have \"AE \\<omega> in T s. ev (HLD (\\<Psi> \\<union> ?P0)) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)))", "proof (rule AE_T_ev_HLD)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter>\n                 - (\\<Psi> \\<union>\n                    Prob0 \\<Phi> \\<Psi>))\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n          (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter>\n                 - (\\<Psi> \\<union>\n                    Prob0 \\<Phi> \\<Psi>))\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n          (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "assume s_t: \"(s, t) \\<in> acc_on (- (\\<Psi> \\<union> ?P0))\""], ["proof (state)\nthis:\n  (s, t)\n  \\<in> (SIGMA s:UNIV.\n            E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter>\n                 - (\\<Psi> \\<union>\n                    Prob0 \\<Phi> \\<Psi>))\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n          (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "from \\<open>s \\<in> S\\<close> s_t"], ["proof (chain)\npicking this:\n  s \\<in> S\n  (s, t)\n  \\<in> (SIGMA s:UNIV.\n            E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>*", "have \"t \\<in> S\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  (s, t)\n  \\<in> (SIGMA s:UNIV.\n            E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>*\n\ngoal (1 subgoal):\n 1. t \\<in> S", "by (rule E_rtrancl_closed) auto"], ["proof (state)\nthis:\n  t \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter>\n                 - (\\<Psi> \\<union>\n                    Prob0 \\<Phi> \\<Psi>))\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n          (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "show \"\\<exists>t'\\<in>\\<Psi> \\<union> ?P0. (t, t') \\<in> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "assume \"t \\<in> ?P0\""], ["proof (state)\nthis:\n  t \\<in> Prob0 \\<Phi> \\<Psi>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  t \\<in> Prob0 \\<Phi> \\<Psi>", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n     (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. t \\<notin> Prob0 \\<Phi> \\<Psi> \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> Prob0 \\<Phi> \\<Psi> \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "assume \"t \\<notin> ?P0\""], ["proof (state)\nthis:\n  t \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. t \\<notin> Prob0 \\<Phi> \\<Psi> \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "with \\<open>t\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  t \\<in> S\n  t \\<notin> Prob0 \\<Phi> \\<Psi>", "obtain s where t_s: \"(t, s) \\<in> (SIGMA x:\\<Phi>. E x)\\<^sup>*\" and \"s \\<in> \\<Psi>\""], ["proof (prove)\nusing this:\n  t \\<in> S\n  t \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>(t, s) \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n         s \\<in> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding P0"], ["proof (prove)\nusing this:\n  t \\<in> S\n  t \\<notin> {s \\<in> S.\n              (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>(t, s) \\<in> (Sigma \\<Phi> E)\\<^sup>*;\n         s \\<in> \\<Psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (t, s) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n  s \\<in> \\<Psi>\n\ngoal (1 subgoal):\n 1. t \\<notin> Prob0 \\<Phi> \\<Psi> \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "from t_s"], ["proof (chain)\npicking this:\n  (t, s) \\<in> (Sigma \\<Phi> E)\\<^sup>*", "have \"(t, s) \\<in> acc\""], ["proof (prove)\nusing this:\n  (t, s) \\<in> (Sigma \\<Phi> E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (t, s) \\<in> (Sigma UNIV E)\\<^sup>*", "by (rule rev_subsetD) (intro rtrancl_mono Sigma_mono, auto)"], ["proof (state)\nthis:\n  (t, s) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. t \\<notin> Prob0 \\<Phi> \\<Psi> \\<Longrightarrow>\n    \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "with \\<open>s \\<in> \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> \\<Psi>\n  (t, s) \\<in> (Sigma UNIV E)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> \\<Psi>\n  (t, s) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n       (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n     (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t'\\<in>\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>.\n     (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "have \"acc_on (- (\\<Psi> \\<union> ?P0)) `` {s} \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMA s:UNIV.\n        E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n    {s}\n    \\<subseteq> S", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (SIGMA s:UNIV.\n        E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n    {s}\n    \\<subseteq> S", "by (auto intro: E_rtrancl_closed)"], ["proof (state)\nthis:\n  (SIGMA s:UNIV.\n      E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n  {s}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "then"], ["proof (chain)\npicking this:\n  (SIGMA s:UNIV.\n      E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n  {s}\n  \\<subseteq> S", "show \"finite (acc_on (- (\\<Psi> \\<union> ?P0)) `` {s})\""], ["proof (prove)\nusing this:\n  (SIGMA s:UNIV.\n      E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n  {s}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "using finite_S"], ["proof (prove)\nusing this:\n  (SIGMA s:UNIV.\n      E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n  {s}\n  \\<subseteq> S\n  finite S\n\ngoal (1 subgoal):\n 1. finite\n     ((SIGMA s:UNIV.\n          E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n      {s})", "by (auto dest: finite_subset)"], ["proof (state)\nthis:\n  finite\n   ((SIGMA s:UNIV.\n        E s \\<inter> - (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>))\\<^sup>* ``\n    {s})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_everywhere (T s) (ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "then"], ["proof (chain)\npicking this:\n  almost_everywhere (T s) (ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)))", "have \"AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\""], ["proof (prove)\nusing this:\n  almost_everywhere (T s) (ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)))\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (HLD \\<Phi> suntil HLD \\<Psi>)", "using AE_T_enabled"], ["proof (prove)\nusing this:\n  almost_everywhere (T s) (ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)))\n  almost_everywhere (T ?s) (enabled ?s)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (HLD \\<Phi> suntil HLD \\<Psi>)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) \\<omega>;\n        enabled s \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) \\<omega>;\n        enabled s \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "assume \"ev (HLD (\\<Psi> \\<union> ?P0)) \\<omega>\" \"enabled s \\<omega>\""], ["proof (state)\nthis:\n  ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) \\<omega>\n  enabled s \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) \\<omega>;\n        enabled s \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "from this s \\<open>s \\<in> \\<Phi> - \\<Psi>\\<close>"], ["proof (chain)\npicking this:\n  ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>", "show \"(HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\""], ["proof (prove)\nusing this:\n  ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (1 subgoal):\n 1. (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "proof (induction arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>) xs; enabled s xs;\n        s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "case (base \\<omega>)"], ["proof (state)\nthis:\n  HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>) xs; enabled s xs;\n        s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "then"], ["proof (chain)\npicking this:\n  HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>", "show ?case"], ["proof (prove)\nusing this:\n  HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (1 subgoal):\n 1. (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "by (auto simp: HLD_iff enabled.simps[of s] intro: suntil.intros)"], ["proof (state)\nthis:\n  (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "case (step \\<omega>)"], ["proof (state)\nthis:\n  ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl \\<omega>)\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> S;\n   (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {?s1} \\<inter>\n   Prob0 \\<Phi> \\<Psi> =\n   {};\n   ?s1 \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "then"], ["proof (chain)\npicking this:\n  ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl \\<omega>)\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> S;\n   (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {?s1} \\<inter>\n   Prob0 \\<Phi> \\<Psi> =\n   {};\n   ?s1 \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>", "have \"(s, shd \\<omega>) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\""], ["proof (prove)\nusing this:\n  ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl \\<omega>)\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> S;\n   (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {?s1} \\<inter>\n   Prob0 \\<Phi> \\<Psi> =\n   {};\n   ?s1 \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (1 subgoal):\n 1. (s, shd \\<omega>) \\<in> Sigma (\\<Phi> - \\<Psi>) E", "by (auto simp: enabled.simps[of s])"], ["proof (state)\nthis:\n  (s, shd \\<omega>) \\<in> Sigma (\\<Phi> - \\<Psi>) E\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "then"], ["proof (chain)\npicking this:\n  (s, shd \\<omega>) \\<in> Sigma (\\<Phi> - \\<Psi>) E", "have *: \"(Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter> ?P0 = {}\""], ["proof (prove)\nusing this:\n  (s, shd \\<omega>) \\<in> Sigma (\\<Phi> - \\<Psi>) E\n\ngoal (1 subgoal):\n 1. (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter>\n    Prob0 \\<Phi> \\<Psi> =\n    {}", "using step.prems"], ["proof (prove)\nusing this:\n  (s, shd \\<omega>) \\<in> Sigma (\\<Phi> - \\<Psi>) E\n  enabled s \\<omega>\n  s \\<in> S\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n  s \\<in> \\<Phi> - \\<Psi>\n\ngoal (1 subgoal):\n 1. (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter>\n    Prob0 \\<Phi> \\<Psi> =\n    {}", "by (auto intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter>\n  Prob0 \\<Phi> \\<Psi> =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "then"], ["proof (chain)\npicking this:\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter>\n  Prob0 \\<Phi> \\<Psi> =\n  {}", "have \"shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi>\" \"shd \\<omega> \\<in> S\""], ["proof (prove)\nusing this:\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter>\n  Prob0 \\<Phi> \\<Psi> =\n  {}\n\ngoal (1 subgoal):\n 1. shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi> &&&\n    shd \\<omega> \\<in> S", "using P0_subset step.prems(1,2) E_closed"], ["proof (prove)\nusing this:\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {shd \\<omega>} \\<inter>\n  Prob0 \\<Phi> \\<Psi> =\n  {}\n  S - \\<Phi> - \\<Psi> \\<subseteq> Prob0 \\<Phi> \\<Psi>\n  enabled s \\<omega>\n  s \\<in> S\n  \\<Union> (E ` S) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi> &&&\n    shd \\<omega> \\<in> S", "by (auto simp add: enabled.simps[of s])"], ["proof (state)\nthis:\n  shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi>\n  shd \\<omega> \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>ev (HLD (\\<Psi> \\<union> Prob0 \\<Phi> \\<Psi>)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S;\n            (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n            Prob0 \\<Phi> \\<Psi> =\n            {};\n            s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n           \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl xs);\n        enabled s xs; s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {};\n        s \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) xs", "then"], ["proof (chain)\npicking this:\n  shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi>\n  shd \\<omega> \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi>\n  shd \\<omega> \\<in> S\n\ngoal (1 subgoal):\n 1. (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "using step.prems(1) step.IH[OF _ _ *] \\<open>shd \\<omega> \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  shd \\<omega> \\<in> \\<Phi> - \\<Psi> \\<or> shd \\<omega> \\<in> \\<Psi>\n  shd \\<omega> \\<in> S\n  enabled s \\<omega>\n  \\<lbrakk>enabled (shd \\<omega>) (stl \\<omega>); shd \\<omega> \\<in> S;\n   shd \\<omega> \\<in> \\<Phi> - \\<Psi>\\<rbrakk>\n  \\<Longrightarrow> (HLD \\<Phi> suntil HLD \\<Psi>) (stl \\<omega>)\n  shd \\<omega> \\<in> S\n\ngoal (1 subgoal):\n 1. (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>", "by (auto simp add: suntil.simps[of _ _ \\<omega>] HLD_iff[abs_def] enabled.simps[of s \\<omega>])"], ["proof (state)\nthis:\n  (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (HLD \\<Phi> suntil HLD \\<Psi>) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_everywhere (T s) (HLD \\<Phi> suntil HLD \\<Psi>)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "}"], ["proof (state)\nthis:\n  s \\<in> \\<Phi> - \\<Psi> \\<Longrightarrow>\n  almost_everywhere (T s) (HLD \\<Phi> suntil HLD \\<Psi>)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n        Prob0 \\<Phi> \\<Psi> =\n        {}\\<rbrakk>\n       \\<Longrightarrow> AE \\<omega> in T\n   s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>\n  s \\<in> \\<Phi> - \\<Psi> \\<Longrightarrow>\n  almost_everywhere (T s) (HLD \\<Phi> suntil HLD \\<Psi>)", "show \"AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<in> \\<Phi> - \\<Psi> \\<or> s \\<in> \\<Psi>\n  s \\<in> \\<Phi> - \\<Psi> \\<Longrightarrow>\n  almost_everywhere (T s) (HLD \\<Phi> suntil HLD \\<Psi>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)", "by (cases \"s \\<in> \\<Phi> - \\<Psi>\") (auto simp add: suntil_Stream)"], ["proof (state)\nthis:\n  AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "assume s: \"s \\<in> S\" \"AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\""], ["proof (state)\nthis:\n  s \\<in> S\n  AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "{"], ["proof (state)\nthis:\n  s \\<in> S\n  AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "assume \"(s, t) \\<in> (SIGMA s:\\<Phi>-\\<Psi>. E s)\\<^sup>*\""], ["proof (state)\nthis:\n  (s, t) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "from this \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (s, t) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*\n  s \\<in> S", "have \"(AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>) (t ## \\<omega>)) \\<and> t \\<in> S\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                          (t ## \\<omega>)) \\<and>\n    t \\<in> S", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    (AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                          (s ## \\<omega>)) \\<and>\n    s \\<in> S\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*;\n        (y, z) \\<in> Sigma (\\<Phi> - \\<Psi>) E;\n        s \\<in> S \\<Longrightarrow>\n        (AE \\<omega> in T y. (HLD \\<Phi> suntil HLD \\<Psi>)\n                              (y ## \\<omega>)) \\<and>\n        y \\<in> S;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (AE \\<omega> in T\n    z. (HLD \\<Phi> suntil HLD \\<Psi>) (z ## \\<omega>)) \\<and>\n                         z \\<in> S", "case (step t u)"], ["proof (state)\nthis:\n  (s, t) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*\n  (t, u) \\<in> Sigma (\\<Phi> - \\<Psi>) E\n  s \\<in> S \\<Longrightarrow>\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. s \\<in> S \\<Longrightarrow>\n    (AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                          (s ## \\<omega>)) \\<and>\n    s \\<in> S\n 2. \\<And>y z.\n       \\<lbrakk>(s, y) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*;\n        (y, z) \\<in> Sigma (\\<Phi> - \\<Psi>) E;\n        s \\<in> S \\<Longrightarrow>\n        (AE \\<omega> in T y. (HLD \\<Phi> suntil HLD \\<Psi>)\n                              (y ## \\<omega>)) \\<and>\n        y \\<in> S;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (AE \\<omega> in T\n    z. (HLD \\<Phi> suntil HLD \\<Psi>) (z ## \\<omega>)) \\<and>\n                         z \\<in> S", "with E_closed"], ["proof (chain)\npicking this:\n  \\<Union> (E ` S) \\<subseteq> S\n  (s, t) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*\n  (t, u) \\<in> Sigma (\\<Phi> - \\<Psi>) E\n  s \\<in> S \\<Longrightarrow>\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S\n  s \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n  (s, t) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>*\n  (t, u) \\<in> Sigma (\\<Phi> - \\<Psi>) E\n  s \\<in> S \\<Longrightarrow>\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (AE \\<omega> in T u. (HLD \\<Phi> suntil HLD \\<Psi>)\n                          (u ## \\<omega>)) \\<and>\n    u \\<in> S", "by (auto simp add: AE_T_iff[of _ t] suntil_Stream)"], ["proof (state)\nthis:\n  (AE \\<omega> in T u. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (u ## \\<omega>)) \\<and>\n  u \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    (AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                          (s ## \\<omega>)) \\<and>\n    s \\<in> S", "qed (insert s, auto)"], ["proof (state)\nthis:\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "then"], ["proof (chain)\npicking this:\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S", "have \"t \\<notin> ?P0\""], ["proof (prove)\nusing this:\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. t \\<notin> Prob0 \\<Phi> \\<Psi>", "unfolding Prob0_iff[OF assms]"], ["proof (prove)\nusing this:\n  (AE \\<omega> in T t. (HLD \\<Phi> suntil HLD \\<Psi>)\n                        (t ## \\<omega>)) \\<and>\n  t \\<in> S\n\ngoal (1 subgoal):\n 1. t \\<notin> {s \\<in> S.\n                AE \\<omega> in T s. \\<not> (HLD \\<Phi> suntil HLD \\<Psi>)\n      (s ## \\<omega>)}", "by (auto dest: T.AE_contr)"], ["proof (state)\nthis:\n  t \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "}"], ["proof (state)\nthis:\n  (s, ?t3) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* \\<Longrightarrow>\n  ?t3 \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>)\n                             (s ## \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n                         Prob0 \\<Phi> \\<Psi> =\n                         {}", "then"], ["proof (chain)\npicking this:\n  (s, ?t3) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* \\<Longrightarrow>\n  ?t3 \\<notin> Prob0 \\<Phi> \\<Psi>", "show \"(Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> = {}\""], ["proof (prove)\nusing this:\n  (s, ?t3) \\<in> (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* \\<Longrightarrow>\n  ?t3 \\<notin> Prob0 \\<Phi> \\<Psi>\n\ngoal (1 subgoal):\n 1. (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter>\n    Prob0 \\<Phi> \\<Psi> =\n    {}", "by auto"], ["proof (state)\nthis:\n  (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {s \\<in> S.\n   (Sigma (\\<Phi> - \\<Psi>) E)\\<^sup>* `` {s} \\<inter> Prob0 \\<Phi> \\<Psi> =\n   {}} =\n  {s \\<in> S.\n   AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "finally"], ["proof (chain)\npicking this:\n  Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n  {s \\<in> S.\n   AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n  {s \\<in> S.\n   AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\n\ngoal (1 subgoal):\n 1. Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n    {s \\<in> S.\n     AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}", "."], ["proof (state)\nthis:\n  Prob1 (Prob0 \\<Phi> \\<Psi>) \\<Phi> \\<Psi> =\n  {s \\<in> S.\n   AE \\<omega> in T s. (HLD \\<Phi> suntil HLD \\<Psi>) (s ## \\<omega>)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\\<open>ProbU\\<close>,  \\<open>ExpCumm\\<close>, and \\<open>ExpState\\<close>\\<close>"], ["", "abbreviation \"\\<tau> s t \\<equiv> pmf (K s) t\""], ["", "fun ProbU :: \"'s \\<Rightarrow> nat \\<Rightarrow> 's set \\<Rightarrow> 's set \\<Rightarrow> real\" where\n\"ProbU q 0 S1 S2       = (if q \\<in> S2 then 1 else 0)\" |\n\"ProbU q (Suc k) S1 S2 =\n  (if q \\<in> S1 - S2 then (\\<Sum>q'\\<in>S. \\<tau> q q' * ProbU q' k S1 S2)\n                  else if q \\<in> S2 then 1 else 0)\""], ["", "fun ExpCumm :: \"'s \\<Rightarrow> nat \\<Rightarrow> ennreal\" where\n\"ExpCumm s 0       = 0\" |\n\"ExpCumm s (Suc k) = \\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<iota> s s' + ExpCumm s' k))\""], ["", "fun ExpState :: \"'s \\<Rightarrow> nat \\<Rightarrow> ennreal\" where\n\"ExpState s 0       = \\<rho> s\" |\n\"ExpState s (Suc k) = (\\<Sum>s'\\<in>S. \\<tau> s s' * ExpState s' k)\""], ["", "subsubsection \\<open>\\<open>LES\\<close>\\<close>"], ["", "definition LES :: \"'s set \\<Rightarrow> 's \\<Rightarrow> 's \\<Rightarrow> real\" where\n  \"LES F r c =\n       (if r \\<in> F then (if c = r then 1 else 0)\n                 else (if c = r then \\<tau> r c - 1 else \\<tau> r c ))\""], ["", "subsubsection \\<open>\\<open>ProbUinfty\\<close>, compute unbounded until\\<close>"], ["", "definition ProbUinfty :: \"'s set \\<Rightarrow> 's set \\<Rightarrow> ('s \\<Rightarrow> real) option\" where\n  \"ProbUinfty S1 S2 = gauss_jordan' (LES (Prob0 S1 S2 \\<union> S2))\n                                    (\\<lambda>i. if i \\<in> S2 then 1 else 0)\""], ["", "subsubsection \\<open>\\<open>ExpFuture\\<close>, compute unbounded reward\\<close>"], ["", "definition ExpFuture :: \"'s set \\<Rightarrow> ('s \\<Rightarrow> ennreal) option\" where\n  \"ExpFuture F = do {\n      let N = Prob0 S F ;\n      let Y = Prob1 N S F ;\n      sol \\<leftarrow> gauss_jordan' (LES (S - Y \\<union> F))\n        (\\<lambda>i. if i \\<in> Y \\<and> i \\<notin> F then - \\<rho> i - (\\<Sum>s'\\<in>S. \\<tau> i s' * \\<iota> i s') else 0) ;\n      Some (\\<lambda>s. if s \\<in> Y then ennreal (sol s) else \\<infinity>)\n    }\""], ["", "subsubsection \\<open>\\<open>Sat\\<close>\\<close>"], ["", "fun Sat :: \"'s sform \\<Rightarrow> 's set option\" where\n\"Sat true                   = Some S\" |\n\"Sat (Label L)              = Some {s \\<in> S. s \\<in> L}\" |\n\"Sat (Neg F)                = do { F \\<leftarrow> Sat F ; Some (S - F) }\" |\n\"Sat (And F1 F2)            = do { F1 \\<leftarrow> Sat F1 ; F2 \\<leftarrow> Sat F2 ; Some (F1 \\<inter> F2) }\" |\n\n\"Sat (Prob rel r (X F))        = do { F \\<leftarrow> Sat F ; Some {q \\<in> S. inrealrel rel r (\\<Sum>q'\\<in>F. \\<tau> q q')} }\" |\n\"Sat (Prob rel r (U k F1 F2))  = do { F1 \\<leftarrow> Sat F1 ; F2 \\<leftarrow> Sat F2 ; Some {q \\<in> S. inrealrel rel r (ProbU q k F1 F2) } }\" |\n\"Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2))   = do { F1 \\<leftarrow> Sat F1 ; F2 \\<leftarrow> Sat F2 ; P \\<leftarrow> ProbUinfty F1 F2 ; Some {q \\<in> S. inrealrel rel r (P q) } }\" |\n\n\"Sat (Exp rel r (Cumm k))      = Some {s \\<in> S. inrealrel rel r (ExpCumm s k) }\" |\n\"Sat (Exp rel r (State k))     = Some {s \\<in> S. inrealrel rel r (ExpState s k) }\" |\n\"Sat (Exp rel r (Future F))    = do { F \\<leftarrow> Sat F ; E \\<leftarrow> ExpFuture F ; Some {q \\<in> S. inrealrel rel (ennreal r) (E q) } }\""], ["", "lemma prob_sum:\n  \"s \\<in> S \\<Longrightarrow> Measurable.pred R.S P \\<Longrightarrow> \\<P>(\\<omega> in T s. P \\<omega>) = (\\<Sum>t\\<in>S. \\<tau> s t * \\<P>(\\<omega> in T t. P (t ## \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S;\n     Measurable.pred (stream_space (count_space UNIV)) P\\<rbrakk>\n    \\<Longrightarrow> prob s P =\n                      (\\<Sum>t\\<in>S.\n                         \\<tau> s t *\n                         prob t (\\<lambda>\\<omega>. P (t ## \\<omega>)))", "unfolding prob_T"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S;\n     Measurable.pred (stream_space (count_space UNIV)) P\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation (K s)\n                       (\\<lambda>t.\n                           prob t (\\<lambda>\\<omega>. P (t ## \\<omega>))) =\n                      (\\<Sum>t\\<in>S.\n                         \\<tau> s t *\n                         prob t (\\<lambda>\\<omega>. P (t ## \\<omega>)))", "using E_closed"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S;\n     Measurable.pred (stream_space (count_space UNIV)) P\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation (K s)\n                       (\\<lambda>t.\n                           prob t (\\<lambda>\\<omega>. P (t ## \\<omega>))) =\n                      (\\<Sum>t\\<in>S.\n                         \\<tau> s t *\n                         prob t (\\<lambda>\\<omega>. P (t ## \\<omega>)))", "by (subst integral_measure_pmf[OF finite_S]) (auto simp: mult.commute)"], ["", "lemma nn_integral_eq_sum:\n  \"s \\<in> S \\<Longrightarrow> f \\<in> borel_measurable R.S \\<Longrightarrow> (\\<integral>\\<^sup>+x. f x \\<partial>T s) = (\\<Sum>t\\<in>S. \\<tau> s t * (\\<integral>\\<^sup>+x. f (t ## x) \\<partial>T t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S;\n     f \\<in> borel_measurable (stream_space (count_space UNIV))\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (T s) f =\n                      (\\<Sum>t\\<in>S.\n                         ennreal (\\<tau> s t) *\n                         \\<integral>\\<^sup>+ x. f (t ## x) \\<partial>T t)", "unfolding nn_integral_T"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S;\n     f \\<in> borel_measurable (stream_space (count_space UNIV))\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ t.\n     \\<integral>\\<^sup>+ \\<omega>. f (t ## \\<omega>) \\<partial>T t\n   \\<partial>measure_pmf (K s) =\n                      (\\<Sum>t\\<in>S.\n                         ennreal (\\<tau> s t) *\n                         \\<integral>\\<^sup>+ x. f (t ## x) \\<partial>T t)", "using E_closed"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> S;\n     f \\<in> borel_measurable (stream_space (count_space UNIV))\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ t.\n     \\<integral>\\<^sup>+ \\<omega>. f (t ## \\<omega>) \\<partial>T t\n   \\<partial>measure_pmf (K s) =\n                      (\\<Sum>t\\<in>S.\n                         ennreal (\\<tau> s t) *\n                         \\<integral>\\<^sup>+ x. f (t ## x) \\<partial>T t)", "by (subst nn_integral_measure_pmf_support[OF finite_S])\n     (auto simp: mult.commute)"], ["", "lemma T_space[simp]: \"measure (T s) (space R.S) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob s (space (stream_space (count_space UNIV))) = 1", "using T.prob_space"], ["proof (prove)\nusing this:\n  T.prob ?s (space (T ?s)) = 1\n\ngoal (1 subgoal):\n 1. T.prob s (space (stream_space (count_space UNIV))) = 1", "by simp"], ["", "lemma emeasure_T_space[simp]: \"emeasure (T s) (space R.S) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T s) (space (stream_space (count_space UNIV))) = 1", "using T.emeasure_space_1"], ["proof (prove)\nusing this:\n  emeasure (T ?s) (space (T ?s)) = 1\n\ngoal (1 subgoal):\n 1. emeasure (T s) (space (stream_space (count_space UNIV))) = 1", "by simp"], ["", "lemma \\<tau>_distr[simp]: \"s \\<in> S \\<Longrightarrow> (\\<Sum>t\\<in>S. \\<tau> s t) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> sum (\\<tau> s) S = 1", "using prob_sum[of s \"\\<lambda>_. True\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S;\n   Measurable.pred (stream_space (count_space UNIV))\n    (\\<lambda>_. True)\\<rbrakk>\n  \\<Longrightarrow> prob s (\\<lambda>\\<omega>. True) =\n                    (\\<Sum>t\\<in>S.\n                       \\<tau> s t * prob t (\\<lambda>\\<omega>. True))\n\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> sum (\\<tau> s) S = 1", "by simp"], ["", "lemma ProbU:\n  \"q \\<in> S \\<Longrightarrow> ProbU q k (svalid F1) (svalid F2) = \\<P>(\\<omega> in T q. pvalid (U k F1 F2) (q ## \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> S \\<Longrightarrow>\n    ProbU q k (svalid F1) (svalid F2) =\n    prob q (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>))", "proof (induct k arbitrary: q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       q \\<in> S \\<Longrightarrow>\n       ProbU q 0 (svalid F1) (svalid F2) =\n       prob q (\\<lambda>\\<omega>. pvalid (U 0 F1 F2) (q ## \\<omega>))\n 2. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "case 0"], ["proof (state)\nthis:\n  q \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       q \\<in> S \\<Longrightarrow>\n       ProbU q 0 (svalid F1) (svalid F2) =\n       prob q (\\<lambda>\\<omega>. pvalid (U 0 F1 F2) (q ## \\<omega>))\n 2. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "with T.prob_space"], ["proof (chain)\npicking this:\n  T.prob ?s (space (T ?s)) = 1\n  q \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  T.prob ?s (space (T ?s)) = 1\n  q \\<in> S\n\ngoal (1 subgoal):\n 1. ProbU q 0 (svalid F1) (svalid F2) =\n    prob q (\\<lambda>\\<omega>. pvalid (U 0 F1 F2) (q ## \\<omega>))", "by simp"], ["proof (state)\nthis:\n  ProbU q 0 (svalid F1) (svalid F2) =\n  prob q (\\<lambda>\\<omega>. pvalid (U 0 F1 F2) (q ## \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "case (Suc k)"], ["proof (state)\nthis:\n  ?q1 \\<in> S \\<Longrightarrow>\n  ProbU ?q1 k (svalid F1) (svalid F2) =\n  prob ?q1 (\\<lambda>\\<omega>. pvalid (U k F1 F2) (?q1 ## \\<omega>))\n  q \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "have \"\\<P>(\\<omega> in T q. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n    (if q \\<in> svalid F2 then 1 else if q \\<in> svalid F1 then\n      \\<Sum>t\\<in>S. \\<tau> q t * \\<P>(\\<omega> in T t. pvalid (U k F1 F2) (t ## \\<omega>)) else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n    (if q \\<in> svalid F2 then 1\n     else if q \\<in> svalid F1\n          then \\<Sum>t\\<in>S.\n                 \\<tau> q t *\n                 prob t\n                  (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n          else 0)", "using \\<open>q \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  q \\<in> S\n\ngoal (1 subgoal):\n 1. prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n    (if q \\<in> svalid F2 then 1\n     else if q \\<in> svalid F1\n          then \\<Sum>t\\<in>S.\n                 \\<tau> q t *\n                 prob t\n                  (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n          else 0)", "by (subst prob_sum) simp_all"], ["proof (state)\nthis:\n  prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n  (if q \\<in> svalid F2 then 1\n   else if q \\<in> svalid F1\n        then \\<Sum>t\\<in>S.\n               \\<tau> q t *\n               prob t\n                (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n        else 0)\n\ngoal (1 subgoal):\n 1. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "also"], ["proof (state)\nthis:\n  prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n  (if q \\<in> svalid F2 then 1\n   else if q \\<in> svalid F1\n        then \\<Sum>t\\<in>S.\n               \\<tau> q t *\n               prob t\n                (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n        else 0)\n\ngoal (1 subgoal):\n 1. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "have \"\\<dots> = ProbU q (Suc k) (svalid F1) (svalid F2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if q \\<in> svalid F2 then 1\n     else if q \\<in> svalid F1\n          then \\<Sum>t\\<in>S.\n                 \\<tau> q t *\n                 prob t\n                  (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n          else 0) =\n    ProbU q (Suc k) (svalid F1) (svalid F2)", "using Suc"], ["proof (prove)\nusing this:\n  ?q1 \\<in> S \\<Longrightarrow>\n  ProbU ?q1 k (svalid F1) (svalid F2) =\n  prob ?q1 (\\<lambda>\\<omega>. pvalid (U k F1 F2) (?q1 ## \\<omega>))\n  q \\<in> S\n\ngoal (1 subgoal):\n 1. (if q \\<in> svalid F2 then 1\n     else if q \\<in> svalid F1\n          then \\<Sum>t\\<in>S.\n                 \\<tau> q t *\n                 prob t\n                  (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n          else 0) =\n    ProbU q (Suc k) (svalid F1) (svalid F2)", "by simp"], ["proof (state)\nthis:\n  (if q \\<in> svalid F2 then 1\n   else if q \\<in> svalid F1\n        then \\<Sum>t\\<in>S.\n               \\<tau> q t *\n               prob t\n                (\\<lambda>\\<omega>. pvalid (U k F1 F2) (t ## \\<omega>))\n        else 0) =\n  ProbU q (Suc k) (svalid F1) (svalid F2)\n\ngoal (1 subgoal):\n 1. \\<And>k q.\n       \\<lbrakk>\\<And>q.\n                   q \\<in> S \\<Longrightarrow>\n                   ProbU q k (svalid F1) (svalid F2) =\n                   prob q\n                    (\\<lambda>\\<omega>. pvalid (U k F1 F2) (q ## \\<omega>));\n        q \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ProbU q (Suc k) (svalid F1) (svalid F2) =\n                         prob q\n                          (\\<lambda>\\<omega>.\n                              pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", "finally"], ["proof (chain)\npicking this:\n  prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n  ProbU q (Suc k) (svalid F1) (svalid F2)", "show ?case"], ["proof (prove)\nusing this:\n  prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>)) =\n  ProbU q (Suc k) (svalid F1) (svalid F2)\n\ngoal (1 subgoal):\n 1. ProbU q (Suc k) (svalid F1) (svalid F2) =\n    prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>))", ".."], ["proof (state)\nthis:\n  ProbU q (Suc k) (svalid F1) (svalid F2) =\n  prob q (\\<lambda>\\<omega>. pvalid (U (Suc k) F1 F2) (q ## \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Prob0_imp_not_Psi:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\" \"s \\<in> Prob0 \\<Phi> \\<Psi>\" shows \"s \\<notin> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> \\<Psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> \\<Psi>", "have \"s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S", "using \\<open>s \\<in> Prob0 \\<Phi> \\<Psi>\\<close> Prob0_subset_S"], ["proof (prove)\nusing this:\n  s \\<in> Prob0 \\<Phi> \\<Psi>\n  Prob0 ?\\<Phi> ?\\<Psi> \\<subseteq> S\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<notin> \\<Psi>", "with assms"], ["proof (chain)\npicking this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> S\n  s \\<in> Prob0 \\<Phi> \\<Psi>\n  s \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> \\<subseteq> S\n  \\<Psi> \\<subseteq> S\n  s \\<in> Prob0 \\<Phi> \\<Psi>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<notin> \\<Psi>", "by (auto simp add: Prob0_iff suntil_Stream)"], ["proof (state)\nthis:\n  s \\<notin> \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Psi_imp_not_Prob0:\n  assumes \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\" shows \"s \\<in> \\<Psi> \\<Longrightarrow> s \\<notin> Prob0 \\<Phi> \\<Psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> \\<Psi> \\<Longrightarrow> s \\<notin> Prob0 \\<Phi> \\<Psi>", "using Prob0_imp_not_Psi[OF assms]"], ["proof (prove)\nusing this:\n  ?s \\<in> Prob0 \\<Phi> \\<Psi> \\<Longrightarrow> ?s \\<notin> \\<Psi>\n\ngoal (1 subgoal):\n 1. s \\<in> \\<Psi> \\<Longrightarrow> s \\<notin> Prob0 \\<Phi> \\<Psi>", "by metis"], ["", "subsubsection \\<open>Finite expected reward\\<close>"], ["", "abbreviation \"s0 \\<equiv> SOME s. s \\<in> S\""], ["", "lemma s0_in_S: \"s0 \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s0 \\<in> S", "using S_not_empty"], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s0 \\<in> S", "by (auto intro!: someI_ex[of \"\\<lambda>x. x \\<in> S\"])"], ["", "lemma nn_integral_reward_finite:\n  assumes \"s \\<in> S\"\n  assumes until: \"AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\"\n  shows \"(\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "have \"(\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) = (\\<integral>\\<^sup>+ \\<omega>. reward_until (svalid F) s \\<omega> \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    integral\\<^sup>N (T s) (reward_until (svalid F) s)", "using until"], ["proof (prove)\nusing this:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    integral\\<^sup>N (T s) (reward_until (svalid F) s)", "by (auto intro!: nn_integral_cong_AE ev_suntil)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  integral\\<^sup>N (T s) (reward_until (svalid F) s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  integral\\<^sup>N (T s) (reward_until (svalid F) s)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "have \"\\<dots> \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>\n 2. \\<not> ?P \\<Longrightarrow>\n    integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>", "assume \"s \\<notin> svalid F\""], ["proof (state)\nthis:\n  s \\<notin> svalid F\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>\n 2. \\<not> ?P \\<Longrightarrow>\n    integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>", "proof (rule nn_integral_reward_until_finite)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - svalid F)\\<^sup>* \\<Longrightarrow>\n       ennreal (\\<rho> t) < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - svalid F)\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<iota> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD (svalid F)))", "have \"acc `` {s} \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> S", "using E_rtrancl_closed[of s _ _ E] \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S; (s, ?t) \\<in> (Sigma ?A E)\\<^sup>*;\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> E x \\<subseteq> E x\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> S\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> S\n\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - svalid F)\\<^sup>* \\<Longrightarrow>\n       ennreal (\\<rho> t) < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - svalid F)\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<iota> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD (svalid F)))", "then"], ["proof (chain)\npicking this:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> S", "show \"finite (acc `` {s})\""], ["proof (prove)\nusing this:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})", "using finite_S"], ["proof (prove)\nusing this:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> S\n  finite S\n\ngoal (1 subgoal):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})", "by (auto dest: finite_subset)"], ["proof (state)\nthis:\n  finite ((Sigma UNIV E)\\<^sup>* `` {s})\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - svalid F)\\<^sup>* \\<Longrightarrow>\n       ennreal (\\<rho> t) < \\<infinity>\n 2. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - svalid F)\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<iota> t t') < \\<infinity>\n 3. almost_everywhere (T s) (ev (HLD (svalid F)))", "show \"AE \\<omega> in T s. (ev (HLD (svalid F))) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (ev (HLD (svalid F)))", "using until"], ["proof (prove)\nusing this:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (ev (HLD (svalid F)))", "by (auto simp add: suntil_Stream \\<open>s \\<notin> svalid F\\<close> intro: ev_suntil)"], ["proof (state)\nthis:\n  almost_everywhere (T s) (ev (HLD (svalid F)))\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - svalid F)\\<^sup>* \\<Longrightarrow>\n       ennreal (\\<rho> t) < \\<infinity>\n 2. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - svalid F)\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<iota> t t') < \\<infinity>", "qed auto"], ["proof (state)\nthis:\n  integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> s \\<notin> svalid F \\<Longrightarrow>\n    integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>", "qed simp"], ["proof (state)\nthis:\n  integral\\<^sup>N (T s) (reward_until (svalid F) s) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "."], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique:\n  assumes in_S: \"\\<Phi> \\<subseteq> S\" \"\\<Psi> \\<subseteq> S\" \"N \\<subseteq> S\" \"Prob0 \\<Phi> \\<Psi> \\<subseteq> N\" \"\\<Psi> \\<subseteq> N\"\n  assumes l1: \"\\<And>s. s \\<in> S \\<Longrightarrow> s \\<notin> N \\<Longrightarrow> l1 s - c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l1 s')\"\n  assumes l2: \"\\<And>s. s \\<in> S \\<Longrightarrow> s \\<notin> N \\<Longrightarrow> l2 s - c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l2 s')\"\n  assumes eq: \"\\<And>s. s \\<in> N \\<Longrightarrow> l1 s = l2 s\"\n  shows \"\\<forall>s\\<in>S. l1 s = l2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S. l1 s = l2 s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> l1 s = l2 s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> l1 s = l2 s", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> S \\<Longrightarrow> l1 s = l2 s", "show \"l1 s = l2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 s = l2 s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l1 s = l2 s\n 2. \\<not> ?P \\<Longrightarrow> l1 s = l2 s", "assume \"s \\<in> N\""], ["proof (state)\nthis:\n  s \\<in> N\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> l1 s = l2 s\n 2. \\<not> ?P \\<Longrightarrow> l1 s = l2 s", "then"], ["proof (chain)\npicking this:\n  s \\<in> N", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> N\n\ngoal (1 subgoal):\n 1. l1 s = l2 s", "by (rule eq)"], ["proof (state)\nthis:\n  l1 s = l2 s\n\ngoal (1 subgoal):\n 1. s \\<notin> N \\<Longrightarrow> l1 s = l2 s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> N \\<Longrightarrow> l1 s = l2 s", "assume \"s \\<notin> N\""], ["proof (state)\nthis:\n  s \\<notin> N\n\ngoal (1 subgoal):\n 1. s \\<notin> N \\<Longrightarrow> l1 s = l2 s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 s = l2 s", "proof (rule unique_les[of _ \"S - N\" K N])"], ["proof (state)\ngoal (9 subgoals):\n 1. s \\<in> S - N\n 2. \\<Union> (E ` (S - N)) \\<subseteq> S - N \\<union> N\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l2\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l1\n 5. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 6. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 7. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s\n 8. \\<And>s. s \\<in> N \\<Longrightarrow> l1 s = l2 s\n 9. finite ((\\<lambda>x. l1 x - l2 x) ` (S - N \\<union> N))", "show \"finite ((\\<lambda>x. l1 x - l2 x) ` (S - N \\<union> N))\" \"(\\<Union>x\\<in>S - N. E x) \\<subseteq> S - N \\<union> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((\\<lambda>x. l1 x - l2 x) ` (S - N \\<union> N)) &&&\n    \\<Union> (E ` (S - N)) \\<subseteq> S - N \\<union> N", "using E_closed finite_S \\<open>N \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n  finite S\n  N \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>x. l1 x - l2 x) ` (S - N \\<union> N)) &&&\n    \\<Union> (E ` (S - N)) \\<subseteq> S - N \\<union> N", "by (auto dest: finite_subset)"], ["proof (state)\nthis:\n  finite ((\\<lambda>x. l1 x - l2 x) ` (S - N \\<union> N))\n  \\<Union> (E ` (S - N)) \\<subseteq> S - N \\<union> N\n\ngoal (7 subgoals):\n 1. s \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l2\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l1\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 5. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 6. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s\n 7. \\<And>s. s \\<in> N \\<Longrightarrow> l1 s = l2 s", "show \"\\<And>s. s \\<in> N \\<Longrightarrow> l1 s = l2 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. s \\<in> N \\<Longrightarrow> l1 s = l2 s", "by fact"], ["proof (state)\nthis:\n  ?s1 \\<in> N \\<Longrightarrow> l1 ?s1 = l2 ?s1\n\ngoal (6 subgoals):\n 1. s \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l2\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l1\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 5. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 6. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "{"], ["proof (state)\nthis:\n  ?s1 \\<in> N \\<Longrightarrow> l1 ?s1 = l2 ?s1\n\ngoal (6 subgoals):\n 1. s \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l2\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l1\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 5. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 6. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "fix s"], ["proof (state)\ngoal (6 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l2\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l1\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 5. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 6. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "assume \"s \\<in> S - N\""], ["proof (state)\nthis:\n  s \\<in> S - N\n\ngoal (6 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l2\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow> integrable (measure_pmf (K s)) l1\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 5. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 6. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "with E_closed finite_S"], ["proof (chain)\npicking this:\n  \\<Union> (E ` S) \\<subseteq> S\n  finite S\n  s \\<in> S - N", "show \"integrable (K s) l1\" \"integrable (K s) l2\""], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n  finite S\n  s \\<in> S - N\n\ngoal (1 subgoal):\n 1. integrable (measure_pmf (K s)) l1 &&& integrable (measure_pmf (K s)) l2", "by (auto intro!: integrable_measure_pmf_finite dest: finite_subset)"], ["proof (state)\nthis:\n  integrable (measure_pmf (K s)) l1\n  integrable (measure_pmf (K s)) l2\n\ngoal (4 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "obtain t where \"(t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>*) \\<or> s \\<in> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n        s \\<in> N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>s \\<in> S - N\\<close> in_S(4)"], ["proof (prove)\nusing this:\n  s \\<in> S - N\n  Prob0 \\<Phi> \\<Psi> \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n        s \\<in> N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Prob0_iff_reachable[OF in_S(1,2)]"], ["proof (prove)\nusing this:\n  s \\<in> S - N\n  {s \\<in> S. (Sigma \\<Phi> E)\\<^sup>* `` {s} \\<inter> \\<Psi> = {}}\n  \\<subseteq> N\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n        s \\<in> N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n  s \\<in> N\n\ngoal (4 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "moreover"], ["proof (state)\nthis:\n  t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n  s \\<in> N\n\ngoal (4 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "have \"(Sigma \\<Phi> E)\\<^sup>* \\<subseteq> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Sigma \\<Phi> E)\\<^sup>* \\<subseteq> (Sigma UNIV E)\\<^sup>*", "by (intro rtrancl_mono Sigma_mono) auto"], ["proof (state)\nthis:\n  (Sigma \\<Phi> E)\\<^sup>* \\<subseteq> (Sigma UNIV E)\\<^sup>*\n\ngoal (4 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 4. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "ultimately"], ["proof (chain)\npicking this:\n  t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n  s \\<in> N\n  (Sigma \\<Phi> E)\\<^sup>* \\<subseteq> (Sigma UNIV E)\\<^sup>*", "show \"\\<exists>t\\<in>N. (s, t) \\<in> acc\""], ["proof (prove)\nusing this:\n  t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n  s \\<in> N\n  (Sigma \\<Phi> E)\\<^sup>* \\<subseteq> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*", "using \\<open>\\<Psi> \\<subseteq> N\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> \\<Psi> \\<and> (s, t) \\<in> (Sigma \\<Phi> E)\\<^sup>* \\<or>\n  s \\<in> N\n  (Sigma \\<Phi> E)\\<^sup>* \\<subseteq> (Sigma UNIV E)\\<^sup>*\n  \\<Psi> \\<subseteq> N\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (3 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + ?c s\n 3. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l1 s = measure_pmf.expectation (K s) l1 + ?c s", "show \"l1 s = integral\\<^sup>L (K s) l1 + c s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 s = measure_pmf.expectation (K s) l1 + c s", "using E_closed l1 \\<open>s \\<in> S - N\\<close>"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n  \\<lbrakk>?s1 \\<in> S; ?s1 \\<notin> N\\<rbrakk>\n  \\<Longrightarrow> l1 ?s1 - c ?s1 = (\\<Sum>s'\\<in>S. \\<tau> ?s1 s' * l1 s')\n  s \\<in> S - N\n\ngoal (1 subgoal):\n 1. l1 s = measure_pmf.expectation (K s) l1 + c s", "by (subst integral_measure_pmf[OF finite_S]) (auto simp: subset_eq field_simps)"], ["proof (state)\nthis:\n  l1 s = measure_pmf.expectation (K s) l1 + c s\n\ngoal (2 subgoals):\n 1. s__ \\<in> S - N\n 2. \\<And>s.\n       s \\<in> S - N \\<Longrightarrow>\n       l2 s = measure_pmf.expectation (K s) l2 + c s", "show \"l2 s = integral\\<^sup>L (K s) l2 + c s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 s = measure_pmf.expectation (K s) l2 + c s", "using E_closed l2 \\<open>s \\<in> S - N\\<close>"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n  \\<lbrakk>?s1 \\<in> S; ?s1 \\<notin> N\\<rbrakk>\n  \\<Longrightarrow> l2 ?s1 - c ?s1 = (\\<Sum>s'\\<in>S. \\<tau> ?s1 s' * l2 s')\n  s \\<in> S - N\n\ngoal (1 subgoal):\n 1. l2 s = measure_pmf.expectation (K s) l2 + c s", "by (subst integral_measure_pmf[OF finite_S]) (auto simp: subset_eq field_simps)"], ["proof (state)\nthis:\n  l2 s = measure_pmf.expectation (K s) l2 + c s\n\ngoal (1 subgoal):\n 1. s__ \\<in> S - N", "}"], ["proof (state)\nthis:\n  ?sa3 \\<in> S - N \\<Longrightarrow>\n  l2 ?sa3 = measure_pmf.expectation (K ?sa3) l2 + c ?sa3\n\ngoal (1 subgoal):\n 1. s \\<in> S - N", "qed (insert \\<open>s \\<notin>  N\\<close> \\<open>s \\<in> S\\<close>, auto)"], ["proof (state)\nthis:\n  l1 s = l2 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l1 s = l2 s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniqueness_of_ProbU:\n  assumes sol:\n    \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' * l s') =\n      (if s \\<in> svalid F2 then 1 else 0)\"\n  shows \"\\<forall>s\\<in>S. l s = \\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "proof (rule unique)"], ["proof (state)\ngoal (8 subgoals):\n 1. ?\\<Phi> \\<subseteq> S\n 2. ?\\<Psi> \\<subseteq> S\n 3. ?N \\<subseteq> S\n 4. Prob0 ?\\<Phi> ?\\<Psi> \\<subseteq> ?N\n 5. ?\\<Psi> \\<subseteq> ?N\n 6. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> ?N\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 7. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> ?N\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 8. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "show \"svalid F1 \\<subseteq> S\" \"svalid F2 \\<subseteq> S\"\n    \"Prob0 (svalid F1) (svalid F2) \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\"\n    \"svalid F2 \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\"\n    \"Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (svalid F1 \\<subseteq> S &&& svalid F2 \\<subseteq> S) &&&\n    Prob0 (svalid F1) (svalid F2)\n    \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 &&&\n    svalid F2\n    \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 &&&\n    Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 \\<subseteq> S", "using svalid_subset_S"], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (svalid F1 \\<subseteq> S &&& svalid F2 \\<subseteq> S) &&&\n    Prob0 (svalid F1) (svalid F2)\n    \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 &&&\n    svalid F2\n    \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 &&&\n    Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 \\<subseteq> S", "by (auto simp: Prob0_def)"], ["proof (state)\nthis:\n  svalid F1 \\<subseteq> S\n  svalid F2 \\<subseteq> S\n  Prob0 (svalid F1) (svalid F2)\n  \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n  svalid F2 \\<subseteq> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n  Prob0 (svalid F1) (svalid F2) \\<union> svalid F2 \\<subseteq> S\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "assume s: \"s \\<in> S\" \"s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\""], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "have \"(\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')", "by (auto intro!: sum.cong simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "also"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "have \"\\<dots> = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s", "by (simp add: sum_subtractf single_l)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 3. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s", "show \"l s - 0 = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\""], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\n\ngoal (1 subgoal):\n 1. l s - 0 = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')", "using sol[THEN bspec, of s] s"], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\n  s \\<in> S \\<Longrightarrow>\n  (\\<Sum>s'\\<in>S.\n     LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' * l s') =\n  (if s \\<in> svalid F2 then 1 else 0)\n  s \\<in> S\n  s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n\ngoal (1 subgoal):\n 1. l s - 0 = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')", "by (simp add: LES_def)"], ["proof (state)\nthis:\n  l s - 0 = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         0 =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 2. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         0 =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 2. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         0 =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 2. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "assume s: \"s \\<in> S\" \"s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\""], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S;\n        s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\\<rbrakk>\n       \\<Longrightarrow> prob s\n                          (\\<lambda>\\<omega>.\n                              pvalid (U\\<^sup>\\<infinity> F1 F2)\n                               (s ## \\<omega>)) -\n                         0 =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> F1 F2)\n                                  (s' ## \\<omega>)))\n 2. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2", "show \"\\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) - 0 =\n    (\\<Sum>t\\<in>S. \\<tau> s t * \\<P>(\\<omega> in T t. pvalid (U\\<^sup>\\<infinity> F1 F2) (t ## \\<omega>)))\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n\ngoal (1 subgoal):\n 1. prob s\n     (\\<lambda>\\<omega>.\n         pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) -\n    0 =\n    (\\<Sum>t\\<in>S.\n       \\<tau> s t *\n       prob t\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (t ## \\<omega>)))", "unfolding Prob0_iff[OF svalid_subset_S svalid_subset_S]"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> {s \\<in> S.\n              AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil\n    HLD (svalid F2))\n    (s ## \\<omega>)} \\<union>\n             svalid F2\n\ngoal (1 subgoal):\n 1. prob s\n     (\\<lambda>\\<omega>.\n         pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) -\n    0 =\n    (\\<Sum>t\\<in>S.\n       \\<tau> s t *\n       prob t\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (t ## \\<omega>)))", "by (subst prob_sum) (auto simp add: suntil_Stream)"], ["proof (state)\nthis:\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) -\n  0 =\n  (\\<Sum>t\\<in>S.\n     \\<tau> s t *\n     prob t\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> F1 F2) (t ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "assume \"s \\<in> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\""], ["proof (state)\nthis:\n  s \\<in> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> Prob0 (svalid F1) (svalid F2) \\<union>\n               svalid F2 \\<Longrightarrow>\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  s \\<in> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2", "show \"l s = \\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\""], ["proof (prove)\nusing this:\n  s \\<in> Prob0 (svalid F1) (svalid F2) \\<union> svalid F2\n\ngoal (1 subgoal):\n 1. l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<in> Prob0 (svalid F1) (svalid F2) \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n 2. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "assume P0: \"s \\<in> Prob0 (svalid F1) (svalid F2)\""], ["proof (state)\nthis:\n  s \\<in> Prob0 (svalid F1) (svalid F2)\n\ngoal (2 subgoals):\n 1. s \\<in> Prob0 (svalid F1) (svalid F2) \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n 2. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  s \\<in> Prob0 (svalid F1) (svalid F2)", "have \"s \\<in> S\" \"AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil HLD (svalid F2)) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<in> Prob0 (svalid F1) (svalid F2)\n\ngoal (1 subgoal):\n 1. s \\<in> S &&&\n    AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil HLD (svalid F2))\n                                (s ## \\<omega>)", "unfolding Prob0_iff[OF svalid_subset_S svalid_subset_S]"], ["proof (prove)\nusing this:\n  s \\<in> {s \\<in> S.\n           AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil\n HLD (svalid F2))\n (s ## \\<omega>)}\n\ngoal (1 subgoal):\n 1. s \\<in> S &&&\n    AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil HLD (svalid F2))\n                                (s ## \\<omega>)", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n  AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil HLD (svalid F2))\n                              (s ## \\<omega>)\n\ngoal (2 subgoals):\n 1. s \\<in> Prob0 (svalid F1) (svalid F2) \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n 2. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil HLD (svalid F2))\n                              (s ## \\<omega>)", "have \"\\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) = 0\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  AE \\<omega> in T s. \\<not> (HLD (svalid F1) suntil HLD (svalid F2))\n                              (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. prob s\n     (\\<lambda>\\<omega>.\n         pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) =\n    0", "by (intro T.prob_eq_0_AE) simp"], ["proof (state)\nthis:\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) =\n  0\n\ngoal (2 subgoals):\n 1. s \\<in> Prob0 (svalid F1) (svalid F2) \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n 2. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "moreover"], ["proof (state)\nthis:\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) =\n  0\n\ngoal (2 subgoals):\n 1. s \\<in> Prob0 (svalid F1) (svalid F2) \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n 2. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "have \"l s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l s = 0", "using \\<open>s \\<in> S\\<close> P0 sol[THEN bspec, of s] Prob0_subset_S\n        Prob0_imp_not_Psi[OF svalid_subset_S svalid_subset_S P0]"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<in> Prob0 (svalid F1) (svalid F2)\n  s \\<in> S \\<Longrightarrow>\n  (\\<Sum>s'\\<in>S.\n     LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' * l s') =\n  (if s \\<in> svalid F2 then 1 else 0)\n  Prob0 ?\\<Phi> ?\\<Psi> \\<subseteq> S\n  s \\<notin> svalid F2\n\ngoal (1 subgoal):\n 1. l s = 0", "by (auto simp: LES_def single_l split: if_split_asm)"], ["proof (state)\nthis:\n  l s = 0\n\ngoal (2 subgoals):\n 1. s \\<in> Prob0 (svalid F1) (svalid F2) \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n 2. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "ultimately"], ["proof (chain)\npicking this:\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) =\n  0\n  l s = 0", "show \"l s = \\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\""], ["proof (prove)\nusing this:\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>)) =\n  0\n  l s = 0\n\ngoal (1 subgoal):\n 1. l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "by simp"], ["proof (state)\nthis:\n  l s =\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "assume s: \"s \\<in> svalid F2\""], ["proof (state)\nthis:\n  s \\<in> svalid F2\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "moreover"], ["proof (state)\nthis:\n  s \\<in> svalid F2\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "with svalid_subset_S"], ["proof (chain)\npicking this:\n  svalid ?F \\<subseteq> S\n  s \\<in> svalid F2", "have \"s \\<in> S\""], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n  s \\<in> svalid F2\n\ngoal (1 subgoal):\n 1. s \\<in> S", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "moreover"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "note Psi_imp_not_Prob0[OF svalid_subset_S svalid_subset_S s]"], ["proof (state)\nthis:\n  s \\<notin> Prob0 (svalid ?F2) (svalid F2)\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "ultimately"], ["proof (chain)\npicking this:\n  s \\<in> svalid F2\n  s \\<in> S\n  s \\<notin> Prob0 (svalid ?F2) (svalid F2)", "have \"l s = 1\""], ["proof (prove)\nusing this:\n  s \\<in> svalid F2\n  s \\<in> S\n  s \\<notin> Prob0 (svalid ?F2) (svalid F2)\n\ngoal (1 subgoal):\n 1. l s = 1", "using sol[THEN bspec, of s]"], ["proof (prove)\nusing this:\n  s \\<in> svalid F2\n  s \\<in> S\n  s \\<notin> Prob0 (svalid ?F2) (svalid F2)\n  s \\<in> S \\<Longrightarrow>\n  (\\<Sum>s'\\<in>S.\n     LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' * l s') =\n  (if s \\<in> svalid F2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. l s = 1", "by (auto simp: LES_def single_l dest: Psi_imp_not_Prob0[OF svalid_subset_S svalid_subset_S])"], ["proof (state)\nthis:\n  l s = 1\n\ngoal (1 subgoal):\n 1. s \\<in> svalid F2 \\<Longrightarrow>\n    l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "then"], ["proof (chain)\npicking this:\n  l s = 1", "show \"l s = \\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\""], ["proof (prove)\nusing this:\n  l s = 1\n\ngoal (1 subgoal):\n 1. l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "using s"], ["proof (prove)\nusing this:\n  l s = 1\n  s \\<in> svalid F2\n\ngoal (1 subgoal):\n 1. l s =\n    prob s\n     (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "by (simp add: suntil_Stream)"], ["proof (state)\nthis:\n  l s =\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l s =\n  prob s\n   (\\<lambda>\\<omega>. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_reward:\n  fixes s F\n  defines \"N \\<equiv> Prob0 S (svalid F)\" (is \"_ \\<equiv> Prob0 S ?F\")\n  defines \"Y \\<equiv> Prob1 N S (svalid F)\"\n  assumes s: \"s \\<in> S\" \"s \\<notin> Y\"\n  shows \"(\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "assume \"(AE \\<omega> in T s. ev (HLD ?F) \\<omega>)\""], ["proof (state)\nthis:\n  almost_everywhere (T s) (ev (HLD (svalid F)))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "with AE_T_enabled"], ["proof (chain)\npicking this:\n  almost_everywhere (T ?s) (enabled ?s)\n  almost_everywhere (T s) (ev (HLD (svalid F)))", "have \"(AE \\<omega> in T s. (HLD S suntil HLD ?F) \\<omega>)\""], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (enabled ?s)\n  almost_everywhere (T s) (ev (HLD (svalid F)))\n\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (HLD S suntil HLD (svalid F))", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>enabled s \\<omega>; ev (HLD (svalid F)) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) \\<omega>", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>enabled s \\<omega>; ev (HLD (svalid F)) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) \\<omega>", "assume \"ev (HLD ?F) \\<omega>\" \"enabled s \\<omega>\""], ["proof (state)\nthis:\n  ev (HLD (svalid F)) \\<omega>\n  enabled s \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>enabled s \\<omega>; ev (HLD (svalid F)) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) \\<omega>", "from this \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  ev (HLD (svalid F)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S", "show \"(HLD S suntil HLD ?F) \\<omega>\""], ["proof (prove)\nusing this:\n  ev (HLD (svalid F)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (HLD S suntil HLD (svalid F)) \\<omega>", "proof (induction arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (svalid F) xs; enabled s xs; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) xs\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (svalid F)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S\\<rbrakk>\n           \\<Longrightarrow> (HLD S suntil HLD (svalid F)) (stl xs);\n        enabled s xs; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) xs", "case (step \\<omega>)"], ["proof (state)\nthis:\n  ev (HLD (svalid F)) (stl \\<omega>)\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (HLD S suntil HLD (svalid F)) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (svalid F) xs; enabled s xs; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) xs\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (svalid F)) (stl xs);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> S\\<rbrakk>\n           \\<Longrightarrow> (HLD S suntil HLD (svalid F)) (stl xs);\n        enabled s xs; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HLD S suntil HLD (svalid F)) \\<omega>", "using E_closed step.IH[of \"shd \\<omega>\"] step.prems"], ["proof (prove)\nusing this:\n  \\<Union> (E ` S) \\<subseteq> S\n  \\<lbrakk>enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> S\\<rbrakk>\n  \\<Longrightarrow> (HLD S suntil HLD (svalid F)) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (HLD S suntil HLD (svalid F)) \\<omega>", "by (auto simp: subset_eq enabled.simps[of s] suntil.simps[of _ _ \\<omega>] HLD_iff)"], ["proof (state)\nthis:\n  (HLD S suntil HLD (svalid F)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (svalid F) xs; enabled s xs; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (HLD S suntil HLD (svalid F)) xs", "qed (auto intro: suntil.intros)"], ["proof (state)\nthis:\n  (HLD S suntil HLD (svalid F)) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_everywhere (T s) (HLD S suntil HLD (svalid F))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "}"], ["proof (state)\nthis:\n  almost_everywhere (T s) (ev (HLD (svalid F))) \\<Longrightarrow>\n  almost_everywhere (T s) (HLD S suntil HLD (svalid F))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "moreover"], ["proof (state)\nthis:\n  almost_everywhere (T s) (ev (HLD (svalid F))) \\<Longrightarrow>\n  almost_everywhere (T s) (HLD S suntil HLD (svalid F))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "have \"\\<not> (AE \\<omega> in T s. (HLD S suntil HLD ?F) (s ## \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F))\n                                 (s ## \\<omega>))", "using s svalid_subset_S"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> Y\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F))\n                                 (s ## \\<omega>))", "unfolding N_def Y_def"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> Prob1 (Prob0 S (svalid F)) S (svalid F)\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F))\n                                 (s ## \\<omega>))", "by (simp add: Prob1_iff)"], ["proof (state)\nthis:\n  \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  almost_everywhere (T s) (ev (HLD (svalid F))) \\<Longrightarrow>\n  almost_everywhere (T s) (HLD S suntil HLD (svalid F))\n  \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>))", "have *: \"\\<not> (AE \\<omega> in T s. ev (HLD ?F) (s ## \\<omega>))\""], ["proof (prove)\nusing this:\n  almost_everywhere (T s) (ev (HLD (svalid F))) \\<Longrightarrow>\n  almost_everywhere (T s) (HLD S suntil HLD (svalid F))\n  \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<not> (AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>))", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  almost_everywhere (T s) (ev (HLD (svalid F))) \\<Longrightarrow>\n  almost_everywhere (T s) (HLD S suntil HLD (svalid F))\n  \\<not> (AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>))\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>))", "by (cases \"s \\<in> ?F\") (auto simp add: suntil_Stream ev_Stream)"], ["proof (state)\nthis:\n  \\<not> (AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    False", "from nn_integral_PInf_AE[OF _ this] \\<open>s\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  T.random_variable s borel\n   (\\<lambda>\\<omega>. reward (Future F) (s ## \\<omega>)) \\<Longrightarrow>\n  AE x in T s. reward (Future F) (s ## x) \\<noteq> \\<infinity>\n  s \\<in> S", "have \"AE \\<omega> in T s. ev (HLD ?F) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  T.random_variable s borel\n   (\\<lambda>\\<omega>. reward (Future F) (s ## \\<omega>)) \\<Longrightarrow>\n  AE x in T s. reward (Future F) (s ## x) \\<noteq> \\<infinity>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>)", "by (simp split: if_split_asm)"], ["proof (state)\nthis:\n  AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity> \\<Longrightarrow>\n    False", "with *"], ["proof (chain)\npicking this:\n  \\<not> (AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>))\n  AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>)", "show False"], ["proof (prove)\nusing this:\n  \\<not> (AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>))\n  AE \\<omega> in T s. ev (HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>The expected reward implies a unique LES\\<close>"], ["", "lemma existence_of_ExpFuture:\n  fixes s F\n  assumes N_def: \"N \\<equiv> Prob0 S (svalid F)\" (is \"_ \\<equiv> Prob0 S ?F\")\n  assumes Y_def: \"Y \\<equiv> Prob1 N S (svalid F)\"\n  assumes s: \"s \\<in> S\" \"s \\<notin> S - (Y - ?F)\"\n  shows \"enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s' ## \\<omega>) \\<partial>T s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "let ?R = \"reward (Future F)\""], ["proof (state)\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "from s"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)", "have \"s \\<in> Prob1 (Prob0 S ?F) S ?F\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)\n\ngoal (1 subgoal):\n 1. s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)", "unfolding Y_def N_def"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> S - (Prob1 (Prob0 S (svalid F)) S (svalid F) - svalid F)\n\ngoal (1 subgoal):\n 1. s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)", "by auto"], ["proof (state)\nthis:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "then"], ["proof (chain)\npicking this:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)", "have AE_until: \"AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "using Prob1_iff[of S ?F] svalid_subset_S"], ["proof (prove)\nusing this:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n  \\<lbrakk>S \\<subseteq> S; svalid F \\<subseteq> S\\<rbrakk>\n  \\<Longrightarrow> Prob1 (Prob0 S (svalid F)) S (svalid F) =\n                    {s \\<in> S.\n                     AE \\<omega> in T s. (HLD S suntil HLD (svalid F))\n    (s ## \\<omega>)}\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "by auto"], ["proof (state)\nthis:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "from s"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)", "have \"s \\<notin> ?F\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)\n\ngoal (1 subgoal):\n 1. s \\<notin> svalid F", "by auto"], ["proof (state)\nthis:\n  s \\<notin> svalid F\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "let ?E = \"\\<lambda>s'. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>) \\<partial>T s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "have *: \"(\\<Sum>s'\\<in>S. \\<tau> s s' * ?E s') = (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s' * enn2real (?E s')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       ennreal (\\<tau> s s') *\n       \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                          \\<partial>T s') =\n    (\\<Sum>s'\\<in>S.\n       ennreal\n        (\\<tau> s s' *\n         enn2real\n          (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                              \\<partial>T s')))", "proof (rule sum.cong)"], ["proof (state)\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       ennreal (\\<tau> s x) *\n       \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (x ## \\<omega>)\n                          \\<partial>T x =\n       ennreal\n        (\\<tau> s x *\n         enn2real\n          (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (x ## \\<omega>)\n                              \\<partial>T x))", "fix s'"], ["proof (state)\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       ennreal (\\<tau> s x) *\n       \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (x ## \\<omega>)\n                          \\<partial>T x =\n       ennreal\n        (\\<tau> s x *\n         enn2real\n          (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (x ## \\<omega>)\n                              \\<partial>T x))", "assume \"s' \\<in> S\""], ["proof (state)\nthis:\n  s' \\<in> S\n\ngoal (2 subgoals):\n 1. S = S\n 2. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       ennreal (\\<tau> s x) *\n       \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (x ## \\<omega>)\n                          \\<partial>T x =\n       ennreal\n        (\\<tau> s x *\n         enn2real\n          (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (x ## \\<omega>)\n                              \\<partial>T x))", "show \"\\<tau> s s' * ?E s' = ennreal (\\<tau> s s' * enn2real (?E s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "assume \"\\<tau> s s' \\<noteq> 0\""], ["proof (state)\nthis:\n  \\<tau> s s' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "with \\<open>s \\<in> S\\<close> \\<open>s' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s' \\<in> S\n  \\<tau> s s' \\<noteq> 0", "have \"s' \\<in> E s\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s' \\<in> S\n  \\<tau> s s' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s' \\<in> E s", "by (simp add: set_pmf_iff)"], ["proof (state)\nthis:\n  s' \\<in> E s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "from \\<open>s \\<notin> ?F\\<close> AE_until"], ["proof (chain)\npicking this:\n  s \\<notin> svalid F\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "have \"AE \\<omega> in T s. (HLD S suntil HLD ?F) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<notin> svalid F\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "using svalid_subset_S \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<notin> svalid F\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n  svalid ?F \\<subseteq> S\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "by simp"], ["proof (state)\nthis:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "with nn_integral_reward_finite[OF \\<open>s' \\<in> S\\<close>, of F] \\<open>s \\<in> S\\<close> \\<open>s' \\<in> E s\\<close> \\<open>s \\<notin> ?F\\<close>"], ["proof (chain)\npicking this:\n  AE \\<omega> in T s'. (HLD S suntil HLD (svalid F))\n                        (s' ## \\<omega>) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' \\<noteq>\n  \\<infinity>\n  s \\<in> S\n  s' \\<in> E s\n  s \\<notin> svalid F\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "have \"?E s' \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  AE \\<omega> in T s'. (HLD S suntil HLD (svalid F))\n                        (s' ## \\<omega>) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' \\<noteq>\n  \\<infinity>\n  s \\<in> S\n  s' \\<in> E s\n  s \\<notin> svalid F\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' \\<noteq>\n    \\<infinity>", "by (simp add: AE_T_iff[of _ s] AE_measure_pmf_iff suntil_Stream\n                 del: reward.simps)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' \\<noteq>\n  \\<infinity>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))\n 2. \\<not> ?P \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "then"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' \\<noteq>\n  \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "by (cases \"?E s'\") (auto simp: ennreal_mult)"], ["proof (state)\nthis:\n  ennreal (\\<tau> s s') *\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' =\n  ennreal\n   (\\<tau> s s' *\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                         \\<partial>T s'))\n\ngoal (1 subgoal):\n 1. \\<not> \\<tau> s s' \\<noteq> 0 \\<Longrightarrow>\n    ennreal (\\<tau> s s') *\n    \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                       \\<partial>T s' =\n    ennreal\n     (\\<tau> s s' *\n      enn2real\n       (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                           \\<partial>T s'))", "qed simp"], ["proof (state)\nthis:\n  ennreal (\\<tau> s s') *\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                     \\<partial>T s' =\n  ennreal\n   (\\<tau> s s' *\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                         \\<partial>T s'))\n\ngoal (1 subgoal):\n 1. S = S", "qed simp"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     ennreal (\\<tau> s s') *\n     \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                        \\<partial>T s') =\n  (\\<Sum>s'\\<in>S.\n     ennreal\n      (\\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s')))\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "have \"AE \\<omega> in T s. ?R (s ## \\<omega>) = \\<rho> s + \\<iota> s (shd \\<omega>) + ?R \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. reward (Future F) (s ## \\<omega>) =\n                        ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                        reward (Future F) \\<omega>", "using \\<open>s \\<notin> svalid F\\<close>"], ["proof (prove)\nusing this:\n  s \\<notin> svalid F\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. reward (Future F) (s ## \\<omega>) =\n                        ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                        reward (Future F) \\<omega>", "by (auto simp: ev_Stream )"], ["proof (state)\nthis:\n  AE \\<omega> in T s. reward (Future F) (s ## \\<omega>) =\n                      ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                      reward (Future F) \\<omega>\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in T s. reward (Future F) (s ## \\<omega>) =\n                      ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                      reward (Future F) \\<omega>", "have \"(\\<integral>\\<^sup>+\\<omega>. ?R (s ## \\<omega>) \\<partial>T s) = (\\<integral>\\<^sup>+\\<omega>. (\\<rho> s + \\<iota> s (shd \\<omega>)) + ?R \\<omega> \\<partial>T s)\""], ["proof (prove)\nusing this:\n  AE \\<omega> in T s. reward (Future F) (s ## \\<omega>) =\n                      ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                      reward (Future F) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                         reward (Future F) \\<omega>\n                       \\<partial>T s", "by (rule nn_integral_cong_AE)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                       reward (Future F) \\<omega>\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                       reward (Future F) \\<omega>\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "have \"\\<dots> = (\\<integral>\\<^sup>+\\<omega>. \\<rho> s + \\<iota> s (shd \\<omega>) \\<partial>T s) +\n    (\\<integral>\\<^sup>+\\<omega>. ?R \\<omega> \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                         reward (Future F) \\<omega>\n                       \\<partial>T s =\n    \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                       \\<partial>T s +\n    integral\\<^sup>N (T s) (reward (Future F))", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                         reward (Future F) \\<omega>\n                       \\<partial>T s =\n    \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                       \\<partial>T s +\n    integral\\<^sup>N (T s) (reward (Future F))", "by (subst nn_integral_add)\n       (auto simp add: space_PiM PiE_iff simp del: reward.simps)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                       reward (Future F) \\<omega>\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                     \\<partial>T s +\n  integral\\<^sup>N (T s) (reward (Future F))\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (shd \\<omega>)) +\n                       reward (Future F) \\<omega>\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                     \\<partial>T s +\n  integral\\<^sup>N (T s) (reward (Future F))\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "have \"\\<dots> = ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) + (\\<integral>\\<^sup>+\\<omega>. ?R \\<omega> \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                       \\<partial>T s +\n    integral\\<^sup>N (T s) (reward (Future F)) =\n    ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n    integral\\<^sup>N (T s) (reward (Future F))", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                       \\<partial>T s +\n    integral\\<^sup>N (T s) (reward (Future F)) =\n    ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n    integral\\<^sup>N (T s) (reward (Future F))", "by (subst nn_integral_eq_sum)\n       (auto simp: field_simps sum.distrib sum_distrib_left[symmetric] ennreal_mult[symmetric] sum_nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (shd x))\n                     \\<partial>T s +\n  integral\\<^sup>N (T s) (reward (Future F)) =\n  ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n  integral\\<^sup>N (T s) (reward (Future F))\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n  integral\\<^sup>N (T s) (reward (Future F))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n  integral\\<^sup>N (T s) (reward (Future F))\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "apply (simp del: reward.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n    integral\\<^sup>N (T s) (reward (Future F)) \\<Longrightarrow>\n    enn2real\n     (ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n      integral\\<^sup>N (T s) (reward (Future F))) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "apply (subst nn_integral_eq_sum[OF \\<open>s \\<in> S\\<close> reward_measurable])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n    integral\\<^sup>N (T s) (reward (Future F)) \\<Longrightarrow>\n    enn2real\n     (ennreal (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) +\n      (\\<Sum>t\\<in>S.\n         ennreal (\\<tau> s t) *\n         \\<integral>\\<^sup>+ x. reward (Future F) (t ## x) \\<partial>T t)) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "apply (simp del: reward.simps ennreal_plus add: * ennreal_plus[symmetric] sum_nonneg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s) -\n  (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                          \\<partial>T s'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma uniqueness_of_ExpFuture:\n  fixes F\n  assumes N_def: \"N \\<equiv> Prob0 S (svalid F)\" (is \"_ \\<equiv> Prob0 S ?F\")\n  assumes Y_def: \"Y \\<equiv> Prob1 N S (svalid F)\"\n  assumes const_def: \"const \\<equiv> \\<lambda>s. if s \\<in> Y \\<and> s \\<notin> svalid F then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0\"\n  assumes sol: \"\\<And>s. s\\<in>S \\<Longrightarrow> (\\<Sum>s'\\<in>S. LES (S - Y \\<union> ?F) s s' * l s') = const s\"\n  shows \"\\<forall>s\\<in>S. l s = enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s)\"\n    (is \"\\<forall>s\\<in>S. l s = enn2real (\\<integral>\\<^sup>+\\<omega>. ?R (s ## \\<omega>) \\<partial>T s)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "proof (rule unique)"], ["proof (state)\ngoal (8 subgoals):\n 1. ?\\<Phi> \\<subseteq> S\n 2. ?\\<Psi> \\<subseteq> S\n 3. ?N \\<subseteq> S\n 4. Prob0 ?\\<Phi> ?\\<Psi> \\<subseteq> ?N\n 5. ?\\<Psi> \\<subseteq> ?N\n 6. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> ?N\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 7. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> ?N\\<rbrakk>\n       \\<Longrightarrow> enn2real\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (s ## \\<omega>)\n        \\<partial>T s) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            enn2real\n                             (\\<integral>\\<^sup>+ \\<omega>.\n             reward (Future F) (s' ## \\<omega>)\n           \\<partial>T s'))\n 8. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "show \"S \\<subseteq> S\" \"?F \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> S &&& svalid F \\<subseteq> S", "using svalid_subset_S"], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. S \\<subseteq> S &&& svalid F \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  S \\<subseteq> S\n  svalid F \\<subseteq> S\n\ngoal (6 subgoals):\n 1. ?N \\<subseteq> S\n 2. Prob0 S (svalid F) \\<subseteq> ?N\n 3. svalid F \\<subseteq> ?N\n 4. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> ?N\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 5. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> ?N\\<rbrakk>\n       \\<Longrightarrow> enn2real\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (s ## \\<omega>)\n        \\<partial>T s) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            enn2real\n                             (\\<integral>\\<^sup>+ \\<omega>.\n             reward (Future F) (s' ## \\<omega>)\n           \\<partial>T s'))\n 6. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "show \"S - (Y - ?F) \\<subseteq> S\" \"Prob0 S ?F \\<subseteq> S - (Y - ?F)\" \"?F \\<subseteq> S - (Y - ?F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S - (Y - svalid F) \\<subseteq> S &&&\n    Prob0 S (svalid F) \\<subseteq> S - (Y - svalid F) &&&\n    svalid F \\<subseteq> S - (Y - svalid F)", "using svalid_subset_S"], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. S - (Y - svalid F) \\<subseteq> S &&&\n    Prob0 S (svalid F) \\<subseteq> S - (Y - svalid F) &&&\n    svalid F \\<subseteq> S - (Y - svalid F)", "by (auto simp add: Y_def N_def Prob1_iff)\n       (auto simp add: Prob0_iff dest!: T.AE_contr)"], ["proof (state)\nthis:\n  S - (Y - svalid F) \\<subseteq> S\n  Prob0 S (svalid F) \\<subseteq> S - (Y - svalid F)\n  svalid F \\<subseteq> S - (Y - svalid F)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> enn2real\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (s ## \\<omega>)\n        \\<partial>T s) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            enn2real\n                             (\\<integral>\\<^sup>+ \\<omega>.\n             reward (Future F) (s' ## \\<omega>)\n           \\<partial>T s'))\n 3. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> enn2real\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (s ## \\<omega>)\n        \\<partial>T s) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            enn2real\n                             (\\<integral>\\<^sup>+ \\<omega>.\n             reward (Future F) (s' ## \\<omega>)\n           \\<partial>T s'))\n 3. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> enn2real\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (s ## \\<omega>)\n        \\<partial>T s) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            enn2real\n                             (\\<integral>\\<^sup>+ \\<omega>.\n             reward (Future F) (s' ## \\<omega>)\n           \\<partial>T s'))\n 3. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "assume \"s \\<in> S\" \"s \\<notin> S - (Y - ?F)\""], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s - ?c s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> enn2real\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (s ## \\<omega>)\n        \\<partial>T s) -\n                         ?c s =\n                         (\\<Sum>s'\\<in>S.\n                            \\<tau> s s' *\n                            enn2real\n                             (\\<integral>\\<^sup>+ \\<omega>.\n             reward (Future F) (s' ## \\<omega>)\n           \\<partial>T s'))\n 3. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)", "show \"enn2real (\\<integral>\\<^sup>+\\<omega>. ?R (s ## \\<omega>) \\<partial>T s) - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * enn2real (\\<integral>\\<^sup>+\\<omega>. ?R (s' ## \\<omega>) \\<partial>T s'))\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)\n\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s) -\n    (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                            \\<partial>T s'))", "by (rule existence_of_ExpFuture[OF N_def Y_def])"], ["proof (state)\nthis:\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s) -\n  (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s' ## \\<omega>)\n                          \\<partial>T s'))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "assume \"s \\<in> S\" \"s \\<notin> S - (Y - ?F)\""], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)", "have \"s \\<in> Y\" \"s \\<notin> ?F\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<notin> S - (Y - svalid F)\n\ngoal (1 subgoal):\n 1. s \\<in> Y &&& s \\<notin> svalid F", "by auto"], ["proof (state)\nthis:\n  s \\<in> Y\n  s \\<notin> svalid F\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "have \"(\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')", "by (auto intro!: sum.cong simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "also"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s')\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "have \"\\<dots> = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s') =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s", "by (simp add: sum_subtractf single_l)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s' - (if s' = s then 1 else 0) * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s", "have \"l s = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - (\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s')\""], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s') =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') - l s\n\ngoal (1 subgoal):\n 1. l s =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') -\n    (\\<Sum>s'\\<in>S.\n       (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s')", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  l s =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') -\n  (\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s')\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> S - (Y - svalid F)\\<rbrakk>\n       \\<Longrightarrow> l s -\n                         (\\<rho> s +\n                          (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n                         (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n 2. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "then"], ["proof (chain)\npicking this:\n  l s =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') -\n  (\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s')", "show \"l s - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) = (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\""], ["proof (prove)\nusing this:\n  l s =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') -\n  (\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s')\n\ngoal (1 subgoal):\n 1. l s - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')", "using sol[OF \\<open>s \\<in> S\\<close>] \\<open>s \\<in> Y\\<close> \\<open>s \\<notin> ?F\\<close>"], ["proof (prove)\nusing this:\n  l s =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s') -\n  (\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * l s')\n  (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s\n  s \\<in> Y\n  s \\<notin> svalid F\n\ngoal (1 subgoal):\n 1. l s - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n    (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')", "by (simp add: const_def LES_def)"], ["proof (state)\nthis:\n  l s - (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n  (\\<Sum>s'\\<in>S. \\<tau> s s' * l s')\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "assume s: \"s \\<in> S - (Y - ?F)\""], ["proof (state)\nthis:\n  s \\<in> S - (Y - svalid F)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "with sol[of s]"], ["proof (chain)\npicking this:\n  s \\<in> S \\<Longrightarrow>\n  (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s\n  s \\<in> S - (Y - svalid F)", "have \"l s = 0\""], ["proof (prove)\nusing this:\n  s \\<in> S \\<Longrightarrow>\n  (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s\n  s \\<in> S - (Y - svalid F)\n\ngoal (1 subgoal):\n 1. l s = 0", "by (cases \"s \\<in> ?F\") (simp_all add: const_def LES_def single_l)"], ["proof (state)\nthis:\n  l s = 0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "also"], ["proof (state)\nthis:\n  l s = 0\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "have \"0 = enn2real (\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)\n 2. \\<not> ?P \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "assume \"s \\<in> ?F\""], ["proof (state)\nthis:\n  s \\<in> svalid F\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)\n 2. \\<not> ?P \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "then"], ["proof (chain)\npicking this:\n  s \\<in> svalid F", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> svalid F\n\ngoal (1 subgoal):\n 1. 0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "by (simp add: HLD_iff ev_Stream)"], ["proof (state)\nthis:\n  0 =\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal (1 subgoal):\n 1. s \\<notin> svalid F \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> svalid F \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "assume \"s \\<notin> ?F\""], ["proof (state)\nthis:\n  s \\<notin> svalid F\n\ngoal (1 subgoal):\n 1. s \\<notin> svalid F \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "with s"], ["proof (chain)\npicking this:\n  s \\<in> S - (Y - svalid F)\n  s \\<notin> svalid F", "have \"s \\<in> S - Y\""], ["proof (prove)\nusing this:\n  s \\<in> S - (Y - svalid F)\n  s \\<notin> svalid F\n\ngoal (1 subgoal):\n 1. s \\<in> S - Y", "by auto"], ["proof (state)\nthis:\n  s \\<in> S - Y\n\ngoal (1 subgoal):\n 1. s \\<notin> svalid F \\<Longrightarrow>\n    0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "with infinite_reward[of s F]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s \\<in> S;\n   s \\<notin> Prob1 (Prob0 S (svalid F)) S (svalid F)\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (s ## \\<omega>)\n \\<partial>T s =\n                    \\<infinity>\n  s \\<in> S - Y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S;\n   s \\<notin> Prob1 (Prob0 S (svalid F)) S (svalid F)\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (s ## \\<omega>)\n \\<partial>T s =\n                    \\<infinity>\n  s \\<in> S - Y\n\ngoal (1 subgoal):\n 1. 0 =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "by (simp add: Y_def N_def del: reward.simps)"], ["proof (state)\nthis:\n  0 =\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 =\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S - (Y - svalid F) \\<Longrightarrow>\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "finally"], ["proof (chain)\npicking this:\n  l s =\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s)", "show \"l s = enn2real (\\<integral>\\<^sup>+\\<omega>. ?R (s ## \\<omega>) \\<partial>T s)\""], ["proof (prove)\nusing this:\n  l s =\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal (1 subgoal):\n 1. l s =\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                         \\<partial>T s)", "."], ["proof (state)\nthis:\n  l s =\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Soundness of @{const Sat}\\<close>"], ["", "theorem Sat_sound:\n  \"Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)", "proof (induct F rule: Sat.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "case (5 rel r F)"], ["proof (state)\nthis:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Prob rel r (X F)) \\<noteq> None\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "{"], ["proof (state)\nthis:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Prob rel r (X F)) \\<noteq> None\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "fix q"], ["proof (state)\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "assume \"q \\<in> S\""], ["proof (state)\nthis:\n  q \\<in> S\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "with svalid_subset_S"], ["proof (chain)\npicking this:\n  svalid ?F \\<subseteq> S\n  q \\<in> S", "have \"sum (\\<tau> q) (svalid F) = \\<P>(\\<omega> in T q. HLD (svalid F) \\<omega>)\""], ["proof (prove)\nusing this:\n  svalid ?F \\<subseteq> S\n  q \\<in> S\n\ngoal (1 subgoal):\n 1. sum (\\<tau> q) (svalid F) = prob q (HLD (svalid F))", "by (subst prob_sum[OF \\<open>q\\<in>S\\<close>]) (auto intro!: sum.mono_neutral_cong_left)"], ["proof (state)\nthis:\n  sum (\\<tau> q) (svalid F) = prob q (HLD (svalid F))\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "}"], ["proof (state)\nthis:\n  ?q3 \\<in> S \\<Longrightarrow>\n  sum (\\<tau> ?q3) (svalid F) = prob ?q3 (HLD (svalid F))\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Prob rel r (X F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (X F)) =\n                         Some (svalid (Prob rel r (X F)))\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 9. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 10. \\<And>rel r F.\n        \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                 Sat F = Some (svalid F);\n         Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n        \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                          Some (svalid (Exp rel r (Future F)))", "with 5"], ["proof (chain)\npicking this:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Prob rel r (X F)) \\<noteq> None\n  ?q3 \\<in> S \\<Longrightarrow>\n  sum (\\<tau> ?q3) (svalid F) = prob ?q3 (HLD (svalid F))", "show ?case"], ["proof (prove)\nusing this:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Prob rel r (X F)) \\<noteq> None\n  ?q3 \\<in> S \\<Longrightarrow>\n  sum (\\<tau> ?q3) (svalid F) = prob ?q3 (HLD (svalid F))\n\ngoal (1 subgoal):\n 1. Sat (Prob rel r (X F)) = Some (svalid (Prob rel r (X F)))", "by (auto split: bind_split_asm)"], ["proof (state)\nthis:\n  Sat (Prob rel r (X F)) = Some (svalid (Prob rel r (X F)))\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 6. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 9. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 6. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 9. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "case (6 rel r k F1 F2)"], ["proof (state)\nthis:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U k F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) =\n                         Some (svalid (Prob rel r (U k F1 F2)))\n 6. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 8. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 9. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U k F1 F2)) \\<noteq> None", "show ?case"], ["proof (prove)\nusing this:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n\ngoal (1 subgoal):\n 1. Sat (Prob rel r (U k F1 F2)) = Some (svalid (Prob rel r (U k F1 F2)))", "by (simp add: ProbU cong: conj_cong split: bind_split_asm)"], ["proof (state)\nthis:\n  Sat (Prob rel r (U k F1 F2)) = Some (svalid (Prob rel r (U k F1 F2)))\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "case (7 rel r F1 F2)"], ["proof (state)\nthis:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "moreover"], ["proof (state)\nthis:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "define constants :: \"'s \\<Rightarrow> real\" where \"constants = (\\<lambda>s. if s \\<in> (svalid F2) then 1 else 0)\""], ["proof (state)\nthis:\n  constants = (\\<lambda>s. if s \\<in> svalid F2 then 1 else 0)\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "moreover"], ["proof (state)\nthis:\n  constants = (\\<lambda>s. if s \\<in> svalid F2 then 1 else 0)\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "define distr where \"distr = LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2)\""], ["proof (state)\nthis:\n  distr = LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2)\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "ultimately"], ["proof (chain)\npicking this:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\n  constants = (\\<lambda>s. if s \\<in> svalid F2 then 1 else 0)\n  distr = LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2)", "obtain l where eq: \"Sat F1 = Some (svalid F1)\" \"Sat F2 = Some (svalid F2)\"\n    and l: \"gauss_jordan' distr constants = Some l\""], ["proof (prove)\nusing this:\n  Sat F1 \\<noteq> None \\<Longrightarrow> Sat F1 = Some (svalid F1)\n  \\<lbrakk>Sat F1 = Some ?a1; Sat F2 \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> Sat F2 = Some (svalid F2)\n  Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\n  constants = (\\<lambda>s. if s \\<in> svalid F2 then 1 else 0)\n  distr = LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>Sat F1 = Some (svalid F1); Sat F2 = Some (svalid F2);\n         gauss_jordan' distr constants = Some l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by atomize_elim (simp add: ProbUinfty_def split: bind_split_asm)"], ["proof (state)\nthis:\n  Sat F1 = Some (svalid F1)\n  Sat F2 = Some (svalid F2)\n  gauss_jordan' distr constants = Some l\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "from l"], ["proof (chain)\npicking this:\n  gauss_jordan' distr constants = Some l", "have P: \"ProbUinfty (svalid F1) (svalid F2) = Some l\""], ["proof (prove)\nusing this:\n  gauss_jordan' distr constants = Some l\n\ngoal (1 subgoal):\n 1. ProbUinfty (svalid F1) (svalid F2) = Some l", "unfolding ProbUinfty_def constants_def distr_def"], ["proof (prove)\nusing this:\n  gauss_jordan' (LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2))\n   (\\<lambda>s. if s \\<in> svalid F2 then 1 else 0) =\n  Some l\n\ngoal (1 subgoal):\n 1. gauss_jordan' (LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2))\n     (\\<lambda>i. if i \\<in> svalid F2 then 1 else 0) =\n    Some l", "by simp"], ["proof (state)\nthis:\n  ProbUinfty (svalid F1) (svalid F2) = Some l\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "have \"\\<forall>s\\<in>S. l s = \\<P>(\\<omega> in T s. pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       l s =\n       prob s\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "proof (rule uniqueness_of_ProbU)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' *\n          l s') =\n       (if s \\<in> svalid F2 then 1 else 0)", "show \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' * l s') =\n                   (if s \\<in> svalid F2 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' *\n          l s') =\n       (if s \\<in> svalid F2 then 1 else 0)", "using gauss_jordan'_correct[OF l]"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. distr s s' * l s') = constants s\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' *\n          l s') =\n       (if s \\<in> svalid F2 then 1 else 0)", "unfolding distr_def constants_def"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S.\n     (\\<Sum>s'\\<in>S.\n        LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' *\n        l s') =\n     (if s \\<in> svalid F2 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' *\n          l s') =\n       (if s \\<in> svalid F2 then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S.\n     (\\<Sum>s'\\<in>S.\n        LES (Prob0 (svalid F1) (svalid F2) \\<union> svalid F2) s s' *\n        l s') =\n     (if s \\<in> svalid F2 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S.\n     l s =\n     prob s\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n                         Some\n                          (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 7. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 8. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>S.\n     l s =\n     prob s\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S.\n     l s =\n     prob s\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> F1 F2) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n    Some (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))", "by (auto simp add: eq P)"], ["proof (state)\nthis:\n  Sat (Prob rel r (U\\<^sup>\\<infinity> F1 F2)) =\n  Some (svalid (Prob rel r (U\\<^sup>\\<infinity> F1 F2)))\n\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "case (8 rel r k)"], ["proof (state)\nthis:\n  Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "{"], ["proof (state)\nthis:\n  Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "fix s"], ["proof (state)\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"ExpCumm s k = (\\<integral>\\<^sup>+ x. ennreal (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i)) \\<partial>T s)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. ExpCumm s k =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> ((s ## x) !! i) +\n                                \\<iota> ((s ## x) !! i) (x !! i))\n                       \\<partial>T s", "proof (induct k arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       ExpCumm s 0 =\n       \\<integral>\\<^sup>+ x. ennreal\n                               (\\<Sum>i<0.\n                                   \\<rho> ((s ## x) !! i) +\n                                   \\<iota> ((s ## x) !! i) (x !! i))\n                          \\<partial>T s\n 2. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "case 0"], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       ExpCumm s 0 =\n       \\<integral>\\<^sup>+ x. ennreal\n                               (\\<Sum>i<0.\n                                   \\<rho> ((s ## x) !! i) +\n                                   \\<iota> ((s ## x) !! i) (x !! i))\n                          \\<partial>T s\n 2. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. ExpCumm s 0 =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<0.\n                                \\<rho> ((s ## x) !! i) +\n                                \\<iota> ((s ## x) !! i) (x !! i))\n                       \\<partial>T s", "by simp"], ["proof (state)\nthis:\n  ExpCumm s 0 =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<0.\n                              \\<rho> ((s ## x) !! i) +\n                              \\<iota> ((s ## x) !! i) (x !! i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "case (Suc k)"], ["proof (state)\nthis:\n  ?s1 \\<in> S \\<Longrightarrow>\n  ExpCumm ?s1 k =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> ((?s1 ## x) !! i) +\n                              \\<iota> ((?s1 ## x) !! i) (x !! i))\n                     \\<partial>T ?s1\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "have \"(\\<integral>\\<^sup>+\\<omega>. ennreal (\\<Sum>i<Suc k. \\<rho> ((s ## \\<omega>) !! i) + \\<iota> ((s ## \\<omega>) !! i) (\\<omega> !! i)) \\<partial>T s)\n        = (\\<integral>\\<^sup>+\\<omega>. ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) + ennreal (\\<Sum>i<k. \\<rho> (\\<omega> !! i) + \\<iota> (\\<omega> !! i) (\\<omega> !! (Suc i))) \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal\n                          (\\<Sum>i<Suc k.\n                              \\<rho> ((s ## \\<omega>) !! i) +\n                              \\<iota> ((s ## \\<omega>) !! i)\n                               (\\<omega> !! i))\n                       \\<partial>T s =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                         ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (\\<omega> !! i) +\n                              \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                       \\<partial>T s", "by (auto intro!: nn_integral_cong\n                 simp del: ennreal_plus\n                 simp: ennreal_plus[symmetric] sum_nonneg sum.reindex lessThan_Suc_eq_insert_0 zero_notin_Suc_image)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal\n                        (\\<Sum>i<Suc k.\n                            \\<rho> ((s ## \\<omega>) !! i) +\n                            \\<iota> ((s ## \\<omega>) !! i) (\\<omega> !! i))\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                       ennreal\n                        (\\<Sum>i<k.\n                            \\<rho> (\\<omega> !! i) +\n                            \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal\n                        (\\<Sum>i<Suc k.\n                            \\<rho> ((s ## \\<omega>) !! i) +\n                            \\<iota> ((s ## \\<omega>) !! i) (\\<omega> !! i))\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                       ennreal\n                        (\\<Sum>i<k.\n                            \\<rho> (\\<omega> !! i) +\n                            \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "have \"\\<dots> = (\\<integral>\\<^sup>+\\<omega>. \\<rho> s + \\<iota> s (\\<omega> !! 0) \\<partial>T s) +\n          (\\<integral>\\<^sup>+\\<omega>. (\\<Sum>i<k. \\<rho> (\\<omega> !! i) + \\<iota> (\\<omega> !! i) (\\<omega> !! (Suc i))) \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                         ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (\\<omega> !! i) +\n                              \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                       \\<partial>T s =\n    \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                       \\<partial>T s +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                         ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (\\<omega> !! i) +\n                              \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                       \\<partial>T s =\n    \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                       \\<partial>T s +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s", "by (intro nn_integral_add AE_I2) (auto simp: sum_nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                       ennreal\n                        (\\<Sum>i<k.\n                            \\<rho> (\\<omega> !! i) +\n                            \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                     \\<partial>T s +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal (\\<rho> s + \\<iota> s (\\<omega> !! 0)) +\n                       ennreal\n                        (\\<Sum>i<k.\n                            \\<rho> (\\<omega> !! i) +\n                            \\<iota> (\\<omega> !! i) (\\<omega> !! Suc i))\n                     \\<partial>T s =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                     \\<partial>T s +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "have \"\\<dots> = (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n        (\\<integral>\\<^sup>+\\<omega>. (\\<Sum>i<k. \\<rho> (\\<omega> !! i) + \\<iota> (\\<omega> !! i) (\\<omega> !! (Suc i))) \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                       \\<partial>T s +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s =\n    ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                       \\<partial>T s +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s =\n    ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s", "by (subst nn_integral_eq_sum)\n          (auto simp del: ennreal_plus simp: ennreal_plus[symmetric] ennreal_mult[symmetric] sum_nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                     \\<partial>T s +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s =\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> s + \\<iota> s (x !! 0))\n                     \\<partial>T s +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s =\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "have \"\\<dots> = (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n        (\\<Sum>s'\\<in>S. \\<tau> s s' * ExpCumm s' k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s =\n    ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k)", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<k.\n                                \\<rho> (x !! i) +\n                                \\<iota> (x !! i) (x !! Suc i))\n                       \\<partial>T s =\n    ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k)", "by (subst nn_integral_eq_sum) (auto simp: Suc)"], ["proof (state)\nthis:\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s =\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k)\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "also"], ["proof (state)\nthis:\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> (x !! i) +\n                              \\<iota> (x !! i) (x !! Suc i))\n                     \\<partial>T s =\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k)\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "have \"\\<dots> = ExpCumm s (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k) =\n    ExpCumm s (Suc k)", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n    (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k) =\n    ExpCumm s (Suc k)", "by (simp add: field_simps sum.distrib sum_distrib_left[symmetric] ennreal_mult[symmetric]\n            ennreal_plus[symmetric] sum_nonneg del: ennreal_plus)"], ["proof (state)\nthis:\n  ennreal (\\<Sum>s'\\<in>S. \\<tau> s s' * (\\<rho> s + \\<iota> s s')) +\n  (\\<Sum>s'\\<in>S. ennreal (\\<tau> s s') * ExpCumm s' k) =\n  ExpCumm s (Suc k)\n\ngoal (1 subgoal):\n 1. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpCumm s k =\n                   \\<integral>\\<^sup>+ x.\n  ennreal\n   (\\<Sum>i<k. \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpCumm s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal\n         (\\<Sum>i<Suc k.\n             \\<rho> ((s ## x) !! i) + \\<iota> ((s ## x) !! i) (x !! i))\n      \\<partial>T s", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal\n                        (\\<Sum>i<Suc k.\n                            \\<rho> ((s ## \\<omega>) !! i) +\n                            \\<iota> ((s ## \\<omega>) !! i) (\\<omega> !! i))\n                     \\<partial>T s =\n  ExpCumm s (Suc k)", "show ?case"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       ennreal\n                        (\\<Sum>i<Suc k.\n                            \\<rho> ((s ## \\<omega>) !! i) +\n                            \\<iota> ((s ## \\<omega>) !! i) (\\<omega> !! i))\n                     \\<partial>T s =\n  ExpCumm s (Suc k)\n\ngoal (1 subgoal):\n 1. ExpCumm s (Suc k) =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (\\<Sum>i<Suc k.\n                                \\<rho> ((s ## x) !! i) +\n                                \\<iota> ((s ## x) !! i) (x !! i))\n                       \\<partial>T s", "by simp"], ["proof (state)\nthis:\n  ExpCumm s (Suc k) =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<Suc k.\n                              \\<rho> ((s ## x) !! i) +\n                              \\<iota> ((s ## x) !! i) (x !! i))\n                     \\<partial>T s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ExpCumm s k =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> ((s ## x) !! i) +\n                              \\<iota> ((s ## x) !! i) (x !! i))\n                     \\<partial>T s\n\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "}"], ["proof (state)\nthis:\n  ?s3 \\<in> S \\<Longrightarrow>\n  ExpCumm ?s3 k =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> ((?s3 ## x) !! i) +\n                              \\<iota> ((?s3 ## x) !! i) (x !! i))\n                     \\<partial>T ?s3\n\ngoal (7 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n       Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n 6. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 7. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  ?s3 \\<in> S \\<Longrightarrow>\n  ExpCumm ?s3 k =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> ((?s3 ## x) !! i) +\n                              \\<iota> ((?s3 ## x) !! i) (x !! i))\n                     \\<partial>T ?s3", "show ?case"], ["proof (prove)\nusing this:\n  ?s3 \\<in> S \\<Longrightarrow>\n  ExpCumm ?s3 k =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (\\<Sum>i<k.\n                              \\<rho> ((?s3 ## x) !! i) +\n                              \\<iota> ((?s3 ## x) !! i) (x !! i))\n                     \\<partial>T ?s3\n\ngoal (1 subgoal):\n 1. Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n    Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))", "by auto"], ["proof (state)\nthis:\n  Sat (Exp rel r (C\\<^sup>\\<le> k)) =\n  Some (svalid (Exp rel r (C\\<^sup>\\<le> k)))\n\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "case (9 rel r k)"], ["proof (state)\nthis:\n  Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "{"], ["proof (state)\nthis:\n  Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "fix s"], ["proof (state)\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  s \\<in> S", "have \"ExpState s k = (\\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! k)) \\<partial>T s)\""], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. ExpState s k =\n    \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! k)) \\<partial>T s", "proof (induct k arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       ExpState s 0 =\n       \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! 0)) \\<partial>T s\n 2. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpState s k =\n                   \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! k))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpState s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal (\\<rho> ((s ## x) !! Suc k))\n      \\<partial>T s", "case (Suc k)"], ["proof (state)\nthis:\n  ?s1 \\<in> S \\<Longrightarrow>\n  ExpState ?s1 k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((?s1 ## x) !! k)) \\<partial>T ?s1\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       ExpState s 0 =\n       \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! 0)) \\<partial>T s\n 2. \\<And>k s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> S \\<Longrightarrow>\n                   ExpState s k =\n                   \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! k))\n\\<partial>T s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> ExpState s (Suc k) =\n                         \\<integral>\\<^sup>+ x.\n        ennreal (\\<rho> ((s ## x) !! Suc k))\n      \\<partial>T s", "then"], ["proof (chain)\npicking this:\n  ?s1 \\<in> S \\<Longrightarrow>\n  ExpState ?s1 k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((?s1 ## x) !! k)) \\<partial>T ?s1\n  s \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  ?s1 \\<in> S \\<Longrightarrow>\n  ExpState ?s1 k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((?s1 ## x) !! k)) \\<partial>T ?s1\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. ExpState s (Suc k) =\n    \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! Suc k))\n                       \\<partial>T s", "by (simp add: nn_integral_eq_sum[of s])"], ["proof (state)\nthis:\n  ExpState s (Suc k) =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! Suc k)) \\<partial>T s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       ExpState s 0 =\n       \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! 0)) \\<partial>T s", "qed simp"], ["proof (state)\nthis:\n  ExpState s k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((s ## x) !! k)) \\<partial>T s\n\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "}"], ["proof (state)\nthis:\n  ?s3 \\<in> S \\<Longrightarrow>\n  ExpState ?s3 k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((?s3 ## x) !! k)) \\<partial>T ?s3\n\ngoal (6 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r k.\n       Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (I\\<^sup>= k)) =\n       Some (svalid (Exp rel r (I\\<^sup>= k)))\n 6. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  ?s3 \\<in> S \\<Longrightarrow>\n  ExpState ?s3 k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((?s3 ## x) !! k)) \\<partial>T ?s3", "show ?case"], ["proof (prove)\nusing this:\n  ?s3 \\<in> S \\<Longrightarrow>\n  ExpState ?s3 k =\n  \\<integral>\\<^sup>+ x. ennreal (\\<rho> ((?s3 ## x) !! k)) \\<partial>T ?s3\n\ngoal (1 subgoal):\n 1. Sat (Exp rel r (I\\<^sup>= k)) = Some (svalid (Exp rel r (I\\<^sup>= k)))", "by auto"], ["proof (state)\nthis:\n  Sat (Exp rel r (I\\<^sup>= k)) = Some (svalid (Exp rel r (I\\<^sup>= k)))\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "case (10 rel r F)"], ["proof (state)\nthis:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Exp rel r (Future F)) \\<noteq> None\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "moreover"], ["proof (state)\nthis:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Exp rel r (Future F)) \\<noteq> None\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "let ?F = \"svalid F\""], ["proof (state)\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "define N where \"N \\<equiv> Prob0 S ?F\""], ["proof (state)\nthis:\n  N \\<equiv> Prob0 S (svalid F)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "moreover"], ["proof (state)\nthis:\n  N \\<equiv> Prob0 S (svalid F)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "define Y where \"Y \\<equiv> Prob1 N S ?F\""], ["proof (state)\nthis:\n  Y \\<equiv> Prob1 N S (svalid F)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "moreover"], ["proof (state)\nthis:\n  Y \\<equiv> Prob1 N S (svalid F)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "define const where \"const \\<equiv> (\\<lambda>s. if s \\<in> Y \\<and> s \\<notin> ?F then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0)\""], ["proof (state)\nthis:\n  const \\<equiv>\n  \\<lambda>s.\n     if s \\<in> Y \\<and> s \\<notin> svalid F\n     then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "ultimately"], ["proof (chain)\npicking this:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Exp rel r (Future F)) \\<noteq> None\n  N \\<equiv> Prob0 S (svalid F)\n  Y \\<equiv> Prob1 N S (svalid F)\n  const \\<equiv>\n  \\<lambda>s.\n     if s \\<in> Y \\<and> s \\<notin> svalid F\n     then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0", "obtain l\n    where l: \"gauss_jordan' (LES (S - Y \\<union> ?F)) const = Some l\"\n    and F: \"Sat F = Some ?F\""], ["proof (prove)\nusing this:\n  Sat F \\<noteq> None \\<Longrightarrow> Sat F = Some (svalid F)\n  Sat (Exp rel r (Future F)) \\<noteq> None\n  N \\<equiv> Prob0 S (svalid F)\n  Y \\<equiv> Prob1 N S (svalid F)\n  const \\<equiv>\n  \\<lambda>s.\n     if s \\<in> Y \\<and> s \\<notin> svalid F\n     then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>gauss_jordan' (LES (S - Y \\<union> svalid F)) const =\n                 Some l;\n         Sat F = Some (svalid F)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: ExpFuture_def Let_def split: bind_split_asm)"], ["proof (state)\nthis:\n  gauss_jordan' (LES (S - Y \\<union> svalid F)) const = Some l\n  Sat F = Some (svalid F)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "from l"], ["proof (chain)\npicking this:\n  gauss_jordan' (LES (S - Y \\<union> svalid F)) const = Some l", "have EF: \"ExpFuture ?F =\n    Some (\\<lambda>s. if s \\<in> Y then ennreal (l s) else \\<infinity>)\""], ["proof (prove)\nusing this:\n  gauss_jordan' (LES (S - Y \\<union> svalid F)) const = Some l\n\ngoal (1 subgoal):\n 1. ExpFuture (svalid F) =\n    Some (\\<lambda>s. if s \\<in> Y then ennreal (l s) else \\<infinity>)", "unfolding ExpFuture_def N_def Y_def const_def"], ["proof (prove)\nusing this:\n  gauss_jordan'\n   (LES (S - Prob1 (Prob0 S (svalid F)) S (svalid F) \\<union> svalid F))\n   (\\<lambda>s.\n       if s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F) \\<and>\n          s \\<notin> svalid F\n       then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')\n       else 0) =\n  Some l\n\ngoal (1 subgoal):\n 1. (let N = Prob0 S (svalid F); Y = Prob1 N S (svalid F)\n     in gauss_jordan' (LES (S - Y \\<union> svalid F))\n         (\\<lambda>i.\n             if i \\<in> Y \\<and> i \\<notin> svalid F\n             then - \\<rho> i - (\\<Sum>s'\\<in>S. \\<tau> i s' * \\<iota> i s')\n             else 0) \\<bind>\n        (\\<lambda>sol.\n            Some\n             (\\<lambda>s.\n                 if s \\<in> Y then ennreal (sol s) else \\<infinity>))) =\n    Some\n     (\\<lambda>s.\n         if s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n         then ennreal (l s) else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  ExpFuture (svalid F) =\n  Some (\\<lambda>s. if s \\<in> Y then ennreal (l s) else \\<infinity>)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "let ?R = \"reward (Future F)\""], ["proof (state)\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "have l_eq: \"\\<forall>s\\<in>S. l s = enn2real (\\<integral>\\<^sup>+\\<omega>. ?R (s ## \\<omega>) \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       l s =\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                            \\<partial>T s)", "proof (rule uniqueness_of_ExpFuture[OF N_def Y_def const_def])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s", "show \"\\<And>s. s\\<in>S \\<Longrightarrow> (\\<Sum>s'\\<in>S. LES (S - Y \\<union> ?F) s s' * l s') = const s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s", "using gauss_jordan'_correct[OF l]"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S.\n     (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) s s' * l s') = const s", "by auto"], ["proof (state)\nthis:\n  ?s1 \\<in> S \\<Longrightarrow>\n  (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid F) ?s1 s' * l s') = const ?s1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S.\n     l s =\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                          \\<partial>T s)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "{"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S.\n     l s =\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                          \\<partial>T s)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "fix s"], ["proof (state)\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "assume [simp]: \"s \\<in> S\" \"s \\<in> Y\""], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<in> Y\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<in> Y", "have \"s \\<in> Prob1 (Prob0 S ?F) S ?F\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)", "unfolding Y_def N_def"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n\ngoal (1 subgoal):\n 1. s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)", "by auto"], ["proof (state)\nthis:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "then"], ["proof (chain)\npicking this:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)", "have \"AE \\<omega> in T s. (HLD S suntil HLD ?F) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "using svalid_subset_S"], ["proof (prove)\nusing this:\n  s \\<in> Prob1 (Prob0 S (svalid F)) S (svalid F)\n  svalid ?F \\<subseteq> S\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "by (auto simp add: Prob1_iff)"], ["proof (state)\nthis:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "from nn_integral_reward_finite[OF \\<open>s \\<in> S\\<close>] this"], ["proof (chain)\npicking this:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid ?F))\n                       (s ## \\<omega>) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future ?F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)", "have \"(\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid ?F))\n                       (s ## \\<omega>) \\<Longrightarrow>\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future ?F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n  AE \\<omega> in T s. (HLD S suntil HLD (svalid F)) (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s \\<noteq>\n    \\<infinity>", "by (simp add: )"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "with l_eq \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>S.\n     l s =\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                          \\<partial>T s)\n  s \\<in> S\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>", "have \"(\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) = ennreal (l s)\""], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>S.\n     l s =\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                          \\<partial>T s)\n  s \\<in> S\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    ennreal (l s)", "by (auto simp: less_top)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  ennreal (l s)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    ennreal (l ?s3)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    ennreal (l ?s3)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    ennreal (l ?s3)\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "fix s"], ["proof (state)\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "assume \"s \\<in> S\" \"s \\<notin> Y\""], ["proof (state)\nthis:\n  s \\<in> S\n  s \\<notin> Y\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "with infinite_reward[of s F]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s \\<in> S;\n   s \\<notin> Prob1 (Prob0 S (svalid F)) S (svalid F)\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (s ## \\<omega>)\n \\<partial>T s =\n                    \\<infinity>\n  s \\<in> S\n  s \\<notin> Y", "have \"(\\<integral>\\<^sup>+\\<omega>. reward (Future F) (s ## \\<omega>) \\<partial>T s) = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S;\n   s \\<notin> Prob1 (Prob0 S (svalid F)) S (svalid F)\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (s ## \\<omega>)\n \\<partial>T s =\n                    \\<infinity>\n  s \\<in> S\n  s \\<notin> Y\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                       \\<partial>T s =\n    \\<infinity>", "by (simp add: Y_def N_def)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>. reward (Future F) (s ## \\<omega>)\n                     \\<partial>T s =\n  \\<infinity>\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<notin> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    \\<infinity>\n\ngoal (5 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))\n 5. \\<And>rel r F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Exp rel r (Future F)) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Exp rel r (Future F)) =\n                         Some (svalid (Exp rel r (Future F)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    ennreal (l ?s3)\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<notin> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    \\<infinity>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<in> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    ennreal (l ?s3)\n  \\<lbrakk>?s3 \\<in> S; ?s3 \\<notin> Y\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future F) (?s3 ## \\<omega>)\n \\<partial>T ?s3 =\n                    \\<infinity>\n\ngoal (1 subgoal):\n 1. Sat (Exp rel r (Future F)) = Some (svalid (Exp rel r (Future F)))", "apply (auto simp add: EF F simp del: reward.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> S; s \\<in> Y\\<rbrakk>\n                   \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n                    reward (Future F) (s ## \\<omega>)\n                  \\<partial>T s =\n                                     ennreal (l s);\n        \\<And>s.\n           \\<lbrakk>s \\<in> S; s \\<notin> Y\\<rbrakk>\n           \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n            reward (Future F) (s ## \\<omega>)\n          \\<partial>T s =\n                             \\<top>;\n        inrealrel rel (ennreal r) (ennreal (l x)); x \\<in> S;\n        inrealrel rel (ennreal r) \\<top>\\<rbrakk>\n       \\<Longrightarrow> inrealrel rel (ennreal r)\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (x ## \\<omega>)\n        \\<partial>T x)", "apply (case_tac \"x \\<in> Y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> S; s \\<in> Y\\<rbrakk>\n                   \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n                    reward (Future F) (s ## \\<omega>)\n                  \\<partial>T s =\n                                     ennreal (l s);\n        \\<And>s.\n           \\<lbrakk>s \\<in> S; s \\<notin> Y\\<rbrakk>\n           \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n            reward (Future F) (s ## \\<omega>)\n          \\<partial>T s =\n                             \\<top>;\n        inrealrel rel (ennreal r) (ennreal (l x)); x \\<in> S;\n        inrealrel rel (ennreal r) \\<top>; x \\<in> Y\\<rbrakk>\n       \\<Longrightarrow> inrealrel rel (ennreal r)\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (x ## \\<omega>)\n        \\<partial>T x)\n 2. \\<And>x.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> S; s \\<in> Y\\<rbrakk>\n                   \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n                    reward (Future F) (s ## \\<omega>)\n                  \\<partial>T s =\n                                     ennreal (l s);\n        \\<And>s.\n           \\<lbrakk>s \\<in> S; s \\<notin> Y\\<rbrakk>\n           \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n            reward (Future F) (s ## \\<omega>)\n          \\<partial>T s =\n                             \\<top>;\n        inrealrel rel (ennreal r) (ennreal (l x)); x \\<in> S;\n        inrealrel rel (ennreal r) \\<top>; x \\<notin> Y\\<rbrakk>\n       \\<Longrightarrow> inrealrel rel (ennreal r)\n                          (\\<integral>\\<^sup>+ \\<omega>.\n          reward (Future F) (x ## \\<omega>)\n        \\<partial>T x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Sat (Exp rel r (Future F)) = Some (svalid (Exp rel r (Future F)))\n\ngoal (4 subgoals):\n 1. Sat sform.true \\<noteq> None \\<Longrightarrow>\n    Sat sform.true = Some (svalid sform.true)\n 2. \\<And>L.\n       Sat (Label L) \\<noteq> None \\<Longrightarrow>\n       Sat (Label L) = Some (svalid (Label L))\n 3. \\<And>F.\n       \\<lbrakk>Sat F \\<noteq> None \\<Longrightarrow>\n                Sat F = Some (svalid F);\n        Sat (Neg F) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Neg F) = Some (svalid (Neg F))\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None \\<Longrightarrow>\n                Sat F1 = Some (svalid F1);\n        \\<And>a.\n           \\<lbrakk>Sat F1 = Some a; Sat F2 \\<noteq> None\\<rbrakk>\n           \\<Longrightarrow> Sat F2 = Some (svalid F2);\n        Sat (And F1 F2) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) = Some (svalid (And F1 F2))", "qed (auto split: bind_split_asm)"], ["", "subsection \\<open>Completeness of @{const Sat}\\<close>"], ["", "theorem Sat_complete:\n  \"Sat F \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sat F \\<noteq> None", "proof (induct F rule: Sat.induct)"], ["proof (state)\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "case (7 r rel \\<Phi> \\<Psi>)"], ["proof (state)\nthis:\n  Sat \\<Phi> \\<noteq> None\n  Sat \\<Phi> = Some ?a1 \\<Longrightarrow> Sat \\<Psi> \\<noteq> None\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  Sat \\<Phi> \\<noteq> None\n  Sat \\<Phi> = Some ?a1 \\<Longrightarrow> Sat \\<Psi> \\<noteq> None", "have F: \"Sat \\<Phi> = Some (svalid \\<Phi>)\" \"Sat \\<Psi> = Some (svalid \\<Psi>)\""], ["proof (prove)\nusing this:\n  Sat \\<Phi> \\<noteq> None\n  Sat \\<Phi> = Some ?a1 \\<Longrightarrow> Sat \\<Psi> \\<noteq> None\n\ngoal (1 subgoal):\n 1. Sat \\<Phi> = Some (svalid \\<Phi>) &&& Sat \\<Psi> = Some (svalid \\<Psi>)", "by (auto intro!: Sat_sound)"], ["proof (state)\nthis:\n  Sat \\<Phi> = Some (svalid \\<Phi>)\n  Sat \\<Psi> = Some (svalid \\<Psi>)\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "define constants :: \"'s \\<Rightarrow> real\" where \"constants = (\\<lambda>s. if s \\<in> svalid \\<Psi> then 1 else 0)\""], ["proof (state)\nthis:\n  constants = (\\<lambda>s. if s \\<in> svalid \\<Psi> then 1 else 0)\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "define distr where \"distr = LES (Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<union> svalid \\<Psi>)\""], ["proof (state)\nthis:\n  distr = LES (Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<union> svalid \\<Psi>)\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "have \"\\<exists>l. gauss_jordan' distr constants = Some l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. gauss_jordan' distr constants = Some l", "proof (rule gauss_jordan'_complete[OF _ uniqueness_of_ProbU])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          distr s s' *\n          prob s'\n           (\\<lambda>\\<omega>.\n               pvalid (U\\<^sup>\\<infinity> ?F1.2 ?F2.3) (s' ## \\<omega>))) =\n       constants s\n 2. \\<And>l.\n       \\<forall>s\\<in>S.\n          (\\<Sum>s'\\<in>S. distr s s' * l s') =\n          constants s \\<Longrightarrow>\n       \\<forall>s\\<in>S.\n          (\\<Sum>s'\\<in>S.\n             LES (Prob0 (svalid ?F1.2) (svalid ?F2.3) \\<union> svalid ?F2.3)\n              s s' *\n             l s') =\n          (if s \\<in> svalid ?F2.3 then 1 else 0)", "show \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. distr s s' * \\<P>(\\<omega> in T s'. pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) = constants s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          distr s s' *\n          prob s'\n           (\\<lambda>\\<omega>.\n               pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                (s' ## \\<omega>))) =\n       constants s", "apply (simp add: distr_def constants_def LES_def del: pvalid.simps space_T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (s \\<in> svalid \\<Psi> \\<longrightarrow>\n        (\\<Sum>s'\\<in>S.\n           (if s' = s then 1 else 0) *\n           prob s'\n            (\\<lambda>\\<omega>.\n                pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                 (s' ## \\<omega>))) =\n        1) \\<and>\n       (s \\<notin> svalid \\<Psi> \\<longrightarrow>\n        (\\<Sum>s'\\<in>S.\n           (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n            then if s' = s then 1 else 0\n            else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n           prob s'\n            (\\<lambda>\\<omega>.\n                pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                 (s' ## \\<omega>))) =\n        0)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<in> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s' = s then 1 else 0) *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         1\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<in> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s' = s then 1 else 0) *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         1\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "assume \"s \\<in> svalid \\<Psi>\" \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> svalid \\<Psi>\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<in> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s' = s then 1 else 0) *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         1\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "then"], ["proof (chain)\npicking this:\n  s \\<in> svalid \\<Psi>\n  s \\<in> S", "show \"(\\<Sum>s'\\<in>S. (if s' = s then 1 else 0) * \\<P>(\\<omega> in T s'. pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) = 1\""], ["proof (prove)\nusing this:\n  s \\<in> svalid \\<Psi>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s' = s then 1 else 0) *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    1", "by (simp add: single_l suntil_Stream)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then 1 else 0) *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  1\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "assume s: \"s \\<notin> svalid \\<Psi>\" \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<notin> svalid \\<Psi>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "let ?x = \"\\<lambda>s'. \\<P>(\\<omega> in T s'. pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> S; s \\<notin> svalid \\<Psi>\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            (if s \\<in> Prob0 (svalid \\<Phi>)\n   (svalid \\<Psi>)\n                             then if s' = s then 1 else 0\n                             else if s' = s then \\<tau> s s' - 1\n                                  else \\<tau> s s') *\n                            prob s'\n                             (\\<lambda>\\<omega>.\n                                 pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)\n                                  (s' ## \\<omega>))) =\n                         0", "show \"(\\<Sum>s'\\<in>S. (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) then if s' = s then 1 else 0 else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * ?x s') = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "assume \"s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\""], ["proof (state)\nthis:\n  s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "with s"], ["proof (chain)\npicking this:\n  s \\<notin> svalid \\<Psi>\n  s \\<in> S\n  s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<notin> svalid \\<Psi>\n  s \\<in> S\n  s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "by (simp add: single_l Prob0_iff svalid_subset_S T.prob_eq_0_AE del: space_T)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n      then if s' = s then 1 else 0\n      else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  0\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "assume s_not_0: \"s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\""], ["proof (state)\nthis:\n  s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "with s"], ["proof (chain)\npicking this:\n  s \\<notin> svalid \\<Psi>\n  s \\<in> S\n  s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)", "have *:\"\\<And>s' \\<omega>. s' \\<in> S \\<Longrightarrow> pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## s' ## \\<omega>) = pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)\""], ["proof (prove)\nusing this:\n  s \\<notin> svalid \\<Psi>\n  s \\<in> S\n  s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<And>s' \\<omega>.\n       s' \\<in> S \\<Longrightarrow>\n       pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## s' ## \\<omega>) =\n       pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)", "by (auto simp: suntil_Stream Prob0_iff svalid_subset_S)"], ["proof (state)\nthis:\n  ?s'1 \\<in> S \\<Longrightarrow>\n  pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## ?s'1 ## ?\\<omega>1) =\n  pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (?s'1 ## ?\\<omega>1)\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "have \"(\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * ?x s') =\n          (\\<Sum>s'\\<in>S. \\<tau> s s' * ?x s' - (if s' = s then 1 else 0) * ?x s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)) -\n       (if s' = s then 1 else 0) *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)))", "by (auto intro!: sum.cong simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)) -\n     (if s' = s then 1 else 0) *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "also"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)) -\n     (if s' = s then 1 else 0) *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)))\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "have \"\\<dots> = (\\<Sum>s'\\<in>S. \\<tau> s s' * ?x s') - ?x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)) -\n       (if s' = s then 1 else 0) *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) -\n    prob s\n     (\\<lambda>\\<omega>.\n         pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## \\<omega>))", "using s"], ["proof (prove)\nusing this:\n  s \\<notin> svalid \\<Psi>\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)) -\n       (if s' = s then 1 else 0) *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) -\n    prob s\n     (\\<lambda>\\<omega>.\n         pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## \\<omega>))", "by (simp add: single_l sum_subtractf)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>)) -\n     (if s' = s then 1 else 0) *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) -\n  prob s\n   (\\<lambda>\\<omega>.\n       pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) -\n  prob s\n   (\\<lambda>\\<omega>.\n       pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## \\<omega>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) -\n  prob s\n   (\\<lambda>\\<omega>.\n       pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## \\<omega>))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "using * prob_sum[OF \\<open>s \\<in> S\\<close>] s_not_0"], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) -\n  prob s\n   (\\<lambda>\\<omega>.\n       pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## \\<omega>))\n  ?s'1 \\<in> S \\<Longrightarrow>\n  pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s ## ?s'1 ## ?\\<omega>1) =\n  pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (?s'1 ## ?\\<omega>1)\n  Measurable.pred (stream_space (count_space UNIV)) ?P \\<Longrightarrow>\n  prob s ?P =\n  (\\<Sum>t\\<in>S.\n     \\<tau> s t * prob t (\\<lambda>\\<omega>. ?P (t ## \\<omega>)))\n  s \\<notin> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n        then if s' = s then 1 else 0\n        else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       prob s'\n        (\\<lambda>\\<omega>.\n            pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n    0", "by (simp del: pvalid.simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n      then if s' = s then 1 else 0\n      else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s \\<in> Prob0 (svalid \\<Phi>) (svalid \\<Psi>)\n      then if s' = s then 1 else 0\n      else if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     prob s'\n      (\\<lambda>\\<omega>.\n          pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S.\n     (\\<Sum>s'\\<in>S.\n        distr s s' *\n        prob s'\n         (\\<lambda>\\<omega>.\n             pvalid (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>) (s' ## \\<omega>))) =\n     constants s\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<forall>s\\<in>S.\n          (\\<Sum>s'\\<in>S. distr s s' * l s') =\n          constants s \\<Longrightarrow>\n       \\<forall>s\\<in>S.\n          (\\<Sum>s'\\<in>S.\n             LES (Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<union>\n                  svalid \\<Psi>)\n              s s' *\n             l s') =\n          (if s \\<in> svalid \\<Psi> then 1 else 0)", "qed (simp add: distr_def constants_def)"], ["proof (state)\nthis:\n  \\<exists>l. gauss_jordan' distr constants = Some l\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  \\<exists>l. gauss_jordan' distr constants = Some l", "have P: \"\\<exists>l. ProbUinfty (svalid \\<Phi>) (svalid \\<Psi>) = Some l\""], ["proof (prove)\nusing this:\n  \\<exists>l. gauss_jordan' distr constants = Some l\n\ngoal (1 subgoal):\n 1. \\<exists>l. ProbUinfty (svalid \\<Phi>) (svalid \\<Psi>) = Some l", "unfolding ProbUinfty_def constants_def distr_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     gauss_jordan'\n      (LES (Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<union> svalid \\<Psi>))\n      (\\<lambda>s. if s \\<in> svalid \\<Psi> then 1 else 0) =\n     Some l\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       gauss_jordan'\n        (LES (Prob0 (svalid \\<Phi>) (svalid \\<Psi>) \\<union> svalid \\<Psi>))\n        (\\<lambda>i. if i \\<in> svalid \\<Psi> then 1 else 0) =\n       Some l", "by simp"], ["proof (state)\nthis:\n  \\<exists>l. ProbUinfty (svalid \\<Phi>) (svalid \\<Psi>) = Some l\n\ngoal (10 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r\n                               (U\\<^sup>\\<infinity> F1 F2)) \\<noteq>\n                         None\n 8. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 9. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 10. \\<And>rel r F.\n        Sat F \\<noteq> None \\<Longrightarrow>\n        Sat (Exp rel r (Future F)) \\<noteq> None", "with F"], ["proof (chain)\npicking this:\n  Sat \\<Phi> = Some (svalid \\<Phi>)\n  Sat \\<Psi> = Some (svalid \\<Psi>)\n  \\<exists>l. ProbUinfty (svalid \\<Phi>) (svalid \\<Psi>) = Some l", "show ?case"], ["proof (prove)\nusing this:\n  Sat \\<Phi> = Some (svalid \\<Phi>)\n  Sat \\<Psi> = Some (svalid \\<Psi>)\n  \\<exists>l. ProbUinfty (svalid \\<Phi>) (svalid \\<Psi>) = Some l\n\ngoal (1 subgoal):\n 1. Sat (Prob r rel (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)) \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  Sat (Prob r rel (U\\<^sup>\\<infinity> \\<Phi> \\<Psi>)) \\<noteq> None\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "case (10 rel r \\<Phi>)"], ["proof (state)\nthis:\n  Sat \\<Phi> \\<noteq> None\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  Sat \\<Phi> \\<noteq> None", "have F: \"Sat \\<Phi> = Some (svalid \\<Phi>)\""], ["proof (prove)\nusing this:\n  Sat \\<Phi> \\<noteq> None\n\ngoal (1 subgoal):\n 1. Sat \\<Phi> = Some (svalid \\<Phi>)", "by (auto intro!: Sat_sound)"], ["proof (state)\nthis:\n  Sat \\<Phi> = Some (svalid \\<Phi>)\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "let ?F = \"svalid \\<Phi>\""], ["proof (state)\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "define N where \"N \\<equiv> Prob0 S ?F\""], ["proof (state)\nthis:\n  N \\<equiv> Prob0 S (svalid \\<Phi>)\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "define Y where \"Y \\<equiv> Prob1 N S ?F\""], ["proof (state)\nthis:\n  Y \\<equiv> Prob1 N S (svalid \\<Phi>)\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "define const where \"const \\<equiv> (\\<lambda>s. if s \\<in> Y \\<and> s \\<notin> ?F then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0)\""], ["proof (state)\nthis:\n  const \\<equiv>\n  \\<lambda>s.\n     if s \\<in> Y \\<and> s \\<notin> svalid \\<Phi>\n     then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s') else 0\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "let ?E = \"\\<lambda>s'. \\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>) \\<partial>T s'\""], ["proof (state)\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "have \"\\<exists>l. gauss_jordan' (LES (S - Y \\<union> ?F)) const = Some l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       gauss_jordan' (LES (S - Y \\<union> svalid \\<Phi>)) const = Some l", "proof (rule gauss_jordan'_complete[OF _ uniqueness_of_ExpFuture[OF N_def Y_def const_def]])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          LES (S - Y \\<union> svalid \\<Phi>) s s' *\n          enn2real\n           (\\<integral>\\<^sup>+ \\<omega>.\n                                 reward (Future \\<Phi>) (s' ## \\<omega>)\n                               \\<partial>T s')) =\n       const s\n 2. \\<And>l s.\n       \\<lbrakk>\\<forall>s\\<in>S.\n                   (\\<Sum>s'\\<in>S.\n                      LES (S - Y \\<union> svalid \\<Phi>) s s' * l s') =\n                   const s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            LES (S - Y \\<union> svalid \\<Phi>) s s' *\n                            l s') =\n                         const s", "show \"\\<forall>s\\<in>S. (\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid \\<Phi>) s s' * enn2real (?E s')) = const s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       (\\<Sum>s'\\<in>S.\n          LES (S - Y \\<union> svalid \\<Phi>) s s' *\n          enn2real\n           (\\<integral>\\<^sup>+ \\<omega>.\n                                 reward (Future \\<Phi>) (s' ## \\<omega>)\n                               \\<partial>T s')) =\n       const s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S.\n          LES (S - Y \\<union> svalid \\<Phi>) s s' *\n          enn2real\n           (\\<integral>\\<^sup>+ \\<omega>.\n                                 reward (Future \\<Phi>) (s' ## \\<omega>)\n                               \\<partial>T s')) =\n       const s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S.\n          LES (S - Y \\<union> svalid \\<Phi>) s s' *\n          enn2real\n           (\\<integral>\\<^sup>+ \\<omega>.\n                                 reward (Future \\<Phi>) (s' ## \\<omega>)\n                               \\<partial>T s')) =\n       const s", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> S \\<Longrightarrow>\n       (\\<Sum>s'\\<in>S.\n          LES (S - Y \\<union> svalid \\<Phi>) s s' *\n          enn2real\n           (\\<integral>\\<^sup>+ \\<omega>.\n                                 reward (Future \\<Phi>) (s' ## \\<omega>)\n                               \\<partial>T s')) =\n       const s", "show \"(\\<Sum>s'\\<in>S. LES (S - Y \\<union> svalid \\<Phi>) s s' * enn2real (?E s')) = const s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "assume s: \"s \\<in> S - (Y - svalid \\<Phi>)\""], ["proof (state)\nthis:\n  s \\<in> S - (Y - svalid \\<Phi>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "assume \"s \\<in> Y\""], ["proof (state)\nthis:\n  s \\<in> Y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s\n 2. \\<not> ?P \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "with \\<open>s \\<in> S\\<close> s \\<open>s \\<in> Y\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> S\n  s \\<in> S - (Y - svalid \\<Phi>)\n  s \\<in> Y\n  s \\<in> Y", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> S\n  s \\<in> S - (Y - svalid \\<Phi>)\n  s \\<in> Y\n  s \\<in> Y\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "by (simp add: LES_def const_def single_l ev_Stream)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     LES (S - Y \\<union> svalid \\<Phi>) s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  const s\n\ngoal (1 subgoal):\n 1. s \\<notin> Y \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> Y \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "assume \"s \\<notin> Y\""], ["proof (state)\nthis:\n  s \\<notin> Y\n\ngoal (1 subgoal):\n 1. s \\<notin> Y \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "with infinite_reward[of s \\<Phi>] Y_def N_def s \\<open>s \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>s \\<in> S;\n   s \\<notin> Prob1 (Prob0 S (svalid \\<Phi>)) S (svalid \\<Phi>)\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future \\<Phi>) (s ## \\<omega>)\n \\<partial>T s =\n                    \\<infinity>\n  Y \\<equiv> Prob1 N S (svalid \\<Phi>)\n  N \\<equiv> Prob0 S (svalid \\<Phi>)\n  s \\<in> S - (Y - svalid \\<Phi>)\n  s \\<in> S\n  s \\<notin> Y", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S;\n   s \\<notin> Prob1 (Prob0 S (svalid \\<Phi>)) S (svalid \\<Phi>)\\<rbrakk>\n  \\<Longrightarrow> \\<integral>\\<^sup>+ \\<omega>.\n   reward (Future \\<Phi>) (s ## \\<omega>)\n \\<partial>T s =\n                    \\<infinity>\n  Y \\<equiv> Prob1 N S (svalid \\<Phi>)\n  N \\<equiv> Prob0 S (svalid \\<Phi>)\n  s \\<in> S - (Y - svalid \\<Phi>)\n  s \\<in> S\n  s \\<notin> Y\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "by (simp add: const_def LES_def single_l del: reward.simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     LES (S - Y \\<union> svalid \\<Phi>) s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  const s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     LES (S - Y \\<union> svalid \\<Phi>) s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  const s\n\ngoal (1 subgoal):\n 1. s \\<notin> S - (Y - svalid \\<Phi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> S - (Y - svalid \\<Phi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "assume s: \"s \\<notin> S - (Y - svalid \\<Phi>)\""], ["proof (state)\nthis:\n  s \\<notin> S - (Y - svalid \\<Phi>)\n\ngoal (1 subgoal):\n 1. s \\<notin> S - (Y - svalid \\<Phi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "have \"(\\<Sum>s'\\<in>S. (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') * enn2real (?E s')) =\n          (\\<Sum>s'\\<in>S. \\<tau> s s' * enn2real (?E s') - (if s' = s then 1 else 0) * enn2real (?E s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s') -\n       (if s' = s then 1 else 0) *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s'))", "by (auto intro!: sum.cong simp: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s') -\n     (if s' = s then 1 else 0) *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s'))\n\ngoal (1 subgoal):\n 1. s \\<notin> S - (Y - svalid \\<Phi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "also"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s') -\n     (if s' = s then 1 else 0) *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s'))\n\ngoal (1 subgoal):\n 1. s \\<notin> S - (Y - svalid \\<Phi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "have \"\\<dots> = (\\<Sum>s'\\<in>S. \\<tau> s s' * enn2real (?E s')) - enn2real (?E s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s') -\n       (if s' = s then 1 else 0) *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) -\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                         \\<partial>T s)", "using \\<open>s \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s') -\n       (if s' = s then 1 else 0) *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    (\\<Sum>s'\\<in>S.\n       \\<tau> s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) -\n    enn2real\n     (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                         \\<partial>T s)", "by (simp add: sum_subtractf single_l)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s') -\n     (if s' = s then 1 else 0) *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) -\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal (1 subgoal):\n 1. s \\<notin> S - (Y - svalid \\<Phi>) \\<Longrightarrow>\n    (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) -\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                       \\<partial>T s)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) -\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                       \\<partial>T s)\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "using s \\<open>s \\<in> S\\<close> existence_of_ExpFuture[OF N_def Y_def \\<open>s \\<in> S\\<close> s]"], ["proof (prove)\nusing this:\n  (\\<Sum>s'\\<in>S.\n     (if s' = s then \\<tau> s s' - 1 else \\<tau> s s') *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) -\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                       \\<partial>T s)\n  s \\<notin> S - (Y - svalid \\<Phi>)\n  s \\<in> S\n  enn2real\n   (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s ## \\<omega>)\n                       \\<partial>T s) -\n  (\\<rho> s + (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')) =\n  (\\<Sum>s'\\<in>S.\n     \\<tau> s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s'))\n\ngoal (1 subgoal):\n 1. (\\<Sum>s'\\<in>S.\n       LES (S - Y \\<union> svalid \\<Phi>) s s' *\n       enn2real\n        (\\<integral>\\<^sup>+ \\<omega>.\n                              reward (Future \\<Phi>) (s' ## \\<omega>)\n                            \\<partial>T s')) =\n    const s", "by (simp add: LES_def const_def del: reward.simps)"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     LES (S - Y \\<union> svalid \\<Phi>) s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  const s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>s'\\<in>S.\n     LES (S - Y \\<union> svalid \\<Phi>) s s' *\n     enn2real\n      (\\<integral>\\<^sup>+ \\<omega>. reward (Future \\<Phi>) (s' ## \\<omega>)\n                          \\<partial>T s')) =\n  const s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s\\<in>S.\n     (\\<Sum>s'\\<in>S.\n        LES (S - Y \\<union> svalid \\<Phi>) s s' *\n        enn2real\n         (\\<integral>\\<^sup>+ \\<omega>.\n                               reward (Future \\<Phi>) (s' ## \\<omega>)\n                             \\<partial>T s')) =\n     const s\n\ngoal (1 subgoal):\n 1. \\<And>l s.\n       \\<lbrakk>\\<forall>s\\<in>S.\n                   (\\<Sum>s'\\<in>S.\n                      LES (S - Y \\<union> svalid \\<Phi>) s s' * l s') =\n                   const s;\n        s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>s'\\<in>S.\n                            LES (S - Y \\<union> svalid \\<Phi>) s s' *\n                            l s') =\n                         const s", "qed simp"], ["proof (state)\nthis:\n  \\<exists>l.\n     gauss_jordan' (LES (S - Y \\<union> svalid \\<Phi>)) const = Some l\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "then"], ["proof (chain)\npicking this:\n  \\<exists>l.\n     gauss_jordan' (LES (S - Y \\<union> svalid \\<Phi>)) const = Some l", "have P: \"\\<exists>l. ExpFuture (svalid \\<Phi>) = Some l\""], ["proof (prove)\nusing this:\n  \\<exists>l.\n     gauss_jordan' (LES (S - Y \\<union> svalid \\<Phi>)) const = Some l\n\ngoal (1 subgoal):\n 1. \\<exists>l. ExpFuture (svalid \\<Phi>) = Some l", "unfolding ExpFuture_def const_def N_def Y_def"], ["proof (prove)\nusing this:\n  \\<exists>l.\n     gauss_jordan'\n      (LES (S - Prob1 (Prob0 S (svalid \\<Phi>)) S (svalid \\<Phi>) \\<union>\n            svalid \\<Phi>))\n      (\\<lambda>s.\n          if s \\<in> Prob1 (Prob0 S (svalid \\<Phi>)) S\n                      (svalid \\<Phi>) \\<and>\n             s \\<notin> svalid \\<Phi>\n          then - \\<rho> s - (\\<Sum>s'\\<in>S. \\<tau> s s' * \\<iota> s s')\n          else 0) =\n     Some l\n\ngoal (1 subgoal):\n 1. \\<exists>l.\n       (let N = Prob0 S (svalid \\<Phi>); Y = Prob1 N S (svalid \\<Phi>)\n        in gauss_jordan' (LES (S - Y \\<union> svalid \\<Phi>))\n            (\\<lambda>i.\n                if i \\<in> Y \\<and> i \\<notin> svalid \\<Phi>\n                then - \\<rho> i -\n                     (\\<Sum>s'\\<in>S. \\<tau> i s' * \\<iota> i s')\n                else 0) \\<bind>\n           (\\<lambda>sol.\n               Some\n                (\\<lambda>s.\n                    if s \\<in> Y then ennreal (sol s) else \\<infinity>))) =\n       Some l", "by auto"], ["proof (state)\nthis:\n  \\<exists>l. ExpFuture (svalid \\<Phi>) = Some l\n\ngoal (9 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None\n 9. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Exp rel r (Future F)) \\<noteq> None", "with F"], ["proof (chain)\npicking this:\n  Sat \\<Phi> = Some (svalid \\<Phi>)\n  \\<exists>l. ExpFuture (svalid \\<Phi>) = Some l", "show ?case"], ["proof (prove)\nusing this:\n  Sat \\<Phi> = Some (svalid \\<Phi>)\n  \\<exists>l. ExpFuture (svalid \\<Phi>) = Some l\n\ngoal (1 subgoal):\n 1. Sat (Exp rel r (Future \\<Phi>)) \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  Sat (Exp rel r (Future \\<Phi>)) \\<noteq> None\n\ngoal (8 subgoals):\n 1. Sat sform.true \\<noteq> None\n 2. \\<And>L. Sat (Label L) \\<noteq> None\n 3. \\<And>F. Sat F \\<noteq> None \\<Longrightarrow> Sat (Neg F) \\<noteq> None\n 4. \\<And>F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (And F1 F2) \\<noteq> None\n 5. \\<And>rel r F.\n       Sat F \\<noteq> None \\<Longrightarrow>\n       Sat (Prob rel r (X F)) \\<noteq> None\n 6. \\<And>rel r k F1 F2.\n       \\<lbrakk>Sat F1 \\<noteq> None;\n        \\<And>a.\n           Sat F1 = Some a \\<Longrightarrow> Sat F2 \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> Sat (Prob rel r (U k F1 F2)) \\<noteq> None\n 7. \\<And>rel r k. Sat (Exp rel r (C\\<^sup>\\<le> k)) \\<noteq> None\n 8. \\<And>rel r k. Sat (Exp rel r (I\\<^sup>= k)) \\<noteq> None", "qed (force split: bind_split)+"], ["", "subsection \\<open>Completeness and Soundness @{const Sat}\\<close>"], ["", "corollary Sat: \"Sat \\<Phi> = Some (svalid \\<Phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sat \\<Phi> = Some (svalid \\<Phi>)", "using Sat_sound Sat_complete"], ["proof (prove)\nusing this:\n  Sat ?F \\<noteq> None \\<Longrightarrow> Sat ?F = Some (svalid ?F)\n  Sat ?F \\<noteq> None\n\ngoal (1 subgoal):\n 1. Sat \\<Phi> = Some (svalid \\<Phi>)", "by auto"], ["", "end"], ["", "end"]]}