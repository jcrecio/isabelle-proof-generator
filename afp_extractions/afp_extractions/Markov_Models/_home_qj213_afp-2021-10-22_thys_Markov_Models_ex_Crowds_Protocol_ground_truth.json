{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/Crowds_Protocol.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma cond_prob_nonneg[simp]: \"0 \\<le> cond_prob M A B\"", "lemma (in MC_syntax) emeasure_suntil_geometric:\n  assumes [measurable]: \"Measurable.pred S P\"\n  assumes \"s \\<in> X\" and *[simp]: \"0 \\<le> p\" \"0 \\<le> r\"\n  assumes r: \"\\<And>s. s \\<in> X \\<Longrightarrow> emeasure (T s) {\\<omega>\\<in>space (T s). P \\<omega>} = ennreal r\"\n  assumes p: \"\\<And>s. s \\<in> X \\<Longrightarrow> emeasure (K s) X = ennreal p\" \"p < 1\"\n  assumes \"\\<And>t. AE \\<omega> in T t. \\<not> (P \\<sqinter> (HLD X \\<sqinter> nxt (HLD X suntil P))) \\<omega>\"\n  shows \"emeasure (T s) {\\<omega>\\<in>space (T s). (HLD X suntil P) \\<omega>} = r / (1 - p)\"", "lemma inj_Mix[simp]: \"inj_on Mix A\"", "lemma inj_Init[simp]: \"inj_on Init A\"", "lemma distinct_state_image[simp]:\n  \"Start \\<notin> Mix ` A\" \"Init j \\<notin> Mix ` A\" \"End \\<notin> Mix ` A\" \"Mix j \\<in> Mix ` A \\<longleftrightarrow> j \\<in> A\"\n  \"Start \\<notin> Init ` A\" \"Mix j \\<notin> Init ` A\" \"End \\<notin> Init ` A\" \"Init j \\<in> Init ` A \\<longleftrightarrow> j \\<in> A\"", "lemma Init_cut_Mix[simp]:\n  \"Init ` H \\<inter> Mix ` J = {}\"", "lemma p_f_nonneg[simp]: \"0 \\<le> p_f\" \"p_f \\<le> 1\"", "lemma p_j_nonneg[simp]: \"0 \\<le> p_j\"", "lemma p_H_nonneg[simp]: \"0 \\<le> p_H\" \"p_H \\<le> 1\"", "lemma finite_C[simp]: \"finite C\"", "lemma sum_p_i_C[simp]: \"sum p_i C = 0\"", "lemma sum_p_i_H[simp]: \"sum p_i H = 1\"", "lemma possible_jondo:\n  obtains j where \"j \\<in> J\" \"j \\<notin> C\" \"p_i j \\<noteq> 0\"", "lemma C_le_J[simp]: \"card C < card J\"", "lemma p_H: \"0 < p_H\" \"p_H < 1\"", "lemma p_H_p_f_pos: \"0 < p_H * p_f\"", "lemma p_H_p_f_less_1: \"p_H * p_f < 1\"", "lemma p_j_pos: \"0 < p_j\"", "lemma H_compl: \"1 - p_H = real (card C) / real (card J)\"", "lemma H_compl2: \"1 - p_H = card C * p_j\"", "lemma H_eq2: \"card H * p_j = p_H\"", "lemma pmf_next_pmf[simp]: \"pmf (N s) t = next_prob s t\"", "lemma next_prob_Start[simp]: \"next_prob Start (Init j) = (if j \\<in> H then p_i j else 0)\"", "lemma next_prob_to_Init[simp]: \"j \\<in> H \\<Longrightarrow> next_prob s (Init j) =\n    (case s of Start \\<Rightarrow> p_i j | _ \\<Rightarrow> 0)\"", "lemma next_prob_to_Mix[simp]: \"j \\<in> J \\<Longrightarrow> next_prob s (Mix j) =\n    (case s of Init j \\<Rightarrow> p_j | Mix j \\<Rightarrow> p_f * p_j | _ \\<Rightarrow> 0)\"", "lemma next_prob_to_End[simp]: \"next_prob s End =\n    (case s of Mix j \\<Rightarrow> 1 - p_f | End \\<Rightarrow> 1 | _ \\<Rightarrow> 0)\"", "lemma next_prob_from_End[simp]: \"next_prob End s = 0 \\<longleftrightarrow> s \\<noteq> End\"", "lemma next_prob_Mix_MixI: \"\\<exists>j. s = Mix j \\<Longrightarrow> \\<exists>j\\<in>J. s' = Mix j \\<Longrightarrow> next_prob s s' = p_f * p_j\"", "lemma E_Start: \"E Start = {Init j | j. j \\<in> H \\<and> p_i j \\<noteq> 0 }\"", "lemma E_Init: \"E (Init j) = {Mix j | j. j \\<in> J }\"", "lemma E_Mix: \"E (Mix j) = {Mix j | j. j \\<in> J } \\<union> {End}\"", "lemma E_End: \"E End = {End}\"", "lemma enabled_End:\n  \"enabled End \\<omega> \\<longleftrightarrow> \\<omega> = sconst End\"", "lemma AE_End: \"(AE \\<omega> in T End. P \\<omega>) \\<longleftrightarrow> P (sconst End)\"", "lemma emeasure_Init_eq_Mix:\n  assumes [measurable]: \"Measurable.pred S P\"\n  assumes AE_End: \"AE x in T End. \\<not> P (End ## x)\"\n  shows \"emeasure (T (Init j)) {x\\<in>space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x\\<in>space (T (Mix j)). P x} / p_f\"", "lemma visit_unique1:\n  \"visit I1 L1 \\<omega> \\<Longrightarrow> visit I2 L2 \\<omega> \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}\"", "lemma visit_unique2:\n  assumes \"visit I1 L1 \\<omega>\" \"visit I2 L2 \\<omega>\"\n  shows \"L1 \\<inter> L2 \\<noteq> {}\"", "lemma visit_imp_in_H: \"visit {i} J \\<omega> \\<Longrightarrow> i \\<in> H\"", "lemma emeasure_visit:\n  assumes I: \"I \\<subseteq> H\" and L: \"L \\<subseteq> J\"\n  shows \"emeasure \\<PP> {\\<omega>\\<in>space \\<PP>. visit I L \\<omega>} = (\\<Sum>i\\<in>I. p_i i) * (card L * p_j)\"", "lemma measurable_visit[measurable]: \"Measurable.pred S (visit I L)\"", "lemma AE_visit: \"AE \\<omega> in \\<PP>. visit H J \\<omega>\"", "lemma server_view1: \"j \\<in> J \\<Longrightarrow> \\<P>(\\<omega> in \\<PP>. visit H {j} \\<omega>) = p_j\"", "lemma server_view_indep:\n  \"L \\<subseteq> J \\<Longrightarrow> I \\<subseteq> H \\<Longrightarrow> \\<P>(\\<omega> in \\<PP>. visit I L \\<omega>) = \\<P>(\\<omega> in \\<PP>. visit H L \\<omega>) * \\<P>(\\<omega> in \\<PP>. visit I J \\<omega>)\"", "lemma server_view: \"\\<P>(\\<omega> in \\<PP>. \\<exists>j\\<in>H. visit {j} {j} \\<omega>) = p_j\"", "lemma measurable_hit_C[measurable]: \"Measurable.pred S hit_C\"", "lemma measurable_before_C[measurable]: \"Measurable.pred S (before_C B)\"", "lemma before_C:\n  assumes \\<omega>: \"enabled Start \\<omega>\"\n  shows \"before_C B \\<omega> \\<longleftrightarrow>\n    ((Init`H \\<cdot> (HLD (Mix`H) suntil (Mix`(B \\<inter> H) \\<cdot> HLD (Mix`C)))) or (Init`(B \\<inter> H) \\<cdot> HLD (Mix`C))) \\<omega>\"", "lemma before_C_unique:\n  assumes \\<omega>: \"before_C I1 \\<omega>\" \"before_C I2 \\<omega>\" shows \"I1 \\<inter> I2 \\<noteq> {}\"", "lemma hit_C_imp_before_C:\n  assumes \"enabled Start \\<omega>\" \"hit_C \\<omega>\" shows \"before_C H \\<omega>\"", "lemma before_C_single:\n  assumes \"before_C I \\<omega>\" shows \"\\<exists>i\\<in>I \\<inter> H. before_C {i} \\<omega>\"", "lemma before_C_imp_in_H: \"before_C {i} \\<omega> \\<Longrightarrow> i \\<in> H\"", "lemma Pr_hit_C: \"\\<P>(\\<omega> in \\<PP>. hit_C \\<omega>) = (1 - p_H) / (1 - p_H * p_f)\"", "lemma before_C_imp_hit_C:\n  assumes \"enabled Start \\<omega>\" \"before_C B \\<omega>\"\n  shows \"hit_C \\<omega>\"", "lemma negE: \"\\<not> P \\<Longrightarrow> P \\<Longrightarrow> False\"", "lemma Pr_visit_before_C:\n  assumes L: \"L \\<subseteq> H\" and I: \"I \\<subseteq> H\"\n  shows \"\\<P>(\\<omega> in \\<PP>. visit I J \\<omega> \\<and> before_C L \\<omega> \\<bar> hit_C \\<omega> ) =\n    (\\<Sum>i\\<in>I. p_i i) * card L * p_j * p_f + (\\<Sum>i\\<in>I \\<inter> L. p_i i) * (1 - p_H * p_f)\"", "lemma Pr_visit_eq_before_C:\n  \"\\<P>(\\<omega> in \\<PP>. \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega> \\<bar> hit_C \\<omega> ) = 1 - (p_H - p_j) * p_f\"", "lemma probably_innocent:\n  assumes approx: \"1 / (2 * (p_H - p_j)) \\<le> p_f\" and \"p_H \\<noteq> p_j\"\n  shows \"\\<P>(\\<omega> in \\<PP>. \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega> \\<bar> hit_C \\<omega> ) \\<le> 1 / 2\"", "lemma Pr_before_C:\n  assumes L: \"L \\<subseteq> H\"\n  shows \"\\<P>(\\<omega> in \\<PP>. before_C L \\<omega> \\<bar> hit_C \\<omega> ) =\n    card L * p_j * p_f + (\\<Sum>l\\<in>L. p_i l) * (1 - p_H * p_f)\"", "lemma P_visit:\n  assumes I: \"I \\<subseteq> H\"\n  shows \"\\<P>(\\<omega> in \\<PP>. visit I J \\<omega> \\<bar> hit_C \\<omega> ) = (\\<Sum>i\\<in>I. p_i i)\"", "lemma emeasure_hit_C_not_0: \"emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} \\<noteq> 0\"", "lemma measurable_hC[measurable (raw)]:\n  \"A \\<in> sets S \\<Longrightarrow> A \\<in> sets hC\"\n  \"f \\<in> measurable M S \\<Longrightarrow> f \\<in> measurable M hC\"\n  \"g \\<in> measurable S M \\<Longrightarrow> g \\<in> measurable hC M\"\n  \"A \\<inter> space S \\<in> sets S \\<Longrightarrow> A \\<inter> space hC \\<in> sets S\"", "lemma vimage_Int_space_C[simp]:\n  \"f -` {x} \\<inter> space hC = {\\<omega>\\<in>space S. f \\<omega> = x}\"", "lemma simple_functionI:\n  assumes \"finite (range f)\"\n  assumes [measurable]: \"\\<And>x. {\\<omega>\\<in>space S. f \\<omega> = x} \\<in> sets S\"\n  shows \"simple_function hC f\"", "lemma measure_hC[simp]:\n  assumes A[measurable]: \"A \\<in> sets S\"\n  shows \"measure hC A = \\<P>(\\<omega> in \\<PP>. \\<omega> \\<in> A \\<bar> hit_C \\<omega> )\"", "lemma first_J_eq:\n  \"visit {i} J \\<omega> \\<Longrightarrow> first_J \\<omega> = i\"", "lemma AE_first_J:\n  \"AE \\<omega> in \\<PP>. visit {i} J \\<omega> \\<longleftrightarrow> first_J \\<omega> = i\"", "lemma measurbale_first_J[measurable]: \"first_J \\<in> measurable S (count_space UNIV)\"", "lemma measurbale_last_H[measurable]: \"last_H \\<in> measurable S (count_space UNIV)\"", "lemma last_H_eq:\n  \"before_C {i} \\<omega> \\<Longrightarrow> last_H \\<omega> = i\"", "lemma last_H:\n  assumes \"enabled Start \\<omega>\" \"hit_C \\<omega>\"\n  shows \"before_C {last_H \\<omega>} \\<omega>\" \"last_H \\<omega> \\<in> H\"", "lemma AE_last_H:\n  \"AE \\<omega> in \\<PP>. hit_C \\<omega> \\<longrightarrow> before_C {i} \\<omega> \\<longleftrightarrow> last_H \\<omega> = i\"", "lemma information_flow:\n  defines \"h \\<equiv> real (card H)\"\n  assumes init_uniform: \"\\<And>i. i \\<in> H \\<Longrightarrow> p_i i = 1 / h\"\n  shows \"\\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\""], "translations": [["", "lemma cond_prob_nonneg[simp]: \"0 \\<le> cond_prob M A B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cond_prob M A B", "by (auto simp: cond_prob_def)"], ["", "lemma (in MC_syntax) emeasure_suntil_geometric:\n  assumes [measurable]: \"Measurable.pred S P\"\n  assumes \"s \\<in> X\" and *[simp]: \"0 \\<le> p\" \"0 \\<le> r\"\n  assumes r: \"\\<And>s. s \\<in> X \\<Longrightarrow> emeasure (T s) {\\<omega>\\<in>space (T s). P \\<omega>} = ennreal r\"\n  assumes p: \"\\<And>s. s \\<in> X \\<Longrightarrow> emeasure (K s) X = ennreal p\" \"p < 1\"\n  assumes \"\\<And>t. AE \\<omega> in T t. \\<not> (P \\<sqinter> (HLD X \\<sqinter> nxt (HLD X suntil P))) \\<omega>\"\n  shows \"emeasure (T s) {\\<omega>\\<in>space (T s). (HLD X suntil P) \\<omega>} = r / (1 - p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T s) {\\<omega> \\<in> space (T s). (HLD X suntil P) \\<omega>} =\n    ennreal (r / (1 - p))", "proof (subst emeasure_suntil_disj)"], ["proof (state)\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "let ?F = \"\\<lambda>F s. emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} + \\<integral>\\<^sup>+ t. F t * indicator X t \\<partial>K s\""], ["proof (state)\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "let ?f = \"\\<lambda>x. ennreal r + ennreal p * x\""], ["proof (state)\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "have \"mono ?F\" \"mono ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\n     (\\<lambda>F s.\n         emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n         set_nn_integral (measure_pmf (K s)) X F) &&&\n    mono (\\<lambda>x. ennreal r + ennreal p * x)", "by (auto intro!: monoI max.mono add_mono nn_integral_mono mult_left_mono mult_right_mono simp: le_fun_def)"], ["proof (state)\nthis:\n  mono\n   (\\<lambda>F s.\n       emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n       set_nn_integral (measure_pmf (K s)) X F)\n  mono (\\<lambda>x. ennreal r + ennreal p * x)\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "have 1: \"lfp ?f \\<le> lfp ?F s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. ennreal r + ennreal p * x)\n    \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           s", "using \\<open>s \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> X\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. ennreal r + ennreal p * x)\n    \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           s", "proof (induction arbitrary: s rule: lfp_ordinal_induct[OF \\<open>mono ?f\\<close>])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S \\<le> lfp (\\<lambda>F s.\n                                   emeasure (T s)\n                                    {\\<omega> \\<in> space (T s).\n                                     P \\<omega>} +\n                                   set_nn_integral (measure_pmf (K s)) X F)\n                            s;\n        S \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> ennreal r + ennreal p * S\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S \\<le> lfp (\\<lambda>F s.\nemeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\nset_nn_integral (measure_pmf (K s)) X F)\n                               x;\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> M\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s", "case step: (1 x)"], ["proof (state)\nthis:\n  ?s1 \\<in> X \\<Longrightarrow>\n  x \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           ?s1\n  x \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  s \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S \\<le> lfp (\\<lambda>F s.\n                                   emeasure (T s)\n                                    {\\<omega> \\<in> space (T s).\n                                     P \\<omega>} +\n                                   set_nn_integral (measure_pmf (K s)) X F)\n                            s;\n        S \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> ennreal r + ennreal p * S\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S \\<le> lfp (\\<lambda>F s.\nemeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\nset_nn_integral (measure_pmf (K s)) X F)\n                               x;\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> M\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s", "then"], ["proof (chain)\npicking this:\n  ?s1 \\<in> X \\<Longrightarrow>\n  x \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           ?s1\n  x \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  s \\<in> X", "have \"?f x \\<le> ?F (\\<lambda>_. x) s\""], ["proof (prove)\nusing this:\n  ?s1 \\<in> X \\<Longrightarrow>\n  x \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           ?s1\n  x \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  s \\<in> X\n\ngoal (1 subgoal):\n 1. ennreal r + ennreal p * x\n    \\<le> emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n          (\\<integral>\\<^sup>+t\\<in>X. x\\<partial>measure_pmf (K s))", "by (auto simp: p r[simplified] nn_integral_cmult mult.commute[of _ x]\n               intro!: add_mono mult_right_mono)"], ["proof (state)\nthis:\n  ennreal r + ennreal p * x\n  \\<le> emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n        (\\<integral>\\<^sup>+t\\<in>X. x\\<partial>measure_pmf (K s))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S \\<le> lfp (\\<lambda>F s.\n                                   emeasure (T s)\n                                    {\\<omega> \\<in> space (T s).\n                                     P \\<omega>} +\n                                   set_nn_integral (measure_pmf (K s)) X F)\n                            s;\n        S \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> ennreal r + ennreal p * S\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S \\<le> lfp (\\<lambda>F s.\nemeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\nset_nn_integral (measure_pmf (K s)) X F)\n                               x;\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> M\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s", "also"], ["proof (state)\nthis:\n  ennreal r + ennreal p * x\n  \\<le> emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n        (\\<integral>\\<^sup>+t\\<in>X. x\\<partial>measure_pmf (K s))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S \\<le> lfp (\\<lambda>F s.\n                                   emeasure (T s)\n                                    {\\<omega> \\<in> space (T s).\n                                     P \\<omega>} +\n                                   set_nn_integral (measure_pmf (K s)) X F)\n                            s;\n        S \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> ennreal r + ennreal p * S\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S \\<le> lfp (\\<lambda>F s.\nemeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\nset_nn_integral (measure_pmf (K s)) X F)\n                               x;\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> M\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s", "have \"?F (\\<lambda>_. x) \\<le> ?F (lfp ?F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n        (\\<integral>\\<^sup>+t\\<in>X. x\\<partial>measure_pmf (K s)))\n    \\<le> (\\<lambda>s.\n              emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n              set_nn_integral (measure_pmf (K s)) X\n               (lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F)))", "using step"], ["proof (prove)\nusing this:\n  ?s1 \\<in> X \\<Longrightarrow>\n  x \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           ?s1\n  x \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  s \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n        (\\<integral>\\<^sup>+t\\<in>X. x\\<partial>measure_pmf (K s)))\n    \\<le> (\\<lambda>s.\n              emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n              set_nn_integral (measure_pmf (K s)) X\n               (lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F)))", "by (intro le_funI add_mono order_refl nn_integral_mono) (auto simp: split: split_indicator)"], ["proof (state)\nthis:\n  (\\<lambda>s.\n      emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n      (\\<integral>\\<^sup>+t\\<in>X. x\\<partial>measure_pmf (K s)))\n  \\<le> (\\<lambda>s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X\n             (lfp (\\<lambda>F s.\n                      emeasure (T s)\n                       {\\<omega> \\<in> space (T s). P \\<omega>} +\n                      set_nn_integral (measure_pmf (K s)) X F)))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S \\<le> lfp (\\<lambda>F s.\n                                   emeasure (T s)\n                                    {\\<omega> \\<in> space (T s).\n                                     P \\<omega>} +\n                                   set_nn_integral (measure_pmf (K s)) X F)\n                            s;\n        S \\<le> lfp (\\<lambda>x. ennreal r + ennreal p * x);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> ennreal r + ennreal p * S\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S \\<le> lfp (\\<lambda>F s.\nemeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\nset_nn_integral (measure_pmf (K s)) X F)\n                               x;\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> M\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y. x \\<le> y \\<Longrightarrow> x s \\<le> y s) \\<Longrightarrow>\n  ennreal r + ennreal p * x\n  \\<le> emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n        set_nn_integral (measure_pmf (K s)) X\n         (lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y. x \\<le> y \\<Longrightarrow> x s \\<le> y s) \\<Longrightarrow>\n  ennreal r + ennreal p * x\n  \\<le> emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n        set_nn_integral (measure_pmf (K s)) X\n         (lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F))\n\ngoal (1 subgoal):\n 1. ennreal r + ennreal p * x\n    \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n           s", "by (subst lfp_unfold[OF \\<open>mono ?F\\<close>]) (auto simp: le_fun_def)"], ["proof (state)\nthis:\n  ennreal r + ennreal p * x\n  \\<le> lfp (\\<lambda>F s.\n                emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                set_nn_integral (measure_pmf (K s)) X F)\n         s\n\ngoal (1 subgoal):\n 1. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S \\<le> lfp (\\<lambda>F s.\nemeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\nset_nn_integral (measure_pmf (K s)) X F)\n                               x;\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> \\<Squnion> M\n                         \\<le> lfp (\\<lambda>F s.\n emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n set_nn_integral (measure_pmf (K s)) X F)\n                                s", "qed (auto intro!: Sup_least)"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  \\<le> lfp (\\<lambda>F s.\n                emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                set_nn_integral (measure_pmf (K s)) X F)\n         s\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "also"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  \\<le> lfp (\\<lambda>F s.\n                emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                set_nn_integral (measure_pmf (K s)) X F)\n         s\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "have 2: \"lfp ?F s \\<le> r / (1 - p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s\n    \\<le> ennreal (r / (1 - p))", "using \\<open>s \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> X\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s\n    \\<le> ennreal (r / (1 - p))", "proof (induction arbitrary: s rule: lfp_ordinal_induct[OF \\<open>mono ?F\\<close>])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "case (1 S)"], ["proof (state)\nthis:\n  ?s1 \\<in> X \\<Longrightarrow> S ?s1 \\<le> ennreal (r / (1 - p))\n  S \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n  s \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "with r"], ["proof (chain)\npicking this:\n  ?s1 \\<in> X \\<Longrightarrow>\n  emeasure (T ?s1) {\\<omega> \\<in> space (T ?s1). P \\<omega>} = ennreal r\n  ?s1 \\<in> X \\<Longrightarrow> S ?s1 \\<le> ennreal (r / (1 - p))\n  S \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n  s \\<in> X", "have \"?F S s \\<le> ennreal r + (\\<integral>\\<^sup>+x. ennreal (r / (1 - p)) * indicator X x \\<partial>K s)\""], ["proof (prove)\nusing this:\n  ?s1 \\<in> X \\<Longrightarrow>\n  emeasure (T ?s1) {\\<omega> \\<in> space (T ?s1). P \\<omega>} = ennreal r\n  ?s1 \\<in> X \\<Longrightarrow> S ?s1 \\<le> ennreal (r / (1 - p))\n  S \\<le> lfp (\\<lambda>F s.\n                  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                  set_nn_integral (measure_pmf (K s)) X F)\n  s \\<in> X\n\ngoal (1 subgoal):\n 1. emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n    set_nn_integral (measure_pmf (K s)) X S\n    \\<le> ennreal r +\n          (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n           \\<partial>measure_pmf (K s))", "by (intro add_mono nn_integral_mono) (auto split: split_indicator)"], ["proof (state)\nthis:\n  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n  set_nn_integral (measure_pmf (K s)) X S\n  \\<le> ennreal r +\n        (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n         \\<partial>measure_pmf (K s))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "also"], ["proof (state)\nthis:\n  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n  set_nn_integral (measure_pmf (K s)) X S\n  \\<le> ennreal r +\n        (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n         \\<partial>measure_pmf (K s))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "have \"\\<dots> \\<le> ennreal r + ennreal (r * p / (1 - p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal r +\n    (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n     \\<partial>measure_pmf (K s))\n    \\<le> ennreal r + ennreal (r * p / (1 - p))", "using \\<open>s \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> X\n\ngoal (1 subgoal):\n 1. ennreal r +\n    (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n     \\<partial>measure_pmf (K s))\n    \\<le> ennreal r + ennreal (r * p / (1 - p))", "by (simp add: nn_integral_cmult_indicator p ennreal_mult''[symmetric])"], ["proof (state)\nthis:\n  ennreal r +\n  (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n   \\<partial>measure_pmf (K s))\n  \\<le> ennreal r + ennreal (r * p / (1 - p))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "also"], ["proof (state)\nthis:\n  ennreal r +\n  (\\<integral>\\<^sup>+x\\<in>X. ennreal (r / (1 - p))\n   \\<partial>measure_pmf (K s))\n  \\<le> ennreal r + ennreal (r * p / (1 - p))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "have \"\\<dots> = ennreal (r / (1 - p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal r + ennreal (r * p / (1 - p)) = ennreal (r / (1 - p))", "using \\<open>p < 1\\<close>"], ["proof (prove)\nusing this:\n  p < 1\n\ngoal (1 subgoal):\n 1. ennreal r + ennreal (r * p / (1 - p)) = ennreal (r / (1 - p))", "by (simp add: field_simps ennreal_plus[symmetric] del: ennreal_plus)"], ["proof (state)\nthis:\n  ennreal r + ennreal (r * p / (1 - p)) = ennreal (r / (1 - p))\n\ngoal (2 subgoals):\n 1. \\<And>S s.\n       \\<lbrakk>\\<And>s.\n                   s \\<in> X \\<Longrightarrow>\n                   S s \\<le> ennreal (r / (1 - p));\n        S \\<le> lfp (\\<lambda>F s.\n                        emeasure (T s)\n                         {\\<omega> \\<in> space (T s). P \\<omega>} +\n                        set_nn_integral (measure_pmf (K s)) X F);\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> emeasure (T s)\n                          {\\<omega> \\<in> space (T s). P \\<omega>} +\n                         set_nn_integral (measure_pmf (K s)) X S\n                         \\<le> ennreal (r / (1 - p))\n 2. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "finally"], ["proof (chain)\npicking this:\n  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n  set_nn_integral (measure_pmf (K s)) X S\n  \\<le> ennreal (r / (1 - p))", "show ?case"], ["proof (prove)\nusing this:\n  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n  set_nn_integral (measure_pmf (K s)) X S\n  \\<le> ennreal (r / (1 - p))\n\ngoal (1 subgoal):\n 1. emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n    set_nn_integral (measure_pmf (K s)) X S\n    \\<le> ennreal (r / (1 - p))", "."], ["proof (state)\nthis:\n  emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n  set_nn_integral (measure_pmf (K s)) X S\n  \\<le> ennreal (r / (1 - p))\n\ngoal (1 subgoal):\n 1. \\<And>M s.\n       \\<lbrakk>\\<forall>S\\<in>M.\n                   \\<forall>x.\n                      x \\<in> X \\<longrightarrow>\n                      S x \\<le> ennreal (r / (1 - p));\n        s \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (\\<Squnion> M) s \\<le> ennreal (r / (1 - p))", "qed (auto intro!: SUP_least)"], ["proof (state)\nthis:\n  lfp (\\<lambda>F s.\n          emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n          set_nn_integral (measure_pmf (K s)) X F)\n   s\n  \\<le> ennreal (r / (1 - p))\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "finally"], ["proof (chain)\npicking this:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) \\<le> ennreal (r / (1 - p))", "obtain x where x: \"lfp ?f = ennreal x\" and [simp]: \"0 \\<le> x\""], ["proof (prove)\nusing this:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) \\<le> ennreal (r / (1 - p))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>lfp (\\<lambda>x. ennreal r + ennreal p * x) = ennreal x;\n         0 \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"lfp ?f\") (auto simp: top_unique)"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) = ennreal x\n  0 \\<le> x\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "from \\<open>p < 1\\<close>"], ["proof (chain)\npicking this:\n  p < 1", "have \"\\<And>x. x = r + p * x \\<Longrightarrow> x = r / (1 - p)\""], ["proof (prove)\nusing this:\n  p < 1\n\ngoal (1 subgoal):\n 1. \\<And>x. x = r + p * x \\<Longrightarrow> x = r / (1 - p)", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  ?x1 = r + p * ?x1 \\<Longrightarrow> ?x1 = r / (1 - p)\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "with lfp_unfold[OF \\<open>mono ?f\\<close>] \\<open>p < 1\\<close>"], ["proof (chain)\npicking this:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) =\n  ennreal r + ennreal p * lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  p < 1\n  ?x1 = r + p * ?x1 \\<Longrightarrow> ?x1 = r / (1 - p)", "have \"lfp ?f = r / (1 - p)\""], ["proof (prove)\nusing this:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) =\n  ennreal r + ennreal p * lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  p < 1\n  ?x1 = r + p * ?x1 \\<Longrightarrow> ?x1 = r / (1 - p)\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>x. ennreal r + ennreal p * x) = ennreal (r / (1 - p))", "unfolding x"], ["proof (prove)\nusing this:\n  ennreal x = ennreal r + ennreal p * ennreal x\n  p < 1\n  ?x1 = r + p * ?x1 \\<Longrightarrow> ?x1 = r / (1 - p)\n\ngoal (1 subgoal):\n 1. ennreal x = ennreal (r / (1 - p))", "by (auto simp add: ennreal_plus[symmetric] ennreal_mult[symmetric] simp del: ennreal_plus)"], ["proof (state)\nthis:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) = ennreal (r / (1 - p))\n\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>\n 3. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "with 1 2"], ["proof (chain)\npicking this:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  \\<le> lfp (\\<lambda>F s.\n                emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                set_nn_integral (measure_pmf (K s)) X F)\n         s\n  lfp (\\<lambda>F s.\n          emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n          set_nn_integral (measure_pmf (K s)) X F)\n   s\n  \\<le> ennreal (r / (1 - p))\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) = ennreal (r / (1 - p))", "show \"lfp ?F s = ennreal (r / (1 - p))\""], ["proof (prove)\nusing this:\n  lfp (\\<lambda>x. ennreal r + ennreal p * x)\n  \\<le> lfp (\\<lambda>F s.\n                emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n                set_nn_integral (measure_pmf (K s)) X F)\n         s\n  lfp (\\<lambda>F s.\n          emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n          set_nn_integral (measure_pmf (K s)) X F)\n   s\n  \\<le> ennreal (r / (1 - p))\n  lfp (\\<lambda>x. ennreal r + ennreal p * x) = ennreal (r / (1 - p))\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>F s.\n            emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n            set_nn_integral (measure_pmf (K s)) X F)\n     s =\n    ennreal (r / (1 - p))", "by auto"], ["proof (state)\nthis:\n  lfp (\\<lambda>F s.\n          emeasure (T s) {\\<omega> \\<in> space (T s). P \\<omega>} +\n          set_nn_integral (measure_pmf (K s)) X F)\n   s =\n  ennreal (r / (1 - p))\n\ngoal (2 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<And>t.\n       AE \\<omega> in T t. \\<not> (P \\<sqinter>\n                                   (HLD X \\<sqinter> nxt (HLD X suntil P)))\n                                   \\<omega>", "qed fact+"], ["", "subsection \\<open>Definition of the Crowds-Protocol\\<close>"], ["", "datatype 'a state = Start | Init 'a | Mix 'a | End"], ["", "lemma inj_Mix[simp]: \"inj_on Mix A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Mix A", "by (auto intro: inj_onI)"], ["", "lemma inj_Init[simp]: \"inj_on Init A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Init A", "by (auto intro: inj_onI)"], ["", "lemma distinct_state_image[simp]:\n  \"Start \\<notin> Mix ` A\" \"Init j \\<notin> Mix ` A\" \"End \\<notin> Mix ` A\" \"Mix j \\<in> Mix ` A \\<longleftrightarrow> j \\<in> A\"\n  \"Start \\<notin> Init ` A\" \"Mix j \\<notin> Init ` A\" \"End \\<notin> Init ` A\" \"Init j \\<in> Init ` A \\<longleftrightarrow> j \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Start \\<notin> Mix ` A &&& Init j \\<notin> Mix ` A) &&&\n     End \\<notin> Mix ` A &&& (Mix j \\<in> Mix ` A) = (j \\<in> A)) &&&\n    (Start \\<notin> Init ` A &&& Mix j \\<notin> Init ` A) &&&\n    End \\<notin> Init ` A &&& (Init j \\<in> Init ` A) = (j \\<in> A)", "by auto"], ["", "lemma Init_cut_Mix[simp]:\n  \"Init ` H \\<inter> Mix ` J = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Init ` H \\<inter> Mix ` J = {}", "by auto"], ["", "abbreviation \"Jondo B \\<equiv> Init`B \\<union> Mix`B\""], ["", "locale Crowds_Protocol =\n  fixes J :: \"'a set\" and C :: \"'a set\" and p_f :: real and p_i :: \"'a \\<Rightarrow> real\"\n  assumes J_not_empty: \"J \\<noteq> {}\" and finite_J[simp]: \"finite J\"\n  assumes C_smaller: \"C \\<subset> J\" and C_non_empty: \"C \\<noteq> {}\"\n  assumes p_f: \"0 < p_f\" \"p_f < 1\"\n  assumes p_i_nonneg[simp]: \"\\<And>j. j \\<in> J \\<Longrightarrow> 0 \\<le> p_i j\"\n  assumes p_i_distr: \"(\\<Sum>j\\<in>J. p_i j) = 1\"\n  assumes p_i_C: \"\\<And>j. j \\<in> C \\<Longrightarrow> p_i j = 0\"\nbegin"], ["", "abbreviation H :: \"'a set\" where\n  \"H \\<equiv> J - C\""], ["", "definition \"p_j = 1 / card J\""], ["", "lemma p_f_nonneg[simp]: \"0 \\<le> p_f\" \"p_f \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p_f &&& p_f \\<le> 1", "using p_f"], ["proof (prove)\nusing this:\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> p_f &&& p_f \\<le> 1", "by simp_all"], ["", "lemma p_j_nonneg[simp]: \"0 \\<le> p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p_j", "by (simp add: p_j_def)"], ["", "definition \"p_H = card H / card J\""], ["", "lemma p_H_nonneg[simp]: \"0 \\<le> p_H\" \"p_H \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p_H &&& p_H \\<le> 1", "by (auto simp: p_H_def divide_le_eq_1 card_gt_0_iff intro!: card_mono )"], ["", "definition next_prob :: \"'a state \\<Rightarrow> 'a state \\<Rightarrow> real\" where\n  \"next_prob s t = (case (s, t) of (Start, Init j) \\<Rightarrow> if j \\<in> H then p_i j else 0\n                                 | (Init j, Mix j') \\<Rightarrow> if j' \\<in> J then p_j else 0\n                                 | (Mix j, Mix j') \\<Rightarrow> if j' \\<in> J then p_f * p_j else 0\n                                 | (Mix j, End) \\<Rightarrow> 1 - p_f\n                                 | (End, End) \\<Rightarrow> 1\n                                 | _ \\<Rightarrow> 0)\""], ["", "definition \"N s = embed_pmf (next_prob s)\""], ["", "interpretation MC_syntax N"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation \"\\<PP> \\<equiv> T Start\""], ["", "abbreviation \"E s \\<equiv> set_pmf (N s)\""], ["", "lemma finite_C[simp]: \"finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C", "using C_smaller finite_J"], ["proof (prove)\nusing this:\n  C \\<subset> J\n  finite J\n\ngoal (1 subgoal):\n 1. finite C", "by (blast intro: finite_subset)"], ["", "lemma sum_p_i_C[simp]: \"sum p_i C = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p_i C = 0", "by (auto intro: sum.neutral p_i_C)"], ["", "lemma sum_p_i_H[simp]: \"sum p_i H = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum p_i H = 1", "using C_smaller"], ["proof (prove)\nusing this:\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. sum p_i H = 1", "by (simp add: sum_diff p_i_distr)"], ["", "lemma possible_jondo:\n  obtains j where \"j \\<in> J\" \"j \\<notin> C\" \"p_i j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> J; j \\<notin> C; p_i j \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (atomize_elim, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>j.\n       j \\<in> J \\<and>\n       j \\<notin> C \\<and> p_i j \\<noteq> 0 \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>j. j \\<in> J \\<and> j \\<notin> C \\<and> p_i j \\<noteq> 0)\""], ["proof (state)\nthis:\n  \\<nexists>j. j \\<in> J \\<and> j \\<notin> C \\<and> p_i j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>j.\n       j \\<in> J \\<and>\n       j \\<notin> C \\<and> p_i j \\<noteq> 0 \\<Longrightarrow>\n    False", "with p_i_C"], ["proof (chain)\npicking this:\n  ?j \\<in> C \\<Longrightarrow> p_i ?j = 0\n  \\<nexists>j. j \\<in> J \\<and> j \\<notin> C \\<and> p_i j \\<noteq> 0", "have \"\\<forall>j\\<in>J. p_i j = 0\""], ["proof (prove)\nusing this:\n  ?j \\<in> C \\<Longrightarrow> p_i ?j = 0\n  \\<nexists>j. j \\<in> J \\<and> j \\<notin> C \\<and> p_i j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<in>J. p_i j = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<in>J. p_i j = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>j.\n       j \\<in> J \\<and>\n       j \\<notin> C \\<and> p_i j \\<noteq> 0 \\<Longrightarrow>\n    False", "with p_i_distr"], ["proof (chain)\npicking this:\n  sum p_i J = 1\n  \\<forall>j\\<in>J. p_i j = 0", "show False"], ["proof (prove)\nusing this:\n  sum p_i J = 1\n  \\<forall>j\\<in>J. p_i j = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_le_J[simp]: \"card C < card J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card C < card J", "using C_smaller"], ["proof (prove)\nusing this:\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. card C < card J", "by (intro psubset_card_mono) auto"], ["", "lemma p_H: \"0 < p_H\" \"p_H < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p_H &&& p_H < 1", "using J_not_empty C_smaller C_non_empty"], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n  C \\<subset> J\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < p_H &&& p_H < 1", "by (simp_all add: p_H_def card_Diff_subset card_mono field_simps zero_less_divide_iff card_gt_0_iff)"], ["", "lemma p_H_p_f_pos: \"0 < p_H * p_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p_H * p_f", "using p_f p_H"], ["proof (prove)\nusing this:\n  0 < p_f\n  p_f < 1\n  0 < p_H\n  p_H < 1\n\ngoal (1 subgoal):\n 1. 0 < p_H * p_f", "by (simp add: zero_less_mult_iff)"], ["", "lemma p_H_p_f_less_1: \"p_H * p_f < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_H * p_f < 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p_H * p_f < 1", "have \"p_H * p_f < 1 * 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_H * p_f < 1 * 1", "using p_H p_f"], ["proof (prove)\nusing this:\n  0 < p_H\n  p_H < 1\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. p_H * p_f < 1 * 1", "by (intro mult_strict_mono) auto"], ["proof (state)\nthis:\n  p_H * p_f < 1 * 1\n\ngoal (1 subgoal):\n 1. p_H * p_f < 1", "then"], ["proof (chain)\npicking this:\n  p_H * p_f < 1 * 1", "show \"p_H * p_f < 1\""], ["proof (prove)\nusing this:\n  p_H * p_f < 1 * 1\n\ngoal (1 subgoal):\n 1. p_H * p_f < 1", "by simp"], ["proof (state)\nthis:\n  p_H * p_f < 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_j_pos: \"0 < p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p_j", "unfolding p_j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 / real (card J)", "using J_not_empty"], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < 1 / real (card J)", "by auto"], ["", "lemma H_compl: \"1 - p_H = real (card C) / real (card J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - p_H = real (card C) / real (card J)", "using C_non_empty J_not_empty C_smaller"], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n  J \\<noteq> {}\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. 1 - p_H = real (card C) / real (card J)", "by (simp add: p_H_def card_Diff_subset card_mono of_nat_diff divide_eq_eq field_simps)"], ["", "lemma H_compl2: \"1 - p_H = card C * p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - p_H = real (card C) * p_j", "unfolding H_compl p_j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card C) / real (card J) = real (card C) * (1 / real (card J))", "by simp"], ["", "lemma H_eq2: \"card H * p_j = p_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card H) * p_j = p_H", "unfolding p_j_def p_H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (card H) * (1 / real (card J)) = real (card H) / real (card J)", "by simp"], ["", "lemma pmf_next_pmf[simp]: \"pmf (N s) t = next_prob s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (N s) t = next_prob s t", "unfolding N_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (embed_pmf (next_prob s)) t = next_prob s t", "proof (rule pmf_embed_pmf)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> next_prob s x\n 2. \\<integral>\\<^sup>+ x. ennreal (next_prob s x)\n                       \\<partial>count_space UNIV =\n    1", "show \"\\<And>x. 0 \\<le> next_prob s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> next_prob s x", "using p_j_pos p_f"], ["proof (prove)\nusing this:\n  0 < p_j\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 \\<le> next_prob s x", "by (auto simp: next_prob_def intro: p_i_nonneg split: state.split)"], ["proof (state)\nthis:\n  0 \\<le> next_prob s ?x1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (next_prob s x)\n                       \\<partial>count_space UNIV =\n    1", "show \"(\\<integral>\\<^sup>+ x. ennreal (next_prob s x) \\<partial>count_space UNIV) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (next_prob s x)\n                       \\<partial>count_space UNIV =\n    1", "using p_f J_not_empty"], ["proof (prove)\nusing this:\n  0 < p_f\n  p_f < 1\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (next_prob s x)\n                       \\<partial>count_space UNIV =\n    1", "by (subst nn_integral_count_space'[where A=\"Init`H \\<union> Mix`J \\<union> {End}\"])\n       (auto simp: next_prob_def sum.reindex sum.union_disjoint p_i_distr p_j_def\n             split: state.split)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (next_prob s x)\n                     \\<partial>count_space UNIV =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma next_prob_Start[simp]: \"next_prob Start (Init j) = (if j \\<in> H then p_i j else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_prob Start (Init j) = (if j \\<in> H then p_i j else 0)", "by (auto simp: next_prob_def)"], ["", "lemma next_prob_to_Init[simp]: \"j \\<in> H \\<Longrightarrow> next_prob s (Init j) =\n    (case s of Start \\<Rightarrow> p_i j | _ \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> H \\<Longrightarrow>\n    next_prob s (Init j) =\n    (case s of Start \\<Rightarrow> p_i j | _ \\<Rightarrow> 0)", "by (cases s) (auto simp: next_prob_def)"], ["", "lemma next_prob_to_Mix[simp]: \"j \\<in> J \\<Longrightarrow> next_prob s (Mix j) =\n    (case s of Init j \\<Rightarrow> p_j | Mix j \\<Rightarrow> p_f * p_j | _ \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> J \\<Longrightarrow>\n    next_prob s (Mix j) =\n    (case s of Init j \\<Rightarrow> p_j | Mix j \\<Rightarrow> p_f * p_j\n     | _ \\<Rightarrow> 0)", "by (cases s) (auto simp: next_prob_def)"], ["", "lemma next_prob_to_End[simp]: \"next_prob s End =\n    (case s of Mix j \\<Rightarrow> 1 - p_f | End \\<Rightarrow> 1 | _ \\<Rightarrow> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_prob s End =\n    (case s of Mix j \\<Rightarrow> 1 - p_f | End \\<Rightarrow> 1\n     | _ \\<Rightarrow> 0)", "by (cases s) (auto simp: next_prob_def)"], ["", "lemma next_prob_from_End[simp]: \"next_prob End s = 0 \\<longleftrightarrow> s \\<noteq> End\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (next_prob End s = 0) = (s \\<noteq> End)", "by (cases s) (auto simp: next_prob_def)"], ["", "lemma next_prob_Mix_MixI: \"\\<exists>j. s = Mix j \\<Longrightarrow> \\<exists>j\\<in>J. s' = Mix j \\<Longrightarrow> next_prob s s' = p_f * p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>j. s = Mix j; \\<exists>j\\<in>J. s' = Mix j\\<rbrakk>\n    \\<Longrightarrow> next_prob s s' = p_f * p_j", "by (cases s) auto"], ["", "lemma E_Start: \"E Start = {Init j | j. j \\<in> H \\<and> p_i j \\<noteq> 0 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E Start = {Init j |j. j \\<in> H \\<and> p_i j \\<noteq> 0}", "using p_i_C"], ["proof (prove)\nusing this:\n  ?j \\<in> C \\<Longrightarrow> p_i ?j = 0\n\ngoal (1 subgoal):\n 1. E Start = {Init j |j. j \\<in> H \\<and> p_i j \\<noteq> 0}", "by (auto simp: set_pmf_iff next_prob_def split: state.splits if_split_asm)"], ["", "lemma E_Init: \"E (Init j) = {Mix j | j. j \\<in> J }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (Init j) = {Mix j |j. j \\<in> J}", "using p_j_pos C_smaller"], ["proof (prove)\nusing this:\n  0 < p_j\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. E (Init j) = {Mix j |j. j \\<in> J}", "by (auto simp: set_pmf_iff next_prob_def split: state.splits if_split_asm)"], ["", "lemma E_Mix: \"E (Mix j) = {Mix j | j. j \\<in> J } \\<union> {End}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E (Mix j) = {Mix j |j. j \\<in> J} \\<union> {End}", "using p_j_pos p_f"], ["proof (prove)\nusing this:\n  0 < p_j\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. E (Mix j) = {Mix j |j. j \\<in> J} \\<union> {End}", "by (auto simp: set_pmf_iff next_prob_def split: state.splits if_split_asm)"], ["", "lemma E_End: \"E End = {End}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E End = {End}", "by (auto simp: set_pmf_iff next_prob_def split: state.splits if_split_asm)"], ["", "lemma enabled_End:\n  \"enabled End \\<omega> \\<longleftrightarrow> \\<omega> = sconst End\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled End \\<omega> = (\\<omega> = sconst End)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. enabled End \\<omega> \\<Longrightarrow> \\<omega> = sconst End\n 2. \\<omega> = sconst End \\<Longrightarrow> enabled End (sconst End)", "assume \"enabled End \\<omega>\""], ["proof (state)\nthis:\n  enabled End \\<omega>\n\ngoal (2 subgoals):\n 1. enabled End \\<omega> \\<Longrightarrow> \\<omega> = sconst End\n 2. \\<omega> = sconst End \\<Longrightarrow> enabled End (sconst End)", "then"], ["proof (chain)\npicking this:\n  enabled End \\<omega>", "show \"\\<omega> = sconst End\""], ["proof (prove)\nusing this:\n  enabled End \\<omega>\n\ngoal (1 subgoal):\n 1. \\<omega> = sconst End", "proof (coinduction arbitrary: \\<omega>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled End \\<omega> \\<Longrightarrow>\n       shd \\<omega> = shd (sconst End) \\<and>\n       (\\<exists>\\<omega>'.\n           stl \\<omega> = \\<omega>' \\<and>\n           stl (sconst End) = sconst End \\<and> enabled End \\<omega>')", "case Eq_stream"], ["proof (state)\nthis:\n  enabled End \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled End \\<omega> \\<Longrightarrow>\n       shd \\<omega> = shd (sconst End) \\<and>\n       (\\<exists>\\<omega>'.\n           stl \\<omega> = \\<omega>' \\<and>\n           stl (sconst End) = sconst End \\<and> enabled End \\<omega>')", "then"], ["proof (chain)\npicking this:\n  enabled End \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  enabled End \\<omega>\n\ngoal (1 subgoal):\n 1. shd \\<omega> = shd (sconst End) \\<and>\n    (\\<exists>\\<omega>.\n        stl \\<omega> = \\<omega> \\<and>\n        stl (sconst End) = sconst End \\<and> enabled End \\<omega>)", "by (auto simp: enabled.simps[of _ \\<omega>] E_End)"], ["proof (state)\nthis:\n  shd \\<omega> = shd (sconst End) \\<and>\n  (\\<exists>\\<omega>.\n      stl \\<omega> = \\<omega> \\<and>\n      stl (sconst End) = sconst End \\<and> enabled End \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<omega> = sconst End\n\ngoal (1 subgoal):\n 1. \\<omega> = sconst End \\<Longrightarrow> enabled End (sconst End)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<omega> = sconst End \\<Longrightarrow> enabled End (sconst End)", "show \"enabled End (sconst End)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled End (sconst End)", "by coinduction (simp add: E_End)"], ["proof (state)\nthis:\n  enabled End (sconst End)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma AE_End: \"(AE \\<omega> in T End. P \\<omega>) \\<longleftrightarrow> P (sconst End)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "have \"(AE \\<omega> in T End. P \\<omega>) \\<longleftrightarrow> (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P =\n    (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End)", "using AE_T_enabled[of End]"], ["proof (prove)\nusing this:\n  almost_everywhere (T End) (enabled End)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P =\n    (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End)", "by (simp add: enabled_End)"], ["proof (state)\nthis:\n  almost_everywhere (T End) P =\n  (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "also"], ["proof (state)\nthis:\n  almost_everywhere (T End) P =\n  (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "have \"\\<dots> = (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End) =\n    (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End)", "by (simp add: enabled_End del: AE_conj_iff cong: rev_conj_cong)"], ["proof (state)\nthis:\n  (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End) =\n  (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "also"], ["proof (state)\nthis:\n  (AE \\<omega> in T End. P \\<omega> \\<and> \\<omega> = sconst End) =\n  (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End)\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "have \"\\<dots> = (AE \\<omega> in T End. P (sconst End))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End) =\n    (AE \\<omega> in T End. P (sconst End))", "using AE_T_enabled[of End]"], ["proof (prove)\nusing this:\n  almost_everywhere (T End) (enabled End)\n\ngoal (1 subgoal):\n 1. (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End) =\n    (AE \\<omega> in T End. P (sconst End))", "by (simp add: enabled_End)"], ["proof (state)\nthis:\n  (AE \\<omega> in T End. P (sconst End) \\<and> \\<omega> = sconst End) =\n  (AE \\<omega> in T End. P (sconst End))\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "finally"], ["proof (chain)\npicking this:\n  almost_everywhere (T End) P = (AE \\<omega> in T End. P (sconst End))", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_everywhere (T End) P = (AE \\<omega> in T End. P (sconst End))\n\ngoal (1 subgoal):\n 1. almost_everywhere (T End) P = P (sconst End)", "by simp"], ["proof (state)\nthis:\n  almost_everywhere (T End) P = P (sconst End)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emeasure_Init_eq_Mix:\n  assumes [measurable]: \"Measurable.pred S P\"\n  assumes AE_End: \"AE x in T End. \\<not> P (End ## x)\"\n  shows \"emeasure (T (Init j)) {x\\<in>space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x\\<in>space (T (Mix j)). P x} / p_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (Init j)) {x \\<in> space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x \\<in> space (T (Mix j)). P x} / ennreal p_f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (T (Init j)) {x \\<in> space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x \\<in> space (T (Mix j)). P x} / ennreal p_f", "have *: \"{Mix j | j. j \\<in> J } = Mix ` J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Mix j |j. j \\<in> J} = Mix ` J", "by auto"], ["proof (state)\nthis:\n  {Mix j |j. j \\<in> J} = Mix ` J\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j)) {x \\<in> space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x \\<in> space (T (Mix j)). P x} / ennreal p_f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (Init j)) {x \\<in> space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x \\<in> space (T (Mix j)). P x} / ennreal p_f", "using emeasure_eq_0_AE[OF AE_End] p_f"], ["proof (prove)\nusing this:\n  emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j)) {x \\<in> space (T (Init j)). P x} =\n    emeasure (T (Mix j)) {x \\<in> space (T (Mix j)). P x} / ennreal p_f", "apply (subst (1 2) emeasure_Collect_T)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n     0 < p_f; p_f < 1\\<rbrakk>\n    \\<Longrightarrow> Measurable.pred (stream_space (count_space UNIV)) P\n 2. \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n     0 < p_f; p_f < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ t.\n     emeasure (T t) {x \\<in> space (T t). P (t ## x)}\n   \\<partial>measure_pmf (N (Init j)) =\n                      \\<integral>\\<^sup>+ t.\n     emeasure (T t) {x \\<in> space (T t). P (t ## x)}\n   \\<partial>measure_pmf (N (Mix j)) /\n                      ennreal p_f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n     0 < p_f; p_f < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ t.\n     emeasure (T t) {x \\<in> space (T t). P (t ## x)}\n   \\<partial>measure_pmf (N (Init j)) =\n                      \\<integral>\\<^sup>+ t.\n     emeasure (T t) {x \\<in> space (T t). P (t ## x)}\n   \\<partial>measure_pmf (N (Mix j)) /\n                      ennreal p_f", "apply (subst (1 2) nn_integral_measure_pmf_finite)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n     0 < p_f; p_f < 1\\<rbrakk>\n    \\<Longrightarrow> finite (E (Mix j))\n 2. \\<And>x.\n       \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n        0 < p_f; p_f < 1; x \\<in> E (Mix j)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> emeasure (T x)\n                                  {xa \\<in> space (T x). P (x ## xa)}\n 3. \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n     0 < p_f; p_f < 1\\<rbrakk>\n    \\<Longrightarrow> finite (E (Init j))\n 4. \\<And>x.\n       \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n        0 < p_f; p_f < 1; x \\<in> E (Init j)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> emeasure (T x)\n                                  {xa \\<in> space (T x). P (x ## xa)}\n 5. \\<lbrakk>emeasure (T End) {x \\<in> space (T End). P (End ## x)} = 0;\n     0 < p_f; p_f < 1\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>E (Init j).\n                         emeasure (T x)\n                          {xa \\<in> space (T x). P (x ## xa)} *\n                         ennreal (pmf (N (Init j)) x)) =\n                      (\\<Sum>x\\<in>E (Mix j).\n                         emeasure (T x)\n                          {xa \\<in> space (T x). P (x ## xa)} *\n                         ennreal (pmf (N (Mix j)) x)) /\n                      ennreal p_f", "apply (auto simp: E_Mix E_Init * sum.reindex sum_distrib_right[symmetric] divide_ennreal\n      ennreal_times_divide[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (T (Init j)) {x \\<in> space (T (Init j)). P x} =\n  emeasure (T (Mix j)) {x \\<in> space (T (Mix j)). P x} / ennreal p_f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\nWhat is the probability that the server sees a specific jondo (including the initiator) as sender.\n\n\\<close>"], ["", "definition visit :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a state stream \\<Rightarrow> bool\" where\n  \"visit I L = Init`(I \\<inter> H) \\<cdot> (HLD (Mix`J) suntil (Mix`(L \\<inter> J) \\<cdot> HLD {End}))\""], ["", "lemma visit_unique1:\n  \"visit I1 L1 \\<omega> \\<Longrightarrow> visit I2 L2 \\<omega> \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>visit I1 L1 \\<omega>; visit I2 L2 \\<omega>\\<rbrakk>\n    \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}", "by (auto simp: visit_def HLD_iff)"], ["", "lemma visit_unique2:\n  assumes \"visit I1 L1 \\<omega>\" \"visit I2 L2 \\<omega>\"\n  shows \"L1 \\<inter> L2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "let ?U = \"\\<lambda>L \\<omega>. (HLD (Mix`J) suntil ((Mix`(L\\<inter>J)) \\<cdot> HLD {End})) \\<omega>\""], ["proof (state)\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "have \"?U L1 (stl \\<omega>)\" \"?U L2 (stl \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HLD (Mix ` J) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n     (stl \\<omega>) &&&\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n     (stl \\<omega>)", "using assms"], ["proof (prove)\nusing this:\n  visit I1 L1 \\<omega>\n  visit I2 L2 \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` J) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n     (stl \\<omega>) &&&\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n     (stl \\<omega>)", "by (auto simp: visit_def)"], ["proof (state)\nthis:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)", "show \"L1 \\<inter> L2 \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "proof (induction \"stl \\<omega>\" arbitrary: \\<omega> rule: suntil_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>);\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` J) (stl \\<omega>);\n        \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>));\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl (stl \\<omega>));\n        \\<And>\\<omega>'.\n           \\<lbrakk>stl (stl \\<omega>) = stl \\<omega>';\n            (HLD (Mix ` J) suntil\n             (\\<lambda>xs.\n                 HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n             (stl \\<omega>')\\<rbrakk>\n           \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {};\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "case base"], ["proof (state)\nthis:\n  HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n  nxt (HLD {End}) (stl \\<omega>)\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>);\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` J) (stl \\<omega>);\n        \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>));\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl (stl \\<omega>));\n        \\<And>\\<omega>'.\n           \\<lbrakk>stl (stl \\<omega>) = stl \\<omega>';\n            (HLD (Mix ` J) suntil\n             (\\<lambda>xs.\n                 HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n             (stl \\<omega>')\\<rbrakk>\n           \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {};\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n  nxt (HLD {End}) (stl \\<omega>)\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n  nxt (HLD {End}) (stl \\<omega>)\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "by (auto simp add: suntil.simps[of _ _ \"stl (stl \\<omega>)\"] suntil.simps[of _ _ \"stl \\<omega>\"] HLD_iff)"], ["proof (state)\nthis:\n  L1 \\<inter> L2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` J) (stl \\<omega>);\n        \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>));\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl (stl \\<omega>));\n        \\<And>\\<omega>'.\n           \\<lbrakk>stl (stl \\<omega>) = stl \\<omega>';\n            (HLD (Mix ` J) suntil\n             (\\<lambda>xs.\n                 HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n             (stl \\<omega>')\\<rbrakk>\n           \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {};\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` J) (stl \\<omega>);\n        \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>));\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl (stl \\<omega>));\n        \\<And>\\<omega>'.\n           \\<lbrakk>stl (stl \\<omega>) = stl \\<omega>';\n            (HLD (Mix ` J) suntil\n             (\\<lambda>xs.\n                 HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n             (stl \\<omega>')\\<rbrakk>\n           \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {};\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "case step"], ["proof (state)\nthis:\n  HLD (Mix ` J) (stl \\<omega>)\n  \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n          nxt (HLD {End}) (stl \\<omega>))\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl (stl \\<omega>))\n  \\<lbrakk>stl (stl \\<omega>) = stl ?\\<omega>1;\n   (HLD (Mix ` J) suntil\n    (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n    (stl ?\\<omega>1)\\<rbrakk>\n  \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Mix ` J) (stl \\<omega>);\n        \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n                nxt (HLD {End}) (stl \\<omega>));\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl (stl \\<omega>));\n        \\<And>\\<omega>'.\n           \\<lbrakk>stl (stl \\<omega>) = stl \\<omega>';\n            (HLD (Mix ` J) suntil\n             (\\<lambda>xs.\n                 HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n             (stl \\<omega>')\\<rbrakk>\n           \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {};\n        (HLD (Mix ` J) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n         (stl \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "assume \"((Mix`(L2\\<inter>J)) \\<cdot> HLD {End}) (stl \\<omega>)\""], ["proof (state)\nthis:\n  HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n  nxt (HLD {End}) (stl \\<omega>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n 2. \\<not> ?P \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}", "with step.hyps"], ["proof (chain)\npicking this:\n  HLD (Mix ` J) (stl \\<omega>)\n  \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n          nxt (HLD {End}) (stl \\<omega>))\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl (stl \\<omega>))\n  \\<lbrakk>stl (stl \\<omega>) = stl ?\\<omega>1;\n   (HLD (Mix ` J) suntil\n    (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n    (stl ?\\<omega>1)\\<rbrakk>\n  \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n  HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n  nxt (HLD {End}) (stl \\<omega>)", "show ?thesis"], ["proof (prove)\nusing this:\n  HLD (Mix ` J) (stl \\<omega>)\n  \\<not> (HLD (Mix ` (L1 \\<inter> J)) (stl \\<omega>) \\<and>\n          nxt (HLD {End}) (stl \\<omega>))\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L1 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl (stl \\<omega>))\n  \\<lbrakk>stl (stl \\<omega>) = stl ?\\<omega>1;\n   (HLD (Mix ` J) suntil\n    (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n    (stl ?\\<omega>1)\\<rbrakk>\n  \\<Longrightarrow> L1 \\<inter> L2 \\<noteq> {}\n  HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n  nxt (HLD {End}) (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "by (auto simp: inj_Mix HLD_iff elim: suntil.cases)"], ["proof (state)\nthis:\n  L1 \\<inter> L2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n            nxt (HLD {End}) (stl \\<omega>)) \\<Longrightarrow>\n    L1 \\<inter> L2 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n            nxt (HLD {End}) (stl \\<omega>)) \\<Longrightarrow>\n    L1 \\<inter> L2 \\<noteq> {}", "assume \"\\<not> ((Mix`(L2\\<inter>J)) \\<cdot> HLD {End}) (stl \\<omega>)\""], ["proof (state)\nthis:\n  \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n          nxt (HLD {End}) (stl \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n            nxt (HLD {End}) (stl \\<omega>)) \\<Longrightarrow>\n    L1 \\<inter> L2 \\<noteq> {}", "with step.prems"], ["proof (chain)\npicking this:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n  \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n          nxt (HLD {End}) (stl \\<omega>))", "have \"?U L2 (stl (stl \\<omega>))\""], ["proof (prove)\nusing this:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl \\<omega>)\n  \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n          nxt (HLD {End}) (stl \\<omega>))\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` J) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n     (stl (stl \\<omega>))", "by (auto elim: suntil.cases)"], ["proof (state)\nthis:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl (stl \\<omega>))\n\ngoal (1 subgoal):\n 1. \\<not> (HLD (Mix ` (L2 \\<inter> J)) (stl \\<omega>) \\<and>\n            nxt (HLD {End}) (stl \\<omega>)) \\<Longrightarrow>\n    L1 \\<inter> L2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl (stl \\<omega>))", "show ?thesis"], ["proof (prove)\nusing this:\n  (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` (L2 \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n   (stl (stl \\<omega>))\n\ngoal (1 subgoal):\n 1. L1 \\<inter> L2 \\<noteq> {}", "by (rule step.hyps(4)[OF refl])"], ["proof (state)\nthis:\n  L1 \\<inter> L2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L1 \\<inter> L2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  L1 \\<inter> L2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma visit_imp_in_H: \"visit {i} J \\<omega> \\<Longrightarrow> i \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visit {i} J \\<omega> \\<Longrightarrow> i \\<in> H", "by (auto simp: visit_def HLD_iff)"], ["", "lemma emeasure_visit:\n  assumes I: \"I \\<subseteq> H\" and L: \"L \\<subseteq> J\"\n  shows \"emeasure \\<PP> {\\<omega>\\<in>space \\<PP>. visit I L \\<omega>} = (\\<Sum>i\\<in>I. p_i i) * (card L * p_j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "let ?J = \"HLD (Mix`J)\" and ?E = \"(Mix`L) \\<cdot> HLD {End}\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "let ?\\<phi> = \"?J aand not ?E\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "let ?P = \"\\<lambda>x P. emeasure (T x) {\\<omega>\\<in>space (T x). P \\<omega>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "have [intro]: \"finite L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite L", "using finite_J \\<open>L \\<subseteq> J\\<close>"], ["proof (prove)\nusing this:\n  finite J\n  L \\<subseteq> J\n\ngoal (1 subgoal):\n 1. finite L", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite L\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "have [simp, intro]: \"finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I", "using finite_J \\<open>I \\<subseteq> H\\<close>"], ["proof (prove)\nusing this:\n  finite J\n  I \\<subseteq> H\n\ngoal (1 subgoal):\n 1. finite I", "by (blast intro: finite_subset)"], ["proof (state)\nthis:\n  finite I\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "{"], ["proof (state)\nthis:\n  finite I\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "assume j: \"j \\<in> H\""], ["proof (state)\nthis:\n  j \\<in> H\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "have \"?P (Mix j) (?J suntil ?E) = (p_f * p_j * (1 - p_f) * card L) / (1 - p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (Mix j))\n     {\\<omega> \\<in> space (T (Mix j)).\n      (HLD (Mix ` J) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n       \\<omega>} =\n    ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f))", "proof (rule emeasure_suntil_geometric)"], ["proof (state)\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "fix s"], ["proof (state)\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "assume s: \"s \\<in> Mix ` J\""], ["proof (state)\nthis:\n  s \\<in> Mix ` J\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "then"], ["proof (chain)\npicking this:\n  s \\<in> Mix ` J", "have \"?P s ?E = (\\<integral>\\<^sup>+x. ennreal (1 - p_f) * indicator (Mix`L) x \\<partial>N s)\""], ["proof (prove)\nusing this:\n  s \\<in> Mix ` J\n\ngoal (1 subgoal):\n 1. emeasure (T s)\n     {\\<omega> \\<in> space (T s).\n      HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n    \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n    \\<partial>measure_pmf (N s)", "by (auto simp add: emeasure_HLD_nxt emeasure_HLD AE_measure_pmf_iff emeasure_pmf_single\n                 split: state.split split_indicator simp del: space_T nxt.simps\n                 intro!: nn_integral_cong_AE)"], ["proof (state)\nthis:\n  emeasure (T s)\n   {\\<omega> \\<in> space (T s).\n    HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n  \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n  \\<partial>measure_pmf (N s)\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "also"], ["proof (state)\nthis:\n  emeasure (T s)\n   {\\<omega> \\<in> space (T s).\n    HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n  \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n  \\<partial>measure_pmf (N s)\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "have \"\\<dots> = ennreal (1 - p_f) * emeasure (N s) (Mix`L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n    \\<partial>measure_pmf (N s) =\n    ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L)", "using p_f"], ["proof (prove)\nusing this:\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n    \\<partial>measure_pmf (N s) =\n    ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L)", "by (intro nn_integral_cmult_indicator) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n  \\<partial>measure_pmf (N s) =\n  ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L)\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Mix ` L. ennreal (1 - p_f)\n  \\<partial>measure_pmf (N s) =\n  ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L)\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "have \"\\<dots> = ennreal ((1 - p_f) * card L * p_j * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L) =\n    ennreal ((1 - p_f) * real (card L) * p_j * p_f)", "using s assms"], ["proof (prove)\nusing this:\n  s \\<in> Mix ` J\n  I \\<subseteq> H\n  L \\<subseteq> J\n\ngoal (1 subgoal):\n 1. ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L) =\n    ennreal ((1 - p_f) * real (card L) * p_j * p_f)", "by (subst emeasure_measure_pmf_finite)\n           (auto simp: sum.reindex subset_eq ennreal_mult mult_ac)"], ["proof (state)\nthis:\n  ennreal (1 - p_f) * emeasure (measure_pmf (N s)) (Mix ` L) =\n  ennreal ((1 - p_f) * real (card L) * p_j * p_f)\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n       ennreal (p_f * p_j * (1 - p_f) * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 7. p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "finally"], ["proof (chain)\npicking this:\n  emeasure (T s)\n   {\\<omega> \\<in> space (T s).\n    HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n  ennreal ((1 - p_f) * real (card L) * p_j * p_f)", "show \"?P s ?E = p_f * p_j * (1 - p_f) * card L\""], ["proof (prove)\nusing this:\n  emeasure (T s)\n   {\\<omega> \\<in> space (T s).\n    HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n  ennreal ((1 - p_f) * real (card L) * p_j * p_f)\n\ngoal (1 subgoal):\n 1. emeasure (T s)\n     {\\<omega> \\<in> space (T s).\n      HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n    ennreal (p_f * p_j * (1 - p_f) * real (card L))", "by simp"], ["proof (state)\nthis:\n  emeasure (T s)\n   {\\<omega> \\<in> space (T s).\n    HLD (Mix ` L) \\<omega> \\<and> nxt (HLD {End}) \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L))\n\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 6. p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 6. p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "show \"\\<And>t. AE \\<omega> in T  t. \\<not> (?E \\<sqinter> (?J \\<sqinter> nxt (?J suntil ?E))) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs) \\<sqinter>\n                                   (HLD (Mix ` J) \\<sqinter>\n                                    nxt (HLD (Mix ` J) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                   \\<omega>", "by (intro AE_I2) (auto simp: HLD_iff elim: suntil.cases)"], ["proof (state)\nthis:\n  AE \\<omega> in T ?t1. \\<not> ((\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD {End}) xs) \\<sqinter>\n                                (HLD (Mix ` J) \\<sqinter>\n                                 nxt (HLD (Mix ` J) suntil\n(\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))))\n                                \\<omega>\n\ngoal (6 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs)\n 2. Mix j \\<in> Mix ` J\n 3. 0 \\<le> p_f\n 4. 0 \\<le> p_f * p_j * (1 - p_f) * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` J \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` J) = ennreal p_f\n 6. p_f < 1", "qed (insert p_f j, auto simp: emeasure_measure_pmf_finite sum.reindex p_j_def)"], ["proof (state)\nthis:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f))\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "then"], ["proof (chain)\npicking this:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f))", "have \"?P (Init j) (?J suntil ?E) = (p_f * p_j * (1 - p_f) * card L) / (1 - p_f) / p_f\""], ["proof (prove)\nusing this:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f))\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j))\n     {\\<omega> \\<in> space (T (Init j)).\n      (HLD (Mix ` J) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n       \\<omega>} =\n    ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f) / p_f)", "by (subst emeasure_Init_eq_Mix) (simp_all add:  suntil.simps[of _ _ \"x ## s\" for x s] divide_ennreal p_f)"], ["proof (state)\nthis:\n  emeasure (T (Init j))\n   {\\<omega> \\<in> space (T (Init j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f) / p_f)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "then"], ["proof (chain)\npicking this:\n  emeasure (T (Init j))\n   {\\<omega> \\<in> space (T (Init j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f) / p_f)", "have \"?P (Init j) (?J suntil ?E) = p_j * card L\""], ["proof (prove)\nusing this:\n  emeasure (T (Init j))\n   {\\<omega> \\<in> space (T (Init j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f) / p_f)\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j))\n     {\\<omega> \\<in> space (T (Init j)).\n      (HLD (Mix ` J) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n       \\<omega>} =\n    ennreal (p_j * real (card L))", "using p_f"], ["proof (prove)\nusing this:\n  emeasure (T (Init j))\n   {\\<omega> \\<in> space (T (Init j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_f * p_j * (1 - p_f) * real (card L) / (1 - p_f) / p_f)\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j))\n     {\\<omega> \\<in> space (T (Init j)).\n      (HLD (Mix ` J) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n       \\<omega>} =\n    ennreal (p_j * real (card L))", "by simp"], ["proof (state)\nthis:\n  emeasure (T (Init j))\n   {\\<omega> \\<in> space (T (Init j)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_j * real (card L))\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "}"], ["proof (state)\nthis:\n  ?j3 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j3))\n   {\\<omega> \\<in> space (T (Init ?j3)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_j * real (card L))\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "note J_suntil_E = this"], ["proof (state)\nthis:\n  ?j3 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j3))\n   {\\<omega> \\<in> space (T (Init ?j3)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_j * real (card L))\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "have \"?P Start (visit I L) = (\\<integral>\\<^sup>+x. ?P x (?J suntil ?E) * indicator (Init`I) x \\<partial>N Start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    \\<integral>\\<^sup>+x\\<in>Init ` I.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         (HLD (Mix ` J) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                          \\<omega>}\n    \\<partial>measure_pmf (N Start)", "unfolding visit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` (I \\<inter> H)) \\<omega> \\<and>\n      nxt (HLD (Mix ` J) suntil\n           (\\<lambda>xs.\n               HLD (Mix ` (L \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n       \\<omega>} =\n    \\<integral>\\<^sup>+x\\<in>Init ` I.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         (HLD (Mix ` J) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                          \\<omega>}\n    \\<partial>measure_pmf (N Start)", "using I L"], ["proof (prove)\nusing this:\n  I \\<subseteq> H\n  L \\<subseteq> J\n\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` (I \\<inter> H)) \\<omega> \\<and>\n      nxt (HLD (Mix ` J) suntil\n           (\\<lambda>xs.\n               HLD (Mix ` (L \\<inter> J)) xs \\<and> nxt (HLD {End}) xs))\n       \\<omega>} =\n    \\<integral>\\<^sup>+x\\<in>Init ` I.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         (HLD (Mix ` J) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                          \\<omega>}\n    \\<partial>measure_pmf (N Start)", "by (subst emeasure_HLD_nxt) (auto simp: Int_absorb2)"], ["proof (state)\nthis:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n  \\<integral>\\<^sup>+x\\<in>Init ` I.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       (HLD (Mix ` J) suntil\n                        (\\<lambda>xs.\n                            HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                        \\<omega>}\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "also"], ["proof (state)\nthis:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n  \\<integral>\\<^sup>+x\\<in>Init ` I.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       (HLD (Mix ` J) suntil\n                        (\\<lambda>xs.\n                            HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                        \\<omega>}\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "have \"\\<dots> = (\\<integral>\\<^sup>+x. ennreal (p_j * card L) * indicator (Init`I) x \\<partial>N Start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` I.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         (HLD (Mix ` J) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                          \\<omega>}\n    \\<partial>measure_pmf (N Start) =\n    \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n    \\<partial>measure_pmf (N Start)", "using I J_suntil_E"], ["proof (prove)\nusing this:\n  I \\<subseteq> H\n  ?j3 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j3))\n   {\\<omega> \\<in> space (T (Init ?j3)).\n    (HLD (Mix ` J) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n     \\<omega>} =\n  ennreal (p_j * real (card L))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` I.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         (HLD (Mix ` J) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                          \\<omega>}\n    \\<partial>measure_pmf (N Start) =\n    \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n    \\<partial>measure_pmf (N Start)", "by (intro nn_integral_cong ennreal_mult_right_cong)\n       (auto split: split_indicator_asm)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Init ` I.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       (HLD (Mix ` J) suntil\n                        (\\<lambda>xs.\n                            HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                        \\<omega>}\n  \\<partial>measure_pmf (N Start) =\n  \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Init ` I.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       (HLD (Mix ` J) suntil\n                        (\\<lambda>xs.\n                            HLD (Mix ` L) xs \\<and> nxt (HLD {End}) xs))\n                        \\<omega>}\n  \\<partial>measure_pmf (N Start) =\n  \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "have \"\\<dots> = ennreal ((\\<Sum>i\\<in>I. p_i i) * card L * p_j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n    \\<partial>measure_pmf (N Start) =\n    ennreal (sum p_i I * real (card L) * p_j)", "using p_j_pos assms"], ["proof (prove)\nusing this:\n  0 < p_j\n  I \\<subseteq> H\n  L \\<subseteq> J\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n    \\<partial>measure_pmf (N Start) =\n    ennreal (sum p_i I * real (card L) * p_j)", "by (subst nn_integral_cmult_indicator)\n       (auto simp: emeasure_measure_pmf_finite sum.reindex subset_eq ennreal_mult[symmetric] sum_nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Init ` I. ennreal (p_j * real (card L))\n  \\<partial>measure_pmf (N Start) =\n  ennreal (sum p_i I * real (card L) * p_j)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "finally"], ["proof (chain)\npicking this:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n  ennreal (sum p_i I * real (card L) * p_j)", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n  ennreal (sum p_i I * real (card L) * p_j)\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n    ennreal (sum p_i I * (real (card L) * p_j))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n  ennreal (sum p_i I * (real (card L) * p_j))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurable_visit[measurable]: \"Measurable.pred S (visit I L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (visit I L)", "by (simp add: visit_def)"], ["", "lemma AE_visit: \"AE \\<omega> in \\<PP>. visit H J \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere \\<PP> (visit H J)", "proof (rule T.AE_I_eq_1)"], ["proof (state)\ngoal (2 subgoals):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit H J \\<omega>} = 1\n 2. {\\<omega> \\<in> space \\<PP>. visit H J \\<omega>} \\<in> T.events Start", "show \"emeasure \\<PP> {\\<omega>\\<in>space \\<PP>. visit H J \\<omega>} = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit H J \\<omega>} = 1", "using J_not_empty"], ["proof (prove)\nusing this:\n  J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit H J \\<omega>} = 1", "by (subst emeasure_visit ) (simp_all add: p_j_def)"], ["proof (state)\nthis:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit H J \\<omega>} = 1\n\ngoal (1 subgoal):\n 1. {\\<omega> \\<in> space \\<PP>. visit H J \\<omega>} \\<in> T.events Start", "qed simp"], ["", "subsection \\<open>Server gets no information\\<close>"], ["", "lemma server_view1: \"j \\<in> J \\<Longrightarrow> \\<P>(\\<omega> in \\<PP>. visit H {j} \\<omega>) = p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> J \\<Longrightarrow>\n    T.prob Start {\\<omega> \\<in> space \\<PP>. visit H {j} \\<omega>} = p_j", "unfolding measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> J \\<Longrightarrow>\n    enn2real\n     (emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. visit H {j} \\<omega>}) =\n    p_j", "by (subst emeasure_visit) simp_all"], ["", "lemma server_view_indep:\n  \"L \\<subseteq> J \\<Longrightarrow> I \\<subseteq> H \\<Longrightarrow> \\<P>(\\<omega> in \\<PP>. visit I L \\<omega>) = \\<P>(\\<omega> in \\<PP>. visit H L \\<omega>) * \\<P>(\\<omega> in \\<PP>. visit I J \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<subseteq> J; I \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> T.prob Start\n                       {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>} =\n                      T.prob Start\n                       {\\<omega> \\<in> space \\<PP>. visit H L \\<omega>} *\n                      T.prob Start\n                       {\\<omega> \\<in> space \\<PP>. visit I J \\<omega>}", "unfolding measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<subseteq> J; I \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> enn2real\n                       (emeasure \\<PP>\n                         {\\<omega> \\<in> space \\<PP>. visit I L \\<omega>}) =\n                      enn2real\n                       (emeasure \\<PP>\n                         {\\<omega> \\<in> space \\<PP>. visit H L \\<omega>}) *\n                      enn2real\n                       (emeasure \\<PP>\n                         {\\<omega> \\<in> space \\<PP>. visit I J \\<omega>})", "by (subst (1 2 3) emeasure_visit) (auto simp: p_j_def sum_nonneg subset_eq)"], ["", "lemma server_view: \"\\<P>(\\<omega> in \\<PP>. \\<exists>j\\<in>H. visit {j} {j} \\<omega>) = p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      \\<exists>j\\<in>H. visit {j} {j} \\<omega>} =\n    p_j", "using finite_J"], ["proof (prove)\nusing this:\n  finite J\n\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      \\<exists>j\\<in>H. visit {j} {j} \\<omega>} =\n    p_j", "proof (subst T.prob_sum[where I=\"H\" and P=\"\\<lambda>j. visit {j} {j}\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. finite J \\<Longrightarrow> finite H\n 2. \\<And>n.\n       \\<lbrakk>finite J; n \\<in> H\\<rbrakk>\n       \\<Longrightarrow> {x \\<in> space \\<PP>. visit {n} {n} x}\n                         \\<in> T.events Start\n 3. finite J \\<Longrightarrow>\n    {x \\<in> space \\<PP>. \\<exists>j\\<in>H. visit {j} {j} x}\n    \\<in> T.events Start\n 4. finite J \\<Longrightarrow>\n    AE x in \\<PP>. (\\<forall>n\\<in>H.\n                       visit {n} {n} x \\<longrightarrow>\n                       (\\<exists>j\\<in>H. visit {j} {j} x)) \\<and>\n                   ((\\<exists>j\\<in>H. visit {j} {j} x) \\<longrightarrow>\n                    (\\<exists>!n. n \\<in> H \\<and> visit {n} {n} x))\n 5. finite J \\<Longrightarrow>\n    (\\<Sum>n\\<in>H. T.prob Start {x \\<in> space \\<PP>. visit {n} {n} x}) =\n    p_j", "show \"(\\<Sum>j\\<in>H. \\<P>(\\<omega> in \\<PP>. visit {j} {j} \\<omega>)) = p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>H.\n       T.prob Start {\\<omega> \\<in> space \\<PP>. visit {j} {j} \\<omega>}) =\n    p_j", "by (auto simp: measure_def emeasure_visit sum_distrib_right[symmetric] simp del: space_T sets_T)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>H.\n     T.prob Start {\\<omega> \\<in> space \\<PP>. visit {j} {j} \\<omega>}) =\n  p_j\n\ngoal (4 subgoals):\n 1. finite J \\<Longrightarrow> finite H\n 2. \\<And>n.\n       \\<lbrakk>finite J; n \\<in> H\\<rbrakk>\n       \\<Longrightarrow> {x \\<in> space \\<PP>. visit {n} {n} x}\n                         \\<in> T.events Start\n 3. finite J \\<Longrightarrow>\n    {x \\<in> space \\<PP>. \\<exists>j\\<in>H. visit {j} {j} x}\n    \\<in> T.events Start\n 4. finite J \\<Longrightarrow>\n    AE x in \\<PP>. (\\<forall>n\\<in>H.\n                       visit {n} {n} x \\<longrightarrow>\n                       (\\<exists>j\\<in>H. visit {j} {j} x)) \\<and>\n                   ((\\<exists>j\\<in>H. visit {j} {j} x) \\<longrightarrow>\n                    (\\<exists>!n. n \\<in> H \\<and> visit {n} {n} x))", "show \"AE x in \\<PP>. (\\<forall>n\\<in>H. visit {n} {n} x \\<longrightarrow> (\\<exists>j\\<in>H. visit {j} {j} x)) \\<and>\n                ((\\<exists>j\\<in>H. visit {j} {j} x) \\<longrightarrow> (\\<exists>!n. n \\<in> H \\<and> visit {n} {n} x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in \\<PP>. (\\<forall>n\\<in>H.\n                       visit {n} {n} x \\<longrightarrow>\n                       (\\<exists>j\\<in>H. visit {j} {j} x)) \\<and>\n                   ((\\<exists>j\\<in>H. visit {j} {j} x) \\<longrightarrow>\n                    (\\<exists>!n. n \\<in> H \\<and> visit {n} {n} x))", "by (auto dest: visit_unique1)"], ["proof (state)\nthis:\n  AE x in \\<PP>. (\\<forall>n\\<in>H.\n                     visit {n} {n} x \\<longrightarrow>\n                     (\\<exists>j\\<in>H. visit {j} {j} x)) \\<and>\n                 ((\\<exists>j\\<in>H. visit {j} {j} x) \\<longrightarrow>\n                  (\\<exists>!n. n \\<in> H \\<and> visit {n} {n} x))\n\ngoal (3 subgoals):\n 1. finite J \\<Longrightarrow> finite H\n 2. \\<And>n.\n       \\<lbrakk>finite J; n \\<in> H\\<rbrakk>\n       \\<Longrightarrow> {x \\<in> space \\<PP>. visit {n} {n} x}\n                         \\<in> T.events Start\n 3. finite J \\<Longrightarrow>\n    {x \\<in> space \\<PP>. \\<exists>j\\<in>H. visit {j} {j} x}\n    \\<in> T.events Start", "qed simp_all"], ["", "subsection \\<open>Probability that collaborators gain information\\<close>"], ["", "definition \"hit_C = Init`H \\<cdot> ev (HLD (Mix`C))\""], ["", "definition \"before_C B = (HLD (Jondo H)) suntil ((Jondo (B \\<inter> H)) \\<cdot> HLD (Mix ` C))\""], ["", "lemma measurable_hit_C[measurable]: \"Measurable.pred S hit_C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) hit_C", "by (simp add: hit_C_def)"], ["", "lemma measurable_before_C[measurable]: \"Measurable.pred S (before_C B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Measurable.pred (stream_space (count_space UNIV)) (before_C B)", "by (simp add: before_C_def)"], ["", "lemma before_C:\n  assumes \\<omega>: \"enabled Start \\<omega>\"\n  shows \"before_C B \\<omega> \\<longleftrightarrow>\n    ((Init`H \\<cdot> (HLD (Mix`H) suntil (Mix`(B \\<inter> H) \\<cdot> HLD (Mix`C)))) or (Init`(B \\<inter> H) \\<cdot> HLD (Mix`C))) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "fix \\<omega> s"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "assume \"((HLD (Jondo H)) suntil (Jondo (B \\<inter> H) \\<cdot> HLD (Mix ` C))) \\<omega>\"\n      \"enabled s \\<omega>\" \"s \\<in> Jondo H\""], ["proof (state)\nthis:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H", "have \"(HLD (Mix ` H) suntil (Mix ` (B \\<inter> H) \\<cdot> (HLD (Mix ` C)))) \\<omega>\""], ["proof (prove)\nusing this:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` H) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>", "proof (induction arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>\n 2. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "case (base \\<omega>)"], ["proof (state)\nthis:\n  HLD (Jondo (B \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>\n 2. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "then"], ["proof (chain)\npicking this:\n  HLD (Jondo (B \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H", "show ?case"], ["proof (prove)\nusing this:\n  HLD (Jondo (B \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` H) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>", "by (auto simp: HLD_iff enabled.simps[of _ \\<omega>] E_Init E_Mix intro!: suntil.intros(1))"], ["proof (state)\nthis:\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "case (step \\<omega>)"], ["proof (state)\nthis:\n  HLD (Jondo H) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil\n                          (\\<lambda>xs.\n                              HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "from step.prems step.hyps step.IH[of \"shd \\<omega>\"]"], ["proof (chain)\npicking this:\n  enabled s \\<omega>\n  s \\<in> Jondo H\n  HLD (Jondo H) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  enabled s \\<omega>\n  s \\<in> Jondo H\n  HLD (Jondo H) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` H) suntil\n     (\\<lambda>xs.\n         HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>", "by (auto simp: HLD_iff enabled.simps[of _ \\<omega>] E_Init E_Mix\n                       suntil.simps[of _ _ \\<omega>] enabled_End suntil_sconst)"], ["proof (state)\nthis:\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            ?\\<omega>'3;\n   enabled ?s3 ?\\<omega>'3; ?s3 \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     ?\\<omega>'3\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "note this[of \"stl \\<omega>\" \"shd \\<omega>\"]"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "fix \\<omega> s"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "assume \"(HLD (Mix ` H) suntil (Mix ` (B \\<inter> H) \\<cdot> (HLD (Mix ` C)))) \\<omega>\"\n      \"enabled s \\<omega>\" \"s \\<in> Jondo H\""], ["proof (state)\nthis:\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H", "have \"((HLD (Jondo H)) suntil ((Jondo (B \\<inter> H)) \\<cdot> HLD (Mix ` C))) \\<omega>\""], ["proof (prove)\nusing this:\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (1 subgoal):\n 1. (HLD (Jondo H) suntil\n     (\\<lambda>xs.\n         HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>", "proof (induction arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Mix ` (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>\n 2. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Mix ` H) \\<omega>;\n        (HLD (Mix ` H) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Jondo H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Jondo (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "case (step \\<omega>)"], ["proof (state)\nthis:\n  HLD (Mix ` H) \\<omega>\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> Jondo H\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Mix ` (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>\n 2. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Mix ` H) \\<omega>;\n        (HLD (Mix ` H) suntil\n         (\\<lambda>xs.\n             HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>s.\n           \\<lbrakk>enabled s (stl \\<omega>); s \\<in> Jondo H\\<rbrakk>\n           \\<Longrightarrow> (HLD (Jondo H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Jondo (B \\<inter> H)) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (stl \\<omega>);\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "from step.prems step.hyps step.IH[of \"shd \\<omega>\"]"], ["proof (chain)\npicking this:\n  enabled s \\<omega>\n  s \\<in> Jondo H\n  HLD (Mix ` H) \\<omega>\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  enabled s \\<omega>\n  s \\<in> Jondo H\n  HLD (Mix ` H) \\<omega>\n  (HLD (Mix ` H) suntil\n   (\\<lambda>xs.\n       HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. (HLD (Jondo H) suntil\n     (\\<lambda>xs.\n         HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>", "by (auto simp: HLD_iff enabled.simps[of _ \\<omega>] E_Init E_Mix\n                       suntil.simps[of _ _ \\<omega>] enabled_End suntil_sconst)"], ["proof (state)\nthis:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> s.\n       \\<lbrakk>HLD (Mix ` (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        enabled s \\<omega>; s \\<in> Jondo H\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo (B \\<inter> H)) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          \\<omega>", "qed (auto intro: suntil.intros simp: HLD_iff)"], ["proof (state)\nthis:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            ?\\<omega>'3;\n   enabled ?s3 ?\\<omega>'3; ?s3 \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     ?\\<omega>'3\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "note this[of \"stl \\<omega>\" \"shd \\<omega>\"]"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  enabled Start \\<omega>\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "using \\<open>enabled Start \\<omega>\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  enabled Start \\<omega>\n  enabled Start \\<omega>\n\ngoal (1 subgoal):\n 1. before_C B \\<omega> =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "unfolding before_C_def suntil.simps[of _ _ \\<omega>] enabled.simps[of _ \\<omega>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil\n                     (\\<lambda>xs.\n                         HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  \\<lbrakk>(HLD (Mix ` H) suntil\n            (\\<lambda>xs.\n                HLD (Mix ` (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl \\<omega>);\n   enabled (shd \\<omega>) (stl \\<omega>);\n   shd \\<omega> \\<in> Jondo H\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo (B \\<inter> H)) xs \\<and>\n                         nxt (HLD (Mix ` C)) xs))\n                     (stl \\<omega>)\n  \\<exists>\\<omega>' s.\n     Start = s \\<and>\n     \\<omega> = \\<omega>' \\<and>\n     enabled (shd \\<omega>') (stl \\<omega>') \\<and> shd \\<omega>' \\<in> E s\n  \\<exists>\\<omega>' s.\n     Start = s \\<and>\n     \\<omega> = \\<omega>' \\<and>\n     enabled (shd \\<omega>') (stl \\<omega>') \\<and> shd \\<omega>' \\<in> E s\n\ngoal (1 subgoal):\n 1. ((\\<exists>\\<omega>'.\n         \\<omega> = \\<omega>' \\<and>\n         HLD (Jondo (B \\<inter> H)) \\<omega>' \\<and>\n         nxt (HLD (Mix ` C)) \\<omega>') \\<or>\n     (\\<exists>\\<omega>'.\n         \\<omega> = \\<omega>' \\<and>\n         HLD (Jondo H) \\<omega>' \\<and>\n         (HLD (Jondo H) suntil\n          (\\<lambda>xs.\n              HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          (stl \\<omega>'))) =\n    (HLD (Init ` H) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs.\n              HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (B \\<inter> H)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "by (auto simp: E_Start HLD_iff)"], ["proof (state)\nthis:\n  before_C B \\<omega> =\n  (HLD (Init ` H) \\<omega> \\<and>\n   nxt (HLD (Mix ` H) suntil\n        (\\<lambda>xs.\n            HLD (Mix ` (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n    \\<omega> \\<or>\n   HLD (Init ` (B \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma before_C_unique:\n  assumes \\<omega>: \"before_C I1 \\<omega>\" \"before_C I2 \\<omega>\" shows \"I1 \\<inter> I2 \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I1 \\<inter> I2 \\<noteq> {}", "using \\<omega>"], ["proof (prove)\nusing this:\n  before_C I1 \\<omega>\n  before_C I2 \\<omega>\n\ngoal (1 subgoal):\n 1. I1 \\<inter> I2 \\<noteq> {}", "unfolding before_C_def"], ["proof (prove)\nusing this:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. I1 \\<inter> I2 \\<noteq> {}", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo (I1 \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>) \\<Longrightarrow>\n        I1 \\<inter> I2 \\<noteq> {};\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}", "case (base \\<omega>)"], ["proof (state)\nthis:\n  HLD (Jondo (I1 \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo (I1 \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}\n 2. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>) \\<Longrightarrow>\n        I1 \\<inter> I2 \\<noteq> {};\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  HLD (Jondo (I1 \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  HLD (Jondo (I1 \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. I1 \\<inter> I2 \\<noteq> {}", "by (auto simp add: suntil.simps[of _ _ \\<omega>] suntil.simps[of _ _ \"stl \\<omega>\"] HLD_iff)"], ["proof (state)\nthis:\n  I1 \\<inter> I2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>) \\<Longrightarrow>\n        I1 \\<inter> I2 \\<noteq> {};\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>) \\<Longrightarrow>\n        I1 \\<inter> I2 \\<noteq> {};\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}", "case (step \\<omega>)"], ["proof (state)\nthis:\n  HLD (Jondo H) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>) \\<Longrightarrow>\n  I1 \\<inter> I2 \\<noteq> {}\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>) \\<Longrightarrow>\n        I1 \\<inter> I2 \\<noteq> {};\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         \\<omega>\\<rbrakk>\n       \\<Longrightarrow> I1 \\<inter> I2 \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  HLD (Jondo H) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>) \\<Longrightarrow>\n  I1 \\<inter> I2 \\<noteq> {}\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  HLD (Jondo H) \\<omega>\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I1 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>) \\<Longrightarrow>\n  I1 \\<inter> I2 \\<noteq> {}\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I2 \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. I1 \\<inter> I2 \\<noteq> {}", "by (auto simp add: suntil.simps[of _ _ \\<omega>] suntil.simps[of _ _ \"stl \\<omega>\"] HLD_iff)"], ["proof (state)\nthis:\n  I1 \\<inter> I2 \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hit_C_imp_before_C:\n  assumes \"enabled Start \\<omega>\" \"hit_C \\<omega>\" shows \"before_C H \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "let ?X = \"Init`H \\<union> Mix`H\""], ["proof (state)\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "fix \\<omega> s"], ["proof (state)\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "assume \"ev (HLD (Mix`C)) \\<omega>\" \"s\\<in>?X\" \"enabled s \\<omega>\""], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) \\<omega>\n  s \\<in> Jondo H\n  enabled s \\<omega>\n\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "then"], ["proof (chain)\npicking this:\n  ev (HLD (Mix ` C)) \\<omega>\n  s \\<in> Jondo H\n  enabled s \\<omega>", "have \"((HLD (Jondo H)) suntil (?X \\<cdot> HLD (Mix ` C))) (s ## \\<omega>)\""], ["proof (prove)\nusing this:\n  ev (HLD (Mix ` C)) \\<omega>\n  s \\<in> Jondo H\n  enabled s \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Jondo H) suntil\n     (\\<lambda>xs. HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     (s ## \\<omega>)", "proof (induction arbitrary: s rule: ev_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (Mix ` C) xs; s \\<in> Jondo H; enabled s xs\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo H) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          (s ## xs)\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (Mix ` C)) (stl xs); \\<not> HLD (Mix ` C) xs;\n        \\<And>s.\n           \\<lbrakk>s \\<in> Jondo H; enabled s (stl xs)\\<rbrakk>\n           \\<Longrightarrow> (HLD (Jondo H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Jondo H) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (s ## stl xs);\n        s \\<in> Jondo H; enabled s xs\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo H) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          (s ## xs)", "case (step \\<omega> s)"], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) (stl \\<omega>)\n  \\<not> HLD (Mix ` C) \\<omega>\n  \\<lbrakk>?s1 \\<in> Jondo H; enabled ?s1 (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n                     (?s1 ## stl \\<omega>)\n  s \\<in> Jondo H\n  enabled s \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (Mix ` C) xs; s \\<in> Jondo H; enabled s xs\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo H) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          (s ## xs)\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (Mix ` C)) (stl xs); \\<not> HLD (Mix ` C) xs;\n        \\<And>s.\n           \\<lbrakk>s \\<in> Jondo H; enabled s (stl xs)\\<rbrakk>\n           \\<Longrightarrow> (HLD (Jondo H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Jondo H) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                              (s ## stl xs);\n        s \\<in> Jondo H; enabled s xs\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo H) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          (s ## xs)", "from step.IH[of \"shd \\<omega>\"] step.prems step.hyps"], ["proof (chain)\npicking this:\n  \\<lbrakk>shd \\<omega> \\<in> Jondo H;\n   enabled (shd \\<omega>) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n                     (shd \\<omega> ## stl \\<omega>)\n  s \\<in> Jondo H\n  enabled s \\<omega>\n  ev (HLD (Mix ` C)) (stl \\<omega>)\n  \\<not> HLD (Mix ` C) \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>shd \\<omega> \\<in> Jondo H;\n   enabled (shd \\<omega>) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n                     (shd \\<omega> ## stl \\<omega>)\n  s \\<in> Jondo H\n  enabled s \\<omega>\n  ev (HLD (Mix ` C)) (stl \\<omega>)\n  \\<not> HLD (Mix ` C) \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Jondo H) suntil\n     (\\<lambda>xs. HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     (s ## \\<omega>)", "by (auto simp: enabled.simps[of _ \\<omega>] suntil_Stream E_Init E_Mix HLD_iff\n          enabled_End ev_sconst)"], ["proof (state)\nthis:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs. HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (Mix ` C) xs; s \\<in> Jondo H; enabled s xs\\<rbrakk>\n       \\<Longrightarrow> (HLD (Jondo H) suntil\n                          (\\<lambda>xs.\n                              HLD (Jondo H) xs \\<and>\n                              nxt (HLD (Mix ` C)) xs))\n                          (s ## xs)", "qed (auto simp: suntil_Stream)"], ["proof (state)\nthis:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs. HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (s ## \\<omega>)\n\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ev (HLD (Mix ` C)) ?\\<omega>'3; ?s3 \\<in> Jondo H;\n   enabled ?s3 ?\\<omega>'3\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n                     (?s3 ## ?\\<omega>'3)\n\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "from this[of \"stl \\<omega>\" \"shd \\<omega>\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>ev (HLD (Mix ` C)) (stl \\<omega>); shd \\<omega> \\<in> Jondo H;\n   enabled (shd \\<omega>) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n                     (shd \\<omega> ## stl \\<omega>)\n  enabled Start \\<omega>\n  hit_C \\<omega>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ev (HLD (Mix ` C)) (stl \\<omega>); shd \\<omega> \\<in> Jondo H;\n   enabled (shd \\<omega>) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> (HLD (Jondo H) suntil\n                     (\\<lambda>xs.\n                         HLD (Jondo H) xs \\<and> nxt (HLD (Mix ` C)) xs))\n                     (shd \\<omega> ## stl \\<omega>)\n  enabled Start \\<omega>\n  hit_C \\<omega>\n\ngoal (1 subgoal):\n 1. before_C H \\<omega>", "by (auto simp: before_C_def hit_C_def enabled.simps[of _ \\<omega>] E_Start)"], ["proof (state)\nthis:\n  before_C H \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma before_C_single:\n  assumes \"before_C I \\<omega>\" shows \"\\<exists>i\\<in>I \\<inter> H. before_C {i} \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I \\<inter> H. before_C {i} \\<omega>", "using assms"], ["proof (prove)\nusing this:\n  before_C I \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I \\<inter> H. before_C {i} \\<omega>", "unfolding before_C_def"], ["proof (prove)\nusing this:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (I \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<in>I \\<inter> H.\n       (HLD (Jondo H) suntil\n        (\\<lambda>xs.\n            HLD (Jondo ({i} \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n        \\<omega>", "by induction (auto simp: HLD_iff intro: suntil.intros)"], ["", "lemma before_C_imp_in_H: \"before_C {i} \\<omega> \\<Longrightarrow> i \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before_C {i} \\<omega> \\<Longrightarrow> i \\<in> H", "by (auto dest: before_C_single)"], ["", "subsection \\<open>The probability that the sender hits a collaborator\\<close>"], ["", "lemma Pr_hit_C: \"\\<P>(\\<omega> in \\<PP>. hit_C \\<omega>) = (1 - p_H) / (1 - p_H * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "let ?P = \"\\<lambda>x P. emeasure (T x) {\\<omega>\\<in>space (T x). P \\<omega>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "let ?M = \"HLD (Mix ` C)\" and ?I = \"Init`H\" and ?J = \"Mix`H\""], ["proof (state)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "let ?\\<phi> = \"(HLD ?J) aand not ?M\""], ["proof (state)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "assume s: \"s \\<in> Jondo J\""], ["proof (state)\nthis:\n  s \\<in> Jondo J\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "have \"AE \\<omega> in T s. ev ?M \\<omega> \\<longleftrightarrow> (HLD ?J suntil ?M) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. ev (HLD (Mix ` C)) \\<omega> =\n                        (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "using AE_T_enabled"], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (enabled ?s)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T s. ev (HLD (Mix ` C)) \\<omega> =\n                        (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled s \\<omega> \\<Longrightarrow>\n       ev (HLD (Mix ` C)) \\<omega> =\n       (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled s \\<omega> \\<Longrightarrow>\n       ev (HLD (Mix ` C)) \\<omega> =\n       (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "assume \\<omega>: \"enabled s \\<omega>\""], ["proof (state)\nthis:\n  enabled s \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled s \\<omega> \\<Longrightarrow>\n       ev (HLD (Mix ` C)) \\<omega> =\n       (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "show \"ev ?M \\<omega> \\<longleftrightarrow> (HLD ?J suntil ?M) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (HLD (Mix ` C)) \\<omega> =\n    (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ev (HLD (Mix ` C)) \\<omega> \\<Longrightarrow>\n    (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n 2. (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega> \\<Longrightarrow>\n    ev (HLD (Mix ` C)) \\<omega>", "assume \"ev ?M \\<omega>\""], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) \\<omega>\n\ngoal (2 subgoals):\n 1. ev (HLD (Mix ` C)) \\<omega> \\<Longrightarrow>\n    (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n 2. (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega> \\<Longrightarrow>\n    ev (HLD (Mix ` C)) \\<omega>", "from this \\<omega> s"], ["proof (chain)\npicking this:\n  ev (HLD (Mix ` C)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo J", "show \"(HLD ?J suntil ?M) \\<omega>\""], ["proof (prove)\nusing this:\n  ev (HLD (Mix ` C)) \\<omega>\n  enabled s \\<omega>\n  s \\<in> Jondo J\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "proof (induct arbitrary: s rule: ev_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (Mix ` C) xs; enabled s xs; s \\<in> Jondo J\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) xs\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (Mix ` C)) (stl xs); \\<not> HLD (Mix ` C) xs;\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> Jondo J\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) (stl xs);\n        enabled s xs; s \\<in> Jondo J\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) xs", "case (step \\<omega>)"], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) (stl \\<omega>)\n  \\<not> HLD (Mix ` C) \\<omega>\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> Jondo J\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> Jondo J\n\ngoal (2 subgoals):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (Mix ` C) xs; enabled s xs; s \\<in> Jondo J\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) xs\n 2. \\<And>xs s.\n       \\<lbrakk>ev (HLD (Mix ` C)) (stl xs); \\<not> HLD (Mix ` C) xs;\n        \\<And>s.\n           \\<lbrakk>enabled s (stl xs); s \\<in> Jondo J\\<rbrakk>\n           \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) (stl xs);\n        enabled s xs; s \\<in> Jondo J\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) xs", "then"], ["proof (chain)\npicking this:\n  ev (HLD (Mix ` C)) (stl \\<omega>)\n  \\<not> HLD (Mix ` C) \\<omega>\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> Jondo J\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> Jondo J", "show ?case"], ["proof (prove)\nusing this:\n  ev (HLD (Mix ` C)) (stl \\<omega>)\n  \\<not> HLD (Mix ` C) \\<omega>\n  \\<lbrakk>enabled ?s1 (stl \\<omega>); ?s1 \\<in> Jondo J\\<rbrakk>\n  \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) (stl \\<omega>)\n  enabled s \\<omega>\n  s \\<in> Jondo J\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>", "by (auto simp: HLD_iff enabled.simps[of _ \\<omega>] suntil.simps[of _ _ \\<omega>] E_End E_Init E_Mix\n                           enabled_End ev_sconst)"], ["proof (state)\nthis:\n  (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>xs s.\n       \\<lbrakk>HLD (Mix ` C) xs; enabled s xs; s \\<in> Jondo J\\<rbrakk>\n       \\<Longrightarrow> (HLD (Mix ` H) suntil HLD (Mix ` C)) xs", "qed (auto simp: HLD_iff E_Init intro: suntil.intros)"], ["proof (state)\nthis:\n  (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega> \\<Longrightarrow>\n    ev (HLD (Mix ` C)) \\<omega>", "qed (rule ev_suntil)"], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) \\<omega> =\n  (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in T s. ev (HLD (Mix ` C)) \\<omega> =\n                      (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "}"], ["proof (state)\nthis:\n  ?s3 \\<in> Jondo J \\<Longrightarrow>\n  AE \\<omega> in T ?s3. ev (HLD (Mix ` C)) \\<omega> =\n                        (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "note ev_eq_suntil = this"], ["proof (state)\nthis:\n  ?s3 \\<in> Jondo J \\<Longrightarrow>\n  AE \\<omega> in T ?s3. ev (HLD (Mix ` C)) \\<omega> =\n                        (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "have \"?P Start hit_C = (\\<integral>\\<^sup>+x. ?P x (ev ?M) * indicator ?I x \\<partial>N Start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    \\<integral>\\<^sup>+x\\<in>Init ` H.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         ev (HLD (Mix ` C)) \\<omega>}\n    \\<partial>measure_pmf (N Start)", "unfolding hit_C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` H) \\<omega> \\<and> nxt (ev (HLD (Mix ` C))) \\<omega>} =\n    \\<integral>\\<^sup>+x\\<in>Init ` H.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         ev (HLD (Mix ` C)) \\<omega>}\n    \\<partial>measure_pmf (N Start)", "by (rule emeasure_HLD_nxt) measurable"], ["proof (state)\nthis:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n  \\<integral>\\<^sup>+x\\<in>Init ` H.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       ev (HLD (Mix ` C)) \\<omega>}\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n  \\<integral>\\<^sup>+x\\<in>Init ` H.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       ev (HLD (Mix ` C)) \\<omega>}\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "have \"\\<dots> = (\\<integral>\\<^sup>+x. ennreal ((1 - p_H) / (1 - p_f * p_H)) * indicator ?I x \\<partial>N Start)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` H.\n                       emeasure (T x)\n                        {\\<omega> \\<in> space (T x).\n                         ev (HLD (Mix ` C)) \\<omega>}\n    \\<partial>measure_pmf (N Start) =\n    \\<integral>\\<^sup>+x\\<in>Init ` H. ennreal ((1 - p_H) / (1 - p_f * p_H))\n    \\<partial>measure_pmf (N Start)", "proof (intro nn_integral_cong ennreal_mult_right_cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "assume \"indicator (Init ` H) x \\<noteq> 0\""], ["proof (state)\nthis:\n  indicator (Init ` H) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "then"], ["proof (chain)\npicking this:\n  indicator (Init ` H) x \\<noteq> (0::'b)", "have \"x \\<in> ?I\""], ["proof (prove)\nusing this:\n  indicator (Init ` H) x \\<noteq> (0::'b)\n\ngoal (1 subgoal):\n 1. x \\<in> Init ` H", "by (auto split: split_indicator_asm)"], ["proof (state)\nthis:\n  x \\<in> Init ` H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "{"], ["proof (state)\nthis:\n  x \\<in> Init ` H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "assume j: \"j \\<in> H\""], ["proof (state)\nthis:\n  j \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "with ev_eq_suntil[of \"Mix j\"]"], ["proof (chain)\npicking this:\n  Mix j \\<in> Jondo J \\<Longrightarrow>\n  AE \\<omega> in T (Mix j). ev (HLD (Mix ` C)) \\<omega> =\n                            (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n  j \\<in> H", "have \"?P (Mix j) (ev ?M) = ?P (Mix j) ((HLD ?J) suntil ?M)\""], ["proof (prove)\nusing this:\n  Mix j \\<in> Jondo J \\<Longrightarrow>\n  AE \\<omega> in T (Mix j). ev (HLD (Mix ` C)) \\<omega> =\n                            (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>\n  j \\<in> H\n\ngoal (1 subgoal):\n 1. emeasure (T (Mix j))\n     {\\<omega> \\<in> space (T (Mix j)). ev (HLD (Mix ` C)) \\<omega>} =\n    emeasure (T (Mix j))\n     {\\<omega> \\<in> space (T (Mix j)).\n      (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>}", "by (intro emeasure_eq_AE) auto"], ["proof (state)\nthis:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)). ev (HLD (Mix ` C)) \\<omega>} =\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)).\n    (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "also"], ["proof (state)\nthis:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)). ev (HLD (Mix ` C)) \\<omega>} =\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)).\n    (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "have \"\\<dots> = (((1 - p_H) * p_f)) / (1 - p_H * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (Mix j))\n     {\\<omega> \\<in> space (T (Mix j)).\n      (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>} =\n    ennreal ((1 - p_H) * p_f / (1 - p_H * p_f))", "proof (rule emeasure_suntil_geometric)"], ["proof (state)\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) (HLD (Mix ` C))\n 2. Mix j \\<in> Mix ` H\n 3. 0 \\<le> p_H * p_f\n 4. 0 \\<le> (1 - p_H) * p_f\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s) {\\<omega> \\<in> space (T s). HLD (Mix ` C) \\<omega>} =\n       ennreal ((1 - p_H) * p_f)\n 6. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 7. p_H * p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> (HLD (Mix ` C) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   HLD (Mix ` C))))\n                                   \\<omega>", "fix s"], ["proof (state)\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) (HLD (Mix ` C))\n 2. Mix j \\<in> Mix ` H\n 3. 0 \\<le> p_H * p_f\n 4. 0 \\<le> (1 - p_H) * p_f\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s) {\\<omega> \\<in> space (T s). HLD (Mix ` C) \\<omega>} =\n       ennreal ((1 - p_H) * p_f)\n 6. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 7. p_H * p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> (HLD (Mix ` C) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   HLD (Mix ` C))))\n                                   \\<omega>", "assume s: \"s \\<in> Mix ` H\""], ["proof (state)\nthis:\n  s \\<in> Mix ` H\n\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) (HLD (Mix ` C))\n 2. Mix j \\<in> Mix ` H\n 3. 0 \\<le> p_H * p_f\n 4. 0 \\<le> (1 - p_H) * p_f\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s) {\\<omega> \\<in> space (T s). HLD (Mix ` C) \\<omega>} =\n       ennreal ((1 - p_H) * p_f)\n 6. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 7. p_H * p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> (HLD (Mix ` C) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   HLD (Mix ` C))))\n                                   \\<omega>", "from s C_smaller"], ["proof (chain)\npicking this:\n  s \\<in> Mix ` H\n  C \\<subset> J", "show \"?P s ?M = ennreal ((1 - p_H) * p_f)\""], ["proof (prove)\nusing this:\n  s \\<in> Mix ` H\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. emeasure (T s) {\\<omega> \\<in> space (T s). HLD (Mix ` C) \\<omega>} =\n    ennreal ((1 - p_H) * p_f)", "by (subst emeasure_HLD)\n             (auto simp add: emeasure_measure_pmf_finite sum.reindex subset_eq p_j_def H_compl)"], ["proof (state)\nthis:\n  emeasure (T s) {\\<omega> \\<in> space (T s). HLD (Mix ` C) \\<omega>} =\n  ennreal ((1 - p_H) * p_f)\n\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) (HLD (Mix ` C))\n 2. Mix j \\<in> Mix ` H\n 3. 0 \\<le> p_H * p_f\n 4. 0 \\<le> (1 - p_H) * p_f\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 6. p_H * p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> (HLD (Mix ` C) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   HLD (Mix ` C))))\n                                   \\<omega>", "from s"], ["proof (chain)\npicking this:\n  s \\<in> Mix ` H", "show \"emeasure (N s) (Mix`H) = p_H * p_f\""], ["proof (prove)\nusing this:\n  s \\<in> Mix ` H\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)", "by (auto simp: emeasure_measure_pmf_finite sum.reindex p_H_def p_j_def)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n\ngoal (6 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV)) (HLD (Mix ` C))\n 2. Mix j \\<in> Mix ` H\n 3. 0 \\<le> p_H * p_f\n 4. 0 \\<le> (1 - p_H) * p_f\n 5. p_H * p_f < 1\n 6. \\<And>t.\n       AE \\<omega> in T t. \\<not> (HLD (Mix ` C) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   HLD (Mix ` C))))\n                                   \\<omega>", "qed (insert j, auto simp: HLD_iff p_H_p_f_less_1)"], ["proof (state)\nthis:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)).\n    (HLD (Mix ` H) suntil HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) * p_f / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "finally"], ["proof (chain)\npicking this:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) * p_f / (1 - p_H * p_f))", "have \"?P (Init j) (ev ?M) = (1 - p_H) / (1 - p_H * p_f)\""], ["proof (prove)\nusing this:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) * p_f / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j))\n     {\\<omega> \\<in> space (T (Init j)). ev (HLD (Mix ` C)) \\<omega>} =\n    ennreal ((1 - p_H) / (1 - p_H * p_f))", "using p_f"], ["proof (prove)\nusing this:\n  emeasure (T (Mix j))\n   {\\<omega> \\<in> space (T (Mix j)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) * p_f / (1 - p_H * p_f))\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. emeasure (T (Init j))\n     {\\<omega> \\<in> space (T (Init j)). ev (HLD (Mix ` C)) \\<omega>} =\n    ennreal ((1 - p_H) / (1 - p_H * p_f))", "by (subst emeasure_Init_eq_Mix)\n           (auto simp: ev_Stream AE_End ev_sconst HLD_iff mult_le_one divide_ennreal)"], ["proof (state)\nthis:\n  emeasure (T (Init j))\n   {\\<omega> \\<in> space (T (Init j)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "}"], ["proof (state)\nthis:\n  ?j4 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j4))\n   {\\<omega> \\<in> space (T (Init ?j4)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space (measure_pmf (N Start));\n        indicator (Init ` H) x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> emeasure (T x)\n                          {\\<omega> \\<in> space (T x).\n                           ev (HLD (Mix ` C)) \\<omega>} =\n                         ennreal ((1 - p_H) / (1 - p_f * p_H))", "then"], ["proof (chain)\npicking this:\n  ?j4 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j4))\n   {\\<omega> \\<in> space (T (Init ?j4)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))", "show \"?P x (ev ?M) = (1 - p_H) / (1 - p_f * p_H)\""], ["proof (prove)\nusing this:\n  ?j4 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j4))\n   {\\<omega> \\<in> space (T (Init ?j4)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. emeasure (T x)\n     {\\<omega> \\<in> space (T x). ev (HLD (Mix ` C)) \\<omega>} =\n    ennreal ((1 - p_H) / (1 - p_f * p_H))", "using \\<open>x \\<in> ?I\\<close>"], ["proof (prove)\nusing this:\n  ?j4 \\<in> H \\<Longrightarrow>\n  emeasure (T (Init ?j4))\n   {\\<omega> \\<in> space (T (Init ?j4)). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))\n  x \\<in> Init ` H\n\ngoal (1 subgoal):\n 1. emeasure (T x)\n     {\\<omega> \\<in> space (T x). ev (HLD (Mix ` C)) \\<omega>} =\n    ennreal ((1 - p_H) / (1 - p_f * p_H))", "by (auto simp: mult_ac)"], ["proof (state)\nthis:\n  emeasure (T x) {\\<omega> \\<in> space (T x). ev (HLD (Mix ` C)) \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_f * p_H))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Init ` H.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       ev (HLD (Mix ` C)) \\<omega>}\n  \\<partial>measure_pmf (N Start) =\n  \\<integral>\\<^sup>+x\\<in>Init ` H. ennreal ((1 - p_H) / (1 - p_f * p_H))\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Init ` H.\n                     emeasure (T x)\n                      {\\<omega> \\<in> space (T x).\n                       ev (HLD (Mix ` C)) \\<omega>}\n  \\<partial>measure_pmf (N Start) =\n  \\<integral>\\<^sup>+x\\<in>Init ` H. ennreal ((1 - p_H) / (1 - p_f * p_H))\n  \\<partial>measure_pmf (N Start)\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "have \"\\<dots> = ennreal ((1 - p_H) / (1 - p_H * p_f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` H. ennreal ((1 - p_H) / (1 - p_f * p_H))\n    \\<partial>measure_pmf (N Start) =\n    ennreal ((1 - p_H) / (1 - p_H * p_f))", "using p_j_pos p_H p_H_p_f_less_1"], ["proof (prove)\nusing this:\n  0 < p_j\n  0 < p_H\n  p_H < 1\n  p_H * p_f < 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>Init ` H. ennreal ((1 - p_H) / (1 - p_f * p_H))\n    \\<partial>measure_pmf (N Start) =\n    ennreal ((1 - p_H) / (1 - p_H * p_f))", "by (subst nn_integral_cmult_indicator)\n       (auto simp: emeasure_measure_pmf_finite sum.reindex subset_eq mult_ac\n             intro!: divide_nonneg_nonneg)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>Init ` H. ennreal ((1 - p_H) / (1 - p_f * p_H))\n  \\<partial>measure_pmf (N Start) =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "finally"], ["proof (chain)\npicking this:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n  ennreal ((1 - p_H) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n    (1 - p_H) / (1 - p_H * p_f)", "by (simp add: measure_def mult_le_one)"], ["proof (state)\nthis:\n  T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} =\n  (1 - p_H) / (1 - p_H * p_f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma before_C_imp_hit_C:\n  assumes \"enabled Start \\<omega>\" \"before_C B \\<omega>\"\n  shows \"hit_C \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "fix \\<omega> j"], ["proof (state)\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "assume \"((HLD (Jondo H)) suntil (Jondo (B \\<inter> H) \\<cdot> HLD (Mix ` C))) \\<omega>\"\n      \"j \\<in> H\" \"enabled (Mix j) \\<omega>\""], ["proof (state)\nthis:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  j \\<in> H\n  enabled (Mix j) \\<omega>\n\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "then"], ["proof (chain)\npicking this:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  j \\<in> H\n  enabled (Mix j) \\<omega>", "have \"ev (HLD (Mix`C)) \\<omega>\""], ["proof (prove)\nusing this:\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   \\<omega>\n  j \\<in> H\n  enabled (Mix j) \\<omega>\n\ngoal (1 subgoal):\n 1. ev (HLD (Mix ` C)) \\<omega>", "proof (induction arbitrary: j rule: suntil_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega> j.\n       \\<lbrakk>HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        j \\<in> H; enabled (Mix j) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ev (HLD (Mix ` C)) \\<omega>\n 2. \\<And>\\<omega> j.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        \\<not> (HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>j.\n           \\<lbrakk>j \\<in> H; enabled (Mix j) (stl \\<omega>)\\<rbrakk>\n           \\<Longrightarrow> ev (HLD (Mix ` C)) (stl \\<omega>);\n        j \\<in> H; enabled (Mix j) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ev (HLD (Mix ` C)) \\<omega>", "case (step \\<omega>)"], ["proof (state)\nthis:\n  HLD (Jondo H) \\<omega>\n  \\<not> (HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n          nxt (HLD (Mix ` C)) \\<omega>)\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>?j1 \\<in> H; enabled (Mix ?j1) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> ev (HLD (Mix ` C)) (stl \\<omega>)\n  j \\<in> H\n  enabled (Mix j) \\<omega>\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega> j.\n       \\<lbrakk>HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        j \\<in> H; enabled (Mix j) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ev (HLD (Mix ` C)) \\<omega>\n 2. \\<And>\\<omega> j.\n       \\<lbrakk>HLD (Jondo H) \\<omega>;\n        \\<not> (HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>);\n        (HLD (Jondo H) suntil\n         (\\<lambda>xs.\n             HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n         (stl \\<omega>);\n        \\<And>j.\n           \\<lbrakk>j \\<in> H; enabled (Mix j) (stl \\<omega>)\\<rbrakk>\n           \\<Longrightarrow> ev (HLD (Mix ` C)) (stl \\<omega>);\n        j \\<in> H; enabled (Mix j) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ev (HLD (Mix ` C)) \\<omega>", "then"], ["proof (chain)\npicking this:\n  HLD (Jondo H) \\<omega>\n  \\<not> (HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n          nxt (HLD (Mix ` C)) \\<omega>)\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>?j1 \\<in> H; enabled (Mix ?j1) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> ev (HLD (Mix ` C)) (stl \\<omega>)\n  j \\<in> H\n  enabled (Mix j) \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  HLD (Jondo H) \\<omega>\n  \\<not> (HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n          nxt (HLD (Mix ` C)) \\<omega>)\n  (HLD (Jondo H) suntil\n   (\\<lambda>xs.\n       HLD (Jondo (B \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n   (stl \\<omega>)\n  \\<lbrakk>?j1 \\<in> H; enabled (Mix ?j1) (stl \\<omega>)\\<rbrakk>\n  \\<Longrightarrow> ev (HLD (Mix ` C)) (stl \\<omega>)\n  j \\<in> H\n  enabled (Mix j) \\<omega>\n\ngoal (1 subgoal):\n 1. ev (HLD (Mix ` C)) \\<omega>", "by (auto simp: enabled.simps[of _ \\<omega>] E_Mix enabled_End ev_sconst suntil_sconst HLD_iff)"], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega> j.\n       \\<lbrakk>HLD (Jondo (B \\<inter> H)) \\<omega> \\<and>\n                nxt (HLD (Mix ` C)) \\<omega>;\n        j \\<in> H; enabled (Mix j) \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ev (HLD (Mix ` C)) \\<omega>", "qed auto"], ["proof (state)\nthis:\n  ev (HLD (Mix ` C)) \\<omega>\n\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            ?\\<omega>'3;\n   ?j3 \\<in> H; enabled (Mix ?j3) ?\\<omega>'3\\<rbrakk>\n  \\<Longrightarrow> ev (HLD (Mix ` C)) ?\\<omega>'3\n\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "from this[of \"stl (stl \\<omega>)\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl (stl \\<omega>));\n   ?j3 \\<in> H; enabled (Mix ?j3) (stl (stl \\<omega>))\\<rbrakk>\n  \\<Longrightarrow> ev (HLD (Mix ` C)) (stl (stl \\<omega>))\n  enabled Start \\<omega>\n  before_C B \\<omega>", "show \"hit_C \\<omega>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(HLD (Jondo H) suntil\n            (\\<lambda>xs.\n                HLD (Jondo (B \\<inter> H)) xs \\<and>\n                nxt (HLD (Mix ` C)) xs))\n            (stl (stl \\<omega>));\n   ?j3 \\<in> H; enabled (Mix ?j3) (stl (stl \\<omega>))\\<rbrakk>\n  \\<Longrightarrow> ev (HLD (Mix ` C)) (stl (stl \\<omega>))\n  enabled Start \\<omega>\n  before_C B \\<omega>\n\ngoal (1 subgoal):\n 1. hit_C \\<omega>", "by (force simp: before_C_def hit_C_def E_Start HLD_iff E_Init\n      enabled.simps[of _ \\<omega>] ev.simps[of _ \\<omega>] suntil.simps[of _ _ \\<omega>]\n      enabled.simps[of _ \"stl \\<omega>\"] ev.simps[of _ \"stl \\<omega>\"] suntil.simps[of _ _ \"stl \\<omega>\"])"], ["proof (state)\nthis:\n  hit_C \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma negE: \"\\<not> P \\<Longrightarrow> P \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> P; P\\<rbrakk> \\<Longrightarrow> False", "by blast"], ["", "lemma Pr_visit_before_C:\n  assumes L: \"L \\<subseteq> H\" and I: \"I \\<subseteq> H\"\n  shows \"\\<P>(\\<omega> in \\<PP>. visit I J \\<omega> \\<and> before_C L \\<omega> \\<bar> hit_C \\<omega> ) =\n    (\\<Sum>i\\<in>I. p_i i) * card L * p_j * p_f + (\\<Sum>i\\<in>I \\<inter> L. p_i i) * (1 - p_H * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "let ?M = \"Mix`H\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "let ?P = \"\\<lambda>x P. emeasure (T x) {\\<omega>\\<in>space (T x). P \\<omega>}\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "let ?V = \"(visit I J aand before_C L) aand hit_C\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "let ?U = \"HLD ?M suntil (Mix`L \\<cdot> HLD (Mix`C))\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "let ?L = \"HLD (Mix`C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have IJ: \"x \\<in> I \\<Longrightarrow> x \\<in> J\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> I \\<Longrightarrow> x \\<in> J", "using I"], ["proof (prove)\nusing this:\n  I \\<subseteq> H\n\ngoal (1 subgoal):\n 1. x \\<in> I \\<Longrightarrow> x \\<in> J", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> I \\<Longrightarrow> ?x1 \\<in> J\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have [simp, intro]: \"finite I\" \"finite L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I &&& finite L", "using L I"], ["proof (prove)\nusing this:\n  L \\<subseteq> H\n  I \\<subseteq> H\n\ngoal (1 subgoal):\n 1. finite I &&& finite L", "by (auto dest: finite_subset)"], ["proof (state)\nthis:\n  finite I\n  finite L\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have \"?P Start ?V = ?P Start ((Init`I \\<cdot> ?U) or (Init`(I \\<inter> L) \\<cdot> ?L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega> \\<or>\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>}", "proof (rule emeasure_Collect_eq_AE)"], ["proof (state)\ngoal (3 subgoals):\n 1. AE \\<omega> in \\<PP>. ((visit I J \\<omega> \\<and>\n                            before_C L \\<omega>) \\<and>\n                           hit_C \\<omega>) =\n                          (HLD (Init ` I) \\<omega> \\<and>\n                           nxt (HLD (Mix ` H) suntil\n                                (\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD (Mix ` C)) xs))\n                            \\<omega> \\<or>\n                           HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                           nxt (HLD (Mix ` C)) \\<omega>)\n 2. T.random_variable Start (count_space UNIV)\n     (\\<lambda>x.\n         HLD (Init ` I) x \\<and>\n         nxt (HLD (Mix ` H) suntil\n              (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          x \\<or>\n         HLD (Init ` (I \\<inter> L)) x \\<and> nxt (HLD (Mix ` C)) x)\n 3. T.random_variable Start (count_space UNIV)\n     (\\<lambda>x. (visit I J x \\<and> before_C L x) \\<and> hit_C x)", "show \"AE \\<omega> in \\<PP>. ?V \\<omega> \\<longleftrightarrow> ((Init`I \\<cdot> ?U) or (Init`(I \\<inter> L) \\<cdot> ?L)) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. ((visit I J \\<omega> \\<and>\n                            before_C L \\<omega>) \\<and>\n                           hit_C \\<omega>) =\n                          (HLD (Init ` I) \\<omega> \\<and>\n                           nxt (HLD (Mix ` H) suntil\n                                (\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD (Mix ` C)) xs))\n                            \\<omega> \\<or>\n                           HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                           nxt (HLD (Mix ` C)) \\<omega>)", "using AE_T_enabled AE_visit"], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (enabled ?s)\n  almost_everywhere \\<PP> (visit H J)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. ((visit I J \\<omega> \\<and>\n                            before_C L \\<omega>) \\<and>\n                           hit_C \\<omega>) =\n                          (HLD (Init ` I) \\<omega> \\<and>\n                           nxt (HLD (Mix ` H) suntil\n                                (\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD (Mix ` C)) xs))\n                            \\<omega> \\<or>\n                           HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                           nxt (HLD (Mix ` C)) \\<omega>)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>enabled Start \\<omega>; visit H J \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ((visit I J \\<omega> \\<and>\n                           before_C L \\<omega>) \\<and>\n                          hit_C \\<omega>) =\n                         (HLD (Init ` I) \\<omega> \\<and>\n                          nxt (HLD (Mix ` H) suntil\n                               (\\<lambda>xs.\n                                   HLD (Mix ` L) xs \\<and>\n                                   nxt (HLD (Mix ` C)) xs))\n                           \\<omega> \\<or>\n                          HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                          nxt (HLD (Mix ` C)) \\<omega>)", "case (elim \\<omega>)"], ["proof (state)\nthis:\n  enabled Start \\<omega>\n  visit H J \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<lbrakk>enabled Start \\<omega>; visit H J \\<omega>\\<rbrakk>\n       \\<Longrightarrow> ((visit I J \\<omega> \\<and>\n                           before_C L \\<omega>) \\<and>\n                          hit_C \\<omega>) =\n                         (HLD (Init ` I) \\<omega> \\<and>\n                          nxt (HLD (Mix ` H) suntil\n                               (\\<lambda>xs.\n                                   HLD (Mix ` L) xs \\<and>\n                                   nxt (HLD (Mix ` C)) xs))\n                           \\<omega> \\<or>\n                          HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                          nxt (HLD (Mix ` C)) \\<omega>)", "then"], ["proof (chain)\npicking this:\n  enabled Start \\<omega>\n  visit H J \\<omega>", "show ?case"], ["proof (prove)\nusing this:\n  enabled Start \\<omega>\n  visit H J \\<omega>\n\ngoal (1 subgoal):\n 1. ((visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and>\n     hit_C \\<omega>) =\n    (HLD (Init ` I) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "using before_C_imp_hit_C[of \\<omega> \"L\"]  before_C[of \\<omega> \"L\"] I L"], ["proof (prove)\nusing this:\n  enabled Start \\<omega>\n  visit H J \\<omega>\n  \\<lbrakk>enabled Start \\<omega>; before_C L \\<omega>\\<rbrakk>\n  \\<Longrightarrow> hit_C \\<omega>\n  enabled Start \\<omega> \\<Longrightarrow>\n  before_C L \\<omega> =\n  (HLD (Init ` H) \\<omega> \\<and>\n   nxt (HLD (Mix ` H) suntil\n        (\\<lambda>xs.\n            HLD (Mix ` (L \\<inter> H)) xs \\<and> nxt (HLD (Mix ` C)) xs))\n    \\<omega> \\<or>\n   HLD (Init ` (L \\<inter> H)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>)\n  I \\<subseteq> H\n  L \\<subseteq> H\n\ngoal (1 subgoal):\n 1. ((visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and>\n     hit_C \\<omega>) =\n    (HLD (Init ` I) \\<omega> \\<and>\n     nxt (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n      \\<omega> \\<or>\n     HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n     nxt (HLD (Mix ` C)) \\<omega>)", "by (auto simp: visit_def HLD_iff Int_absorb2)"], ["proof (state)\nthis:\n  ((visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>) =\n  (HLD (Init ` I) \\<omega> \\<and>\n   nxt (HLD (Mix ` H) suntil\n        (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n    \\<omega> \\<or>\n   HLD (Init ` (I \\<inter> L)) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in \\<PP>. ((visit I J \\<omega> \\<and>\n                          before_C L \\<omega>) \\<and>\n                         hit_C \\<omega>) =\n                        (HLD (Init ` I) \\<omega> \\<and>\n                         nxt (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` L) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                          \\<omega> \\<or>\n                         HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                         nxt (HLD (Mix ` C)) \\<omega>)\n\ngoal (2 subgoals):\n 1. T.random_variable Start (count_space UNIV)\n     (\\<lambda>x.\n         HLD (Init ` I) x \\<and>\n         nxt (HLD (Mix ` H) suntil\n              (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          x \\<or>\n         HLD (Init ` (I \\<inter> L)) x \\<and> nxt (HLD (Mix ` C)) x)\n 2. T.random_variable Start (count_space UNIV)\n     (\\<lambda>x. (visit I J x \\<and> before_C L x) \\<and> hit_C x)", "show \"Measurable.pred \\<PP> ((Init`I \\<cdot> ?U) or (Init`(I \\<inter> L) \\<cdot> ?L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.random_variable Start (count_space UNIV)\n     (\\<lambda>xs.\n         HLD (Init ` I) xs \\<and>\n         nxt (HLD (Mix ` H) suntil\n              (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          xs \\<or>\n         HLD (Init ` (I \\<inter> L)) xs \\<and> nxt (HLD (Mix ` C)) xs)", "by measurable"], ["proof (state)\nthis:\n  T.random_variable Start (count_space UNIV)\n   (\\<lambda>xs.\n       HLD (Init ` I) xs \\<and>\n       nxt (HLD (Mix ` H) suntil\n            (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n        xs \\<or>\n       HLD (Init ` (I \\<inter> L)) xs \\<and> nxt (HLD (Mix ` C)) xs)\n\ngoal (1 subgoal):\n 1. T.random_variable Start (count_space UNIV)\n     (\\<lambda>x. (visit I J x \\<and> before_C L x) \\<and> hit_C x)", "qed measurable"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega> \\<or>\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>}\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega> \\<or>\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>}\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have \"\\<dots> = ?P Start (Init`I \\<cdot> ?U) + ?P Start (Init`(I \\<inter> L) \\<cdot> ?L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega> \\<or>\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>} =\n    emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} +\n    emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>}", "using L I"], ["proof (prove)\nusing this:\n  L \\<subseteq> H\n  I \\<subseteq> H\n\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega> \\<or>\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>} =\n    emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} +\n    emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>}", "apply (subst plus_emeasure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> {\\<omega> \\<in> space \\<PP>.\n                       HLD (Init ` I) \\<omega> \\<and>\n                       nxt (HLD (Mix ` H) suntil\n                            (\\<lambda>xs.\n                                HLD (Mix ` L) xs \\<and>\n                                nxt (HLD (Mix ` C)) xs))\n                        \\<omega>}\n                      \\<in> T.events Start\n 2. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> {\\<omega> \\<in> space \\<PP>.\n                       HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                       nxt (HLD (Mix ` C)) \\<omega>}\n                      \\<in> T.events Start\n 3. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> {\\<omega> \\<in> space \\<PP>.\n                       HLD (Init ` I) \\<omega> \\<and>\n                       nxt (HLD (Mix ` H) suntil\n                            (\\<lambda>xs.\n                                HLD (Mix ` L) xs \\<and>\n                                nxt (HLD (Mix ` C)) xs))\n                        \\<omega>} \\<inter>\n                      {\\<omega> \\<in> space \\<PP>.\n                       HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                       nxt (HLD (Mix ` C)) \\<omega>} =\n                      {}\n 4. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H\\<rbrakk>\n    \\<Longrightarrow> emeasure \\<PP>\n                       {\\<omega> \\<in> space \\<PP>.\n                        HLD (Init ` I) \\<omega> \\<and>\n                        nxt (HLD (Mix ` H) suntil\n                             (\\<lambda>xs.\n                                 HLD (Mix ` L) xs \\<and>\n                                 nxt (HLD (Mix ` C)) xs))\n                         \\<omega> \\<or>\n                        HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                        nxt (HLD (Mix ` C)) \\<omega>} =\n                      emeasure \\<PP>\n                       ({\\<omega> \\<in> space \\<PP>.\n                         HLD (Init ` I) \\<omega> \\<and>\n                         nxt (HLD (Mix ` H) suntil\n                              (\\<lambda>xs.\n                                  HLD (Mix ` L) xs \\<and>\n                                  nxt (HLD (Mix ` C)) xs))\n                          \\<omega>} \\<union>\n                        {\\<omega> \\<in> space \\<PP>.\n                         HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n                         nxt (HLD (Mix ` C)) \\<omega>})", "apply (auto intro!: arg_cong2[where f=emeasure])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H;\n        x \\<in> space (stream_space (count_space UNIV)); HLD (Init ` I) x;\n        (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> HLD (Mix ` C) (stl xs)))\n         (stl x);\n        HLD (Init ` (I \\<inter> L)) x; HLD (Mix ` C) (stl x)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst (asm) suntil.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H;\n        x \\<in> space (stream_space (count_space UNIV)); HLD (Init ` I) x;\n        (\\<exists>\\<omega>.\n            stl x = \\<omega> \\<and>\n            HLD (Mix ` L) \\<omega> \\<and>\n            HLD (Mix ` C) (stl \\<omega>)) \\<or>\n        (\\<exists>\\<omega>.\n            stl x = \\<omega> \\<and>\n            HLD (Mix ` H) \\<omega> \\<and>\n            (HLD (Mix ` H) suntil\n             (\\<lambda>xs. HLD (Mix ` L) xs \\<and> HLD (Mix ` C) (stl xs)))\n             (stl \\<omega>));\n        HLD (Init ` (I \\<inter> L)) x; HLD (Mix ` C) (stl x)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add: HLD_iff[abs_def] elim: suntil.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega> \\<or>\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>} =\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} +\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>}\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega> \\<or>\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>} =\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} +\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>}\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have \"?P Start (Init`(I \\<inter> L) \\<cdot> ?L) = (\\<Sum>i\\<in>I\\<inter>L. p_i i * (1 - p_H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>} =\n    ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))", "using L I C_smaller p_j_pos"], ["proof (prove)\nusing this:\n  L \\<subseteq> H\n  I \\<subseteq> H\n  C \\<subset> J\n  0 < p_j\n\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n      nxt (HLD (Mix ` C)) \\<omega>} =\n    ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))", "apply (subst emeasure_HLD_nxt emeasure_HLD, simp)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H; C \\<subset> J;\n     0 < p_j\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+x\\<in>Init ` (I \\<inter> L).\n   emeasure (measure_pmf (N x)) (Mix ` C)\n                      \\<partial>measure_pmf (N Start) =\n                      ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))", "apply (subst nn_integral_indicator_finite)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H; C \\<subset> J;\n     0 < p_j\\<rbrakk>\n    \\<Longrightarrow> finite (Init ` (I \\<inter> L))\n 2. \\<And>a.\n       \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H; C \\<subset> J; 0 < p_j;\n        a \\<in> Init ` (I \\<inter> L)\\<rbrakk>\n       \\<Longrightarrow> {a} \\<in> measure_pmf.events (N Start)\n 3. \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H; C \\<subset> J;\n     0 < p_j\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>Init ` (I \\<inter> L).\n                         emeasure (measure_pmf (N x)) (Mix ` C) *\n                         emeasure (measure_pmf (N Start)) {x}) =\n                      ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))", "apply (auto simp: emeasure_measure_pmf_finite sum.reindex next_prob_def sum.If_cases\n                      Int_absorb2 H_compl2 ennreal_mult[symmetric] sum_nonneg\n                      sum_distrib_left[symmetric] sum_distrib_right[symmetric]\n                intro!: sum.cong sum_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H; 0 < p_j; C \\<subseteq> J;\n        ennreal\n         (real (card C) * p_j *\n          sum p_i\n           (I \\<inter> L \\<inter> {x \\<in> J. x \\<notin> C})) \\<noteq>\n        ennreal (sum p_i (I \\<inter> L) * (real (card C) * p_j));\n        x \\<in> J\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C", "apply (subst (asm) ennreal_inj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> J; L \\<subseteq> H; I \\<subseteq> H; 0 < p_j;\n        C \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> real (card C) * p_j *\n                                 sum p_i\n                                  (I \\<inter> L \\<inter>\n                                   {x \\<in> J. x \\<notin> C})\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> J; L \\<subseteq> H; I \\<subseteq> H; 0 < p_j;\n        C \\<subseteq> J\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> sum p_i (I \\<inter> L) *\n                                 (real (card C) * p_j)\n 3. \\<And>x.\n       \\<lbrakk>L \\<subseteq> H; I \\<subseteq> H; 0 < p_j; C \\<subseteq> J;\n        real (card C) * p_j *\n        sum p_i (I \\<inter> L \\<inter> {x \\<in> J. x \\<notin> C}) \\<noteq>\n        sum p_i (I \\<inter> L) * (real (card C) * p_j);\n        x \\<in> J\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C", "apply (auto intro!: mult_nonneg_nonneg sum_nonneg sum.mono_neutral_left elim!: negE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>} =\n  ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` (I \\<inter> L)) \\<omega> \\<and>\n    nxt (HLD (Mix ` C)) \\<omega>} =\n  ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have \"?P Start (Init`I \\<cdot> ?U) = (\\<Sum>i\\<in>I. ?P (Init i) ?U * p_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} =\n    (\\<Sum>i\\<in>I.\n       emeasure (T (Init i))\n        {\\<omega> \\<in> space (T (Init i)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} *\n       ennreal (p_i i))", "using I"], ["proof (prove)\nusing this:\n  I \\<subseteq> H\n\ngoal (1 subgoal):\n 1. emeasure \\<PP>\n     {\\<omega> \\<in> space \\<PP>.\n      HLD (Init ` I) \\<omega> \\<and>\n      nxt (HLD (Mix ` H) suntil\n           (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} =\n    (\\<Sum>i\\<in>I.\n       emeasure (T (Init i))\n        {\\<omega> \\<in> space (T (Init i)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} *\n       ennreal (p_i i))", "by (subst emeasure_HLD_nxt, simp)\n       (auto simp: nn_integral_indicator_finite sum.reindex emeasure_measure_pmf_finite\n             intro!: sum.cong[OF refl])"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} =\n  (\\<Sum>i\\<in>I.\n     emeasure (T (Init i))\n      {\\<omega> \\<in> space (T (Init i)).\n       (HLD (Mix ` H) suntil\n        (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n        \\<omega>} *\n     ennreal (p_i i))\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    HLD (Init ` I) \\<omega> \\<and>\n    nxt (HLD (Mix ` H) suntil\n         (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} =\n  (\\<Sum>i\\<in>I.\n     emeasure (T (Init i))\n      {\\<omega> \\<in> space (T (Init i)).\n       (HLD (Mix ` H) suntil\n        (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n        \\<omega>} *\n     ennreal (p_i i))\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "have \"\\<dots> = (\\<Sum>i\\<in>I. ennreal (p_f * (1 - p_H) * p_j * card L / (1 - p_H * p_f)) * p_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>I.\n       emeasure (T (Init i))\n        {\\<omega> \\<in> space (T (Init i)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} *\n       ennreal (p_i i)) =\n    (\\<Sum>i\\<in>I.\n       ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f)) *\n       ennreal (p_i i))", "proof (intro sum.cong refl arg_cong2[where f=\"(*)\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       emeasure (T (Init x))\n        {\\<omega> \\<in> space (T (Init x)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} =\n       ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       emeasure (T (Init x))\n        {\\<omega> \\<in> space (T (Init x)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} =\n       ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "assume \"i \\<in> I\""], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       emeasure (T (Init x))\n        {\\<omega> \\<in> space (T (Init x)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} =\n       ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "with I"], ["proof (chain)\npicking this:\n  I \\<subseteq> H\n  i \\<in> I", "have i: \"i \\<in> H\""], ["proof (prove)\nusing this:\n  I \\<subseteq> H\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. i \\<in> H", "by auto"], ["proof (state)\nthis:\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       emeasure (T (Init x))\n        {\\<omega> \\<in> space (T (Init x)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} =\n       ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "have \"?P (Mix i) ?U = (p_f * p_f * (1 - p_H) * p_j * card L / (1 - p_H * p_f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (Mix i))\n     {\\<omega> \\<in> space (T (Mix i)).\n      (HLD (Mix ` H) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} =\n    ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "unfolding before_C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T (Mix i))\n     {\\<omega> \\<in> space (T (Mix i)).\n      (HLD (Mix ` H) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} =\n    ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "proof (rule emeasure_suntil_geometric[where X=\"?M\"])"], ["proof (state)\ngoal (8 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. Mix i \\<in> Mix ` H\n 3. 0 \\<le> p_H * p_f\n 4. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n       ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))\n 6. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 7. p_H * p_f < 1\n 8. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "show \"Mix i \\<in> ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mix i \\<in> Mix ` H", "using i"], ["proof (prove)\nusing this:\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. Mix i \\<in> Mix ` H", "by auto"], ["proof (state)\nthis:\n  Mix i \\<in> Mix ` H\n\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n       ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 6. p_H * p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n       ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 6. p_H * p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "fix s"], ["proof (state)\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n       ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 6. p_H * p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "assume \"s \\<in> ?M\""], ["proof (state)\nthis:\n  s \\<in> Mix ` H\n\ngoal (7 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (T s)\n        {\\<omega> \\<in> space (T s).\n         HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n       ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))\n 5. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 6. p_H * p_f < 1\n 7. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "with p_f p_j_pos L C_smaller[THEN less_imp_le]"], ["proof (chain)\npicking this:\n  0 < p_f\n  p_f < 1\n  0 < p_j\n  L \\<subseteq> H\n  C \\<subseteq> J\n  s \\<in> Mix ` H", "show \"?P s (Mix`L \\<cdot> (HLD (Mix ` C))) = ennreal (p_f * p_f * (1 - p_H) * p_j * card L)\""], ["proof (prove)\nusing this:\n  0 < p_f\n  p_f < 1\n  0 < p_j\n  L \\<subseteq> H\n  C \\<subseteq> J\n  s \\<in> Mix ` H\n\ngoal (1 subgoal):\n 1. emeasure (T s)\n     {\\<omega> \\<in> space (T s).\n      HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n    ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))", "apply (simp add: emeasure_HLD emeasure_HLD_nxt del: nxt.simps space_T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < p_f; p_f < 1; 0 < p_j; L \\<subseteq> H; C \\<subseteq> J;\n     s \\<in> Mix ` H\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+x\\<in>Mix ` L.\n   emeasure (measure_pmf (N x)) (Mix ` C)\n                      \\<partial>measure_pmf (N s) =\n                      ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))", "apply (subst nn_integral_measure_pmf_support[of \"Mix`L\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>0 < p_f; p_f < 1; 0 < p_j; L \\<subseteq> H; C \\<subseteq> J;\n     s \\<in> Mix ` H\\<rbrakk>\n    \\<Longrightarrow> finite (Mix ` L)\n 2. \\<And>x.\n       \\<lbrakk>0 < p_f; p_f < 1; 0 < p_j; L \\<subseteq> H; C \\<subseteq> J;\n        s \\<in> Mix ` H; x \\<in> Mix ` L\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> emeasure (measure_pmf (N x)) (Mix ` C) *\n                                 indicator (Mix ` L) x\n 3. \\<And>x.\n       \\<lbrakk>0 < p_f; p_f < 1; 0 < p_j; L \\<subseteq> H; C \\<subseteq> J;\n        s \\<in> Mix ` H; x \\<in> E s; x \\<notin> Mix ` L\\<rbrakk>\n       \\<Longrightarrow> emeasure (measure_pmf (N x)) (Mix ` C) *\n                         indicator (Mix ` L) x =\n                         0\n 4. \\<lbrakk>0 < p_f; p_f < 1; 0 < p_j; L \\<subseteq> H; C \\<subseteq> J;\n     s \\<in> Mix ` H\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>Mix ` L.\n                         emeasure (measure_pmf (N x)) (Mix ` C) *\n                         indicator (Mix ` L) x *\n                         ennreal (pmf (N s) x)) =\n                      ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))", "apply (auto simp add: subset_eq emeasure_measure_pmf_finite sum.reindex H_compl p_j_def\n          ennreal_mult[symmetric] ennreal_of_nat_eq_real_of_nat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (T s)\n   {\\<omega> \\<in> space (T s).\n    HLD (Mix ` L) \\<omega> \\<and> nxt (HLD (Mix ` C)) \\<omega>} =\n  ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L))\n\ngoal (6 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 5. p_H * p_f < 1\n 6. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 5. p_H * p_f < 1\n 6. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "fix s"], ["proof (state)\ngoal (6 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 5. p_H * p_f < 1\n 6. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "assume \"s \\<in> ?M\""], ["proof (state)\nthis:\n  s \\<in> Mix ` H\n\ngoal (6 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. \\<And>s.\n       s \\<in> Mix ` H \\<Longrightarrow>\n       emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n 5. p_H * p_f < 1\n 6. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "then"], ["proof (chain)\npicking this:\n  s \\<in> Mix ` H", "show \"emeasure (N s) ?M = ennreal (p_H * p_f)\""], ["proof (prove)\nusing this:\n  s \\<in> Mix ` H\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)", "by (auto simp add: emeasure_measure_pmf_finite sum.reindex H_eq2)"], ["proof (state)\nthis:\n  emeasure (measure_pmf (N s)) (Mix ` H) = ennreal (p_H * p_f)\n\ngoal (5 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. p_H * p_f < 1\n 5. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. p_H * p_f < 1\n 5. \\<And>t.\n       AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                   (HLD (Mix ` H) \\<sqinter>\n                                    nxt (HLD (Mix ` H) suntil\n   (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                   \\<omega>", "show \"AE \\<omega> in T t. \\<not> ((Mix ` L \\<cdot> ?L) \\<sqinter> (HLD (Mix ` H) \\<sqinter> nxt ?U)) \\<omega>\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                (HLD (Mix ` H) \\<sqinter>\n                                 nxt (HLD (Mix ` H) suntil\n(\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                \\<omega>", "using L"], ["proof (prove)\nusing this:\n  L \\<subseteq> H\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T t. \\<not> ((\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                (HLD (Mix ` H) \\<sqinter>\n                                 nxt (HLD (Mix ` H) suntil\n(\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                \\<omega>", "apply (simp add: AE_T_iff[of _ t])"], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> H \\<Longrightarrow>\n    \\<forall>y\\<in>E t.\n       AE \\<omega> in T y. y \\<in> Mix ` H \\<longrightarrow>\n                           HLD (Mix ` C) \\<omega> \\<longrightarrow>\n                           y \\<in> Mix ` L \\<longrightarrow>\n                           \\<not> (HLD (Mix ` H) suntil\n                                   (\\<lambda>xs.\n HLD (Mix ` L) xs \\<and> HLD (Mix ` C) (stl xs)))\n                                   \\<omega>", "apply (subst AE_T_iff; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<subseteq> H \\<Longrightarrow>\n    \\<forall>y\\<in>E t.\n       \\<forall>ya\\<in>E y.\n          AE \\<omega> in T ya. y \\<in> Mix ` H \\<longrightarrow>\n                               ya \\<in> Mix ` C \\<longrightarrow>\n                               y \\<in> Mix ` L \\<longrightarrow>\n                               \\<not> (HLD (Mix ` H) suntil\n (\\<lambda>xs. HLD (Mix ` L) xs \\<and> HLD (Mix ` C) (stl xs)))\n (ya ## \\<omega>)", "apply (auto simp: HLD_iff suntil_Stream)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  AE \\<omega> in T ?t1. \\<not> ((\\<lambda>xs.\n                                    HLD (Mix ` L) xs \\<and>\n                                    nxt (HLD (Mix ` C)) xs) \\<sqinter>\n                                (HLD (Mix ` H) \\<sqinter>\n                                 nxt (HLD (Mix ` H) suntil\n(\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))))\n                                \\<omega>\n\ngoal (4 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs)\n 2. 0 \\<le> p_H * p_f\n 3. 0 \\<le> p_f * p_f * (1 - p_H) * p_j * real (card L)\n 4. p_H * p_f < 1", "qed (insert L, auto simp: p_H_p_f_less_1 E_Mix)"], ["proof (state)\nthis:\n  emeasure (T (Mix i))\n   {\\<omega> \\<in> space (T (Mix i)).\n    (HLD (Mix ` H) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} =\n  ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       emeasure (T (Init x))\n        {\\<omega> \\<in> space (T (Init x)).\n         (HLD (Mix ` H) suntil\n          (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n          \\<omega>} =\n       ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "then"], ["proof (chain)\npicking this:\n  emeasure (T (Mix i))\n   {\\<omega> \\<in> space (T (Mix i)).\n    (HLD (Mix ` H) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} =\n  ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "show \"?P (Init i) ?U = p_f * (1 - p_H) * p_j * card L / (1 - p_H * p_f)\""], ["proof (prove)\nusing this:\n  emeasure (T (Mix i))\n   {\\<omega> \\<in> space (T (Mix i)).\n    (HLD (Mix ` H) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} =\n  ennreal (p_f * p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))\n\ngoal (1 subgoal):\n 1. emeasure (T (Init i))\n     {\\<omega> \\<in> space (T (Init i)).\n      (HLD (Mix ` H) suntil\n       (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n       \\<omega>} =\n    ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))", "by (subst emeasure_Init_eq_Mix)\n         (auto simp: AE_End suntil_Stream divide_ennreal mult_le_one p_f)"], ["proof (state)\nthis:\n  emeasure (T (Init i))\n   {\\<omega> \\<in> space (T (Init i)).\n    (HLD (Mix ` H) suntil\n     (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n     \\<omega>} =\n  ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>I.\n     emeasure (T (Init i))\n      {\\<omega> \\<in> space (T (Init i)).\n       (HLD (Mix ` H) suntil\n        (\\<lambda>xs. HLD (Mix ` L) xs \\<and> nxt (HLD (Mix ` C)) xs))\n        \\<omega>} *\n     ennreal (p_i i)) =\n  (\\<Sum>i\\<in>I.\n     ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f)) *\n     ennreal (p_i i))\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "finally"], ["proof (chain)\npicking this:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  (\\<Sum>i\\<in>I.\n     ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f)) *\n     ennreal (p_i i)) +\n  ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))", "have *: \"\\<P>(\\<omega> in T Start. ?V \\<omega>) =\n      (p_f * (1 - p_H) * p_j * (card L) / (1 - p_H * p_f)) * (\\<Sum>i\\<in>I. p_i i) +\n      (\\<Sum>i\\<in>I \\<inter> L. p_i i) * (1 - p_H)\""], ["proof (prove)\nusing this:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  (\\<Sum>i\\<in>I.\n     ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f)) *\n     ennreal (p_i i)) +\n  ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))\n\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n    sum p_i (I \\<inter> L) * (1 - p_H)", "using sum_nonneg [of \"I \\<inter> L\" p_i]  sum_nonneg [of \"I\" p_i]"], ["proof (prove)\nusing this:\n  emeasure \\<PP>\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  (\\<Sum>i\\<in>I.\n     ennreal (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f)) *\n     ennreal (p_i i)) +\n  ennreal (\\<Sum>i\\<in>I \\<inter> L. p_i i * (1 - p_H))\n  (\\<And>x.\n      x \\<in> I \\<inter> L \\<Longrightarrow>\n      0 \\<le> p_i x) \\<Longrightarrow>\n  0 \\<le> sum p_i (I \\<inter> L)\n  (\\<And>x. x \\<in> I \\<Longrightarrow> 0 \\<le> p_i x) \\<Longrightarrow>\n  0 \\<le> sum p_i I\n\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n    sum p_i (I \\<inter> L) * (1 - p_H)", "by (simp add: mult_ac measure_def sum_distrib_right[symmetric] sum_distrib_left[symmetric]\n                  sum_divide_distrib[symmetric] IJ ennreal_mult[symmetric] \n                  mult_le_one ennreal_plus[symmetric]\n             del: ennreal_plus)"], ["proof (state)\nthis:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n  sum p_i (I \\<inter> L) * (1 - p_H)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "unfolding cond_prob_def Pr_hit_C *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n     sum p_i (I \\<inter> L) * (1 - p_H)) /\n    ((1 - p_H) / (1 - p_H * p_f)) =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "using *"], ["proof (prove)\nusing this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n  sum p_i (I \\<inter> L) * (1 - p_H)\n\ngoal (1 subgoal):\n 1. (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n     sum p_i (I \\<inter> L) * (1 - p_H)) /\n    ((1 - p_H) / (1 - p_H * p_f)) =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "using p_f p_H p_j_pos p_H_p_f_less_1"], ["proof (prove)\nusing this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit I J \\<omega> \\<and> before_C L \\<omega>) \\<and> hit_C \\<omega>} =\n  p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n  sum p_i (I \\<inter> L) * (1 - p_H)\n  0 < p_f\n  p_f < 1\n  0 < p_H\n  p_H < 1\n  0 < p_j\n  p_H * p_f < 1\n\ngoal (1 subgoal):\n 1. (p_f * (1 - p_H) * p_j * real (card L) / (1 - p_H * p_f) * sum p_i I +\n     sum p_i (I \\<inter> L) * (1 - p_H)) /\n    ((1 - p_H) / (1 - p_H * p_f)) =\n    sum p_i I * real (card L) * p_j * p_f +\n    sum p_i (I \\<inter> L) * (1 - p_H * p_f)", "by (simp add: divide_simps) (simp add: field_simps)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C L \\<omega>)\n   hit_C =\n  sum p_i I * real (card L) * p_j * p_f +\n  sum p_i (I \\<inter> L) * (1 - p_H * p_f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pr_visit_eq_before_C:\n  \"\\<P>(\\<omega> in \\<PP>. \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega> \\<bar> hit_C \\<omega> ) = 1 - (p_H - p_j) * p_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "let ?V = \"\\<lambda>j. visit {j} J aand before_C {j}\" and ?H = \"hit_C\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "let ?J = \"H\""], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "have \"\\<P>(\\<omega> in \\<PP>. (\\<exists>j\\<in>?J. ?V j \\<omega>) \\<and> ?H \\<omega>) = (\\<Sum>j\\<in>?J. \\<P>(\\<omega> in \\<PP>. (?V j aand ?H) \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      (\\<exists>j\\<in>H.\n          visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    (\\<Sum>j\\<in>H.\n       T.prob Start\n        {\\<omega> \\<in> space \\<PP>.\n         (visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n         hit_C \\<omega>})", "proof (rule T.prob_sum)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite H\n 2. \\<And>j.\n       j \\<in> H \\<Longrightarrow>\n       {\\<omega> \\<in> space \\<PP>.\n        (visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n        hit_C \\<omega>}\n       \\<in> T.events Start\n 3. {\\<omega> \\<in> space \\<PP>.\n     (\\<exists>j\\<in>H.\n         visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n     hit_C \\<omega>}\n    \\<in> T.events Start\n 4. AE \\<omega> in \\<PP>. (\\<forall>j\\<in>H.\n                              (visit {j} J \\<omega> \\<and>\n                               before_C {j} \\<omega>) \\<and>\n                              hit_C \\<omega> \\<longrightarrow>\n                              (\\<exists>j\\<in>H.\n                                  visit {j} J \\<omega> \\<and>\n                                  before_C {j} \\<omega>) \\<and>\n                              hit_C \\<omega>) \\<and>\n                          ((\\<exists>j\\<in>H.\n                               visit {j} J \\<omega> \\<and>\n                               before_C {j} \\<omega>) \\<and>\n                           hit_C \\<omega> \\<longrightarrow>\n                           (\\<exists>!j.\n                               j \\<in> H \\<and>\n                               (visit {j} J \\<omega> \\<and>\n                                before_C {j} \\<omega>) \\<and>\n                               hit_C \\<omega>))", "show \"AE \\<omega> in \\<PP>. (\\<forall>j\\<in>?J. (?V j aand ?H) \\<omega> \\<longrightarrow> ((\\<exists>j\\<in>?J. ?V j \\<omega>) \\<and> ?H \\<omega>)) \\<and>\n      (((\\<exists>j\\<in>?J. ?V j \\<omega>) \\<and> ?H \\<omega>) \\<longrightarrow> (\\<exists>!j. j\\<in>?J \\<and> (?V j aand ?H) \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. (\\<forall>j\\<in>H.\n                              (visit {j} J \\<omega> \\<and>\n                               before_C {j} \\<omega>) \\<and>\n                              hit_C \\<omega> \\<longrightarrow>\n                              (\\<exists>j\\<in>H.\n                                  visit {j} J \\<omega> \\<and>\n                                  before_C {j} \\<omega>) \\<and>\n                              hit_C \\<omega>) \\<and>\n                          ((\\<exists>j\\<in>H.\n                               visit {j} J \\<omega> \\<and>\n                               before_C {j} \\<omega>) \\<and>\n                           hit_C \\<omega> \\<longrightarrow>\n                           (\\<exists>!j.\n                               j \\<in> H \\<and>\n                               (visit {j} J \\<omega> \\<and>\n                                before_C {j} \\<omega>) \\<and>\n                               hit_C \\<omega>))", "by (auto intro!: AE_I2 dest: visit_unique1)"], ["proof (state)\nthis:\n  AE \\<omega> in \\<PP>. (\\<forall>j\\<in>H.\n                            (visit {j} J \\<omega> \\<and>\n                             before_C {j} \\<omega>) \\<and>\n                            hit_C \\<omega> \\<longrightarrow>\n                            (\\<exists>j\\<in>H.\n                                visit {j} J \\<omega> \\<and>\n                                before_C {j} \\<omega>) \\<and>\n                            hit_C \\<omega>) \\<and>\n                        ((\\<exists>j\\<in>H.\n                             visit {j} J \\<omega> \\<and>\n                             before_C {j} \\<omega>) \\<and>\n                         hit_C \\<omega> \\<longrightarrow>\n                         (\\<exists>!j.\n                             j \\<in> H \\<and>\n                             (visit {j} J \\<omega> \\<and>\n                              before_C {j} \\<omega>) \\<and>\n                             hit_C \\<omega>))\n\ngoal (3 subgoals):\n 1. finite H\n 2. \\<And>j.\n       j \\<in> H \\<Longrightarrow>\n       {\\<omega> \\<in> space \\<PP>.\n        (visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n        hit_C \\<omega>}\n       \\<in> T.events Start\n 3. {\\<omega> \\<in> space \\<PP>.\n     (\\<exists>j\\<in>H.\n         visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n     hit_C \\<omega>}\n    \\<in> T.events Start", "qed auto"], ["proof (state)\nthis:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (\\<exists>j\\<in>H.\n        visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  (\\<Sum>j\\<in>H.\n     T.prob Start\n      {\\<omega> \\<in> space \\<PP>.\n       (visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n       hit_C \\<omega>})\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "then"], ["proof (chain)\npicking this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (\\<exists>j\\<in>H.\n        visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  (\\<Sum>j\\<in>H.\n     T.prob Start\n      {\\<omega> \\<in> space \\<PP>.\n       (visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n       hit_C \\<omega>})", "have \"\\<P>(\\<omega> in \\<PP>. (\\<exists>j\\<in>?J. ?V j \\<omega>) \\<bar> ?H \\<omega>) = (\\<Sum>j\\<in>?J. \\<P>(\\<omega> in \\<PP>. ?V j \\<omega> \\<bar> ?H \\<omega>))\""], ["proof (prove)\nusing this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (\\<exists>j\\<in>H.\n        visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  (\\<Sum>j\\<in>H.\n     T.prob Start\n      {\\<omega> \\<in> space \\<PP>.\n       (visit {j} J \\<omega> \\<and> before_C {j} \\<omega>) \\<and>\n       hit_C \\<omega>})\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    (\\<Sum>j\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n        hit_C)", "by (simp add: cond_prob_def sum_divide_distrib)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>.\n       \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n   hit_C =\n  (\\<Sum>j\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n      hit_C)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "also"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>.\n       \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n   hit_C =\n  (\\<Sum>j\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n      hit_C)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "have \"\\<dots> = p_j * p_f + (1 - p_H * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n        hit_C) =\n    p_j * p_f + (1 - p_H * p_f)", "by (simp add: Pr_visit_before_C sum_distrib_right[symmetric] sum.distrib)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n      hit_C) =\n  p_j * p_f + (1 - p_H * p_f)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "finally"], ["proof (chain)\npicking this:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>.\n       \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n   hit_C =\n  p_j * p_f + (1 - p_H * p_f)", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>.\n       \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n   hit_C =\n  p_j * p_f + (1 - p_H * p_f)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C =\n    1 - (p_H - p_j) * p_f", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>.\n       \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n   hit_C =\n  1 - (p_H - p_j) * p_f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma probably_innocent:\n  assumes approx: \"1 / (2 * (p_H - p_j)) \\<le> p_f\" and \"p_H \\<noteq> p_j\"\n  shows \"\\<P>(\\<omega> in \\<PP>. \\<exists>j\\<in>H. visit {j} J \\<omega> \\<and> before_C {j} \\<omega> \\<bar> hit_C \\<omega> ) \\<le> 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         \\<exists>j\\<in>H.\n            visit {j} J \\<omega> \\<and> before_C {j} \\<omega>)\n     hit_C\n    \\<le> 1 / 2", "unfolding Pr_visit_eq_before_C"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "have [simp]: \"\\<And>n :: nat. 1 \\<le> real n \\<longleftrightarrow> 1 \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. (1 \\<le> real n) = (1 \\<le> n)", "by auto"], ["proof (state)\nthis:\n  (1 \\<le> real ?n1) = (1 \\<le> ?n1)\n\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "have \"0 \\<le> p_j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p_j", "unfolding p_j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1 / real (card J)", "by auto"], ["proof (state)\nthis:\n  0 \\<le> p_j\n\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "then"], ["proof (chain)\npicking this:\n  0 \\<le> p_j", "have \"1 * p_j \\<le> p_H\""], ["proof (prove)\nusing this:\n  0 \\<le> p_j\n\ngoal (1 subgoal):\n 1. 1 * p_j \\<le> p_H", "unfolding H_eq2[symmetric]"], ["proof (prove)\nusing this:\n  0 \\<le> p_j\n\ngoal (1 subgoal):\n 1. 1 * p_j \\<le> real (card H) * p_j", "using C_smaller"], ["proof (prove)\nusing this:\n  0 \\<le> p_j\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. 1 * p_j \\<le> real (card H) * p_j", "by (intro mult_mono) (auto simp: Suc_le_eq card_Diff_subset not_le)"], ["proof (state)\nthis:\n  1 * p_j \\<le> p_H\n\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "with \\<open>p_H \\<noteq> p_j\\<close>"], ["proof (chain)\npicking this:\n  p_H \\<noteq> p_j\n  1 * p_j \\<le> p_H", "have \"p_j < p_H\""], ["proof (prove)\nusing this:\n  p_H \\<noteq> p_j\n  1 * p_j \\<le> p_H\n\ngoal (1 subgoal):\n 1. p_j < p_H", "by auto"], ["proof (state)\nthis:\n  p_j < p_H\n\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "with approx"], ["proof (chain)\npicking this:\n  1 / (2 * (p_H - p_j)) \\<le> p_f\n  p_j < p_H", "show \"1 - (p_H - p_j) * p_f \\<le> 1 / 2\""], ["proof (prove)\nusing this:\n  1 / (2 * (p_H - p_j)) \\<le> p_f\n  p_j < p_H\n\ngoal (1 subgoal):\n 1. 1 - (p_H - p_j) * p_f \\<le> 1 / 2", "by (auto simp add: field_simps divide_le_eq split: if_split_asm)"], ["proof (state)\nthis:\n  1 - (p_H - p_j) * p_f \\<le> 1 / 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Pr_before_C:\n  assumes L: \"L \\<subseteq> H\"\n  shows \"\\<P>(\\<omega> in \\<PP>. before_C L \\<omega> \\<bar> hit_C \\<omega> ) =\n    card L * p_j * p_f + (\\<Sum>l\\<in>L. p_i l) * (1 - p_H * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "have \"\\<P>(\\<omega> in \\<PP>. before_C L \\<omega> \\<bar> hit_C \\<omega> ) =\n    \\<P>(\\<omega> in \\<PP>. visit H J \\<omega> \\<and> before_C L \\<omega> \\<bar> hit_C \\<omega> )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C", "using AE_visit"], ["proof (prove)\nusing this:\n  almost_everywhere \\<PP> (visit H J)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C", "by (auto intro!: T.cond_prob_eq_AE)"], ["proof (state)\nthis:\n  cond_prob \\<PP> (before_C L) hit_C =\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>) hit_C\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "also"], ["proof (state)\nthis:\n  cond_prob \\<PP> (before_C L) hit_C =\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>) hit_C\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "have \"\\<dots> = card L * p_j * p_f + (\\<Sum>i\\<in>L. p_i i) * (1 - p_H * p_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "using L"], ["proof (prove)\nusing this:\n  L \\<subseteq> H\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>)\n     hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "by (subst Pr_visit_before_C[OF L order_refl]) (auto simp: Int_absorb1)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit H J \\<omega> \\<and> before_C L \\<omega>)\n   hit_C =\n  real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "finally"], ["proof (chain)\npicking this:\n  cond_prob \\<PP> (before_C L) hit_C =\n  real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_prob \\<PP> (before_C L) hit_C =\n  real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (before_C L) hit_C =\n    real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)", "."], ["proof (state)\nthis:\n  cond_prob \\<PP> (before_C L) hit_C =\n  real (card L) * p_j * p_f + sum p_i L * (1 - p_H * p_f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P_visit:\n  assumes I: \"I \\<subseteq> H\"\n  shows \"\\<P>(\\<omega> in \\<PP>. visit I J \\<omega> \\<bar> hit_C \\<omega> ) = (\\<Sum>i\\<in>I. p_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "have \"\\<P>(\\<omega> in \\<PP>. visit I J \\<omega> \\<bar> hit_C \\<omega> ) =\n    \\<P>(\\<omega> in \\<PP>. visit I J \\<omega> \\<and> before_C H \\<omega> \\<bar> hit_C \\<omega> )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C =\n    cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C H \\<omega>)\n     hit_C", "proof (rule T.cond_prob_eq_AE)"], ["proof (state)\ngoal (6 subgoals):\n 1. AE x in \\<PP>. hit_C x \\<longrightarrow>\n                   visit I J x = (visit I J x \\<and> before_C H x)\n 2. {x \\<in> space \\<PP>. visit I J x} \\<in> T.events Start\n 3. {x \\<in> space \\<PP>. visit I J x \\<and> before_C H x}\n    \\<in> T.events Start\n 4. AE x in \\<PP>. hit_C x = hit_C x\n 5. {x \\<in> space \\<PP>. hit_C x} \\<in> T.events Start\n 6. {x \\<in> space \\<PP>. hit_C x} \\<in> T.events Start", "show \"AE x in \\<PP>. hit_C x \\<longrightarrow>\n                visit I J x = (visit I J x \\<and> before_C H x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE x in \\<PP>. hit_C x \\<longrightarrow>\n                   visit I J x = (visit I J x \\<and> before_C H x)", "using AE_T_enabled"], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (enabled ?s)\n\ngoal (1 subgoal):\n 1. AE x in \\<PP>. hit_C x \\<longrightarrow>\n                   visit I J x = (visit I J x \\<and> before_C H x)", "by eventually_elim (auto intro: hit_C_imp_before_C)"], ["proof (state)\nthis:\n  AE x in \\<PP>. hit_C x \\<longrightarrow>\n                 visit I J x = (visit I J x \\<and> before_C H x)\n\ngoal (5 subgoals):\n 1. {x \\<in> space \\<PP>. visit I J x} \\<in> T.events Start\n 2. {x \\<in> space \\<PP>. visit I J x \\<and> before_C H x}\n    \\<in> T.events Start\n 3. AE x in \\<PP>. hit_C x = hit_C x\n 4. {x \\<in> space \\<PP>. hit_C x} \\<in> T.events Start\n 5. {x \\<in> space \\<PP>. hit_C x} \\<in> T.events Start", "qed auto"], ["proof (state)\nthis:\n  cond_prob \\<PP> (visit I J) hit_C =\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C H \\<omega>) hit_C\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "also"], ["proof (state)\nthis:\n  cond_prob \\<PP> (visit I J) hit_C =\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C H \\<omega>) hit_C\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "have \"\\<dots> = sum p_i I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C H \\<omega>)\n     hit_C =\n    sum p_i I", "using I"], ["proof (prove)\nusing this:\n  I \\<subseteq> H\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C H \\<omega>)\n     hit_C =\n    sum p_i I", "by (subst Pr_visit_before_C[OF order_refl]) (auto simp: Int_absorb2 field_simps p_H_def p_j_def)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit I J \\<omega> \\<and> before_C H \\<omega>)\n   hit_C =\n  sum p_i I\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "finally"], ["proof (chain)\npicking this:\n  cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "show ?thesis"], ["proof (prove)\nusing this:\n  cond_prob \\<PP> (visit I J) hit_C = sum p_i I\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP> (visit I J) hit_C = sum p_i I", "."], ["proof (state)\nthis:\n  cond_prob \\<PP> (visit I J) hit_C = sum p_i I\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Probability space of hitting a collaborator\\<close>"], ["", "definition \"hC = uniform_measure \\<PP> {\\<omega>\\<in>space \\<PP>. hit_C \\<omega>}\""], ["", "lemma emeasure_hit_C_not_0: \"emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} \\<noteq> 0", "using p_H p_H_p_f_less_1"], ["proof (prove)\nusing this:\n  0 < p_H\n  p_H < 1\n  p_H * p_f < 1\n\ngoal (1 subgoal):\n 1. emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} \\<noteq> 0", "unfolding Pr_hit_C T.emeasure_eq_measure"], ["proof (prove)\nusing this:\n  0 < p_H\n  p_H < 1\n  p_H * p_f < 1\n\ngoal (1 subgoal):\n 1. ennreal ((1 - p_H) / (1 - p_H * p_f)) \\<noteq> 0", "by auto"], ["", "lemma measurable_hC[measurable (raw)]:\n  \"A \\<in> sets S \\<Longrightarrow> A \\<in> sets hC\"\n  \"f \\<in> measurable M S \\<Longrightarrow> f \\<in> measurable M hC\"\n  \"g \\<in> measurable S M \\<Longrightarrow> g \\<in> measurable hC M\"\n  \"A \\<inter> space S \\<in> sets S \\<Longrightarrow> A \\<inter> space hC \\<in> sets S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n      A \\<in> sets hC) &&&\n     (f \\<in> M \\<rightarrow>\\<^sub>M\n              stream_space (count_space UNIV) \\<Longrightarrow>\n      f \\<in> M \\<rightarrow>\\<^sub>M hC)) &&&\n    (g \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             M \\<Longrightarrow>\n     g \\<in> hC \\<rightarrow>\\<^sub>M M) &&&\n    (A \\<inter> space (stream_space (count_space UNIV))\n     \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n     A \\<inter> space hC \\<in> sets (stream_space (count_space UNIV)))", "unfolding hC_def uniform_measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n      A \\<in> sets\n               (density \\<PP>\n                 (\\<lambda>x.\n                     indicator {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}\n                      x /\n                     emeasure \\<PP>\n                      {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}))) &&&\n     (f \\<in> M \\<rightarrow>\\<^sub>M\n              stream_space (count_space UNIV) \\<Longrightarrow>\n      f \\<in> M \\<rightarrow>\\<^sub>M\n              density \\<PP>\n               (\\<lambda>x.\n                   indicator {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}\n                    x /\n                   emeasure \\<PP>\n                    {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}))) &&&\n    (g \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n             M \\<Longrightarrow>\n     g \\<in> density \\<PP>\n              (\\<lambda>x.\n                  indicator {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} x /\n                  emeasure \\<PP>\n                   {\\<omega> \\<in> space \\<PP>.\n                    hit_C \\<omega>}) \\<rightarrow>\\<^sub>M\n             M) &&&\n    (A \\<inter> space (stream_space (count_space UNIV))\n     \\<in> sets (stream_space (count_space UNIV)) \\<Longrightarrow>\n     A \\<inter>\n     space\n      (density \\<PP>\n        (\\<lambda>x.\n            indicator {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} x /\n            emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}))\n     \\<in> sets (stream_space (count_space UNIV)))", "by simp_all"], ["", "lemma vimage_Int_space_C[simp]:\n  \"f -` {x} \\<inter> space hC = {\\<omega>\\<in>space S. f \\<omega> = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f -` {x} \\<inter> space hC =\n    {\\<omega> \\<in> space (stream_space (count_space UNIV)). f \\<omega> = x}", "by (auto simp: hC_def)"], ["", "sublocale hC: information_space hC 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. information_space hC 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. information_space hC 2", "interpret hC: prob_space hC"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space hC", "unfolding hC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space\n     (uniform_measure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>})", "using emeasure_hit_C_not_0"], ["proof (prove)\nusing this:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prob_space\n     (uniform_measure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>})", "by (intro prob_space_uniform_measure) auto"], ["proof (state)\ngoal (1 subgoal):\n 1. information_space hC 2", "show \"information_space hC 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. information_space hC 2", "by standard simp"], ["proof (state)\nthis:\n  information_space hC 2\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation\n  mutual_information_Pow_CP (\"\\<I>'(_ ; _')\") where\n  \"\\<I>(X ; Y) \\<equiv> hC.mutual_information 2 (count_space (X`space hC)) (count_space (Y`space hC)) X Y\""], ["", "lemma simple_functionI:\n  assumes \"finite (range f)\"\n  assumes [measurable]: \"\\<And>x. {\\<omega>\\<in>space S. f \\<omega> = x} \\<in> sets S\"\n  shows \"simple_function hC f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_function hC f", "using assms"], ["proof (prove)\nusing this:\n  finite (range f)\n  {\\<omega> \\<in> space (stream_space (count_space UNIV)). f \\<omega> = ?x2}\n  \\<in> sets (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. simple_function hC f", "unfolding simple_function_def hC_def"], ["proof (prove)\nusing this:\n  finite (range f)\n  {\\<omega> \\<in> space (stream_space (count_space UNIV)). f \\<omega> = ?x2}\n  \\<in> sets (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. finite\n     (f `\n      space\n       (uniform_measure \\<PP>\n         {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>})) \\<and>\n    (\\<forall>x\\<in>f `\n                    space\n                     (uniform_measure \\<PP>\n                       {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}).\n        f -` {x} \\<inter>\n        space\n         (uniform_measure \\<PP>\n           {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>})\n        \\<in> sets\n               (uniform_measure \\<PP>\n                 {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}))", "by (simp add: vimage_def space_stream_space)"], ["", "subsection \\<open>Estimate the information to the collaborators\\<close>"], ["", "lemma measure_hC[simp]:\n  assumes A[measurable]: \"A \\<in> sets S\"\n  shows \"measure hC A = \\<P>(\\<omega> in \\<PP>. \\<omega> \\<in> A \\<bar> hit_C \\<omega> )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hC.prob A = cond_prob \\<PP> (\\<lambda>\\<omega>. \\<omega> \\<in> A) hit_C", "unfolding hC_def cond_prob_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (uniform_measure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>})\n     A =\n    T.prob Start\n     {\\<omega> \\<in> space \\<PP>. \\<omega> \\<in> A \\<and> hit_C \\<omega>} /\n    T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}", "using emeasure_hit_C_not_0 A"], ["proof (prove)\nusing this:\n  emeasure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>} \\<noteq> 0\n  A \\<in> sets (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. Sigma_Algebra.measure\n     (uniform_measure \\<PP> {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>})\n     A =\n    T.prob Start\n     {\\<omega> \\<in> space \\<PP>. \\<omega> \\<in> A \\<and> hit_C \\<omega>} /\n    T.prob Start {\\<omega> \\<in> space \\<PP>. hit_C \\<omega>}", "by (subst measure_uniform_measure) (simp_all add: T.emeasure_eq_measure Int_def conj_ac)"], ["", "subsubsection \\<open>Setup random variables for mutual information\\<close>"], ["", "definition \"first_J \\<omega> = (THE i. visit {i} J \\<omega>)\""], ["", "lemma first_J_eq:\n  \"visit {i} J \\<omega> \\<Longrightarrow> first_J \\<omega> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. visit {i} J \\<omega> \\<Longrightarrow> first_J \\<omega> = i", "unfolding first_J_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. visit {i} J \\<omega> \\<Longrightarrow> (THE i. visit {i} J \\<omega>) = i", "by (intro the_equality) (auto dest: visit_unique1)"], ["", "lemma AE_first_J:\n  \"AE \\<omega> in \\<PP>. visit {i} J \\<omega> \\<longleftrightarrow> first_J \\<omega> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. visit {i} J \\<omega> = (first_J \\<omega> = i)", "using AE_visit"], ["proof (prove)\nusing this:\n  almost_everywhere \\<PP> (visit H J)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. visit {i} J \\<omega> = (first_J \\<omega> = i)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       visit H J \\<omega> \\<Longrightarrow>\n       visit {i} J \\<omega> = (first_J \\<omega> = i)", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       visit H J \\<omega> \\<Longrightarrow>\n       visit {i} J \\<omega> = (first_J \\<omega> = i)", "assume \"visit H J \\<omega>\""], ["proof (state)\nthis:\n  visit H J \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       visit H J \\<omega> \\<Longrightarrow>\n       visit {i} J \\<omega> = (first_J \\<omega> = i)", "then"], ["proof (chain)\npicking this:\n  visit H J \\<omega>", "obtain j where \"visit {j} J \\<omega>\" \"j \\<in> H\""], ["proof (prove)\nusing this:\n  visit H J \\<omega>\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>visit {j} J \\<omega>; j \\<in> H\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: visit_def HLD_iff)"], ["proof (state)\nthis:\n  visit {j} J \\<omega>\n  j \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       visit H J \\<omega> \\<Longrightarrow>\n       visit {i} J \\<omega> = (first_J \\<omega> = i)", "then"], ["proof (chain)\npicking this:\n  visit {j} J \\<omega>\n  j \\<in> H", "show \"visit {i} J \\<omega> \\<longleftrightarrow> first_J \\<omega> = i\""], ["proof (prove)\nusing this:\n  visit {j} J \\<omega>\n  j \\<in> H\n\ngoal (1 subgoal):\n 1. visit {i} J \\<omega> = (first_J \\<omega> = i)", "by (auto dest: visit_unique1 first_J_eq)"], ["proof (state)\nthis:\n  visit {i} J \\<omega> = (first_J \\<omega> = i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measurbale_first_J[measurable]: \"first_J \\<in> measurable S (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_J\n    \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          count_space UNIV", "unfolding first_J_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>. THE i. visit {i} J \\<omega>)\n    \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          count_space UNIV", "by (intro measurable_THE[where I=H])\n     (auto dest: visit_imp_in_H visit_unique1 intro: countable_finite)"], ["", "definition \"last_H \\<omega> = (THE i. before_C {i} \\<omega>)\""], ["", "lemma measurbale_last_H[measurable]: \"last_H \\<in> measurable S (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_H\n    \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          count_space UNIV", "unfolding last_H_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<omega>. THE i. before_C {i} \\<omega>)\n    \\<in> stream_space (count_space UNIV) \\<rightarrow>\\<^sub>M\n          count_space UNIV", "by (intro measurable_THE[where I=H])\n     (auto dest: before_C_single before_C_unique intro: countable_finite)"], ["", "lemma last_H_eq:\n  \"before_C {i} \\<omega> \\<Longrightarrow> last_H \\<omega> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before_C {i} \\<omega> \\<Longrightarrow> last_H \\<omega> = i", "unfolding last_H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. before_C {i} \\<omega> \\<Longrightarrow>\n    (THE i. before_C {i} \\<omega>) = i", "by (intro the_equality) (auto dest: before_C_unique)"], ["", "lemma last_H:\n  assumes \"enabled Start \\<omega>\" \"hit_C \\<omega>\"\n  shows \"before_C {last_H \\<omega>} \\<omega>\" \"last_H \\<omega> \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. before_C {last_H \\<omega>} \\<omega> &&& last_H \\<omega> \\<in> H", "by (metis before_C_single hit_C_imp_before_C last_H_eq Int_iff assms)+"], ["", "lemma AE_last_H:\n  \"AE \\<omega> in \\<PP>. hit_C \\<omega> \\<longrightarrow> before_C {i} \\<omega> \\<longleftrightarrow> last_H \\<omega> = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. hit_C \\<omega> \\<longrightarrow>\n                          before_C {i} \\<omega> = (last_H \\<omega> = i)", "using AE_T_enabled"], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (enabled ?s)\n\ngoal (1 subgoal):\n 1. AE \\<omega> in \\<PP>. hit_C \\<omega> \\<longrightarrow>\n                          before_C {i} \\<omega> = (last_H \\<omega> = i)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled Start \\<omega> \\<Longrightarrow>\n       hit_C \\<omega> \\<longrightarrow>\n       before_C {i} \\<omega> = (last_H \\<omega> = i)", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled Start \\<omega> \\<Longrightarrow>\n       hit_C \\<omega> \\<longrightarrow>\n       before_C {i} \\<omega> = (last_H \\<omega> = i)", "assume \"enabled Start \\<omega>\""], ["proof (state)\nthis:\n  enabled Start \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       enabled Start \\<omega> \\<Longrightarrow>\n       hit_C \\<omega> \\<longrightarrow>\n       before_C {i} \\<omega> = (last_H \\<omega> = i)", "then"], ["proof (chain)\npicking this:\n  enabled Start \\<omega>", "show \"hit_C \\<omega> \\<longrightarrow> before_C {i} \\<omega> = (last_H \\<omega> = i)\""], ["proof (prove)\nusing this:\n  enabled Start \\<omega>\n\ngoal (1 subgoal):\n 1. hit_C \\<omega> \\<longrightarrow>\n    before_C {i} \\<omega> = (last_H \\<omega> = i)", "by (auto dest: last_H last_H_eq)"], ["proof (state)\nthis:\n  hit_C \\<omega> \\<longrightarrow>\n  before_C {i} \\<omega> = (last_H \\<omega> = i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma information_flow:\n  defines \"h \\<equiv> real (card H)\"\n  assumes init_uniform: \"\\<And>i. i \\<in> H \\<Longrightarrow> p_i i = 1 / h\"\n  shows \"\\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "let ?il = \"\\<lambda>i l. \\<P>(\\<omega> in \\<PP>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega> \\<bar> hit_C \\<omega> )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "let ?i = \"\\<lambda>i. \\<P>(\\<omega> in \\<PP>. visit {i} J \\<omega> \\<bar> hit_C \\<omega> )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "let ?l = \"\\<lambda>l. \\<P>(\\<omega> in \\<PP>. before_C {l} \\<omega> \\<bar> hit_C \\<omega> )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "from init_uniform"], ["proof (chain)\npicking this:\n  ?i2 \\<in> H \\<Longrightarrow> p_i ?i2 = 1 / h", "have init_H: \"\\<And>i. i \\<in> H \\<Longrightarrow> p_i i = p_j / p_H\""], ["proof (prove)\nusing this:\n  ?i2 \\<in> H \\<Longrightarrow> p_i ?i2 = 1 / h\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> H \\<Longrightarrow> p_i i = p_j / p_H", "by (simp add: p_j_def p_H_def h_def)"], ["proof (state)\nthis:\n  ?i2 \\<in> H \\<Longrightarrow> p_i ?i2 = p_j / p_H\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "from h_def"], ["proof (chain)\npicking this:\n  h \\<equiv> real (card H)", "have \"1/h = p_j/p_H\" \"h = p_H / p_j\" \"p_H = h * p_j\""], ["proof (prove)\nusing this:\n  h \\<equiv> real (card H)\n\ngoal (1 subgoal):\n 1. 1 / h = p_j / p_H &&& h = p_H / p_j &&& p_H = h * p_j", "by (auto simp: p_H_def p_j_def field_simps)"], ["proof (state)\nthis:\n  1 / h = p_j / p_H\n  h = p_H / p_j\n  p_H = h * p_j\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "from C_smaller"], ["proof (chain)\npicking this:\n  C \\<subset> J", "have h_pos: \"0 < h\""], ["proof (prove)\nusing this:\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. 0 < h", "by (auto simp add: card_gt_0_iff h_def)"], ["proof (state)\nthis:\n  0 < h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "let ?s = \"(h - 1) * p_j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "let ?f = \"?s * p_f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "from psubset_card_mono[OF _ C_smaller]"], ["proof (chain)\npicking this:\n  finite J \\<Longrightarrow> card C < card J", "have \"1 \\<le> card J - card C\""], ["proof (prove)\nusing this:\n  finite J \\<Longrightarrow> card C < card J\n\ngoal (1 subgoal):\n 1. 1 \\<le> card J - card C", "by (simp del: C_le_J)"], ["proof (state)\nthis:\n  1 \\<le> card J - card C\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card J - card C", "have \"1 \\<le> h\""], ["proof (prove)\nusing this:\n  1 \\<le> card J - card C\n\ngoal (1 subgoal):\n 1. 1 \\<le> h", "using C_smaller"], ["proof (prove)\nusing this:\n  1 \\<le> card J - card C\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. 1 \\<le> h", "by (simp add: h_def card_Diff_subset card_mono field_simps del: C_le_J)"], ["proof (state)\nthis:\n  1 \\<le> h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have log_le_0: \"?f * log 2 (p_H * p_f) \\<le> ?f * log 2 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f * log 2 (p_H * p_f)\n    \\<le> (h - 1) * p_j * p_f * log 2 1", "using p_H_p_f_less_1 p_H_p_f_pos p_j_pos p_f \\<open>1 \\<le> h\\<close>"], ["proof (prove)\nusing this:\n  p_H * p_f < 1\n  0 < p_H * p_f\n  0 < p_j\n  0 < p_f\n  p_f < 1\n  1 \\<le> h\n\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f * log 2 (p_H * p_f)\n    \\<le> (h - 1) * p_j * p_f * log 2 1", "by (intro mult_left_mono log_le mult_nonneg_nonneg) auto"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f * log 2 (p_H * p_f)\n  \\<le> (h - 1) * p_j * p_f * log 2 1\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"(h - 1) * p_j < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h - 1) * p_j < 1", "using \\<open>1 \\<le> h\\<close> C_smaller"], ["proof (prove)\nusing this:\n  1 \\<le> h\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. (h - 1) * p_j < 1", "by (auto simp: h_def p_j_def divide_less_eq card_Diff_subset card_mono)"], ["proof (state)\nthis:\n  (h - 1) * p_j < 1\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "then"], ["proof (chain)\npicking this:\n  (h - 1) * p_j < 1", "have 1: \"(h - 1) * p_j * p_f < 1 * 1\""], ["proof (prove)\nusing this:\n  (h - 1) * p_j < 1\n\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f < 1 * 1", "using p_f"], ["proof (prove)\nusing this:\n  (h - 1) * p_j < 1\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f < 1 * 1", "by (intro mult_strict_mono) auto"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f < 1 * 1\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "{"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f < 1 * 1\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"first_J \\<omega> \\<in> H \\<or> first_J \\<omega> = (THE x. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first_J \\<omega> \\<in> H \\<or> first_J \\<omega> = (THE x. False)", "apply (cases \"\\<forall>i. \\<not> visit {i} J \\<omega>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i. \\<not> visit {i} J \\<omega> \\<Longrightarrow>\n    first_J \\<omega> \\<in> H \\<or> first_J \\<omega> = (THE x. False)\n 2. \\<not> (\\<forall>i. \\<not> visit {i} J \\<omega>) \\<Longrightarrow>\n    first_J \\<omega> \\<in> H \\<or> first_J \\<omega> = (THE x. False)", "apply (simp add: first_J_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. \\<not> visit {i} J \\<omega>) \\<Longrightarrow>\n    first_J \\<omega> \\<in> H \\<or> first_J \\<omega> = (THE x. False)", "apply (auto dest: visit_imp_in_H first_J_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  first_J \\<omega> \\<in> H \\<or> first_J \\<omega> = (THE x. False)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "}"], ["proof (state)\nthis:\n  first_J ?\\<omega>4 \\<in> H \\<or> first_J ?\\<omega>4 = (THE x. False)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "then"], ["proof (chain)\npicking this:\n  first_J ?\\<omega>4 \\<in> H \\<or> first_J ?\\<omega>4 = (THE x. False)", "have range_fj: \"range first_J \\<subseteq> H \\<union> {THE x. False}\""], ["proof (prove)\nusing this:\n  first_J ?\\<omega>4 \\<in> H \\<or> first_J ?\\<omega>4 = (THE x. False)\n\ngoal (1 subgoal):\n 1. range first_J \\<subseteq> H \\<union> {THE x. False}", "by auto"], ["proof (state)\nthis:\n  range first_J \\<subseteq> H \\<union> {THE x. False}\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have sf_fj: \"simple_function hC first_J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_function hC first_J", "by (rule simple_functionI) (auto intro: finite_subset[OF range_fj])"], ["proof (state)\nthis:\n  simple_function hC first_J\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have sd_fj: \"simple_distributed hC first_J ?i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_distributed hC first_J\n     (\\<lambda>i. cond_prob \\<PP> (visit {i} J) hit_C)", "apply (rule hC.simple_distributedI[OF sf_fj])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> cond_prob \\<PP> (visit {x} J) hit_C\n 2. \\<And>x.\n       x \\<in> first_J ` space hC \\<Longrightarrow>\n       cond_prob \\<PP> (visit {x} J) hit_C =\n       hC.prob (first_J -` {x} \\<inter> space hC)", "apply (auto intro!: T.cond_prob_eq_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      visit {first_J xa} J x =\n                      (x \\<in> space\n                                (stream_space (count_space UNIV)) \\<and>\n                       first_J x = first_J xa)", "apply (auto simp: space_stream_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      visit {first_J xa} J x = (first_J x = first_J xa)", "using AE_first_J"], ["proof (prove)\nusing this:\n  AE \\<omega> in \\<PP>. visit {?i} J \\<omega> = (first_J \\<omega> = ?i)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      visit {first_J xa} J x = (first_J x = first_J xa)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x.\n       \\<lbrakk>xa \\<in> space hC;\n        visit {?i24 xa} J x = (first_J x = ?i24 xa)\\<rbrakk>\n       \\<Longrightarrow> hit_C x \\<longrightarrow>\n                         visit {first_J xa} J x = (first_J x = first_J xa)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_distributed hC first_J\n   (\\<lambda>i. cond_prob \\<PP> (visit {i} J) hit_C)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "{"], ["proof (state)\nthis:\n  simple_distributed hC first_J\n   (\\<lambda>i. cond_prob \\<PP> (visit {i} J) hit_C)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"last_H \\<omega> \\<in> H \\<or> last_H \\<omega> = (THE x. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_H \\<omega> \\<in> H \\<or> last_H \\<omega> = (THE x. False)", "apply (cases \"\\<forall>i. \\<not> before_C {i} \\<omega>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i. \\<not> before_C {i} \\<omega> \\<Longrightarrow>\n    last_H \\<omega> \\<in> H \\<or> last_H \\<omega> = (THE x. False)\n 2. \\<not> (\\<forall>i. \\<not> before_C {i} \\<omega>) \\<Longrightarrow>\n    last_H \\<omega> \\<in> H \\<or> last_H \\<omega> = (THE x. False)", "apply (simp add: last_H_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i. \\<not> before_C {i} \\<omega>) \\<Longrightarrow>\n    last_H \\<omega> \\<in> H \\<or> last_H \\<omega> = (THE x. False)", "apply (auto dest: before_C_imp_in_H last_H_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last_H \\<omega> \\<in> H \\<or> last_H \\<omega> = (THE x. False)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "}"], ["proof (state)\nthis:\n  last_H ?\\<omega>4 \\<in> H \\<or> last_H ?\\<omega>4 = (THE x. False)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "then"], ["proof (chain)\npicking this:\n  last_H ?\\<omega>4 \\<in> H \\<or> last_H ?\\<omega>4 = (THE x. False)", "have range_lnc: \"range last_H \\<subseteq> H \\<union> {THE x. False}\""], ["proof (prove)\nusing this:\n  last_H ?\\<omega>4 \\<in> H \\<or> last_H ?\\<omega>4 = (THE x. False)\n\ngoal (1 subgoal):\n 1. range last_H \\<subseteq> H \\<union> {THE x. False}", "by auto"], ["proof (state)\nthis:\n  range last_H \\<subseteq> H \\<union> {THE x. False}\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have sf_lnc: \"simple_function hC last_H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_function hC last_H", "by (rule simple_functionI) (auto intro: finite_subset[OF range_lnc])"], ["proof (state)\nthis:\n  simple_function hC last_H\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have sd_lnc: \"simple_distributed hC last_H ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_distributed hC last_H\n     (\\<lambda>l. cond_prob \\<PP> (before_C {l}) hit_C)", "apply (rule hC.simple_distributedI[OF sf_lnc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. 0 \\<le> cond_prob \\<PP> (before_C {x}) hit_C\n 2. \\<And>x.\n       x \\<in> last_H ` space hC \\<Longrightarrow>\n       cond_prob \\<PP> (before_C {x}) hit_C =\n       hC.prob (last_H -` {x} \\<inter> space hC)", "apply (auto intro!: T.cond_prob_eq_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      before_C {last_H xa} x =\n                      (x \\<in> space\n                                (stream_space (count_space UNIV)) \\<and>\n                       last_H x = last_H xa)", "apply (auto simp: space_stream_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      before_C {last_H xa} x = (last_H x = last_H xa)", "using AE_last_H"], ["proof (prove)\nusing this:\n  AE \\<omega> in \\<PP>. hit_C \\<omega> \\<longrightarrow>\n                        before_C {?i} \\<omega> = (last_H \\<omega> = ?i)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      before_C {last_H xa} x = (last_H x = last_H xa)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x.\n       \\<lbrakk>xa \\<in> space hC;\n        hit_C x \\<longrightarrow>\n        before_C {?i24 xa} x = (last_H x = ?i24 xa)\\<rbrakk>\n       \\<Longrightarrow> hit_C x \\<longrightarrow>\n                         before_C {last_H xa} x = (last_H x = last_H xa)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_distributed hC last_H\n   (\\<lambda>l. cond_prob \\<PP> (before_C {l}) hit_C)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have sd_fj_lnc: \"simple_distributed hC (\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>)) (\\<lambda>(i, l). ?il i l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_distributed hC\n     (\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>))\n     (\\<lambda>(i, l).\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C)", "apply (rule hC.simple_distributedI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. simple_function hC\n     (\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>))\n 2. \\<And>x.\n       0 \\<le> (case x of\n                (i, l) \\<Rightarrow>\n                  cond_prob \\<PP>\n                   (\\<lambda>\\<omega>.\n                       visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n                   hit_C)\n 3. \\<And>x.\n       x \\<in> (\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>)) `\n               space hC \\<Longrightarrow>\n       (case x of\n        (i, l) \\<Rightarrow>\n          cond_prob \\<PP>\n           (\\<lambda>\\<omega>.\n               visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n           hit_C) =\n       hC.prob\n        ((\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>)) -`\n         {x} \\<inter>\n         space hC)", "apply (rule simple_function_Pair[OF sf_fj sf_lnc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       0 \\<le> (case x of\n                (i, l) \\<Rightarrow>\n                  cond_prob \\<PP>\n                   (\\<lambda>\\<omega>.\n                       visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n                   hit_C)\n 2. \\<And>x.\n       x \\<in> (\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>)) `\n               space hC \\<Longrightarrow>\n       (case x of\n        (i, l) \\<Rightarrow>\n          cond_prob \\<PP>\n           (\\<lambda>\\<omega>.\n               visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n           hit_C) =\n       hC.prob\n        ((\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>)) -`\n         {x} \\<inter>\n         space hC)", "apply (auto intro!: T.cond_prob_eq_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<omega> \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      (visit {first_J \\<omega>} J x \\<and>\n                       before_C {last_H \\<omega>} x) =\n                      (x \\<in> space\n                                (stream_space (count_space UNIV)) \\<and>\n                       first_J x = first_J \\<omega> \\<and>\n                       last_H x = last_H \\<omega>)", "apply (auto simp: space_stream_space)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<omega> \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      (visit {first_J \\<omega>} J x \\<and>\n                       before_C {last_H \\<omega>} x) =\n                      (first_J x = first_J \\<omega> \\<and>\n                       last_H x = last_H \\<omega>)", "using AE_last_H AE_first_J"], ["proof (prove)\nusing this:\n  AE \\<omega> in \\<PP>. hit_C \\<omega> \\<longrightarrow>\n                        before_C {?i} \\<omega> = (last_H \\<omega> = ?i)\n  AE \\<omega> in \\<PP>. visit {?i} J \\<omega> = (first_J \\<omega> = ?i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<omega> \\<in> space hC \\<Longrightarrow>\n       AE x in \\<PP>. hit_C x \\<longrightarrow>\n                      (visit {first_J \\<omega>} J x \\<and>\n                       before_C {last_H \\<omega>} x) =\n                      (first_J x = first_J \\<omega> \\<and>\n                       last_H x = last_H \\<omega>)", "apply eventually_elim"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<omega> x.\n       \\<lbrakk>\\<omega> \\<in> space hC;\n        hit_C x \\<longrightarrow>\n        before_C {?i16 \\<omega>} x = (last_H x = ?i16 \\<omega>);\n        visit {?i14 \\<omega>} J x = (first_J x = ?i14 \\<omega>)\\<rbrakk>\n       \\<Longrightarrow> hit_C x \\<longrightarrow>\n                         (visit {first_J \\<omega>} J x \\<and>\n                          before_C {last_H \\<omega>} x) =\n                         (first_J x = first_J \\<omega> \\<and>\n                          last_H x = last_H \\<omega>)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_distributed hC\n   (\\<lambda>\\<omega>. (first_J \\<omega>, last_H \\<omega>))\n   (\\<lambda>(i, l).\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "define c where \"c = (SOME j. j \\<in> C)\""], ["proof (state)\nthis:\n  c = (SOME j. j \\<in> C)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have c: \"c \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<in> C", "using C_non_empty"], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. c \\<in> C", "unfolding ex_in_conv[symmetric] c_def"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> C\n\ngoal (1 subgoal):\n 1. (SOME j. j \\<in> C) \\<in> C", "by (rule someI_ex)"], ["proof (state)\nthis:\n  c \\<in> C\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "let ?inner = \"\\<lambda>i. \\<Sum>l\\<in>H. ?il i l * log 2 (?il i l / (?i i * ?l l))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "assume i: \"i \\<in> H\""], ["proof (state)\nthis:\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "with h_pos"], ["proof (chain)\npicking this:\n  0 < h\n  i \\<in> H", "have card_idx: \"real_of_nat (card (H - {i})) = p_H / p_j - 1\""], ["proof (prove)\nusing this:\n  0 < h\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. real (card (H - {i})) = p_H / p_j - 1", "by (auto simp add: p_j_def p_H_def h_def)"], ["proof (state)\nthis:\n  real (card (H - {i})) = p_H / p_j - 1\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have neq0: \"p_j \\<noteq> 0\" \"p_H \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_j \\<noteq> 0 &&& p_H \\<noteq> 0", "unfolding p_j_def p_H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real (card J) \\<noteq> 0 &&&\n    real (card H) / real (card J) \\<noteq> 0", "using C_smaller i"], ["proof (prove)\nusing this:\n  C \\<subset> J\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. 1 / real (card J) \\<noteq> 0 &&&\n    real (card H) / real (card J) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p_j \\<noteq> 0\n  p_H \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "from i"], ["proof (chain)\npicking this:\n  i \\<in> H", "have \"?inner i =\n      (\\<Sum>l\\<in>H - {i}. ?il i l * log 2 (?il i l / (?i i * ?l l))) +\n      ?il i i * log 2 (?il i i / (?i i * ?l i))\""], ["proof (prove)\nusing this:\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (\\<Sum>l\\<in>H - {i}.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) +\n    cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C *\n    log 2\n     (cond_prob \\<PP>\n       (\\<lambda>\\<omega>.\n           visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n       hit_C /\n      (cond_prob \\<PP> (visit {i} J) hit_C *\n       cond_prob \\<PP> (before_C {i}) hit_C))", "by (simp add: sum_diff)"], ["proof (state)\nthis:\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  (\\<Sum>l\\<in>H - {i}.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) +\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n   hit_C *\n  log 2\n   (cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C /\n    (cond_prob \\<PP> (visit {i} J) hit_C *\n     cond_prob \\<PP> (before_C {i}) hit_C))\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  (\\<Sum>l\\<in>H - {i}.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) +\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n   hit_C *\n  log 2\n   (cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C /\n    (cond_prob \\<PP> (visit {i} J) hit_C *\n     cond_prob \\<PP> (before_C {i}) hit_C))\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"\\<dots> =\n      (\\<Sum>l\\<in>H - {i}. p_j/p_H * p_j * p_f * log 2 (p_j * p_f / (p_j * p_f + p_j/p_H * (1 - p_H * p_f)))) +\n      p_j/p_H * (p_j * p_f + (1 - p_H * p_f)) * log 2 ((p_j * p_f + (1 - p_H * p_f)) / (p_j * p_f + p_j/p_H * (1 - p_H * p_f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<in>H - {i}.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) +\n    cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C *\n    log 2\n     (cond_prob \\<PP>\n       (\\<lambda>\\<omega>.\n           visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n       hit_C /\n      (cond_prob \\<PP> (visit {i} J) hit_C *\n       cond_prob \\<PP> (before_C {i}) hit_C)) =\n    (\\<Sum>l\\<in>H - {i}.\n       p_j / p_H * p_j * p_f *\n       log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n    p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n    log 2\n     ((p_j * p_f + (1 - p_H * p_f)) /\n      (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))", "using i p_f p_j_pos p_H"], ["proof (prove)\nusing this:\n  i \\<in> H\n  0 < p_f\n  p_f < 1\n  0 < p_j\n  0 < p_H\n  p_H < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<in>H - {i}.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) +\n    cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C *\n    log 2\n     (cond_prob \\<PP>\n       (\\<lambda>\\<omega>.\n           visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n       hit_C /\n      (cond_prob \\<PP> (visit {i} J) hit_C *\n       cond_prob \\<PP> (before_C {i}) hit_C)) =\n    (\\<Sum>l\\<in>H - {i}.\n       p_j / p_H * p_j * p_f *\n       log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n    p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n    log 2\n     ((p_j * p_f + (1 - p_H * p_f)) /\n      (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))", "apply (simp add: Pr_visit_before_C P_visit init_H Pr_before_C\n                  del: sum_constant)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> J \\<and> i \\<notin> C; 0 < p_f; p_f < 1; 0 < p_j;\n     0 < p_H; p_H < 1\\<rbrakk>\n    \\<Longrightarrow> (p_j * p_j * p_f / p_H +\n                       p_j * (1 - p_H * p_f) / p_H) *\n                      log 2\n                       ((p_j * p_j * p_f / p_H +\n                         p_j * (1 - p_H * p_f) / p_H) *\n                        p_H /\n                        (p_j * (p_j * p_f + p_j * (1 - p_H * p_f) / p_H))) =\n                      p_j * (p_j * p_f + (1 - p_H * p_f)) *\n                      log 2\n                       ((p_j * p_f + (1 - p_H * p_f)) /\n                        (p_j * p_f + p_j * (1 - p_H * p_f) / p_H)) /\n                      p_H", "apply (simp add: divide_simps distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> J \\<and> i \\<notin> C; 0 < p_f; p_f < 1; 0 < p_j;\n     0 < p_H; p_H < 1\\<rbrakk>\n    \\<Longrightarrow> (p_j * p_j * p_f + p_j * (1 - p_H * p_f)) *\n                      log 2\n                       ((p_j * p_j * p_f + p_j * (1 - p_H * p_f)) * p_H /\n                        (p_j * (p_j * p_f * p_H) +\n                         p_j * (p_j * (1 - p_H * p_f)))) =\n                      (p_j * (p_j * p_f) + p_j * (1 - p_H * p_f)) *\n                      log 2\n                       ((p_j * p_f + (1 - p_H * p_f)) * p_H /\n                        (p_j * p_f * p_H + p_j * (1 - p_H * p_f)))", "apply (intro arg_cong2[where f=\"(*)\"] refl arg_cong2[where f=log])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<in> J \\<and> i \\<notin> C; 0 < p_f; p_f < 1; 0 < p_j;\n     0 < p_H; p_H < 1\\<rbrakk>\n    \\<Longrightarrow> p_j * p_j * p_f + p_j * (1 - p_H * p_f) =\n                      p_j * (p_j * p_f) + p_j * (1 - p_H * p_f)\n 2. \\<lbrakk>i \\<in> J \\<and> i \\<notin> C; 0 < p_f; p_f < 1; 0 < p_j;\n     0 < p_H; p_H < 1\\<rbrakk>\n    \\<Longrightarrow> (p_j * p_j * p_f + p_j * (1 - p_H * p_f)) * p_H /\n                      (p_j * (p_j * p_f * p_H) +\n                       p_j * (p_j * (1 - p_H * p_f))) =\n                      (p_j * p_f + (1 - p_H * p_f)) * p_H /\n                      (p_j * p_f * p_H + p_j * (1 - p_H * p_f))", "apply (auto simp: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>l\\<in>H - {i}.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) +\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n   hit_C *\n  log 2\n   (cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C /\n    (cond_prob \\<PP> (visit {i} J) hit_C *\n     cond_prob \\<PP> (before_C {i}) hit_C)) =\n  (\\<Sum>l\\<in>H - {i}.\n     p_j / p_H * p_j * p_f *\n     log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n  p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n  log 2\n   ((p_j * p_f + (1 - p_H * p_f)) /\n    (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (\\<Sum>l\\<in>H - {i}.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) +\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n   hit_C *\n  log 2\n   (cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {i} \\<omega>)\n     hit_C /\n    (cond_prob \\<PP> (visit {i} J) hit_C *\n     cond_prob \\<PP> (before_C {i}) hit_C)) =\n  (\\<Sum>l\\<in>H - {i}.\n     p_j / p_H * p_j * p_f *\n     log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n  p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n  log 2\n   ((p_j * p_f + (1 - p_H * p_f)) /\n    (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"\\<dots> = (?f * log 2 (h * p_j * p_f) + (1 - ?f) * log 2 ((1 - ?f) * h)) / h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<in>H - {i}.\n       p_j / p_H * p_j * p_f *\n       log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n    p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n    log 2\n     ((p_j * p_f + (1 - p_H * p_f)) /\n      (p_j * p_f + p_j / p_H * (1 - p_H * p_f))) =\n    ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n     (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n    h", "using neq0 p_f"], ["proof (prove)\nusing this:\n  p_j \\<noteq> 0\n  p_H \\<noteq> 0\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<in>H - {i}.\n       p_j / p_H * p_j * p_f *\n       log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n    p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n    log 2\n     ((p_j * p_f + (1 - p_H * p_f)) /\n      (p_j * p_f + p_j / p_H * (1 - p_H * p_f))) =\n    ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n     (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n    h", "by (simp add: card_idx field_simps \\<open>p_H = h * p_j\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>l\\<in>H - {i}.\n     p_j / p_H * p_j * p_f *\n     log 2 (p_j * p_f / (p_j * p_f + p_j / p_H * (1 - p_H * p_f)))) +\n  p_j / p_H * (p_j * p_f + (1 - p_H * p_f)) *\n  log 2\n   ((p_j * p_f + (1 - p_H * p_f)) /\n    (p_j * p_f + p_j / p_H * (1 - p_H * p_f))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h", "have \"?inner i = (?f * log 2 (h * p_j * p_f) + (1 - ?f) * log 2 ((1 - ?f) * h)) / h\""], ["proof (prove)\nusing this:\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h\n\ngoal (1 subgoal):\n 1. (\\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n    ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n     (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n    h", "."], ["proof (state)\nthis:\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "}"], ["proof (state)\nthis:\n  ?i4 \\<in> H \\<Longrightarrow>\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>.\n          visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {?i4} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "then"], ["proof (chain)\npicking this:\n  ?i4 \\<in> H \\<Longrightarrow>\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>.\n          visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {?i4} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h", "have \"(\\<Sum>i\\<in>H. ?inner i) = ?f * log 2 (h * p_j * p_f) + (1 - ?f) * log 2 ((1 - ?f) * h)\""], ["proof (prove)\nusing this:\n  ?i4 \\<in> H \\<Longrightarrow>\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>.\n          visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {?i4} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>H.\n       \\<Sum>l\\<in>H.\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C *\n         log 2\n          (cond_prob \\<PP>\n            (\\<lambda>\\<omega>.\n                visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n            hit_C /\n           (cond_prob \\<PP> (visit {i} J) hit_C *\n            cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n    (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)", "using h_pos"], ["proof (prove)\nusing this:\n  ?i4 \\<in> H \\<Longrightarrow>\n  (\\<Sum>l\\<in>H.\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>.\n          visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {?i4} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {?i4} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  ((h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n   (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)) /\n  h\n  0 < h\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>H.\n       \\<Sum>l\\<in>H.\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C *\n         log 2\n          (cond_prob \\<PP>\n            (\\<lambda>\\<omega>.\n                visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n            hit_C /\n           (cond_prob \\<PP> (visit {i} J) hit_C *\n            cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n    (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)", "by (simp add: h_def[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n  (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n  (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"\\<dots> = ?f * log 2 (p_H * p_f) + (1 - ?f) * log 2 ((1 - ?f) * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n    (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h) =\n    (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n    (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)", "by (simp add: \\<open>h = p_H / p_j\\<close>)"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h) =\n  (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f * log 2 (h * p_j * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h) =\n  (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"\\<dots> \\<le> (1 - ?f) * log 2 ((1 - ?f) * h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n    (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n    \\<le> (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)", "using log_le_0"], ["proof (prove)\nusing this:\n  (h - 1) * p_j * p_f * log 2 (p_H * p_f)\n  \\<le> (h - 1) * p_j * p_f * log 2 1\n\ngoal (1 subgoal):\n 1. (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n    (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n    \\<le> (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)", "by simp"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (h - 1) * p_j * p_f * log 2 (p_H * p_f) +\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"\\<dots> \\<le> (1 - ?f) * log 2 h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n    \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "using h_pos \\<open>1 \\<le> h\\<close> 1 p_j_pos p_f"], ["proof (prove)\nusing this:\n  0 < h\n  1 \\<le> h\n  (h - 1) * p_j * p_f < 1 * 1\n  0 < p_j\n  0 < p_f\n  p_f < 1\n\ngoal (1 subgoal):\n 1. (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n    \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "by (intro mult_left_mono log_le mult_pos_pos mult_nonneg_nonneg) auto"], ["proof (state)\nthis:\n  (1 - (h - 1) * p_j * p_f) * log 2 ((1 - (h - 1) * p_j * p_f) * h)\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C)))\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"(\\<Sum>i\\<in>H. ?inner i) \\<le> (1 - ?f) * log 2 h\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C)))\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>H.\n       \\<Sum>l\\<in>H.\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C *\n         log 2\n          (cond_prob \\<PP>\n            (\\<lambda>\\<omega>.\n                visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n            hit_C /\n           (cond_prob \\<PP> (visit {i} J) hit_C *\n            cond_prob \\<PP> (before_C {l}) hit_C)))\n    \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "."], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C)))\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C)))\n  \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"(\\<Sum>i\\<in>H. ?inner i) =\n      (\\<Sum>(i, l)\\<in>(first_J`space S) \\<times> (last_H`space S). ?il i l * log 2 (?il i l / (?i i * ?l l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>H.\n       \\<Sum>l\\<in>H.\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C *\n         log 2\n          (cond_prob \\<PP>\n            (\\<lambda>\\<omega>.\n                visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n            hit_C /\n           (cond_prob \\<PP> (visit {i} J) hit_C *\n            cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (\\<Sum>(i, l)\n           \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n                last_H ` space (stream_space (count_space UNIV)).\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C)))", "unfolding sum.cartesian_product"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, l)\\<in>H \\<times> H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (\\<Sum>(i, l)\n           \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n                last_H ` space (stream_space (count_space UNIV)).\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C)))", "proof (safe intro!: sum.mono_neutral_cong_left del: DiffE DiffI)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite\n     (first_J ` space (stream_space (count_space UNIV)) \\<times>\n      last_H ` space (stream_space (count_space UNIV)))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a \\<in> first_J `\n                                 space (stream_space (count_space UNIV))\n 3. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> b \\<in> last_H `\n                                 space (stream_space (count_space UNIV))\n 4. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "show \"finite ((first_J ` space S) \\<times> (last_H ` space S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (first_J ` space (stream_space (count_space UNIV)) \\<times>\n      last_H ` space (stream_space (count_space UNIV)))", "using sf_fj sf_lnc"], ["proof (prove)\nusing this:\n  simple_function hC first_J\n  simple_function hC last_H\n\ngoal (1 subgoal):\n 1. finite\n     (first_J ` space (stream_space (count_space UNIV)) \\<times>\n      last_H ` space (stream_space (count_space UNIV)))", "by (auto simp add: hC_def dest!: simple_functionD(1))"], ["proof (state)\nthis:\n  finite\n   (first_J ` space (stream_space (count_space UNIV)) \\<times>\n    last_H ` space (stream_space (count_space UNIV)))\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a \\<in> first_J `\n                                 space (stream_space (count_space UNIV))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> b \\<in> last_H `\n                                 space (stream_space (count_space UNIV))\n 3. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a \\<in> first_J `\n                                 space (stream_space (count_space UNIV))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> b \\<in> last_H `\n                                 space (stream_space (count_space UNIV))\n 3. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a \\<in> first_J `\n                                 space (stream_space (count_space UNIV))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> b \\<in> last_H `\n                                 space (stream_space (count_space UNIV))\n 3. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "assume \"i \\<in> H\""], ["proof (state)\nthis:\n  i \\<in> H\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a \\<in> first_J `\n                                 space (stream_space (count_space UNIV))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> b \\<in> last_H `\n                                 space (stream_space (count_space UNIV))\n 3. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "then"], ["proof (chain)\npicking this:\n  i \\<in> H", "have \"visit {i} J (Init i ## Mix i ## sconst End)\"\n      \"before_C {i} (Init i ## Mix c ## sconst End)\""], ["proof (prove)\nusing this:\n  i \\<in> H\n\ngoal (1 subgoal):\n 1. visit {i} J (Init i ## Mix i ## sconst End) &&&\n    before_C {i} (Init i ## Mix c ## sconst End)", "by (auto simp: before_C_def visit_def suntil_Stream HLD_iff c)"], ["proof (state)\nthis:\n  visit {i} J (Init i ## Mix i ## sconst End)\n  before_C {i} (Init i ## Mix c ## sconst End)\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> a \\<in> first_J `\n                                 space (stream_space (count_space UNIV))\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> H; b \\<in> H\\<rbrakk>\n       \\<Longrightarrow> b \\<in> last_H `\n                                 space (stream_space (count_space UNIV))\n 3. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "then"], ["proof (chain)\npicking this:\n  visit {i} J (Init i ## Mix i ## sconst End)\n  before_C {i} (Init i ## Mix c ## sconst End)", "show \"i \\<in> first_J ` space S\" \"i \\<in> last_H ` space S\""], ["proof (prove)\nusing this:\n  visit {i} J (Init i ## Mix i ## sconst End)\n  before_C {i} (Init i ## Mix c ## sconst End)\n\ngoal (1 subgoal):\n 1. i \\<in> first_J ` space (stream_space (count_space UNIV)) &&&\n    i \\<in> last_H ` space (stream_space (count_space UNIV))", "by (auto simp: space_stream_space image_iff eq_commute dest!: first_J_eq last_H_eq)"], ["proof (state)\nthis:\n  i \\<in> first_J ` space (stream_space (count_space UNIV))\n  i \\<in> last_H ` space (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "fix i l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "assume \"(i, l) \\<in> first_J ` space S \\<times> last_H ` space S - H \\<times> H\""], ["proof (state)\nthis:\n  (i, l)\n  \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n        last_H ` space (stream_space (count_space UNIV)) -\n        H \\<times> H\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "then"], ["proof (chain)\npicking this:\n  (i, l)\n  \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n        last_H ` space (stream_space (count_space UNIV)) -\n        H \\<times> H", "have H: \"i \\<notin> H \\<or> l \\<notin> H\""], ["proof (prove)\nusing this:\n  (i, l)\n  \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n        last_H ` space (stream_space (count_space UNIV)) -\n        H \\<times> H\n\ngoal (1 subgoal):\n 1. i \\<notin> H \\<or> l \\<notin> H", "by auto"], ["proof (state)\nthis:\n  i \\<notin> H \\<or> l \\<notin> H\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "have \"\\<P>(\\<omega> in \\<PP>. (visit {i} J \\<omega> \\<and> before_C {l} \\<omega>) \\<and> hit_C \\<omega>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      (visit {i} J \\<omega> \\<and> before_C {l} \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    0", "using H"], ["proof (prove)\nusing this:\n  i \\<notin> H \\<or> l \\<notin> H\n\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      (visit {i} J \\<omega> \\<and> before_C {l} \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    0", "by (intro T.prob_eq_0_AE) (auto dest: visit_imp_in_H before_C_imp_in_H)"], ["proof (state)\nthis:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit {i} J \\<omega> \\<and> before_C {l} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b)\n       \\<in> first_J ` space (stream_space (count_space UNIV)) \\<times>\n             last_H ` space (stream_space (count_space UNIV)) -\n             H \\<times> H \\<Longrightarrow>\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {a} J \\<omega> \\<and> before_C {b} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {a} J) hit_C *\n          cond_prob \\<PP> (before_C {b}) hit_C)) =\n       0", "then"], ["proof (chain)\npicking this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit {i} J \\<omega> \\<and> before_C {l} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  0", "show \"?il i l * log 2 (?il i l / (?i i * ?l l)) = 0\""], ["proof (prove)\nusing this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit {i} J \\<omega> \\<and> before_C {l} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n     hit_C *\n    log 2\n     (cond_prob \\<PP>\n       (\\<lambda>\\<omega>.\n           visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n       hit_C /\n      (cond_prob \\<PP> (visit {i} J) hit_C *\n       cond_prob \\<PP> (before_C {l}) hit_C)) =\n    0", "by (simp add: cond_prob_def)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n   hit_C *\n  log 2\n   (cond_prob \\<PP>\n     (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n     hit_C /\n    (cond_prob \\<PP> (visit {i} J) hit_C *\n     cond_prob \\<PP> (before_C {l}) hit_C)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n  (\\<Sum>(i, l)\n         \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n              last_H ` space (stream_space (count_space UNIV)).\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C)))\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>H.\n     \\<Sum>l\\<in>H.\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n  (\\<Sum>(i, l)\n         \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n              last_H ` space (stream_space (count_space UNIV)).\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C)))\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "have \"\\<dots> = \\<I>(first_J ; last_H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, l)\n           \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n                last_H ` space (stream_space (count_space UNIV)).\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n    \\<I>(first_J ; last_H)", "unfolding sum.cartesian_product"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, l)\n           \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n                last_H ` space (stream_space (count_space UNIV)).\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n    \\<I>(first_J ; last_H)", "apply (subst hC.mutual_information_simple_distributed[OF sd_fj sd_lnc sd_fj_lnc])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(i, l)\n           \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n                last_H ` space (stream_space (count_space UNIV)).\n       cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C *\n       log 2\n        (cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C /\n         (cond_prob \\<PP> (visit {i} J) hit_C *\n          cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (\\<Sum>(x, y)\\<in>(\\<lambda>x. (first_J x, last_H x)) ` space hC.\n       (case (x, y) of\n        (i, l) \\<Rightarrow>\n          cond_prob \\<PP>\n           (\\<lambda>\\<omega>.\n               visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n           hit_C) *\n       log 2\n        ((case (x, y) of\n          (i, l) \\<Rightarrow>\n            cond_prob \\<PP>\n             (\\<lambda>\\<omega>.\n                 visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n             hit_C) /\n         (cond_prob \\<PP> (visit {x} J) hit_C *\n          cond_prob \\<PP> (before_C {y}) hit_C)))", "apply (simp add: hC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n                 last_H ` space (stream_space (count_space UNIV)).\n       case x of\n       (i, l) \\<Rightarrow>\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n          hit_C *\n         log 2\n          (cond_prob \\<PP>\n            (\\<lambda>\\<omega>.\n                visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n            hit_C /\n           (cond_prob \\<PP> (visit {i} J) hit_C *\n            cond_prob \\<PP> (before_C {l}) hit_C))) =\n    (\\<Sum>x\\<in>(\\<lambda>x. (first_J x, last_H x)) `\n                 space (stream_space (count_space UNIV)).\n       case x of\n       (x, y) \\<Rightarrow>\n         cond_prob \\<PP>\n          (\\<lambda>\\<omega>.\n              visit {x} J \\<omega> \\<and> before_C {y} \\<omega>)\n          hit_C *\n         log 2\n          (cond_prob \\<PP>\n            (\\<lambda>\\<omega>.\n                visit {x} J \\<omega> \\<and> before_C {y} \\<omega>)\n            hit_C /\n           (cond_prob \\<PP> (visit {x} J) hit_C *\n            cond_prob \\<PP> (before_C {y}) hit_C)))", "proof (safe intro!: sum.mono_neutral_right imageI)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     (first_J ` space (stream_space (count_space UNIV)) \\<times>\n      last_H ` space (stream_space (count_space UNIV)))\n 2. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "show \"finite ((first_J ` space S) \\<times> (last_H ` space S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (first_J ` space (stream_space (count_space UNIV)) \\<times>\n      last_H ` space (stream_space (count_space UNIV)))", "using sf_fj sf_lnc"], ["proof (prove)\nusing this:\n  simple_function hC first_J\n  simple_function hC last_H\n\ngoal (1 subgoal):\n 1. finite\n     (first_J ` space (stream_space (count_space UNIV)) \\<times>\n      last_H ` space (stream_space (count_space UNIV)))", "by (auto simp add: hC_def dest!: simple_functionD(1))"], ["proof (state)\nthis:\n  finite\n   (first_J ` space (stream_space (count_space UNIV)) \\<times>\n    last_H ` space (stream_space (count_space UNIV)))\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "fix i l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "assume \"(first_J i, last_H l) \\<notin> (\\<lambda>x. (first_J x, last_H x)) ` space S\""], ["proof (state)\nthis:\n  (first_J i, last_H l)\n  \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n           space (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "moreover"], ["proof (state)\nthis:\n  (first_J i, last_H l)\n  \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n           space (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "{"], ["proof (state)\nthis:\n  (first_J i, last_H l)\n  \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n           space (stream_space (count_space UNIV))\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "fix i l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "assume \"i \\<in> H\" \"l \\<in> H\""], ["proof (state)\nthis:\n  i \\<in> H\n  l \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "then"], ["proof (chain)\npicking this:\n  i \\<in> H\n  l \\<in> H", "have \"visit {i} J (Init i ## Mix l ## Mix c ## sconst End)\"\n        \"before_C {l} (Init i ## Mix l ## Mix c ## sconst End)\""], ["proof (prove)\nusing this:\n  i \\<in> H\n  l \\<in> H\n\ngoal (1 subgoal):\n 1. visit {i} J (Init i ## Mix l ## Mix c ## sconst End) &&&\n    before_C {l} (Init i ## Mix l ## Mix c ## sconst End)", "using c C_smaller"], ["proof (prove)\nusing this:\n  i \\<in> H\n  l \\<in> H\n  c \\<in> C\n  C \\<subset> J\n\ngoal (1 subgoal):\n 1. visit {i} J (Init i ## Mix l ## Mix c ## sconst End) &&&\n    before_C {l} (Init i ## Mix l ## Mix c ## sconst End)", "by (auto simp: before_C_def visit_def HLD_iff suntil_Stream)"], ["proof (state)\nthis:\n  visit {i} J (Init i ## Mix l ## Mix c ## sconst End)\n  before_C {l} (Init i ## Mix l ## Mix c ## sconst End)\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "then"], ["proof (chain)\npicking this:\n  visit {i} J (Init i ## Mix l ## Mix c ## sconst End)\n  before_C {l} (Init i ## Mix l ## Mix c ## sconst End)", "have \"first_J (Init i ## Mix l ## Mix c ## sconst End) = i\"\n        \"last_H (Init i ## Mix l ## Mix c ## sconst End) = l\""], ["proof (prove)\nusing this:\n  visit {i} J (Init i ## Mix l ## Mix c ## sconst End)\n  before_C {l} (Init i ## Mix l ## Mix c ## sconst End)\n\ngoal (1 subgoal):\n 1. first_J (Init i ## Mix l ## Mix c ## sconst End) = i &&&\n    last_H (Init i ## Mix l ## Mix c ## sconst End) = l", "by (auto intro!: first_J_eq last_H_eq)"], ["proof (state)\nthis:\n  first_J (Init i ## Mix l ## Mix c ## sconst End) = i\n  last_H (Init i ## Mix l ## Mix c ## sconst End) = l\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ia4 \\<in> H; ?la4 \\<in> H\\<rbrakk>\n  \\<Longrightarrow> first_J (Init ?ia4 ## Mix ?la4 ## Mix c ## sconst End) =\n                    ?ia4\n  \\<lbrakk>?ia4 \\<in> H; ?la4 \\<in> H\\<rbrakk>\n  \\<Longrightarrow> last_H (Init ?ia4 ## Mix ?la4 ## Mix c ## sconst End) =\n                    ?la4\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "note this[of \"first_J i\" \"last_H l\"]"], ["proof (state)\nthis:\n  \\<lbrakk>first_J i \\<in> H; last_H l \\<in> H\\<rbrakk>\n  \\<Longrightarrow> first_J\n                     (Init (first_J i) ##\n                      Mix (last_H l) ## Mix c ## sconst End) =\n                    first_J i\n  \\<lbrakk>first_J i \\<in> H; last_H l \\<in> H\\<rbrakk>\n  \\<Longrightarrow> last_H\n                     (Init (first_J i) ##\n                      Mix (last_H l) ## Mix c ## sconst End) =\n                    last_H l\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "ultimately"], ["proof (chain)\npicking this:\n  (first_J i, last_H l)\n  \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n           space (stream_space (count_space UNIV))\n  \\<lbrakk>first_J i \\<in> H; last_H l \\<in> H\\<rbrakk>\n  \\<Longrightarrow> first_J\n                     (Init (first_J i) ##\n                      Mix (last_H l) ## Mix c ## sconst End) =\n                    first_J i\n  \\<lbrakk>first_J i \\<in> H; last_H l \\<in> H\\<rbrakk>\n  \\<Longrightarrow> last_H\n                     (Init (first_J i) ##\n                      Mix (last_H l) ## Mix c ## sconst End) =\n                    last_H l", "have \"(first_J i, last_H l) \\<notin> H\\<times>H\""], ["proof (prove)\nusing this:\n  (first_J i, last_H l)\n  \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n           space (stream_space (count_space UNIV))\n  \\<lbrakk>first_J i \\<in> H; last_H l \\<in> H\\<rbrakk>\n  \\<Longrightarrow> first_J\n                     (Init (first_J i) ##\n                      Mix (last_H l) ## Mix c ## sconst End) =\n                    first_J i\n  \\<lbrakk>first_J i \\<in> H; last_H l \\<in> H\\<rbrakk>\n  \\<Longrightarrow> last_H\n                     (Init (first_J i) ##\n                      Mix (last_H l) ## Mix c ## sconst End) =\n                    last_H l\n\ngoal (1 subgoal):\n 1. (first_J i, last_H l) \\<notin> H \\<times> H", "by (auto simp: space_stream_space image_iff eq_commute) metis"], ["proof (state)\nthis:\n  (first_J i, last_H l) \\<notin> H \\<times> H\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "then"], ["proof (chain)\npicking this:\n  (first_J i, last_H l) \\<notin> H \\<times> H", "have \"\\<P>(\\<omega> in \\<PP>. (visit {first_J i} J \\<omega> \\<and> before_C {last_H l} \\<omega>) \\<and> hit_C \\<omega>) = 0\""], ["proof (prove)\nusing this:\n  (first_J i, last_H l) \\<notin> H \\<times> H\n\ngoal (1 subgoal):\n 1. T.prob Start\n     {\\<omega> \\<in> space \\<PP>.\n      (visit {first_J i} J \\<omega> \\<and>\n       before_C {last_H l} \\<omega>) \\<and>\n      hit_C \\<omega>} =\n    0", "by (intro T.prob_eq_0_AE) (auto dest: visit_imp_in_H before_C_imp_in_H)"], ["proof (state)\nthis:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit {first_J i} J \\<omega> \\<and>\n     before_C {last_H l} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>(first_J x, last_H xa)\n                \\<notin> (\\<lambda>x. (first_J x, last_H x)) `\n                         space (stream_space (count_space UNIV));\n        x \\<in> space (stream_space (count_space UNIV));\n        xa \\<in> space (stream_space (count_space UNIV))\\<rbrakk>\n       \\<Longrightarrow> cond_prob \\<PP>\n                          (\\<lambda>\\<omega>.\n                              visit {first_J x} J \\<omega> \\<and>\n                              before_C {last_H xa} \\<omega>)\n                          hit_C *\n                         log 2\n                          (cond_prob \\<PP>\n                            (\\<lambda>\\<omega>.\n                                visit {first_J x} J \\<omega> \\<and>\n                                before_C {last_H xa} \\<omega>)\n                            hit_C /\n                           (cond_prob \\<PP> (visit {first_J x} J) hit_C *\n                            cond_prob \\<PP> (before_C {last_H xa}) hit_C)) =\n                         0", "then"], ["proof (chain)\npicking this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit {first_J i} J \\<omega> \\<and>\n     before_C {last_H l} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  0", "show \"?il (first_J i) (last_H l) *\n      log 2 (?il (first_J i) (last_H l) / (?i (first_J i) * ?l (last_H l))) = 0\""], ["proof (prove)\nusing this:\n  T.prob Start\n   {\\<omega> \\<in> space \\<PP>.\n    (visit {first_J i} J \\<omega> \\<and>\n     before_C {last_H l} \\<omega>) \\<and>\n    hit_C \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         visit {first_J i} J \\<omega> \\<and> before_C {last_H l} \\<omega>)\n     hit_C *\n    log 2\n     (cond_prob \\<PP>\n       (\\<lambda>\\<omega>.\n           visit {first_J i} J \\<omega> \\<and> before_C {last_H l} \\<omega>)\n       hit_C /\n      (cond_prob \\<PP> (visit {first_J i} J) hit_C *\n       cond_prob \\<PP> (before_C {last_H l}) hit_C)) =\n    0", "by (simp add: cond_prob_def)"], ["proof (state)\nthis:\n  cond_prob \\<PP>\n   (\\<lambda>\\<omega>.\n       visit {first_J i} J \\<omega> \\<and> before_C {last_H l} \\<omega>)\n   hit_C *\n  log 2\n   (cond_prob \\<PP>\n     (\\<lambda>\\<omega>.\n         visit {first_J i} J \\<omega> \\<and> before_C {last_H l} \\<omega>)\n     hit_C /\n    (cond_prob \\<PP> (visit {first_J i} J) hit_C *\n     cond_prob \\<PP> (before_C {last_H l}) hit_C)) =\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(i, l)\n         \\<in>first_J ` space (stream_space (count_space UNIV)) \\<times>\n              last_H ` space (stream_space (count_space UNIV)).\n     cond_prob \\<PP>\n      (\\<lambda>\\<omega>. visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n      hit_C *\n     log 2\n      (cond_prob \\<PP>\n        (\\<lambda>\\<omega>.\n            visit {i} J \\<omega> \\<and> before_C {l} \\<omega>)\n        hit_C /\n       (cond_prob \\<PP> (visit {i} J) hit_C *\n        cond_prob \\<PP> (before_C {l}) hit_C))) =\n  \\<I>(first_J ; last_H)\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "finally"], ["proof (chain)\npicking this:\n  \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\n\ngoal (1 subgoal):\n 1. \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h", "by simp"], ["proof (state)\nthis:\n  \\<I>(first_J ; last_H) \\<le> (1 - (h - 1) * p_j * p_f) * log 2 h\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}