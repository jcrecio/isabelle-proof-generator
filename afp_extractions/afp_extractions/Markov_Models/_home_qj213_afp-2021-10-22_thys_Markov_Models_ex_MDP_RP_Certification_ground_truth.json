{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/MDP_RP_Certification.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma p_ub':\n  fixes x\n  assumes 1: \"s \\<in> S\" \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> (\\<Sum>t\\<in>S. pmf D t * x t) \\<le> x s\"\n  assumes 2: \"\\<And>s. s \\<in> S1 \\<Longrightarrow> x s \\<noteq> 0 \\<Longrightarrow> (\\<exists>t\\<in>S2. (s, t) \\<in> (SIGMA s:S1. \\<Union>D\\<in>K s. set_pmf D)\\<^sup>*)\"\n  assumes 3: \"\\<And>s. s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\"\n  assumes 4: \"\\<And>s. s \\<in> S2 \\<Longrightarrow> x s = 1\"\n  shows \"enn2real (p s) \\<le> x s\"", "lemma n_lb':\n  fixes x\n  assumes \"wf R\"\n  assumes 1: \"s \\<in> S\" \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> x s \\<le> (\\<Sum>t\\<in>S. pmf D t * x t)\"\n  assumes 2: \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> x s \\<noteq> 0 \\<Longrightarrow> \\<exists>t\\<in>D. ((t, s) \\<in> R \\<and> t \\<in> S1 \\<and> x t \\<noteq> 0) \\<or> t \\<in> S2\"\n  assumes 3: \"\\<And>s. s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\"\n  assumes 4: \"\\<And>s. s \\<in> S2 \\<Longrightarrow> x s = 1\"\n  shows \"x s \\<le> enn2real (n s)\"", "lemma lookup_eq_map_of: \"lookup d xs x = (case map_of xs x of Some x \\<Rightarrow> x | None \\<Rightarrow> d)\"", "lemma lookup_in_set:\n  \"distinct (map fst xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> lookup d xs (fst x) = snd x\"", "lemma lookup_not_in_set:\n  \"x \\<notin> fst ` set xs \\<Longrightarrow> lookup d xs x = d\"", "lemma lookup_nonneg:\n  \"(\\<And>x v. (x, v) \\<in> set xs \\<Longrightarrow> 0 \\<le> v) \\<Longrightarrow> (0::'a::ordered_comm_monoid_add) \\<le> lookup 0 xs x\"", "lemma sparse_mult_eq_sum_lookup:\n  fixes xs :: \"(nat \\<times> 'a::comm_semiring_1) list\"\n  assumes \"list_all (\\<lambda>(n, x). n < M) xs\" \"distinct (map fst xs)\"\n  shows \"sparse_mult xs y = (\\<Sum>i<M. lookup 0 xs i * y !! i)\"", "lemma sum_list_eq_sum_lookup:\n  fixes xs :: \"(nat \\<times> 'a::comm_semiring_1) list\"\n  assumes \"list_all (\\<lambda>(n, x). n < M) xs\" \"distinct (map fst xs)\"\n  shows \"sum_list (map snd xs) = (\\<Sum>i<M. lookup 0 xs i)\"", "lemma valid_mdp_rpD_length:\n  assumes \"valid_mdp_rp mdp\"\n  shows \"0 < state_count mdp\" \"IArray.length (distrs mdp) = state_count mdp\"\n    \"IArray.length (states1 mdp) = state_count mdp\" \"IArray.length (states2 mdp) = state_count mdp\"", "lemma valid_mdp_rpD:\n  assumes \"valid_mdp_rp mdp\" \"i < state_count mdp\"\n  shows \"\\<not> (states1 mdp !! i \\<and> states2 mdp !! i)\"\n    and \"\\<And>ds n x. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> (n, x) \\<in> set ds \\<Longrightarrow> n < state_count mdp\"\n    and \"\\<And>ds n x. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> (n, x) \\<in> set ds \\<Longrightarrow> 0 \\<le> x\"\n    and \"\\<And>ds. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> sum_list (map snd ds) = 1\"\n    and \"\\<And>ds. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> distinct (map fst ds)\"\n    and \"distrs mdp !! i \\<noteq> []\"", "lemma valid_mdp_rp_sparse_mult:\n  assumes \"valid_mdp_rp mdp\" \"i < state_count mdp\" \"ds \\<in> set (distrs mdp !! i)\"\n  shows \"sparse_mult ds y = (\\<Sum>i<state_count mdp. lookup 0 ds i * y !! i)\"", "lemma valid_sub_certD:\n  assumes \"valid_mdp_rp mdp\" \"valid_sub_cert mdp c ord check\" \"i < state_count mdp\"\n  shows \"\\<not> states1 mdp !! i \\<Longrightarrow> \\<not> states2 mdp !! i \\<Longrightarrow> solution c !! i = 0\"\n    and \"states2 mdp !! i \\<Longrightarrow> solution c !! i = 1\"\n    and \"states1 mdp !! i \\<Longrightarrow> 0 \\<le> solution c !! i\"\n    and \"\\<And>ds. states1 mdp !! i \\<Longrightarrow> ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> ord (sparse_mult ds (solution c)) (solution c !! i)\"\n    and \"\\<And>ds. states1 mdp !! i \\<Longrightarrow> 0 < solution c !! i \\<longrightarrow> check (distrs mdp !! i) (witness c !! i)\"", "lemma valid_pos_certD:\n  assumes \"valid_mdp_rp mdp\" \"valid_pos_cert mdp c\" \"i < state_count mdp\" \"states1 mdp !! i\"\n    \"0 < solution c !! i\" \"witness c !! i = ((j, a), n)\"\n  shows \"snd (witness c !! j) < n \\<and> j < state_count mdp \\<and> a < length (distrs mdp !! i) \\<and>\n          lookup 0 ((distrs mdp !! i) ! a) j \\<noteq> 0 \\<and> 0 < solution c !! j\"", "lemma valid_neg_certD:\n  assumes \"valid_mdp_rp mdp\" \"valid_neg_cert mdp c\" \"i < state_count mdp\" \"states1 mdp !! i\"\n    \"0 < solution c !! i\" \"witness c !! i = (js, n)\"\n  shows \"list_all2 (\\<lambda>j ds. j < state_count mdp \\<and> snd (witness c !! j) < n \\<and> lookup 0 ds j \\<noteq> 0 \\<and> 0 < solution c !! j) js (distrs mdp !! i)\"", "lemma\n  assumes \"i < state_count mdp\"\n  shows P_max: \"P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\" (is ?max)\n    and P_min: \"P_min i \\<ge> real_of_rat (solution (neg_cert c) !! i)\" (is ?min)"], "translations": [["", "lemma p_ub':\n  fixes x\n  assumes 1: \"s \\<in> S\" \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> (\\<Sum>t\\<in>S. pmf D t * x t) \\<le> x s\"\n  assumes 2: \"\\<And>s. s \\<in> S1 \\<Longrightarrow> x s \\<noteq> 0 \\<Longrightarrow> (\\<exists>t\\<in>S2. (s, t) \\<in> (SIGMA s:S1. \\<Union>D\\<in>K s. set_pmf D)\\<^sup>*)\"\n  assumes 3: \"\\<And>s. s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\"\n  assumes 4: \"\\<And>s. s \\<in> S2 \\<Longrightarrow> x s = 1\"\n  shows \"enn2real (p s) \\<le> x s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (p s) \\<le> x s", "proof (rule p_ub[OF 1 _ 4])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. \\<lbrakk>s \\<in> S; p s = 0\\<rbrakk> \\<Longrightarrow> x s = 0\n 4. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "fix s"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. \\<lbrakk>s \\<in> S; p s = 0\\<rbrakk> \\<Longrightarrow> x s = 0\n 4. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "assume \"s \\<in> S\" \"p s = 0\""], ["proof (state)\nthis:\n  s \\<in> S\n  p s = 0\n\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. \\<lbrakk>s \\<in> S; p s = 0\\<rbrakk> \\<Longrightarrow> x s = 0\n 4. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "with 2[of s] p_pos[of s] p_S2[of s] 3[of s]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s \\<in> S1; x s \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>S2.\n                       (s, t)\n                       \\<in> (SIGMA s:S1. \\<Union> (set_pmf ` K s))\\<^sup>*\n  \\<lbrakk>(s, ?t) \\<in> (SIGMA s:S1. \\<Union> (set_pmf ` K s))\\<^sup>*;\n   ?t \\<in> S2\\<rbrakk>\n  \\<Longrightarrow> 0 < p s\n  s \\<in> S2 \\<Longrightarrow> p s = 1\n  s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\n  s \\<in> S\n  p s = 0", "show \"x s = 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> S1; x s \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>S2.\n                       (s, t)\n                       \\<in> (SIGMA s:S1. \\<Union> (set_pmf ` K s))\\<^sup>*\n  \\<lbrakk>(s, ?t) \\<in> (SIGMA s:S1. \\<Union> (set_pmf ` K s))\\<^sup>*;\n   ?t \\<in> S2\\<rbrakk>\n  \\<Longrightarrow> 0 < p s\n  s \\<in> S2 \\<Longrightarrow> p s = 1\n  s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\n  s \\<in> S\n  p s = 0\n\ngoal (1 subgoal):\n 1. x s = 0", "by (cases \"x s = 0\") auto"], ["proof (state)\nthis:\n  x s = 0\n\ngoal (3 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "qed"], ["", "lemma n_lb':\n  fixes x\n  assumes \"wf R\"\n  assumes 1: \"s \\<in> S\" \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> x s \\<le> (\\<Sum>t\\<in>S. pmf D t * x t)\"\n  assumes 2: \"\\<And>s D. s \\<in> S1 \\<Longrightarrow> D \\<in> K s \\<Longrightarrow> x s \\<noteq> 0 \\<Longrightarrow> \\<exists>t\\<in>D. ((t, s) \\<in> R \\<and> t \\<in> S1 \\<and> x t \\<noteq> 0) \\<or> t \\<in> S2\"\n  assumes 3: \"\\<And>s. s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\"\n  assumes 4: \"\\<And>s. s \\<in> S2 \\<Longrightarrow> x s = 1\"\n  shows \"x s \\<le> enn2real (n s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x s \\<le> enn2real (n s)", "proof (rule n_lb[OF 1 _ 4])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. \\<lbrakk>s \\<in> S; n s = 0\\<rbrakk> \\<Longrightarrow> x s = 0\n 4. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "fix s"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. \\<lbrakk>s \\<in> S; n s = 0\\<rbrakk> \\<Longrightarrow> x s = 0\n 4. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "assume *: \"s \\<in> S\" \"n s = 0\""], ["proof (state)\nthis:\n  s \\<in> S\n  n s = 0\n\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. \\<lbrakk>s \\<in> S; n s = 0\\<rbrakk> \\<Longrightarrow> x s = 0\n 4. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "show \"x s = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x s = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x s \\<noteq> 0 \\<Longrightarrow> False", "assume \"x s \\<noteq> 0\""], ["proof (state)\nthis:\n  x s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x s \\<noteq> 0 \\<Longrightarrow> False", "with * n_S2[of s] n_nS12[of s] 3[of s]"], ["proof (chain)\npicking this:\n  s \\<in> S\n  n s = 0\n  s \\<in> S2 \\<Longrightarrow> n s = 1\n  \\<lbrakk>s \\<in> S; s \\<notin> S1; s \\<notin> S2\\<rbrakk>\n  \\<Longrightarrow> n s = 0\n  s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\n  x s \\<noteq> 0", "have \"s \\<in> S1\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  n s = 0\n  s \\<in> S2 \\<Longrightarrow> n s = 1\n  \\<lbrakk>s \\<in> S; s \\<notin> S1; s \\<notin> S2\\<rbrakk>\n  \\<Longrightarrow> n s = 0\n  s \\<in> S - S1 - S2 \\<Longrightarrow> x s = 0\n  x s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<in> S1", "by (metis DiffI zero_neq_one)"], ["proof (state)\nthis:\n  s \\<in> S1\n\ngoal (1 subgoal):\n 1. x s \\<noteq> 0 \\<Longrightarrow> False", "have \"0 < n s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n s", "by (intro n_pos[of \"\\<lambda>s. x s \\<noteq> 0\", OF \\<open>x s \\<noteq> 0\\<close> \\<open>s \\<in> S1\\<close> \\<open>wf R\\<close>])\n         (metis zero_less_one n_S2 2)"], ["proof (state)\nthis:\n  0 < n s\n\ngoal (1 subgoal):\n 1. x s \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>n s = 0\\<close>"], ["proof (chain)\npicking this:\n  n s = 0\n  0 < n s", "show False"], ["proof (prove)\nusing this:\n  n s = 0\n  0 < n s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x s = 0\n\ngoal (3 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> s \\<in> S1\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> S1; D \\<in> K s\\<rbrakk>\n       \\<Longrightarrow> D \\<in> K s\n 3. \\<And>s. s \\<in> S2 \\<Longrightarrow> s \\<in> S2", "qed"], ["", "end"], ["", "no_notation Stream.snth (infixl \"!!\" 100) \\<comment> \\<open>we use @{text \"!!\"} for IArray\\<close>"], ["", "subsection \\<open>Computable representation\\<close>"], ["", "record mdp_reachability_problem =\n  state_count :: nat\n  distrs :: \"(nat \\<times> rat) list list iarray\"\n  states1 :: \"bool iarray\"\n  states2 :: \"bool iarray\""], ["", "record 'a RP_sub_cert =\n  solution :: \"rat iarray\"\n  witness :: \"('a \\<times> nat) iarray\""], ["", "record RP_cert =\n  pos_cert :: \"(nat \\<times> nat) RP_sub_cert\"\n  neg_cert :: \"nat list RP_sub_cert\""], ["", "definition \"sparse_mult sx y = sum_list (map (\\<lambda>(n, x). x * y !! n) sx)\""], ["", "primrec lookup where\n  \"lookup d [] x = d\"\n| \"lookup d (y#ys) x = (if fst y = x then snd y else lookup d ys x)\""], ["", "lemma lookup_eq_map_of: \"lookup d xs x = (case map_of xs x of Some x \\<Rightarrow> x | None \\<Rightarrow> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup d xs x =\n    (case map_of xs x of None \\<Rightarrow> d | Some x \\<Rightarrow> x)", "by (induct xs) simp_all"], ["", "lemma lookup_in_set:\n  \"distinct (map fst xs) \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> lookup d xs (fst x) = snd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> lookup d xs (fst x) = snd x", "unfolding lookup_eq_map_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> (case map_of xs (fst x) of None \\<Rightarrow> d\n                       | Some x \\<Rightarrow> x) =\n                      snd x", "by (subst map_of_is_SomeI[where y=\"snd x\"]) simp_all"], ["", "lemma lookup_not_in_set:\n  \"x \\<notin> fst ` set xs \\<Longrightarrow> lookup d xs x = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set xs \\<Longrightarrow> lookup d xs x = d", "unfolding lookup_eq_map_of"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set xs \\<Longrightarrow>\n    (case map_of xs x of None \\<Rightarrow> d | Some x \\<Rightarrow> x) = d", "by (subst map_of_eq_None_iff[of xs x, THEN iffD2]) auto"], ["", "lemma lookup_nonneg:\n  \"(\\<And>x v. (x, v) \\<in> set xs \\<Longrightarrow> 0 \\<le> v) \\<Longrightarrow> (0::'a::ordered_comm_monoid_add) \\<le> lookup 0 xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x v.\n        (x, v) \\<in> set xs \\<Longrightarrow>\n        (0::'a) \\<le> v) \\<Longrightarrow>\n    (0::'a) \\<le> lookup (0::'a) xs x", "apply (induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x v.\n        (x, v) \\<in> set [] \\<Longrightarrow>\n        (0::'a) \\<le> v) \\<Longrightarrow>\n    (0::'a) \\<le> lookup (0::'a) [] x\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x v.\n                    (x, v) \\<in> set xs \\<Longrightarrow>\n                    (0::'a) \\<le> v) \\<Longrightarrow>\n                (0::'a) \\<le> lookup (0::'a) xs x;\n        \\<And>x v.\n           (x, v) \\<in> set (a # xs) \\<Longrightarrow>\n           (0::'a) \\<le> v\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> lookup (0::'a) (a # xs) x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>(\\<And>x v.\n                    (x, v) \\<in> set xs \\<Longrightarrow>\n                    (0::'a) \\<le> v) \\<Longrightarrow>\n                (0::'a) \\<le> lookup (0::'a) xs x;\n        \\<And>x v.\n           (x, v) \\<in> set (a # xs) \\<Longrightarrow>\n           (0::'a) \\<le> v\\<rbrakk>\n       \\<Longrightarrow> (0::'a) \\<le> lookup (0::'a) (a # xs) x", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sparse_mult_eq_sum_lookup:\n  fixes xs :: \"(nat \\<times> 'a::comm_semiring_1) list\"\n  assumes \"list_all (\\<lambda>(n, x). n < M) xs\" \"distinct (map fst xs)\"\n  shows \"sparse_mult xs y = (\\<Sum>i<M. lookup 0 xs i * y !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "from \\<open>distinct (map fst xs)\\<close>"], ["proof (chain)\npicking this:\n  distinct (map fst xs)", "have \"distinct xs\" \"inj_on fst (set xs)\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct xs &&& inj_on fst (set xs)", "by (simp_all add: distinct_map)"], ["proof (state)\nthis:\n  distinct xs\n  inj_on fst (set xs)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  inj_on fst (set xs)", "have \"sparse_mult xs y = (\\<Sum>x\\<in>set xs. snd x * y !! fst x)\""], ["proof (prove)\nusing this:\n  distinct xs\n  inj_on fst (set xs)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>x\\<in>set xs. snd x * y !! fst x)", "by (auto intro!: sum.cong simp add: sparse_mult_def sum_list_distinct_conv_sum_set)"], ["proof (state)\nthis:\n  sparse_mult xs y = (\\<Sum>x\\<in>set xs. snd x * y !! fst x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "also"], ["proof (state)\nthis:\n  sparse_mult xs y = (\\<Sum>x\\<in>set xs. snd x * y !! fst x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "have \"\\<dots> = (\\<Sum>x\\<in>set xs. lookup 0 xs (fst x) * y !! fst x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set xs. snd x * y !! fst x) =\n    (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x)", "by (intro sum.cong refl arg_cong2[where f=\"(*)\"]) (simp add: lookup_in_set assms)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set xs. snd x * y !! fst x) =\n  (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set xs. snd x * y !! fst x) =\n  (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "have \"\\<dots> = (\\<Sum>x\\<in>fst ` set xs. lookup 0 xs x * y !! x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x) =\n    (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x)", "using \\<open>inj_on fst (set xs)\\<close>"], ["proof (prove)\nusing this:\n  inj_on fst (set xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x) =\n    (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x)", "by (simp add: sum.reindex)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x) =\n  (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x) * y !! fst x) =\n  (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "have \"\\<dots> = (\\<Sum>x<M. lookup 0 xs x * y !! x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x) =\n    (\\<Sum>x<M. lookup (0::'a) xs x * y !! x)", "using assms(1)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(n, x). n < M) xs\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x) =\n    (\\<Sum>x<M. lookup (0::'a) xs x * y !! x)", "by (intro sum.mono_neutral_cong_left)\n       (auto simp: list_all_iff lookup_eq_map_of map_of_eq_None_iff[THEN iffD2])"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>fst ` set xs. lookup (0::'a) xs x * y !! x) =\n  (\\<Sum>x<M. lookup (0::'a) xs x * y !! x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "finally"], ["proof (chain)\npicking this:\n  sparse_mult xs y = (\\<Sum>x<M. lookup (0::'a) xs x * y !! x)", "show ?thesis"], ["proof (prove)\nusing this:\n  sparse_mult xs y = (\\<Sum>x<M. lookup (0::'a) xs x * y !! x)\n\ngoal (1 subgoal):\n 1. sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)", "."], ["proof (state)\nthis:\n  sparse_mult xs y = (\\<Sum>i<M. lookup (0::'a) xs i * y !! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_eq_sum_lookup:\n  fixes xs :: \"(nat \\<times> 'a::comm_semiring_1) list\"\n  assumes \"list_all (\\<lambda>(n, x). n < M) xs\" \"distinct (map fst xs)\"\n  shows \"sum_list (map snd xs) = (\\<Sum>i<M. lookup 0 xs i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "from \\<open>distinct (map fst xs)\\<close>"], ["proof (chain)\npicking this:\n  distinct (map fst xs)", "have \"distinct xs\" \"inj_on fst (set xs)\""], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n\ngoal (1 subgoal):\n 1. distinct xs &&& inj_on fst (set xs)", "by (simp_all add: distinct_map)"], ["proof (state)\nthis:\n  distinct xs\n  inj_on fst (set xs)\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "then"], ["proof (chain)\npicking this:\n  distinct xs\n  inj_on fst (set xs)", "have \"sum_list (map snd xs) = (\\<Sum>x\\<in>set xs. snd x)\""], ["proof (prove)\nusing this:\n  distinct xs\n  inj_on fst (set xs)\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum snd (set xs)", "by (auto intro!: sum.cong simp add: sparse_mult_def sum_list_distinct_conv_sum_set)"], ["proof (state)\nthis:\n  sum_list (map snd xs) = sum snd (set xs)\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "also"], ["proof (state)\nthis:\n  sum_list (map snd xs) = sum snd (set xs)\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "have \"\\<dots> = (\\<Sum>x\\<in>set xs. lookup 0 xs (fst x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum snd (set xs) = (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x))", "by (intro sum.cong refl arg_cong2[where f=\"(*)\"]) (simp add: lookup_in_set assms)"], ["proof (state)\nthis:\n  sum snd (set xs) = (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x))\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "also"], ["proof (state)\nthis:\n  sum snd (set xs) = (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x))\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "have \"\\<dots> = (\\<Sum>x\\<in>fst ` set xs. lookup 0 xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x)) =\n    sum (lookup (0::'a) xs) (fst ` set xs)", "using \\<open>inj_on fst (set xs)\\<close>"], ["proof (prove)\nusing this:\n  inj_on fst (set xs)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x)) =\n    sum (lookup (0::'a) xs) (fst ` set xs)", "by (simp add: sum.reindex)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x)) =\n  sum (lookup (0::'a) xs) (fst ` set xs)\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>set xs. lookup (0::'a) xs (fst x)) =\n  sum (lookup (0::'a) xs) (fst ` set xs)\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "have \"\\<dots> = (\\<Sum>x<M. lookup 0 xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (lookup (0::'a) xs) (fst ` set xs) = sum (lookup (0::'a) xs) {..<M}", "using assms(1)"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>(n, x). n < M) xs\n\ngoal (1 subgoal):\n 1. sum (lookup (0::'a) xs) (fst ` set xs) = sum (lookup (0::'a) xs) {..<M}", "by (intro sum.mono_neutral_cong_left)\n       (auto simp: list_all_iff lookup_eq_map_of map_of_eq_None_iff[THEN iffD2])"], ["proof (state)\nthis:\n  sum (lookup (0::'a) xs) (fst ` set xs) = sum (lookup (0::'a) xs) {..<M}\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "finally"], ["proof (chain)\npicking this:\n  sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "show ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}\n\ngoal (1 subgoal):\n 1. sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}", "."], ["proof (state)\nthis:\n  sum_list (map snd xs) = sum (lookup (0::'a) xs) {..<M}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"valid_mdp_rp mdp \\<longleftrightarrow>\n    0 < state_count mdp \\<and>\n    IArray.length (distrs mdp) = state_count mdp \\<and>\n    IArray.length (states1 mdp) = state_count mdp \\<and>\n    IArray.length (states2 mdp) = state_count mdp \\<and>\n    (\\<forall>i<state_count mdp. \\<not> (states1 mdp !! i \\<and> states2 mdp !! i) \\<and>\n      list_all (\\<lambda>ds. distinct (map fst ds) \\<and> list_all (\\<lambda>(n, x). 0 \\<le> x \\<and> n < state_count mdp) ds \\<and>\n                     sum_list (map snd ds) = 1) (distrs mdp !! i) \\<and>\n      \\<not> List.null (distrs mdp !! i))\""], ["", "definition\n  \"valid_sub_cert mdp c ord check \\<longleftrightarrow>\n    IArray.length (witness c) = state_count mdp \\<and>\n    IArray.length (solution c) = state_count mdp \\<and>\n    (\\<forall>i<state_count mdp.\n      if states2 mdp !! i then solution c !! i = 1\n      else if states1 mdp !! i then 0 \\<le> solution c !! i \\<and>\n        (list_all (\\<lambda>ds. ord (sparse_mult ds (solution c)) (solution c !! i)) (distrs mdp !! i)) \\<and>\n        (0 < solution c !! i \\<longrightarrow> check (distrs mdp !! i) (witness c !! i))\n      else solution c !! i = 0)\""], ["", "definition\n  \"valid_pos_cert mdp c \\<longleftrightarrow>\n    valid_sub_cert mdp c (\\<le>)\n      (\\<lambda>D ((j, a), n). j < state_count mdp \\<and> snd (witness c !! j) < n \\<and> 0 < solution c !! j \\<and>\n        a < length D \\<and> lookup 0 (D ! a) j \\<noteq> 0)\""], ["", "definition\n  \"valid_neg_cert mdp c \\<longleftrightarrow>\n    valid_sub_cert mdp c (\\<ge>)\n      (\\<lambda>D (J, n). list_all2 (\\<lambda>j d. j < state_count mdp \\<and> snd (witness c !! j) < n \\<and>\n        lookup 0 d j \\<noteq> 0 \\<and> 0 < solution c !! j) J D)\""], ["", "definition\n  \"valid_cert mdp c \\<longleftrightarrow> valid_pos_cert mdp (pos_cert c) \\<and> valid_neg_cert mdp (neg_cert c)\""], ["", "lemma valid_mdp_rpD_length:\n  assumes \"valid_mdp_rp mdp\"\n  shows \"0 < state_count mdp\" \"IArray.length (distrs mdp) = state_count mdp\"\n    \"IArray.length (states1 mdp) = state_count mdp\" \"IArray.length (states2 mdp) = state_count mdp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < state_count mdp &&&\n     IArray.length (distrs mdp) = state_count mdp) &&&\n    IArray.length (states1 mdp) = state_count mdp &&&\n    IArray.length (states2 mdp) = state_count mdp", "using assms"], ["proof (prove)\nusing this:\n  valid_mdp_rp mdp\n\ngoal (1 subgoal):\n 1. (0 < state_count mdp &&&\n     IArray.length (distrs mdp) = state_count mdp) &&&\n    IArray.length (states1 mdp) = state_count mdp &&&\n    IArray.length (states2 mdp) = state_count mdp", "by (auto simp: valid_mdp_rp_def)"], ["", "lemma valid_mdp_rpD:\n  assumes \"valid_mdp_rp mdp\" \"i < state_count mdp\"\n  shows \"\\<not> (states1 mdp !! i \\<and> states2 mdp !! i)\"\n    and \"\\<And>ds n x. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> (n, x) \\<in> set ds \\<Longrightarrow> n < state_count mdp\"\n    and \"\\<And>ds n x. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> (n, x) \\<in> set ds \\<Longrightarrow> 0 \\<le> x\"\n    and \"\\<And>ds. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> sum_list (map snd ds) = 1\"\n    and \"\\<And>ds. ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> distinct (map fst ds)\"\n    and \"distrs mdp !! i \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> (states1 mdp !! i \\<and> states2 mdp !! i) &&&\n     (\\<And>ds n x.\n         \\<lbrakk>ds \\<in> set (distrs mdp !! i);\n          (n, x) \\<in> set ds\\<rbrakk>\n         \\<Longrightarrow> n < state_count mdp) &&&\n     (\\<And>ds n x.\n         \\<lbrakk>ds \\<in> set (distrs mdp !! i);\n          (n, x) \\<in> set ds\\<rbrakk>\n         \\<Longrightarrow> 0 \\<le> x)) &&&\n    (\\<And>ds.\n        ds \\<in> set (distrs mdp !! i) \\<Longrightarrow>\n        sum_list (map snd ds) = 1) &&&\n    (\\<And>ds.\n        ds \\<in> set (distrs mdp !! i) \\<Longrightarrow>\n        distinct (map fst ds)) &&&\n    distrs mdp !! i \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  valid_mdp_rp mdp\n  i < state_count mdp\n\ngoal (1 subgoal):\n 1. (\\<not> (states1 mdp !! i \\<and> states2 mdp !! i) &&&\n     (\\<And>ds n x.\n         \\<lbrakk>ds \\<in> set (distrs mdp !! i);\n          (n, x) \\<in> set ds\\<rbrakk>\n         \\<Longrightarrow> n < state_count mdp) &&&\n     (\\<And>ds n x.\n         \\<lbrakk>ds \\<in> set (distrs mdp !! i);\n          (n, x) \\<in> set ds\\<rbrakk>\n         \\<Longrightarrow> 0 \\<le> x)) &&&\n    (\\<And>ds.\n        ds \\<in> set (distrs mdp !! i) \\<Longrightarrow>\n        sum_list (map snd ds) = 1) &&&\n    (\\<And>ds.\n        ds \\<in> set (distrs mdp !! i) \\<Longrightarrow>\n        distinct (map fst ds)) &&&\n    distrs mdp !! i \\<noteq> []", "by (auto simp: valid_mdp_rp_def list_all_iff List.null_def elim!: allE[of _ i])"], ["", "lemma valid_mdp_rp_sparse_mult:\n  assumes \"valid_mdp_rp mdp\" \"i < state_count mdp\" \"ds \\<in> set (distrs mdp !! i)\"\n  shows \"sparse_mult ds y = (\\<Sum>i<state_count mdp. lookup 0 ds i * y !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sparse_mult ds y = (\\<Sum>i<state_count mdp. lookup 0 ds i * y !! i)", "using valid_mdp_rpD(2,5)[OF assms]"], ["proof (prove)\nusing this:\n  (?n, ?x) \\<in> set ds \\<Longrightarrow> ?n < state_count mdp\n  distinct (map fst ds)\n\ngoal (1 subgoal):\n 1. sparse_mult ds y = (\\<Sum>i<state_count mdp. lookup 0 ds i * y !! i)", "by (intro sparse_mult_eq_sum_lookup) (auto simp: list_all_iff)"], ["", "lemma valid_sub_certD:\n  assumes \"valid_mdp_rp mdp\" \"valid_sub_cert mdp c ord check\" \"i < state_count mdp\"\n  shows \"\\<not> states1 mdp !! i \\<Longrightarrow> \\<not> states2 mdp !! i \\<Longrightarrow> solution c !! i = 0\"\n    and \"states2 mdp !! i \\<Longrightarrow> solution c !! i = 1\"\n    and \"states1 mdp !! i \\<Longrightarrow> 0 \\<le> solution c !! i\"\n    and \"\\<And>ds. states1 mdp !! i \\<Longrightarrow> ds \\<in> set (distrs mdp !! i) \\<Longrightarrow> ord (sparse_mult ds (solution c)) (solution c !! i)\"\n    and \"\\<And>ds. states1 mdp !! i \\<Longrightarrow> 0 < solution c !! i \\<longrightarrow> check (distrs mdp !! i) (witness c !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<not> states1 mdp !! i; \\<not> states2 mdp !! i\\<rbrakk>\n      \\<Longrightarrow> solution c !! i = 0) &&&\n     (states2 mdp !! i \\<Longrightarrow> solution c !! i = 1)) &&&\n    (states1 mdp !! i \\<Longrightarrow> 0 \\<le> solution c !! i) &&&\n    (\\<And>ds.\n        \\<lbrakk>states1 mdp !! i; ds \\<in> set (distrs mdp !! i)\\<rbrakk>\n        \\<Longrightarrow> ord (sparse_mult ds (solution c))\n                           (solution c !! i)) &&&\n    (\\<And>ds.\n        states1 mdp !! i \\<Longrightarrow>\n        0 < solution c !! i \\<longrightarrow>\n        check (distrs mdp !! i) (witness c !! i))", "using assms(2,3) valid_mdp_rpD(1)[OF assms(1,3)]"], ["proof (prove)\nusing this:\n  valid_sub_cert mdp c ord check\n  i < state_count mdp\n  \\<not> (states1 mdp !! i \\<and> states2 mdp !! i)\n\ngoal (1 subgoal):\n 1. ((\\<lbrakk>\\<not> states1 mdp !! i; \\<not> states2 mdp !! i\\<rbrakk>\n      \\<Longrightarrow> solution c !! i = 0) &&&\n     (states2 mdp !! i \\<Longrightarrow> solution c !! i = 1)) &&&\n    (states1 mdp !! i \\<Longrightarrow> 0 \\<le> solution c !! i) &&&\n    (\\<And>ds.\n        \\<lbrakk>states1 mdp !! i; ds \\<in> set (distrs mdp !! i)\\<rbrakk>\n        \\<Longrightarrow> ord (sparse_mult ds (solution c))\n                           (solution c !! i)) &&&\n    (\\<And>ds.\n        states1 mdp !! i \\<Longrightarrow>\n        0 < solution c !! i \\<longrightarrow>\n        check (distrs mdp !! i) (witness c !! i))", "by (auto simp add: valid_sub_cert_def list_all_iff)"], ["", "lemma valid_pos_certD:\n  assumes \"valid_mdp_rp mdp\" \"valid_pos_cert mdp c\" \"i < state_count mdp\" \"states1 mdp !! i\"\n    \"0 < solution c !! i\" \"witness c !! i = ((j, a), n)\"\n  shows \"snd (witness c !! j) < n \\<and> j < state_count mdp \\<and> a < length (distrs mdp !! i) \\<and>\n          lookup 0 ((distrs mdp !! i) ! a) j \\<noteq> 0 \\<and> 0 < solution c !! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (witness c !! j) < n \\<and>\n    j < state_count mdp \\<and>\n    a < length (distrs mdp !! i) \\<and>\n    lookup 0 (distrs mdp !! i ! a) j \\<noteq> 0 \\<and> 0 < solution c !! j", "using valid_sub_certD(5)[OF assms(1) assms(2)[unfolded valid_pos_cert_def] assms(3,4)] assms(5-)"], ["proof (prove)\nusing this:\n  0 < solution c !! i \\<longrightarrow>\n  (case witness c !! i of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (j, a) \\<Rightarrow>\n        \\<lambda>n.\n           j < state_count mdp \\<and>\n           snd (witness c !! j) < n \\<and>\n           0 < solution c !! j \\<and>\n           a < length (distrs mdp !! i) \\<and>\n           lookup 0 (distrs mdp !! i ! a) j \\<noteq> 0)\n      xa)\n  0 < solution c !! i\n  witness c !! i = ((j, a), n)\n\ngoal (1 subgoal):\n 1. snd (witness c !! j) < n \\<and>\n    j < state_count mdp \\<and>\n    a < length (distrs mdp !! i) \\<and>\n    lookup 0 (distrs mdp !! i ! a) j \\<noteq> 0 \\<and> 0 < solution c !! j", "by auto"], ["", "lemma valid_neg_certD:\n  assumes \"valid_mdp_rp mdp\" \"valid_neg_cert mdp c\" \"i < state_count mdp\" \"states1 mdp !! i\"\n    \"0 < solution c !! i\" \"witness c !! i = (js, n)\"\n  shows \"list_all2 (\\<lambda>j ds. j < state_count mdp \\<and> snd (witness c !! j) < n \\<and> lookup 0 ds j \\<noteq> 0 \\<and> 0 < solution c !! j) js (distrs mdp !! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>j ds.\n         j < state_count mdp \\<and>\n         snd (witness c !! j) < n \\<and>\n         lookup 0 ds j \\<noteq> 0 \\<and> 0 < solution c !! j)\n     js (distrs mdp !! i)", "using valid_sub_certD(5)[OF assms(1) assms(2)[unfolded valid_neg_cert_def] assms(3)] assms(4-)"], ["proof (prove)\nusing this:\n  states1 mdp !! i \\<Longrightarrow>\n  0 < solution c !! i \\<longrightarrow>\n  (case witness c !! i of\n   (J, n) \\<Rightarrow>\n     list_all2\n      (\\<lambda>j d.\n          j < state_count mdp \\<and>\n          snd (witness c !! j) < n \\<and>\n          lookup 0 d j \\<noteq> 0 \\<and> 0 < solution c !! j)\n      J (distrs mdp !! i))\n  states1 mdp !! i\n  0 < solution c !! i\n  witness c !! i = (js, n)\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>j ds.\n         j < state_count mdp \\<and>\n         snd (witness c !! j) < n \\<and>\n         lookup 0 ds j \\<noteq> 0 \\<and> 0 < solution c !! j)\n     js (distrs mdp !! i)", "by auto"], ["", "context\n  fixes mdp c\n  assumes rp: \"valid_mdp_rp mdp\"\n  assumes cert: \"valid_cert mdp c\"\nbegin"], ["", "interpretation pmf_as_function"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "abbreviation \"S \\<equiv> {..< state_count mdp}\""], ["", "abbreviation \"S1 \\<equiv> {i. i < state_count mdp \\<and> (states1 mdp) !! i}\""], ["", "abbreviation \"S2 \\<equiv> {i. i < state_count mdp \\<and> (states2 mdp) !! i}\""], ["", "lift_definition K :: \"nat \\<Rightarrow> nat pmf set\" is\n  \"\\<lambda>i. if i < state_count mdp then\n     { (\\<lambda>j. of_rat (lookup 0 D j) :: real) | D. D \\<in> set (distrs mdp !! i) }\n     else { indicator {0} }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       fun\n       \\<in> (if nat < state_count mdp\n              then {\\<lambda>j. real_of_rat (lookup 0 D j) |D.\n                    D \\<in> set (distrs mdp !! nat)}\n              else {indicat_real {0}}) \\<Longrightarrow>\n       (\\<forall>x. 0 \\<le> fun x) \\<and>\n       \\<integral>\\<^sup>+ x. ennreal (fun x) \\<partial>count_space UNIV = 1", "proof (auto split: if_split_asm simp del: IArray.sub_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>nat D x.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> lookup 0 D x\n 2. \\<And>nat D.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ x.\n        ennreal (real_of_rat (lookup 0 D x))\n      \\<partial>count_space UNIV =\n                         1\n 3. \\<And>nat.\n       \\<not> nat < state_count mdp \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal (indicat_real {0} x)\n                          \\<partial>count_space UNIV =\n       1", "fix n D"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>nat D x.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> lookup 0 D x\n 2. \\<And>nat D.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ x.\n        ennreal (real_of_rat (lookup 0 D x))\n      \\<partial>count_space UNIV =\n                         1\n 3. \\<And>nat.\n       \\<not> nat < state_count mdp \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal (indicat_real {0} x)\n                          \\<partial>count_space UNIV =\n       1", "assume n: \"n < state_count mdp\" and D: \"D \\<in> set (distrs mdp !! n)\""], ["proof (state)\nthis:\n  n < state_count mdp\n  D \\<in> set (distrs mdp !! n)\n\ngoal (3 subgoals):\n 1. \\<And>nat D x.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> lookup 0 D x\n 2. \\<And>nat D.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ x.\n        ennreal (real_of_rat (lookup 0 D x))\n      \\<partial>count_space UNIV =\n                         1\n 3. \\<And>nat.\n       \\<not> nat < state_count mdp \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal (indicat_real {0} x)\n                          \\<partial>count_space UNIV =\n       1", "from valid_mdp_rpD(3)[OF rp this]"], ["proof (chain)\npicking this:\n  (?n, ?x) \\<in> set D \\<Longrightarrow> 0 \\<le> ?x", "show nn: \"\\<And>i. 0 \\<le> lookup 0 D i\""], ["proof (prove)\nusing this:\n  (?n, ?x) \\<in> set D \\<Longrightarrow> 0 \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>i. 0 \\<le> lookup 0 D i", "by (auto simp add: lookup_eq_map_of split: option.split dest: map_of_SomeD)"], ["proof (state)\nthis:\n  0 \\<le> lookup 0 D ?i\n\ngoal (2 subgoals):\n 1. \\<And>nat D.\n       \\<lbrakk>nat < state_count mdp;\n        D \\<in> set (distrs mdp !! nat)\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ x.\n        ennreal (real_of_rat (lookup 0 D x))\n      \\<partial>count_space UNIV =\n                         1\n 2. \\<And>nat.\n       \\<not> nat < state_count mdp \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal (indicat_real {0} x)\n                          \\<partial>count_space UNIV =\n       1", "show \"(\\<integral>\\<^sup>+ x. ennreal (real_of_rat (lookup 0 D x)) \\<partial>count_space UNIV) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real_of_rat (lookup 0 D x))\n                       \\<partial>count_space UNIV =\n    1", "using valid_mdp_rpD(2,3,4,5)[OF rp n D]"], ["proof (prove)\nusing this:\n  (?n, ?x) \\<in> set D \\<Longrightarrow> ?n < state_count mdp\n  (?n, ?x) \\<in> set D \\<Longrightarrow> 0 \\<le> ?x\n  sum_list (map snd D) = 1\n  distinct (map fst D)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (real_of_rat (lookup 0 D x))\n                       \\<partial>count_space UNIV =\n    1", "apply (subst nn_integral_count_space'[of \"{..< state_count mdp}\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> finite local.S\n 2. \\<And>x.\n       \\<lbrakk>\\<And>n x.\n                   (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n        \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n        sum_list (map snd D) = 1; distinct (map fst D); x \\<in> UNIV;\n        x \\<notin> local.S\\<rbrakk>\n       \\<Longrightarrow> ennreal (real_of_rat (lookup 0 D x)) = 0\n 3. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> local.S \\<subseteq> UNIV\n 4. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>x\\<in>local.S.\n                         ennreal (real_of_rat (lookup 0 D x))) =\n                      1", "apply (auto intro: nn lookup_not_in_set simp: of_rat_sum[symmetric] lookup_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> sum (lookup 0 D) local.S = 1", "apply (subst sum_list_eq_sum_lookup[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> list_all (\\<lambda>(n, x). n < state_count mdp) D\n 2. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst D)\n 3. \\<lbrakk>\\<And>n x.\n                (n, x) \\<in> set D \\<Longrightarrow> n < state_count mdp;\n     \\<And>n x. (n, x) \\<in> set D \\<Longrightarrow> 0 \\<le> x;\n     sum_list (map snd D) = 1; distinct (map fst D)\\<rbrakk>\n    \\<Longrightarrow> sum_list (map snd D) = 1", "apply (auto simp: list_all_iff lookup_eq_map_of split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (real_of_rat (lookup 0 D x))\n                     \\<partial>count_space UNIV =\n  1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<not> nat < state_count mdp \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal (indicat_real {0} x)\n                          \\<partial>count_space UNIV =\n       1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<not> nat < state_count mdp \\<Longrightarrow>\n       \\<integral>\\<^sup>+ x. ennreal (indicat_real {0} x)\n                          \\<partial>count_space UNIV =\n       1", "show \"(\\<integral>\\<^sup>+ x. ennreal (indicator {0} x) \\<partial>count_space UNIV) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal (indicat_real {0::'c} x)\n                       \\<partial>count_space UNIV =\n    1", "by (subst nn_integral_count_space'[of \"{0}\"]) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal (indicat_real {0::?'c1} x)\n                     \\<partial>count_space UNIV =\n  1\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation MDP: Reachability_Problem K S S1 S2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Reachability_Problem local.K local.S local.S1 local.S2", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s. local.K s \\<noteq> {}\n 2. local.S \\<noteq> {}\n 3. finite local.S\n 4. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S\n 5. \\<And>s. s \\<in> local.S \\<Longrightarrow> finite (local.K s)\n 6. local.S1 \\<subseteq> local.S\n 7. local.S2 \\<subseteq> local.S\n 8. local.S1 \\<inter> local.S2 = {}", "show \"S1 \\<inter> S2 = {}\" \"S1 \\<subseteq> S\" \"S2 \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.S1 \\<inter> local.S2 = {} &&&\n    local.S1 \\<subseteq> local.S &&& local.S2 \\<subseteq> local.S", "using valid_mdp_rpD(1)[OF rp]"], ["proof (prove)\nusing this:\n  ?i < state_count mdp \\<Longrightarrow>\n  \\<not> (states1 mdp !! ?i \\<and> states2 mdp !! ?i)\n\ngoal (1 subgoal):\n 1. local.S1 \\<inter> local.S2 = {} &&&\n    local.S1 \\<subseteq> local.S &&& local.S2 \\<subseteq> local.S", "by auto"], ["proof (state)\nthis:\n  local.S1 \\<inter> local.S2 = {}\n  local.S1 \\<subseteq> local.S\n  local.S2 \\<subseteq> local.S\n\ngoal (5 subgoals):\n 1. \\<And>s. local.K s \\<noteq> {}\n 2. local.S \\<noteq> {}\n 3. finite local.S\n 4. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S\n 5. \\<And>s. s \\<in> local.S \\<Longrightarrow> finite (local.K s)", "show \"finite S\" \"S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite local.S &&& local.S \\<noteq> {}", "using \\<open>valid_mdp_rp mdp\\<close>"], ["proof (prove)\nusing this:\n  valid_mdp_rp mdp\n\ngoal (1 subgoal):\n 1. finite local.S &&& local.S \\<noteq> {}", "by (auto simp add: valid_mdp_rp_def)"], ["proof (state)\nthis:\n  finite local.S\n  local.S \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>s. local.K s \\<noteq> {}\n 2. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S\n 3. \\<And>s. s \\<in> local.S \\<Longrightarrow> finite (local.K s)", "show \"\\<And>s. K s \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. local.K s \\<noteq> {}", "using valid_mdp_rpD(6)[OF rp]"], ["proof (prove)\nusing this:\n  ?i < state_count mdp \\<Longrightarrow> distrs mdp !! ?i \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s. local.K s \\<noteq> {}", "by transfer simp"], ["proof (state)\nthis:\n  local.K ?s \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S\n 2. \\<And>s. s \\<in> local.S \\<Longrightarrow> finite (local.K s)", "show \"\\<And>s. finite (K s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. finite (local.K s)", "by transfer simp"], ["proof (state)\nthis:\n  finite (local.K ?s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S", "assume \"s \\<in> S\""], ["proof (state)\nthis:\n  s \\<in> local.S\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S \\<Longrightarrow>\n       \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S", "show \"(\\<Union>D\\<in>K s. set_pmf D) \\<subseteq> S\""], ["proof (prove)\nusing this:\n  s \\<in> local.S\n\ngoal (1 subgoal):\n 1. \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S", "using valid_mdp_rpD(2)[OF rp]"], ["proof (prove)\nusing this:\n  s \\<in> local.S\n  \\<lbrakk>?i < state_count mdp; ?ds \\<in> set (distrs mdp !! ?i);\n   (?n, ?x) \\<in> set ?ds\\<rbrakk>\n  \\<Longrightarrow> ?n < state_count mdp\n\ngoal (1 subgoal):\n 1. \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S", "by transfer (auto simp: lookup_eq_map_of split: option.splits dest!: map_of_SomeD)"], ["proof (state)\nthis:\n  \\<Union> (set_pmf ` local.K s) \\<subseteq> local.S\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"P_max s = enn2real (MDP.p s)\""], ["", "definition \"P_min s = enn2real (MDP.n s)\""], ["", "lemma\n  assumes \"i < state_count mdp\"\n  shows P_max: \"P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\" (is ?max)\n    and P_min: \"P_min i \\<ge> real_of_rat (solution (neg_cert c) !! i)\" (is ?min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i) &&&\n    real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\n 2. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "have \"valid_pos_cert mdp (pos_cert c)\" \"valid_neg_cert mdp (neg_cert c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_pos_cert mdp (pos_cert c) &&& valid_neg_cert mdp (neg_cert c)", "using \\<open>valid_cert mdp c\\<close>"], ["proof (prove)\nusing this:\n  valid_cert mdp c\n\ngoal (1 subgoal):\n 1. valid_pos_cert mdp (pos_cert c) &&& valid_neg_cert mdp (neg_cert c)", "by (auto simp: valid_cert_def)"], ["proof (state)\nthis:\n  valid_pos_cert mdp (pos_cert c)\n  valid_neg_cert mdp (neg_cert c)\n\ngoal (2 subgoals):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\n 2. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "note pos = this(1)[unfolded valid_pos_cert_def] and neg = this(2)[unfolded valid_neg_cert_def]"], ["proof (state)\nthis:\n  valid_sub_cert mdp (pos_cert c) (\\<le>)\n   (\\<lambda>D ((j, a), n).\n       j < state_count mdp \\<and>\n       snd (witness (pos_cert c) !! j) < n \\<and>\n       0 < solution (pos_cert c) !! j \\<and>\n       a < length D \\<and> lookup 0 (D ! a) j \\<noteq> 0)\n  valid_sub_cert mdp (neg_cert c) (\\<lambda>x y. y \\<le> x)\n   (\\<lambda>D (J, n).\n       list_all2\n        (\\<lambda>j d.\n            j < state_count mdp \\<and>\n            snd (witness (neg_cert c) !! j) < n \\<and>\n            lookup 0 d j \\<noteq> 0 \\<and> 0 < solution (neg_cert c) !! j)\n        J D)\n\ngoal (2 subgoals):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\n 2. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "let ?x = \"\\<lambda>s. real_of_rat (solution (pos_cert c) !! s)\""], ["proof (state)\ngoal (2 subgoals):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\n 2. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "have \"enn2real (MDP.p i) \\<le> ?x i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (MDP.p i) \\<le> real_of_rat (solution (pos_cert c) !! i)", "proof (rule MDP.p_ub')"], ["proof (state)\ngoal (5 subgoals):\n 1. i \\<in> local.S\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>local.S.\n                            pmf D t *\n                            real_of_rat (solution (pos_cert c) !! t))\n                         \\<le> real_of_rat (solution (pos_cert c) !! s)\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 4. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 5. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "show \"i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> local.S", "using assms"], ["proof (prove)\nusing this:\n  i < state_count mdp\n\ngoal (1 subgoal):\n 1. i \\<in> local.S", "by simp"], ["proof (state)\nthis:\n  i \\<in> local.S\n\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>local.S.\n                            pmf D t *\n                            real_of_rat (solution (pos_cert c) !! t))\n                         \\<le> real_of_rat (solution (pos_cert c) !! s)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>local.S.\n                            pmf D t *\n                            real_of_rat (solution (pos_cert c) !! t))\n                         \\<le> real_of_rat (solution (pos_cert c) !! s)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "fix s D"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>local.S.\n                            pmf D t *\n                            real_of_rat (solution (pos_cert c) !! t))\n                         \\<le> real_of_rat (solution (pos_cert c) !! s)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "assume \"s \\<in> S1\" \"D \\<in> K s\""], ["proof (state)\nthis:\n  s \\<in> local.S1\n  D \\<in> local.K s\n\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>local.S.\n                            pmf D t *\n                            real_of_rat (solution (pos_cert c) !! t))\n                         \\<le> real_of_rat (solution (pos_cert c) !! s)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S1\n  D \\<in> local.K s", "obtain j where j: \"j < length (distrs mdp !! s)\"\n      \"\\<And>i. i < state_count mdp \\<Longrightarrow> pmf D i = real_of_rat (lookup 0 (distrs mdp !! s ! j) i)\""], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  D \\<in> local.K s\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length (distrs mdp !! s);\n         \\<And>i.\n            i < state_count mdp \\<Longrightarrow>\n            pmf D i =\n            real_of_rat (lookup 0 (distrs mdp !! s ! j) i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! j) ?i1)\n\ngoal (4 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>t\\<in>local.S.\n                            pmf D t *\n                            real_of_rat (solution (pos_cert c) !! t))\n                         \\<le> real_of_rat (solution (pos_cert c) !! s)\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "with valid_sub_certD(4)[OF \\<open>valid_mdp_rp mdp\\<close> pos, of s \"distrs mdp !! s ! j\"] \\<open>s \\<in> S1\\<close>\n         valid_mdp_rp_sparse_mult[OF \\<open>valid_mdp_rp mdp\\<close>, of s \"distrs mdp !! s ! j\" \"solution (pos_cert c)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult (distrs mdp !! s ! j)\n                     (solution (pos_cert c))\n                    \\<le> solution (pos_cert c) !! s\n  s \\<in> local.S1\n  \\<lbrakk>s < state_count mdp;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult (distrs mdp !! s ! j)\n                     (solution (pos_cert c)) =\n                    (\\<Sum>i\\<in>local.S.\n                       lookup 0 (distrs mdp !! s ! j) i *\n                       solution (pos_cert c) !! i)\n  j < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! j) ?i1)", "show \"(\\<Sum>t\\<in>S. pmf D t * ?x t) \\<le> ?x s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult (distrs mdp !! s ! j)\n                     (solution (pos_cert c))\n                    \\<le> solution (pos_cert c) !! s\n  s \\<in> local.S1\n  \\<lbrakk>s < state_count mdp;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult (distrs mdp !! s ! j)\n                     (solution (pos_cert c)) =\n                    (\\<Sum>i\\<in>local.S.\n                       lookup 0 (distrs mdp !! s ! j) i *\n                       solution (pos_cert c) !! i)\n  j < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! j) ?i1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>t\\<in>local.S.\n       pmf D t * real_of_rat (solution (pos_cert c) !! t))\n    \\<le> real_of_rat (solution (pos_cert c) !! s)", "by (simp add: of_rat_mult[symmetric] of_rat_sum[symmetric] of_rat_less_eq j)"], ["proof (state)\nthis:\n  (\\<Sum>t\\<in>local.S. pmf D t * real_of_rat (solution (pos_cert c) !! t))\n  \\<le> real_of_rat (solution (pos_cert c) !! s)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 3. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 3. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "fix s a"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 3. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "assume \"s \\<in> S2\""], ["proof (state)\nthis:\n  s \\<in> local.S2\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0\n 3. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 1", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S2", "show \"?x s = 1\""], ["proof (prove)\nusing this:\n  s \\<in> local.S2\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (pos_cert c) !! s) = 1", "using valid_sub_certD[OF \\<open>valid_mdp_rp mdp\\<close> pos]"], ["proof (prove)\nusing this:\n  s \\<in> local.S2\n  \\<lbrakk>?i < state_count mdp; \\<not> states1 mdp !! ?i;\n   \\<not> states2 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! ?i = 0\n  \\<lbrakk>?i < state_count mdp; states2 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! ?i = 1\n  \\<lbrakk>?i < state_count mdp; states1 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (pos_cert c) !! ?i\n  \\<lbrakk>?i < state_count mdp; states1 mdp !! ?i;\n   ?ds \\<in> set (distrs mdp !! ?i)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult ?ds (solution (pos_cert c))\n                    \\<le> solution (pos_cert c) !! ?i\n  \\<lbrakk>?i < state_count mdp; states1 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> 0 < solution (pos_cert c) !! ?i \\<longrightarrow>\n                    (case witness (pos_cert c) !! ?i of\n                     (x, xa) \\<Rightarrow>\n                       (case x of\n                        (j, a) \\<Rightarrow>\n                          \\<lambda>n.\n                             j < state_count mdp \\<and>\n                             snd (witness (pos_cert c) !! j) < n \\<and>\n                             0 < solution (pos_cert c) !! j \\<and>\n                             a < length (distrs mdp !! ?i) \\<and>\n                             lookup 0 (distrs mdp !! ?i ! a) j \\<noteq> 0)\n                        xa)\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (pos_cert c) !! s) = 1", "by simp"], ["proof (state)\nthis:\n  real_of_rat (solution (pos_cert c) !! s) = 1\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "define X where \"X = (SIGMA s:S1. \\<Union>D\\<in>K s. set_pmf D)\""], ["proof (state)\nthis:\n  X = (SIGMA s:local.S1. \\<Union> (set_pmf ` local.K s))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "assume \"s \\<in> S1\" \"?x s \\<noteq> 0\""], ["proof (state)\nthis:\n  s \\<in> local.S1\n  real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "with valid_sub_certD(3)[OF rp pos, of s]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (pos_cert c) !! s\n  s \\<in> local.S1\n  real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0", "have \"0 < ?x s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (pos_cert c) !! s\n  s \\<in> local.S1\n  real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat (solution (pos_cert c) !! s)", "by simp"], ["proof (state)\nthis:\n  0 < real_of_rat (solution (pos_cert c) !! s)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> local.S1;\n        real_of_rat (solution (pos_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n                            (s, t)\n                            \\<in> (SIGMA s:local.S1.\n\\<Union> (set_pmf ` local.K s))\\<^sup>*\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "with \\<open>s\\<in>S1\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> local.S1\n  0 < real_of_rat (solution (pos_cert c) !! s)", "show \"\\<exists>t\\<in>S2. (s, t) \\<in> X\\<^sup>*\""], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  0 < real_of_rat (solution (pos_cert c) !! s)\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "proof (induction n\\<equiv>\"snd (witness (pos_cert c) !! s)\" arbitrary: s rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>snd (witness (pos_cert c) !! sa)\n                            < snd (witness (pos_cert c) !! s);\n                    sa \\<in> local.S1;\n                    0 < real_of_rat (solution (pos_cert c) !! sa)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n  (sa, t) \\<in> X\\<^sup>*;\n        s \\<in> local.S1;\n        0 < real_of_rat (solution (pos_cert c) !! s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "case (less s)"], ["proof (state)\nthis:\n  \\<lbrakk>snd (witness (pos_cert c) !! ?s1)\n           < snd (witness (pos_cert c) !! s);\n   ?s1 \\<in> local.S1;\n   0 < real_of_rat (solution (pos_cert c) !! ?s1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t\\<in>local.S2. (?s1, t) \\<in> X\\<^sup>*\n  s \\<in> local.S1\n  0 < real_of_rat (solution (pos_cert c) !! s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>snd (witness (pos_cert c) !! sa)\n                            < snd (witness (pos_cert c) !! s);\n                    sa \\<in> local.S1;\n                    0 < real_of_rat (solution (pos_cert c) !! sa)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n  (sa, t) \\<in> X\\<^sup>*;\n        s \\<in> local.S1;\n        0 < real_of_rat (solution (pos_cert c) !! s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "obtain t a n where eq: \"witness (pos_cert c) !! s = ((t, a), n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t a n.\n        witness (pos_cert c) !! s = ((t, a), n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  witness (pos_cert c) !! s = ((t, a), n)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>snd (witness (pos_cert c) !! sa)\n                            < snd (witness (pos_cert c) !! s);\n                    sa \\<in> local.S1;\n                    0 < real_of_rat (solution (pos_cert c) !! sa)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n  (sa, t) \\<in> X\\<^sup>*;\n        s \\<in> local.S1;\n        0 < real_of_rat (solution (pos_cert c) !! s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "from valid_pos_certD[OF rp \\<open>valid_pos_cert mdp (pos_cert c)\\<close> _ _ _ this] less.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   0 < solution (pos_cert c) !! s\\<rbrakk>\n  \\<Longrightarrow> snd (witness (pos_cert c) !! t) < n \\<and>\n                    t < state_count mdp \\<and>\n                    a < length (distrs mdp !! s) \\<and>\n                    lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0 \\<and>\n                    0 < solution (pos_cert c) !! t\n  s \\<in> local.S1\n  0 < real_of_rat (solution (pos_cert c) !! s)", "have ord: \"snd (witness (pos_cert c) !! t) < snd (witness (pos_cert c) !! s)\"\n        and t: \"lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0\" \"0 < ?x t\" \"t\\<in>S\" \"a < length (distrs mdp !! s)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   0 < solution (pos_cert c) !! s\\<rbrakk>\n  \\<Longrightarrow> snd (witness (pos_cert c) !! t) < n \\<and>\n                    t < state_count mdp \\<and>\n                    a < length (distrs mdp !! s) \\<and>\n                    lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0 \\<and>\n                    0 < solution (pos_cert c) !! t\n  s \\<in> local.S1\n  0 < real_of_rat (solution (pos_cert c) !! s)\n\ngoal (1 subgoal):\n 1. snd (witness (pos_cert c) !! t) < snd (witness (pos_cert c) !! s) &&&\n    (lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0 &&&\n     0 < real_of_rat (solution (pos_cert c) !! t)) &&&\n    t \\<in> local.S &&& a < length (distrs mdp !! s)", "unfolding eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   0 < solution (pos_cert c) !! s\\<rbrakk>\n  \\<Longrightarrow> snd (witness (pos_cert c) !! t) < n \\<and>\n                    t < state_count mdp \\<and>\n                    a < length (distrs mdp !! s) \\<and>\n                    lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0 \\<and>\n                    0 < solution (pos_cert c) !! t\n  s \\<in> local.S1\n  0 < real_of_rat (solution (pos_cert c) !! s)\n\ngoal (1 subgoal):\n 1. snd (witness (pos_cert c) !! t) < snd ((t, a), n) &&&\n    (lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0 &&&\n     0 < real_of_rat (solution (pos_cert c) !! t)) &&&\n    t \\<in> local.S &&& a < length (distrs mdp !! s)", "by auto"], ["proof (state)\nthis:\n  snd (witness (pos_cert c) !! t) < snd (witness (pos_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0\n  0 < real_of_rat (solution (pos_cert c) !! t)\n  t \\<in> local.S\n  a < length (distrs mdp !! s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>snd (witness (pos_cert c) !! sa)\n                            < snd (witness (pos_cert c) !! s);\n                    sa \\<in> local.S1;\n                    0 < real_of_rat (solution (pos_cert c) !! sa)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n  (sa, t) \\<in> X\\<^sup>*;\n        s \\<in> local.S1;\n        0 < real_of_rat (solution (pos_cert c) !! s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "with \\<open>s\\<in>S1\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> local.S1\n  snd (witness (pos_cert c) !! t) < snd (witness (pos_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0\n  0 < real_of_rat (solution (pos_cert c) !! t)\n  t \\<in> local.S\n  a < length (distrs mdp !! s)", "have X: \"(s, t) \\<in> X\""], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  snd (witness (pos_cert c) !! t) < snd (witness (pos_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0\n  0 < real_of_rat (solution (pos_cert c) !! t)\n  t \\<in> local.S\n  a < length (distrs mdp !! s)\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> X", "unfolding X_def"], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  snd (witness (pos_cert c) !! t) < snd (witness (pos_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) t \\<noteq> 0\n  0 < real_of_rat (solution (pos_cert c) !! t)\n  t \\<in> local.S\n  a < length (distrs mdp !! s)\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> (SIGMA s:local.S1. \\<Union> (set_pmf ` local.K s))", "by (transfer fixing: s t a c)\n           (auto simp: X_def in_set_conv_nth\n                 intro!: exI[of _ \"\\<lambda>j. real_of_rat (lookup 0 (distrs mdp !! s ! a) j)\"]\n                         exI[of _ \"distrs mdp !! s ! a\"] exI[of _ a])"], ["proof (state)\nthis:\n  (s, t) \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>snd (witness (pos_cert c) !! sa)\n                            < snd (witness (pos_cert c) !! s);\n                    sa \\<in> local.S1;\n                    0 < real_of_rat (solution (pos_cert c) !! sa)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>t\\<in>local.S2.\n  (sa, t) \\<in> X\\<^sup>*;\n        s \\<in> local.S1;\n        0 < real_of_rat (solution (pos_cert c) !! s)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "assume \"t \\<in> S1\""], ["proof (state)\nthis:\n  t \\<in> local.S1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "with less.hyps[OF ord _ \\<open>0 < ?x t\\<close>] X"], ["proof (chain)\npicking this:\n  t \\<in> local.S1 \\<Longrightarrow>\n  \\<exists>ta\\<in>local.S2. (t, ta) \\<in> X\\<^sup>*\n  (s, t) \\<in> X\n  t \\<in> local.S1", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> local.S1 \\<Longrightarrow>\n  \\<exists>ta\\<in>local.S2. (t, ta) \\<in> X\\<^sup>*\n  (s, t) \\<in> X\n  t \\<in> local.S1\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*\n\ngoal (1 subgoal):\n 1. t \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "assume \"t \\<notin> S1\""], ["proof (state)\nthis:\n  t \\<notin> local.S1\n\ngoal (1 subgoal):\n 1. t \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "with valid_sub_certD[OF \\<open>valid_mdp_rp mdp\\<close> pos, of t] \\<open>0 < ?x t\\<close> \\<open>t\\<in>S\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>t < state_count mdp; \\<not> states1 mdp !! t;\n   \\<not> states2 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! t = 0\n  \\<lbrakk>t < state_count mdp; states2 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! t = 1\n  \\<lbrakk>t < state_count mdp; states1 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (pos_cert c) !! t\n  \\<lbrakk>t < state_count mdp; states1 mdp !! t;\n   ?ds \\<in> set (distrs mdp !! t)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult ?ds (solution (pos_cert c))\n                    \\<le> solution (pos_cert c) !! t\n  \\<lbrakk>t < state_count mdp; states1 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> 0 < solution (pos_cert c) !! t \\<longrightarrow>\n                    (case witness (pos_cert c) !! t of\n                     (x, xa) \\<Rightarrow>\n                       (case x of\n                        (j, a) \\<Rightarrow>\n                          \\<lambda>n.\n                             j < state_count mdp \\<and>\n                             snd (witness (pos_cert c) !! j) < n \\<and>\n                             0 < solution (pos_cert c) !! j \\<and>\n                             a < length (distrs mdp !! t) \\<and>\n                             lookup 0 (distrs mdp !! t ! a) j \\<noteq> 0)\n                        xa)\n  0 < real_of_rat (solution (pos_cert c) !! t)\n  t \\<in> local.S\n  t \\<notin> local.S1", "have \"t \\<in> S2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t < state_count mdp; \\<not> states1 mdp !! t;\n   \\<not> states2 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! t = 0\n  \\<lbrakk>t < state_count mdp; states2 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! t = 1\n  \\<lbrakk>t < state_count mdp; states1 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (pos_cert c) !! t\n  \\<lbrakk>t < state_count mdp; states1 mdp !! t;\n   ?ds \\<in> set (distrs mdp !! t)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult ?ds (solution (pos_cert c))\n                    \\<le> solution (pos_cert c) !! t\n  \\<lbrakk>t < state_count mdp; states1 mdp !! t\\<rbrakk>\n  \\<Longrightarrow> 0 < solution (pos_cert c) !! t \\<longrightarrow>\n                    (case witness (pos_cert c) !! t of\n                     (x, xa) \\<Rightarrow>\n                       (case x of\n                        (j, a) \\<Rightarrow>\n                          \\<lambda>n.\n                             j < state_count mdp \\<and>\n                             snd (witness (pos_cert c) !! j) < n \\<and>\n                             0 < solution (pos_cert c) !! j \\<and>\n                             a < length (distrs mdp !! t) \\<and>\n                             lookup 0 (distrs mdp !! t ! a) j \\<noteq> 0)\n                        xa)\n  0 < real_of_rat (solution (pos_cert c) !! t)\n  t \\<in> local.S\n  t \\<notin> local.S1\n\ngoal (1 subgoal):\n 1. t \\<in> local.S2", "by auto"], ["proof (state)\nthis:\n  t \\<in> local.S2\n\ngoal (1 subgoal):\n 1. t \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "with X"], ["proof (chain)\npicking this:\n  (s, t) \\<in> X\n  t \\<in> local.S2", "show ?thesis"], ["proof (prove)\nusing this:\n  (s, t) \\<in> X\n  t \\<in> local.S2\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>local.S2. (s, t) \\<in> X\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "assume \"s \\<in> S - S1 - S2\""], ["proof (state)\nthis:\n  s \\<in> local.S - local.S1 - local.S2\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (pos_cert c) !! s) = 0", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S - local.S1 - local.S2", "show \"?x s = 0\""], ["proof (prove)\nusing this:\n  s \\<in> local.S - local.S1 - local.S2\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (pos_cert c) !! s) = 0", "using valid_sub_certD(1)[OF \\<open>valid_mdp_rp mdp\\<close> pos, of s]"], ["proof (prove)\nusing this:\n  s \\<in> local.S - local.S1 - local.S2\n  \\<lbrakk>s < state_count mdp; \\<not> states1 mdp !! s;\n   \\<not> states2 mdp !! s\\<rbrakk>\n  \\<Longrightarrow> solution (pos_cert c) !! s = 0\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (pos_cert c) !! s) = 0", "by simp"], ["proof (state)\nthis:\n  real_of_rat (solution (pos_cert c) !! s) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  enn2real (MDP.p i) \\<le> real_of_rat (solution (pos_cert c) !! i)\n\ngoal (2 subgoals):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\n 2. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "then"], ["proof (chain)\npicking this:\n  enn2real (MDP.p i) \\<le> real_of_rat (solution (pos_cert c) !! i)", "show ?max"], ["proof (prove)\nusing this:\n  enn2real (MDP.p i) \\<le> real_of_rat (solution (pos_cert c) !! i)\n\ngoal (1 subgoal):\n 1. local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)", "by (simp add: P_max_def)"], ["proof (state)\nthis:\n  local.P_max i \\<le> real_of_rat (solution (pos_cert c) !! i)\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "let ?x = \"\\<lambda>s. real_of_rat (solution (neg_cert c) !! s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "have \"?x i \\<le> enn2real (MDP.n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! i) \\<le> enn2real (MDP.n i)", "proof (rule MDP.n_lb')"], ["proof (state)\ngoal (6 subgoals):\n 1. wf ?R\n 2. i \\<in> local.S\n 3. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> real_of_rat (solution (neg_cert c) !! s)\n                         \\<le> (\\<Sum>t\\<in>local.S.\n                                  pmf D t *\n                                  real_of_rat (solution (neg_cert c) !! t))\n 4. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 5. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 6. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "show \"i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> local.S", "using assms"], ["proof (prove)\nusing this:\n  i < state_count mdp\n\ngoal (1 subgoal):\n 1. i \\<in> local.S", "by simp"], ["proof (state)\nthis:\n  i \\<in> local.S\n\ngoal (5 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> real_of_rat (solution (neg_cert c) !! s)\n                         \\<le> (\\<Sum>t\\<in>local.S.\n                                  pmf D t *\n                                  real_of_rat (solution (neg_cert c) !! t))\n 3. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 4. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 5. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> real_of_rat (solution (neg_cert c) !! s)\n                         \\<le> (\\<Sum>t\\<in>local.S.\n                                  pmf D t *\n                                  real_of_rat (solution (neg_cert c) !! t))\n 3. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 4. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 5. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "fix s D"], ["proof (state)\ngoal (5 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> real_of_rat (solution (neg_cert c) !! s)\n                         \\<le> (\\<Sum>t\\<in>local.S.\n                                  pmf D t *\n                                  real_of_rat (solution (neg_cert c) !! t))\n 3. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 4. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 5. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "assume \"s \\<in> S1\" \"D \\<in> K s\""], ["proof (state)\nthis:\n  s \\<in> local.S1\n  D \\<in> local.K s\n\ngoal (5 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> real_of_rat (solution (neg_cert c) !! s)\n                         \\<le> (\\<Sum>t\\<in>local.S.\n                                  pmf D t *\n                                  real_of_rat (solution (neg_cert c) !! t))\n 3. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 4. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 5. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S1\n  D \\<in> local.K s", "obtain j where j: \"j < length (distrs mdp !! s)\"\n      \"\\<And>i. i < state_count mdp \\<Longrightarrow> pmf D i = real_of_rat (lookup 0 (distrs mdp !! s ! j) i)\""], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  D \\<in> local.K s\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length (distrs mdp !! s);\n         \\<And>i.\n            i < state_count mdp \\<Longrightarrow>\n            pmf D i =\n            real_of_rat (lookup 0 (distrs mdp !! s ! j) i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! j) ?i1)\n\ngoal (5 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s\\<rbrakk>\n       \\<Longrightarrow> real_of_rat (solution (neg_cert c) !! s)\n                         \\<le> (\\<Sum>t\\<in>local.S.\n                                  pmf D t *\n                                  real_of_rat (solution (neg_cert c) !! t))\n 3. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 4. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 5. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "with valid_sub_certD(4)[OF \\<open>valid_mdp_rp mdp\\<close> neg, of s \"distrs mdp !! s ! j\"] \\<open>s \\<in> S1\\<close>\n         valid_mdp_rp_sparse_mult[OF \\<open>valid_mdp_rp mdp\\<close>, of s \"distrs mdp !! s ! j\" \"solution (neg_cert c)\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! s\n                    \\<le> sparse_mult (distrs mdp !! s ! j)\n                           (solution (neg_cert c))\n  s \\<in> local.S1\n  \\<lbrakk>s < state_count mdp;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult (distrs mdp !! s ! j)\n                     (solution (neg_cert c)) =\n                    (\\<Sum>i\\<in>local.S.\n                       lookup 0 (distrs mdp !! s ! j) i *\n                       solution (neg_cert c) !! i)\n  j < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! j) ?i1)", "show \"?x s \\<le> (\\<Sum>t\\<in>S. pmf D t * ?x t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! s\n                    \\<le> sparse_mult (distrs mdp !! s ! j)\n                           (solution (neg_cert c))\n  s \\<in> local.S1\n  \\<lbrakk>s < state_count mdp;\n   distrs mdp !! s ! j \\<in> set (distrs mdp !! s)\\<rbrakk>\n  \\<Longrightarrow> sparse_mult (distrs mdp !! s ! j)\n                     (solution (neg_cert c)) =\n                    (\\<Sum>i\\<in>local.S.\n                       lookup 0 (distrs mdp !! s ! j) i *\n                       solution (neg_cert c) !! i)\n  j < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! j) ?i1)\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! s)\n    \\<le> (\\<Sum>t\\<in>local.S.\n             pmf D t * real_of_rat (solution (neg_cert c) !! t))", "by (simp add: of_rat_mult[symmetric] of_rat_sum[symmetric] of_rat_less_eq j)"], ["proof (state)\nthis:\n  real_of_rat (solution (neg_cert c) !! s)\n  \\<le> (\\<Sum>t\\<in>local.S.\n           pmf D t * real_of_rat (solution (neg_cert c) !! t))\n\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "fix s a"], ["proof (state)\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "assume \"s \\<in> S2\""], ["proof (state)\nthis:\n  s \\<in> local.S2\n\ngoal (4 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0\n 4. \\<And>s.\n       s \\<in> local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 1", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S2", "show \"?x s = 1\""], ["proof (prove)\nusing this:\n  s \\<in> local.S2\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! s) = 1", "using valid_sub_certD[OF \\<open>valid_mdp_rp mdp\\<close> neg]"], ["proof (prove)\nusing this:\n  s \\<in> local.S2\n  \\<lbrakk>?i < state_count mdp; \\<not> states1 mdp !! ?i;\n   \\<not> states2 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! ?i = 0\n  \\<lbrakk>?i < state_count mdp; states2 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! ?i = 1\n  \\<lbrakk>?i < state_count mdp; states1 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (neg_cert c) !! ?i\n  \\<lbrakk>?i < state_count mdp; states1 mdp !! ?i;\n   ?ds \\<in> set (distrs mdp !! ?i)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! ?i\n                    \\<le> sparse_mult ?ds (solution (neg_cert c))\n  \\<lbrakk>?i < state_count mdp; states1 mdp !! ?i\\<rbrakk>\n  \\<Longrightarrow> 0 < solution (neg_cert c) !! ?i \\<longrightarrow>\n                    (case witness (neg_cert c) !! ?i of\n                     (J, n) \\<Rightarrow>\n                       list_all2\n                        (\\<lambda>j d.\n                            j < state_count mdp \\<and>\n                            snd (witness (neg_cert c) !! j) < n \\<and>\n                            lookup 0 d j \\<noteq> 0 \\<and>\n                            0 < solution (neg_cert c) !! j)\n                        J (distrs mdp !! ?i))\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! s) = 1", "by simp"], ["proof (state)\nthis:\n  real_of_rat (solution (neg_cert c) !! s) = 1\n\ngoal (3 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. wf ?R\n 2. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s) \\<in> ?R \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 3. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "show \"wf ((S \\<times> S \\<inter> {(s, t). snd (witness (neg_cert c) !! t) < snd (witness (neg_cert c) !! s)})\\<inverse>)\" (is \"wf ?F\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ((local.S \\<times> local.S \\<inter>\n         {(s, t).\n          snd (witness (neg_cert c) !! t)\n          < snd (witness (neg_cert c) !! s)})\\<inverse>)", "using MDP.S_finite"], ["proof (prove)\nusing this:\n  finite local.S\n\ngoal (1 subgoal):\n 1. wf ((local.S \\<times> local.S \\<inter>\n         {(s, t).\n          snd (witness (neg_cert c) !! t)\n          < snd (witness (neg_cert c) !! s)})\\<inverse>)", "by (intro finite_acyclic_wf_converse acyclicI_order[where f=\"\\<lambda>s. snd (witness (neg_cert c) !! s)\"]) auto"], ["proof (state)\nthis:\n  wf ((local.S \\<times> local.S \\<inter>\n       {(s, t).\n        snd (witness (neg_cert c) !! t)\n        < snd (witness (neg_cert c) !! s)})\\<inverse>)\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "fix s D"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "assume 2: \"s \\<in> S1\" \"D \\<in> K s\" and \"?x s \\<noteq> 0\""], ["proof (state)\nthis:\n  s \\<in> local.S1\n  D \\<in> local.K s\n  real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S1\n  D \\<in> local.K s\n  real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0", "have \"0 < ?x s\""], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  D \\<in> local.K s\n  real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat (solution (neg_cert c) !! s)", "using valid_sub_certD(3)[OF \\<open>valid_mdp_rp mdp\\<close> neg, of s]"], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  D \\<in> local.K s\n  real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (neg_cert c) !! s\n\ngoal (1 subgoal):\n 1. 0 < real_of_rat (solution (neg_cert c) !! s)", "by auto"], ["proof (state)\nthis:\n  0 < real_of_rat (solution (neg_cert c) !! s)\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "from 2"], ["proof (chain)\npicking this:\n  s \\<in> local.S1\n  D \\<in> local.K s", "obtain a where a: \"a < length (distrs mdp !! s)\"\n      \"\\<And>i. i < state_count mdp \\<Longrightarrow> pmf D i = real_of_rat (lookup 0 (distrs mdp !! s ! a) i)\""], ["proof (prove)\nusing this:\n  s \\<in> local.S1\n  D \\<in> local.K s\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a < length (distrs mdp !! s);\n         \\<And>i.\n            i < state_count mdp \\<Longrightarrow>\n            pmf D i =\n            real_of_rat (lookup 0 (distrs mdp !! s ! a) i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by transfer (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  a < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! a) ?i1)\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "obtain js n where eq: \"witness (neg_cert c) !! s = (js, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>js n.\n        witness (neg_cert c) !! s = (js, n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust)"], ["proof (state)\nthis:\n  witness (neg_cert c) !! s = (js, n)\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "from valid_neg_certD[OF \\<open>valid_mdp_rp mdp\\<close> \\<open>valid_neg_cert mdp (neg_cert c)\\<close> _ _ _ eq] a \\<open>s \\<in> S1\\<close> \\<open>0 < ?x s\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   0 < solution (neg_cert c) !! s\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>j ds.\n                         j < state_count mdp \\<and>\n                         snd (witness (neg_cert c) !! j) < n \\<and>\n                         lookup 0 ds j \\<noteq> 0 \\<and>\n                         0 < solution (neg_cert c) !! j)\n                     js (distrs mdp !! s)\n  a < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! a) ?i1)\n  s \\<in> local.S1\n  0 < real_of_rat (solution (neg_cert c) !! s)", "have *: \"length js = length (distrs mdp !! s)\" \"js ! a \\<in> S\"\n      \"snd (witness (neg_cert c) !! (js ! a)) < snd (witness (neg_cert c) !! s)\"\n      \"lookup 0 (distrs mdp !! s ! a) (js ! a) \\<noteq> 0\"\n      \"0 < ?x (js ! a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   0 < solution (neg_cert c) !! s\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>j ds.\n                         j < state_count mdp \\<and>\n                         snd (witness (neg_cert c) !! j) < n \\<and>\n                         lookup 0 ds j \\<noteq> 0 \\<and>\n                         0 < solution (neg_cert c) !! j)\n                     js (distrs mdp !! s)\n  a < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! a) ?i1)\n  s \\<in> local.S1\n  0 < real_of_rat (solution (neg_cert c) !! s)\n\ngoal (1 subgoal):\n 1. (length js = length (distrs mdp !! s) &&& js ! a \\<in> local.S) &&&\n    snd (witness (neg_cert c) !! (js ! a))\n    < snd (witness (neg_cert c) !! s) &&&\n    lookup 0 (distrs mdp !! s ! a) (js ! a) \\<noteq> 0 &&&\n    0 < real_of_rat (solution (neg_cert c) !! (js ! a))", "unfolding eq"], ["proof (prove)\nusing this:\n  \\<lbrakk>s < state_count mdp; states1 mdp !! s;\n   0 < solution (neg_cert c) !! s\\<rbrakk>\n  \\<Longrightarrow> list_all2\n                     (\\<lambda>j ds.\n                         j < state_count mdp \\<and>\n                         snd (witness (neg_cert c) !! j) < n \\<and>\n                         lookup 0 ds j \\<noteq> 0 \\<and>\n                         0 < solution (neg_cert c) !! j)\n                     js (distrs mdp !! s)\n  a < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! a) ?i1)\n  s \\<in> local.S1\n  0 < real_of_rat (solution (neg_cert c) !! s)\n\ngoal (1 subgoal):\n 1. (length js = length (distrs mdp !! s) &&& js ! a \\<in> local.S) &&&\n    snd (witness (neg_cert c) !! (js ! a)) < snd (js, n) &&&\n    lookup 0 (distrs mdp !! s ! a) (js ! a) \\<noteq> 0 &&&\n    0 < real_of_rat (solution (neg_cert c) !! (js ! a))", "by (auto dest: list_all2_nthD2 list_all2_lengthD)"], ["proof (state)\nthis:\n  length js = length (distrs mdp !! s)\n  js ! a \\<in> local.S\n  snd (witness (neg_cert c) !! (js ! a)) < snd (witness (neg_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) (js ! a) \\<noteq> 0\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "with a \\<open>s \\<in> S1\\<close>"], ["proof (chain)\npicking this:\n  a < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! a) ?i1)\n  s \\<in> local.S1\n  length js = length (distrs mdp !! s)\n  js ! a \\<in> local.S\n  snd (witness (neg_cert c) !! (js ! a)) < snd (witness (neg_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) (js ! a) \\<noteq> 0\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))", "have js_a: \"js ! a \\<in> D\" \"(js ! a, s) \\<in> ?F\""], ["proof (prove)\nusing this:\n  a < length (distrs mdp !! s)\n  ?i1 < state_count mdp \\<Longrightarrow>\n  pmf D ?i1 = real_of_rat (lookup 0 (distrs mdp !! s ! a) ?i1)\n  s \\<in> local.S1\n  length js = length (distrs mdp !! s)\n  js ! a \\<in> local.S\n  snd (witness (neg_cert c) !! (js ! a)) < snd (witness (neg_cert c) !! s)\n  lookup 0 (distrs mdp !! s ! a) (js ! a) \\<noteq> 0\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))\n\ngoal (1 subgoal):\n 1. js ! a \\<in> set_pmf D &&&\n    (js ! a, s)\n    \\<in> (local.S \\<times> local.S \\<inter>\n           {(s, t).\n            snd (witness (neg_cert c) !! t)\n            < snd (witness (neg_cert c) !! s)})\\<inverse>", "by (auto simp: set_pmf_iff)"], ["proof (state)\nthis:\n  js ! a \\<in> set_pmf D\n  (js ! a, s)\n  \\<in> (local.S \\<times> local.S \\<inter>\n         {(s, t).\n          snd (witness (neg_cert c) !! t)\n          < snd (witness (neg_cert c) !! s)})\\<inverse>\n\ngoal (2 subgoals):\n 1. \\<And>s D.\n       \\<lbrakk>s \\<in> local.S1; D \\<in> local.K s;\n        real_of_rat (solution (neg_cert c) !! s) \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set_pmf D.\n                            (t, s)\n                            \\<in> (local.S \\<times> local.S \\<inter>\n                                   {(s, t).\n                                    snd (witness (neg_cert c) !! t)\n                                    < snd\n (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n                            t \\<in> local.S1 \\<and>\n                            real_of_rat\n                             (solution (neg_cert c) !! t) \\<noteq>\n                            0 \\<or>\n                            t \\<in> local.S2\n 2. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "show \"\\<exists>t\\<in>D. (t, s) \\<in> ?F \\<and> t \\<in> S1 \\<and> ?x t \\<noteq> 0 \\<or> t \\<in> S2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "assume \"js ! a \\<in> S1\""], ["proof (state)\nthis:\n  js ! a \\<in> local.S1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "with js_a \\<open>0 < ?x (js ! a)\\<close>"], ["proof (chain)\npicking this:\n  js ! a \\<in> set_pmf D\n  (js ! a, s)\n  \\<in> (local.S \\<times> local.S \\<inter>\n         {(s, t).\n          snd (witness (neg_cert c) !! t)\n          < snd (witness (neg_cert c) !! s)})\\<inverse>\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))\n  js ! a \\<in> local.S1", "show ?thesis"], ["proof (prove)\nusing this:\n  js ! a \\<in> set_pmf D\n  (js ! a, s)\n  \\<in> (local.S \\<times> local.S \\<inter>\n         {(s, t).\n          snd (witness (neg_cert c) !! t)\n          < snd (witness (neg_cert c) !! s)})\\<inverse>\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))\n  js ! a \\<in> local.S1\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set_pmf D.\n     (t, s)\n     \\<in> (local.S \\<times> local.S \\<inter>\n            {(s, t).\n             snd (witness (neg_cert c) !! t)\n             < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n     t \\<in> local.S1 \\<and>\n     real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n     t \\<in> local.S2\n\ngoal (1 subgoal):\n 1. js ! a \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. js ! a \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "assume \"js ! a \\<notin> S1\""], ["proof (state)\nthis:\n  js ! a \\<notin> local.S1\n\ngoal (1 subgoal):\n 1. js ! a \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "with \\<open>0 < ?x (js ! a)\\<close> \\<open>js!a \\<in> S\\<close> valid_sub_certD[OF rp neg, of \"js ! a\"]"], ["proof (chain)\npicking this:\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))\n  js ! a \\<in> local.S\n  \\<lbrakk>js ! a < state_count mdp; \\<not> states1 mdp !! (js ! a);\n   \\<not> states2 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! (js ! a) = 0\n  \\<lbrakk>js ! a < state_count mdp; states2 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! (js ! a) = 1\n  \\<lbrakk>js ! a < state_count mdp; states1 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (neg_cert c) !! (js ! a)\n  \\<lbrakk>js ! a < state_count mdp; states1 mdp !! (js ! a);\n   ?ds \\<in> set (distrs mdp !! (js ! a))\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! (js ! a)\n                    \\<le> sparse_mult ?ds (solution (neg_cert c))\n  \\<lbrakk>js ! a < state_count mdp; states1 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> 0 < solution (neg_cert c) !! (js ! a) \\<longrightarrow>\n                    (case witness (neg_cert c) !! (js ! a) of\n                     (J, n) \\<Rightarrow>\n                       list_all2\n                        (\\<lambda>j d.\n                            j < state_count mdp \\<and>\n                            snd (witness (neg_cert c) !! j) < n \\<and>\n                            lookup 0 d j \\<noteq> 0 \\<and>\n                            0 < solution (neg_cert c) !! j)\n                        J (distrs mdp !! (js ! a)))\n  js ! a \\<notin> local.S1", "have \"js ! a \\<in> S2\""], ["proof (prove)\nusing this:\n  0 < real_of_rat (solution (neg_cert c) !! (js ! a))\n  js ! a \\<in> local.S\n  \\<lbrakk>js ! a < state_count mdp; \\<not> states1 mdp !! (js ! a);\n   \\<not> states2 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! (js ! a) = 0\n  \\<lbrakk>js ! a < state_count mdp; states2 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! (js ! a) = 1\n  \\<lbrakk>js ! a < state_count mdp; states1 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> 0 \\<le> solution (neg_cert c) !! (js ! a)\n  \\<lbrakk>js ! a < state_count mdp; states1 mdp !! (js ! a);\n   ?ds \\<in> set (distrs mdp !! (js ! a))\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! (js ! a)\n                    \\<le> sparse_mult ?ds (solution (neg_cert c))\n  \\<lbrakk>js ! a < state_count mdp; states1 mdp !! (js ! a)\\<rbrakk>\n  \\<Longrightarrow> 0 < solution (neg_cert c) !! (js ! a) \\<longrightarrow>\n                    (case witness (neg_cert c) !! (js ! a) of\n                     (J, n) \\<Rightarrow>\n                       list_all2\n                        (\\<lambda>j d.\n                            j < state_count mdp \\<and>\n                            snd (witness (neg_cert c) !! j) < n \\<and>\n                            lookup 0 d j \\<noteq> 0 \\<and>\n                            0 < solution (neg_cert c) !! j)\n                        J (distrs mdp !! (js ! a)))\n  js ! a \\<notin> local.S1\n\ngoal (1 subgoal):\n 1. js ! a \\<in> local.S2", "by (auto simp:  less_le)"], ["proof (state)\nthis:\n  js ! a \\<in> local.S2\n\ngoal (1 subgoal):\n 1. js ! a \\<notin> local.S1 \\<Longrightarrow>\n    \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "with \\<open>js ! a \\<in> D\\<close>"], ["proof (chain)\npicking this:\n  js ! a \\<in> set_pmf D\n  js ! a \\<in> local.S2", "show ?thesis"], ["proof (prove)\nusing this:\n  js ! a \\<in> set_pmf D\n  js ! a \\<in> local.S2\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>set_pmf D.\n       (t, s)\n       \\<in> (local.S \\<times> local.S \\<inter>\n              {(s, t).\n               snd (witness (neg_cert c) !! t)\n               < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n       t \\<in> local.S1 \\<and>\n       real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n       t \\<in> local.S2", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set_pmf D.\n     (t, s)\n     \\<in> (local.S \\<times> local.S \\<inter>\n            {(s, t).\n             snd (witness (neg_cert c) !! t)\n             < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n     t \\<in> local.S1 \\<and>\n     real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n     t \\<in> local.S2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t\\<in>set_pmf D.\n     (t, s)\n     \\<in> (local.S \\<times> local.S \\<inter>\n            {(s, t).\n             snd (witness (neg_cert c) !! t)\n             < snd (witness (neg_cert c) !! s)})\\<inverse> \\<and>\n     t \\<in> local.S1 \\<and>\n     real_of_rat (solution (neg_cert c) !! t) \\<noteq> 0 \\<or>\n     t \\<in> local.S2\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "assume \"s \\<in> S - S1 - S2\""], ["proof (state)\nthis:\n  s \\<in> local.S - local.S1 - local.S2\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s \\<in> local.S - local.S1 - local.S2 \\<Longrightarrow>\n       real_of_rat (solution (neg_cert c) !! s) = 0", "then"], ["proof (chain)\npicking this:\n  s \\<in> local.S - local.S1 - local.S2", "show \"?x s = 0\""], ["proof (prove)\nusing this:\n  s \\<in> local.S - local.S1 - local.S2\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! s) = 0", "using valid_sub_certD(1)[OF \\<open>valid_mdp_rp mdp\\<close> neg, of s]"], ["proof (prove)\nusing this:\n  s \\<in> local.S - local.S1 - local.S2\n  \\<lbrakk>s < state_count mdp; \\<not> states1 mdp !! s;\n   \\<not> states2 mdp !! s\\<rbrakk>\n  \\<Longrightarrow> solution (neg_cert c) !! s = 0\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! s) = 0", "by simp"], ["proof (state)\nthis:\n  real_of_rat (solution (neg_cert c) !! s) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_rat (solution (neg_cert c) !! i) \\<le> enn2real (MDP.n i)\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "then"], ["proof (chain)\npicking this:\n  real_of_rat (solution (neg_cert c) !! i) \\<le> enn2real (MDP.n i)", "show ?min"], ["proof (prove)\nusing this:\n  real_of_rat (solution (neg_cert c) !! i) \\<le> enn2real (MDP.n i)\n\ngoal (1 subgoal):\n 1. real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i", "by (simp add: P_min_def)"], ["proof (state)\nthis:\n  real_of_rat (solution (neg_cert c) !! i) \\<le> local.P_min i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}