{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/Classifying_Markov_Chain_States.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma eventually_mult_Gcd:\n  fixes S :: \"nat set\"\n  assumes S: \"\\<And>s t. s \\<in> S \\<Longrightarrow> t \\<in> S \\<Longrightarrow> s + t \\<in> S\"\n  assumes s: \"s \\<in> S\" \"s > 0\"\n  shows \"eventually (\\<lambda>m. m * Gcd S \\<in> S) sequentially\"", "lemma G_eq: \"G s t = (\\<integral>\\<^sup>+\\<omega>. emeasure (count_space UNIV) {i. (s ## \\<omega>) !! i = t} \\<partial>T s)\"", "lemma p_nonneg[simp]: \"0 \\<le> p x y n\"", "lemma p_le_1: \"p x y n \\<le> 1\"", "lemma p_x_x_0[simp]: \"p x x 0 = 1\"", "lemma p_0: \"p x y 0 = (if x = y then 1 else 0)\"", "lemma p_in_reachable: assumes \"(x, y) \\<notin> (SIGMA x:UNIV. K x)\\<^sup>*\" shows \"p x y n = 0\"", "lemma p_Suc: \"ennreal (p x y (Suc n)) = (\\<integral>\\<^sup>+ w. p w y n \\<partial>K x)\"", "lemma p_Suc':\n  \"p x y (Suc n) = (\\<integral>x'. p x' y n \\<partial>K x)\"", "lemma p_add: \"p x y (n + m) = (\\<integral>\\<^sup>+ w. p x w n * p w y m \\<partial>count_space UNIV)\"", "lemma prob_reachable_le:\n  assumes [simp]: \"m \\<le> n\"\n  shows \"p x y m * p y w (n - m) \\<le> p x w n\"", "lemma G_eq_suminf: \"G x y = (\\<Sum>i. ennreal (p x y i))\"", "lemma G_eq_real_suminf:\n  \"convergence_G x y (1::real) \\<Longrightarrow> G x y = ennreal (\\<Sum>i. p x y i)\"", "lemma convergence_norm_G:\n  \"convergence_G x y z \\<Longrightarrow> summable (\\<lambda>n. p x y n * norm z ^ n)\"", "lemma convergence_G:\n  \"convergence_G x y (z::'a::{banach, real_normed_div_algebra}) \\<Longrightarrow> summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)\"", "lemma convergence_G_less_1:\n  fixes z :: \"_ :: {banach, real_normed_field}\"\n  assumes z: \"norm z < 1\" shows \"convergence_G x y z\"", "lemma lim_gf_G: \"((\\<lambda>z. ennreal (gf_G x y z)) \\<longlongrightarrow> G x y) (at_left (1::real))\"", "lemma f_Suc: \"x \\<noteq> y \\<Longrightarrow> f x y (Suc n) = u x y n\"", "lemma f_Suc_eq: \"f x x (Suc n) = 0\"", "lemma f_0: \"f x y 0 = (if x = y then 1 else 0)\"", "lemma shows u_nonneg: \"0 \\<le> u x y n\" and u_le_1: \"u x y n \\<le> 1\"", "lemma shows f_nonneg: \"0 \\<le> f x y n\" and f_le_1: \"f x y n \\<le> 1\"", "lemma U_nonneg[simp]: \"0 \\<le> U x y\"", "lemma U_le_1: \"U s t \\<le> 1\"", "lemma U_cases: \"U s s = 1 \\<or> U s s < 1\"", "lemma u_sums_U: \"u x y sums U x y\"", "lemma gf_U_eq_U: \"gf_U x y 1 = U x y\"", "lemma f_sums_F: \"f x y sums F x y\"", "lemma F_nonneg[simp]: \"0 \\<le> F x y\"", "lemma F_le_1: \"F x y \\<le> 1\"", "lemma gf_F_eq_F: \"gf_F x y 1 = F x y\"", "lemma gf_F_le_1:\n  fixes z :: real\n  assumes z: \"0 \\<le> z\" \"z \\<le> 1\"\n  shows \"gf_F x y z \\<le> 1\"", "lemma u_le_p: \"u x y n \\<le> p x y (Suc n)\"", "lemma f_le_p: \"f x y n \\<le> p x y n\"", "lemma convergence_norm_U:\n  fixes z :: \"_ :: real_normed_div_algebra\"\n  assumes z: \"convergence_G x y z\"\n  shows \"summable (\\<lambda>n. u x y n * norm z ^ Suc n)\"", "lemma convergence_norm_F:\n  fixes z :: \"_ :: real_normed_div_algebra\"\n  assumes z: \"convergence_G x y z\"\n  shows \"summable (\\<lambda>n. f x y n * norm z ^ n)\"", "lemma gf_G_nonneg:\n  fixes z :: real\n  shows \"0 \\<le> z \\<Longrightarrow> z < 1 \\<Longrightarrow> 0 \\<le> gf_G x y z\"", "lemma gf_F_nonneg:\n  fixes z :: real\n  shows \"0 \\<le> z \\<Longrightarrow> z < 1 \\<Longrightarrow> 0 \\<le> gf_F x y z\"", "lemma convergence_U:\n  fixes z :: \"_ :: banach\"\n  shows \"convergence_G x y z \\<Longrightarrow> summable (\\<lambda>n. u x y n * z ^ Suc n)\"", "lemma p_eq_sum_p_u: \"p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)\"", "lemma p_eq_sum_p_f: \"p x y n = (\\<Sum>i\\<le>n. p y y (n - i) * f x y i)\"", "lemma gf_G_eq_gf_F:\n  assumes z: \"norm z < 1\"\n  shows \"gf_G x y z = gf_F x y z * gf_G y y z\"", "lemma gf_G_eq_gf_U:\n  fixes z :: \"'z :: {banach, real_normed_field}\"\n  assumes z: \"convergence_G x x z\"\n  shows \"gf_G x x z = 1 / (1 - gf_U x x z)\" \"gf_U x x z \\<noteq> 1\"", "lemma gf_U: \"(gf_U x y \\<longlongrightarrow> U x y) (at_left 1)\"", "lemma gf_U_le_1: assumes z: \"0 < z\" \"z < 1\" shows \"gf_U x y z \\<le> (1::real)\"", "lemma gf_F: \"(gf_F x y \\<longlongrightarrow> F x y) (at_left 1)\"", "lemma U_bounded: \"0 \\<le> U x y\" \"U x y \\<le> 1\"", "lemma recurrent_iff_U_eq_1: \"recurrent s \\<longleftrightarrow> U s s = 1\"", "lemma H_eq:\n  \"recurrent s \\<longleftrightarrow> H s s = 1\"\n  \"\\<not> recurrent s \\<longleftrightarrow> H s s = 0\"\n  \"H s t = U s t * H t t\"", "lemma recurrent_iff_G_infinite: \"recurrent x \\<longleftrightarrow> G x x = \\<infinity>\"", "lemma accI_U:\n  assumes \"0 < U x y\" shows \"(x, y) \\<in> acc\"", "lemma accD_pos:\n  assumes \"(x, y) \\<in> acc\"\n  shows \"\\<exists>n. 0 < p x y n\"", "lemma accI_pos: \"0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc\"", "lemma recurrent_iffI_communicating:\n  assumes \"(x, y) \\<in> communicating\"\n  shows \"recurrent x \\<longleftrightarrow> recurrent y\"", "lemma recurrent_acc:\n  assumes \"recurrent x\" \"(x, y) \\<in> acc\"\n  shows \"U y x = 1\" \"H y x = 1\" \"recurrent y\" \"(x, y) \\<in> communicating\"", "lemma equiv_communicating: \"equiv UNIV communicating\"", "lemma recurrent_class:\n  assumes \"recurrent x\"\n  shows \"acc `` {x} = communicating `` {x}\"", "lemma irreduccible_recurrent_class:\n  assumes \"recurrent x\" shows \"acc `` {x} \\<in> UNIV // communicating\"", "lemma essential_classI:\n  assumes C: \"C \\<in> UNIV // communicating\"\n  assumes eq: \"\\<And>x y. x \\<in> C \\<Longrightarrow> (x, y) \\<in> acc \\<Longrightarrow> y \\<in> C\"\n  shows \"essential_class C\"", "lemma essential_recurrent_class:\n  assumes \"recurrent x\" shows \"essential_class (communicating `` {x})\"", "lemma essential_classD2:\n  \"essential_class C \\<Longrightarrow> x \\<in> C \\<Longrightarrow> (x, y) \\<in> acc \\<Longrightarrow> y \\<in> C\"", "lemma essential_classD3:\n  \"essential_class C \\<Longrightarrow> x \\<in> C \\<Longrightarrow> y \\<in> C \\<Longrightarrow> (x, y) \\<in> communicating\"", "lemma AE_acc:\n  shows \"AE \\<omega> in T x. \\<forall>m. (x, (x ## \\<omega>) !! m) \\<in> acc\"", "lemma finite_essential_class_imp_recurrent:\n  assumes C: \"essential_class C\" \"finite C\" and x: \"x \\<in> C\"\n  shows \"recurrent x\"", "lemma irreducibleD:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> a \\<in> C \\<Longrightarrow> b \\<in> C \\<Longrightarrow> (a, b) \\<in> communicating\"", "lemma irreducibleD2:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> a \\<in> C \\<Longrightarrow> (a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C\"", "lemma essential_class_iff_recurrent:\n  \"finite C \\<Longrightarrow> C \\<in> UNIV // communicating \\<Longrightarrow> essential_class C \\<longleftrightarrow> (\\<forall>x\\<in>C. recurrent x)\"", "lemma U'_neq_zero[simp]: \"U' x y \\<noteq> 0\"", "lemma summable_gf_U':\n  assumes z: \"norm z < 1\"\n  shows \"summable (\\<lambda>n. u x y n * Suc n * z ^ n)\"", "lemma gf_U'_nonneg[simp]: \"0 < z \\<Longrightarrow> z < 1 \\<Longrightarrow> 0 \\<le> gf_U' x y z\"", "lemma DERIV_gf_U:\n  fixes z :: real assumes z: \"0 < z\" \"z < 1\"\n  shows \"DERIV (gf_U x y) z :> gf_U' x y z\"", "lemma sfirst_finiteI_recurrent:\n  \"recurrent x \\<Longrightarrow> (x, y) \\<in> acc \\<Longrightarrow> AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>\"", "lemma U'_eq_suminf:\n  assumes x: \"recurrent x\" \"(x, y) \\<in> acc\"\n  shows \"U' x y = (\\<Sum>i. ennreal (u x y i * Suc i))\"", "lemma gf_U'_tendsto_U':\n  assumes x: \"recurrent x\" \"(x, y) \\<in> acc\"\n  shows \"((\\<lambda>z. ennreal (gf_U' x y z)) \\<longlongrightarrow> U' x y) (at_left 1)\"", "lemma one_le_integral_t:\n  assumes x: \"recurrent x\" shows \"1 \\<le> U' x x\"", "lemma gf_U'_pos:\n  fixes z :: real\n  assumes z: \"0 < z\" \"z < 1\" and \"U x y \\<noteq> 0\"\n  shows \"0 < gf_U' x y z\"", "lemma inverse_gf_U'_tendsto:\n  assumes \"recurrent y\"\n  shows \"((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow> enn2real (1 / U' y y)) (at_left (1::real))\"", "lemma gf_G_pos:\n  fixes z :: real\n  assumes z: \"0 < z\" \"z < 1\" and *: \"(x, y) \\<in> acc\"\n  shows \"0 < gf_G x y z\"", "lemma pos_recurrentI_communicating:\n  assumes y: \"pos_recurrent y\" and x: \"(y, x) \\<in> communicating\"\n  shows \"pos_recurrent x\"", "lemma pos_recurrent_iffI_communicating:\n  \"(y, x) \\<in> communicating \\<Longrightarrow> pos_recurrent y \\<longleftrightarrow> pos_recurrent x\"", "lemma U_le_F: \"U x y \\<le> F x y\"", "lemma not_empty_irreducible: \"C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}\"", "lemma sets_stat[simp]: \"sets (stat C) = sets (count_space UNIV)\"", "lemma space_stat[simp]: \"space (stat C) = UNIV\"", "lemma stat_subprob:\n  assumes C: \"essential_class C\" and \"countable C\" and pos: \"\\<forall>c\\<in>C. pos_recurrent c\"\n  shows \"emeasure (stat C) C \\<le> 1\"", "lemma emeasure_stat_not_C:\n  assumes \"y \\<notin> C\"\n  shows \"emeasure (stat C) {y} = 0\"", "lemma stationary_distributionI:\n  assumes le: \"\\<And>y. (\\<integral>x. pmf (K x) y \\<partial>measure_pmf N) \\<le> pmf N y\"\n  shows \"stationary_distribution N\"", "lemma stationary_distribution_iterate:\n  assumes N: \"stationary_distribution N\"\n  shows \"ennreal (pmf N y) = (\\<integral>\\<^sup>+x. p x y n \\<partial>N)\"", "lemma stationary_distribution_iterate':\n  assumes \"stationary_distribution N\"\n  shows \"measure N {y} = (\\<integral>x. p x y n \\<partial>N)\"", "lemma stationary_distributionD:\n  assumes C: \"essential_class C\" \"countable C\"\n  assumes N: \"stationary_distribution N\" \"N \\<subseteq> C\"\n  shows \"\\<forall>x\\<in>C. pos_recurrent x\" \"measure_pmf N = stat C\"", "lemma measure_point_measure_singleton:\n  \"x \\<in> A \\<Longrightarrow> measure (point_measure A X) {x} = enn2real (X x)\"", "lemma stationary_distribution_imp_int_t:\n  assumes C: \"essential_class C\" \"countable C\" \"stationary_distribution N\" \"N \\<subseteq> C\"\n  assumes x: \"x \\<in> C\" shows \"U' x x = 1 / ennreal (pmf N x)\"", "lemma Gcd_period_set_invariant:\n  assumes c: \"(x, y) \\<in> communicating\"\n  shows \"Gcd (period_set x) = Gcd (period_set y)\"", "lemma period_eq:\n  assumes \"C \\<in> UNIV // communicating\" \"x \\<in> C\"\n  shows \"period C = Gcd (period_set x)\"", "lemma not_ephemeralD:\n  assumes C: \"not_ephemeral C\" \"x \\<in> C\"\n  shows \"\\<exists>n>0. 0 < p x x n\"", "lemma not_ephemeralD_pos_period:\n  assumes C: \"not_ephemeral C\"\n  shows \"0 < period C\"", "lemma period_posD:\n  assumes C: \"C \\<in> UNIV // communicating\" and \"0 < period C\" \"x \\<in> C\"\n  shows \"\\<exists>n>0. 0 < p x x n\"", "lemma not_ephemeralD_pos_period':\n  assumes C: \"C \\<in> UNIV // communicating\"\n  shows \"not_ephemeral C \\<longleftrightarrow> 0 < period C\"", "lemma eventually_periodic:\n  assumes C: \"C \\<in> UNIV // communicating\" \"0 < period C\" \"x \\<in> C\"\n  shows \"eventually (\\<lambda>m. 0 < p x x (m * period C)) sequentially\"", "lemma aperiodic_eventually_recurrent:\n  \"aperiodic C \\<longleftrightarrow> C \\<in> UNIV // communicating \\<and> (\\<forall>x\\<in>C. eventually (\\<lambda>m. 0 < p x x m) sequentially)\"", "lemma stationary_distributionD_emeasure:\n  assumes N: \"stationary_distribution N\"\n  shows \"emeasure N A = (\\<integral>\\<^sup>+s. emeasure (K s) A \\<partial>N)\"", "lemma communicatingD1:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> (a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C \\<Longrightarrow> b \\<in> C\"", "lemma communicatingD2:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> (a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C \\<Longrightarrow> a \\<in> C\"", "lemma acc_iff: \"(x, y) \\<in> acc \\<longleftrightarrow> (\\<exists>n. 0 < p x y n)\"", "lemma communicating_iff: \"(x, y) \\<in> communicating \\<longleftrightarrow> (\\<exists>n. 0 < p x y n) \\<and> (\\<exists>n. 0 < p y x n)\"", "lemma p_eq_p1_p2:\n  \"p (x1, x2) (y1, y2) n = K1.p x1 y1 n * K2.p x2 y2 n\"", "lemma P_accD:\n  assumes \"((x1, x2), (y1, y2)) \\<in> acc\"shows \"(x1, y1) \\<in> K1.acc\" \"(x2, y2) \\<in> K2.acc\"", "lemma aperiodicI_pair:\n  assumes C1: \"K1.aperiodic C1\" and C2: \"K2.aperiodic C2\"\n  shows \"aperiodic (C1 \\<times> C2)\"", "lemma stationary_distributionI_pair:\n  assumes N1: \"K1.stationary_distribution N1\"\n  assumes N2: \"K2.stationary_distribution N2\"\n  shows \"stationary_distribution (pair_pmf N1 N2)\"", "lemma stationary_distribution_imp_limit:\n  assumes C: \"aperiodic C\" \"essential_class C\" \"countable C\" and N: \"stationary_distribution N\" \"N \\<subseteq> C\"\n  assumes [simp]: \"y \\<in> C\"\n  shows \"(\\<lambda>n. \\<integral>x. \\<bar>p y x n - pmf N x\\<bar> \\<partial>count_space C) \\<longlonglongrightarrow> 0\"\n    (is \"?L \\<longlonglongrightarrow> 0\")", "lemma stationary_distribution_imp_p_limit:\n  assumes \"aperiodic C\" \"essential_class C\" and [simp]: \"countable C\"\n  assumes N: \"stationary_distribution N\" \"N \\<subseteq> C\"\n  assumes [simp]: \"x \\<in> C\" \"y \\<in> C\"\n  shows \"p x y \\<longlonglongrightarrow> pmf N y\"", "lemma (in MC_syntax) essential_classI2:\n  assumes \"X \\<noteq> {}\"\n  assumes accI: \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> (x, y) \\<in> acc\"\n  assumes ED: \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> set_pmf (K x) \\<Longrightarrow> y \\<in> X\"\n  shows \"essential_class X\""], "translations": [["", "lemma eventually_mult_Gcd:\n  fixes S :: \"nat set\"\n  assumes S: \"\\<And>s t. s \\<in> S \\<Longrightarrow> t \\<in> S \\<Longrightarrow> s + t \\<in> S\"\n  assumes s: \"s \\<in> S\" \"s > 0\"\n  shows \"eventually (\\<lambda>m. m * Gcd S \\<in> S) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "define T where \"T = insert 0 (int ` S)\""], ["proof (state)\nthis:\n  T = insert 0 (int ` S)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "with s S"], ["proof (chain)\npicking this:\n  s \\<in> S\n  0 < s\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk> \\<Longrightarrow> ?s + ?t \\<in> S\n  T = insert 0 (int ` S)", "have \"int s \\<in> T\" \"0 \\<in> T\" and T: \"r \\<in> T \\<Longrightarrow> t \\<in> T \\<Longrightarrow> r + t \\<in> T\" for r t"], ["proof (prove)\nusing this:\n  s \\<in> S\n  0 < s\n  \\<lbrakk>?s \\<in> S; ?t \\<in> S\\<rbrakk> \\<Longrightarrow> ?s + ?t \\<in> S\n  T = insert 0 (int ` S)\n\ngoal (1 subgoal):\n 1. (int s \\<in> T &&& 0 \\<in> T) &&&\n    (\\<lbrakk>r \\<in> T; t \\<in> T\\<rbrakk> \\<Longrightarrow> r + t \\<in> T)", "by (auto simp del: of_nat_add simp add: of_nat_add [symmetric])"], ["proof (state)\nthis:\n  int s \\<in> T\n  0 \\<in> T\n  \\<lbrakk>?r \\<in> T; ?t \\<in> T\\<rbrakk> \\<Longrightarrow> ?r + ?t \\<in> T\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "have \"Gcd T \\<in> group_closure T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd T \\<in> group_closure T", "by (rule Gcd_in_group_closure)"], ["proof (state)\nthis:\n  Gcd T \\<in> group_closure T\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "also"], ["proof (state)\nthis:\n  Gcd T \\<in> group_closure T\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "have \"group_closure T = {s - t | s t. s \\<in> T \\<and> t \\<in> T}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_closure T = {s - t |s t. s \\<in> T \\<and> t \\<in> T}", "proof (auto intro: group_closure.base group_closure.diff)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> group_closure T \\<Longrightarrow>\n       \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> group_closure T \\<Longrightarrow>\n       \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "assume \"x \\<in> group_closure T\""], ["proof (state)\nthis:\n  x \\<in> group_closure T\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> group_closure T \\<Longrightarrow>\n       \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "then"], ["proof (chain)\npicking this:\n  x \\<in> group_closure T", "show \"\\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T\""], ["proof (prove)\nusing this:\n  x \\<in> group_closure T\n\ngoal (1 subgoal):\n 1. \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> insert 0 T \\<Longrightarrow>\n       \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> group_closure T;\n        \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T;\n        t \\<in> group_closure T;\n        \\<exists>s ta.\n           t = s - ta \\<and> s \\<in> T \\<and> ta \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa ta.\n                            s - t = sa - ta \\<and>\n                            sa \\<in> T \\<and> ta \\<in> T", "case (base x)"], ["proof (state)\nthis:\n  x \\<in> insert 0 T\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> insert 0 T \\<Longrightarrow>\n       \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T\n 2. \\<And>s t.\n       \\<lbrakk>s \\<in> group_closure T;\n        \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T;\n        t \\<in> group_closure T;\n        \\<exists>s ta.\n           t = s - ta \\<and> s \\<in> T \\<and> ta \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa ta.\n                            s - t = sa - ta \\<and>\n                            sa \\<in> T \\<and> ta \\<in> T", "with \\<open>0 \\<in> T\\<close>"], ["proof (chain)\npicking this:\n  0 \\<in> T\n  x \\<in> insert 0 T", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<in> T\n  x \\<in> insert 0 T\n\ngoal (1 subgoal):\n 1. \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "apply (rule_tac x=x in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> T; x \\<in> insert 0 T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x = x - t \\<and> x \\<in> T \\<and> t \\<in> T", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> T; x \\<in> insert 0 T\\<rbrakk>\n    \\<Longrightarrow> x = x - 0 \\<and> x \\<in> T \\<and> 0 \\<in> T", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> group_closure T;\n        \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T;\n        t \\<in> group_closure T;\n        \\<exists>s ta.\n           t = s - ta \\<and> s \\<in> T \\<and> ta \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa ta.\n                            s - t = sa - ta \\<and>\n                            sa \\<in> T \\<and> ta \\<in> T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> group_closure T;\n        \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T;\n        t \\<in> group_closure T;\n        \\<exists>s ta.\n           t = s - ta \\<and> s \\<in> T \\<and> ta \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa ta.\n                            s - t = sa - ta \\<and>\n                            sa \\<in> T \\<and> ta \\<in> T", "case (diff x y)"], ["proof (state)\nthis:\n  x \\<in> group_closure T\n  y \\<in> group_closure T\n  \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n  \\<exists>s t. y = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> group_closure T;\n        \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T;\n        t \\<in> group_closure T;\n        \\<exists>s ta.\n           t = s - ta \\<and> s \\<in> T \\<and> ta \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa ta.\n                            s - t = sa - ta \\<and>\n                            sa \\<in> T \\<and> ta \\<in> T", "then"], ["proof (chain)\npicking this:\n  x \\<in> group_closure T\n  y \\<in> group_closure T\n  \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n  \\<exists>s t. y = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "obtain a b c d where\n        \"a \\<in> T\" \"b \\<in> T\" \"x = a - b\"\n        \"c \\<in> T\" \"d \\<in> T\" \"y = c - d\""], ["proof (prove)\nusing this:\n  x \\<in> group_closure T\n  y \\<in> group_closure T\n  \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n  \\<exists>s t. y = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>a b c d.\n        \\<lbrakk>a \\<in> T; b \\<in> T; x = a - b; c \\<in> T; d \\<in> T;\n         y = c - d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> T\n  b \\<in> T\n  x = a - b\n  c \\<in> T\n  d \\<in> T\n  y = c - d\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> group_closure T;\n        \\<exists>sa t. s = sa - t \\<and> sa \\<in> T \\<and> t \\<in> T;\n        t \\<in> group_closure T;\n        \\<exists>s ta.\n           t = s - ta \\<and> s \\<in> T \\<and> ta \\<in> T\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa ta.\n                            s - t = sa - ta \\<and>\n                            sa \\<in> T \\<and> ta \\<in> T", "then"], ["proof (chain)\npicking this:\n  a \\<in> T\n  b \\<in> T\n  x = a - b\n  c \\<in> T\n  d \\<in> T\n  y = c - d", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> T\n  b \\<in> T\n  x = a - b\n  c \\<in> T\n  d \\<in> T\n  y = c - d\n\ngoal (1 subgoal):\n 1. \\<exists>s t. x - y = s - t \\<and> s \\<in> T \\<and> t \\<in> T", "apply (rule_tac x=\"a + d\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> T; b \\<in> T; x = a - b; c \\<in> T; d \\<in> T;\n     y = c - d\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t.\n                         x - y = a + d - t \\<and>\n                         a + d \\<in> T \\<and> t \\<in> T", "apply (rule_tac x=\"b + c\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<in> T; b \\<in> T; x = a - b; c \\<in> T; d \\<in> T;\n     y = c - d\\<rbrakk>\n    \\<Longrightarrow> x - y = a + d - (b + c) \\<and>\n                      a + d \\<in> T \\<and> b + c \\<in> T", "apply (auto intro: T)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>s t. x - y = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s t. x = s - t \\<and> s \\<in> T \\<and> t \\<in> T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  group_closure T = {s - t |s t. s \\<in> T \\<and> t \\<in> T}\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "finally"], ["proof (chain)\npicking this:\n  Gcd T \\<in> {s - t |s t. s \\<in> T \\<and> t \\<in> T}", "obtain s' t' :: int\n    where \"s' \\<in> T\" \"t' \\<in> T\" \"Gcd T = s' - t'\""], ["proof (prove)\nusing this:\n  Gcd T \\<in> {s - t |s t. s \\<in> T \\<and> t \\<in> T}\n\ngoal (1 subgoal):\n 1. (\\<And>s' t'.\n        \\<lbrakk>s' \\<in> T; t' \\<in> T; Gcd T = s' - t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s' \\<in> T\n  t' \\<in> T\n  Gcd T = s' - t'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "moreover"], ["proof (state)\nthis:\n  s' \\<in> T\n  t' \\<in> T\n  Gcd T = s' - t'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "define s and t where \"s = nat s'\" and \"t = nat t'\""], ["proof (state)\nthis:\n  s = nat s'\n  t = nat t'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "moreover"], ["proof (state)\nthis:\n  s = nat s'\n  t = nat t'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "have \"int (Gcd S) = - int t \\<longleftrightarrow> S \\<subseteq> {0} \\<and> t = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int (Gcd S) = - int t) = (S \\<subseteq> {0} \\<and> t = 0)", "by auto (metis Gcd_dvd_nat dvd_0_right dvd_antisym nat_int nat_zminus_int)"], ["proof (state)\nthis:\n  (int (Gcd S) = - int t) = (S \\<subseteq> {0} \\<and> t = 0)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  s' \\<in> T\n  t' \\<in> T\n  Gcd T = s' - t'\n  s = nat s'\n  t = nat t'\n  (int (Gcd S) = - int t) = (S \\<subseteq> {0} \\<and> t = 0)", "have \n    st: \"s = 0 \\<or> s \\<in> S\" \"t = 0 \\<or> t \\<in> S\" and Gcd_S: \"Gcd S = s - t\""], ["proof (prove)\nusing this:\n  s' \\<in> T\n  t' \\<in> T\n  Gcd T = s' - t'\n  s = nat s'\n  t = nat t'\n  (int (Gcd S) = - int t) = (S \\<subseteq> {0} \\<and> t = 0)\n\ngoal (1 subgoal):\n 1. (s = 0 \\<or> s \\<in> S &&& t = 0 \\<or> t \\<in> S) &&& Gcd S = s - t", "using T_def"], ["proof (prove)\nusing this:\n  s' \\<in> T\n  t' \\<in> T\n  Gcd T = s' - t'\n  s = nat s'\n  t = nat t'\n  (int (Gcd S) = - int t) = (S \\<subseteq> {0} \\<and> t = 0)\n  T = insert 0 (int ` S)\n\ngoal (1 subgoal):\n 1. (s = 0 \\<or> s \\<in> S &&& t = 0 \\<or> t \\<in> S) &&& Gcd S = s - t", "by safe simp_all"], ["proof (state)\nthis:\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  Gcd S = s - t\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "with s"], ["proof (chain)\npicking this:\n  s \\<in> S\n  0 < s\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  Gcd S = s - t", "have \"t < s\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  0 < s\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  Gcd S = s - t\n\ngoal (1 subgoal):\n 1. t < s", "by (rule_tac ccontr) auto"], ["proof (state)\nthis:\n  t < s\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "{"], ["proof (state)\nthis:\n  t < s\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "fix s n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "have \"0 < n \\<Longrightarrow> s \\<in> S \\<Longrightarrow> n * s \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; s \\<in> S\\<rbrakk> \\<Longrightarrow> n * s \\<in> S", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; s \\<in> S\\<rbrakk> \\<Longrightarrow> 0 * s \\<in> S\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; s \\<in> S\\<rbrakk>\n                \\<Longrightarrow> n * s \\<in> S;\n        0 < Suc n; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Suc n * s \\<in> S", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; s \\<in> S\\<rbrakk> \\<Longrightarrow> n * s \\<in> S\n  0 < Suc n\n  s \\<in> S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < 0; s \\<in> S\\<rbrakk> \\<Longrightarrow> 0 * s \\<in> S\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; s \\<in> S\\<rbrakk>\n                \\<Longrightarrow> n * s \\<in> S;\n        0 < Suc n; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> Suc n * s \\<in> S", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < n; s \\<in> S\\<rbrakk> \\<Longrightarrow> n * s \\<in> S\n  0 < Suc n\n  s \\<in> S", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; s \\<in> S\\<rbrakk> \\<Longrightarrow> n * s \\<in> S\n  0 < Suc n\n  s \\<in> S\n\ngoal (1 subgoal):\n 1. Suc n * s \\<in> S", "by (cases n) (auto intro: S)"], ["proof (state)\nthis:\n  Suc n * s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < 0; s \\<in> S\\<rbrakk> \\<Longrightarrow> 0 * s \\<in> S", "qed simp"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; s \\<in> S\\<rbrakk> \\<Longrightarrow> n * s \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n2; ?sb2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> ?n2 * ?sb2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "note cmult_S = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n2; ?sb2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> ?n2 * ?sb2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S", "unfolding eventually_sequentially"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "assume \"s = 0 \\<or> t = 0\""], ["proof (state)\nthis:\n  s = 0 \\<or> t = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "with st Gcd_S s"], ["proof (chain)\npicking this:\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  Gcd S = s - t\n  s \\<in> S\n  0 < s\n  s = 0 \\<or> t = 0", "have *: \"Gcd S \\<in> S\""], ["proof (prove)\nusing this:\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  Gcd S = s - t\n  s \\<in> S\n  0 < s\n  s = 0 \\<or> t = 0\n\ngoal (1 subgoal):\n 1. Gcd S \\<in> S", "by (auto simp: int_eq_iff)"], ["proof (state)\nthis:\n  Gcd S \\<in> S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "then"], ["proof (chain)\npicking this:\n  Gcd S \\<in> S", "show \"\\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\""], ["proof (prove)\nusing this:\n  Gcd S \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "by (auto intro!: exI[of _ 1] cmult_S)"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "assume \"\\<not> (s = 0 \\<or> t = 0)\""], ["proof (state)\nthis:\n  \\<not> (s = 0 \\<or> t = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "with st"], ["proof (chain)\npicking this:\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  \\<not> (s = 0 \\<or> t = 0)", "have \"s \\<in> S\" \"t \\<in> S\" \"t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  s = 0 \\<or> s \\<in> S\n  t = 0 \\<or> t \\<in> S\n  \\<not> (s = 0 \\<or> t = 0)\n\ngoal (1 subgoal):\n 1. s \\<in> S &&& t \\<in> S &&& t \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  s \\<in> S\n  t \\<in> S\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "then"], ["proof (chain)\npicking this:\n  s \\<in> S\n  t \\<in> S\n  t \\<noteq> 0", "have \"Gcd S dvd t\""], ["proof (prove)\nusing this:\n  s \\<in> S\n  t \\<in> S\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Gcd S dvd t", "by auto"], ["proof (state)\nthis:\n  Gcd S dvd t\n\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "then"], ["proof (chain)\npicking this:\n  Gcd S dvd t", "obtain a where a: \"t = Gcd S * a\""], ["proof (prove)\nusing this:\n  Gcd S dvd t\n\ngoal (1 subgoal):\n 1. (\\<And>a. t = Gcd S * a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  t = Gcd S * a\n\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "with \\<open>t \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  t \\<noteq> 0\n  t = Gcd S * a", "have \"0 < a\""], ["proof (prove)\nusing this:\n  t \\<noteq> 0\n  t = Gcd S * a\n\ngoal (1 subgoal):\n 1. 0 < a", "by auto"], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. \\<not> (s = 0 \\<or> t = 0) \\<Longrightarrow>\n    \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "show \"\\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S", "proof (safe intro!: exI[of _ \"a * a\"])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "define m where \"m = (n - a * a) div a\""], ["proof (state)\nthis:\n  m = (n - a * a) div a\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "define r where \"r = (n - a * a) mod a\""], ["proof (state)\nthis:\n  r = (n - a * a) mod a\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "with \\<open>0 < a\\<close>"], ["proof (chain)\npicking this:\n  0 < a\n  r = (n - a * a) mod a", "have \"r < a\""], ["proof (prove)\nusing this:\n  0 < a\n  r = (n - a * a) mod a\n\ngoal (1 subgoal):\n 1. r < a", "by simp"], ["proof (state)\nthis:\n  r < a\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "moreover"], ["proof (state)\nthis:\n  r < a\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "define am where \"am = a + m\""], ["proof (state)\nthis:\n  am = a + m\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "ultimately"], ["proof (chain)\npicking this:\n  r < a\n  am = a + m", "have \"r < am\""], ["proof (prove)\nusing this:\n  r < a\n  am = a + m\n\ngoal (1 subgoal):\n 1. r < am", "by simp"], ["proof (state)\nthis:\n  r < am\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "assume \"a * a \\<le> n\""], ["proof (state)\nthis:\n  a * a \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "then"], ["proof (chain)\npicking this:\n  a * a \\<le> n", "have n: \"n = a * a + (m * a + r)\""], ["proof (prove)\nusing this:\n  a * a \\<le> n\n\ngoal (1 subgoal):\n 1. n = a * a + (m * a + r)", "unfolding m_def r_def"], ["proof (prove)\nusing this:\n  a * a \\<le> n\n\ngoal (1 subgoal):\n 1. n = a * a + ((n - a * a) div a * a + (n - a * a) mod a)", "by simp"], ["proof (state)\nthis:\n  n = a * a + (m * a + r)\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "have \"n * Gcd S = am * t + r * Gcd S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * Gcd S = am * t + r * Gcd S", "unfolding n a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * a + (m * a + r)) * Gcd S = am * (Gcd S * a) + r * Gcd S", "by (simp add: field_simps am_def)"], ["proof (state)\nthis:\n  n * Gcd S = am * t + r * Gcd S\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "also"], ["proof (state)\nthis:\n  n * Gcd S = am * t + r * Gcd S\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "have \"\\<dots> = r * s + (am - r) * t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. am * t + r * Gcd S = r * s + (am - r) * t", "unfolding \\<open>Gcd S = s - t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. am * t + r * (s - t) = r * s + (am - r) * t", "using \\<open>t < s\\<close> \\<open>r < am\\<close>"], ["proof (prove)\nusing this:\n  t < s\n  r < am\n\ngoal (1 subgoal):\n 1. am * t + r * (s - t) = r * s + (am - r) * t", "by (simp add: field_simps diff_mult_distrib2)"], ["proof (state)\nthis:\n  am * t + r * Gcd S = r * s + (am - r) * t\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "also"], ["proof (state)\nthis:\n  am * t + r * Gcd S = r * s + (am - r) * t\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "have \"\\<dots> \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * s + (am - r) * t \\<in> S", "using \\<open>s \\<in> S\\<close> \\<open>t \\<in> S\\<close> \\<open>r < am\\<close>"], ["proof (prove)\nusing this:\n  s \\<in> S\n  t \\<in> S\n  r < am\n\ngoal (1 subgoal):\n 1. r * s + (am - r) * t \\<in> S", "by (cases \"r = 0\") (auto intro!: cmult_S S)"], ["proof (state)\nthis:\n  r * s + (am - r) * t \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>n. a * a \\<le> n \\<Longrightarrow> n * Gcd S \\<in> S", "finally"], ["proof (chain)\npicking this:\n  n * Gcd S \\<in> S", "show \"n * Gcd S \\<in> S\""], ["proof (prove)\nusing this:\n  n * Gcd S \\<in> S\n\ngoal (1 subgoal):\n 1. n * Gcd S \\<in> S", "."], ["proof (state)\nthis:\n  n * Gcd S \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. n * Gcd S \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially. m * Gcd S \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["", "context MC_syntax\nbegin"], ["", "subsection \\<open>Expected number of visits\\<close>"], ["", "definition \"G s t = (\\<integral>\\<^sup>+\\<omega>. scount (HLD {t}) (s ## \\<omega>) \\<partial>T s)\""], ["", "lemma G_eq: \"G s t = (\\<integral>\\<^sup>+\\<omega>. emeasure (count_space UNIV) {i. (s ## \\<omega>) !! i = t} \\<partial>T s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G s t =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         emeasure (count_space UNIV)\n                          {i. (s ## \\<omega>) !! i = t}\n                       \\<partial>T s", "by (simp add: G_def scount_eq_emeasure HLD_iff)"], ["", "definition \"p s t n = \\<P>(\\<omega> in T s. (s ## \\<omega>) !! n = t)\""], ["", "definition \"gf_G s t z = (\\<Sum>n. p s t n *\\<^sub>R z ^ n)\""], ["", "definition \"convergence_G s t z \\<longleftrightarrow> summable (\\<lambda>n. p s t n * norm z ^ n)\""], ["", "lemma p_nonneg[simp]: \"0 \\<le> p x y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p x y n", "by (simp add: p_def)"], ["", "lemma p_le_1: \"p x y n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y n \\<le> 1", "by (simp add: p_def)"], ["", "lemma p_x_x_0[simp]: \"p x x 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x x 0 = 1", "by (simp add: p_def T.prob_space del: space_T)"], ["", "lemma p_0: \"p x y 0 = (if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y 0 = (if x = y then 1 else 0)", "by (simp add: p_def T.prob_space del: space_T)"], ["", "lemma p_in_reachable: assumes \"(x, y) \\<notin> (SIGMA x:UNIV. K x)\\<^sup>*\" shows \"p x y n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y n = 0", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! n = y} = 0", "proof (rule T.prob_eq_0_AE)"], ["proof (state)\ngoal (1 subgoal):\n 1. AE \\<omega> in T x. (x ## \\<omega>) !! n \\<noteq> y", "from AE_T_reachable"], ["proof (chain)\npicking this:\n  almost_everywhere (T ?s) (alw (HLD (acc `` {?s})))", "show \"AE \\<omega> in T x. (x ## \\<omega>) !! n \\<noteq> y\""], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (alw (HLD (acc `` {?s})))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T x. (x ## \\<omega>) !! n \\<noteq> y", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       (x ## \\<omega>) !! n \\<noteq> y", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       (x ## \\<omega>) !! n \\<noteq> y", "assume \"alw (HLD ((SIGMA \\<omega>:UNIV. K \\<omega>)\\<^sup>* `` {x})) \\<omega>\""], ["proof (state)\nthis:\n  alw (HLD (acc `` {x})) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       (x ## \\<omega>) !! n \\<noteq> y", "then"], ["proof (chain)\npicking this:\n  alw (HLD (acc `` {x})) \\<omega>", "have \"alw (HLD (- {y})) \\<omega>\""], ["proof (prove)\nusing this:\n  alw (HLD (acc `` {x})) \\<omega>\n\ngoal (1 subgoal):\n 1. alw (HLD (- {y})) \\<omega>", "using assms"], ["proof (prove)\nusing this:\n  alw (HLD (acc `` {x})) \\<omega>\n  (x, y) \\<notin> acc\n\ngoal (1 subgoal):\n 1. alw (HLD (- {y})) \\<omega>", "by (auto intro: alw_mono simp: HLD_iff)"], ["proof (state)\nthis:\n  alw (HLD (- {y})) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       (x ## \\<omega>) !! n \\<noteq> y", "then"], ["proof (chain)\npicking this:\n  alw (HLD (- {y})) \\<omega>", "show \"(x ## \\<omega>) !! n \\<noteq> y\""], ["proof (prove)\nusing this:\n  alw (HLD (- {y})) \\<omega>\n\ngoal (1 subgoal):\n 1. (x ## \\<omega>) !! n \\<noteq> y", "using assms"], ["proof (prove)\nusing this:\n  alw (HLD (- {y})) \\<omega>\n  (x, y) \\<notin> acc\n\ngoal (1 subgoal):\n 1. (x ## \\<omega>) !! n \\<noteq> y", "by (cases n) (auto simp: alw_HLD_iff_streams streams_iff_snth)"], ["proof (state)\nthis:\n  (x ## \\<omega>) !! n \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in T x. (x ## \\<omega>) !! n \\<noteq> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_Suc: \"ennreal (p x y (Suc n)) = (\\<integral>\\<^sup>+ w. p w y n \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y (Suc n)) =\n    \\<integral>\\<^sup>+ x. ennreal (p x y n) \\<partial>measure_pmf (K x)", "unfolding p_def T.emeasure_eq_measure[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x)\n     {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! Suc n = y} =\n    \\<integral>\\<^sup>+ x. emeasure (T x)\n                            {\\<omega> \\<in> space (T x).\n                             (x ## \\<omega>) !! n = y}\n                       \\<partial>measure_pmf (K x)", "by (subst emeasure_Collect_T) simp_all"], ["", "lemma p_Suc':\n  \"p x y (Suc n) = (\\<integral>x'. p x' y n \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y (Suc n) = measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n)", "using p_Suc[of x y n]"], ["proof (prove)\nusing this:\n  ennreal (p x y (Suc n)) =\n  \\<integral>\\<^sup>+ x. ennreal (p x y n) \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. p x y (Suc n) = measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n)", "by (subst (asm) nn_integral_eq_integral)\n     (auto simp: p_le_1 intro!: measure_pmf.integrable_const_bound[where B=1])"], ["", "lemma p_add: \"p x y (n + m) = (\\<integral>\\<^sup>+ w. p x w n * p w y m \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y (n + m)) =\n    \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                       \\<partial>count_space UNIV", "proof (induction n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ennreal (p x y (0 + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa 0 * p xa y m)\n                          \\<partial>count_space UNIV\n 2. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ennreal (p x y (0 + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa 0 * p xa y m)\n                          \\<partial>count_space UNIV\n 2. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have [simp]: \"\\<And>w. (if x = w then 1 else 0) * p w y m = ennreal (p x y m) * indicator {x} w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       ennreal ((if x = w then 1 else 0) * p w y m) =\n       ennreal (p x y m) * indicator {x} w", "by auto"], ["proof (state)\nthis:\n  ennreal ((if x = ?w3 then 1 else 0) * p ?w3 y m) =\n  ennreal (p x y m) * indicator {x} ?w3\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       ennreal (p x y (0 + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa 0 * p xa y m)\n                          \\<partial>count_space UNIV\n 2. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y (0 + m)) =\n    \\<integral>\\<^sup>+ x. ennreal (p x x 0 * p x y m)\n                       \\<partial>count_space UNIV", "by (simp add: p_0 one_ennreal_def[symmetric] max_def)"], ["proof (state)\nthis:\n  ennreal (p x y (0 + m)) =\n  \\<integral>\\<^sup>+ x. ennreal (p x x 0 * p x y m)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "case (Suc n)"], ["proof (state)\nthis:\n  ennreal (p ?x3 y (n + m)) =\n  \\<integral>\\<^sup>+ x. ennreal (p ?x3 x n * p x y m)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "define X where \"X = (SIGMA x:UNIV. K x)\\<^sup>* `` K x\""], ["proof (state)\nthis:\n  X = acc `` set_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "then"], ["proof (chain)\npicking this:\n  X = acc `` set_pmf (K x)", "have X: \"countable X\""], ["proof (prove)\nusing this:\n  X = acc `` set_pmf (K x)\n\ngoal (1 subgoal):\n 1. countable X", "by (blast intro: countable_Image countable_reachable countable_set_pmf)"], ["proof (state)\nthis:\n  countable X\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "then"], ["proof (chain)\npicking this:\n  countable X", "interpret X: sigma_finite_measure \"count_space X\""], ["proof (prove)\nusing this:\n  countable X\n\ngoal (1 subgoal):\n 1. sigma_finite_measure (count_space X)", "by (rule sigma_finite_measure_count_space_countable)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "interpret XK: pair_sigma_finite \"K x\" \"count_space X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_sigma_finite (measure_pmf (K x)) (count_space X)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"ennreal (p x y (Suc n + m)) = (\\<integral>\\<^sup>+t. (\\<integral>\\<^sup>+w. p t w n * p w y m \\<partial>count_space UNIV) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y (Suc n + m)) =\n    \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x.\n          ennreal (p t x n * p x y m)\n        \\<partial>count_space UNIV\n                       \\<partial>measure_pmf (K x)", "by (simp add: p_Suc Suc)"], ["proof (state)\nthis:\n  ennreal (p x y (Suc n + m)) =\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space UNIV\n                     \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  ennreal (p x y (Suc n + m)) =\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space UNIV\n                     \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+t. (\\<integral>\\<^sup>+w. ennreal (p t w n * p w y m) * indicator X w \\<partial>count_space UNIV) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x.\n          ennreal (p t x n * p x y m)\n        \\<partial>count_space UNIV\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ t. (\\<integral>\\<^sup>+w\\<in>X.\n         ennreal (p t w n * p w y m)\n                            \\<partial>count_space UNIV)\n                       \\<partial>measure_pmf (K x)", "by (auto intro!: nn_integral_cong_AE simp: AE_measure_pmf_iff AE_count_space Image_iff p_in_reachable X_def             split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space UNIV\n                     \\<partial>measure_pmf (K x) =\n  \\<integral>\\<^sup>+ t. (\\<integral>\\<^sup>+w\\<in>X.\n       ennreal (p t w n * p w y m)\n                          \\<partial>count_space UNIV)\n                     \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space UNIV\n                     \\<partial>measure_pmf (K x) =\n  \\<integral>\\<^sup>+ t. (\\<integral>\\<^sup>+w\\<in>X.\n       ennreal (p t w n * p w y m)\n                          \\<partial>count_space UNIV)\n                     \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+t. (\\<integral>\\<^sup>+w. p t w n * p w y m \\<partial>count_space X) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. (\\<integral>\\<^sup>+w\\<in>X.\n         ennreal (p t w n * p w y m)\n                            \\<partial>count_space UNIV)\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x.\n          ennreal (p t x n * p x y m)\n        \\<partial>count_space X\n                       \\<partial>measure_pmf (K x)", "by (subst nn_integral_restrict_space[symmetric]) (simp_all add: restrict_count_space)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. (\\<integral>\\<^sup>+w\\<in>X.\n       ennreal (p t w n * p w y m)\n                          \\<partial>count_space UNIV)\n                     \\<partial>measure_pmf (K x) =\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space X\n                     \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. (\\<integral>\\<^sup>+w\\<in>X.\n       ennreal (p t w n * p w y m)\n                          \\<partial>count_space UNIV)\n                     \\<partial>measure_pmf (K x) =\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space X\n                     \\<partial>measure_pmf (K x)\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+w. (\\<integral>\\<^sup>+t. p t w n * p w y m \\<partial>K x) \\<partial>count_space X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x.\n          ennreal (p t x n * p x y m)\n        \\<partial>count_space X\n                       \\<partial>measure_pmf (K x) =\n    \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x.\n          ennreal (p x w n * p w y m)\n        \\<partial>measure_pmf (K x)\n                       \\<partial>count_space X", "apply (rule XK.Fubini'[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, ya). ennreal (p x ya n * p ya y m))\n    \\<in> borel_measurable\n           (measure_pmf (K x) \\<Otimes>\\<^sub>M count_space X)", "unfolding measurable_split_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. ennreal (p (fst x) (snd x) n * p (snd x) y m))\n    \\<in> borel_measurable\n           (measure_pmf (K x) \\<Otimes>\\<^sub>M count_space X)", "apply (rule measurable_compose_countable'[OF _ measurable_snd X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> X \\<Longrightarrow>\n       (\\<lambda>x. ennreal (p (fst x) i n * p i y m))\n       \\<in> borel_measurable\n              (measure_pmf (K x) \\<Otimes>\\<^sub>M count_space X)", "apply (rule measurable_compose[OF measurable_fst])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> X \\<Longrightarrow>\n       measure_pmf.random_variable (K x) borel\n        (\\<lambda>a. ennreal (p a i n * p i y m))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space X\n                     \\<partial>measure_pmf (K x) =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space X\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. \\<integral>\\<^sup>+ x. ennreal (p t x n * p x y m)\n      \\<partial>count_space X\n                     \\<partial>measure_pmf (K x) =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space X\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+w. (\\<integral>\\<^sup>+t. ennreal (p t w n * p w y m) * indicator X w \\<partial>K x) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x.\n          ennreal (p x w n * p w y m)\n        \\<partial>measure_pmf (K x)\n                       \\<partial>count_space X =\n    \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n          ennreal (p t w n * p w y m) * indicator X w\n        \\<partial>measure_pmf (K x)\n                       \\<partial>count_space UNIV", "by (simp add: nn_integral_restrict_space[symmetric] restrict_count_space nn_integral_multc)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space X =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n        ennreal (p t w n * p w y m) * indicator X w\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space X =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n        ennreal (p t w n * p w y m) * indicator X w\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+w. (\\<integral>\\<^sup>+t. ennreal (p t w n * p w y m) \\<partial>K x) \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n          ennreal (p t w n * p w y m) * indicator X w\n        \\<partial>measure_pmf (K x)\n                       \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n          ennreal (p t w n * p w y m)\n        \\<partial>measure_pmf (K x)\n                       \\<partial>count_space UNIV", "by (auto intro!: nn_integral_cong_AE simp: AE_measure_pmf_iff AE_count_space Image_iff p_in_reachable X_def             split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n        ennreal (p t w n * p w y m) * indicator X w\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t. ennreal (p t w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n        ennreal (p t w n * p w y m) * indicator X w\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t. ennreal (p t w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "have \"\\<dots> = (\\<integral>\\<^sup>+w. (\\<integral>\\<^sup>+t. p t w n \\<partial>K x) * p w y m \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t.\n          ennreal (p t w n * p w y m)\n        \\<partial>measure_pmf (K x)\n                       \\<partial>count_space UNIV =\n    \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n)\n        \\<partial>measure_pmf (K x) *\n                           ennreal (p w y m)\n                       \\<partial>count_space UNIV", "by (simp add: nn_integral_multc[symmetric] ennreal_mult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ t. ennreal (p t w n * p w y m)\n      \\<partial>measure_pmf (K x)\n                     \\<partial>count_space UNIV =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n)\n      \\<partial>measure_pmf (K x) *\n                         ennreal (p w y m)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. \\<And>n x.\n       (\\<And>x.\n           ennreal (p x y (n + m)) =\n           \\<integral>\\<^sup>+ xa. ennreal (p x xa n * p xa y m)\n                              \\<partial>count_space UNIV) \\<Longrightarrow>\n       ennreal (p x y (Suc n + m)) =\n       \\<integral>\\<^sup>+ xa. ennreal (p x xa (Suc n) * p xa y m)\n                          \\<partial>count_space UNIV", "finally"], ["proof (chain)\npicking this:\n  ennreal (p x y (Suc n + m)) =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n)\n      \\<partial>measure_pmf (K x) *\n                         ennreal (p w y m)\n                     \\<partial>count_space UNIV", "show ?case"], ["proof (prove)\nusing this:\n  ennreal (p x y (Suc n + m)) =\n  \\<integral>\\<^sup>+ w. \\<integral>\\<^sup>+ x. ennreal (p x w n)\n      \\<partial>measure_pmf (K x) *\n                         ennreal (p w y m)\n                     \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. ennreal (p x y (Suc n + m)) =\n    \\<integral>\\<^sup>+ x. ennreal (p x x (Suc n) * p x y m)\n                       \\<partial>count_space UNIV", "by (simp add: ennreal_mult p_Suc)"], ["proof (state)\nthis:\n  ennreal (p x y (Suc n + m)) =\n  \\<integral>\\<^sup>+ x. ennreal (p x x (Suc n) * p x y m)\n                     \\<partial>count_space UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prob_reachable_le:\n  assumes [simp]: \"m \\<le> n\"\n  shows \"p x y m * p y w (n - m) \\<le> p x w n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y m * p y w (n - m) \\<le> p x w n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y m * p y w (n - m) \\<le> p x w n", "have \"p x y m * p y w (n - m) = (\\<integral>\\<^sup>+y'. ennreal (p x y m * p y w (n - m)) * indicator {y} y' \\<partial>count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y m * p y w (n - m)) =\n    \\<integral>\\<^sup>+y'\\<in>{y}. ennreal (p x y m * p y w (n - m))\n    \\<partial>count_space UNIV", "by simp"], ["proof (state)\nthis:\n  ennreal (p x y m * p y w (n - m)) =\n  \\<integral>\\<^sup>+y'\\<in>{y}. ennreal (p x y m * p y w (n - m))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. p x y m * p y w (n - m) \\<le> p x w n", "also"], ["proof (state)\nthis:\n  ennreal (p x y m * p y w (n - m)) =\n  \\<integral>\\<^sup>+y'\\<in>{y}. ennreal (p x y m * p y w (n - m))\n  \\<partial>count_space UNIV\n\ngoal (1 subgoal):\n 1. p x y m * p y w (n - m) \\<le> p x w n", "have \"\\<dots> \\<le> p x w (m + (n - m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+y'\\<in>{y}. ennreal (p x y m * p y w (n - m))\n    \\<partial>count_space UNIV\n    \\<le> ennreal (p x w (m + (n - m)))", "by (subst p_add)\n       (auto intro!: nn_integral_mono split: split_indicator simp del: nn_integral_indicator_singleton)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+y'\\<in>{y}. ennreal (p x y m * p y w (n - m))\n  \\<partial>count_space UNIV\n  \\<le> ennreal (p x w (m + (n - m)))\n\ngoal (1 subgoal):\n 1. p x y m * p y w (n - m) \\<le> p x w n", "finally"], ["proof (chain)\npicking this:\n  ennreal (p x y m * p y w (n - m)) \\<le> ennreal (p x w (m + (n - m)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ennreal (p x y m * p y w (n - m)) \\<le> ennreal (p x w (m + (n - m)))\n\ngoal (1 subgoal):\n 1. p x y m * p y w (n - m) \\<le> p x w n", "by simp"], ["proof (state)\nthis:\n  p x y m * p y w (n - m) \\<le> p x w n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma G_eq_suminf: \"G x y = (\\<Sum>i. ennreal (p x y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "have *: \"\\<And>i \\<omega>. indicator {\\<omega> \\<in> space S. (x ## \\<omega>) !! i = y} \\<omega> = indicator {i. (x ## \\<omega>) !! i = y} i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<omega>.\n       indicator\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         (x ## \\<omega>) !! i = y}\n        \\<omega> =\n       indicator {i. (x ## \\<omega>) !! i = y} i", "by (auto simp: space_stream_space split: split_indicator)"], ["proof (state)\nthis:\n  indicator\n   {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n    (x ## \\<omega>) !! ?i3 = y}\n   ?\\<omega>3 =\n  indicator {i. (x ## ?\\<omega>3) !! i = y} ?i3\n\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "have \"G x y = (\\<integral>\\<^sup>+ \\<omega>. (\\<Sum>i. indicator {\\<omega>\\<in>space (T x). (x ## \\<omega>) !! i = y} \\<omega>) \\<partial>T x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G x y =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sum>i.\n                             indicator\n                              {\\<omega> \\<in> space (T x).\n                               (x ## \\<omega>) !! i = y}\n                              \\<omega>)\n                       \\<partial>T x", "unfolding G_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         emeasure (count_space UNIV)\n                          {i. (x ## \\<omega>) !! i = y}\n                       \\<partial>T x =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sum>i.\n                             indicator\n                              {\\<omega> \\<in> space (T x).\n                               (x ## \\<omega>) !! i = y}\n                              \\<omega>)\n                       \\<partial>T x", "by (simp add: nn_integral_count_space_nat[symmetric] *)"], ["proof (state)\nthis:\n  G x y =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sum>i.\n                           indicator\n                            {\\<omega> \\<in> space (T x).\n                             (x ## \\<omega>) !! i = y}\n                            \\<omega>)\n                     \\<partial>T x\n\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "also"], ["proof (state)\nthis:\n  G x y =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sum>i.\n                           indicator\n                            {\\<omega> \\<in> space (T x).\n                             (x ## \\<omega>) !! i = y}\n                            \\<omega>)\n                     \\<partial>T x\n\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "have \"\\<dots> = (\\<Sum>i. ennreal (p x y i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sum>i.\n                             indicator\n                              {\\<omega> \\<in> space (T x).\n                               (x ## \\<omega>) !! i = y}\n                              \\<omega>)\n                       \\<partial>T x =\n    (\\<Sum>i. ennreal (p x y i))", "by (simp add: T.emeasure_eq_measure[symmetric] p_def nn_integral_suminf)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sum>i.\n                           indicator\n                            {\\<omega> \\<in> space (T x).\n                             (x ## \\<omega>) !! i = y}\n                            \\<omega>)\n                     \\<partial>T x =\n  (\\<Sum>i. ennreal (p x y i))\n\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "finally"], ["proof (chain)\npicking this:\n  G x y = (\\<Sum>i. ennreal (p x y i))", "show ?thesis"], ["proof (prove)\nusing this:\n  G x y = (\\<Sum>i. ennreal (p x y i))\n\ngoal (1 subgoal):\n 1. G x y = (\\<Sum>i. ennreal (p x y i))", "."], ["proof (state)\nthis:\n  G x y = (\\<Sum>i. ennreal (p x y i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma G_eq_real_suminf:\n  \"convergence_G x y (1::real) \\<Longrightarrow> G x y = ennreal (\\<Sum>i. p x y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergence_G x y 1 \\<Longrightarrow> G x y = ennreal (\\<Sum>i. p x y i)", "unfolding G_eq_suminf"], ["proof (prove)\ngoal (1 subgoal):\n 1. convergence_G x y 1 \\<Longrightarrow>\n    (\\<Sum>i. ennreal (p x y i)) = ennreal (\\<Sum>i. p x y i)", "by (intro suminf_ennreal ennreal_suminf_neq_top p_nonneg)\n     (auto simp: convergence_G_def p_def)"], ["", "lemma convergence_norm_G:\n  \"convergence_G x y z \\<Longrightarrow> summable (\\<lambda>n. p x y n * norm z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergence_G x y z \\<Longrightarrow>\n    summable (\\<lambda>n. p x y n * norm z ^ n)", "unfolding convergence_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. p x y n * norm z ^ n) \\<Longrightarrow>\n    summable (\\<lambda>n. p x y n * norm z ^ n)", "."], ["", "lemma convergence_G:\n  \"convergence_G x y (z::'a::{banach, real_normed_div_algebra}) \\<Longrightarrow> summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergence_G x y z \\<Longrightarrow>\n    summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)", "unfolding convergence_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. p x y n * norm z ^ n) \\<Longrightarrow>\n    summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)", "by (rule summable_norm_cancel) (simp add: abs_mult norm_power)"], ["", "lemma convergence_G_less_1:\n  fixes z :: \"_ :: {banach, real_normed_field}\"\n  assumes z: \"norm z < 1\" shows \"convergence_G x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergence_G x y z", "unfolding convergence_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. p x y n * norm z ^ n)", "proof (rule summable_comparison_test)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>N. \\<forall>n\\<ge>N. norm (p x y n * norm z ^ n) \\<le> ?g n\n 2. summable ?g", "have \"\\<And>n. p x y n * norm (z ^ n) \\<le> 1 * norm (z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. p x y n * norm (z ^ n) \\<le> 1 * norm (z ^ n)", "by (intro mult_right_mono p_le_1) simp_all"], ["proof (state)\nthis:\n  p x y ?n3 * norm (z ^ ?n3) \\<le> 1 * norm (z ^ ?n3)\n\ngoal (2 subgoals):\n 1. \\<exists>N. \\<forall>n\\<ge>N. norm (p x y n * norm z ^ n) \\<le> ?g n\n 2. summable ?g", "then"], ["proof (chain)\npicking this:\n  p x y ?n3 * norm (z ^ ?n3) \\<le> 1 * norm (z ^ ?n3)", "show \"\\<exists>N. \\<forall>n\\<ge>N. norm (p x y n * norm z ^ n) \\<le> norm z ^ n\""], ["proof (prove)\nusing this:\n  p x y ?n3 * norm (z ^ ?n3) \\<le> 1 * norm (z ^ ?n3)\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N. norm (p x y n * norm z ^ n) \\<le> norm z ^ n", "by (simp add: norm_power)"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>n\\<ge>N. norm (p x y n * norm z ^ n) \\<le> norm z ^ n\n\ngoal (1 subgoal):\n 1. summable ((^) (norm z))", "qed (simp add: z summable_geometric)"], ["", "lemma lim_gf_G: \"((\\<lambda>z. ennreal (gf_G x y z)) \\<longlongrightarrow> G x y) (at_left (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (gf_G x y z)) \\<longlongrightarrow> G x y)\n     (at_left 1)", "unfolding gf_G_def G_eq_suminf real_scaleR_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (\\<Sum>n. p x y n * z ^ n)) \\<longlongrightarrow>\n     (\\<Sum>i. ennreal (p x y i)))\n     (at_left 1)", "by (intro power_series_tendsto_at_left p_nonneg p_le_1 summable_power_series)"], ["", "subsection \\<open>Reachability probability\\<close>"], ["", "definition \"u x y n = \\<P>(\\<omega> in T x. ev_at (HLD {y}) n \\<omega>)\""], ["", "definition \"U s t = \\<P>(\\<omega> in T s. ev (HLD {t}) \\<omega>)\""], ["", "definition \"gf_U x y z = (\\<Sum>n. u x y n *\\<^sub>R z ^ Suc n)\""], ["", "definition \"f x y n = \\<P>(\\<omega> in T x. ev_at (HLD {y}) n (x ## \\<omega>))\""], ["", "definition \"F s t = \\<P>(\\<omega> in T s. ev (HLD {t}) (s ## \\<omega>))\""], ["", "definition \"gf_F x y z = (\\<Sum>n. f x y n * z ^ n)\""], ["", "lemma f_Suc: \"x \\<noteq> y \\<Longrightarrow> f x y (Suc n) = u x y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> f x y (Suc n) = u x y n", "by (simp add: u_def f_def)"], ["", "lemma f_Suc_eq: \"f x x (Suc n) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x x (Suc n) = 0", "by (simp add: f_def)"], ["", "lemma f_0: \"f x y 0 = (if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y 0 = (if x = y then 1 else 0)", "using T.prob_space"], ["proof (prove)\nusing this:\n  T.prob ?s (space (T ?s)) = 1\n\ngoal (1 subgoal):\n 1. f x y 0 = (if x = y then 1 else 0)", "by (simp add: f_def)"], ["", "lemma shows u_nonneg: \"0 \\<le> u x y n\" and u_le_1: \"u x y n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> u x y n &&& u x y n \\<le> 1", "by (simp_all add: u_def)"], ["", "lemma shows f_nonneg: \"0 \\<le> f x y n\" and f_le_1: \"f x y n \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> f x y n &&& f x y n \\<le> 1", "by (simp_all add: f_def)"], ["", "lemma U_nonneg[simp]: \"0 \\<le> U x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> U x y", "by (simp add: U_def)"], ["", "lemma U_le_1: \"U s t \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U s t \\<le> 1", "by (auto simp add: U_def intro!: antisym)"], ["", "lemma U_cases: \"U s s = 1 \\<or> U s s < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U s s = 1 \\<or> U s s < 1", "by (auto simp add: U_def intro!: antisym)"], ["", "lemma u_sums_U: \"u x y sums U x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x y sums U x y", "unfolding u_def[abs_def] U_def ev_iff_ev_at"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        T.prob x\n         {\\<omega> \\<in> space (T x). ev_at (HLD {y}) n \\<omega>}) sums\n    T.prob x\n     {\\<omega> \\<in> space (T x). \\<exists>n. ev_at (HLD {y}) n \\<omega>}", "by (intro T.prob_sums) (auto intro: ev_at_unique)"], ["", "lemma gf_U_eq_U: \"gf_U x y 1 = U x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_U x y 1 = U x y", "using u_sums_U[THEN sums_unique]"], ["proof (prove)\nusing this:\n  U ?x1 ?y1 = suminf (u ?x1 ?y1)\n\ngoal (1 subgoal):\n 1. gf_U x y 1 = U x y", "by (simp add: gf_U_def U_def)"], ["", "lemma f_sums_F: \"f x y sums F x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y sums F x y", "unfolding f_def[abs_def] F_def ev_iff_ev_at"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        T.prob x\n         {\\<omega> \\<in> space (T x).\n          ev_at (HLD {y}) n (x ## \\<omega>)}) sums\n    T.prob x\n     {\\<omega> \\<in> space (T x).\n      \\<exists>n. ev_at (HLD {y}) n (x ## \\<omega>)}", "by (intro T.prob_sums) (auto intro: ev_at_unique)"], ["", "lemma F_nonneg[simp]: \"0 \\<le> F x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> F x y", "by (auto simp: F_def)"], ["", "lemma F_le_1: \"F x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F x y \\<le> 1", "by (simp add: F_def)"], ["", "lemma gf_F_eq_F: \"gf_F x y 1 = F x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_F x y 1 = F x y", "using f_sums_F[THEN sums_unique]"], ["proof (prove)\nusing this:\n  F ?x1 ?y1 = suminf (f ?x1 ?y1)\n\ngoal (1 subgoal):\n 1. gf_F x y 1 = F x y", "by (simp add: gf_F_def F_def)"], ["", "lemma gf_F_le_1:\n  fixes z :: real\n  assumes z: \"0 \\<le> z\" \"z \\<le> 1\"\n  shows \"gf_F x y z \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> 1", "have \"gf_F x y z \\<le> gf_F x y 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> gf_F x y 1", "using z"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z \\<le> 1\n\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> gf_F x y 1", "unfolding gf_F_def"], ["proof (prove)\nusing this:\n  0 \\<le> z\n  z \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f x y n * z ^ n) \\<le> (\\<Sum>n. f x y n * 1 ^ n)", "by (intro suminf_le[OF _ summable_comparison_test[OF _ sums_summable[OF f_sums_F[of x y]]]] mult_left_mono allI f_nonneg)\n       (simp_all add: power_le_one f_nonneg mult_right_le_one_le f_le_1 sums_summable[OF f_sums_F[of x y]])"], ["proof (state)\nthis:\n  gf_F x y z \\<le> gf_F x y 1\n\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> 1", "also"], ["proof (state)\nthis:\n  gf_F x y z \\<le> gf_F x y 1\n\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> 1", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_F x y 1 \\<le> 1", "by (simp add: gf_F_eq_F F_def)"], ["proof (state)\nthis:\n  gf_F x y 1 \\<le> 1\n\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  gf_F x y z \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  gf_F x y z \\<le> 1\n\ngoal (1 subgoal):\n 1. gf_F x y z \\<le> 1", "."], ["proof (state)\nthis:\n  gf_F x y z \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma u_le_p: \"u x y n \\<le> p x y (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u x y n \\<le> p x y (Suc n)", "unfolding u_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x {\\<omega> \\<in> space (T x). ev_at (HLD {y}) n \\<omega>}\n    \\<le> T.prob x\n           {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! Suc n = y}", "by (auto intro!: T.finite_measure_mono dest: ev_at_HLD_imp_snth)"], ["", "lemma f_le_p: \"f x y n \\<le> p x y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y n \\<le> p x y n", "unfolding f_def p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x {\\<omega> \\<in> space (T x). ev_at (HLD {y}) n (x ## \\<omega>)}\n    \\<le> T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! n = y}", "by (auto intro!: T.finite_measure_mono dest: ev_at_HLD_imp_snth)"], ["", "lemma convergence_norm_U:\n  fixes z :: \"_ :: real_normed_div_algebra\"\n  assumes z: \"convergence_G x y z\"\n  shows \"summable (\\<lambda>n. u x y n * norm z ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * norm z ^ Suc n)", "using summable_ignore_initial_segment[OF convergence_norm_G[OF z], of 1]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. p x y (n + 1) * norm z ^ (n + 1))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * norm z ^ Suc n)", "by (rule summable_comparison_test[rotated])\n     (auto simp add: u_nonneg abs_mult intro!: exI[of _ 0] mult_right_mono u_le_p)"], ["", "lemma convergence_norm_F:\n  fixes z :: \"_ :: real_normed_div_algebra\"\n  assumes z: \"convergence_G x y z\"\n  shows \"summable (\\<lambda>n. f x y n * norm z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. f x y n * norm z ^ n)", "using convergence_norm_G[OF z]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. p x y n * norm z ^ n)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. f x y n * norm z ^ n)", "by (rule summable_comparison_test[rotated])\n     (auto simp add: f_nonneg abs_mult intro!: exI[of _ 0] mult_right_mono f_le_p)"], ["", "lemma gf_G_nonneg:\n  fixes z :: real\n  shows \"0 \\<le> z \\<Longrightarrow> z < 1 \\<Longrightarrow> 0 \\<le> gf_G x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z < 1\\<rbrakk> \\<Longrightarrow> 0 \\<le> gf_G x y z", "unfolding gf_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z < 1\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> (\\<Sum>n. p x y n *\\<^sub>R z ^ n)", "by (intro suminf_nonneg convergence_G convergence_G_less_1) simp_all"], ["", "lemma gf_F_nonneg:\n  fixes z :: real\n  shows \"0 \\<le> z \\<Longrightarrow> z < 1 \\<Longrightarrow> 0 \\<le> gf_F x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z < 1\\<rbrakk> \\<Longrightarrow> 0 \\<le> gf_F x y z", "unfolding gf_F_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z < 1\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> (\\<Sum>n. f x y n * z ^ n)", "using convergence_norm_F[OF convergence_G_less_1, of z x y]"], ["proof (prove)\nusing this:\n  norm z < 1 \\<Longrightarrow> summable (\\<lambda>n. f x y n * norm z ^ n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> z; z < 1\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> (\\<Sum>n. f x y n * z ^ n)", "by (intro suminf_nonneg) (simp_all add: f_nonneg)"], ["", "lemma convergence_U:\n  fixes z :: \"_ :: banach\"\n  shows \"convergence_G x y z \\<Longrightarrow> summable (\\<lambda>n. u x y n * z ^ Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convergence_G x y z \\<Longrightarrow>\n    summable (\\<lambda>n. u x y n * z ^ Suc n)", "by (rule summable_norm_cancel)\n     (auto simp add: abs_mult u_nonneg power_abs dest!: convergence_norm_U)"], ["", "lemma p_eq_sum_p_u: \"p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "have \"\\<And>\\<omega>. \\<omega> !! n = y \\<Longrightarrow> (\\<exists>i. i \\<le> n \\<and> ev_at (HLD {y}) i \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<omega> !! n = y \\<Longrightarrow>\n       \\<exists>i\\<le>n. ev_at (HLD {y}) i \\<omega>", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<omega> !! 0 = y \\<Longrightarrow>\n       \\<exists>i\\<le>0. ev_at (HLD {y}) i \\<omega>\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   \\<omega> !! n = y \\<Longrightarrow>\n                   \\<exists>i\\<le>n. ev_at (HLD {y}) i \\<omega>;\n        \\<omega> !! Suc n = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>Suc n. ev_at (HLD {y}) i \\<omega>", "case (Suc n)"], ["proof (state)\nthis:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4\n  \\<omega> !! Suc n = y\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<omega> !! 0 = y \\<Longrightarrow>\n       \\<exists>i\\<le>0. ev_at (HLD {y}) i \\<omega>\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   \\<omega> !! n = y \\<Longrightarrow>\n                   \\<exists>i\\<le>n. ev_at (HLD {y}) i \\<omega>;\n        \\<omega> !! Suc n = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>Suc n. ev_at (HLD {y}) i \\<omega>", "then"], ["proof (chain)\npicking this:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4\n  \\<omega> !! Suc n = y", "obtain i where \"i \\<le> n\" \"ev_at (HLD {y}) i (stl \\<omega>)\""], ["proof (prove)\nusing this:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4\n  \\<omega> !! Suc n = y\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<le> n; ev_at (HLD {y}) i (stl \\<omega>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> n\n  ev_at (HLD {y}) i (stl \\<omega>)\n\ngoal (2 subgoals):\n 1. \\<And>\\<omega>.\n       \\<omega> !! 0 = y \\<Longrightarrow>\n       \\<exists>i\\<le>0. ev_at (HLD {y}) i \\<omega>\n 2. \\<And>n \\<omega>.\n       \\<lbrakk>\\<And>\\<omega>.\n                   \\<omega> !! n = y \\<Longrightarrow>\n                   \\<exists>i\\<le>n. ev_at (HLD {y}) i \\<omega>;\n        \\<omega> !! Suc n = y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i\\<le>Suc n. ev_at (HLD {y}) i \\<omega>", "then"], ["proof (chain)\npicking this:\n  i \\<le> n\n  ev_at (HLD {y}) i (stl \\<omega>)", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> n\n  ev_at (HLD {y}) i (stl \\<omega>)\n\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>Suc n. ev_at (HLD {y}) i \\<omega>", "by (auto intro!: exI[of _ \"if HLD {y} \\<omega> then 0 else Suc i\"])"], ["proof (state)\nthis:\n  \\<exists>i\\<le>Suc n. ev_at (HLD {y}) i \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       \\<omega> !! 0 = y \\<Longrightarrow>\n       \\<exists>i\\<le>0. ev_at (HLD {y}) i \\<omega>", "qed (simp add: HLD_iff)"], ["proof (state)\nthis:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4\n\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "then"], ["proof (chain)\npicking this:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4", "have \"p x y (Suc n) = (\\<Sum>i\\<le>n. \\<P>(\\<omega> in T x. ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y))\""], ["proof (prove)\nusing this:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4\n\ngoal (1 subgoal):\n 1. p x y (Suc n) =\n    (\\<Sum>i\\<le>n.\n        T.prob x\n         {\\<omega> \\<in> space (T x).\n          ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y})", "unfolding p_def"], ["proof (prove)\nusing this:\n  ?\\<omega>4 !! n = y \\<Longrightarrow>\n  \\<exists>i\\<le>n. ev_at (HLD {y}) i ?\\<omega>4\n\ngoal (1 subgoal):\n 1. T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! Suc n = y} =\n    (\\<Sum>i\\<le>n.\n        T.prob x\n         {\\<omega> \\<in> space (T x).\n          ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y})", "by (intro T.prob_sum) (auto intro: ev_at_unique)"], ["proof (state)\nthis:\n  p x y (Suc n) =\n  (\\<Sum>i\\<le>n.\n      T.prob x\n       {\\<omega> \\<in> space (T x).\n        ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y})\n\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "also"], ["proof (state)\nthis:\n  p x y (Suc n) =\n  (\\<Sum>i\\<le>n.\n      T.prob x\n       {\\<omega> \\<in> space (T x).\n        ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y})\n\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "have \"\\<dots> = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n.\n        T.prob x\n         {\\<omega> \\<in> space (T x).\n          ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y}) =\n    (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..n} \\<Longrightarrow>\n       T.prob x\n        {\\<omega> \\<in> space (T x).\n         ev_at (HLD {y}) xa \\<omega> \\<and> \\<omega> !! n = y} =\n       p y y (n - xa) * u x y xa", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..n} \\<Longrightarrow>\n       T.prob x\n        {\\<omega> \\<in> space (T x).\n         ev_at (HLD {y}) xa \\<omega> \\<and> \\<omega> !! n = y} =\n       p y y (n - xa) * u x y xa", "assume i: \"i \\<in> {.. n}\""], ["proof (state)\nthis:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..n} \\<Longrightarrow>\n       T.prob x\n        {\\<omega> \\<in> space (T x).\n         ev_at (HLD {y}) xa \\<omega> \\<and> \\<omega> !! n = y} =\n       p y y (n - xa) * u x y xa", "then"], ["proof (chain)\npicking this:\n  i \\<in> {..n}", "have \"\\<And>\\<omega>. (Suc i \\<le> n \\<longrightarrow> \\<omega> !! (n - Suc i) = y) \\<longleftrightarrow> ((y ## \\<omega>) !! (n - i) = y)\""], ["proof (prove)\nusing this:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       (Suc i \\<le> n \\<longrightarrow> \\<omega> !! (n - Suc i) = y) =\n       ((y ## \\<omega>) !! (n - i) = y)", "by (auto simp: Stream_snth diff_Suc split: nat.split)"], ["proof (state)\nthis:\n  (Suc i \\<le> n \\<longrightarrow> ?\\<omega>4 !! (n - Suc i) = y) =\n  ((y ## ?\\<omega>4) !! (n - i) = y)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..n} \\<Longrightarrow>\n       T.prob x\n        {\\<omega> \\<in> space (T x).\n         ev_at (HLD {y}) xa \\<omega> \\<and> \\<omega> !! n = y} =\n       p y y (n - xa) * u x y xa", "from i"], ["proof (chain)\npicking this:\n  i \\<in> {..n}", "have \"i \\<le> n\""], ["proof (prove)\nusing this:\n  i \\<in> {..n}\n\ngoal (1 subgoal):\n 1. i \\<le> n", "by auto"], ["proof (state)\nthis:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..n} \\<Longrightarrow>\n       T.prob x\n        {\\<omega> \\<in> space (T x).\n         ev_at (HLD {y}) xa \\<omega> \\<and> \\<omega> !! n = y} =\n       p y y (n - xa) * u x y xa", "then"], ["proof (chain)\npicking this:\n  i \\<le> n", "have \"\\<P>(\\<omega> in T x. ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y) =\n      (\\<integral>\\<omega>'. \\<P>(\\<omega> in T y. (y ## \\<omega>) !! (n - i) = y) *\n        indicator {\\<omega>'\\<in>space (T x). ev_at (HLD {y}) i \\<omega>' } \\<omega>' \\<partial>T x)\""], ["proof (prove)\nusing this:\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. T.prob x\n     {\\<omega> \\<in> space (T x).\n      ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y} =\n    T.expectation x\n     (\\<lambda>\\<omega>'.\n         T.prob y\n          {\\<omega> \\<in> space (T y). (y ## \\<omega>) !! (n - i) = y} *\n         indicat_real\n          {\\<omega>' \\<in> space (T x). ev_at (HLD {y}) i \\<omega>'}\n          \\<omega>')", "by (subst prob_T_split[where n=\"Suc i\"])\n         (auto simp: ev_at_shift ev_at_HLD_single_imp_snth shift_snth diff_Suc\n               split: split_indicator nat.split intro!: Bochner_Integration.integral_cong arg_cong2[where f=measure]\n               simp del: stake.simps integral_mult_right_zero)"], ["proof (state)\nthis:\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y} =\n  T.expectation x\n   (\\<lambda>\\<omega>'.\n       T.prob y\n        {\\<omega> \\<in> space (T y). (y ## \\<omega>) !! (n - i) = y} *\n       indicat_real\n        {\\<omega>' \\<in> space (T x). ev_at (HLD {y}) i \\<omega>'}\n        \\<omega>')\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..n} \\<Longrightarrow>\n       T.prob x\n        {\\<omega> \\<in> space (T x).\n         ev_at (HLD {y}) xa \\<omega> \\<and> \\<omega> !! n = y} =\n       p y y (n - xa) * u x y xa", "then"], ["proof (chain)\npicking this:\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y} =\n  T.expectation x\n   (\\<lambda>\\<omega>'.\n       T.prob y\n        {\\<omega> \\<in> space (T y). (y ## \\<omega>) !! (n - i) = y} *\n       indicat_real\n        {\\<omega>' \\<in> space (T x). ev_at (HLD {y}) i \\<omega>'}\n        \\<omega>')", "show \"\\<P>(\\<omega> in T x. ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y) = p y y (n - i) * u x y i\""], ["proof (prove)\nusing this:\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y} =\n  T.expectation x\n   (\\<lambda>\\<omega>'.\n       T.prob y\n        {\\<omega> \\<in> space (T y). (y ## \\<omega>) !! (n - i) = y} *\n       indicat_real\n        {\\<omega>' \\<in> space (T x). ev_at (HLD {y}) i \\<omega>'}\n        \\<omega>')\n\ngoal (1 subgoal):\n 1. T.prob x\n     {\\<omega> \\<in> space (T x).\n      ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y} =\n    p y y (n - i) * u x y i", "by (simp add: p_def u_def)"], ["proof (state)\nthis:\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y} =\n  p y y (n - i) * u x y i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n.\n      T.prob x\n       {\\<omega> \\<in> space (T x).\n        ev_at (HLD {y}) i \\<omega> \\<and> \\<omega> !! n = y}) =\n  (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)\n\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "finally"], ["proof (chain)\npicking this:\n  p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "show ?thesis"], ["proof (prove)\nusing this:\n  p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)\n\ngoal (1 subgoal):\n 1. p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)", "."], ["proof (state)\nthis:\n  p x y (Suc n) = (\\<Sum>i\\<le>n. p y y (n - i) * u x y i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_eq_sum_p_f: \"p x y n = (\\<Sum>i\\<le>n. p y y (n - i) * f x y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y n = (\\<Sum>i\\<le>n. p y y (n - i) * f x y i)", "by (cases n)\n     (simp_all del: sum.atMost_Suc\n               add: f_0 p_0 p_eq_sum_p_u atMost_Suc_eq_insert_0 zero_notin_Suc_image sum.reindex\n                    f_Suc f_Suc_eq)"], ["", "lemma gf_G_eq_gf_F:\n  assumes z: \"norm z < 1\"\n  shows \"gf_G x y z = gf_F x y z * gf_G y y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "have \"gf_G x y z = (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_G x y z = (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z ^ n)", "by (simp add: gf_G_def p_eq_sum_p_f[of x y] sum_distrib_right)"], ["proof (state)\nthis:\n  gf_G x y z = (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z ^ n)\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "also"], ["proof (state)\nthis:\n  gf_G x y z = (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z ^ n)\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "have \"\\<dots> = (\\<Sum>n. \\<Sum>i\\<le>n. (f x y i * z^i) * (p y y (n - i) * z^(n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z ^ n) =\n    (\\<Sum>n.\n        \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i)))", "by (intro arg_cong[where f=suminf] sum.cong ext atLeast0AtMost[symmetric])\n       (simp_all add: power_add[symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z ^ n) =\n  (\\<Sum>n. \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i)))\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. \\<Sum>i\\<le>n. p y y (n - i) * f x y i * z ^ n) =\n  (\\<Sum>n. \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i)))\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "have \"\\<dots> = (\\<Sum>n. f x y n * z^n) * (\\<Sum>n. p y y n * z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i))) =\n    (\\<Sum>n. f x y n * z ^ n) * (\\<Sum>n. p y y n * z ^ n)", "using convergence_norm_F[OF convergence_G_less_1[OF z]] convergence_norm_G[OF convergence_G_less_1[OF z]]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. f ?x ?y n * norm z ^ n)\n  summable (\\<lambda>n. p ?x ?y n * norm z ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i))) =\n    (\\<Sum>n. f x y n * z ^ n) * (\\<Sum>n. p y y n * z ^ n)", "by (intro Cauchy_product[symmetric]) (auto simp: f_nonneg abs_mult power_abs)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i))) =\n  (\\<Sum>n. f x y n * z ^ n) * (\\<Sum>n. p y y n * z ^ n)\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<Sum>i\\<le>n. f x y i * z ^ i * (p y y (n - i) * z ^ (n - i))) =\n  (\\<Sum>n. f x y n * z ^ n) * (\\<Sum>n. p y y n * z ^ n)\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "have \"\\<dots> = gf_F x y z * gf_G y y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. f x y n * z ^ n) * (\\<Sum>n. p y y n * z ^ n) =\n    gf_F x y z * gf_G y y z", "by (simp add: gf_F_def gf_G_def)"], ["proof (state)\nthis:\n  (\\<Sum>n. f x y n * z ^ n) * (\\<Sum>n. p y y n * z ^ n) =\n  gf_F x y z * gf_G y y z\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "finally"], ["proof (chain)\npicking this:\n  gf_G x y z = gf_F x y z * gf_G y y z", "show ?thesis"], ["proof (prove)\nusing this:\n  gf_G x y z = gf_F x y z * gf_G y y z\n\ngoal (1 subgoal):\n 1. gf_G x y z = gf_F x y z * gf_G y y z", "."], ["proof (state)\nthis:\n  gf_G x y z = gf_F x y z * gf_G y y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_G_eq_gf_U:\n  fixes z :: \"'z :: {banach, real_normed_field}\"\n  assumes z: \"convergence_G x x z\"\n  shows \"gf_G x x z = 1 / (1 - gf_U x x z)\" \"gf_U x x z \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z) &&&\n    gf_U x x z \\<noteq> (1::'z)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "have \"p x x (Suc n) *\\<^sub>R z^Suc n = (\\<Sum>i\\<le>n. (p x x (n - i) * u x x i) *\\<^sub>R z^Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x x (Suc n) *\\<^sub>R z ^ Suc n =\n    (\\<Sum>i\\<le>n. (p x x (n - i) * u x x i) *\\<^sub>R z ^ Suc n)", "unfolding scaleR_sum_left[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p x x (Suc n) *\\<^sub>R z ^ Suc n =\n    (\\<Sum>i\\<le>n. p x x (n - i) * u x x i) *\\<^sub>R z ^ Suc n", "by (simp add: p_eq_sum_p_u)"], ["proof (state)\nthis:\n  p x x (Suc n) *\\<^sub>R z ^ Suc n =\n  (\\<Sum>i\\<le>n. (p x x (n - i) * u x x i) *\\<^sub>R z ^ Suc n)\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "also"], ["proof (state)\nthis:\n  p x x (Suc n) *\\<^sub>R z ^ Suc n =\n  (\\<Sum>i\\<le>n. (p x x (n - i) * u x x i) *\\<^sub>R z ^ Suc n)\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "have \"\\<dots> = (\\<Sum>i\\<le>n. (u x x i *\\<^sub>R z^Suc i) * (p x x (n - i) *\\<^sub>R z^(n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>n. (p x x (n - i) * u x x i) *\\<^sub>R z ^ Suc n) =\n    (\\<Sum>i\\<le>n.\n        u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))", "by (intro sum.cong refl) (simp add: field_simps power_diff cong: disj_cong)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<le>n. (p x x (n - i) * u x x i) *\\<^sub>R z ^ Suc n) =\n  (\\<Sum>i\\<le>n.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "finally"], ["proof (chain)\npicking this:\n  p x x (Suc n) *\\<^sub>R z ^ Suc n =\n  (\\<Sum>i\\<le>n.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))", "have \"p x x (Suc n) *\\<^sub>R z^(Suc n) = (\\<Sum>i\\<le>n. (u x x i *\\<^sub>R z^Suc i) * (p x x (n - i) *\\<^sub>R z^(n - i)))\""], ["proof (prove)\nusing this:\n  p x x (Suc n) *\\<^sub>R z ^ Suc n =\n  (\\<Sum>i\\<le>n.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))\n\ngoal (1 subgoal):\n 1. p x x (Suc n) *\\<^sub>R z ^ Suc n =\n    (\\<Sum>i\\<le>n.\n        u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))", "unfolding atLeast0AtMost"], ["proof (prove)\nusing this:\n  p x x (Suc n) *\\<^sub>R z ^ Suc n =\n  (\\<Sum>i\\<le>n.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))\n\ngoal (1 subgoal):\n 1. p x x (Suc n) *\\<^sub>R z ^ Suc n =\n    (\\<Sum>i\\<le>n.\n        u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))", "."], ["proof (state)\nthis:\n  p x x (Suc n) *\\<^sub>R z ^ Suc n =\n  (\\<Sum>i\\<le>n.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "}"], ["proof (state)\nthis:\n  p x x (Suc ?n6) *\\<^sub>R z ^ Suc ?n6 =\n  (\\<Sum>i\\<le>?n6.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (?n6 - i) *\\<^sub>R z ^ (?n6 - i))\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "note gfs_Suc_eq = this"], ["proof (state)\nthis:\n  p x x (Suc ?n6) *\\<^sub>R z ^ Suc ?n6 =\n  (\\<Sum>i\\<le>?n6.\n      u x x i *\\<^sub>R z ^ Suc i * p x x (?n6 - i) *\\<^sub>R z ^ (?n6 - i))\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "have \"gf_G x x z = 1 + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z^(Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_G x x z = (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n)", "unfolding gf_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. p x x n *\\<^sub>R z ^ n) =\n    (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n)", "by (subst suminf_split_initial_segment[OF convergence_G[OF z], of 1]) simp"], ["proof (state)\nthis:\n  gf_G x x z = (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n)\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "also"], ["proof (state)\nthis:\n  gf_G x x z = (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n)\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "have \"\\<dots> = 1 + (\\<Sum>n. \\<Sum>i\\<le>n. (u x x i *\\<^sub>R z^Suc i) * (p x x (n - i) *\\<^sub>R z^(n - i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n) =\n    (1::'z) +\n    (\\<Sum>n.\n        \\<Sum>i\\<le>n.\n           u x x i *\\<^sub>R z ^ Suc i *\n           p x x (n - i) *\\<^sub>R z ^ (n - i))", "unfolding gfs_Suc_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'z) +\n    (\\<Sum>n.\n        \\<Sum>i\\<le>n.\n           u x x i *\\<^sub>R z ^ Suc i *\n           p x x (n - i) *\\<^sub>R z ^ (n - i)) =\n    (1::'z) +\n    (\\<Sum>n.\n        \\<Sum>i\\<le>n.\n           u x x i *\\<^sub>R z ^ Suc i *\n           p x x (n - i) *\\<^sub>R z ^ (n - i))", ".."], ["proof (state)\nthis:\n  (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n) =\n  (1::'z) +\n  (\\<Sum>n.\n      \\<Sum>i\\<le>n.\n         u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "also"], ["proof (state)\nthis:\n  (1::'z) + (\\<Sum>n. p x x (Suc n) *\\<^sub>R z ^ Suc n) =\n  (1::'z) +\n  (\\<Sum>n.\n      \\<Sum>i\\<le>n.\n         u x x i *\\<^sub>R z ^ Suc i * p x x (n - i) *\\<^sub>R z ^ (n - i))\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "have \"\\<dots> = 1 + gf_U x x z * gf_G x x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'z) +\n    (\\<Sum>n.\n        \\<Sum>i\\<le>n.\n           u x x i *\\<^sub>R z ^ Suc i *\n           p x x (n - i) *\\<^sub>R z ^ (n - i)) =\n    (1::'z) + gf_U x x z * gf_G x x z", "unfolding gf_U_def gf_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'z) +\n    (\\<Sum>n.\n        \\<Sum>i\\<le>n.\n           u x x i *\\<^sub>R z ^ Suc i *\n           p x x (n - i) *\\<^sub>R z ^ (n - i)) =\n    (1::'z) +\n    (\\<Sum>n. u x x n *\\<^sub>R z ^ Suc n) *\n    (\\<Sum>n. p x x n *\\<^sub>R z ^ n)", "by (subst Cauchy_product)\n       (auto simp: u_nonneg norm_power simp del: power_Suc\n             intro!: z convergence_norm_G convergence_norm_U)"], ["proof (state)\nthis:\n  (1::'z) +\n  (\\<Sum>n.\n      \\<Sum>i\\<le>n.\n         u x x i *\\<^sub>R z ^ Suc i *\n         p x x (n - i) *\\<^sub>R z ^ (n - i)) =\n  (1::'z) + gf_U x x z * gf_G x x z\n\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_U x x z \\<noteq> (1::'z)", "finally"], ["proof (chain)\npicking this:\n  gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z", "show \"gf_G x x z = 1 / (1 - gf_U x x z)\" \"gf_U x x z \\<noteq> 1\""], ["proof (prove)\nusing this:\n  gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z\n\ngoal (1 subgoal):\n 1. gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z) &&&\n    gf_U x x z \\<noteq> (1::'z)", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z \\<Longrightarrow>\n    gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z \\<Longrightarrow>\n    gf_U x x z \\<noteq> (1::'z)", "apply (cases \"gf_U x x z = 1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z;\n     gf_U x x z = (1::'z)\\<rbrakk>\n    \\<Longrightarrow> gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 2. \\<lbrakk>gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z;\n     gf_U x x z \\<noteq> (1::'z)\\<rbrakk>\n    \\<Longrightarrow> gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n 3. gf_G x x z = (1::'z) + gf_U x x z * gf_G x x z \\<Longrightarrow>\n    gf_U x x z \\<noteq> (1::'z)", "apply (auto simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gf_G x x z = (1::'z) / ((1::'z) - gf_U x x z)\n  gf_U x x z \\<noteq> (1::'z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_U: \"(gf_U x y \\<longlongrightarrow> U x y) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "have \"((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow> (\\<Sum>n. ennreal (u x y n))) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n     (\\<Sum>n. ennreal (u x y n)))\n     (at_left 1)", "using u_le_1 u_nonneg"], ["proof (prove)\nusing this:\n  u ?x ?y ?n \\<le> 1\n  0 \\<le> u ?x ?y ?n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n     (\\<Sum>n. ennreal (u x y n)))\n     (at_left 1)", "by (intro power_series_tendsto_at_left summable_power_series)"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   (\\<Sum>n. ennreal (u x y n)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   (\\<Sum>n. ennreal (u x y n)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "have \"(\\<Sum>n. ennreal (u x y n)) = ennreal (suminf (u x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (u x y n)) = ennreal (suminf (u x y))", "by (intro u_nonneg suminf_ennreal ennreal_suminf_neq_top sums_summable[OF u_sums_U])"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (u x y n)) = ennreal (suminf (u x y))\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (u x y n)) = ennreal (suminf (u x y))\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "have \"suminf (u x y) = U x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suminf (u x y) = U x y", "using u_sums_U"], ["proof (prove)\nusing this:\n  u ?x ?y sums U ?x ?y\n\ngoal (1 subgoal):\n 1. suminf (u x y) = U x y", "by (rule sums_unique[symmetric])"], ["proof (state)\nthis:\n  suminf (u x y) = U x y\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   ennreal (U x y))\n   (at_left 1)", "have \"((\\<lambda>z. \\<Sum>n. u x y n * z ^ n) \\<longlongrightarrow> U x y) (at_left 1)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. ennreal (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   ennreal (U x y))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. \\<Sum>n. u x y n * z ^ n) \\<longlongrightarrow> U x y)\n     (at_left 1)", "by (rule tendsto_ennrealD)\n       (auto simp: u_nonneg u_le_1 intro!: suminf_nonneg summable_power_series eventually_at_left_1)"], ["proof (state)\nthis:\n  ((\\<lambda>z. \\<Sum>n. u x y n * z ^ n) \\<longlongrightarrow> U x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. \\<Sum>n. u x y n * z ^ n) \\<longlongrightarrow> U x y)\n   (at_left 1)", "have \"((\\<lambda>z. z * (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow> 1 * U x y) (at_left 1)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. \\<Sum>n. u x y n * z ^ n) \\<longlongrightarrow> U x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. z * (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n     1 * U x y)\n     (at_left 1)", "by (intro tendsto_intros) simp"], ["proof (state)\nthis:\n  ((\\<lambda>z. z * (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   1 * U x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. z * (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   1 * U x y)\n   (at_left 1)", "have \"((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) \\<longlongrightarrow> 1 * U x y) (at_left 1)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. z * (\\<Sum>n. u x y n * z ^ n)) \\<longlongrightarrow>\n   1 * U x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) \\<longlongrightarrow>\n     1 * U x y)\n     (at_left 1)", "apply (rule filterlim_cong[OF refl refl, THEN iffD1, rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in at_left 1.\n       xa * (\\<Sum>n. u x y n * xa ^ n) = (\\<Sum>n. u x y n * xa ^ Suc n)", "apply (rule eventually_at_left_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> z * (\\<Sum>n. u x y n * z ^ n) =\n                         (\\<Sum>n. u x y n * z ^ Suc n)", "apply (subst suminf_mult[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> summable (\\<lambda>n. u x y n * z ^ n)\n 2. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>n. z * (u x y n * z ^ n)) =\n                         (\\<Sum>n. u x y n * z ^ Suc n)", "apply (auto intro!: summable_power_series u_le_1 u_nonneg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>n. z * (u x y n * z ^ n)) =\n                         (\\<Sum>n. u x y n * (z * z ^ n))", "apply (simp add: field_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) \\<longlongrightarrow>\n   1 * U x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) \\<longlongrightarrow>\n   1 * U x y)\n   (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) \\<longlongrightarrow>\n   1 * U x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)", "by (simp add: gf_U_def[abs_def] U_def)"], ["proof (state)\nthis:\n  (gf_U x y \\<longlongrightarrow> U x y) (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_U_le_1: assumes z: \"0 < z\" \"z < 1\" shows \"gf_U x y z \\<le> (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "note u = u_sums_U[of x y, THEN sums_summable]"], ["proof (state)\nthis:\n  summable (u x y)\n\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "have \"gf_U x y z \\<le> gf_U x y 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> gf_U x y 1", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> gf_U x y 1", "unfolding gf_U_def real_scaleR_def"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. u x y n * z ^ Suc n) \\<le> (\\<Sum>n. u x y n * 1 ^ Suc n)", "by (intro suminf_le allI mult_mono power_mono summable_comparison_test_ev[OF _ u] always_eventually)\n       (auto simp: u_nonneg intro!: mult_left_le mult_le_one power_le_one)"], ["proof (state)\nthis:\n  gf_U x y z \\<le> gf_U x y 1\n\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "also"], ["proof (state)\nthis:\n  gf_U x y z \\<le> gf_U x y 1\n\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_U x y 1 \\<le> 1", "unfolding gf_U_eq_U"], ["proof (prove)\ngoal (1 subgoal):\n 1. U x y \\<le> 1", "by (rule U_le_1)"], ["proof (state)\nthis:\n  gf_U x y 1 \\<le> 1\n\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  gf_U x y z \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  gf_U x y z \\<le> 1\n\ngoal (1 subgoal):\n 1. gf_U x y z \\<le> 1", "."], ["proof (state)\nthis:\n  gf_U x y z \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_F: \"(gf_F x y \\<longlongrightarrow> F x y) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "have \"((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow> (\\<Sum>n. ennreal (f x y n))) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow>\n     (\\<Sum>n. ennreal (f x y n)))\n     (at_left 1)", "using f_le_1 f_nonneg"], ["proof (prove)\nusing this:\n  f ?x ?y ?n \\<le> 1\n  0 \\<le> f ?x ?y ?n\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow>\n     (\\<Sum>n. ennreal (f x y n)))\n     (at_left 1)", "by (intro power_series_tendsto_at_left summable_power_series)"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow>\n   (\\<Sum>n. ennreal (f x y n)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow>\n   (\\<Sum>n. ennreal (f x y n)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "have \"(\\<Sum>n. ennreal (f x y n)) = ennreal (suminf (f x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. ennreal (f x y n)) = ennreal (suminf (f x y))", "by (intro f_nonneg suminf_ennreal ennreal_suminf_neq_top sums_summable[OF f_sums_F])"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f x y n)) = ennreal (suminf (f x y))\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. ennreal (f x y n)) = ennreal (suminf (f x y))\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "have \"suminf (f x y) = F x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. suminf (f x y) = F x y", "using f_sums_F"], ["proof (prove)\nusing this:\n  f ?x ?y sums F ?x ?y\n\ngoal (1 subgoal):\n 1. suminf (f x y) = F x y", "by (rule sums_unique[symmetric])"], ["proof (state)\nthis:\n  suminf (f x y) = F x y\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow>\n   ennreal (F x y))\n   (at_left 1)", "have \"((\\<lambda>z. \\<Sum>n. f x y n * z ^ n) \\<longlongrightarrow> F x y) (at_left 1)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. ennreal (\\<Sum>n. f x y n * z ^ n)) \\<longlongrightarrow>\n   ennreal (F x y))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. \\<Sum>n. f x y n * z ^ n) \\<longlongrightarrow> F x y)\n     (at_left 1)", "by (rule tendsto_ennrealD)\n       (auto simp: f_nonneg f_le_1 intro!: suminf_nonneg summable_power_series eventually_at_left_1)"], ["proof (state)\nthis:\n  ((\\<lambda>z. \\<Sum>n. f x y n * z ^ n) \\<longlongrightarrow> F x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. \\<Sum>n. f x y n * z ^ n) \\<longlongrightarrow> F x y)\n   (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>z. \\<Sum>n. f x y n * z ^ n) \\<longlongrightarrow> F x y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)", "by (simp add: gf_F_def[abs_def] F_def)"], ["proof (state)\nthis:\n  (gf_F x y \\<longlongrightarrow> F x y) (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma U_bounded: \"0 \\<le> U x y\" \"U x y \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> U x y &&& U x y \\<le> 1", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T.prob x {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>} &&&\n    T.prob x {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>} \\<le> 1", "by simp_all"], ["", "subsection \\<open>Recurrent states\\<close>"], ["", "definition recurrent :: \"'s \\<Rightarrow> bool\" where\n  \"recurrent s \\<longleftrightarrow> (AE \\<omega> in T s. ev (HLD {s}) \\<omega>)\""], ["", "lemma recurrent_iff_U_eq_1: \"recurrent s \\<longleftrightarrow> U s s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurrent s = (U s s = 1)", "unfolding recurrent_def U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (ev (HLD {s})) =\n    (T.prob s {\\<omega> \\<in> space (T s). ev (HLD {s}) \\<omega>} = 1)", "by (subst T.prob_Collect_eq_1) simp_all"], ["", "definition \"H s t = \\<P>(\\<omega> in T s. alw (ev (HLD {t})) \\<omega>)\""], ["", "lemma H_eq:\n  \"recurrent s \\<longleftrightarrow> H s s = 1\"\n  \"\\<not> recurrent s \\<longleftrightarrow> H s s = 0\"\n  \"H s t = U s t * H t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurrent s = (H s s = 1) &&&\n    (\\<not> recurrent s) = (H s s = 0) &&& H s t = U s t * H t t", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "define H' where \"H' t n = {\\<omega>\\<in>space S. enat n \\<le> scount (HLD {t::'s}) \\<omega>}\" for t n"], ["proof (state)\nthis:\n  H' ?t ?n =\n  {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n   enat ?n \\<le> scount (HLD {?t}) \\<omega>}\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have [measurable]: \"\\<And>y n. H' y n \\<in> sets S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y n. H' y n \\<in> sets (stream_space (count_space UNIV))", "by (simp add: H'_def)"], ["proof (state)\nthis:\n  H' ?y4 ?n4 \\<in> sets (stream_space (count_space UNIV))\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "let ?H' = \"\\<lambda>s t n. measure (T s) (H' t n)\""], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "fix x y :: 's and \\<omega>"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"Suc 0 \\<le> scount (HLD {y}) \\<omega> \\<longleftrightarrow> ev (HLD {y}) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat (Suc 0) \\<le> scount (HLD {y}) \\<omega>) = ev (HLD {y}) \\<omega>", "using scount_eq_0_iff[of \"HLD {y}\" \\<omega>]"], ["proof (prove)\nusing this:\n  (scount (HLD {y}) \\<omega> = 0) =\n  alw (\\<lambda>xs. \\<not> HLD {y} xs) \\<omega>\n\ngoal (1 subgoal):\n 1. (enat (Suc 0) \\<le> scount (HLD {y}) \\<omega>) = ev (HLD {y}) \\<omega>", "by (cases \"scount (HLD {y}) \\<omega>\" rule: enat_coexhaust)\n         (auto simp: not_ev_iff[symmetric] eSuc_enat[symmetric] enat_0 HLD_iff[abs_def])"], ["proof (state)\nthis:\n  (enat (Suc 0) \\<le> scount (HLD {y}) \\<omega>) = ev (HLD {y}) \\<omega>\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "}"], ["proof (state)\nthis:\n  (enat (Suc 0) \\<le> scount (HLD {?y6}) ?\\<omega>6) =\n  ev (HLD {?y6}) ?\\<omega>6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "then"], ["proof (chain)\npicking this:\n  (enat (Suc 0) \\<le> scount (HLD {?y6}) ?\\<omega>6) =\n  ev (HLD {?y6}) ?\\<omega>6", "have H'_1: \"\\<And>x y. ?H' x y 1 = U x y\""], ["proof (prove)\nusing this:\n  (enat (Suc 0) \\<le> scount (HLD {?y6}) ?\\<omega>6) =\n  ev (HLD {?y6}) ?\\<omega>6\n\ngoal (1 subgoal):\n 1. \\<And>x y. T.prob x (H' y 1) = U x y", "unfolding H'_def U_def"], ["proof (prove)\nusing this:\n  (enat (Suc 0) \\<le> scount (HLD {?y6}) ?\\<omega>6) =\n  ev (HLD {?y6}) ?\\<omega>6\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       T.prob x\n        {\\<omega> \\<in> space (stream_space (count_space UNIV)).\n         enat 1 \\<le> scount (HLD {y}) \\<omega>} =\n       T.prob x {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>}", "by simp"], ["proof (state)\nthis:\n  T.prob ?x4 (H' ?y4 1) = U ?x4 ?y4\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "{"], ["proof (state)\nthis:\n  T.prob ?x4 (H' ?y4 1) = U ?x4 ?y4\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "fix n and x y :: 's"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "let ?U = \"(not (HLD {y}) suntil (HLD {y} aand nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "fix \\<omega>"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"enat (Suc n) \\<le> scount (HLD {y}) \\<omega> \\<longleftrightarrow> ?U \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (enat (Suc n) \\<le> scount (HLD {y}) \\<omega>) =\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. enat (Suc n) \\<le> scount (HLD {y}) \\<omega> \\<Longrightarrow>\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>\n 2. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega> \\<Longrightarrow>\n    enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "assume \"enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\""], ["proof (state)\nthis:\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\n\ngoal (2 subgoals):\n 1. enat (Suc n) \\<le> scount (HLD {y}) \\<omega> \\<Longrightarrow>\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>\n 2. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega> \\<Longrightarrow>\n    enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "with scount_eq_0_iff[of \"HLD {y}\" \\<omega>]"], ["proof (chain)\npicking this:\n  (scount (HLD {y}) \\<omega> = 0) =\n  alw (\\<lambda>xs. \\<not> HLD {y} xs) \\<omega>\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "have \"ev (HLD {y}) \\<omega>\" \"enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\""], ["proof (prove)\nusing this:\n  (scount (HLD {y}) \\<omega> = 0) =\n  alw (\\<lambda>xs. \\<not> HLD {y} xs) \\<omega>\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\n\ngoal (1 subgoal):\n 1. ev (HLD {y}) \\<omega> &&& enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "by (auto simp add: not_ev_iff[symmetric] eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  ev (HLD {y}) \\<omega>\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\n\ngoal (2 subgoals):\n 1. enat (Suc n) \\<le> scount (HLD {y}) \\<omega> \\<Longrightarrow>\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>\n 2. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega> \\<Longrightarrow>\n    enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "then"], ["proof (chain)\npicking this:\n  ev (HLD {y}) \\<omega>\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "show \"?U \\<omega>\""], ["proof (prove)\nusing this:\n  ev (HLD {y}) \\<omega>\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>", "by (induction rule: ev_induct_strong)\n             (auto simp: scount_simps eSuc_enat[symmetric] intro: suntil.intros)"], ["proof (state)\nthis:\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega> \\<Longrightarrow>\n    enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega> \\<Longrightarrow>\n    enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "assume \"?U \\<omega>\""], ["proof (state)\nthis:\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega> \\<Longrightarrow>\n    enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   \\<omega>", "show \"enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\""], ["proof (prove)\nusing this:\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   \\<omega>\n\ngoal (1 subgoal):\n 1. enat (Suc n) \\<le> scount (HLD {y}) \\<omega>", "by induction (auto simp: scount_simps  eSuc_enat[symmetric])"], ["proof (state)\nthis:\n  enat (Suc n) \\<le> scount (HLD {y}) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (enat (Suc n) \\<le> scount (HLD {y}) \\<omega>) =\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   \\<omega>\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "}"], ["proof (state)\nthis:\n  (enat (Suc n) \\<le> scount (HLD {y}) ?\\<omega>6) =\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   ?\\<omega>6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "then"], ["proof (chain)\npicking this:\n  (enat (Suc n) \\<le> scount (HLD {y}) ?\\<omega>6) =\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   ?\\<omega>6", "have \"emeasure (T x) (H' y (Suc n)) = emeasure (T x) {\\<omega>\\<in>space (T x). ?U \\<omega>}\""], ["proof (prove)\nusing this:\n  (enat (Suc n) \\<le> scount (HLD {y}) ?\\<omega>6) =\n  ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n   (\\<lambda>xs.\n       HLD {y} xs \\<and>\n       nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>) xs))\n   ?\\<omega>6\n\ngoal (1 subgoal):\n 1. emeasure (T x) (H' y (Suc n)) =\n    emeasure (T x)\n     {\\<omega> \\<in> space (T x).\n      ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n       (\\<lambda>xs.\n           HLD {y} xs \\<and>\n           nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n            xs))\n       \\<omega>}", "by (simp add: H'_def)"], ["proof (state)\nthis:\n  emeasure (T x) (H' y (Suc n)) =\n  emeasure (T x)\n   {\\<omega> \\<in> space (T x).\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>}\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "also"], ["proof (state)\nthis:\n  emeasure (T x) (H' y (Suc n)) =\n  emeasure (T x)\n   {\\<omega> \\<in> space (T x).\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>}\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"\\<dots> = U x y * ?H' y y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (T x)\n     {\\<omega> \\<in> space (T x).\n      ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n       (\\<lambda>xs.\n           HLD {y} xs \\<and>\n           nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n            xs))\n       \\<omega>} =\n    ennreal (U x y * T.prob y (H' y n))", "by (subst emeasure_suntil_HLD) (simp_all add: T.emeasure_eq_measure U_def H'_def ennreal_mult)"], ["proof (state)\nthis:\n  emeasure (T x)\n   {\\<omega> \\<in> space (T x).\n    ((\\<lambda>xs. \\<not> HLD {y} xs) suntil\n     (\\<lambda>xs.\n         HLD {y} xs \\<and>\n         nxt (\\<lambda>\\<omega>. enat n \\<le> scount (HLD {y}) \\<omega>)\n          xs))\n     \\<omega>} =\n  ennreal (U x y * T.prob y (H' y n))\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "finally"], ["proof (chain)\npicking this:\n  emeasure (T x) (H' y (Suc n)) = ennreal (U x y * T.prob y (H' y n))", "have \"?H' x y (Suc n) = U x y * ?H' y y n\""], ["proof (prove)\nusing this:\n  emeasure (T x) (H' y (Suc n)) = ennreal (U x y * T.prob y (H' y n))\n\ngoal (1 subgoal):\n 1. T.prob x (H' y (Suc n)) = U x y * T.prob y (H' y n)", "by (simp add: T.emeasure_eq_measure)"], ["proof (state)\nthis:\n  T.prob x (H' y (Suc n)) = U x y * T.prob y (H' y n)\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "}"], ["proof (state)\nthis:\n  T.prob ?x6 (H' ?y6 (Suc ?n6)) = U ?x6 ?y6 * T.prob ?y6 (H' ?y6 ?n6)\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "note H'_Suc = this"], ["proof (state)\nthis:\n  T.prob ?x6 (H' ?y6 (Suc ?n6)) = U ?x6 ?y6 * T.prob ?y6 (H' ?y6 ?n6)\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "{"], ["proof (state)\nthis:\n  T.prob ?x6 (H' ?y6 (Suc ?n6)) = U ?x6 ?y6 * T.prob ?y6 (H' ?y6 ?n6)\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "fix m and x :: 's"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"?H' x x (Suc m) = U x x^Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x (H' x (Suc m)) = U x x ^ Suc m", "using H'_1 H'_Suc"], ["proof (prove)\nusing this:\n  T.prob ?x4 (H' ?y4 1) = U ?x4 ?y4\n  T.prob ?x6 (H' ?y6 (Suc ?n6)) = U ?x6 ?y6 * T.prob ?y6 (H' ?y6 ?n6)\n\ngoal (1 subgoal):\n 1. T.prob x (H' x (Suc m)) = U x x ^ Suc m", "by (induct m) auto"], ["proof (state)\nthis:\n  T.prob x (H' x (Suc m)) = U x x ^ Suc m\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "}"], ["proof (state)\nthis:\n  T.prob ?x6 (H' ?x6 (Suc ?m6)) = U ?x6 ?x6 ^ Suc ?m6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "note H'_eq = this"], ["proof (state)\nthis:\n  T.prob ?x6 (H' ?x6 (Suc ?m6)) = U ?x6 ?x6 ^ Suc ?m6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "{"], ["proof (state)\nthis:\n  T.prob ?x6 (H' ?x6 (Suc ?m6)) = U ?x6 ?x6 ^ Suc ?m6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "fix x y"], ["proof (state)\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"?H' x y \\<longlonglongrightarrow> measure (T x) (\\<Inter>i. H' y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. T.prob x (H' y n))\n    \\<longlonglongrightarrow> T.prob x (\\<Inter> (range (H' y)))", "apply (rule T.finite_Lim_measure_decseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. range (H' y) \\<subseteq> T.events x\n 2. decseq (H' y)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa n. n \\<in> UNIV \\<Longrightarrow> H' y n \\<in> T.events x\n 2. decseq (H' y)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. decseq (H' y)", "apply (auto simp add: decseq_Suc_iff subset_eq H'_def eSuc_enat[symmetric]\n                  intro: ile_eSuc order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>n. T.prob x (H' y n))\n  \\<longlonglongrightarrow> T.prob x (\\<Inter> (range (H' y)))\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. T.prob x (H' y n))\n  \\<longlonglongrightarrow> T.prob x (\\<Inter> (range (H' y)))\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"(\\<Inter>i. H' y i) = {\\<omega>\\<in>space (T x). alw (ev (HLD {y})) \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Inter> (range (H' y)) =\n    {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>}", "by (auto simp: H'_def scount_infinite_iff[symmetric]) (metis Suc_ile_eq enat.exhaust neq_iff)"], ["proof (state)\nthis:\n  \\<Inter> (range (H' y)) =\n  {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>}\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. T.prob x (H' y n))\n  \\<longlonglongrightarrow> T.prob x\n                             {\\<omega> \\<in> space (T x).\n                              alw (ev (HLD {y})) \\<omega>}", "have \"?H' x y \\<longlonglongrightarrow> H x y\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. T.prob x (H' y n))\n  \\<longlonglongrightarrow> T.prob x\n                             {\\<omega> \\<in> space (T x).\n                              alw (ev (HLD {y})) \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. T.prob x (H' y n)) \\<longlonglongrightarrow> H x y", "unfolding H_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. T.prob x (H' y n))\n  \\<longlonglongrightarrow> T.prob x\n                             {\\<omega> \\<in> space (T x).\n                              alw (ev (HLD {y})) \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. T.prob x (H' y n))\n    \\<longlonglongrightarrow> T.prob x\n                               {\\<omega> \\<in> space (T x).\n                                alw (ev (HLD {y})) \\<omega>}", "."], ["proof (state)\nthis:\n  (\\<lambda>n. T.prob x (H' y n)) \\<longlonglongrightarrow> H x y\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "}"], ["proof (state)\nthis:\n  (\\<lambda>n. T.prob ?x6 (H' ?y6 n)) \\<longlonglongrightarrow> H ?x6 ?y6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "note H'_lim = this"], ["proof (state)\nthis:\n  (\\<lambda>n. T.prob ?x6 (H' ?y6 n)) \\<longlonglongrightarrow> H ?x6 ?y6\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "from H'_lim[of s s, THEN LIMSEQ_Suc]"], ["proof (chain)\npicking this:\n  (\\<lambda>n. T.prob s (H' s (Suc n))) \\<longlonglongrightarrow> H s s", "have \"(\\<lambda>n. U s s ^ Suc n) \\<longlonglongrightarrow> H s s\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. T.prob s (H' s (Suc n))) \\<longlonglongrightarrow> H s s\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. U s s ^ Suc n) \\<longlonglongrightarrow> H s s", "by (simp add: H'_eq)"], ["proof (state)\nthis:\n  (\\<lambda>n. U s s ^ Suc n) \\<longlonglongrightarrow> H s s\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. U s s ^ Suc n) \\<longlonglongrightarrow> H s s", "have lim_H: \"(\\<lambda>n. U s s ^ n) \\<longlonglongrightarrow> H s s\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. U s s ^ Suc n) \\<longlonglongrightarrow> H s s\n\ngoal (1 subgoal):\n 1. (^) (U s s) \\<longlonglongrightarrow> H s s", "by (rule LIMSEQ_imp_Suc)"], ["proof (state)\nthis:\n  (^) (U s s) \\<longlonglongrightarrow> H s s\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"U s s < 1 \\<Longrightarrow> (\\<lambda>n. U s s ^ n) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U s s < 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 0", "by (rule LIMSEQ_realpow_zero) (simp_all add: U_def)"], ["proof (state)\nthis:\n  U s s < 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 0\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "with lim_H"], ["proof (chain)\npicking this:\n  (^) (U s s) \\<longlonglongrightarrow> H s s\n  U s s < 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 0", "have \"U s s < 1 \\<Longrightarrow> H s s = 0\""], ["proof (prove)\nusing this:\n  (^) (U s s) \\<longlonglongrightarrow> H s s\n  U s s < 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. U s s < 1 \\<Longrightarrow> H s s = 0", "by (blast intro: LIMSEQ_unique)"], ["proof (state)\nthis:\n  U s s < 1 \\<Longrightarrow> H s s = 0\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "moreover"], ["proof (state)\nthis:\n  U s s < 1 \\<Longrightarrow> H s s = 0\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "have \"U s s = 1 \\<Longrightarrow> (\\<lambda>n. U s s ^ n) \\<longlonglongrightarrow> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U s s = 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 1", "by simp"], ["proof (state)\nthis:\n  U s s = 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 1\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "with lim_H"], ["proof (chain)\npicking this:\n  (^) (U s s) \\<longlonglongrightarrow> H s s\n  U s s = 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 1", "have \"U s s = 1 \\<Longrightarrow> H s s = 1\""], ["proof (prove)\nusing this:\n  (^) (U s s) \\<longlonglongrightarrow> H s s\n  U s s = 1 \\<Longrightarrow> (^) (U s s) \\<longlonglongrightarrow> 1\n\ngoal (1 subgoal):\n 1. U s s = 1 \\<Longrightarrow> H s s = 1", "by (blast intro: LIMSEQ_unique)"], ["proof (state)\nthis:\n  U s s = 1 \\<Longrightarrow> H s s = 1\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "moreover"], ["proof (state)\nthis:\n  U s s = 1 \\<Longrightarrow> H s s = 1\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "note recurrent_iff_U_eq_1 U_cases"], ["proof (state)\nthis:\n  recurrent ?s = (U ?s ?s = 1)\n  U ?s ?s = 1 \\<or> U ?s ?s < 1\n\ngoal (3 subgoals):\n 1. recurrent s = (H s s = 1)\n 2. (\\<not> recurrent s) = (H s s = 0)\n 3. H s t = U s t * H t t", "ultimately"], ["proof (chain)\npicking this:\n  U s s < 1 \\<Longrightarrow> H s s = 0\n  U s s = 1 \\<Longrightarrow> H s s = 1\n  recurrent ?s = (U ?s ?s = 1)\n  U ?s ?s = 1 \\<or> U ?s ?s < 1", "show \"recurrent s \\<longleftrightarrow> H s s = 1\" \"\\<not> recurrent s \\<longleftrightarrow> H s s = 0\""], ["proof (prove)\nusing this:\n  U s s < 1 \\<Longrightarrow> H s s = 0\n  U s s = 1 \\<Longrightarrow> H s s = 1\n  recurrent ?s = (U ?s ?s = 1)\n  U ?s ?s = 1 \\<or> U ?s ?s < 1\n\ngoal (1 subgoal):\n 1. recurrent s = (H s s = 1) &&& (\\<not> recurrent s) = (H s s = 0)", "by (metis one_neq_zero)+"], ["proof (state)\nthis:\n  recurrent s = (H s s = 1)\n  (\\<not> recurrent s) = (H s s = 0)\n\ngoal (1 subgoal):\n 1. H s t = U s t * H t t", "from H'_lim[of s t, THEN LIMSEQ_Suc] H'_Suc[of s]"], ["proof (chain)\npicking this:\n  (\\<lambda>n. T.prob s (H' t (Suc n))) \\<longlonglongrightarrow> H s t\n  T.prob s (H' ?y6 (Suc ?n6)) = U s ?y6 * T.prob ?y6 (H' ?y6 ?n6)", "have \"(\\<lambda>n. U s t * ?H' t t n) \\<longlonglongrightarrow> H s t\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. T.prob s (H' t (Suc n))) \\<longlonglongrightarrow> H s t\n  T.prob s (H' ?y6 (Suc ?n6)) = U s ?y6 * T.prob ?y6 (H' ?y6 ?n6)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. U s t * T.prob t (H' t n)) \\<longlonglongrightarrow> H s t", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. U s t * T.prob t (H' t n)) \\<longlonglongrightarrow> H s t\n\ngoal (1 subgoal):\n 1. H s t = U s t * H t t", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. U s t * T.prob t (H' t n)) \\<longlonglongrightarrow> H s t\n\ngoal (1 subgoal):\n 1. H s t = U s t * H t t", "have \"(\\<lambda>n. U s t * ?H' t t n) \\<longlonglongrightarrow> U s t * H t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. U s t * T.prob t (H' t n))\n    \\<longlonglongrightarrow> U s t * H t t", "by (intro tendsto_intros H'_lim)"], ["proof (state)\nthis:\n  (\\<lambda>n. U s t * T.prob t (H' t n))\n  \\<longlonglongrightarrow> U s t * H t t\n\ngoal (1 subgoal):\n 1. H s t = U s t * H t t", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. U s t * T.prob t (H' t n)) \\<longlonglongrightarrow> H s t\n  (\\<lambda>n. U s t * T.prob t (H' t n))\n  \\<longlonglongrightarrow> U s t * H t t", "show \"H s t = U s t * H t t\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. U s t * T.prob t (H' t n)) \\<longlonglongrightarrow> H s t\n  (\\<lambda>n. U s t * T.prob t (H' t n))\n  \\<longlonglongrightarrow> U s t * H t t\n\ngoal (1 subgoal):\n 1. H s t = U s t * H t t", "by (blast intro: LIMSEQ_unique)"], ["proof (state)\nthis:\n  H s t = U s t * H t t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma recurrent_iff_G_infinite: \"recurrent x \\<longleftrightarrow> G x x = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "have \"((\\<lambda>z. ennreal (gf_G x x z)) \\<longlongrightarrow> G x x) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (gf_G x x z)) \\<longlongrightarrow> G x x)\n     (at_left 1)", "by (rule lim_gf_G)"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (gf_G x x z)) \\<longlongrightarrow> G x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. ennreal (gf_G x x z)) \\<longlongrightarrow> G x x)\n   (at_left 1)", "have G: \"((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow> G x x) (at_left (1::real))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. ennreal (gf_G x x z)) \\<longlongrightarrow> G x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow>\n     G x x)\n     (at_left 1)", "apply (rule filterlim_cong[OF refl refl, THEN iffD1, rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F xa in at_left 1.\n       ennreal (gf_G x x xa) = ennreal (1 / (1 - gf_U x x xa))", "apply (rule eventually_at_left_1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (gf_G x x z) =\n                         ennreal (1 / (1 - gf_U x x z))", "apply (subst gf_G_eq_gf_U)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk> \\<Longrightarrow> convergence_G x x z\n 2. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (1 / (1 - gf_U x x z)) =\n                         ennreal (1 / (1 - gf_U x x z))", "apply (rule convergence_G_less_1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z. \\<lbrakk>0 < z; z < 1\\<rbrakk> \\<Longrightarrow> norm z < 1\n 2. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (1 / (1 - gf_U x x z)) =\n                         ennreal (1 / (1 - gf_U x x z))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> ennreal (1 / (1 - gf_U x x z)) =\n                         ennreal (1 / (1 - gf_U x x z))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow> G x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "{"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow> G x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "fix z :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "assume z: \"0 < z\" \"z < 1\""], ["proof (state)\nthis:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "have 1: \"summable (u x x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (u x x)", "using u_sums_U"], ["proof (prove)\nusing this:\n  u ?x ?y sums U ?x ?y\n\ngoal (1 subgoal):\n 1. summable (u x x)", "by (rule sums_summable)"], ["proof (state)\nthis:\n  summable (u x x)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "have \"gf_U x x z \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_U x x z \\<noteq> 1", "using gf_G_eq_gf_U[OF convergence_G_less_1[of z]] z"], ["proof (prove)\nusing this:\n  norm z < 1 \\<Longrightarrow> gf_G ?x ?x z = 1 / (1 - gf_U ?x ?x z)\n  norm z < 1 \\<Longrightarrow> gf_U ?x ?x z \\<noteq> 1\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. gf_U x x z \\<noteq> 1", "by simp"], ["proof (state)\nthis:\n  gf_U x x z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  gf_U x x z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "have \"gf_U x x z \\<le> U x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_U x x z \\<le> U x x", "unfolding gf_U_def gf_U_eq_U[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. u x x n *\\<^sub>R z ^ Suc n)\n    \\<le> (\\<Sum>n. u x x n *\\<^sub>R 1 ^ Suc n)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. u x x n *\\<^sub>R z ^ Suc n)\n    \\<le> (\\<Sum>n. u x x n *\\<^sub>R 1 ^ Suc n)", "by (intro suminf_le)\n         (auto simp add: 1 convergence_U convergence_G_less_1 u_nonneg simp del: power_Suc\n               intro!: mult_right_le_one_le power_le_one)"], ["proof (state)\nthis:\n  gf_U x x z \\<le> U x x\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  gf_U x x z \\<noteq> 1\n  gf_U x x z \\<le> U x x", "have \"gf_U x x z < 1\""], ["proof (prove)\nusing this:\n  gf_U x x z \\<noteq> 1\n  gf_U x x z \\<le> U x x\n\ngoal (1 subgoal):\n 1. gf_U x x z < 1", "using U_bounded[of x x]"], ["proof (prove)\nusing this:\n  gf_U x x z \\<noteq> 1\n  gf_U x x z \\<le> U x x\n  0 \\<le> U x x\n  U x x \\<le> 1\n\ngoal (1 subgoal):\n 1. gf_U x x z < 1", "by simp"], ["proof (state)\nthis:\n  gf_U x x z < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?z6; ?z6 < 1\\<rbrakk> \\<Longrightarrow> gf_U x x ?z6 < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "note strict = this"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?z6; ?z6 < 1\\<rbrakk> \\<Longrightarrow> gf_U x x ?z6 < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?z6; ?z6 < 1\\<rbrakk> \\<Longrightarrow> gf_U x x ?z6 < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "assume \"U x x = 1\""], ["proof (state)\nthis:\n  U x x = 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  U x x = 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "have \"((\\<lambda>xa. 1 - gf_U x x xa :: real) \\<longlongrightarrow> 1 - U x x) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 1 - U x x)\n     (at_left 1)", "by (intro tendsto_intros gf_U)"], ["proof (state)\nthis:\n  ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 1 - U x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 1 - U x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "have \"eventually (\\<lambda>z. gf_U x x z < 1) (at_left (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1. gf_U x x z < 1", "by (auto intro!: eventually_at_left_1 strict simp: \\<open>U x x = 1\\<close> gf_U_eq_U)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_left 1. gf_U x x z < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  U x x = 1\n  ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 1 - U x x)\n   (at_left 1)\n  \\<forall>\\<^sub>F z in at_left 1. gf_U x x z < 1", "have \"((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow> top) (at_left 1)\""], ["proof (prove)\nusing this:\n  U x x = 1\n  ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 1 - U x x)\n   (at_left 1)\n  \\<forall>\\<^sub>F z in at_left 1. gf_U x x z < 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow>\n     \\<top>)\n     (at_left 1)", "unfolding ennreal_tendsto_top_eq_at_top"], ["proof (prove)\nusing this:\n  U x x = 1\n  ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 1 - U x x)\n   (at_left 1)\n  \\<forall>\\<^sub>F z in at_left 1. gf_U x x z < 1\n\ngoal (1 subgoal):\n 1. LIM z at_left 1. 1 / (1 - gf_U x x z) :> at_top", "by (intro LIM_at_top_divide[where a=1] tendsto_const zero_less_one)\n         (auto simp: field_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow>\n   \\<top>)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "with G"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow> G x x)\n   (at_left 1)\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow>\n   \\<top>)\n   (at_left 1)", "have \"G x x = top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow> G x x)\n   (at_left 1)\n  ((\\<lambda>z. ennreal (1 / (1 - gf_U x x z))) \\<longlongrightarrow>\n   \\<top>)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. G x x = \\<top>", "by (rule tendsto_unique[rotated]) simp"], ["proof (state)\nthis:\n  G x x = \\<top>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "}"], ["proof (state)\nthis:\n  U x x = 1 \\<Longrightarrow> G x x = \\<top>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "moreover"], ["proof (state)\nthis:\n  U x x = 1 \\<Longrightarrow> G x x = \\<top>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "{"], ["proof (state)\nthis:\n  U x x = 1 \\<Longrightarrow> G x x = \\<top>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "assume \"U x x < 1\""], ["proof (state)\nthis:\n  U x x < 1\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  U x x < 1", "have \"((\\<lambda>xa. ennreal (1 / (1 - gf_U x x xa))) \\<longlongrightarrow> 1 / (1 - U x x)) (at_left 1)\""], ["proof (prove)\nusing this:\n  U x x < 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xa. ennreal (1 / (1 - gf_U x x xa))) \\<longlongrightarrow>\n     ennreal (1 / (1 - U x x)))\n     (at_left 1)", "by (intro tendsto_intros gf_U tendsto_ennrealI) simp"], ["proof (state)\nthis:\n  ((\\<lambda>xa. ennreal (1 / (1 - gf_U x x xa))) \\<longlongrightarrow>\n   ennreal (1 / (1 - U x x)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "from tendsto_unique[OF _ G this]"], ["proof (chain)\npicking this:\n  at_left 1 \\<noteq> \\<bottom> \\<Longrightarrow>\n  G x x = ennreal (1 / (1 - U x x))", "have \"G x x \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  at_left 1 \\<noteq> \\<bottom> \\<Longrightarrow>\n  G x x = ennreal (1 / (1 - U x x))\n\ngoal (1 subgoal):\n 1. G x x \\<noteq> \\<infinity>", "by simp"], ["proof (state)\nthis:\n  G x x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "}"], ["proof (state)\nthis:\n  U x x < 1 \\<Longrightarrow> G x x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "ultimately"], ["proof (chain)\npicking this:\n  U x x = 1 \\<Longrightarrow> G x x = \\<top>\n  U x x < 1 \\<Longrightarrow> G x x \\<noteq> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  U x x = 1 \\<Longrightarrow> G x x = \\<top>\n  U x x < 1 \\<Longrightarrow> G x x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "using U_cases recurrent_iff_U_eq_1"], ["proof (prove)\nusing this:\n  U x x = 1 \\<Longrightarrow> G x x = \\<top>\n  U x x < 1 \\<Longrightarrow> G x x \\<noteq> \\<infinity>\n  U ?s ?s = 1 \\<or> U ?s ?s < 1\n  recurrent ?s = (U ?s ?s = 1)\n\ngoal (1 subgoal):\n 1. recurrent x = (G x x = \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  recurrent x = (G x x = \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition communicating :: \"('s \\<times> 's) set\" where\n  \"communicating = acc \\<inter> acc\\<inverse>\""], ["", "definition essential_class :: \"'s set \\<Rightarrow> bool\" where\n  \"essential_class C \\<longleftrightarrow> C \\<in> UNIV // communicating \\<and> acc `` C \\<subseteq> C\""], ["", "lemma accI_U:\n  assumes \"0 < U x y\" shows \"(x, y) \\<in> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> acc", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "assume *: \"(x, y) \\<notin> acc\""], ["proof (state)\nthis:\n  (x, y) \\<notin> acc\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  (x, y) \\<notin> acc\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "assume \"ev (HLD {y}) \\<omega>\" \"alw (HLD (acc `` {x})) \\<omega>\""], ["proof (state)\nthis:\n  ev (HLD {y}) \\<omega>\n  alw (HLD (acc `` {x})) \\<omega>\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "from this *"], ["proof (chain)\npicking this:\n  ev (HLD {y}) \\<omega>\n  alw (HLD (acc `` {x})) \\<omega>\n  (x, y) \\<notin> acc", "have False"], ["proof (prove)\nusing this:\n  ev (HLD {y}) \\<omega>\n  alw (HLD (acc `` {x})) \\<omega>\n  (x, y) \\<notin> acc\n\ngoal (1 subgoal):\n 1. False", "by induction (auto simp: HLD_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ev (HLD {y}) ?\\<omega>6;\n   alw (HLD (acc `` {x})) ?\\<omega>6\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "with AE_T_reachable[of x]"], ["proof (chain)\npicking this:\n  almost_everywhere (T x) (alw (HLD (acc `` {x})))\n  \\<lbrakk>ev (HLD {y}) ?\\<omega>6;\n   alw (HLD (acc `` {x})) ?\\<omega>6\\<rbrakk>\n  \\<Longrightarrow> False", "have \"U x y = 0\""], ["proof (prove)\nusing this:\n  almost_everywhere (T x) (alw (HLD (acc `` {x})))\n  \\<lbrakk>ev (HLD {y}) ?\\<omega>6;\n   alw (HLD (acc `` {x})) ?\\<omega>6\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. U x y = 0", "unfolding U_def"], ["proof (prove)\nusing this:\n  almost_everywhere (T x) (alw (HLD (acc `` {x})))\n  \\<lbrakk>ev (HLD {y}) ?\\<omega>6;\n   alw (HLD (acc `` {x})) ?\\<omega>6\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. T.prob x {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>} = 0", "by (intro T.prob_eq_0_AE) auto"], ["proof (state)\nthis:\n  U x y = 0\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> acc \\<Longrightarrow> False", "with \\<open>0 < U x y\\<close>"], ["proof (chain)\npicking this:\n  0 < U x y\n  U x y = 0", "show False"], ["proof (prove)\nusing this:\n  0 < U x y\n  U x y = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma accD_pos:\n  assumes \"(x, y) \\<in> acc\"\n  shows \"\\<exists>n. 0 < p x y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. 0 < p x y n", "using assms"], ["proof (prove)\nusing this:\n  (x, y) \\<in> acc\n\ngoal (1 subgoal):\n 1. \\<exists>n. 0 < p x y n", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>n. 0 < p x x n\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>n. 0 < p x x n\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "with T.prob_space[of x]"], ["proof (chain)\npicking this:\n  T.prob x (space (T x)) = 1", "show ?case"], ["proof (prove)\nusing this:\n  T.prob x (space (T x)) = 1\n\ngoal (1 subgoal):\n 1. \\<exists>n. 0 < p x x n", "by (auto intro!: exI[of _ 0])"], ["proof (state)\nthis:\n  \\<exists>n. 0 < p x x n\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "have [simp]: \"\\<And>x y. (if x = y then 1 else 0::real) = indicator {y} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (if x = y then 1 else 0) = indicat_real {y} x", "by simp"], ["proof (state)\nthis:\n  (if ?x4 = ?y4 then 1 else 0) = indicat_real {?y4} ?x4\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "case (step w y)"], ["proof (state)\nthis:\n  (x, w) \\<in> acc\n  (w, y) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  \\<exists>n. 0 < p x w n\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "then"], ["proof (chain)\npicking this:\n  (x, w) \\<in> acc\n  (w, y) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  \\<exists>n. 0 < p x w n", "obtain n where \"0 < p x w n\" and \"0 < pmf (K w) y\""], ["proof (prove)\nusing this:\n  (x, w) \\<in> acc\n  (w, y) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  \\<exists>n. 0 < p x w n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>0 < p x w n; 0 < pmf (K w) y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_pmf_iff less_le)"], ["proof (state)\nthis:\n  0 < p x w n\n  0 < pmf (K w) y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "then"], ["proof (chain)\npicking this:\n  0 < p x w n\n  0 < pmf (K w) y", "have \"0 < p x w n * pmf (K w) y\""], ["proof (prove)\nusing this:\n  0 < p x w n\n  0 < pmf (K w) y\n\ngoal (1 subgoal):\n 1. 0 < p x w n * pmf (K w) y", "by (intro mult_pos_pos)"], ["proof (state)\nthis:\n  0 < p x w n * pmf (K w) y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "also"], ["proof (state)\nthis:\n  0 < p x w n * pmf (K w) y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "have \"\\<dots> \\<le> p x w n * p w y (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x w n * pmf (K w) y \\<le> p x w n * p w y (Suc 0)", "by (simp add: p_Suc' p_0 pmf.rep_eq)"], ["proof (state)\nthis:\n  p x w n * pmf (K w) y \\<le> p x w n * p w y (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "also"], ["proof (state)\nthis:\n  p x w n * pmf (K w) y \\<le> p x w n * p w y (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "have \"\\<dots> \\<le> p x y (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x w n * p w y (Suc 0) \\<le> p x y (Suc n)", "using prob_reachable_le[of n \"Suc n\" x w y]"], ["proof (prove)\nusing this:\n  n \\<le> Suc n \\<Longrightarrow>\n  p x w n * p w y (Suc n - n) \\<le> p x y (Suc n)\n\ngoal (1 subgoal):\n 1. p x w n * p w y (Suc 0) \\<le> p x y (Suc n)", "by simp"], ["proof (state)\nthis:\n  p x w n * p w y (Suc 0) \\<le> p x y (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x));\n        \\<exists>n. 0 < p x y n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. 0 < p x z n", "finally"], ["proof (chain)\npicking this:\n  0 < p x y (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  0 < p x y (Suc n)\n\ngoal (1 subgoal):\n 1. \\<exists>n. 0 < p x y n", ".."], ["proof (state)\nthis:\n  \\<exists>n. 0 < p x y n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma accI_pos: \"0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc", "proof (induct n arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. 0 < p x y 0 \\<Longrightarrow> (x, y) \\<in> acc\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x. 0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc;\n        0 < p x y (Suc n)\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> acc", "case (Suc n)"], ["proof (state)\nthis:\n  0 < p ?x4 y n \\<Longrightarrow> (?x4, y) \\<in> acc\n  0 < p x y (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 < p x y 0 \\<Longrightarrow> (x, y) \\<in> acc\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x. 0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc;\n        0 < p x y (Suc n)\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> acc", "then"], ["proof (chain)\npicking this:\n  0 < p ?x4 y n \\<Longrightarrow> (?x4, y) \\<in> acc\n  0 < p x y (Suc n)", "have less: \"0 < (\\<integral>x'. p x' y n \\<partial>K x)\""], ["proof (prove)\nusing this:\n  0 < p ?x4 y n \\<Longrightarrow> (?x4, y) \\<in> acc\n  0 < p x y (Suc n)\n\ngoal (1 subgoal):\n 1. 0 < measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n)", "by (simp add: p_Suc')"], ["proof (state)\nthis:\n  0 < measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n)\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 < p x y 0 \\<Longrightarrow> (x, y) \\<in> acc\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x. 0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc;\n        0 < p x y (Suc n)\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> acc", "have \"\\<exists>x'\\<in>K x. 0 < p x' y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n)", "have \"AE x' in K x. p x' y n = 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n)\n\ngoal (1 subgoal):\n 1. AE x' in measure_pmf (K x). p x' y n = 0", "by (simp add: AE_measure_pmf_iff less_le)"], ["proof (state)\nthis:\n  AE x' in measure_pmf (K x). p x' y n = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  AE x' in measure_pmf (K x). p x' y n = 0", "have \"(\\<integral>x'. p x' y n \\<partial>K x) = (\\<integral>x'. 0 \\<partial>K x)\""], ["proof (prove)\nusing this:\n  AE x' in measure_pmf (K x). p x' y n = 0\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n) =\n    measure_pmf.expectation (K x) (\\<lambda>x'. 0)", "by (intro integral_cong_AE) simp_all"], ["proof (state)\nthis:\n  measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n) =\n  measure_pmf.expectation (K x) (\\<lambda>x'. 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n) \\<Longrightarrow>\n    False", "with less"], ["proof (chain)\npicking this:\n  0 < measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n)\n  measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n) =\n  measure_pmf.expectation (K x) (\\<lambda>x'. 0)", "show False"], ["proof (prove)\nusing this:\n  0 < measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n)\n  measure_pmf.expectation (K x) (\\<lambda>x'. p x' y n) =\n  measure_pmf.expectation (K x) (\\<lambda>x'. 0)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n\n\ngoal (2 subgoals):\n 1. \\<And>x. 0 < p x y 0 \\<Longrightarrow> (x, y) \\<in> acc\n 2. \\<And>n x.\n       \\<lbrakk>\\<And>x. 0 < p x y n \\<Longrightarrow> (x, y) \\<in> acc;\n        0 < p x y (Suc n)\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> acc", "with Suc"], ["proof (chain)\npicking this:\n  0 < p ?x4 y n \\<Longrightarrow> (?x4, y) \\<in> acc\n  0 < p x y (Suc n)\n  \\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n", "show ?case"], ["proof (prove)\nusing this:\n  0 < p ?x4 y n \\<Longrightarrow> (?x4, y) \\<in> acc\n  0 < p x y (Suc n)\n  \\<exists>x'\\<in>set_pmf (K x). 0 < p x' y n\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> acc", "by (auto intro: converse_rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  (x, y) \\<in> acc\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < p x y 0 \\<Longrightarrow> (x, y) \\<in> acc", "qed (simp add: p_0 split: if_split_asm)"], ["", "lemma recurrent_iffI_communicating:\n  assumes \"(x, y) \\<in> communicating\"\n  shows \"recurrent x \\<longleftrightarrow> recurrent y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "from assms"], ["proof (chain)\npicking this:\n  (x, y) \\<in> communicating", "obtain n m where \"0 < p x y n\" \"0 < p y x m\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>0 < p x y n; 0 < p y x m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: communicating_def dest: accD_pos)"], ["proof (state)\nthis:\n  0 < p x y n\n  0 < p y x m\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "moreover"], ["proof (state)\nthis:\n  0 < p x y n\n  0 < p y x m\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "{"], ["proof (state)\nthis:\n  0 < p x y n\n  0 < p y x m\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "fix x y n m"], ["proof (state)\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "assume \"0 < p x y n\" \"0 < p y x m\" \"G y y = \\<infinity>\""], ["proof (state)\nthis:\n  0 < p x y n\n  0 < p y x m\n  G y y = \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "then"], ["proof (chain)\npicking this:\n  0 < p x y n\n  0 < p y x m\n  G y y = \\<infinity>", "have \"\\<infinity> = ennreal (p x y n * p y x m) * G y y\""], ["proof (prove)\nusing this:\n  0 < p x y n\n  0 < p y x m\n  G y y = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<infinity> = ennreal (p x y n * p y x m) * G y y", "by (auto intro: mult_pos_pos simp: ennreal_mult_top)"], ["proof (state)\nthis:\n  \\<infinity> = ennreal (p x y n * p y x m) * G y y\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "also"], ["proof (state)\nthis:\n  \\<infinity> = ennreal (p x y n * p y x m) * G y y\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "have \"ennreal (p x y n * p y x m) * G y y = (\\<Sum>i. ennreal (p x y n * p y x m) * p y y i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y n * p y x m) * G y y =\n    (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))", "unfolding G_eq_suminf"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (p x y n * p y x m) * (\\<Sum>i. ennreal (p y y i)) =\n    (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))", "by (rule ennreal_suminf_cmult[symmetric])"], ["proof (state)\nthis:\n  ennreal (p x y n * p y x m) * G y y =\n  (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "also"], ["proof (state)\nthis:\n  ennreal (p x y n * p y x m) * G y y =\n  (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "have \"\\<dots> \\<le> (\\<Sum>i. ennreal (p x x (n + i + m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n    \\<le> (\\<Sum>i. ennreal (p x x (n + i + m)))", "proof (intro suminf_le allI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       ennreal (p x y n * p y x m) * ennreal (p y y n)\n       \\<le> ennreal (p x x (n + n + m))\n 2. summable (\\<lambda>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n 3. summable (\\<lambda>i. ennreal (p x x (n + i + m)))", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       ennreal (p x y n * p y x m) * ennreal (p y y n)\n       \\<le> ennreal (p x x (n + n + m))\n 2. summable (\\<lambda>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n 3. summable (\\<lambda>i. ennreal (p x x (n + i + m)))", "have \"(p x y n * p y y ((n + i) - n)) * p y x ((n + i + m) - (n + i)) \\<le> p x y (n + i) * p y x ((n + i + m) - (n + i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n    \\<le> p x y (n + i) * p y x (n + i + m - (n + i))", "by (intro mult_right_mono prob_reachable_le) simp_all"], ["proof (state)\nthis:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x y (n + i) * p y x (n + i + m - (n + i))\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       ennreal (p x y n * p y x m) * ennreal (p y y n)\n       \\<le> ennreal (p x x (n + n + m))\n 2. summable (\\<lambda>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n 3. summable (\\<lambda>i. ennreal (p x x (n + i + m)))", "also"], ["proof (state)\nthis:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x y (n + i) * p y x (n + i + m - (n + i))\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       ennreal (p x y n * p y x m) * ennreal (p y y n)\n       \\<le> ennreal (p x x (n + n + m))\n 2. summable (\\<lambda>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n 3. summable (\\<lambda>i. ennreal (p x x (n + i + m)))", "have \"\\<dots> \\<le> p x x (n + i + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y (n + i) * p y x (n + i + m - (n + i)) \\<le> p x x (n + i + m)", "by (intro prob_reachable_le) simp_all"], ["proof (state)\nthis:\n  p x y (n + i) * p y x (n + i + m - (n + i)) \\<le> p x x (n + i + m)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       ennreal (p x y n * p y x m) * ennreal (p y y n)\n       \\<le> ennreal (p x x (n + n + m))\n 2. summable (\\<lambda>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n 3. summable (\\<lambda>i. ennreal (p x x (n + i + m)))", "finally"], ["proof (chain)\npicking this:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x x (n + i + m)", "show \"ennreal (p x y n * p y x m) * p y y i \\<le> ennreal (p x x (n + i + m))\""], ["proof (prove)\nusing this:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x x (n + i + m)\n\ngoal (1 subgoal):\n 1. ennreal (p x y n * p y x m) * ennreal (p y y i)\n    \\<le> ennreal (p x x (n + i + m))", "by (simp add: ac_simps ennreal_mult'[symmetric])"], ["proof (state)\nthis:\n  ennreal (p x y n * p y x m) * ennreal (p y y i)\n  \\<le> ennreal (p x x (n + i + m))\n\ngoal (2 subgoals):\n 1. summable (\\<lambda>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n 2. summable (\\<lambda>i. ennreal (p x x (n + i + m)))", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n  \\<le> (\\<Sum>i. ennreal (p x x (n + i + m)))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x y n * p y x m) * ennreal (p y y i))\n  \\<le> (\\<Sum>i. ennreal (p x x (n + i + m)))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "have \"\\<dots> \\<le> (\\<Sum>i. ennreal (p x x (i + (n + m))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. ennreal (p x x (n + i + m)))\n    \\<le> (\\<Sum>i. ennreal (p x x (i + (n + m))))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x x (n + i + m)))\n  \\<le> (\\<Sum>i. ennreal (p x x (i + (n + m))))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x x (n + i + m)))\n  \\<le> (\\<Sum>i. ennreal (p x x (i + (n + m))))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "have \"\\<dots> \\<le> (\\<Sum>i. ennreal (p x x i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. ennreal (p x x (i + (n + m))))\n    \\<le> (\\<Sum>i. ennreal (p x x i))", "by (subst suminf_offset[of \"\\<lambda>i. ennreal (p x x i)\" \"n + m\"]) auto"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x x (i + (n + m))))\n  \\<le> (\\<Sum>i. ennreal (p x x i))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "also"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x x (i + (n + m))))\n  \\<le> (\\<Sum>i. ennreal (p x x i))\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "have \"\\<dots> \\<le> G x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. ennreal (p x x i)) \\<le> G x x", "unfolding G_eq_suminf"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. ennreal (p x x i)) \\<le> (\\<Sum>i. ennreal (p x x i))", "by (auto intro!: suminf_le_pos)"], ["proof (state)\nthis:\n  (\\<Sum>i. ennreal (p x x i)) \\<le> G x x\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "finally"], ["proof (chain)\npicking this:\n  \\<infinity> \\<le> G x x", "have \"G x x = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<infinity> \\<le> G x x\n\ngoal (1 subgoal):\n 1. G x x = \\<infinity>", "by (simp add: top_unique)"], ["proof (state)\nthis:\n  G x x = \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < p ?xa6 ?ya6 ?na6; 0 < p ?ya6 ?xa6 ?ma6;\n   G ?ya6 ?ya6 = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> G ?xa6 ?xa6 = \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "ultimately"], ["proof (chain)\npicking this:\n  0 < p x y n\n  0 < p y x m\n  \\<lbrakk>0 < p ?xa6 ?ya6 ?na6; 0 < p ?ya6 ?xa6 ?ma6;\n   G ?ya6 ?ya6 = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> G ?xa6 ?xa6 = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < p x y n\n  0 < p y x m\n  \\<lbrakk>0 < p ?xa6 ?ya6 ?na6; 0 < p ?ya6 ?xa6 ?ma6;\n   G ?ya6 ?ya6 = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> G ?xa6 ?xa6 = \\<infinity>\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "using recurrent_iff_G_infinite"], ["proof (prove)\nusing this:\n  0 < p x y n\n  0 < p y x m\n  \\<lbrakk>0 < p ?xa6 ?ya6 ?na6; 0 < p ?ya6 ?xa6 ?ma6;\n   G ?ya6 ?ya6 = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> G ?xa6 ?xa6 = \\<infinity>\n  recurrent ?x = (G ?x ?x = \\<infinity>)\n\ngoal (1 subgoal):\n 1. recurrent x = recurrent y", "by blast"], ["proof (state)\nthis:\n  recurrent x = recurrent y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma recurrent_acc:\n  assumes \"recurrent x\" \"(x, y) \\<in> acc\"\n  shows \"U y x = 1\" \"H y x = 1\" \"recurrent y\" \"(x, y) \\<in> communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (U y x = 1 &&& H y x = 1) &&& recurrent y &&& (x, y) \\<in> communicating", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "fix w y"], ["proof (state)\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "assume step: \"(x, w) \\<in> acc\" \"y \\<in> K w\" \"U w x = 1\" \"H w x = 1\" \"recurrent w\" \"x \\<noteq> y\""], ["proof (state)\nthis:\n  (x, w) \\<in> acc\n  y \\<in> set_pmf (K w)\n  U w x = 1\n  H w x = 1\n  recurrent w\n  x \\<noteq> y\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"measure (K w) UNIV = U w x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (K w) UNIV = U w x", "using step measure_pmf.prob_space[of \"K w\"]"], ["proof (prove)\nusing this:\n  (x, w) \\<in> acc\n  y \\<in> set_pmf (K w)\n  U w x = 1\n  H w x = 1\n  recurrent w\n  x \\<noteq> y\n  measure_pmf.prob (K w) (space (measure_pmf (K w))) = 1\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (K w) UNIV = U w x", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob (K w) UNIV = U w x\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (K w) UNIV = U w x\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"\\<dots> = (\\<integral>v. indicator {x} v + U v x * indicator (- {x}) v \\<partial>K w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U w x =\n    measure_pmf.expectation (K w)\n     (\\<lambda>v. indicat_real {x} v + U v x * indicat_real (- {x}) v)", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob w {\\<omega> \\<in> space (T w). ev (HLD {x}) \\<omega>} =\n    measure_pmf.expectation (K w)\n     (\\<lambda>v.\n         indicat_real {x} v +\n         T.prob v {\\<omega> \\<in> space (T v). ev (HLD {x}) \\<omega>} *\n         indicat_real (- {x}) v)", "by (subst prob_T)\n         (auto intro!: Bochner_Integration.integral_cong arg_cong2[where f=measure] AE_I2\n               simp: ev_Stream T.prob_eq_1 split: split_indicator)"], ["proof (state)\nthis:\n  U w x =\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. indicat_real {x} v + U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "also"], ["proof (state)\nthis:\n  U w x =\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. indicat_real {x} v + U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"\\<dots> = measure (K w) {x} + (\\<integral>v. U v x * indicator (- {x}) v \\<partial>K w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K w)\n     (\\<lambda>v. indicat_real {x} v + U v x * indicat_real (- {x}) v) =\n    measure_pmf.prob (K w) {x} +\n    measure_pmf.expectation (K w)\n     (\\<lambda>v. U v x * indicat_real (- {x}) v)", "by (subst Bochner_Integration.integral_add)\n         (auto intro!: measure_pmf.integrable_const_bound[where B=1]\n               simp: abs_mult mult_le_one U_bounded(2) measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. indicat_real {x} v + U v x * indicat_real (- {x}) v) =\n  measure_pmf.prob (K w) {x} +\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob (K w) UNIV =\n  measure_pmf.prob (K w) {x} +\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)", "have \"measure (K w) UNIV - measure (K w) {x} = (\\<integral>v. U v x * indicator (- {x}) v \\<partial>K w)\""], ["proof (prove)\nusing this:\n  measure_pmf.prob (K w) UNIV =\n  measure_pmf.prob (K w) {x} +\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob (K w) UNIV - measure_pmf.prob (K w) {x} =\n    measure_pmf.expectation (K w)\n     (\\<lambda>v. U v x * indicat_real (- {x}) v)", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob (K w) UNIV - measure_pmf.prob (K w) {x} =\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "also"], ["proof (state)\nthis:\n  measure_pmf.prob (K w) UNIV - measure_pmf.prob (K w) {x} =\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"measure (K w) UNIV - measure (K w) {x} = measure (K w) (UNIV - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob (K w) UNIV - measure_pmf.prob (K w) {x} =\n    measure_pmf.prob (K w) (UNIV - {x})", "by (subst measure_pmf.finite_measure_Diff) auto"], ["proof (state)\nthis:\n  measure_pmf.prob (K w) UNIV - measure_pmf.prob (K w) {x} =\n  measure_pmf.prob (K w) (UNIV - {x})\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob (K w) (UNIV - {x}) =\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)", "have \"0 = (\\<integral>v. indicator (- {x}) v \\<partial>K w) - (\\<integral>v. U v x * indicator (- {x}) v \\<partial>K w)\""], ["proof (prove)\nusing this:\n  measure_pmf.prob (K w) (UNIV - {x}) =\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (1 subgoal):\n 1. 0 =\n    measure_pmf.expectation (K w) (indicat_real (- {x})) -\n    measure_pmf.expectation (K w)\n     (\\<lambda>v. U v x * indicat_real (- {x}) v)", "by (simp add: measure_pmf.emeasure_eq_measure Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  0 =\n  measure_pmf.expectation (K w) (indicat_real (- {x})) -\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "also"], ["proof (state)\nthis:\n  0 =\n  measure_pmf.expectation (K w) (indicat_real (- {x})) -\n  measure_pmf.expectation (K w) (\\<lambda>v. U v x * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"\\<dots> = (\\<integral>v. (1 - U v x) * indicator (- {x}) v \\<partial>K w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K w) (indicat_real (- {x})) -\n    measure_pmf.expectation (K w)\n     (\\<lambda>v. U v x * indicat_real (- {x}) v) =\n    measure_pmf.expectation (K w)\n     (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)", "by (subst Bochner_Integration.integral_diff[symmetric])\n         (auto intro!: measure_pmf.integrable_const_bound[where B=1] Bochner_Integration.integral_cong\n               simp: abs_mult mult_le_one U_bounded(2) split: split_indicator)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K w) (indicat_real (- {x})) -\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. U v x * indicat_real (- {x}) v) =\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (K w) (indicat_real (- {x})) -\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. U v x * indicat_real (- {x}) v) =\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"\\<dots> \\<ge> (\\<integral>v. (1 - U y x) * indicator {y} v \\<partial>K w)\" (is \"_ \\<ge> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K w)\n     (\\<lambda>v. (1 - U y x) * indicat_real {y} v)\n    \\<le> measure_pmf.expectation (K w)\n           (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)", "using \\<open>recurrent x\\<close>"], ["proof (prove)\nusing this:\n  recurrent x\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K w)\n     (\\<lambda>v. (1 - U y x) * indicat_real {y} v)\n    \\<le> measure_pmf.expectation (K w)\n           (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)", "by (intro integral_mono measure_pmf.integrable_const_bound[where B=1])\n         (auto simp: abs_mult mult_le_one U_bounded(2) recurrent_iff_U_eq_1 field_simps\n               split: split_indicator)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. (1 - U y x) * indicat_real {y} v)\n  \\<le> measure_pmf.expectation (K w)\n         (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "also (xtrans)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. (1 - U y x) * indicat_real {y} v)\n  \\<le> measure_pmf.expectation (K w)\n         (\\<lambda>v. (1 - U v x) * indicat_real (- {x}) v)\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "have \"?rhs = (1 - U y x) * pmf (K w) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (K w)\n     (\\<lambda>v. (1 - U y x) * indicat_real {y} v) =\n    (1 - U y x) * pmf (K w) y", "by (simp add: measure_pmf.emeasure_eq_measure pmf.rep_eq)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K w)\n   (\\<lambda>v. (1 - U y x) * indicat_real {y} v) =\n  (1 - U y x) * pmf (K w) y\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "finally"], ["proof (chain)\npicking this:\n  (1 - U y x) * pmf (K w) y \\<le> 0", "have \"(1 - U y x) * pmf (K w) y = 0\""], ["proof (prove)\nusing this:\n  (1 - U y x) * pmf (K w) y \\<le> 0\n\ngoal (1 subgoal):\n 1. (1 - U y x) * pmf (K w) y = 0", "by (auto intro!: antisym simp: U_bounded(2) mult_le_0_iff)"], ["proof (state)\nthis:\n  (1 - U y x) * pmf (K w) y = 0\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "with \\<open>y \\<in> K w\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set_pmf (K w)\n  (1 - U y x) * pmf (K w) y = 0", "have \"U y x = 1\""], ["proof (prove)\nusing this:\n  y \\<in> set_pmf (K w)\n  (1 - U y x) * pmf (K w) y = 0\n\ngoal (1 subgoal):\n 1. U y x = 1", "by (simp add: set_pmf_iff)"], ["proof (state)\nthis:\n  U y x = 1\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "then"], ["proof (chain)\npicking this:\n  U y x = 1", "have \"U y x = 1\" \"H y x = 1\""], ["proof (prove)\nusing this:\n  U y x = 1\n\ngoal (1 subgoal):\n 1. U y x = 1 &&& H y x = 1", "using H_eq(3)[of y x] H_eq(1)[of x]"], ["proof (prove)\nusing this:\n  U y x = 1\n  H y x = U y x * H x x\n  recurrent x = (H x x = 1)\n\ngoal (1 subgoal):\n 1. U y x = 1 &&& H y x = 1", "by (simp_all add: \\<open>recurrent x\\<close>)"], ["proof (state)\nthis:\n  U y x = 1\n  H y x = 1\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "then"], ["proof (chain)\npicking this:\n  U y x = 1\n  H y x = 1", "have \"(y, x) \\<in> acc\""], ["proof (prove)\nusing this:\n  U y x = 1\n  H y x = 1\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> acc", "by (intro accI_U) auto"], ["proof (state)\nthis:\n  (y, x) \\<in> acc\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "with step"], ["proof (chain)\npicking this:\n  (x, w) \\<in> acc\n  y \\<in> set_pmf (K w)\n  U w x = 1\n  H w x = 1\n  recurrent w\n  x \\<noteq> y\n  (y, x) \\<in> acc", "have \"(x, y) \\<in> communicating\""], ["proof (prove)\nusing this:\n  (x, w) \\<in> acc\n  y \\<in> set_pmf (K w)\n  U w x = 1\n  H w x = 1\n  recurrent w\n  x \\<noteq> y\n  (y, x) \\<in> acc\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> communicating", "by (auto simp add: communicating_def intro: rtrancl_trans)"], ["proof (state)\nthis:\n  (x, y) \\<in> communicating\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "with \\<open>recurrent x\\<close>"], ["proof (chain)\npicking this:\n  recurrent x\n  (x, y) \\<in> communicating", "have \"recurrent y\""], ["proof (prove)\nusing this:\n  recurrent x\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. recurrent y", "by (simp add: recurrent_iffI_communicating)"], ["proof (state)\nthis:\n  recurrent y\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "note this \\<open>U y x = 1\\<close> \\<open>H y x = 1\\<close> \\<open>(x, y) \\<in> communicating\\<close>"], ["proof (state)\nthis:\n  recurrent y\n  U y x = 1\n  H y x = 1\n  (x, y) \\<in> communicating\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> recurrent ?ya6\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> U ?ya6 x = 1\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> H ?ya6 x = 1\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> (x, ?ya6) \\<in> communicating\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "note enabled = this"], ["proof (state)\nthis:\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> recurrent ?ya6\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> U ?ya6 x = 1\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> H ?ya6 x = 1\n  \\<lbrakk>(x, ?w6) \\<in> acc; ?ya6 \\<in> set_pmf (K ?w6); U ?w6 x = 1;\n   H ?w6 x = 1; recurrent ?w6; x \\<noteq> ?ya6\\<rbrakk>\n  \\<Longrightarrow> (x, ?ya6) \\<in> communicating\n\ngoal (4 subgoals):\n 1. U y x = 1\n 2. H y x = 1\n 3. recurrent y\n 4. (x, y) \\<in> communicating", "from \\<open>(x, y) \\<in> acc\\<close>"], ["proof (chain)\npicking this:\n  (x, y) \\<in> acc", "show \"U y x = 1\" \"H y x = 1\" \"recurrent y\" \"(x, y) \\<in> communicating\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> acc\n\ngoal (1 subgoal):\n 1. (U y x = 1 &&& H y x = 1) &&& recurrent y &&& (x, y) \\<in> communicating", "proof induction"], ["proof (state)\ngoal (8 subgoals):\n 1. U x x = 1\n 2. H x x = 1\n 3. recurrent x\n 4. (x, x) \\<in> communicating\n 5. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> U z x = 1\n 6. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> H z x = 1\n 7. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> recurrent z\n 8. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> communicating", "case base"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. U x x = 1\n 2. H x x = 1\n 3. recurrent x\n 4. (x, x) \\<in> communicating\n 5. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> U z x = 1\n 6. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> H z x = 1\n 7. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> recurrent z\n 8. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> communicating", "then"], ["proof (chain)\npicking this:", "show \"U x x = 1\" \"H x x = 1\" \"recurrent x\" \"(x, x) \\<in> communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (U x x = 1 &&& H x x = 1) &&& recurrent x &&& (x, x) \\<in> communicating", "using \\<open>recurrent x\\<close> H_eq(1)[of x]"], ["proof (prove)\nusing this:\n  recurrent x\n  recurrent x = (H x x = 1)\n\ngoal (1 subgoal):\n 1. (U x x = 1 &&& H x x = 1) &&& recurrent x &&& (x, x) \\<in> communicating", "by (auto simp: recurrent_iff_U_eq_1 communicating_def)"], ["proof (state)\nthis:\n  U x x = 1\n  H x x = 1\n  recurrent x\n  (x, x) \\<in> communicating\n\ngoal (4 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> U z x = 1\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> H z x = 1\n 3. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> recurrent z\n 4. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> communicating", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> U z x = 1\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> H z x = 1\n 3. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> recurrent z\n 4. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> communicating", "case (step w y)"], ["proof (state)\nthis:\n  (x, w) \\<in> acc\n  (w, y) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  U w x = 1\n  H w x = 1\n  recurrent w\n  (x, w) \\<in> communicating\n\ngoal (4 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> U z x = 1\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> H z x = 1\n 3. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> recurrent z\n 4. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> communicating", "with enabled[of w y] \\<open>recurrent x\\<close> H_eq(1)[of x]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> recurrent y\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> U y x = 1\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> H y x = 1\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> communicating\n  recurrent x\n  recurrent x = (H x x = 1)\n  (x, w) \\<in> acc\n  (w, y) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  U w x = 1\n  H w x = 1\n  recurrent w\n  (x, w) \\<in> communicating", "have \"U y x = 1 \\<and> H y x = 1 \\<and> recurrent y \\<and> (x, y) \\<in> communicating\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> recurrent y\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> U y x = 1\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> H y x = 1\n  \\<lbrakk>(x, w) \\<in> acc; y \\<in> set_pmf (K w); U w x = 1; H w x = 1;\n   recurrent w; x \\<noteq> y\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> communicating\n  recurrent x\n  recurrent x = (H x x = 1)\n  (x, w) \\<in> acc\n  (w, y) \\<in> (SIGMA x:UNIV. set_pmf (K x))\n  U w x = 1\n  H w x = 1\n  recurrent w\n  (x, w) \\<in> communicating\n\ngoal (1 subgoal):\n 1. U y x = 1 \\<and>\n    H y x = 1 \\<and> recurrent y \\<and> (x, y) \\<in> communicating", "by (cases \"x = y\") (auto simp: recurrent_iff_U_eq_1 communicating_def)"], ["proof (state)\nthis:\n  U y x = 1 \\<and>\n  H y x = 1 \\<and> recurrent y \\<and> (x, y) \\<in> communicating\n\ngoal (4 subgoals):\n 1. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> U z x = 1\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> H z x = 1\n 3. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> recurrent z\n 4. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> acc;\n        (y, z) \\<in> (SIGMA x:UNIV. set_pmf (K x)); U y x = 1; H y x = 1;\n        recurrent y; (x, y) \\<in> communicating\\<rbrakk>\n       \\<Longrightarrow> (x, z) \\<in> communicating", "then"], ["proof (chain)\npicking this:\n  U y x = 1 \\<and>\n  H y x = 1 \\<and> recurrent y \\<and> (x, y) \\<in> communicating", "show \"U y x = 1\" \"H y x = 1\" \"recurrent y\" \"(x, y) \\<in> communicating\""], ["proof (prove)\nusing this:\n  U y x = 1 \\<and>\n  H y x = 1 \\<and> recurrent y \\<and> (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (U y x = 1 &&& H y x = 1) &&& recurrent y &&& (x, y) \\<in> communicating", "by auto"], ["proof (state)\nthis:\n  U y x = 1\n  H y x = 1\n  recurrent y\n  (x, y) \\<in> communicating\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U y x = 1\n  H y x = 1\n  recurrent y\n  (x, y) \\<in> communicating\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equiv_communicating: \"equiv UNIV communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equiv UNIV communicating", "by (auto simp: equiv_def sym_def communicating_def refl_on_def trans_def)"], ["", "lemma recurrent_class:\n  assumes \"recurrent x\"\n  shows \"acc `` {x} = communicating `` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc `` {x} = communicating `` {x}", "using recurrent_acc(4)[OF \\<open>recurrent x\\<close>]"], ["proof (prove)\nusing this:\n  (x, ?y) \\<in> acc \\<Longrightarrow> (x, ?y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. acc `` {x} = communicating `` {x}", "by (auto simp: communicating_def)"], ["", "lemma irreduccible_recurrent_class:\n  assumes \"recurrent x\" shows \"acc `` {x} \\<in> UNIV // communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acc `` {x} \\<in> UNIV // communicating", "unfolding recurrent_class[OF \\<open>recurrent x\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. communicating `` {x} \\<in> UNIV // communicating", "by (rule quotientI) simp"], ["", "lemma essential_classI:\n  assumes C: \"C \\<in> UNIV // communicating\"\n  assumes eq: \"\\<And>x y. x \\<in> C \\<Longrightarrow> (x, y) \\<in> acc \\<Longrightarrow> y \\<in> C\"\n  shows \"essential_class C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential_class C", "by (auto simp: essential_class_def intro: C) (metis eq)"], ["", "lemma essential_recurrent_class:\n  assumes \"recurrent x\" shows \"essential_class (communicating `` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential_class (communicating `` {x})", "unfolding recurrent_class[OF \\<open>recurrent x\\<close>, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. essential_class (acc `` {x})", "apply (rule essential_classI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. acc `` {x} \\<in> UNIV // communicating\n 2. \\<And>xa y.\n       \\<lbrakk>xa \\<in> acc `` {x}; (xa, y) \\<in> acc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> acc `` {x}", "apply (rule irreduccible_recurrent_class[OF assms])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa \\<in> acc `` {x}; (xa, y) \\<in> acc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> acc `` {x}", "apply (auto simp: communicating_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma essential_classD2:\n  \"essential_class C \\<Longrightarrow> x \\<in> C \\<Longrightarrow> (x, y) \\<in> acc \\<Longrightarrow> y \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>essential_class C; x \\<in> C; (x, y) \\<in> acc\\<rbrakk>\n    \\<Longrightarrow> y \\<in> C", "unfolding essential_class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> UNIV // communicating \\<and> acc `` C \\<subseteq> C;\n     x \\<in> C; (x, y) \\<in> acc\\<rbrakk>\n    \\<Longrightarrow> y \\<in> C", "by auto"], ["", "lemma essential_classD3:\n  \"essential_class C \\<Longrightarrow> x \\<in> C \\<Longrightarrow> y \\<in> C \\<Longrightarrow> (x, y) \\<in> communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>essential_class C; x \\<in> C; y \\<in> C\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> communicating", "unfolding essential_class_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> UNIV // communicating \\<and> acc `` C \\<subseteq> C;\n     x \\<in> C; y \\<in> C\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<in> communicating", "by (auto elim!: quotientE simp: communicating_def)"], ["", "lemma AE_acc:\n  shows \"AE \\<omega> in T x. \\<forall>m. (x, (x ## \\<omega>) !! m) \\<in> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in T x. \\<forall>m. (x, (x ## \\<omega>) !! m) \\<in> acc", "using AE_T_reachable"], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (alw (HLD (acc `` {?s})))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T x. \\<forall>m. (x, (x ## \\<omega>) !! m) \\<in> acc", "by eventually_elim (auto simp: alw_HLD_iff_streams streams_iff_snth Stream_snth split: nat.splits)"], ["", "lemma finite_essential_class_imp_recurrent:\n  assumes C: \"essential_class C\" \"finite C\" and x: \"x \\<in> C\"\n  shows \"recurrent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurrent x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. recurrent x", "have \"AE \\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "using AE_T_reachable"], ["proof (prove)\nusing this:\n  almost_everywhere (T ?s) (alw (HLD (acc `` {?s})))\n\ngoal (1 subgoal):\n 1. AE \\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "assume \"alw (HLD (acc `` {x})) \\<omega>\""], ["proof (state)\nthis:\n  alw (HLD (acc `` {x})) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "then"], ["proof (chain)\npicking this:\n  alw (HLD (acc `` {x})) \\<omega>", "have \"alw (HLD C) \\<omega>\""], ["proof (prove)\nusing this:\n  alw (HLD (acc `` {x})) \\<omega>\n\ngoal (1 subgoal):\n 1. alw (HLD C) \\<omega>", "by (rule alw_mono) (auto simp: HLD_iff intro: assms essential_classD2)"], ["proof (state)\nthis:\n  alw (HLD C) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<And>\\<omega>.\n       alw (HLD (acc `` {x})) \\<omega> \\<Longrightarrow>\n       \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "then"], ["proof (chain)\npicking this:\n  alw (HLD C) \\<omega>", "show \"\\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>\""], ["proof (prove)\nusing this:\n  alw (HLD C) \\<omega>\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "by (rule pigeonhole_stream) fact"], ["proof (state)\nthis:\n  \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AE \\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>\n\ngoal (1 subgoal):\n 1. recurrent x", "then"], ["proof (chain)\npicking this:\n  AE \\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>", "have \"1 = \\<P>(\\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>)\""], ["proof (prove)\nusing this:\n  AE \\<omega> in T x. \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>\n\ngoal (1 subgoal):\n 1. 1 =\n    T.prob x\n     {\\<omega> \\<in> space (T x).\n      \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>}", "by (subst (asm) T.prob_Collect_eq_1[symmetric]) (auto simp: \\<open>finite C\\<close>)"], ["proof (state)\nthis:\n  1 =\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>}\n\ngoal (1 subgoal):\n 1. recurrent x", "also"], ["proof (state)\nthis:\n  1 =\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>}\n\ngoal (1 subgoal):\n 1. recurrent x", "have \"\\<dots> = measure (T x) (\\<Union>y\\<in>C. {\\<omega>\\<in>space (T x). alw (ev (HLD {y})) \\<omega>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x\n     {\\<omega> \\<in> space (T x).\n      \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>} =\n    T.prob x\n     (\\<Union>y\\<in>C.\n         {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})", "by (intro arg_cong2[where f=measure]) auto"], ["proof (state)\nthis:\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>} =\n  T.prob x\n   (\\<Union>y\\<in>C.\n       {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n\ngoal (1 subgoal):\n 1. recurrent x", "also"], ["proof (state)\nthis:\n  T.prob x\n   {\\<omega> \\<in> space (T x).\n    \\<exists>y\\<in>C. alw (ev (HLD {y})) \\<omega>} =\n  T.prob x\n   (\\<Union>y\\<in>C.\n       {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n\ngoal (1 subgoal):\n 1. recurrent x", "have \"\\<dots> \\<le> (\\<Sum>y\\<in>C. H x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x\n     (\\<Union>y\\<in>C.\n         {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n    \\<le> sum (H x) C", "unfolding H_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob x\n     (\\<Union>y\\<in>C.\n         {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n    \\<le> (\\<Sum>y\\<in>C.\n             T.prob x\n              {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})", "using \\<open>finite C\\<close>"], ["proof (prove)\nusing this:\n  finite C\n\ngoal (1 subgoal):\n 1. T.prob x\n     (\\<Union>y\\<in>C.\n         {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n    \\<le> (\\<Sum>y\\<in>C.\n             T.prob x\n              {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})", "by (rule T.finite_measure_subadditive_finite) auto"], ["proof (state)\nthis:\n  T.prob x\n   (\\<Union>y\\<in>C.\n       {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n  \\<le> sum (H x) C\n\ngoal (1 subgoal):\n 1. recurrent x", "also"], ["proof (state)\nthis:\n  T.prob x\n   (\\<Union>y\\<in>C.\n       {\\<omega> \\<in> space (T x). alw (ev (HLD {y})) \\<omega>})\n  \\<le> sum (H x) C\n\ngoal (1 subgoal):\n 1. recurrent x", "have \"\\<dots> = (\\<Sum>y\\<in>C. U x y * H y y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (H x) C = (\\<Sum>y\\<in>C. U x y * H y y)", "by (auto intro!: sum.cong H_eq)"], ["proof (state)\nthis:\n  sum (H x) C = (\\<Sum>y\\<in>C. U x y * H y y)\n\ngoal (1 subgoal):\n 1. recurrent x", "finally"], ["proof (chain)\npicking this:\n  1 \\<le> (\\<Sum>y\\<in>C. U x y * H y y)", "have \"\\<exists>y\\<in>C. recurrent y\""], ["proof (prove)\nusing this:\n  1 \\<le> (\\<Sum>y\\<in>C. U x y * H y y)\n\ngoal (1 subgoal):\n 1. Bex C recurrent", "by (rule_tac ccontr) (simp add: H_eq(2))"], ["proof (state)\nthis:\n  Bex C recurrent\n\ngoal (1 subgoal):\n 1. recurrent x", "then"], ["proof (chain)\npicking this:\n  Bex C recurrent", "guess y"], ["proof (prove)\nusing this:\n  Bex C recurrent\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  y \\<in> C\n  recurrent y\n\ngoal (1 subgoal):\n 1. recurrent x", "from essential_classD3[OF C(1) x this(1)] recurrent_acc(3)[OF this(2)]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> communicating\n  (y, ?y) \\<in> acc \\<Longrightarrow> recurrent ?y", "show \"recurrent x\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> communicating\n  (y, ?y) \\<in> acc \\<Longrightarrow> recurrent ?y\n\ngoal (1 subgoal):\n 1. recurrent x", "by (simp add: communicating_def)"], ["proof (state)\nthis:\n  recurrent x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducibleD:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> a \\<in> C \\<Longrightarrow> b \\<in> C \\<Longrightarrow> (a, b) \\<in> communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> UNIV // communicating; a \\<in> C; b \\<in> C\\<rbrakk>\n    \\<Longrightarrow> (a, b) \\<in> communicating", "by (auto elim!: quotientE simp: communicating_def)"], ["", "lemma irreducibleD2:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> a \\<in> C \\<Longrightarrow> (a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> UNIV // communicating; a \\<in> C;\n     (a, b) \\<in> communicating\\<rbrakk>\n    \\<Longrightarrow> b \\<in> C", "by (auto elim!: quotientE simp: communicating_def)"], ["", "lemma essential_class_iff_recurrent:\n  \"finite C \\<Longrightarrow> C \\<in> UNIV // communicating \\<Longrightarrow> essential_class C \\<longleftrightarrow> (\\<forall>x\\<in>C. recurrent x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite C; C \\<in> UNIV // communicating\\<rbrakk>\n    \\<Longrightarrow> essential_class C = Ball C recurrent", "by (metis finite_essential_class_imp_recurrent irreducibleD2 recurrent_acc(4) essential_classI)"], ["", "definition \"U' x y = (\\<integral>\\<^sup>+\\<omega>. eSuc (sfirst (HLD {y}) \\<omega>) \\<partial>T x)\""], ["", "lemma U'_neq_zero[simp]: \"U' x y \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U' x y \\<noteq> 0", "unfolding U'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                       \\<partial>T x \\<noteq>\n    0", "by (simp add: nn_integral_add)"], ["", "definition \"gf_U' x y z = (\\<Sum>n. u x y n * Suc n * z ^ n)\""], ["", "definition \"pos_recurrent x \\<longleftrightarrow> recurrent x \\<and> U' x x \\<noteq> \\<infinity>\""], ["", "lemma summable_gf_U':\n  assumes z: \"norm z < 1\"\n  shows \"summable (\\<lambda>n. u x y n * Suc n * z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "have \"summable (\\<lambda>n. n * \\<bar>z\\<bar> ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. real n * \\<bar>z\\<bar> ^ n)", "proof (rule root_test_convergence)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>n. root n (norm (real n * \\<bar>z\\<bar> ^ n)))\n    \\<longlonglongrightarrow> ?x\n 2. ?x < 1", "have \"(\\<lambda>n. root n n * \\<bar>z\\<bar>) \\<longlonglongrightarrow> 1 * \\<bar>z\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. root n (real n) * \\<bar>z\\<bar>)\n    \\<longlonglongrightarrow> 1 * \\<bar>z\\<bar>", "by (intro tendsto_intros LIMSEQ_root)"], ["proof (state)\nthis:\n  (\\<lambda>n. root n (real n) * \\<bar>z\\<bar>)\n  \\<longlonglongrightarrow> 1 * \\<bar>z\\<bar>\n\ngoal (2 subgoals):\n 1. (\\<lambda>n. root n (norm (real n * \\<bar>z\\<bar> ^ n)))\n    \\<longlonglongrightarrow> ?x\n 2. ?x < 1", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. root n (real n) * \\<bar>z\\<bar>)\n  \\<longlonglongrightarrow> 1 * \\<bar>z\\<bar>", "show \"(\\<lambda>n. root n (norm (n * \\<bar>z\\<bar> ^ n))) \\<longlonglongrightarrow> \\<bar>z\\<bar>\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. root n (real n) * \\<bar>z\\<bar>)\n  \\<longlonglongrightarrow> 1 * \\<bar>z\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. root n (norm (real n * \\<bar>z\\<bar> ^ n)))\n    \\<longlonglongrightarrow> \\<bar>z\\<bar>", "by (rule filterlim_cong[THEN iffD1, rotated 3])\n         (auto intro!: exI[of _ 1]\n               simp add: abs_mult u_nonneg real_root_mult power_abs eventually_sequentially real_root_power)"], ["proof (state)\nthis:\n  (\\<lambda>n. root n (norm (real n * \\<bar>z\\<bar> ^ n)))\n  \\<longlonglongrightarrow> \\<bar>z\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>z\\<bar> < 1", "qed (insert z, simp add: abs_less_iff)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. real n * \\<bar>z\\<bar> ^ n)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "note summable_mult[OF this, of \"1 / \\<bar>z\\<bar>\"]"], ["proof (state)\nthis:\n  summable (\\<lambda>n. 1 / \\<bar>z\\<bar> * (real n * \\<bar>z\\<bar> ^ n))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "from summable_ignore_initial_segment[OF this, of 1]"], ["proof (chain)\npicking this:\n  summable\n   (\\<lambda>n.\n       1 / \\<bar>z\\<bar> * (real (n + 1) * \\<bar>z\\<bar> ^ (n + 1)))", "show \"summable (\\<lambda>n. u x y n * Suc n * z ^ n)\""], ["proof (prove)\nusing this:\n  summable\n   (\\<lambda>n.\n       1 / \\<bar>z\\<bar> * (real (n + 1) * \\<bar>z\\<bar> ^ (n + 1)))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "apply (rule summable_comparison_test[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          norm (u x y n * real (Suc n) * z ^ n)\n          \\<le> 1 / \\<bar>z\\<bar> * (real (n + 1) * \\<bar>z\\<bar> ^ (n + 1))", "using z"], ["proof (prove)\nusing this:\n  norm z < 1\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          norm (u x y n * real (Suc n) * z ^ n)\n          \\<le> 1 / \\<bar>z\\<bar> * (real (n + 1) * \\<bar>z\\<bar> ^ (n + 1))", "apply (auto intro!: exI[of _ 1]\n                simp: abs_mult u_nonneg power_abs Suc_le_eq gr0_conv_Suc field_simps le_divide_eq u_le_1\n                simp del: of_nat_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_U'_nonneg[simp]: \"0 < z \\<Longrightarrow> z < 1 \\<Longrightarrow> 0 \\<le> gf_U' x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; z < 1\\<rbrakk> \\<Longrightarrow> 0 \\<le> gf_U' x y z", "unfolding gf_U'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; z < 1\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> (\\<Sum>n. u x y n * real (Suc n) * z ^ n)", "by (intro suminf_nonneg summable_gf_U') (auto simp: u_nonneg)"], ["", "lemma DERIV_gf_U:\n  fixes z :: real assumes z: \"0 < z\" \"z < 1\"\n  shows \"DERIV (gf_U x y) z :> gf_U' x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gf_U x y has_real_derivative gf_U' x y z) (at z)", "unfolding gf_U_def[abs_def]  gf_U'_def real_scaleR_def u_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) has_real_derivative\n     (\\<Sum>n. u x y n * real (Suc n) * z ^ n))\n     (at z)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. \\<Sum>n. u x y n * z ^ Suc n) has_real_derivative\n     (\\<Sum>n. u x y n * real (Suc n) * z ^ n))\n     (at z)", "by (intro DERIV_power_series'[where R=1] summable_gf_U') auto"], ["", "lemma sfirst_finiteI_recurrent:\n  \"recurrent x \\<Longrightarrow> (x, y) \\<in> acc \\<Longrightarrow> AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n    \\<Longrightarrow> AE \\<omega> in T\nx. sfirst (HLD {y}) \\<omega> < \\<infinity>", "using recurrent_acc(1)[of y x] recurrent_acc[of x y]\n    T.AE_prob_1[of x \"{\\<omega>\\<in>space (T x). ev (HLD {y}) \\<omega>}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>recurrent y; (y, x) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> U x y = 1\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> U y x = 1\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> H y x = 1\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> recurrent y\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> communicating\n  T.prob x {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>} =\n  1 \\<Longrightarrow>\n  AE xa in T x. xa \\<in> {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n    \\<Longrightarrow> AE \\<omega> in T\nx. sfirst (HLD {y}) \\<omega> < \\<infinity>", "unfolding sfirst_finite U_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>recurrent y; (y, x) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> T.prob x\n                     {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>} =\n                    1\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> T.prob y\n                     {\\<omega> \\<in> space (T y). ev (HLD {x}) \\<omega>} =\n                    1\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> H y x = 1\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> recurrent y\n  \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> communicating\n  T.prob x {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>} =\n  1 \\<Longrightarrow>\n  AE xa in T x. xa \\<in> {\\<omega> \\<in> space (T x). ev (HLD {y}) \\<omega>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>recurrent x; (x, y) \\<in> acc\\<rbrakk>\n    \\<Longrightarrow> almost_everywhere (T x) (ev (HLD {y}))", "by (simp add: space_stream_space communicating_def)"], ["", "lemma U'_eq_suminf:\n  assumes x: \"recurrent x\" \"(x, y) \\<in> acc\"\n  shows \"U' x y = (\\<Sum>i. ennreal (u x y i * Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))", "have \"(\\<integral>\\<^sup>+\\<omega>. eSuc (sfirst (HLD {y}) \\<omega>) \\<partial>T x) =\n      (\\<integral>\\<^sup>+\\<omega>. (\\<Sum>i. ennreal (Suc i) * indicator {\\<omega>\\<in>space (T y). ev_at (HLD {y}) i \\<omega>} \\<omega>) \\<partial>T x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                       \\<partial>T x =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              \\<omega>)\n                       \\<partial>T x", "using sfirst_finiteI_recurrent[OF x]"], ["proof (prove)\nusing this:\n  AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                       \\<partial>T x =\n    \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              \\<omega>)\n                       \\<partial>T x", "proof (intro nn_integral_cong_AE, eventually_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>;\n        sfirst (HLD {y}) xa < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> ennreal_of_enat (eSuc (sfirst (HLD {y}) xa)) =\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              xa)", "fix \\<omega>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>;\n        sfirst (HLD {y}) xa < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> ennreal_of_enat (eSuc (sfirst (HLD {y}) xa)) =\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              xa)", "assume \"sfirst (HLD {y}) \\<omega> < \\<infinity>\""], ["proof (state)\nthis:\n  sfirst (HLD {y}) \\<omega> < \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>;\n        sfirst (HLD {y}) xa < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> ennreal_of_enat (eSuc (sfirst (HLD {y}) xa)) =\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              xa)", "then"], ["proof (chain)\npicking this:\n  sfirst (HLD {y}) \\<omega> < \\<infinity>", "obtain n :: nat where [simp]: \"sfirst (HLD {y}) \\<omega> = n\""], ["proof (prove)\nusing this:\n  sfirst (HLD {y}) \\<omega> < \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        sfirst (HLD {y}) \\<omega> = enat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sfirst (HLD {y}) \\<omega> = enat n\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>AE \\<omega> in T x. sfirst (HLD {y}) \\<omega> < \\<infinity>;\n        sfirst (HLD {y}) xa < \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> ennreal_of_enat (eSuc (sfirst (HLD {y}) xa)) =\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              xa)", "show \"eSuc (sfirst (HLD {y}) \\<omega>) = (\\<Sum>i. ennreal (Suc i) * indicator {\\<omega>\\<in>space (T y). ev_at (HLD {y}) i \\<omega>} \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal_of_enat (eSuc (sfirst (HLD {y}) \\<omega>)) =\n    (\\<Sum>i.\n        ennreal (real (Suc i)) *\n        indicator {\\<omega> \\<in> space (T y). ev_at (HLD {y}) i \\<omega>}\n         \\<omega>)", "by (subst suminf_cmult_indicator[where i=n])\n         (auto simp: disjoint_family_on_def ev_at_unique space_stream_space\n                     sfirst_eq_enat_iff[symmetric] ennreal_of_nat_eq_real_of_nat\n               split: split_indicator)"], ["proof (state)\nthis:\n  ennreal_of_enat (eSuc (sfirst (HLD {y}) \\<omega>)) =\n  (\\<Sum>i.\n      ennreal (real (Suc i)) *\n      indicator {\\<omega> \\<in> space (T y). ev_at (HLD {y}) i \\<omega>}\n       \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                     \\<partial>T x =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sum>i.\n                           ennreal (real (Suc i)) *\n                           indicator\n                            {\\<omega> \\<in> space (T y).\n                             ev_at (HLD {y}) i \\<omega>}\n                            \\<omega>)\n                     \\<partial>T x\n\ngoal (1 subgoal):\n 1. U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                     \\<partial>T x =\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sum>i.\n                           ennreal (real (Suc i)) *\n                           indicator\n                            {\\<omega> \\<in> space (T y).\n                             ev_at (HLD {y}) i \\<omega>}\n                            \\<omega>)\n                     \\<partial>T x\n\ngoal (1 subgoal):\n 1. U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))", "have \"\\<dots> = (\\<Sum>i. ennreal (Suc i) * emeasure (T x) {\\<omega>\\<in>space (T x). ev_at (HLD {y}) i \\<omega>})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ \\<omega>.\n                         (\\<Sum>i.\n                             ennreal (real (Suc i)) *\n                             indicator\n                              {\\<omega> \\<in> space (T y).\n                               ev_at (HLD {y}) i \\<omega>}\n                              \\<omega>)\n                       \\<partial>T x =\n    (\\<Sum>i.\n        ennreal (real (Suc i)) *\n        emeasure (T x)\n         {\\<omega> \\<in> space (T x). ev_at (HLD {y}) i \\<omega>})", "by (subst nn_integral_suminf)\n       (auto intro!: arg_cong[where f=suminf] nn_integral_cmult_indicator simp: fun_eq_iff)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ \\<omega>.\n                       (\\<Sum>i.\n                           ennreal (real (Suc i)) *\n                           indicator\n                            {\\<omega> \\<in> space (T y).\n                             ev_at (HLD {y}) i \\<omega>}\n                            \\<omega>)\n                     \\<partial>T x =\n  (\\<Sum>i.\n      ennreal (real (Suc i)) *\n      emeasure (T x)\n       {\\<omega> \\<in> space (T x). ev_at (HLD {y}) i \\<omega>})\n\ngoal (1 subgoal):\n 1. U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                     \\<partial>T x =\n  (\\<Sum>i.\n      ennreal (real (Suc i)) *\n      emeasure (T x)\n       {\\<omega> \\<in> space (T x). ev_at (HLD {y}) i \\<omega>})", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                     \\<partial>T x =\n  (\\<Sum>i.\n      ennreal (real (Suc i)) *\n      emeasure (T x)\n       {\\<omega> \\<in> space (T x). ev_at (HLD {y}) i \\<omega>})\n\ngoal (1 subgoal):\n 1. U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))", "by (simp add: U'_def u_def T.emeasure_eq_measure mult_ac ennreal_mult)"], ["proof (state)\nthis:\n  U' x y = (\\<Sum>i. ennreal (u x y i * real (Suc i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_U'_tendsto_U':\n  assumes x: \"recurrent x\" \"(x, y) \\<in> acc\"\n  shows \"((\\<lambda>z. ennreal (gf_U' x y z)) \\<longlongrightarrow> U' x y) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (gf_U' x y z)) \\<longlongrightarrow> U' x y)\n     (at_left 1)", "unfolding U'_eq_suminf[OF x] gf_U'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         ennreal\n          (\\<Sum>n. u x y n * real (Suc n) * z ^ n)) \\<longlongrightarrow>\n     (\\<Sum>i. ennreal (u x y i * real (Suc i))))\n     (at_left 1)", "by (auto intro!: power_series_tendsto_at_left summable_gf_U' mult_nonneg_nonneg u_nonneg simp del: of_nat_Suc)"], ["", "lemma one_le_integral_t:\n  assumes x: \"recurrent x\" shows \"1 \\<le> U' x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> U' x x", "by (simp add: nn_integral_add T.emeasure_space_1 U'_def del: space_T)"], ["", "lemma gf_U'_pos:\n  fixes z :: real\n  assumes z: \"0 < z\" \"z < 1\" and \"U x y \\<noteq> 0\"\n  shows \"0 < gf_U' x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gf_U' x y z", "unfolding gf_U'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>n. u x y n * real (Suc n) * z ^ n)", "proof (subst suminf_pos_iff)"], ["proof (state)\ngoal (3 subgoals):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)\n 2. \\<And>n. 0 \\<le> u x y n * real (Suc n) * z ^ n\n 3. \\<exists>i. 0 < u x y i * real (Suc i) * z ^ i", "show \"summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)", "by (intro summable_gf_U') simp"], ["proof (state)\nthis:\n  summable (\\<lambda>n. u x y n * real (Suc n) * z ^ n)\n\ngoal (2 subgoals):\n 1. \\<And>n. 0 \\<le> u x y n * real (Suc n) * z ^ n\n 2. \\<exists>i. 0 < u x y i * real (Suc i) * z ^ i", "show pos: \"\\<And>n. 0 \\<le> u x y n * real (Suc n) * z ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. 0 \\<le> u x y n * real (Suc n) * z ^ n", "using u_nonneg z"], ["proof (prove)\nusing this:\n  0 \\<le> u ?x ?y ?n\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<And>n. 0 \\<le> u x y n * real (Suc n) * z ^ n", "by auto"], ["proof (state)\nthis:\n  0 \\<le> u x y ?n4 * real (Suc ?n4) * z ^ ?n4\n\ngoal (1 subgoal):\n 1. \\<exists>i. 0 < u x y i * real (Suc i) * z ^ i", "show \"\\<exists>n. 0 < u x y n * real (Suc n) * z ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. 0 < u x y n * real (Suc n) * z ^ n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>n. 0 < u x y n * real (Suc n) * z ^ n)\""], ["proof (state)\nthis:\n  \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n\n\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n \\<Longrightarrow> False", "with pos"], ["proof (chain)\npicking this:\n  0 \\<le> u x y ?n4 * real (Suc ?n4) * z ^ ?n4\n  \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n", "have \"\\<forall>n. u x y n * real (Suc n) * z ^ n = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> u x y ?n4 * real (Suc ?n4) * z ^ ?n4\n  \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n\n\ngoal (1 subgoal):\n 1. \\<forall>n. u x y n * real (Suc n) * z ^ n = 0", "by (intro antisym allI) (simp_all add: not_less)"], ["proof (state)\nthis:\n  \\<forall>n. u x y n * real (Suc n) * z ^ n = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n \\<Longrightarrow> False", "with z"], ["proof (chain)\npicking this:\n  0 < z\n  z < 1\n  \\<forall>n. u x y n * real (Suc n) * z ^ n = 0", "have \"u x y = (\\<lambda>n. 0)\""], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n  \\<forall>n. u x y n * real (Suc n) * z ^ n = 0\n\ngoal (1 subgoal):\n 1. u x y = (\\<lambda>n. 0)", "by (intro ext) simp"], ["proof (state)\nthis:\n  u x y = (\\<lambda>n. 0)\n\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < u x y n * real (Suc n) * z ^ n \\<Longrightarrow> False", "with u_sums_U[of x y, THEN sums_unique] \\<open>U x y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  U x y = suminf (u x y)\n  U x y \\<noteq> 0\n  u x y = (\\<lambda>n. 0)", "show False"], ["proof (prove)\nusing this:\n  U x y = suminf (u x y)\n  U x y \\<noteq> 0\n  u x y = (\\<lambda>n. 0)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. 0 < u x y n * real (Suc n) * z ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_gf_U'_tendsto:\n  assumes \"recurrent y\"\n  shows \"((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow> enn2real (1 / U' y y)) (at_left (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "assume inf: \"U' y y = \\<infinity>\""], ["proof (state)\nthis:\n  U' y y = \\<infinity>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "with gf_U'_tendsto_U'[of y y] \\<open>recurrent y\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>recurrent y; (y, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>z.\n                         ennreal (gf_U' y y z)) \\<longlongrightarrow>\n                     U' y y)\n                     (at_left 1)\n  recurrent y\n  U' y y = \\<infinity>", "have \"LIM z (at_left 1). gf_U' y y z :> at_top\""], ["proof (prove)\nusing this:\n  \\<lbrakk>recurrent y; (y, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>z.\n                         ennreal (gf_U' y y z)) \\<longlongrightarrow>\n                     U' y y)\n                     (at_left 1)\n  recurrent y\n  U' y y = \\<infinity>\n\ngoal (1 subgoal):\n 1. filterlim (gf_U' y y) at_top (at_left 1)", "by (auto simp: ennreal_tendsto_top_eq_at_top U'_def)"], ["proof (state)\nthis:\n  filterlim (gf_U' y y) at_top (at_left 1)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  filterlim (gf_U' y y) at_top (at_left 1)", "have \"LIM z (at_left 1). gf_U' y y z :> at_infinity\""], ["proof (prove)\nusing this:\n  filterlim (gf_U' y y) at_top (at_left 1)\n\ngoal (1 subgoal):\n 1. filterlim (gf_U' y y) at_infinity (at_left 1)", "by (rule filterlim_mono) (auto simp: at_top_le_at_infinity)"], ["proof (state)\nthis:\n  filterlim (gf_U' y y) at_infinity (at_left 1)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)\n 2. \\<not> ?P \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "with inf"], ["proof (chain)\npicking this:\n  U' y y = \\<infinity>\n  filterlim (gf_U' y y) at_infinity (at_left 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  U' y y = \\<infinity>\n  filterlim (gf_U' y y) at_infinity (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "by (auto intro!: tendsto_divide_0)"], ["proof (state)\nthis:\n  ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n   enn2real (1 / U' y y))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "assume fin: \"U' y y \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  U' y y \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  U' y y \\<noteq> \\<infinity>", "obtain r where r: \"U' y y = ennreal r\" and [simp]: \"0 \\<le> r\""], ["proof (prove)\nusing this:\n  U' y y \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>U' y y = ennreal r; 0 \\<le> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"U' y y\") (auto simp: U'_def)"], ["proof (state)\nthis:\n  U' y y = ennreal r\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  U' y y = ennreal r\n  0 \\<le> r", "have eq: \"enn2real (1 / U' y y) = - 1 / - r\" and \"1 \\<le> r\""], ["proof (prove)\nusing this:\n  U' y y = ennreal r\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. enn2real (1 / U' y y) = - 1 / - r &&& 1 \\<le> r", "using one_le_integral_t[OF \\<open>recurrent y\\<close>]"], ["proof (prove)\nusing this:\n  U' y y = ennreal r\n  0 \\<le> r\n  1 \\<le> U' y y\n\ngoal (1 subgoal):\n 1. enn2real (1 / U' y y) = - 1 / - r &&& 1 \\<le> r", "by (auto simp add: ennreal_1[symmetric] divide_ennreal simp del: ennreal_1)"], ["proof (state)\nthis:\n  enn2real (1 / U' y y) = - 1 / - r\n  1 \\<le> r\n\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "have \"((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> ennreal r) (at_left 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> ennreal r)\n     (at_left 1)", "using gf_U'_tendsto_U'[OF \\<open>recurrent y\\<close>, of y] r"], ["proof (prove)\nusing this:\n  (y, y) \\<in> acc \\<Longrightarrow>\n  ((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> U' y y)\n   (at_left 1)\n  U' y y = ennreal r\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> ennreal r)\n     (at_left 1)", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> ennreal r)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> ennreal r)\n   (at_left 1)", "have gf_U': \"(gf_U' y y \\<longlongrightarrow> r) (at_left (1::real))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. ennreal (gf_U' y y z)) \\<longlongrightarrow> ennreal r)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U' y y \\<longlongrightarrow> r) (at_left 1)", "by (rule tendsto_ennrealD)\n       (insert summable_gf_U', auto intro!: eventually_at_left_1 suminf_nonneg simp: gf_U'_def u_nonneg)"], ["proof (state)\nthis:\n  (gf_U' y y \\<longlongrightarrow> r) (at_left 1)\n\ngoal (1 subgoal):\n 1. U' y y \\<noteq> \\<infinity> \\<Longrightarrow>\n    ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "using \\<open>1 \\<le> r\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> r\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "unfolding eq"], ["proof (prove)\nusing this:\n  1 \\<le> r\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow> - 1 / - r)\n     (at_left 1)", "by (intro tendsto_intros gf_U') simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n   enn2real (1 / U' y y))\n   (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gf_G_pos:\n  fixes z :: real\n  assumes z: \"0 < z\" \"z < 1\" and *: \"(x, y) \\<in> acc\"\n  shows \"0 < gf_G x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gf_G x y z", "unfolding gf_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < (\\<Sum>n. p x y n *\\<^sub>R z ^ n)", "proof (subst suminf_pos_iff)"], ["proof (state)\ngoal (3 subgoals):\n 1. summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)\n 2. \\<And>n. 0 \\<le> p x y n *\\<^sub>R z ^ n\n 3. \\<exists>i. 0 < p x y i *\\<^sub>R z ^ i", "show \"summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)", "by (intro convergence_G convergence_G_less_1) simp"], ["proof (state)\nthis:\n  summable (\\<lambda>n. p x y n *\\<^sub>R z ^ n)\n\ngoal (2 subgoals):\n 1. \\<And>n. 0 \\<le> p x y n *\\<^sub>R z ^ n\n 2. \\<exists>i. 0 < p x y i *\\<^sub>R z ^ i", "show pos: \"\\<And>n. 0 \\<le> p x y n *\\<^sub>R z ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. 0 \\<le> p x y n *\\<^sub>R z ^ n", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<And>n. 0 \\<le> p x y n *\\<^sub>R z ^ n", "by (auto intro!: mult_nonneg_nonneg p_nonneg)"], ["proof (state)\nthis:\n  0 \\<le> p x y ?n4 *\\<^sub>R z ^ ?n4\n\ngoal (1 subgoal):\n 1. \\<exists>i. 0 < p x y i *\\<^sub>R z ^ i", "show \"\\<exists>n. 0 < p x y n *\\<^sub>R z ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. 0 < p x y n *\\<^sub>R z ^ n", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n \\<Longrightarrow> False", "assume \"\\<not> (\\<exists>n. 0 < p x y n *\\<^sub>R z ^ n)\""], ["proof (state)\nthis:\n  \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n\n\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n \\<Longrightarrow> False", "with pos"], ["proof (chain)\npicking this:\n  0 \\<le> p x y ?n4 *\\<^sub>R z ^ ?n4\n  \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n", "have \"\\<forall>n. p x y n * z ^ n = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> p x y ?n4 *\\<^sub>R z ^ ?n4\n  \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n\n\ngoal (1 subgoal):\n 1. \\<forall>n. p x y n * z ^ n = 0", "by (intro antisym allI) (simp_all add: not_less)"], ["proof (state)\nthis:\n  \\<forall>n. p x y n * z ^ n = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n \\<Longrightarrow> False", "with z"], ["proof (chain)\npicking this:\n  0 < z\n  z < 1\n  \\<forall>n. p x y n * z ^ n = 0", "have \"\\<And>n. p x y n = 0\""], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n  \\<forall>n. p x y n * z ^ n = 0\n\ngoal (1 subgoal):\n 1. \\<And>n. p x y n = 0", "by simp"], ["proof (state)\nthis:\n  p x y ?n4 = 0\n\ngoal (1 subgoal):\n 1. \\<nexists>n. 0 < p x y n *\\<^sub>R z ^ n \\<Longrightarrow> False", "with *[THEN accD_pos]"], ["proof (chain)\npicking this:\n  \\<exists>n. 0 < p x y n\n  p x y ?n4 = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>n. 0 < p x y n\n  p x y ?n4 = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. 0 < p x y n *\\<^sub>R z ^ n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_recurrentI_communicating:\n  assumes y: \"pos_recurrent y\" and x: \"(y, x) \\<in> communicating\"\n  shows \"pos_recurrent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pos_recurrent x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pos_recurrent x", "from y x"], ["proof (chain)\npicking this:\n  pos_recurrent y\n  (y, x) \\<in> communicating", "have recurrent: \"recurrent y\" \"recurrent x\" and fin: \"U' y y \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  pos_recurrent y\n  (y, x) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (recurrent y &&& recurrent x) &&& U' y y \\<noteq> \\<infinity>", "by (auto simp: pos_recurrent_def recurrent_iffI_communicating nn_integral_add)"], ["proof (state)\nthis:\n  recurrent y\n  recurrent x\n  U' y y \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "have pos: \"0 < enn2real (1 / U' y y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < enn2real (1 / U' y y)", "using one_le_integral_t[OF \\<open>recurrent y\\<close>] fin"], ["proof (prove)\nusing this:\n  1 \\<le> U' y y\n  U' y y \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. 0 < enn2real (1 / U' y y)", "by (auto simp: U'_def enn2real_positive_iff less_top[symmetric] ennreal_zero_less_divide ennreal_divide_eq_top_iff)"], ["proof (state)\nthis:\n  0 < enn2real (1 / U' y y)\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "from fin"], ["proof (chain)\npicking this:\n  U' y y \\<noteq> \\<infinity>", "obtain r where r: \"U' y y = ennreal r\" and [simp]: \"0 \\<le> r\""], ["proof (prove)\nusing this:\n  U' y y \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>U' y y = ennreal r; 0 \\<le> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"U' y y\") (auto simp: U'_def)"], ["proof (state)\nthis:\n  U' y y = ennreal r\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "from x"], ["proof (chain)\npicking this:\n  (y, x) \\<in> communicating", "obtain n m where \"0 < p x y n\" \"0 < p y x m\""], ["proof (prove)\nusing this:\n  (y, x) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>0 < p x y n; 0 < p y x m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: accD_pos simp: communicating_def)"], ["proof (state)\nthis:\n  0 < p x y n\n  0 < p y x m\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "let ?L = \"at_left (1::real)\""], ["proof (state)\ngoal (1 subgoal):\n 1. pos_recurrent x", "have le: \"eventually (\\<lambda>z. p x y n * p y x m * z^(n + m) \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1.\n       p x y n * p y x m * z ^ (n + m)\n       \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "proof (rule eventually_at_left_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "fix z :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "assume z: \"0 < z\" \"z < 1\""], ["proof (state)\nthis:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "then"], ["proof (chain)\npicking this:\n  0 < z\n  z < 1", "have conv: \"\\<And>x. convergence_G x x z\""], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<And>x. convergence_G x x z", "by (intro convergence_G_less_1) simp"], ["proof (state)\nthis:\n  convergence_G ?x4 ?x4 z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "have sums: \"(\\<lambda>i. (p x y n * p y x m * z^(n + m)) * (p y y i * z^i)) sums ((p x y n * p y x m * z^(n + m)) * gf_G y y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i)) sums\n    (p x y n * p y x m * z ^ (n + m) * gf_G y y z)", "unfolding gf_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i)) sums\n    (p x y n * p y x m * z ^ (n + m) * (\\<Sum>n. p y y n *\\<^sub>R z ^ n))", "by (intro sums_mult summable_sums) (auto intro!: conv convergence_G[where 'a=real, simplified])"], ["proof (state)\nthis:\n  (\\<lambda>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i)) sums\n  (p x y n * p y x m * z ^ (n + m) * gf_G y y z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "have \"(\\<Sum>i. (p x y n * p y x m * z^(n + m)) * (p y y i * z^i)) \\<le> (\\<Sum>i. p x x (i + (n + m)) * z^(i + (n + m)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n    \\<le> (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))", "proof (intro allI suminf_le sums_summable[OF sums] summable_ignore_initial_segment convergence_G[where 'a=real, simplified] convergence_G_less_1)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na.\n       p x y n * p y x m * z ^ (n + m) * (p y y na * z ^ na)\n       \\<le> p x x (na + (n + m)) * z ^ (na + (n + m))\n 2. norm z < 1", "show \"norm z < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm z < 1", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. norm z < 1", "by simp"], ["proof (state)\nthis:\n  norm z < 1\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       p x y n * p y x m * z ^ (n + m) * (p y y na * z ^ na)\n       \\<le> p x x (na + (n + m)) * z ^ (na + (n + m))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       p x y n * p y x m * z ^ (n + m) * (p y y na * z ^ na)\n       \\<le> p x x (na + (n + m)) * z ^ (na + (n + m))", "have \"(p x y n * p y y ((n + i) - n)) * p y x ((n + i + m) - (n + i)) \\<le> p x y (n + i) * p y x ((n + i + m) - (n + i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n    \\<le> p x y (n + i) * p y x (n + i + m - (n + i))", "by (intro mult_right_mono prob_reachable_le) simp_all"], ["proof (state)\nthis:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x y (n + i) * p y x (n + i + m - (n + i))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       p x y n * p y x m * z ^ (n + m) * (p y y na * z ^ na)\n       \\<le> p x x (na + (n + m)) * z ^ (na + (n + m))", "also"], ["proof (state)\nthis:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x y (n + i) * p y x (n + i + m - (n + i))\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       p x y n * p y x m * z ^ (n + m) * (p y y na * z ^ na)\n       \\<le> p x x (na + (n + m)) * z ^ (na + (n + m))", "have \"\\<dots> \\<le> p x x (n + i + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y (n + i) * p y x (n + i + m - (n + i)) \\<le> p x x (n + i + m)", "by (intro prob_reachable_le) simp_all"], ["proof (state)\nthis:\n  p x y (n + i) * p y x (n + i + m - (n + i)) \\<le> p x x (n + i + m)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       p x y n * p y x m * z ^ (n + m) * (p y y na * z ^ na)\n       \\<le> p x x (na + (n + m)) * z ^ (na + (n + m))", "finally"], ["proof (chain)\npicking this:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x x (n + i + m)", "show \"p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i) \\<le> p x x (i + (n + m)) * z ^ (i + (n + m))\""], ["proof (prove)\nusing this:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x x (n + i + m)\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i)\n    \\<le> p x x (i + (n + m)) * z ^ (i + (n + m))", "using z"], ["proof (prove)\nusing this:\n  p x y n * p y y (n + i - n) * p y x (n + i + m - (n + i))\n  \\<le> p x x (n + i + m)\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i)\n    \\<le> p x x (i + (n + m)) * z ^ (i + (n + m))", "by (auto simp add: ac_simps power_add intro!: mult_left_mono)"], ["proof (state)\nthis:\n  p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i)\n  \\<le> p x x (i + (n + m)) * z ^ (i + (n + m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n  \\<le> (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n  \\<le> (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "have \"\\<dots> \\<le> gf_G x x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m))) \\<le> gf_G x x z", "unfolding gf_G_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))\n    \\<le> (\\<Sum>n. p x x n *\\<^sub>R z ^ n)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))\n    \\<le> (\\<Sum>n. p x x n *\\<^sub>R z ^ n)", "apply (subst (2) suminf_split_initial_segment[where k=\"n + m\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < z; z < 1\\<rbrakk>\n    \\<Longrightarrow> summable (\\<lambda>n. p x x n *\\<^sub>R z ^ n)\n 2. \\<lbrakk>0 < z; z < 1\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))\n                      \\<le> (\\<Sum>na.\n                                p x x (na + (n + m)) *\\<^sub>R\n                                z ^ (na + (n + m))) +\n                            (\\<Sum>i<n + m. p x x i *\\<^sub>R z ^ i)", "apply (intro convergence_G conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; z < 1\\<rbrakk>\n    \\<Longrightarrow> (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m)))\n                      \\<le> (\\<Sum>na.\n                                p x x (na + (n + m)) *\\<^sub>R\n                                z ^ (na + (n + m))) +\n                            (\\<Sum>i<n + m. p x x i *\\<^sub>R z ^ i)", "apply (simp add: sum_nonneg)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>i. p x x (i + (n + m)) * z ^ (i + (n + m))) \\<le> gf_G x x z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n  \\<le> gf_G x x z", "have \"(p x y n * p y x m * z^(n + m)) * gf_G y y z \\<le> gf_G x x z\""], ["proof (prove)\nusing this:\n  (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n  \\<le> gf_G x x z\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m) * gf_G y y z \\<le> gf_G x x z", "using sums_unique[OF sums]"], ["proof (prove)\nusing this:\n  (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n  \\<le> gf_G x x z\n  p x y n * p y x m * z ^ (n + m) * gf_G y y z =\n  (\\<Sum>i. p x y n * p y x m * z ^ (n + m) * (p y y i * z ^ i))\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m) * gf_G y y z \\<le> gf_G x x z", "by simp"], ["proof (state)\nthis:\n  p x y n * p y x m * z ^ (n + m) * gf_G y y z \\<le> gf_G x x z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "then"], ["proof (chain)\npicking this:\n  p x y n * p y x m * z ^ (n + m) * gf_G y y z \\<le> gf_G x x z", "have \"(p x y n * p y x m * z^(n + m)) \\<le> gf_G x x z / gf_G y y z\""], ["proof (prove)\nusing this:\n  p x y n * p y x m * z ^ (n + m) * gf_G y y z \\<le> gf_G x x z\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m) \\<le> gf_G x x z / gf_G y y z", "using z gf_G_pos[of z y y]"], ["proof (prove)\nusing this:\n  p x y n * p y x m * z ^ (n + m) * gf_G y y z \\<le> gf_G x x z\n  0 < z\n  z < 1\n  \\<lbrakk>0 < z; z < 1; (y, y) \\<in> acc\\<rbrakk>\n  \\<Longrightarrow> 0 < gf_G y y z\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m) \\<le> gf_G x x z / gf_G y y z", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  p x y n * p y x m * z ^ (n + m) \\<le> gf_G x x z / gf_G y y z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "also"], ["proof (state)\nthis:\n  p x y n * p y x m * z ^ (n + m) \\<le> gf_G x x z / gf_G y y z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "have \"\\<dots> = (1 - gf_U y y z) / (1 - gf_U x x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gf_G x x z / gf_G y y z = (1 - gf_U y y z) / (1 - gf_U x x z)", "unfolding gf_G_eq_gf_U[OF conv]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / (1 - gf_U x x z) / (1 / (1 - gf_U y y z)) =\n    (1 - gf_U y y z) / (1 - gf_U x x z)", "using gf_G_eq_gf_U(2)[OF conv]"], ["proof (prove)\nusing this:\n  gf_U ?x ?x z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 / (1 - gf_U x x z) / (1 / (1 - gf_U y y z)) =\n    (1 - gf_U y y z) / (1 - gf_U x x z)", "by (simp add: field_simps )"], ["proof (state)\nthis:\n  gf_G x x z / gf_G y y z = (1 - gf_U y y z) / (1 - gf_U x x z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> p x y n * p y x m * z ^ (n + m)\n                         \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "finally"], ["proof (chain)\npicking this:\n  p x y n * p y x m * z ^ (n + m) \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "show \"p x y n * p y x m * z^(n + m) \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)\""], ["proof (prove)\nusing this:\n  p x y n * p y x m * z ^ (n + m) \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)\n\ngoal (1 subgoal):\n 1. p x y n * p y x m * z ^ (n + m)\n    \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)", "."], ["proof (state)\nthis:\n  p x y n * p y x m * z ^ (n + m) \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_left 1.\n     p x y n * p y x m * z ^ (n + m)\n     \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "have \"U' x x \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U' x x \\<noteq> \\<infinity>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. U' x x = \\<infinity> \\<Longrightarrow> False", "assume \"U' x x = \\<infinity>\""], ["proof (state)\nthis:\n  U' x x = \\<infinity>\n\ngoal (1 subgoal):\n 1. U' x x = \\<infinity> \\<Longrightarrow> False", "have \"((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow>\n     0)\n     (at_left 1)", "proof (rule lhopital_left)"], ["proof (state)\ngoal (7 subgoals):\n 1. ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 2. ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 0) (at_left 1)\n 3. \\<forall>\\<^sub>F z in at_left 1. 1 - gf_U x x z \\<noteq> 0\n 4. \\<forall>\\<^sub>F z in at_left 1. ?g' z \\<noteq> 0\n 5. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?f' z) (at z)\n 6. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative ?g' z) (at z)\n 7. ((\\<lambda>z. ?f' z / ?g' z) \\<longlongrightarrow> 0) (at_left 1)", "show \"((\\<lambda>z. 1 - gf_U y y z) \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. 1 - gf_U y y z) \\<longlongrightarrow> 0) (at_left 1)", "using gf_U[of y] recurrent_iff_U_eq_1[of y] \\<open>recurrent y\\<close>"], ["proof (prove)\nusing this:\n  (gf_U y ?y \\<longlongrightarrow> U y ?y) (at_left 1)\n  recurrent y = (U y y = 1)\n  recurrent y\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. 1 - gf_U y y z) \\<longlongrightarrow> 0) (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>z. 1 - gf_U y y z) \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (6 subgoals):\n 1. ((\\<lambda>xa. 1 - gf_U x x xa) \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<forall>\\<^sub>F z in at_left 1. 1 - gf_U x x z \\<noteq> 0\n 3. \\<forall>\\<^sub>F z in at_left 1. ?g' z \\<noteq> 0\n 4. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?f' z) (at z)\n 5. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative ?g' z) (at z)\n 6. ((\\<lambda>z. ?f' z / ?g' z) \\<longlongrightarrow> 0) (at_left 1)", "show \"((\\<lambda>z. 1 - gf_U x x z) \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. 1 - gf_U x x z) \\<longlongrightarrow> 0) (at_left 1)", "using gf_U[of x] recurrent_iff_U_eq_1[of x] \\<open>recurrent x\\<close>"], ["proof (prove)\nusing this:\n  (gf_U x ?y \\<longlongrightarrow> U x ?y) (at_left 1)\n  recurrent x = (U x x = 1)\n  recurrent x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. 1 - gf_U x x z) \\<longlongrightarrow> 0) (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>z. 1 - gf_U x x z) \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (5 subgoals):\n 1. \\<forall>\\<^sub>F z in at_left 1. 1 - gf_U x x z \\<noteq> 0\n 2. \\<forall>\\<^sub>F z in at_left 1. ?g' z \\<noteq> 0\n 3. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?f' z) (at z)\n 4. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative ?g' z) (at z)\n 5. ((\\<lambda>z. ?f' z / ?g' z) \\<longlongrightarrow> 0) (at_left 1)", "show \"eventually (\\<lambda>z. 1 - gf_U x x z \\<noteq> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1. 1 - gf_U x x z \\<noteq> 0", "by (auto intro!: eventually_at_left_1 simp: gf_G_eq_gf_U(2) convergence_G_less_1)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_left 1. 1 - gf_U x x z \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F z in at_left 1. ?g' z \\<noteq> 0\n 2. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?f' z) (at z)\n 3. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative ?g' z) (at z)\n 4. ((\\<lambda>z. ?f' z / ?g' z) \\<longlongrightarrow> 0) (at_left 1)", "show \"eventually (\\<lambda>z. - gf_U' x x z \\<noteq> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1. - gf_U' x x z \\<noteq> 0", "using gf_U'_pos[of _ x x] recurrent_iff_U_eq_1[of x] \\<open>recurrent x\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?z; ?z < 1; U x x \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> 0 < gf_U' x x ?z\n  recurrent x = (U x x = 1)\n  recurrent x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1. - gf_U' x x z \\<noteq> 0", "by (auto intro!: eventually_at_left_1) (metis less_le)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_left 1. - gf_U' x x z \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?f' z) (at z)\n 2. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative - gf_U' x x z)\n        (at z)\n 3. ((\\<lambda>z. ?f' z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "show \"eventually (\\<lambda>z. DERIV (\\<lambda>xa. 1 - gf_U x x xa) z :> - gf_U' x x z) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative - gf_U' x x z)\n        (at z)", "by (auto intro!: eventually_at_left_1 derivative_eq_intros DERIV_gf_U)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_left 1.\n     ((\\<lambda>xa. 1 - gf_U x x xa) has_real_derivative - gf_U' x x z)\n      (at z)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?f' z) (at z)\n 2. ((\\<lambda>z. ?f' z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "show \"eventually (\\<lambda>z. DERIV (\\<lambda>xa. 1 - gf_U y y xa) z :> - gf_U' y y z) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F z in at_left 1.\n       ((\\<lambda>xa. 1 - gf_U y y xa) has_real_derivative - gf_U' y y z)\n        (at z)", "by (auto intro!: eventually_at_left_1 derivative_eq_intros DERIV_gf_U)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F z in at_left 1.\n     ((\\<lambda>xa. 1 - gf_U y y xa) has_real_derivative - gf_U' y y z)\n      (at z)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "have \"(gf_U' y y \\<longlongrightarrow> U' y y) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ennreal (gf_U' y y x)) \\<longlongrightarrow> U' y y)\n     (at_left 1)", "using \\<open>recurrent y\\<close>"], ["proof (prove)\nusing this:\n  recurrent y\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. ennreal (gf_U' y y x)) \\<longlongrightarrow> U' y y)\n     (at_left 1)", "by (rule gf_U'_tendsto_U') simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. ennreal (gf_U' y y x)) \\<longlongrightarrow> U' y y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. ennreal (gf_U' y y x)) \\<longlongrightarrow> U' y y)\n   (at_left 1)", "have *: \"(gf_U' y y \\<longlongrightarrow> r) ?L\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. ennreal (gf_U' y y x)) \\<longlongrightarrow> U' y y)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (gf_U' y y \\<longlongrightarrow> r) (at_left 1)", "by (auto simp add: r eventually_at_left_1 dest!: tendsto_ennrealD)"], ["proof (state)\nthis:\n  (gf_U' y y \\<longlongrightarrow> r) (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "moreover"], ["proof (state)\nthis:\n  (gf_U' y y \\<longlongrightarrow> r) (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "have \"(gf_U' x x \\<longlongrightarrow> U' x x) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>xa. ennreal (gf_U' x x xa)) \\<longlongrightarrow> U' x x)\n     (at_left 1)", "using \\<open>recurrent x\\<close>"], ["proof (prove)\nusing this:\n  recurrent x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>xa. ennreal (gf_U' x x xa)) \\<longlongrightarrow> U' x x)\n     (at_left 1)", "by (rule gf_U'_tendsto_U') simp"], ["proof (state)\nthis:\n  ((\\<lambda>xa. ennreal (gf_U' x x xa)) \\<longlongrightarrow> U' x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>xa. ennreal (gf_U' x x xa)) \\<longlongrightarrow> U' x x)\n   (at_left 1)", "have \"LIM z ?L. - gf_U' x x z :> at_bot\""], ["proof (prove)\nusing this:\n  ((\\<lambda>xa. ennreal (gf_U' x x xa)) \\<longlongrightarrow> U' x x)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. LIM z at_left 1. - gf_U' x x z :> at_bot", "by (simp add: ennreal_tendsto_top_eq_at_top \\<open>U' x x = \\<infinity>\\<close> filterlim_uminus_at_top\n                 del: ennreal_of_enat_eSuc)"], ["proof (state)\nthis:\n  LIM z at_left 1. - gf_U' x x z :> at_bot\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "then"], ["proof (chain)\npicking this:\n  LIM z at_left 1. - gf_U' x x z :> at_bot", "have \"LIM z ?L. - gf_U' x x z :> at_infinity\""], ["proof (prove)\nusing this:\n  LIM z at_left 1. - gf_U' x x z :> at_bot\n\ngoal (1 subgoal):\n 1. LIM z at_left 1. - gf_U' x x z :> at_infinity", "by (rule filterlim_mono) (auto simp: at_bot_le_at_infinity)"], ["proof (state)\nthis:\n  LIM z at_left 1. - gf_U' x x z :> at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "ultimately"], ["proof (chain)\npicking this:\n  (gf_U' y y \\<longlongrightarrow> r) (at_left 1)\n  LIM z at_left 1. - gf_U' x x z :> at_infinity", "show \"((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\nusing this:\n  (gf_U' y y \\<longlongrightarrow> r) (at_left 1)\n  LIM z at_left 1. - gf_U' x x z :> at_infinity\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n     (at_left 1)", "by (intro tendsto_divide_0[where c=\"- r\"] tendsto_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>z. - gf_U' y y z / - gf_U' x x z) \\<longlongrightarrow> 0)\n   (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow>\n   0)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. U' x x = \\<infinity> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  ((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow>\n   0)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. U' x x = \\<infinity> \\<Longrightarrow> False", "have \"((\\<lambda>z. p x y n * p y x m * z^(n + m)) \\<longlongrightarrow> p x y n * p y x m) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. p x y n * p y x m * z ^ (n + m)) \\<longlongrightarrow>\n     p x y n * p y x m)\n     (at_left 1)", "by (auto intro!: tendsto_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>z. p x y n * p y x m * z ^ (n + m)) \\<longlongrightarrow>\n   p x y n * p y x m)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. U' x x = \\<infinity> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow>\n   0)\n   (at_left 1)\n  ((\\<lambda>z. p x y n * p y x m * z ^ (n + m)) \\<longlongrightarrow>\n   p x y n * p y x m)\n   (at_left 1)", "have \"p x y n * p y x m \\<le> 0\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow>\n   0)\n   (at_left 1)\n  ((\\<lambda>z. p x y n * p y x m * z ^ (n + m)) \\<longlongrightarrow>\n   p x y n * p y x m)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. p x y n * p y x m \\<le> 0", "using le"], ["proof (prove)\nusing this:\n  ((\\<lambda>z. (1 - gf_U y y z) / (1 - gf_U x x z)) \\<longlongrightarrow>\n   0)\n   (at_left 1)\n  ((\\<lambda>z. p x y n * p y x m * z ^ (n + m)) \\<longlongrightarrow>\n   p x y n * p y x m)\n   (at_left 1)\n  \\<forall>\\<^sub>F z in at_left 1.\n     p x y n * p y x m * z ^ (n + m)\n     \\<le> (1 - gf_U y y z) / (1 - gf_U x x z)\n\ngoal (1 subgoal):\n 1. p x y n * p y x m \\<le> 0", "by (rule tendsto_le[OF trivial_limit_at_left_real])"], ["proof (state)\nthis:\n  p x y n * p y x m \\<le> 0\n\ngoal (1 subgoal):\n 1. U' x x = \\<infinity> \\<Longrightarrow> False", "with \\<open>0 < p x y n\\<close> \\<open>0 < p y x m\\<close>"], ["proof (chain)\npicking this:\n  0 < p x y n\n  0 < p y x m\n  p x y n * p y x m \\<le> 0", "show False"], ["proof (prove)\nusing this:\n  0 < p x y n\n  0 < p y x m\n  p x y n * p y x m \\<le> 0\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: mult_le_0_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U' x x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "with \\<open>recurrent x\\<close>"], ["proof (chain)\npicking this:\n  recurrent x\n  U' x x \\<noteq> \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  recurrent x\n  U' x x \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. pos_recurrent x", "by (simp add: pos_recurrent_def nn_integral_add)"], ["proof (state)\nthis:\n  pos_recurrent x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_recurrent_iffI_communicating:\n  \"(y, x) \\<in> communicating \\<Longrightarrow> pos_recurrent y \\<longleftrightarrow> pos_recurrent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> communicating \\<Longrightarrow>\n    pos_recurrent y = pos_recurrent x", "using pos_recurrentI_communicating[of x y] pos_recurrentI_communicating[of y x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>pos_recurrent x; (x, y) \\<in> communicating\\<rbrakk>\n  \\<Longrightarrow> pos_recurrent y\n  \\<lbrakk>pos_recurrent y; (y, x) \\<in> communicating\\<rbrakk>\n  \\<Longrightarrow> pos_recurrent x\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> communicating \\<Longrightarrow>\n    pos_recurrent y = pos_recurrent x", "by (auto simp add: communicating_def)"], ["", "lemma U_le_F: \"U x y \\<le> F x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U x y \\<le> F x y", "by (auto simp: U_def F_def intro!: T.finite_measure_mono)"], ["", "lemma not_empty_irreducible: \"C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}", "by (auto simp: quotient_def Image_def communicating_def)"], ["", "subsection \\<open>Stationary distribution\\<close>"], ["", "definition stat :: \"'s set \\<Rightarrow> 's measure\" where\n  \"stat C = point_measure UNIV (\\<lambda>x. indicator C x / U' x x)\""], ["", "lemma sets_stat[simp]: \"sets (stat C) = sets (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sets (stat C) = sets (count_space UNIV)", "by (simp add: stat_def sets_point_measure)"], ["", "lemma space_stat[simp]: \"space (stat C) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. space (stat C) = UNIV", "by (simp add: stat_def space_point_measure)"], ["", "lemma stat_subprob:\n  assumes C: \"essential_class C\" and \"countable C\" and pos: \"\\<forall>c\\<in>C. pos_recurrent c\"\n  shows \"emeasure (stat C) C \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "let ?L = \"at_left (1::real)\""], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "from finite_sequence_to_countable_set[OF \\<open>countable C\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>F.\n      \\<lbrakk>\\<And>i. F i \\<subseteq> C;\n       \\<And>i. F i \\<subseteq> F (Suc i); \\<And>i. finite (F i);\n       \\<Union> (range F) = C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess A"], ["proof (prove)\nusing this:\n  (\\<And>F.\n      \\<lbrakk>\\<And>i. F i \\<subseteq> C;\n       \\<And>i. F i \\<subseteq> F (Suc i); \\<And>i. finite (F i);\n       \\<Union> (range F) = C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  A ?i4 \\<subseteq> C\n  A ?i4 \\<subseteq> A (Suc ?i4)\n  finite (A ?i4)\n  \\<Union> (range A) = C\n\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "note A = this"], ["proof (state)\nthis:\n  A ?i4 \\<subseteq> C\n  A ?i4 \\<subseteq> A (Suc ?i4)\n  finite (A ?i4)\n  \\<Union> (range A) = C\n\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "then"], ["proof (chain)\npicking this:\n  A ?i4 \\<subseteq> C\n  A ?i4 \\<subseteq> A (Suc ?i4)\n  finite (A ?i4)\n  \\<Union> (range A) = C", "have \"(\\<lambda>n. emeasure (stat C) (A n)) \\<longlonglongrightarrow> emeasure (stat C) (\\<Union>i. A i)\""], ["proof (prove)\nusing this:\n  A ?i4 \\<subseteq> C\n  A ?i4 \\<subseteq> A (Suc ?i4)\n  finite (A ?i4)\n  \\<Union> (range A) = C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure (stat C) (A n))\n    \\<longlonglongrightarrow> emeasure (stat C) (\\<Union> (range A))", "by (intro Lim_emeasure_incseq) (auto simp: incseq_Suc_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure (stat C) (A n))\n  \\<longlonglongrightarrow> emeasure (stat C) (\\<Union> (range A))\n\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. emeasure (stat C) (A n))\n  \\<longlonglongrightarrow> emeasure (stat C) (\\<Union> (range A))", "have \"emeasure (stat C) (\\<Union>i. A i) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. emeasure (stat C) (A n))\n  \\<longlonglongrightarrow> emeasure (stat C) (\\<Union> (range A))\n\ngoal (1 subgoal):\n 1. emeasure (stat C) (\\<Union> (range A)) \\<le> 1", "proof (rule LIMSEQ_le[OF _ tendsto_const], intro exI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "from A(1,3)"], ["proof (chain)\npicking this:\n  A ?i4 \\<subseteq> C\n  finite (A ?i4)", "have A_n: \"finite (A n)\""], ["proof (prove)\nusing this:\n  A ?i4 \\<subseteq> C\n  finite (A ?i4)\n\ngoal (1 subgoal):\n 1. finite (A n)", "by auto"], ["proof (state)\nthis:\n  finite (A n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "from C"], ["proof (chain)\npicking this:\n  essential_class C", "have \"C \\<noteq> {}\""], ["proof (prove)\nusing this:\n  essential_class C\n\ngoal (1 subgoal):\n 1. C \\<noteq> {}", "by (simp add: essential_class_def not_empty_irreducible)"], ["proof (state)\nthis:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  C \\<noteq> {}", "obtain x where \"x \\<in> C\""], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "have \"((\\<lambda>z. (\\<Sum>y\\<in>A n. gf_F x y z * ((1 - z) / (1 - gf_U y y z)))) \\<longlongrightarrow> (\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y))) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         \\<Sum>y\\<in>A n.\n           gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n     (\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y)))\n     (at_left 1)", "proof (intro tendsto_intros gf_F, rule lhopital_left)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 7. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "fix y"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 7. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "assume \"y \\<in> A n\""], ["proof (state)\nthis:\n  y \\<in> A n\n\ngoal (7 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 7. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "with \\<open>A n \\<subseteq> C\\<close>"], ["proof (chain)\npicking this:\n  A n \\<subseteq> C\n  y \\<in> A n", "have \"y \\<in> C\""], ["proof (prove)\nusing this:\n  A n \\<subseteq> C\n  y \\<in> A n\n\ngoal (1 subgoal):\n 1. y \\<in> C", "by auto"], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (7 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 7. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "show \"((-) 1 \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((-) 1 \\<longlongrightarrow> 0) (at_left 1)", "by (intro tendsto_eq_intros) simp_all"], ["proof (state)\nthis:\n  ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (6 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "have \"recurrent y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recurrent y", "using pos[THEN bspec, OF \\<open>y\\<in>C\\<close>]"], ["proof (prove)\nusing this:\n  pos_recurrent y\n\ngoal (1 subgoal):\n 1. recurrent y", "by (simp add: pos_recurrent_def)"], ["proof (state)\nthis:\n  recurrent y\n\ngoal (6 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "then"], ["proof (chain)\npicking this:\n  recurrent y", "have \"U y y = 1\""], ["proof (prove)\nusing this:\n  recurrent y\n\ngoal (1 subgoal):\n 1. U y y = 1", "by (simp add: recurrent_iff_U_eq_1)"], ["proof (state)\nthis:\n  U y y = 1\n\ngoal (6 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 6. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "show \"((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)", "using gf_U[of y y] \\<open>U y y = 1\\<close>"], ["proof (prove)\nusing this:\n  (gf_U y y \\<longlongrightarrow> U y y) (at_left 1)\n  U y y = 1\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)", "by (intro tendsto_eq_intros) auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (5 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 5. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "show \"eventually (\\<lambda>x. 1 - gf_U y y x \\<noteq> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0", "using gf_G_eq_gf_U(2)[OF convergence_G_less_1, where 'z=real]"], ["proof (prove)\nusing this:\n  norm ?z < 1 \\<Longrightarrow> gf_U ?x ?x ?z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0", "by (auto intro!: eventually_at_left_1)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "have \"eventually (\\<lambda>x. 0 < gf_U' y y x) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x", "by (intro eventually_at_left_1 gf_U'_pos) (simp_all add: \\<open>U y y = 1\\<close>)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x\n\ngoal (4 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1. ?g'3 y x \\<noteq> 0\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative ?g'3 y x) (at x)\n 4. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / ?g'3 y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x", "show \"eventually (\\<lambda>x. - gf_U' y y x \\<noteq> 0) ?L\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n           (at x)\n 3. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / - gf_U' y y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "show \"eventually (\\<lambda>x. DERIV (\\<lambda>x. 1 - gf_U y y x) x :> - gf_U' y y x) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)", "by (auto intro!: eventually_at_left_1 derivative_eq_intros DERIV_gf_U)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1.\n     ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x) (at x)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       \\<forall>\\<^sub>F x in at_left 1.\n          ((-) 1 has_real_derivative ?f'3 y x) (at x)\n 2. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. ?f'3 y x / - gf_U' y y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "show \"eventually (\\<lambda>x. DERIV ((-) 1) x :> - 1) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)", "by (auto intro!: eventually_at_left_1 derivative_eq_intros)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> A n \\<Longrightarrow>\n       ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n        enn2real (1 / U' y y))\n        (at_left 1)", "show \"((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow> enn2real (1 / U' y y)) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "using \\<open>recurrent y\\<close>"], ["proof (prove)\nusing this:\n  recurrent y\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "by (rule inverse_gf_U'_tendsto)"], ["proof (state)\nthis:\n  ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n   enn2real (1 / U' y y))\n   (at_left 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       \\<Sum>y\\<in>A n.\n         gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n   (\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "also"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       \\<Sum>y\\<in>A n.\n         gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n   (\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "have \"(\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y)) = (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y)) =\n    (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "assume \"y \\<in> A n\""], ["proof (state)\nthis:\n  y \\<in> A n\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "with \\<open>A n \\<subseteq> C\\<close>"], ["proof (chain)\npicking this:\n  A n \\<subseteq> C\n  y \\<in> A n", "have \"y \\<in> C\""], ["proof (prove)\nusing this:\n  A n \\<subseteq> C\n  y \\<in> A n\n\ngoal (1 subgoal):\n 1. y \\<in> C", "by auto"], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "with \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> C\n  y \\<in> C", "have \"(x, y) \\<in> communicating\""], ["proof (prove)\nusing this:\n  x \\<in> C\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> communicating", "by (rule essential_classD3[OF C])"], ["proof (state)\nthis:\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "with \\<open>y\\<in>C\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> C\n  (x, y) \\<in> communicating", "have \"recurrent y\" \"(y, x) \\<in> acc\""], ["proof (prove)\nusing this:\n  y \\<in> C\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. recurrent y &&& (y, x) \\<in> acc", "using pos[THEN bspec, of y]"], ["proof (prove)\nusing this:\n  y \\<in> C\n  (x, y) \\<in> communicating\n  y \\<in> C \\<Longrightarrow> pos_recurrent y\n\ngoal (1 subgoal):\n 1. recurrent y &&& (y, x) \\<in> acc", "by (auto simp add: pos_recurrent_def communicating_def)"], ["proof (state)\nthis:\n  recurrent y\n  (y, x) \\<in> acc\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "then"], ["proof (chain)\npicking this:\n  recurrent y\n  (y, x) \\<in> acc", "have \"U x y = 1\""], ["proof (prove)\nusing this:\n  recurrent y\n  (y, x) \\<in> acc\n\ngoal (1 subgoal):\n 1. U x y = 1", "by (rule recurrent_acc)"], ["proof (state)\nthis:\n  U x y = 1\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "with F_le_1[of x y] U_le_F[of x y]"], ["proof (chain)\npicking this:\n  F x y \\<le> 1\n  U x y \\<le> F x y\n  U x y = 1", "have \"F x y = 1\""], ["proof (prove)\nusing this:\n  F x y \\<le> 1\n  U x y \\<le> F x y\n  U x y = 1\n\ngoal (1 subgoal):\n 1. F x y = 1", "by simp"], ["proof (state)\nthis:\n  F x y = 1\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> A n \\<Longrightarrow>\n       F x xa * enn2real (1 / U' xa xa) = enn2real (1 / U' xa xa)", "then"], ["proof (chain)\npicking this:\n  F x y = 1", "show \"F x y * enn2real (1 / U' y y) = enn2real (1 / U' y y)\""], ["proof (prove)\nusing this:\n  F x y = 1\n\ngoal (1 subgoal):\n 1. F x y * enn2real (1 / U' y y) = enn2real (1 / U' y y)", "by simp"], ["proof (state)\nthis:\n  F x y * enn2real (1 / U' y y) = enn2real (1 / U' y y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. F x y * enn2real (1 / U' y y)) =\n  (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>z.\n       \\<Sum>y\\<in>A n.\n         gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n   (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n   (at_left 1)", "have le: \"(\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z.\n       \\<Sum>y\\<in>A n.\n         gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n   (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1", "proof (rule tendsto_le[OF trivial_limit_at_left_real tendsto_const], intro eventually_at_left_1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "fix z :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "assume z: \"0 < z\" \"z < 1\""], ["proof (state)\nthis:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "with \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> C\n  0 < z\n  z < 1", "have \"norm z < 1\""], ["proof (prove)\nusing this:\n  x \\<in> C\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. norm z < 1", "by auto"], ["proof (state)\nthis:\n  norm z < 1\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "then"], ["proof (chain)\npicking this:\n  norm z < 1", "have conv: \"\\<And>x y. convergence_G x y z\""], ["proof (prove)\nusing this:\n  norm z < 1\n\ngoal (1 subgoal):\n 1. \\<And>x y. convergence_G x y z", "by (simp add: convergence_G_less_1)"], ["proof (state)\nthis:\n  convergence_G ?x4 ?y4 z\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "have \"(\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) = (\\<Sum>y\\<in>A n. gf_G x y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) =\n    (\\<Sum>y\\<in>A n. gf_G x y z)", "using \\<open>norm z < 1\\<close>"], ["proof (prove)\nusing this:\n  norm z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) =\n    (\\<Sum>y\\<in>A n. gf_G x y z)", "apply (intro sum.cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>norm z < 1; xa \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> gf_F x xa z / (1 - gf_U xa xa z) = gf_G x xa z", "apply (subst gf_G_eq_gf_F)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>norm z < 1; x \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> norm z < 1\n 2. \\<And>xa.\n       \\<lbrakk>norm z < 1; xa \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> gf_F x xa z / (1 - gf_U xa xa z) =\n                         gf_F x xa z * gf_G xa xa z", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>norm z < 1; xa \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> gf_F x xa z / (1 - gf_U xa xa z) =\n                         gf_F x xa z * gf_G xa xa z", "apply (subst gf_G_eq_gf_U(1)[OF conv])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>norm z < 1; xa \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> gf_F x xa z / (1 - gf_U xa xa z) =\n                         gf_F x xa z * (1 / (1 - gf_U xa xa z))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) =\n  (\\<Sum>y\\<in>A n. gf_G x y z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) =\n  (\\<Sum>y\\<in>A n. gf_G x y z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "have \"\\<dots> = (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_G x y z) =\n    (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z ^ n)", "by (simp add: gf_G_def)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_G x y z) =\n  (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_G x y z) =\n  (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "have \"\\<dots>  = (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z^i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z ^ n) =\n    (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z ^ i)", "by (subst suminf_sum[OF convergence_G[OF conv]]) simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z ^ n) =\n  (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. \\<Sum>n. p x y n * z ^ n) =\n  (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "have \"\\<dots>  \\<le> (\\<Sum>i. z^i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z ^ i)\n    \\<le> (\\<Sum>i. z ^ i)", "proof (intro suminf_le summable_sum convergence_G conv summable_geometric allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na. (\\<Sum>y\\<in>A n. p x y na *\\<^sub>R z ^ na) \\<le> z ^ na\n 2. norm z < 1", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>na. (\\<Sum>y\\<in>A n. p x y na *\\<^sub>R z ^ na) \\<le> z ^ na\n 2. norm z < 1", "have \"(\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) = (\\<Sum>y\\<in>A n. p x y l) * z ^ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) =\n    (\\<Sum>y\\<in>A n. p x y l) * z ^ l", "by (simp add: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) =\n  (\\<Sum>y\\<in>A n. p x y l) * z ^ l\n\ngoal (2 subgoals):\n 1. \\<And>na. (\\<Sum>y\\<in>A n. p x y na *\\<^sub>R z ^ na) \\<le> z ^ na\n 2. norm z < 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) =\n  (\\<Sum>y\\<in>A n. p x y l) * z ^ l\n\ngoal (2 subgoals):\n 1. \\<And>na. (\\<Sum>y\\<in>A n. p x y na *\\<^sub>R z ^ na) \\<le> z ^ na\n 2. norm z < 1", "have \"\\<dots> \\<le> z ^ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. p x y l) * z ^ l \\<le> z ^ l", "proof (intro mult_left_le_one_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<le> z ^ l\n 2. 0 \\<le> (\\<Sum>y\\<in>A n. p x y l)\n 3. (\\<Sum>y\\<in>A n. p x y l) \\<le> 1", "have \"(\\<Sum>y\\<in>A n. p x y l) = \\<P>(\\<omega> in T x. (x ## \\<omega>) !! l \\<in> A n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. p x y l) =\n    T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l \\<in> A n}", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n.\n       T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l = y}) =\n    T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l \\<in> A n}", "using \\<open>finite (A n)\\<close>"], ["proof (prove)\nusing this:\n  finite (A n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n.\n       T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l = y}) =\n    T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l \\<in> A n}", "by (subst T.finite_measure_finite_Union[symmetric])\n               (auto simp: disjoint_family_on_def intro!: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. p x y l) =\n  T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l \\<in> A n}\n\ngoal (3 subgoals):\n 1. 0 \\<le> z ^ l\n 2. 0 \\<le> (\\<Sum>y\\<in>A n. p x y l)\n 3. (\\<Sum>y\\<in>A n. p x y l) \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>A n. p x y l) =\n  T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l \\<in> A n}", "show \"(\\<Sum>y\\<in>A n. p x y l) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. p x y l) =\n  T.prob x {\\<omega> \\<in> space (T x). (x ## \\<omega>) !! l \\<in> A n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. p x y l) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. p x y l) \\<le> 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> z ^ l\n 2. 0 \\<le> (\\<Sum>y\\<in>A n. p x y l)", "qed (insert z, auto simp: sum_nonneg)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. p x y l) * z ^ l \\<le> z ^ l\n\ngoal (2 subgoals):\n 1. \\<And>na. (\\<Sum>y\\<in>A n. p x y na *\\<^sub>R z ^ na) \\<le> z ^ na\n 2. norm z < 1", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) \\<le> z ^ l", "show \"(\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) \\<le> z ^ l\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) \\<le> z ^ l\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) \\<le> z ^ l", "."], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. p x y l *\\<^sub>R z ^ l) \\<le> z ^ l\n\ngoal (1 subgoal):\n 1. norm z < 1", "qed fact"], ["proof (state)\nthis:\n  (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z ^ i) \\<le> (\\<Sum>i. z ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>i. \\<Sum>y\\<in>A n. p x y i *\\<^sub>R z ^ i) \\<le> (\\<Sum>i. z ^ i)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "have \"\\<dots> = 1 / (1 - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i. z ^ i) = 1 / (1 - z)", "using sums_unique[OF geometric_sums, OF \\<open>norm z < 1\\<close>]"], ["proof (prove)\nusing this:\n  1 / (1 - z) = (\\<Sum>n. z ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i. z ^ i) = 1 / (1 - z)", ".."], ["proof (state)\nthis:\n  (\\<Sum>i. z ^ i) = 1 / (1 - z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)", "have \"(\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)", "."], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)", "have \"(\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) * (1 - z) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) * (1 - z) \\<le> 1", "using z"], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) \\<le> 1 / (1 - z)\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) * (1 - z) \\<le> 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) * (1 - z) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) * (1 - z) \\<le> 1", "have \"(\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z) * (1 - z)) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z)) * (1 - z) \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z) * (1 - z)) \\<le> 1", "by (simp add: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z) * (1 - z)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>((\\<lambda>z.\n                     \\<Sum>y\\<in>A n.\n                       gf_F x y z *\n                       ((1 - z) / (1 - gf_U y y z))) \\<longlongrightarrow>\n                 (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)))\n                 (at_left 1);\n        0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>y\\<in>A n.\n                            gf_F x y z * ((1 - z) / (1 - gf_U y y z)))\n                         \\<le> 1", "then"], ["proof (chain)\npicking this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z) * (1 - z)) \\<le> 1", "show \"(\\<Sum>y\\<in>A n. gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<le> 1\""], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. gf_F x y z / (1 - gf_U y y z) * (1 - z)) \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. gf_F x y z * ((1 - z) / (1 - gf_U y y z))) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "from A_n"], ["proof (chain)\npicking this:\n  finite (A n)", "have \"emeasure (stat C) (A n) = (\\<Sum>y\\<in>A n. emeasure (stat C) {y})\""], ["proof (prove)\nusing this:\n  finite (A n)\n\ngoal (1 subgoal):\n 1. emeasure (stat C) (A n) = (\\<Sum>y\\<in>A n. emeasure (stat C) {y})", "by (intro emeasure_eq_sum_singleton) simp_all"], ["proof (state)\nthis:\n  emeasure (stat C) (A n) = (\\<Sum>y\\<in>A n. emeasure (stat C) {y})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "also"], ["proof (state)\nthis:\n  emeasure (stat C) (A n) = (\\<Sum>y\\<in>A n. emeasure (stat C) {y})\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "have \"\\<dots> = (\\<Sum>y\\<in>A n. inverse (U' y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. emeasure (stat C) {y}) =\n    (\\<Sum>y\\<in>A n. inverse (U' y y))", "unfolding stat_def U'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n.\n       emeasure\n        (point_measure UNIV\n          (\\<lambda>x.\n              indicator C x /\n              \\<integral>\\<^sup>+ xa. ennreal_of_enat\n (eSuc (sfirst (HLD {x}) xa))\n                                 \\<partial>T x))\n        {y}) =\n    (\\<Sum>y\\<in>A n.\n       inverse\n        (\\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                            \\<partial>T y))", "using A(1)[of n]"], ["proof (prove)\nusing this:\n  A n \\<subseteq> C\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n.\n       emeasure\n        (point_measure UNIV\n          (\\<lambda>x.\n              indicator C x /\n              \\<integral>\\<^sup>+ xa. ennreal_of_enat\n (eSuc (sfirst (HLD {x}) xa))\n                                 \\<partial>T x))\n        {y}) =\n    (\\<Sum>y\\<in>A n.\n       inverse\n        (\\<integral>\\<^sup>+ x. ennreal_of_enat (eSuc (sfirst (HLD {y}) x))\n                            \\<partial>T y))", "apply (intro sum.cong refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>A n \\<subseteq> C; x \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> emeasure\n                          (point_measure UNIV\n                            (\\<lambda>x.\n                                indicator C x /\n                                \\<integral>\\<^sup>+ xa.\n               ennreal_of_enat (eSuc (sfirst (HLD {x}) xa))\n             \\<partial>T x))\n                          {x} =\n                         inverse\n                          (\\<integral>\\<^sup>+ xa.\n          ennreal_of_enat (eSuc (sfirst (HLD {x}) xa))\n        \\<partial>T x)", "apply (subst emeasure_point_measure_finite2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>A n \\<subseteq> C; x \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> {x} \\<subseteq> UNIV\n 2. \\<And>x.\n       \\<lbrakk>A n \\<subseteq> C; x \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> finite {x}\n 3. \\<And>x.\n       \\<lbrakk>A n \\<subseteq> C; x \\<in> A n\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>a\\<in>{x}.\n                            indicator C a /\n                            \\<integral>\\<^sup>+ x.\n           ennreal_of_enat (eSuc (sfirst (HLD {a}) x))\n         \\<partial>T a) =\n                         inverse\n                          (\\<integral>\\<^sup>+ xa.\n          ennreal_of_enat (eSuc (sfirst (HLD {x}) xa))\n        \\<partial>T x)", "apply (auto simp: divide_ennreal_def Collect_conv_if)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. emeasure (stat C) {y}) =\n  (\\<Sum>y\\<in>A n. inverse (U' y y))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. emeasure (stat C) {y}) =\n  (\\<Sum>y\\<in>A n. inverse (U' y y))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "have \"\\<dots> = ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. inverse (U' y y)) =\n    ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))", "apply (subst sum_ennreal[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>A n. inverse (U' y y)) =\n    (\\<Sum>i\\<in>A n. ennreal (enn2real (1 / U' i i)))", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A n \\<Longrightarrow>\n       inverse (U' x x) = ennreal (enn2real (1 / U' x x))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A n \\<Longrightarrow>\n       inverse (U' x x) = ennreal (enn2real (1 / U' x x))", "assume \"y \\<in> A n\""], ["proof (state)\nthis:\n  y \\<in> A n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A n \\<Longrightarrow>\n       inverse (U' x x) = ennreal (enn2real (1 / U' x x))", "with \\<open>A n \\<subseteq> C\\<close> pos"], ["proof (chain)\npicking this:\n  A n \\<subseteq> C\n  Ball C pos_recurrent\n  y \\<in> A n", "have \"pos_recurrent y\""], ["proof (prove)\nusing this:\n  A n \\<subseteq> C\n  Ball C pos_recurrent\n  y \\<in> A n\n\ngoal (1 subgoal):\n 1. pos_recurrent y", "by auto"], ["proof (state)\nthis:\n  pos_recurrent y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A n \\<Longrightarrow>\n       inverse (U' x x) = ennreal (enn2real (1 / U' x x))", "with one_le_integral_t[of y]"], ["proof (chain)\npicking this:\n  recurrent y \\<Longrightarrow> 1 \\<le> U' y y\n  pos_recurrent y", "obtain r where \"U' y y = ennreal r\" \"1 \\<le> U' y y\" and [simp]: \"0 \\<le> r\""], ["proof (prove)\nusing this:\n  recurrent y \\<Longrightarrow> 1 \\<le> U' y y\n  pos_recurrent y\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>U' y y = ennreal r; 1 \\<le> U' y y; 0 \\<le> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"U' y y\") (auto simp: pos_recurrent_def nn_integral_add)"], ["proof (state)\nthis:\n  U' y y = ennreal r\n  1 \\<le> U' y y\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> A n \\<Longrightarrow>\n       inverse (U' x x) = ennreal (enn2real (1 / U' x x))", "then"], ["proof (chain)\npicking this:\n  U' y y = ennreal r\n  1 \\<le> U' y y\n  0 \\<le> r", "show \"inverse (U' y y) = ennreal (enn2real (1 / U' y y))\""], ["proof (prove)\nusing this:\n  U' y y = ennreal r\n  1 \\<le> U' y y\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. inverse (U' y y) = ennreal (enn2real (1 / U' y y))", "by (simp add: ennreal_1[symmetric] divide_ennreal inverse_ennreal inverse_eq_divide del: ennreal_1)"], ["proof (state)\nthis:\n  inverse (U' y y) = ennreal (enn2real (1 / U' y y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. inverse (U' y y)) =\n  ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "also"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>A n. inverse (U' y y)) =\n  ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "have \"\\<dots> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1", "using le"], ["proof (prove)\nusing this:\n  (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1\n\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1", "by simp"], ["proof (state)\nthis:\n  ennreal (\\<Sum>y\\<in>A n. enn2real (1 / U' y y)) \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>(\\<lambda>n. emeasure (stat C) (A n))\n                \\<longlonglongrightarrow> emeasure (stat C)\n     (\\<Union> (range A));\n        ?N6 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> emeasure (stat C) (A n) \\<le> 1", "finally"], ["proof (chain)\npicking this:\n  emeasure (stat C) (A n) \\<le> 1", "show \"emeasure (stat C) (A n) \\<le> 1\""], ["proof (prove)\nusing this:\n  emeasure (stat C) (A n) \\<le> 1\n\ngoal (1 subgoal):\n 1. emeasure (stat C) (A n) \\<le> 1", "."], ["proof (state)\nthis:\n  emeasure (stat C) (A n) \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (stat C) (\\<Union> (range A)) \\<le> 1\n\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "with A"], ["proof (chain)\npicking this:\n  A ?i4 \\<subseteq> C\n  A ?i4 \\<subseteq> A (Suc ?i4)\n  finite (A ?i4)\n  \\<Union> (range A) = C\n  emeasure (stat C) (\\<Union> (range A)) \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  A ?i4 \\<subseteq> C\n  A ?i4 \\<subseteq> A (Suc ?i4)\n  finite (A ?i4)\n  \\<Union> (range A) = C\n  emeasure (stat C) (\\<Union> (range A)) \\<le> 1\n\ngoal (1 subgoal):\n 1. emeasure (stat C) C \\<le> 1", "by simp"], ["proof (state)\nthis:\n  emeasure (stat C) C \\<le> 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emeasure_stat_not_C:\n  assumes \"y \\<notin> C\"\n  shows \"emeasure (stat C) {y} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (stat C) {y} = 0", "unfolding stat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {y} =\n    0", "using \\<open>y \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  y \\<notin> C\n\ngoal (1 subgoal):\n 1. emeasure (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {y} =\n    0", "by (subst emeasure_point_measure_finite2) auto"], ["", "definition stationary_distribution :: \"'s pmf \\<Rightarrow> bool\" where\n  \"stationary_distribution N \\<longleftrightarrow> N = bind_pmf N K\""], ["", "lemma stationary_distributionI:\n  assumes le: \"\\<And>y. (\\<integral>x. pmf (K x) y \\<partial>measure_pmf N) \\<le> pmf N y\"\n  shows \"stationary_distribution N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stationary_distribution N", "unfolding stationary_distribution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N = N \\<bind> K", "proof (rule pmf_eqI antisym)+"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i\n 2. \\<And>i. pmf (N \\<bind> K) i \\<le> pmf N i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i\n 2. \\<And>i. pmf (N \\<bind> K) i \\<le> pmf N i", "show \"pmf (bind_pmf N K) i \\<le> pmf N i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (N \\<bind> K) i \\<le> pmf N i", "by (simp add: pmf_bind le)"], ["proof (state)\nthis:\n  pmf (N \\<bind> K) i \\<le> pmf N i\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "define \\<Omega> where \"\\<Omega> = N \\<union> (\\<Union>i\\<in>N. set_pmf (K i))\""], ["proof (state)\nthis:\n  \\<Omega> = set_pmf N \\<union> (\\<Union>i\\<in>set_pmf N. set_pmf (K i))\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "then"], ["proof (chain)\npicking this:\n  \\<Omega> = set_pmf N \\<union> (\\<Union>i\\<in>set_pmf N. set_pmf (K i))", "have \\<Omega>: \"countable \\<Omega>\""], ["proof (prove)\nusing this:\n  \\<Omega> = set_pmf N \\<union> (\\<Union>i\\<in>set_pmf N. set_pmf (K i))\n\ngoal (1 subgoal):\n 1. countable \\<Omega>", "by (auto intro: countable_set_pmf)"], ["proof (state)\nthis:\n  countable \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "then"], ["proof (chain)\npicking this:\n  countable \\<Omega>", "interpret N: sigma_finite_measure \"count_space \\<Omega>\""], ["proof (prove)\nusing this:\n  countable \\<Omega>\n\ngoal (1 subgoal):\n 1. sigma_finite_measure (count_space \\<Omega>)", "by (rule sigma_finite_measure_count_space_countable)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "interpret pN: pair_sigma_finite N \"count_space \\<Omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_sigma_finite (measure_pmf N) (count_space \\<Omega>)", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have measurable_pmf[measurable]: \"(\\<lambda>(x, y). pmf (K x) y) \\<in> borel_measurable (N \\<Otimes>\\<^sub>M count_space \\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). pmf (K x) y)\n    \\<in> borel_measurable\n           (measure_pmf N \\<Otimes>\\<^sub>M count_space \\<Omega>)", "unfolding measurable_split_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. pmf (K (fst x)) (snd x))\n    \\<in> borel_measurable\n           (measure_pmf N \\<Otimes>\\<^sub>M count_space \\<Omega>)", "apply (rule measurable_compose_countable'[OF _ measurable_snd])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> \\<Omega> \\<Longrightarrow>\n       (\\<lambda>x. pmf (K (fst x)) i)\n       \\<in> borel_measurable\n              (measure_pmf N \\<Otimes>\\<^sub>M count_space \\<Omega>)\n 2. countable \\<Omega>", "apply (rule measurable_compose[OF measurable_fst])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> \\<Omega> \\<Longrightarrow>\n       measure_pmf.random_variable N borel (\\<lambda>a. pmf (K a) i)\n 2. countable \\<Omega>", "apply (simp_all add: \\<Omega>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). pmf (K x) y)\n  \\<in> borel_measurable\n         (measure_pmf N \\<Otimes>\\<^sub>M count_space \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "{"], ["proof (state)\nthis:\n  (\\<lambda>(x, y). pmf (K x) y)\n  \\<in> borel_measurable\n         (measure_pmf N \\<Otimes>\\<^sub>M count_space \\<Omega>)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "assume *: \"(\\<integral>y. pmf (K y) i \\<partial>N) < pmf N i\""], ["proof (state)\nthis:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) < pmf N i\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have \"0 \\<le> (\\<integral>y. pmf (K y) i \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)", "by (intro integral_nonneg_AE) simp"], ["proof (state)\nthis:\n  0 \\<le> measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "with *"], ["proof (chain)\npicking this:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) < pmf N i\n  0 \\<le> measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)", "have i: \"i \\<in> set_pmf N\" \"i \\<in> \\<Omega>\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) < pmf N i\n  0 \\<le> measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n\ngoal (1 subgoal):\n 1. i \\<in> set_pmf N &&& i \\<in> \\<Omega>", "by (auto simp: set_pmf_iff \\<Omega>_def not_le[symmetric])"], ["proof (state)\nthis:\n  i \\<in> set_pmf N\n  i \\<in> \\<Omega>\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "from *"], ["proof (chain)\npicking this:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) < pmf N i", "have \"0 < pmf N i - (\\<integral>y. pmf (K y) i \\<partial>N)\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) < pmf N i\n\ngoal (1 subgoal):\n 1. 0 < pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  0 < pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "also"], ["proof (state)\nthis:\n  0 < pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have \"\\<dots> = (\\<integral>t. (pmf N i - (\\<integral>y. pmf (K y) i \\<partial>N)) * indicator {i} t \\<partial>count_space \\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) =\n    LINT t|count_space \\<Omega>.\n       (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n       indicat_real {i} t", "by (simp add: i)"], ["proof (state)\nthis:\n  pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) =\n  LINT t|count_space \\<Omega>.\n     (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n     indicat_real {i} t\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "also"], ["proof (state)\nthis:\n  pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i) =\n  LINT t|count_space \\<Omega>.\n     (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n     indicat_real {i} t\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have \"\\<dots> \\<le> (\\<integral>t. pmf N t - \\<integral>y. pmf (K y) t \\<partial>N \\<partial>count_space \\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT t|count_space \\<Omega>.\n       (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n       indicat_real {i} t\n    \\<le> LINT t|count_space \\<Omega>.\n             pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t)", "using le"], ["proof (prove)\nusing this:\n  measure_pmf.expectation N (\\<lambda>x. pmf (K x) ?y4) \\<le> pmf N ?y4\n\ngoal (1 subgoal):\n 1. LINT t|count_space \\<Omega>.\n       (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n       indicat_real {i} t\n    \\<le> LINT t|count_space \\<Omega>.\n             pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t)", "by (intro integral_mono integrable_diff)\n         (auto simp: i pmf_bind[symmetric] integrable_pmf field_simps split: split_indicator)"], ["proof (state)\nthis:\n  LINT t|count_space \\<Omega>.\n     (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n     indicat_real {i} t\n  \\<le> LINT t|count_space \\<Omega>.\n           pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "also"], ["proof (state)\nthis:\n  LINT t|count_space \\<Omega>.\n     (pmf N i - measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)) *\n     indicat_real {i} t\n  \\<le> LINT t|count_space \\<Omega>.\n           pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have \"\\<dots> = (\\<integral>t. pmf N t \\<partial>count_space \\<Omega>) - (\\<integral>t. \\<integral>y. pmf (K y) t \\<partial>N \\<partial>count_space \\<Omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT t|count_space \\<Omega>.\n       pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t) =\n    integral\\<^sup>L (count_space \\<Omega>) (pmf N) -\n    (LINT t|count_space \\<Omega>.\n        measure_pmf.expectation N (\\<lambda>y. pmf (K y) t))", "by (subst Bochner_Integration.integral_diff) (auto intro!: integrable_pmf simp: pmf_bind[symmetric])"], ["proof (state)\nthis:\n  LINT t|count_space \\<Omega>.\n     pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t) =\n  integral\\<^sup>L (count_space \\<Omega>) (pmf N) -\n  (LINT t|count_space \\<Omega>.\n      measure_pmf.expectation N (\\<lambda>y. pmf (K y) t))\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "also"], ["proof (state)\nthis:\n  LINT t|count_space \\<Omega>.\n     pmf N t - measure_pmf.expectation N (\\<lambda>y. pmf (K y) t) =\n  integral\\<^sup>L (count_space \\<Omega>) (pmf N) -\n  (LINT t|count_space \\<Omega>.\n      measure_pmf.expectation N (\\<lambda>y. pmf (K y) t))\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have \"(\\<integral>t. \\<integral>y. pmf (K y) t \\<partial>N \\<partial>count_space \\<Omega>) = (\\<integral>y. \\<integral>t. pmf (K y) t \\<partial>count_space \\<Omega> \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT t|count_space \\<Omega>.\n       measure_pmf.expectation N (\\<lambda>y. pmf (K y) t) =\n    measure_pmf.expectation N\n     (\\<lambda>y. integral\\<^sup>L (count_space \\<Omega>) (pmf (K y)))", "apply (intro pN.Fubini_integral integrable_iff_bounded[THEN iffD2] conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>(x, y). pmf (K x) y)\n    \\<in> borel_measurable\n           (measure_pmf N \\<Otimes>\\<^sub>M count_space \\<Omega>)\n 2. \\<integral>\\<^sup>+ x. ennreal\n                            (norm\n                              (case x of (x, y) \\<Rightarrow> pmf (K x) y))\n                       \\<partial>measure_pmf N \\<Otimes>\\<^sub>M\n                                 count_space \\<Omega>\n    < \\<infinity>", "apply (auto simp add: N.nn_integral_fst[symmetric] nn_integral_eq_integral integrable_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (integral\\<^sup>L (count_space \\<Omega>)\n                              (pmf (K x)))\n                       \\<partial>measure_pmf N\n    < \\<top>", "unfolding less_top[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (integral\\<^sup>L (count_space \\<Omega>)\n                              (pmf (K x)))\n                       \\<partial>measure_pmf N \\<noteq>\n    \\<top>", "unfolding infinity_ennreal_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (integral\\<^sup>L (count_space \\<Omega>)\n                              (pmf (K x)))\n                       \\<partial>measure_pmf N \\<noteq>\n    \\<infinity>", "apply (intro integrableD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. integrable (measure_pmf N)\n     (\\<lambda>x. integral\\<^sup>L (count_space \\<Omega>) (pmf (K x)))", "apply (auto intro!: measure_pmf.integrable_const_bound[where B=1]\n                  simp: AE_measure_pmf_iff integral_nonneg_AE integral_pmf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  LINT t|count_space \\<Omega>.\n     measure_pmf.expectation N (\\<lambda>y. pmf (K y) t) =\n  measure_pmf.expectation N\n   (\\<lambda>y. integral\\<^sup>L (count_space \\<Omega>) (pmf (K y)))\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "also"], ["proof (state)\nthis:\n  LINT t|count_space \\<Omega>.\n     measure_pmf.expectation N (\\<lambda>y. pmf (K y) t) =\n  measure_pmf.expectation N\n   (\\<lambda>y. integral\\<^sup>L (count_space \\<Omega>) (pmf (K y)))\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "have \"(\\<integral>y. \\<integral>t. pmf (K y) t \\<partial>count_space \\<Omega> \\<partial>N) = (\\<integral>y. 1 \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N\n     (\\<lambda>y. integral\\<^sup>L (count_space \\<Omega>) (pmf (K y))) =\n    measure_pmf.expectation N (\\<lambda>y. 1)", "by (intro integral_cong_AE)\n         (auto simp: AE_measure_pmf_iff integral_pmf \\<Omega>_def intro!: measure_pmf.prob_eq_1[THEN iffD2])"], ["proof (state)\nthis:\n  measure_pmf.expectation N\n   (\\<lambda>y. integral\\<^sup>L (count_space \\<Omega>) (pmf (K y))) =\n  measure_pmf.expectation N (\\<lambda>y. 1)\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "finally"], ["proof (chain)\npicking this:\n  0 < integral\\<^sup>L (count_space \\<Omega>) (pmf N) -\n      measure_pmf.expectation N (\\<lambda>y. 1)", "have False"], ["proof (prove)\nusing this:\n  0 < integral\\<^sup>L (count_space \\<Omega>) (pmf N) -\n      measure_pmf.expectation N (\\<lambda>y. 1)\n\ngoal (1 subgoal):\n 1. False", "using measure_pmf.prob_space[of N]"], ["proof (prove)\nusing this:\n  0 < integral\\<^sup>L (count_space \\<Omega>) (pmf N) -\n      measure_pmf.expectation N (\\<lambda>y. 1)\n  measure_pmf.prob N (space (measure_pmf N)) = 1\n\ngoal (1 subgoal):\n 1. False", "by (simp add: integral_pmf field_simps not_le[symmetric])"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "}"], ["proof (state)\nthis:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n  < pmf N i \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i. pmf N i \\<le> pmf (N \\<bind> K) i", "then"], ["proof (chain)\npicking this:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n  < pmf N i \\<Longrightarrow>\n  False", "show \"pmf N i \\<le> pmf (bind_pmf N K) i\""], ["proof (prove)\nusing this:\n  measure_pmf.expectation N (\\<lambda>y. pmf (K y) i)\n  < pmf N i \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. pmf N i \\<le> pmf (N \\<bind> K) i", "by (auto simp: pmf_bind not_le[symmetric])"], ["proof (state)\nthis:\n  pmf N i \\<le> pmf (N \\<bind> K) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stationary_distribution_iterate:\n  assumes N: \"stationary_distribution N\"\n  shows \"ennreal (pmf N y) = (\\<integral>\\<^sup>+x. p x y n \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (pmf N y) =\n    \\<integral>\\<^sup>+ x. ennreal (p x y n) \\<partial>measure_pmf N", "proof (induct n arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y 0) \\<partial>measure_pmf N\n 2. \\<And>n y.\n       (\\<And>y.\n           ennreal (pmf N y) =\n           \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                              \\<partial>measure_pmf N) \\<Longrightarrow>\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n))\n                          \\<partial>measure_pmf N", "have [simp]: \"\\<And>x y. ennreal (if x = y then 1 else 0) = indicator {y} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. ennreal (if x = y then 1 else 0) = indicator {y} x", "by simp"], ["proof (state)\nthis:\n  ennreal (if ?x4 = ?y4 then 1 else 0) = indicator {?y4} ?x4\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y 0) \\<partial>measure_pmf N\n 2. \\<And>n y.\n       (\\<And>y.\n           ennreal (pmf N y) =\n           \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                              \\<partial>measure_pmf N) \\<Longrightarrow>\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n))\n                          \\<partial>measure_pmf N", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>y.\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y 0) \\<partial>measure_pmf N\n 2. \\<And>n y.\n       (\\<And>y.\n           ennreal (pmf N y) =\n           \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                              \\<partial>measure_pmf N) \\<Longrightarrow>\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n))\n                          \\<partial>measure_pmf N", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (pmf N y) =\n    \\<integral>\\<^sup>+ x. ennreal (p x y 0) \\<partial>measure_pmf N", "by (simp add: p_0 pmf.rep_eq measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  ennreal (pmf N y) =\n  \\<integral>\\<^sup>+ x. ennreal (p x y 0) \\<partial>measure_pmf N\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       (\\<And>y.\n           ennreal (pmf N y) =\n           \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                              \\<partial>measure_pmf N) \\<Longrightarrow>\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n))\n                          \\<partial>measure_pmf N", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n y.\n       (\\<And>y.\n           ennreal (pmf N y) =\n           \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                              \\<partial>measure_pmf N) \\<Longrightarrow>\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n))\n                          \\<partial>measure_pmf N", "case (Suc n)"], ["proof (state)\nthis:\n  ennreal (pmf N ?y4) =\n  \\<integral>\\<^sup>+ x. ennreal (p x ?y4 n) \\<partial>measure_pmf N\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       (\\<And>y.\n           ennreal (pmf N y) =\n           \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                              \\<partial>measure_pmf N) \\<Longrightarrow>\n       ennreal (pmf N y) =\n       \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n))\n                          \\<partial>measure_pmf N", "with N"], ["proof (chain)\npicking this:\n  stationary_distribution N\n  ennreal (pmf N ?y4) =\n  \\<integral>\\<^sup>+ x. ennreal (p x ?y4 n) \\<partial>measure_pmf N", "show ?case"], ["proof (prove)\nusing this:\n  stationary_distribution N\n  ennreal (pmf N ?y4) =\n  \\<integral>\\<^sup>+ x. ennreal (p x ?y4 n) \\<partial>measure_pmf N\n\ngoal (1 subgoal):\n 1. ennreal (pmf N y) =\n    \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n)) \\<partial>measure_pmf N", "apply (simp add: nn_integral_eq_integral[symmetric] p_le_1 p_Suc'\n                     measure_pmf.integrable_const_bound[where B=1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>stationary_distribution N;\n     \\<And>y.\n        ennreal (pmf N y) =\n        \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                           \\<partial>measure_pmf N\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. ennreal (p x y n)\n   \\<partial>measure_pmf N =\n                      \\<integral>\\<^sup>+ x.\n     \\<integral>\\<^sup>+ x. ennreal (p x y n) \\<partial>measure_pmf (K x)\n   \\<partial>measure_pmf N", "apply (subst nn_integral_bind[symmetric, where B=\"count_space UNIV\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>stationary_distribution N;\n     \\<And>y.\n        ennreal (pmf N y) =\n        \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                           \\<partial>measure_pmf N\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. ennreal (p x y n))\n                      \\<in> borel_measurable (count_space UNIV)\n 2. \\<lbrakk>stationary_distribution N;\n     \\<And>y.\n        ennreal (pmf N y) =\n        \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                           \\<partial>measure_pmf N\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.random_variable N\n                       (subprob_algebra (count_space UNIV))\n                       (\\<lambda>x. measure_pmf (K x))\n 3. \\<lbrakk>stationary_distribution N;\n     \\<And>y.\n        ennreal (pmf N y) =\n        \\<integral>\\<^sup>+ x. ennreal (p x y n)\n                           \\<partial>measure_pmf N\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x. ennreal (p x y n)\n   \\<partial>measure_pmf N =\n                      \\<integral>\\<^sup>+ x. ennreal (p x y n)\n   \\<partial>measure_pmf N \\<bind> (\\<lambda>x. measure_pmf (K x))", "apply (auto simp: stationary_distribution_def measure_pmf_bind[symmetric]\n                simp del: measurable_pmf_measure1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ennreal (pmf N y) =\n  \\<integral>\\<^sup>+ x. ennreal (p x y (Suc n)) \\<partial>measure_pmf N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stationary_distribution_iterate':\n  assumes \"stationary_distribution N\"\n  shows \"measure N {y} = (\\<integral>x. p x y n \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} = measure_pmf.expectation N (\\<lambda>x. p x y n)", "using stationary_distribution_iterate[OF assms]"], ["proof (prove)\nusing this:\n  ennreal (pmf N ?y) =\n  \\<integral>\\<^sup>+ x. ennreal (p x ?y ?n) \\<partial>measure_pmf N\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} = measure_pmf.expectation N (\\<lambda>x. p x y n)", "by (subst (asm) nn_integral_eq_integral)\n     (auto intro!: measure_pmf.integrable_const_bound[where B=1] simp: p_le_1 pmf.rep_eq)"], ["", "lemma stationary_distributionD:\n  assumes C: \"essential_class C\" \"countable C\"\n  assumes N: \"stationary_distribution N\" \"N \\<subseteq> C\"\n  shows \"\\<forall>x\\<in>C. pos_recurrent x\" \"measure_pmf N = stat C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball C pos_recurrent &&& measure_pmf N = stat C", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have integrable_K: \"\\<And>f x. integrable N (\\<lambda>s. pmf (K s) (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x. integrable (measure_pmf N) (\\<lambda>s. pmf (K s) (f x))", "by (rule measure_pmf.integrable_const_bound[where B=1]) (simp_all add: pmf_le_1)"], ["proof (state)\nthis:\n  integrable (measure_pmf N) (\\<lambda>s. pmf (K s) (?f4 ?x4))\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have measure_C: \"measure N C = 1\" and ae_C: \"AE x in N. x \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob N C = 1 &&& AE x in measure_pmf N. x \\<in> C", "using N C measure_pmf.prob_eq_1[of C]"], ["proof (prove)\nusing this:\n  stationary_distribution N\n  set_pmf N \\<subseteq> C\n  essential_class C\n  countable C\n  C \\<in> measure_pmf.events ?M \\<Longrightarrow>\n  (measure_pmf.prob ?M C = 1) = (AE x in measure_pmf ?M. x \\<in> C)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N C = 1 &&& AE x in measure_pmf N. x \\<in> C", "by (auto simp: AE_measure_pmf_iff)"], ["proof (state)\nthis:\n  measure_pmf.prob N C = 1\n  AE x in measure_pmf N. x \\<in> C\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have integrable_p: \"\\<And>n y. integrable N (\\<lambda>x. p x y n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n y. integrable (measure_pmf N) (\\<lambda>x. p x y n)", "by (rule measure_pmf.integrable_const_bound[where B=1]) (simp_all add: p_le_1)"], ["proof (state)\nthis:\n  integrable (measure_pmf N) (\\<lambda>x. p x ?y5 ?n5)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "{"], ["proof (state)\nthis:\n  integrable (measure_pmf N) (\\<lambda>x. p x ?y5 ?n5)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "fix e :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "assume \"0 < e\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  0 < e", "have [simp]: \"0 \\<le> e\""], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. 0 \\<le> e", "by simp"], ["proof (state)\nthis:\n  0 \\<le> e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<exists>A\\<subseteq>C. finite A \\<and> 1 - e < measure N A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>C. finite A \\<and> 1 - e < measure_pmf.prob N A", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>A\\<subseteq>C.\n               finite A \\<and>\n               1 - e < measure_pmf.prob N A) \\<Longrightarrow>\n    False", "assume contr: \"\\<not> (\\<exists>A \\<subseteq> C. finite A \\<and> 1 - e < measure N A)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>A\\<subseteq>C.\n             finite A \\<and> 1 - e < measure_pmf.prob N A)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>A\\<subseteq>C.\n               finite A \\<and>\n               1 - e < measure_pmf.prob N A) \\<Longrightarrow>\n    False", "from finite_sequence_to_countable_set[OF \\<open>countable C\\<close>]"], ["proof (chain)\npicking this:\n  (\\<And>F.\n      \\<lbrakk>\\<And>i. F i \\<subseteq> C;\n       \\<And>i. F i \\<subseteq> F (Suc i); \\<And>i. finite (F i);\n       \\<Union> (range F) = C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "guess F"], ["proof (prove)\nusing this:\n  (\\<And>F.\n      \\<lbrakk>\\<And>i. F i \\<subseteq> C;\n       \\<And>i. F i \\<subseteq> F (Suc i); \\<And>i. finite (F i);\n       \\<Union> (range F) = C\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>A\\<subseteq>C.\n               finite A \\<and>\n               1 - e < measure_pmf.prob N A) \\<Longrightarrow>\n    False", "note F = this"], ["proof (state)\nthis:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>A\\<subseteq>C.\n               finite A \\<and>\n               1 - e < measure_pmf.prob N A) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C", "have *: \"(\\<lambda>n. measure N (F n)) \\<longlonglongrightarrow> measure N (\\<Union>i. F i)\""], ["proof (prove)\nusing this:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. measure_pmf.prob N (F n))\n    \\<longlonglongrightarrow> measure_pmf.prob N (\\<Union> (range F))", "by (intro measure_pmf.finite_Lim_measure_incseq) (auto simp: incseq_Suc_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n. measure_pmf.prob N (F n))\n  \\<longlonglongrightarrow> measure_pmf.prob N (\\<Union> (range F))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>A\\<subseteq>C.\n               finite A \\<and>\n               1 - e < measure_pmf.prob N A) \\<Longrightarrow>\n    False", "with F contr"], ["proof (chain)\npicking this:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n  \\<not> (\\<exists>A\\<subseteq>C.\n             finite A \\<and> 1 - e < measure_pmf.prob N A)\n  (\\<lambda>n. measure_pmf.prob N (F n))\n  \\<longlonglongrightarrow> measure_pmf.prob N (\\<Union> (range F))", "have \"measure N (\\<Union>i. F i) \\<le> 1 - e\""], ["proof (prove)\nusing this:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n  \\<not> (\\<exists>A\\<subseteq>C.\n             finite A \\<and> 1 - e < measure_pmf.prob N A)\n  (\\<lambda>n. measure_pmf.prob N (F n))\n  \\<longlonglongrightarrow> measure_pmf.prob N (\\<Union> (range F))\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N (\\<Union> (range F)) \\<le> 1 - e", "by (intro LIMSEQ_le[OF * tendsto_const]) (auto simp: not_less)"], ["proof (state)\nthis:\n  measure_pmf.prob N (\\<Union> (range F)) \\<le> 1 - e\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>A\\<subseteq>C.\n               finite A \\<and>\n               1 - e < measure_pmf.prob N A) \\<Longrightarrow>\n    False", "with F \\<open>0 < e\\<close>"], ["proof (chain)\npicking this:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n  0 < e\n  measure_pmf.prob N (\\<Union> (range F)) \\<le> 1 - e", "show False"], ["proof (prove)\nusing this:\n  F ?i5 \\<subseteq> C\n  F ?i5 \\<subseteq> F (Suc ?i5)\n  finite (F ?i5)\n  \\<Union> (range F) = C\n  0 < e\n  measure_pmf.prob N (\\<Union> (range F)) \\<le> 1 - e\n\ngoal (1 subgoal):\n 1. False", "by (simp add: measure_C)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A\\<subseteq>C. finite A \\<and> 1 - e < measure_pmf.prob N A\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  \\<exists>A\\<subseteq>C. finite A \\<and> 1 - e < measure_pmf.prob N A", "obtain A where \"A \\<subseteq> C\" \"finite A\" and e: \"1 - e < measure N A\""], ["proof (prove)\nusing this:\n  \\<exists>A\\<subseteq>C. finite A \\<and> 1 - e < measure_pmf.prob N A\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>A \\<subseteq> C; finite A;\n         1 - e < measure_pmf.prob N A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> C\n  finite A\n  1 - e < measure_pmf.prob N A\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "{"], ["proof (state)\nthis:\n  A \\<subseteq> C\n  finite A\n  1 - e < measure_pmf.prob N A\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "fix y n"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "assume \"y \\<in> C\""], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "from N(1)"], ["proof (chain)\npicking this:\n  stationary_distribution N", "have \"measure N {y} = (\\<integral>x. p x y n \\<partial>N)\""], ["proof (prove)\nusing this:\n  stationary_distribution N\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} = measure_pmf.expectation N (\\<lambda>x. p x y n)", "by (rule stationary_distribution_iterate')"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} = measure_pmf.expectation N (\\<lambda>x. p x y n)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} = measure_pmf.expectation N (\\<lambda>x. p x y n)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> \\<le> (\\<integral>x. p x y n * indicator A x + indicator (C - A) x \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n)\n    \\<le> measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x)", "using ae_C \\<open>A \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  AE x in measure_pmf N. x \\<in> C\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n)\n    \\<le> measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x)", "by (intro integral_mono_AE)\n           (auto elim!: eventually_mono\n                 intro!: integral_add integral_indicator p_le_1 integrable_real_mult_indicator\n                   integrable_add\n                 split: split_indicator simp: integrable_p less_top[symmetric] top_unique)"], ["proof (state)\nthis:\n  measure_pmf.expectation N (\\<lambda>x. p x y n)\n  \\<le> measure_pmf.expectation N\n         (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation N (\\<lambda>x. p x y n)\n  \\<le> measure_pmf.expectation N\n         (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<integral>x. p x y n * indicator A x \\<partial>N) + measure N (C - A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N\n     (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x) =\n    measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n    measure_pmf.prob N (C - A)", "using ae_C \\<open>A \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  AE x in measure_pmf N. x \\<in> C\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation N\n     (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x) =\n    measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n    measure_pmf.prob N (C - A)", "apply (subst Bochner_Integration.integral_add)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>AE x in measure_pmf N. x \\<in> C; A \\<subseteq> C\\<rbrakk>\n    \\<Longrightarrow> integrable (measure_pmf N)\n                       (\\<lambda>x. p x y n * indicat_real A x)\n 2. \\<lbrakk>AE x in measure_pmf N. x \\<in> C; A \\<subseteq> C\\<rbrakk>\n    \\<Longrightarrow> integrable (measure_pmf N) (indicat_real (C - A))\n 3. \\<lbrakk>AE x in measure_pmf N. x \\<in> C; A \\<subseteq> C\\<rbrakk>\n    \\<Longrightarrow> measure_pmf.expectation N\n                       (\\<lambda>x. p x y n * indicat_real A x) +\n                      measure_pmf.expectation N (indicat_real (C - A)) =\n                      measure_pmf.expectation N\n                       (\\<lambda>x. p x y n * indicat_real A x) +\n                      measure_pmf.prob N (C - A)", "apply (auto elim!: eventually_mono\n                    intro!: integral_add integral_indicator p_le_1 integrable_real_mult_indicator\n                    split: split_indicator simp: integrable_p less_top[symmetric] top_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  measure_pmf.expectation N\n   (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x) =\n  measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n  measure_pmf.prob N (C - A)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation N\n   (\\<lambda>x. p x y n * indicat_real A x + indicat_real (C - A) x) =\n  measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n  measure_pmf.prob N (C - A)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> \\<le> (\\<integral>x. p x y n * indicator A x \\<partial>N) + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n    measure_pmf.prob N (C - A)\n    \\<le> measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x) +\n          e", "using e \\<open>A \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  1 - e < measure_pmf.prob N A\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n    measure_pmf.prob N (C - A)\n    \\<le> measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x) +\n          e", "by (simp add: measure_pmf.finite_measure_Diff measure_C)"], ["proof (state)\nthis:\n  measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n  measure_pmf.prob N (C - A)\n  \\<le> measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n        e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y}\n  \\<le> measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n        e", "have \"measure N {y} \\<le> (\\<integral>x. p x y n * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y}\n  \\<le> measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n        e\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y}\n    \\<le> measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x) +\n          e", "."], ["proof (state)\nthis:\n  measure_pmf.prob N {y}\n  \\<le> measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n        e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y}\n  \\<le> measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n        e", "have \"emeasure N {y} \\<le> ennreal (\\<integral>x. p x y n * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y}\n  \\<le> measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) +\n        e\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y}\n    \\<le> ennreal\n           (measure_pmf.expectation N\n             (\\<lambda>x. p x y n * indicat_real A x)) +\n          ennreal e", "by (simp add: measure_pmf.emeasure_eq_measure ennreal_plus[symmetric] del: ennreal_plus)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal\n         (measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x)) +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal\n         (measure_pmf.expectation N\n           (\\<lambda>x. p x y n * indicat_real A x)) +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x)) +\n    ennreal e =\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\\<partial>measure_pmf N) +\n    ennreal e", "by (subst nn_integral_eq_integral[symmetric])\n           (auto intro!: measure_pmf.integrable_const_bound[where B=1]\n                 simp: abs_mult p_le_1 mult_le_one ennreal_indicator ennreal_mult)"], ["proof (state)\nthis:\n  ennreal\n   (measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x)) +\n  ennreal e =\n  (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\\<partial>measure_pmf N) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) {y}\n  \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) +\n        ennreal e", "have \"emeasure N {y} \\<le> (\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y}\n  \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) +\n        ennreal e\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y}\n    \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n           \\<partial>measure_pmf N) +\n          ennreal e", "."], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y}\n  \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "}"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow>\n  emeasure (measure_pmf N) {?y7}\n  \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x ?y7 ?n7)\n         \\<partial>measure_pmf N) +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "note v_le = this"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow>\n  emeasure (measure_pmf N) {?y7}\n  \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x ?y7 ?n7)\n         \\<partial>measure_pmf N) +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "{"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow>\n  emeasure (measure_pmf N) {?y7}\n  \\<le> (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x ?y7 ?n7)\n         \\<partial>measure_pmf N) +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "fix y and z :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "assume y: \"y \\<in> C\" and z: \"0 < z\" \"z < 1\""], ["proof (state)\nthis:\n  y \\<in> C\n  0 < z\n  z < 1\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have summable_int_p: \"summable (\\<lambda>n. (\\<integral> x. p x y n * indicator A x \\<partial>N) * (1 - z) * z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         measure_pmf.expectation N\n          (\\<lambda>x. p x y n * indicat_real A x) *\n         (1 - z) *\n         z ^ n)", "using \\<open>y\\<in>C\\<close> z \\<open>A \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> C\n  0 < z\n  z < 1\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         measure_pmf.expectation N\n          (\\<lambda>x. p x y n * indicat_real A x) *\n         (1 - z) *\n         z ^ n)", "by (auto intro!: summable_comparison_test[OF _ summable_mult[OF summable_geometric[of z], of 1]] exI[of _ 0] mult_le_one\n                            measure_pmf.integral_le_const integrable_real_mult_indicator integrable_p AE_I2 p_le_1\n                    simp: abs_mult integral_nonneg_AE)"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>n.\n       measure_pmf.expectation N (\\<lambda>x. p x y n * indicat_real A x) *\n       (1 - z) *\n       z ^ n)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "from y z"], ["proof (chain)\npicking this:\n  y \\<in> C\n  0 < z\n  z < 1", "have sums_y: \"(\\<lambda>n. measure N {y} * (1 - z) * z ^ n) sums measure N {y}\""], ["proof (prove)\nusing this:\n  y \\<in> C\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) sums\n    measure_pmf.prob N {y}", "using sums_mult[OF geometric_sums[of z], of \"measure N {y} * (1 - z)\"]"], ["proof (prove)\nusing this:\n  y \\<in> C\n  0 < z\n  z < 1\n  norm z < 1 \\<Longrightarrow>\n  (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) sums\n  (measure_pmf.prob N {y} * (1 - z) * (1 / (1 - z)))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) sums\n    measure_pmf.prob N {y}", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) sums\n  measure_pmf.prob N {y}\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) sums\n  measure_pmf.prob N {y}", "have \"emeasure N {y} = ennreal (\\<Sum>n. (measure N {y} * (1 - z)) * z ^ n)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) sums\n  measure_pmf.prob N {y}\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y} =\n    ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n)", "by (auto simp add: sums_unique[symmetric] measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} =\n  ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} =\n  ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<Sum>n. emeasure N {y} * (1 - z) * z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) =\n    (\\<Sum>n.\n        emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))", "using z  summable_mult[OF summable_geometric[of z], of \"measure_pmf.prob N {y} * (1 - z)\"]"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n  norm z < 1 \\<Longrightarrow>\n  summable (\\<lambda>n. measure_pmf.prob N {y} * (1 - z) * z ^ n)\n\ngoal (1 subgoal):\n 1. ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) =\n    (\\<Sum>n.\n        emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))", "by (subst suminf_ennreal[symmetric])\n           (auto simp: measure_pmf.emeasure_eq_measure ennreal_mult[symmetric] ennreal_suminf_neq_top)"], ["proof (state)\nthis:\n  ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) =\n  (\\<Sum>n.\n      emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  ennreal (\\<Sum>n. measure_pmf.prob N {y} * (1 - z) * z ^ n) =\n  (\\<Sum>n.\n      emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> \\<le> (\\<Sum>n. ((\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) + e) * (1 - z) * z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))\n    \\<le> (\\<Sum>n.\n              ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n                \\<partial>measure_pmf N) +\n               ennreal e) *\n              ennreal (1 - z) *\n              ennreal (z ^ n))", "using \\<open>y\\<in>C\\<close> z \\<open>A \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  y \\<in> C\n  0 < z\n  z < 1\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))\n    \\<le> (\\<Sum>n.\n              ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n                \\<partial>measure_pmf N) +\n               ennreal e) *\n              ennreal (1 - z) *\n              ennreal (z ^ n))", "by (intro suminf_le mult_right_mono v_le allI)\n           (auto simp: measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))\n  \\<le> (\\<Sum>n.\n            ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n              \\<partial>measure_pmf N) +\n             ennreal e) *\n            ennreal (1 - z) *\n            ennreal (z ^ n))\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      emeasure (measure_pmf N) {y} * ennreal (1 - z) * ennreal (z ^ n))\n  \\<le> (\\<Sum>n.\n            ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n              \\<partial>measure_pmf N) +\n             ennreal e) *\n            ennreal (1 - z) *\n            ennreal (z ^ n))\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<Sum>n. (\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) * (1 - z) * z ^ n) + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n          \\<partial>measure_pmf N) +\n         ennreal e) *\n        ennreal (1 - z) *\n        ennreal (z ^ n)) =\n    (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (1 - z) *\n        ennreal (z ^ n)) +\n    ennreal e", "using \\<open>0 < e\\<close> z sums_mult[OF geometric_sums[of z], of \"e * (1 - z)\"] \\<open>0<z\\<close> \\<open>z<1\\<close>"], ["proof (prove)\nusing this:\n  0 < e\n  0 < z\n  z < 1\n  norm z < 1 \\<Longrightarrow>\n  (\\<lambda>n. e * (1 - z) * z ^ n) sums (e * (1 - z) * (1 / (1 - z)))\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n          \\<partial>measure_pmf N) +\n         ennreal e) *\n        ennreal (1 - z) *\n        ennreal (z ^ n)) =\n    (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (1 - z) *\n        ennreal (z ^ n)) +\n    ennreal e", "by (simp add: distrib_right suminf_add[symmetric] ennreal_suminf_cmult[symmetric]\n                      ennreal_mult[symmetric] suminf_ennreal_eq sums_unique[symmetric]\n                 del: ennreal_suminf_cmult)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n        \\<partial>measure_pmf N) +\n       ennreal e) *\n      ennreal (1 - z) *\n      ennreal (z ^ n)) =\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (1 - z) *\n      ennreal (z ^ n)) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n        \\<partial>measure_pmf N) +\n       ennreal e) *\n      ennreal (1 - z) *\n      ennreal (z ^ n)) =\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (1 - z) *\n      ennreal (z ^ n)) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<Sum>n. ennreal (1 - z) * ((\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) * z ^ n)) + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (1 - z) *\n        ennreal (z ^ n)) +\n    ennreal e =\n    (\\<Sum>n.\n        ennreal (1 - z) *\n        ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n          \\<partial>measure_pmf N) *\n         ennreal (z ^ n))) +\n    ennreal e", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (1 - z) *\n      ennreal (z ^ n)) +\n  ennreal e =\n  (\\<Sum>n.\n      ennreal (1 - z) *\n      ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n        \\<partial>measure_pmf N) *\n       ennreal (z ^ n))) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (1 - z) *\n      ennreal (z ^ n)) +\n  ennreal e =\n  (\\<Sum>n.\n      ennreal (1 - z) *\n      ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n        \\<partial>measure_pmf N) *\n       ennreal (z ^ n))) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = ennreal (1 - z) * (\\<Sum>n. ((\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) * z ^ n)) + e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        ennreal (1 - z) *\n        ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n          \\<partial>measure_pmf N) *\n         ennreal (z ^ n))) +\n    ennreal e =\n    ennreal (1 - z) *\n    (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (z ^ n)) +\n    ennreal e", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        ennreal (1 - z) *\n        ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n          \\<partial>measure_pmf N) *\n         ennreal (z ^ n))) +\n    ennreal e =\n    ennreal (1 - z) *\n    (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (z ^ n)) +\n    ennreal e", "by (subst ennreal_suminf_cmult) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      ennreal (1 - z) *\n      ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n        \\<partial>measure_pmf N) *\n       ennreal (z ^ n))) +\n  ennreal e =\n  ennreal (1 - z) *\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (z ^ n)) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      ennreal (1 - z) *\n      ((\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n        \\<partial>measure_pmf N) *\n       ennreal (z ^ n))) +\n  ennreal e =\n  ennreal (1 - z) *\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (z ^ n)) +\n  ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"(\\<Sum>n. ((\\<integral>\\<^sup>+x. ennreal (p x y n) * indicator A x \\<partial>N) * z ^ n)) =\n          (\\<Sum>n. (\\<integral>\\<^sup>+x. ennreal (p x y n * z ^ n) * indicator A x \\<partial>N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (z ^ n)) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n        \\<partial>measure_pmf N)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n         \\<partial>measure_pmf N) *\n        ennreal (z ^ n)) =\n    (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n        \\<partial>measure_pmf N)", "by (simp add: ac_simps nn_integral_cmult[symmetric] ennreal_mult)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (z ^ n)) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n      \\<partial>measure_pmf N)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      (\\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n)\n       \\<partial>measure_pmf N) *\n      ennreal (z ^ n)) =\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n      \\<partial>measure_pmf N)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<integral>\\<^sup>+x. ennreal (gf_G x y z) * indicator A x \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n        \\<partial>measure_pmf N) =\n    \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\\<partial>measure_pmf N", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n        \\<partial>measure_pmf N) =\n    \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\\<partial>measure_pmf N", "apply (subst nn_integral_suminf[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 < z; z < 1\\<rbrakk>\n       \\<Longrightarrow> measure_pmf.random_variable N borel\n                          (\\<lambda>x.\n                              ennreal (p x y i * z ^ i) * indicator A x)\n 2. \\<lbrakk>0 < z; z < 1\\<rbrakk>\n    \\<Longrightarrow> \\<integral>\\<^sup>+ x.\n     (\\<Sum>i. ennreal (p x y i * z ^ i) * indicator A x)\n   \\<partial>measure_pmf N =\n                      \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\n                      \\<partial>measure_pmf N", "apply (auto simp add: gf_G_def simp del: suminf_ennreal\n                    intro!: ennreal_mult_right_cong suminf_ennreal2 nn_integral_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < z; z < 1; indicator A x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> summable (\\<lambda>i. p x y i * z ^ i)", "apply (intro summable_comparison_test[OF _ summable_mult[OF summable_geometric[of z], of 1]] impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>0 < z; z < 1; indicator A x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>N.\n                            \\<forall>n\\<ge>N.\n                               norm (p x y n * z ^ n) \\<le> 1 * z ^ n\n 2. \\<And>x.\n       \\<lbrakk>0 < z; z < 1; indicator A x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> norm z < 1", "apply (simp_all add: abs_mult p_le_1 mult_le_one power_le_one split: split_indicator)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n      \\<partial>measure_pmf N) =\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\\<partial>measure_pmf N\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      \\<integral>\\<^sup>+x\\<in>A. ennreal (p x y n * z ^ n)\n      \\<partial>measure_pmf N) =\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\\<partial>measure_pmf N\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = (\\<integral>\\<^sup>+x. ennreal (gf_F x y z * gf_G y y z) * indicator A x \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\n    \\<partial>measure_pmf N =\n    \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n    \\<partial>measure_pmf N", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\n    \\<partial>measure_pmf N =\n    \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n    \\<partial>measure_pmf N", "by (intro nn_integral_cong) (simp add: gf_G_eq_gf_F[symmetric])"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\\<partial>measure_pmf N =\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n  \\<partial>measure_pmf N\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_G x y z)\\<partial>measure_pmf N =\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n  \\<partial>measure_pmf N\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = ennreal (gf_G y y z) * (\\<integral>\\<^sup>+x. ennreal (gf_F x y z) * indicator A x \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n    \\<partial>measure_pmf N =\n    ennreal (gf_G y y z) *\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n     \\<partial>measure_pmf N)", "using z"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n    \\<partial>measure_pmf N =\n    ennreal (gf_G y y z) *\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n     \\<partial>measure_pmf N)", "by (subst nn_integral_cmult[symmetric]) (simp_all add: gf_G_nonneg gf_F_nonneg ac_simps ennreal_mult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n  \\<partial>measure_pmf N =\n  ennreal (gf_G y y z) *\n  (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\\<partial>measure_pmf N)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z * gf_G y y z)\n  \\<partial>measure_pmf N =\n  ennreal (gf_G y y z) *\n  (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\\<partial>measure_pmf N)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"\\<dots> = ennreal (1 / (1 - gf_U y y z)) * (\\<integral>\\<^sup>+x. ennreal (gf_F x y z) * indicator A x \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (gf_G y y z) *\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n     \\<partial>measure_pmf N) =\n    ennreal (1 / (1 - gf_U y y z)) *\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n     \\<partial>measure_pmf N)", "using z \\<open>y \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  0 < z\n  z < 1\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. ennreal (gf_G y y z) *\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n     \\<partial>measure_pmf N) =\n    ennreal (1 / (1 - gf_U y y z)) *\n    (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n     \\<partial>measure_pmf N)", "by (subst gf_G_eq_gf_U) (auto intro!: convergence_G_less_1)"], ["proof (state)\nthis:\n  ennreal (gf_G y y z) *\n  (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n   \\<partial>measure_pmf N) =\n  ennreal (1 / (1 - gf_U y y z)) *\n  (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\\<partial>measure_pmf N)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal (1 - z) *\n        (ennreal (1 / (1 - gf_U y y z)) *\n         (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n          \\<partial>measure_pmf N)) +\n        ennreal e", "have \"emeasure N {y} \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) * (\\<integral>\\<^sup>+x. gf_F x y z * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal (1 - z) *\n        (ennreal (1 / (1 - gf_U y y z)) *\n         (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n          \\<partial>measure_pmf N)) +\n        ennreal e\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y}\n    \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) *\n          \\<integral>\\<^sup>+ x. ennreal (gf_F x y z * indicat_real A x)\n                             \\<partial>measure_pmf N +\n          ennreal e", "using z"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal (1 - z) *\n        (ennreal (1 / (1 - gf_U y y z)) *\n         (\\<integral>\\<^sup>+x\\<in>A. ennreal (gf_F x y z)\n          \\<partial>measure_pmf N)) +\n        ennreal e\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y}\n    \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) *\n          \\<integral>\\<^sup>+ x. ennreal (gf_F x y z * indicat_real A x)\n                             \\<partial>measure_pmf N +\n          ennreal e", "by (subst (asm) mult.assoc[symmetric])\n           (simp add: ennreal_indicator[symmetric] ennreal_mult'[symmetric] gf_F_nonneg)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) *\n        \\<integral>\\<^sup>+ x. ennreal (gf_F x y z * indicat_real A x)\n                           \\<partial>measure_pmf N +\n        ennreal e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) *\n        \\<integral>\\<^sup>+ x. ennreal (gf_F x y z * indicat_real A x)\n                           \\<partial>measure_pmf N +\n        ennreal e", "have \"measure N {y} \\<le> (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) *\n        \\<integral>\\<^sup>+ x. ennreal (gf_F x y z * indicat_real A x)\n                           \\<partial>measure_pmf N +\n        ennreal e\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y}\n    \\<le> (1 - z) / (1 - gf_U y y z) *\n          measure_pmf.expectation N\n           (\\<lambda>x. gf_F x y z * indicat_real A x) +\n          e", "using z"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y}\n  \\<le> ennreal ((1 - z) / (1 - gf_U y y z)) *\n        \\<integral>\\<^sup>+ x. ennreal (gf_F x y z * indicat_real A x)\n                           \\<partial>measure_pmf N +\n        ennreal e\n  0 < z\n  z < 1\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y}\n    \\<le> (1 - z) / (1 - gf_U y y z) *\n          measure_pmf.expectation N\n           (\\<lambda>x. gf_F x y z * indicat_real A x) +\n          e", "by (subst (asm) nn_integral_eq_integral[OF measure_pmf.integrable_const_bound[where B=1]])\n           (auto simp: gf_F_nonneg gf_U_le_1 gf_F_le_1 measure_pmf.emeasure_eq_measure mult_le_one\n                       ennreal_mult''[symmetric] ennreal_plus[symmetric]\n                 simp del: ennreal_plus)"], ["proof (state)\nthis:\n  measure_pmf.prob N {y}\n  \\<le> (1 - z) / (1 - gf_U y y z) *\n        measure_pmf.expectation N\n         (\\<lambda>x. gf_F x y z * indicat_real A x) +\n        e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?y7 \\<in> C; 0 < ?z7; ?z7 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {?y7}\n                    \\<le> (1 - ?z7) / (1 - gf_U ?y7 ?y7 ?z7) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x ?y7 ?z7 * indicat_real A x) +\n                          e\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y7 \\<in> C; 0 < ?z7; ?z7 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {?y7}\n                    \\<le> (1 - ?z7) / (1 - gf_U ?y7 ?y7 ?z7) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x ?y7 ?z7 * indicat_real A x) +\n                          e", "have \"\\<exists>A \\<subseteq> C. finite A \\<and> (\\<forall>y\\<in>C. \\<forall>z. 0 < z \\<longrightarrow> z < 1 \\<longrightarrow> measure N {y} \\<le> (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y7 \\<in> C; 0 < ?z7; ?z7 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {?y7}\n                    \\<le> (1 - ?z7) / (1 - gf_U ?y7 ?y7 ?z7) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x ?y7 ?z7 * indicat_real A x) +\n                          e\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>C.\n       finite A \\<and>\n       (\\<forall>y\\<in>C.\n           \\<forall>z>0.\n              z < 1 \\<longrightarrow>\n              measure_pmf.prob N {y}\n              \\<le> (1 - z) / (1 - gf_U y y z) *\n                    measure_pmf.expectation N\n                     (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                    e)", "using \\<open>A \\<subseteq> C\\<close> \\<open>finite A\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y7 \\<in> C; 0 < ?z7; ?z7 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {?y7}\n                    \\<le> (1 - ?z7) / (1 - gf_U ?y7 ?y7 ?z7) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x ?y7 ?z7 * indicat_real A x) +\n                          e\n  A \\<subseteq> C\n  finite A\n\ngoal (1 subgoal):\n 1. \\<exists>A\\<subseteq>C.\n       finite A \\<and>\n       (\\<forall>y\\<in>C.\n           \\<forall>z>0.\n              z < 1 \\<longrightarrow>\n              measure_pmf.prob N {y}\n              \\<le> (1 - z) / (1 - gf_U y y z) *\n                    measure_pmf.expectation N\n                     (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                    e)", "by auto"], ["proof (state)\nthis:\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  e)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "}"], ["proof (state)\nthis:\n  0 < ?e7 \\<Longrightarrow>\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  ?e7)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "note eps = this"], ["proof (state)\nthis:\n  0 < ?e7 \\<Longrightarrow>\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  ?e7)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "{"], ["proof (state)\nthis:\n  0 < ?e7 \\<Longrightarrow>\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  ?e7)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "fix y A"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "assume \"y \\<in> C\" \"finite A\" \"A \\<subseteq> C\""], ["proof (state)\nthis:\n  y \\<in> C\n  finite A\n  A \\<subseteq> C\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  y \\<in> C\n  finite A\n  A \\<subseteq> C", "have \"((\\<lambda>z. \\<integral>x. gf_F x y z * indicator A x \\<partial>N) \\<longlongrightarrow> \\<integral>x. F x y * indicator A x \\<partial>N) (at_left 1)\""], ["proof (prove)\nusing this:\n  y \\<in> C\n  finite A\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         measure_pmf.expectation N\n          (\\<lambda>x. gf_F x y z * indicat_real A x)) \\<longlongrightarrow>\n     measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x))\n     (at_left 1)", "by (subst (1 2) integral_measure_pmf[of A]) (auto intro!: tendsto_intros gf_F simp: indicator_eq_0_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x)) \\<longlongrightarrow>\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x))\n   (at_left 1)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?y7 \\<in> C; finite ?A7; ?A7 \\<subseteq> C\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>z.\n                         measure_pmf.expectation N\n                          (\\<lambda>x.\n                              gf_F x ?y7 z *\n                              indicat_real ?A7 x)) \\<longlongrightarrow>\n                     measure_pmf.expectation N\n                      (\\<lambda>x. F x ?y7 * indicat_real ?A7 x))\n                     (at_left 1)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "note int_gf_F = this"], ["proof (state)\nthis:\n  \\<lbrakk>?y7 \\<in> C; finite ?A7; ?A7 \\<subseteq> C\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>z.\n                         measure_pmf.expectation N\n                          (\\<lambda>x.\n                              gf_F x ?y7 z *\n                              indicat_real ?A7 x)) \\<longlongrightarrow>\n                     measure_pmf.expectation N\n                      (\\<lambda>x. F x ?y7 * indicat_real ?A7 x))\n                     (at_left 1)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have all_recurrent: \"\\<forall>y\\<in>C. recurrent y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball C recurrent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "assume \"\\<not> (\\<forall>y\\<in>C. recurrent y)\""], ["proof (state)\nthis:\n  \\<not> Ball C recurrent\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Ball C recurrent", "obtain x where \"x \\<in> C\" \"\\<not> recurrent x\""], ["proof (prove)\nusing this:\n  \\<not> Ball C recurrent\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; \\<not> recurrent x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> C\n  \\<not> recurrent x\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<in> C\n  \\<not> recurrent x", "have transient: \"\\<And>x. x \\<in> C \\<Longrightarrow> \\<not> recurrent x\""], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<not> recurrent x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> \\<not> recurrent x", "using C"], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<not> recurrent x\n  essential_class C\n  countable C\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> \\<not> recurrent x", "by (auto simp: essential_class_def recurrent_iffI_communicating[symmetric] elim!: quotientE)"], ["proof (state)\nthis:\n  ?x5 \\<in> C \\<Longrightarrow> \\<not> recurrent ?x5\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  ?x5 \\<in> C \\<Longrightarrow> \\<not> recurrent ?x5\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "assume \"y \\<in> C\""], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "with transient"], ["proof (chain)\npicking this:\n  ?x5 \\<in> C \\<Longrightarrow> \\<not> recurrent ?x5\n  y \\<in> C", "have \"U y y < 1\""], ["proof (prove)\nusing this:\n  ?x5 \\<in> C \\<Longrightarrow> \\<not> recurrent ?x5\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. U y y < 1", "by (metis recurrent_iff_U_eq_1 U_cases)"], ["proof (state)\nthis:\n  U y y < 1\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "have \"measure N {y} \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} \\<le> 0", "proof (rule dense_ge)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> measure_pmf.prob N {y} \\<le> x", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> measure_pmf.prob N {y} \\<le> x", "assume \"0 < e\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> measure_pmf.prob N {y} \\<le> x", "from eps[OF this] \\<open>y \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  e)\n  y \\<in> C", "obtain A where\n          A: \"finite A\" \"A \\<subseteq> C\" and\n          le: \"\\<And>z. 0 < z \\<Longrightarrow> z < 1 \\<Longrightarrow> measure N {y} \\<le> (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  e)\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; A \\<subseteq> C;\n         \\<And>z.\n            \\<lbrakk>0 < z; z < 1\\<rbrakk>\n            \\<Longrightarrow> measure_pmf.prob N {y}\n                              \\<le> (1 - z) / (1 - gf_U y y z) *\n                                    measure_pmf.expectation N\n                                     (\\<lambda>x.\n   gf_F x y z * indicat_real A x) +\n                                    e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> C\n  \\<lbrakk>0 < ?z5; ?z5 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {y}\n                    \\<le> (1 - ?z5) / (1 - gf_U y y ?z5) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x y ?z5 * indicat_real A x) +\n                          e\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> measure_pmf.prob N {y} \\<le> x", "have \"((\\<lambda>z. (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e) \\<longlongrightarrow>\n          (1 - 1) / (1 - U y y) * (\\<integral>x. F x y * indicator A x \\<partial>N) + e) (at_left (1::real))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         (1 - z) / (1 - gf_U y y z) *\n         measure_pmf.expectation N\n          (\\<lambda>x. gf_F x y z * indicat_real A x) +\n         e) \\<longlongrightarrow>\n     (1 - 1) / (1 - U y y) *\n     measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n     e)\n     (at_left 1)", "using A \\<open>U y y < 1\\<close> \\<open>y \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> C\n  U y y < 1\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         (1 - z) / (1 - gf_U y y z) *\n         measure_pmf.expectation N\n          (\\<lambda>x. gf_F x y z * indicat_real A x) +\n         e) \\<longlongrightarrow>\n     (1 - 1) / (1 - U y y) *\n     measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n     e)\n     (at_left 1)", "by (intro tendsto_intros gf_U int_gf_F) auto"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   (1 - 1) / (1 - U y y) *\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n   e)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> measure_pmf.prob N {y} \\<le> x", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   (1 - 1) / (1 - U y y) *\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n   e)\n   (at_left 1)", "have 1: \"((\\<lambda>z. (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e) \\<longlongrightarrow> e) (at_left (1::real))\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   (1 - 1) / (1 - U y y) *\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n   e)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         (1 - z) / (1 - gf_U y y z) *\n         measure_pmf.expectation N\n          (\\<lambda>x. gf_F x y z * indicat_real A x) +\n         e) \\<longlongrightarrow>\n     e)\n     (at_left 1)", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   e)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. \\<And>x. 0 < x \\<Longrightarrow> measure_pmf.prob N {y} \\<le> x", "with le"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?z5; ?z5 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {y}\n                    \\<le> (1 - ?z5) / (1 - gf_U y y ?z5) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x y ?z5 * indicat_real A x) +\n                          e\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   e)\n   (at_left 1)", "show \"measure N {y} \\<le> e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?z5; ?z5 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {y}\n                    \\<le> (1 - ?z5) / (1 - gf_U y y ?z5) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x y ?z5 * indicat_real A x) +\n                          e\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   e)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} \\<le> e", "by (intro tendsto_le[OF trivial_limit_at_left_real _ tendsto_const])\n             (auto simp: eventually_at_left_1)"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} \\<le> e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y} \\<le> 0", "have \"measure N {y} = 0\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y} \\<le> 0\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} = 0", "by (intro antisym measure_nonneg)"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow> measure_pmf.prob N {?y7} = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?y7 \\<in> C \\<Longrightarrow> measure_pmf.prob N {?y7} = 0", "have \"emeasure N C = 0\""], ["proof (prove)\nusing this:\n  ?y7 \\<in> C \\<Longrightarrow> measure_pmf.prob N {?y7} = 0\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) C = 0", "by (subst emeasure_countable_singleton) (auto simp: measure_pmf.emeasure_eq_measure nn_integral_0_iff_AE ae_C C)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) C = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) C = 0", "show False"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) C = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>measure N C = 1\\<close>"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) C = 0\n  measure_pmf.prob N C = 1\n\ngoal (1 subgoal):\n 1. False", "by (simp add: measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball C recurrent\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  Ball C recurrent", "have \"\\<And>x. x \\<in> C \\<Longrightarrow> U x x = 1\""], ["proof (prove)\nusing this:\n  Ball C recurrent\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> U x x = 1", "by (metis recurrent_iff_U_eq_1)"], ["proof (state)\nthis:\n  ?x5 \\<in> C \\<Longrightarrow> U ?x5 ?x5 = 1\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "{"], ["proof (state)\nthis:\n  ?x5 \\<in> C \\<Longrightarrow> U ?x5 ?x5 = 1\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "fix y"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "assume \"y \\<in> C\""], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "then"], ["proof (chain)\npicking this:\n  y \\<in> C", "have \"U y y = 1\" \"recurrent y\""], ["proof (prove)\nusing this:\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. U y y = 1 &&& recurrent y", "using \\<open>y \\<in> C \\<Longrightarrow> U y y = 1\\<close> all_recurrent"], ["proof (prove)\nusing this:\n  y \\<in> C\n  y \\<in> C \\<Longrightarrow> U y y = 1\n  Ball C recurrent\n\ngoal (1 subgoal):\n 1. U y y = 1 &&& recurrent y", "by auto"], ["proof (state)\nthis:\n  U y y = 1\n  recurrent y\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "have \"measure N {y} \\<le> enn2real (1 / U' y y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y)", "proof (rule field_le_epsilon)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "fix e :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "assume \"0 < e\""], ["proof (state)\nthis:\n  0 < e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "from eps[OF \\<open>0 < e\\<close>] \\<open>y \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  e)\n  y \\<in> C", "obtain A where\n        A: \"finite A\" \"A \\<subseteq> C\" and\n        le: \"\\<And>z. 0 < z \\<Longrightarrow> z < 1 \\<Longrightarrow> measure N {y} \\<le> (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  \\<exists>A\\<subseteq>C.\n     finite A \\<and>\n     (\\<forall>y\\<in>C.\n         \\<forall>z>0.\n            z < 1 \\<longrightarrow>\n            measure_pmf.prob N {y}\n            \\<le> (1 - z) / (1 - gf_U y y z) *\n                  measure_pmf.expectation N\n                   (\\<lambda>x. gf_F x y z * indicat_real A x) +\n                  e)\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        \\<lbrakk>finite A; A \\<subseteq> C;\n         \\<And>z.\n            \\<lbrakk>0 < z; z < 1\\<rbrakk>\n            \\<Longrightarrow> measure_pmf.prob N {y}\n                              \\<le> (1 - z) / (1 - gf_U y y z) *\n                                    measure_pmf.expectation N\n                                     (\\<lambda>x.\n   gf_F x y z * indicat_real A x) +\n                                    e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  finite A\n  A \\<subseteq> C\n  \\<lbrakk>0 < ?z5; ?z5 < 1\\<rbrakk>\n  \\<Longrightarrow> measure_pmf.prob N {y}\n                    \\<le> (1 - ?z5) / (1 - gf_U y y ?z5) *\n                          measure_pmf.expectation N\n                           (\\<lambda>x. gf_F x y ?z5 * indicat_real A x) +\n                          e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "let ?L = \"at_left (1::real)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "have \"((\\<lambda>z. (1 - z) / (1 - gf_U y y z) * (\\<integral>x. gf_F x y z * indicator A x \\<partial>N) + e) \\<longlongrightarrow>\n          enn2real (1 / U' y y) * (\\<integral>x. F x y * indicator A x \\<partial>N) + e) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         (1 - z) / (1 - gf_U y y z) *\n         measure_pmf.expectation N\n          (\\<lambda>x. gf_F x y z * indicat_real A x) +\n         e) \\<longlongrightarrow>\n     enn2real (1 / U' y y) *\n     measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n     e)\n     (at_left 1)", "proof (intro tendsto_add tendsto_const tendsto_mult int_gf_F,\n             rule lhopital_left[where f'=\"\\<lambda>x. - 1\" and g'=\"\\<lambda>z. - gf_U' y y z\"])"], ["proof (state)\ngoal (10 subgoals):\n 1. ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n 2. ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n 3. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 4. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n 5. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 6. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)\n 7. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)\n 8. y \\<in> C\n 9. finite A\n 10. A \\<subseteq> C", "show \"((-) 1 \\<longlongrightarrow> 0) ?L\" \"((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((-) 1 \\<longlongrightarrow> 0) (at_left 1) &&&\n    ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)", "using gf_U[of y y]"], ["proof (prove)\nusing this:\n  (gf_U y y \\<longlongrightarrow> U y y) (at_left 1)\n\ngoal (1 subgoal):\n 1. ((-) 1 \\<longlongrightarrow> 0) (at_left 1) &&&\n    ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)", "by (auto intro!: tendsto_eq_intros simp: \\<open>U y y = 1\\<close>)"], ["proof (state)\nthis:\n  ((-) 1 \\<longlongrightarrow> 0) (at_left 1)\n  ((\\<lambda>x. 1 - gf_U y y x) \\<longlongrightarrow> 0) (at_left 1)\n\ngoal (8 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n 3. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 4. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)\n 5. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)\n 6. y \\<in> C\n 7. finite A\n 8. A \\<subseteq> C", "show \"y \\<in> C\" \"finite A\" \"A \\<subseteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> C &&& finite A &&& A \\<subseteq> C", "by fact+"], ["proof (state)\nthis:\n  y \\<in> C\n  finite A\n  A \\<subseteq> C\n\ngoal (5 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n 3. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 4. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)\n 5. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "show \"eventually (\\<lambda>x. 1 - gf_U y y x \\<noteq> 0) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0", "using gf_G_eq_gf_U(2)[OF convergence_G_less_1, where 'z=real]"], ["proof (prove)\nusing this:\n  norm ?z < 1 \\<Longrightarrow> gf_U ?x ?x ?z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0", "by (auto intro!: eventually_at_left_1)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. 1 - gf_U y y x \\<noteq> 0\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 3. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)\n 4. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "show \"((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow> enn2real (1 / U' y y)) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "using \\<open>recurrent y\\<close>"], ["proof (prove)\nusing this:\n  recurrent y\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n     enn2real (1 / U' y y))\n     (at_left 1)", "by (rule inverse_gf_U'_tendsto)"], ["proof (state)\nthis:\n  ((\\<lambda>x. - 1 / - gf_U' y y x) \\<longlongrightarrow>\n   enn2real (1 / U' y y))\n   (at_left 1)\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 3. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)", "have \"eventually (\\<lambda>x. 0 < gf_U' y y x) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x", "by (intro eventually_at_left_1 gf_U'_pos) (simp_all add: \\<open>U y y = 1\\<close>)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n 2. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 3. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x", "show \"eventually (\\<lambda>x. - gf_U' y y x \\<noteq> 0) ?L\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_left 1. 0 < gf_U' y y x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0", "by eventually_elim simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. - gf_U' y y x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n 2. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)", "show \"eventually (\\<lambda>x. DERIV (\\<lambda>x. 1 - gf_U y y x) x :> - gf_U' y y x) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1.\n       ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x)\n        (at x)", "by (auto intro!: eventually_at_left_1 derivative_eq_intros DERIV_gf_U)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1.\n     ((\\<lambda>x. 1 - gf_U y y x) has_real_derivative - gf_U' y y x) (at x)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)", "show \"eventually (\\<lambda>x. DERIV ((-) 1) x :> - 1) ?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)", "by (auto intro!: eventually_at_left_1 derivative_eq_intros)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_left 1. ((-) 1 has_real_derivative - 1) (at x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   enn2real (1 / U' y y) *\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n   e)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   enn2real (1 / U' y y) *\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n   e)\n   (at_left 1)", "have \"measure N {y} \\<le> enn2real (1 / U' y y) * (\\<integral>x. F x y * indicator A x \\<partial>N) + e\""], ["proof (prove)\nusing this:\n  ((\\<lambda>z.\n       (1 - z) / (1 - gf_U y y z) *\n       measure_pmf.expectation N\n        (\\<lambda>x. gf_F x y z * indicat_real A x) +\n       e) \\<longlongrightarrow>\n   enn2real (1 / U' y y) *\n   measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n   e)\n   (at_left 1)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y}\n    \\<le> enn2real (1 / U' y y) *\n          measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n          e", "by (rule tendsto_le[OF trivial_limit_at_left_real _ tendsto_const]) (intro eventually_at_left_1 le)"], ["proof (state)\nthis:\n  measure_pmf.prob N {y}\n  \\<le> enn2real (1 / U' y y) *\n        measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n        e\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "then"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y}\n  \\<le> enn2real (1 / U' y y) *\n        measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n        e", "have \"measure N {y} - e \\<le> enn2real (1 / U' y y) * (\\<integral>x. F x y * indicator A x \\<partial>N)\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y}\n  \\<le> enn2real (1 / U' y y) *\n        measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x) +\n        e\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} - e\n    \\<le> enn2real (1 / U' y y) *\n          measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x)", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} - e\n  \\<le> enn2real (1 / U' y y) *\n        measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "also"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} - e\n  \\<le> enn2real (1 / U' y y) *\n        measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "have \"\\<dots> \\<le> enn2real (1 / U' y y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (1 / U' y y) *\n    measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x)\n    \\<le> enn2real (1 / U' y y)", "using A"], ["proof (prove)\nusing this:\n  finite A\n  A \\<subseteq> C\n\ngoal (1 subgoal):\n 1. enn2real (1 / U' y y) *\n    measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x)\n    \\<le> enn2real (1 / U' y y)", "by (intro mult_left_le measure_pmf.integral_le_const measure_pmf.integrable_const_bound[where B=1])\n           (auto simp: mult_le_one F_le_1 U'_def)"], ["proof (state)\nthis:\n  enn2real (1 / U' y y) *\n  measure_pmf.expectation N (\\<lambda>x. F x y * indicat_real A x)\n  \\<le> enn2real (1 / U' y y)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "finally"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y} - e \\<le> enn2real (1 / U' y y)", "show \"measure N {y} \\<le> enn2real (1 / U' y y) + e\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y} - e \\<le> enn2real (1 / U' y y)\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y) + e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "}"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow>\n  measure_pmf.prob N {?y7} \\<le> enn2real (1 / U' ?y7 ?y7)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "note measure_y_le = this"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow>\n  measure_pmf.prob N {?y7} \\<le> enn2real (1 / U' ?y7 ?y7)\n\ngoal (2 subgoals):\n 1. Ball C pos_recurrent\n 2. measure_pmf N = stat C", "show pos: \"\\<forall>y\\<in>C. pos_recurrent y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball C pos_recurrent", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "assume \"\\<not> (\\<forall>y\\<in>C. pos_recurrent y)\""], ["proof (state)\nthis:\n  \\<not> Ball C pos_recurrent\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Ball C pos_recurrent", "obtain x where x: \"x \\<in> C\" \"\\<not> pos_recurrent x\""], ["proof (prove)\nusing this:\n  \\<not> Ball C pos_recurrent\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; \\<not> pos_recurrent x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> C\n  \\<not> pos_recurrent x\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  x \\<in> C\n  \\<not> pos_recurrent x\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "assume \"y \\<in> C\""], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "with x"], ["proof (chain)\npicking this:\n  x \\<in> C\n  \\<not> pos_recurrent x\n  y \\<in> C", "have \"\\<not> pos_recurrent y\""], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<not> pos_recurrent x\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> pos_recurrent y", "using C"], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<not> pos_recurrent x\n  y \\<in> C\n  essential_class C\n  countable C\n\ngoal (1 subgoal):\n 1. \\<not> pos_recurrent y", "by (auto simp: essential_class_def pos_recurrent_iffI_communicating[symmetric] elim!: quotientE)"], ["proof (state)\nthis:\n  \\<not> pos_recurrent y\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "with all_recurrent \\<open>y \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  Ball C recurrent\n  y \\<in> C\n  \\<not> pos_recurrent y", "have \"enn2real (1 / U' y y) = 0\""], ["proof (prove)\nusing this:\n  Ball C recurrent\n  y \\<in> C\n  \\<not> pos_recurrent y\n\ngoal (1 subgoal):\n 1. enn2real (1 / U' y y) = 0", "by (simp add: pos_recurrent_def nn_integral_add)"], ["proof (state)\nthis:\n  enn2real (1 / U' y y) = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "with measure_y_le[OF \\<open>y \\<in> C\\<close>]"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y)\n  enn2real (1 / U' y y) = 0", "have \"measure N {y} = 0\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y)\n  enn2real (1 / U' y y) = 0\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} = 0", "by (auto intro!: antisym simp: pos_recurrent_def)"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?y7 \\<in> C \\<Longrightarrow> measure_pmf.prob N {?y7} = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?y7 \\<in> C \\<Longrightarrow> measure_pmf.prob N {?y7} = 0", "have \"emeasure N C = 0\""], ["proof (prove)\nusing this:\n  ?y7 \\<in> C \\<Longrightarrow> measure_pmf.prob N {?y7} = 0\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) C = 0", "by (subst emeasure_countable_singleton) (auto simp: C ae_C measure_pmf.emeasure_eq_measure nn_integral_0_iff_AE)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) C = 0\n\ngoal (1 subgoal):\n 1. \\<not> Ball C pos_recurrent \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) C = 0", "show False"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) C = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>measure N C = 1\\<close>"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) C = 0\n  measure_pmf.prob N C = 1\n\ngoal (1 subgoal):\n 1. False", "by (simp add: measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball C pos_recurrent\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "{"], ["proof (state)\nthis:\n  Ball C pos_recurrent\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "fix A :: \"'s set\""], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "assume [simp]: \"countable A\""], ["proof (state)\nthis:\n  countable A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "have \"emeasure N A = (\\<integral>\\<^sup>+x. emeasure N {x} \\<partial>count_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A =\n    \\<integral>\\<^sup>+ x. emeasure (measure_pmf N) {x}\n                       \\<partial>count_space A", "by (intro emeasure_countable_singleton) auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) A =\n  \\<integral>\\<^sup>+ x. emeasure (measure_pmf N) {x}\n                     \\<partial>count_space A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) A =\n  \\<integral>\\<^sup>+ x. emeasure (measure_pmf N) {x}\n                     \\<partial>count_space A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "have \"\\<dots> \\<le> (\\<integral>\\<^sup>+x. emeasure (stat C) {x} \\<partial>count_space A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure (measure_pmf N) {x}\n                       \\<partial>count_space A\n    \\<le> \\<integral>\\<^sup>+ x. emeasure (stat C) {x}\n                             \\<partial>count_space A", "proof (intro nn_integral_mono)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space A) \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} \\<le> emeasure (stat C) {x}", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space A) \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} \\<le> emeasure (stat C) {x}", "assume \"y \\<in> space (count_space A)\""], ["proof (state)\nthis:\n  y \\<in> space (count_space A)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> space (count_space A) \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} \\<le> emeasure (stat C) {x}", "show \"emeasure N {y} \\<le> emeasure (stat C) {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "assume \"y \\<in> C\""], ["proof (state)\nthis:\n  y \\<in> C\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "with pos"], ["proof (chain)\npicking this:\n  Ball C pos_recurrent\n  y \\<in> C", "have \"pos_recurrent y\""], ["proof (prove)\nusing this:\n  Ball C pos_recurrent\n  y \\<in> C\n\ngoal (1 subgoal):\n 1. pos_recurrent y", "by auto"], ["proof (state)\nthis:\n  pos_recurrent y\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "with one_le_integral_t[of y]"], ["proof (chain)\npicking this:\n  recurrent y \\<Longrightarrow> 1 \\<le> U' y y\n  pos_recurrent y", "obtain r where r: \"U' y y = ennreal r\" \"1 \\<le> U' y y\" and [simp]: \"0 \\<le> r\""], ["proof (prove)\nusing this:\n  recurrent y \\<Longrightarrow> 1 \\<le> U' y y\n  pos_recurrent y\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>U' y y = ennreal r; 1 \\<le> U' y y; 0 \\<le> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"U' y y\") (auto simp: pos_recurrent_def nn_integral_add)"], ["proof (state)\nthis:\n  U' y y = ennreal r\n  1 \\<le> U' y y\n  0 \\<le> r\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "from measure_y_le[OF \\<open>y \\<in> C\\<close>]"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y)", "have \"emeasure N {y} \\<le> ennreal (enn2real (1 / U' y y))\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y} \\<le> enn2real (1 / U' y y)\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y} \\<le> ennreal (enn2real (1 / U' y y))", "by (simp add: measure_pmf.emeasure_eq_measure)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} \\<le> ennreal (enn2real (1 / U' y y))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} \\<le> ennreal (enn2real (1 / U' y y))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "have \"\\<dots> = emeasure (stat C) {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (enn2real (1 / U' y y)) = emeasure (stat C) {y}", "unfolding stat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (enn2real (1 / U' y y)) =\n    emeasure (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {y}", "using \\<open>y \\<in> C\\<close> r"], ["proof (prove)\nusing this:\n  y \\<in> C\n  U' y y = ennreal r\n  1 \\<le> U' y y\n\ngoal (1 subgoal):\n 1. ennreal (enn2real (1 / U' y y)) =\n    emeasure (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {y}", "by (subst emeasure_point_measure_finite2)\n             (auto simp add: ennreal_1[symmetric] divide_ennreal inverse_ennreal inverse_eq_divide ennreal_mult[symmetric]\n                   simp del: ennreal_1)"], ["proof (state)\nthis:\n  ennreal (enn2real (1 / U' y y)) = emeasure (stat C) {y}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n 2. \\<not> ?P \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "show \"emeasure N {y} \\<le> emeasure (stat C) {y}\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "by simp"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n\ngoal (1 subgoal):\n 1. y \\<notin> C \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> C \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "assume \"y \\<notin> C\""], ["proof (state)\nthis:\n  y \\<notin> C\n\ngoal (1 subgoal):\n 1. y \\<notin> C \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "with ae_C"], ["proof (chain)\npicking this:\n  AE x in measure_pmf N. x \\<in> C\n  y \\<notin> C", "have \"emeasure N {y} = 0\""], ["proof (prove)\nusing this:\n  AE x in measure_pmf N. x \\<in> C\n  y \\<notin> C\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y} = 0", "by (subst AE_iff_measurable[symmetric, where P=\"\\<lambda>x. x \\<noteq> y\"]) (auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> C \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "moreover"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> C \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "have \"emeasure (stat C) {y} = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (stat C) {y} = 0", "using emeasure_stat_not_C[OF \\<open>y \\<notin> C\\<close>]"], ["proof (prove)\nusing this:\n  emeasure (stat C) {y} = 0\n\ngoal (1 subgoal):\n 1. emeasure (stat C) {y} = 0", "."], ["proof (state)\nthis:\n  emeasure (stat C) {y} = 0\n\ngoal (1 subgoal):\n 1. y \\<notin> C \\<Longrightarrow>\n    emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "ultimately"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) {y} = 0\n  emeasure (stat C) {y} = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {y} = 0\n  emeasure (stat C) {y} = 0\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}", "by simp"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {y} \\<le> emeasure (stat C) {y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure (measure_pmf N) {x}\n                     \\<partial>count_space A\n  \\<le> \\<integral>\\<^sup>+ x. emeasure (stat C) {x} \\<partial>count_space A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure (measure_pmf N) {x}\n                     \\<partial>count_space A\n  \\<le> \\<integral>\\<^sup>+ x. emeasure (stat C) {x} \\<partial>count_space A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "have \"\\<dots> = emeasure (stat C) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. emeasure (stat C) {x} \\<partial>count_space A =\n    emeasure (stat C) A", "by (intro emeasure_countable_singleton[symmetric]) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. emeasure (stat C) {x} \\<partial>count_space A =\n  emeasure (stat C) A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "finally"], ["proof (chain)\npicking this:\n  emeasure (measure_pmf N) A \\<le> emeasure (stat C) A", "have \"emeasure N A \\<le> emeasure (stat C) A\""], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) A \\<le> emeasure (stat C) A\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A \\<le> emeasure (stat C) A", "."], ["proof (state)\nthis:\n  emeasure (measure_pmf N) A \\<le> emeasure (stat C) A\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "}"], ["proof (state)\nthis:\n  countable ?A7 \\<Longrightarrow>\n  emeasure (measure_pmf N) ?A7 \\<le> emeasure (stat C) ?A7\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "note N_le_C = this"], ["proof (state)\nthis:\n  countable ?A7 \\<Longrightarrow>\n  emeasure (measure_pmf N) ?A7 \\<le> emeasure (stat C) ?A7\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "from stat_subprob[OF C(1) \\<open>countable C\\<close> pos] N_le_C[OF \\<open>countable C\\<close>] \\<open>measure N C = 1\\<close>"], ["proof (chain)\npicking this:\n  emeasure (stat C) C \\<le> 1\n  emeasure (measure_pmf N) C \\<le> emeasure (stat C) C\n  measure_pmf.prob N C = 1", "have stat_C_eq_1: \"emeasure (stat C) C = 1\""], ["proof (prove)\nusing this:\n  emeasure (stat C) C \\<le> 1\n  emeasure (measure_pmf N) C \\<le> emeasure (stat C) C\n  measure_pmf.prob N C = 1\n\ngoal (1 subgoal):\n 1. emeasure (stat C) C = 1", "by (auto simp add: measure_pmf.emeasure_eq_measure one_ennreal_def)"], ["proof (state)\nthis:\n  emeasure (stat C) C = 1\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "moreover"], ["proof (state)\nthis:\n  emeasure (stat C) C = 1\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "have \"emeasure (stat C) (UNIV - C) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (stat C) (UNIV - C) = 0", "by (subst AE_iff_measurable[symmetric, where P=\"\\<lambda>x. x \\<in> C\"])\n       (auto simp: stat_def AE_point_measure sets_point_measure space_point_measure\n                split: split_indicator cong del: AE_cong)"], ["proof (state)\nthis:\n  emeasure (stat C) (UNIV - C) = 0\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "ultimately"], ["proof (chain)\npicking this:\n  emeasure (stat C) C = 1\n  emeasure (stat C) (UNIV - C) = 0", "have \"emeasure (stat C) (space (stat C)) = 1\""], ["proof (prove)\nusing this:\n  emeasure (stat C) C = 1\n  emeasure (stat C) (UNIV - C) = 0\n\ngoal (1 subgoal):\n 1. emeasure (stat C) (space (stat C)) = 1", "using plus_emeasure[of C \"stat C\" \"UNIV - C\"]"], ["proof (prove)\nusing this:\n  emeasure (stat C) C = 1\n  emeasure (stat C) (UNIV - C) = 0\n  \\<lbrakk>C \\<in> sets (stat C); UNIV - C \\<in> sets (stat C);\n   C \\<inter> (UNIV - C) = {}\\<rbrakk>\n  \\<Longrightarrow> emeasure (stat C) C + emeasure (stat C) (UNIV - C) =\n                    emeasure (stat C) (C \\<union> (UNIV - C))\n\ngoal (1 subgoal):\n 1. emeasure (stat C) (space (stat C)) = 1", "by (simp add: Un_absorb1)"], ["proof (state)\nthis:\n  emeasure (stat C) (space (stat C)) = 1\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "interpret stat: prob_space \"stat C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (stat C)", "by standard fact"], ["proof (state)\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "show \"measure_pmf N = stat C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf N = stat C", "proof (rule measure_eqI_countable_AE)"], ["proof (state)\ngoal (6 subgoals):\n 1. measure_pmf.events N = UNIV\n 2. stat.events = UNIV\n 3. AE x in measure_pmf N. x \\<in> ?\\<Omega>\n 4. AE x in stat C. x \\<in> ?\\<Omega>\n 5. countable ?\\<Omega>\n 6. \\<And>x.\n       x \\<in> ?\\<Omega> \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "show \"sets N = UNIV\" \"sets (stat C) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.events N = UNIV &&& stat.events = UNIV", "by auto"], ["proof (state)\nthis:\n  measure_pmf.events N = UNIV\n  stat.events = UNIV\n\ngoal (4 subgoals):\n 1. AE x in measure_pmf N. x \\<in> ?\\<Omega>\n 2. AE x in stat C. x \\<in> ?\\<Omega>\n 3. countable ?\\<Omega>\n 4. \\<And>x.\n       x \\<in> ?\\<Omega> \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "show \"countable C\" \"AE x in N. x \\<in> C\" and ae_stat: \"AE x in stat C. x \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (countable C &&& AE x in measure_pmf N. x \\<in> C) &&&\n    AE x in stat C. x \\<in> C", "using C ae_C stat_C_eq_1"], ["proof (prove)\nusing this:\n  essential_class C\n  countable C\n  AE x in measure_pmf N. x \\<in> C\n  emeasure (stat C) C = 1\n\ngoal (1 subgoal):\n 1. (countable C &&& AE x in measure_pmf N. x \\<in> C) &&&\n    AE x in stat C. x \\<in> C", "by (auto intro!: stat.AE_prob_1 simp: stat.emeasure_eq_measure)"], ["proof (state)\nthis:\n  countable C\n  AE x in measure_pmf N. x \\<in> C\n  AE x in stat C. x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "{"], ["proof (state)\nthis:\n  countable C\n  AE x in measure_pmf N. x \\<in> C\n  AE x in stat C. x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "assume \"\\<exists>x. emeasure N {x} \\<noteq> emeasure (stat C) {x}\""], ["proof (state)\nthis:\n  \\<exists>x. emeasure (measure_pmf N) {x} \\<noteq> emeasure (stat C) {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. emeasure (measure_pmf N) {x} \\<noteq> emeasure (stat C) {x}", "obtain x where [simp]: \"emeasure N {x} \\<noteq> emeasure (stat C) {x}\""], ["proof (prove)\nusing this:\n  \\<exists>x. emeasure (measure_pmf N) {x} \\<noteq> emeasure (stat C) {x}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        emeasure (measure_pmf N) {x} \\<noteq>\n        emeasure (stat C) {x} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {x} \\<noteq> emeasure (stat C) {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "with N_le_C[of \"{x}\"]"], ["proof (chain)\npicking this:\n  countable {x} \\<Longrightarrow>\n  emeasure (measure_pmf N) {x} \\<le> emeasure (stat C) {x}\n  emeasure (measure_pmf N) {x} \\<noteq> emeasure (stat C) {x}", "have x: \"emeasure N {x} < emeasure (stat C) {x}\""], ["proof (prove)\nusing this:\n  countable {x} \\<Longrightarrow>\n  emeasure (measure_pmf N) {x} \\<le> emeasure (stat C) {x}\n  emeasure (measure_pmf N) {x} \\<noteq> emeasure (stat C) {x}\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {x} < emeasure (stat C) {x}", "by (auto simp: less_le)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {x} < emeasure (stat C) {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "have \"1 = emeasure N {x} + emeasure N (C - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})", "using ae_C"], ["proof (prove)\nusing this:\n  AE x in measure_pmf N. x \\<in> C\n\ngoal (1 subgoal):\n 1. 1 = emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})", "by (subst plus_emeasure) (auto intro!: measure_pmf.emeasure_eq_1_AE)"], ["proof (state)\nthis:\n  1 = emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "also"], ["proof (state)\nthis:\n  1 = emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "have \"\\<dots> < emeasure (stat C) {x} + emeasure (stat C) (C - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})\n    < emeasure (stat C) {x} + emeasure (stat C) (C - {x})", "using x N_le_C[of \"C - {x}\"] C ae_C"], ["proof (prove)\nusing this:\n  emeasure (measure_pmf N) {x} < emeasure (stat C) {x}\n  countable (C - {x}) \\<Longrightarrow>\n  emeasure (measure_pmf N) (C - {x}) \\<le> emeasure (stat C) (C - {x})\n  essential_class C\n  countable C\n  AE x in measure_pmf N. x \\<in> C\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})\n    < emeasure (stat C) {x} + emeasure (stat C) (C - {x})", "by (simp add: stat.emeasure_eq_measure measure_pmf.emeasure_eq_measure\n                      ennreal_plus[symmetric] ennreal_less_iff\n                 del: ennreal_plus)"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})\n  < emeasure (stat C) {x} + emeasure (stat C) (C - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "also"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {x} + emeasure (measure_pmf N) (C - {x})\n  < emeasure (stat C) {x} + emeasure (stat C) (C - {x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (stat C) {x} + emeasure (stat C) (C - {x}) = 1", "using ae_stat"], ["proof (prove)\nusing this:\n  AE x in stat C. x \\<in> C\n\ngoal (1 subgoal):\n 1. emeasure (stat C) {x} + emeasure (stat C) (C - {x}) = 1", "by (subst plus_emeasure) (auto intro!: stat.emeasure_eq_1_AE)"], ["proof (state)\nthis:\n  emeasure (stat C) {x} + emeasure (stat C) (C - {x}) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "finally"], ["proof (chain)\npicking this:\n  1 < 1", "have False"], ["proof (prove)\nusing this:\n  1 < 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "}"], ["proof (state)\nthis:\n  \\<exists>x.\n     emeasure (measure_pmf N) {x} \\<noteq>\n     emeasure (stat C) {x} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     emeasure (measure_pmf N) {x} \\<noteq>\n     emeasure (stat C) {x} \\<Longrightarrow>\n  False", "show \"\\<And>x. emeasure N {x} = emeasure (stat C) {x}\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     emeasure (measure_pmf N) {x} \\<noteq>\n     emeasure (stat C) {x} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x. emeasure (measure_pmf N) {x} = emeasure (stat C) {x}", "by auto"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) {?x5} = emeasure (stat C) {?x5}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  measure_pmf N = stat C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma measure_point_measure_singleton:\n  \"x \\<in> A \\<Longrightarrow> measure (point_measure A X) {x} = enn2real (X x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    Sigma_Algebra.measure (point_measure A X) {x} = enn2real (X x)", "unfolding measure_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow>\n    enn2real (emeasure (point_measure A X) {x}) = enn2real (X x)", "by (subst emeasure_point_measure_finite2) auto"], ["", "lemma stationary_distribution_imp_int_t:\n  assumes C: \"essential_class C\" \"countable C\" \"stationary_distribution N\" \"N \\<subseteq> C\"\n  assumes x: \"x \\<in> C\" shows \"U' x x = 1 / ennreal (pmf N x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U' x x = 1 / ennreal (pmf N x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U' x x = 1 / ennreal (pmf N x)", "from stationary_distributionD[OF C]"], ["proof (chain)\npicking this:\n  Ball C pos_recurrent\n  measure_pmf N = stat C", "have \"measure_pmf N = stat C\" and *: \"\\<forall>x\\<in>C. pos_recurrent x\""], ["proof (prove)\nusing this:\n  Ball C pos_recurrent\n  measure_pmf N = stat C\n\ngoal (1 subgoal):\n 1. measure_pmf N = stat C &&& Ball C pos_recurrent", "by auto"], ["proof (state)\nthis:\n  measure_pmf N = stat C\n  Ball C pos_recurrent\n\ngoal (1 subgoal):\n 1. U' x x = 1 / ennreal (pmf N x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. U' x x = 1 / ennreal (pmf N x)", "unfolding \\<open>measure_pmf N = stat C\\<close> pmf.rep_eq stat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. U' x x =\n    1 /\n    ennreal\n     (Sigma_Algebra.measure\n       (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {x})", "using *[THEN bspec, OF x] x"], ["proof (prove)\nusing this:\n  pos_recurrent x\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. U' x x =\n    1 /\n    ennreal\n     (Sigma_Algebra.measure\n       (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {x})", "apply (simp add: measure_point_measure_singleton)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pos_recurrent x; x \\<in> C\\<rbrakk>\n    \\<Longrightarrow> U' x x = 1 / ennreal (enn2real (1 / U' x x))", "apply (cases \"U' x x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>pos_recurrent x; x \\<in> C; 0 \\<le> r;\n        U' x x = ennreal r\\<rbrakk>\n       \\<Longrightarrow> U' x x = 1 / ennreal (enn2real (1 / U' x x))\n 2. \\<lbrakk>pos_recurrent x; x \\<in> C; U' x x = \\<top>\\<rbrakk>\n    \\<Longrightarrow> U' x x = 1 / ennreal (enn2real (1 / U' x x))", "subgoal for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pos_recurrent x; x \\<in> C; 0 \\<le> r;\n     U' x x = ennreal r\\<rbrakk>\n    \\<Longrightarrow> U' x x = 1 / ennreal (enn2real (1 / U' x x))", "by (cases \"r = 0\")\n         (simp_all add: divide_ennreal_def inverse_ennreal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pos_recurrent x; x \\<in> C; U' x x = \\<top>\\<rbrakk>\n    \\<Longrightarrow> U' x x = 1 / ennreal (enn2real (1 / U' x x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  U' x x = 1 / ennreal (pmf N x)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"period_set x = {i. 0 < i \\<and> 0 < p x x i }\""], ["", "definition \"period C = (SOME d. \\<forall>x\\<in>C. d = Gcd (period_set x))\""], ["", "lemma Gcd_period_set_invariant:\n  assumes c: \"(x, y) \\<in> communicating\"\n  shows \"Gcd (period_set x) = Gcd (period_set y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "fix x y n"], ["proof (state)\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "assume c: \"(x, y) \\<in> communicating\" \"x \\<noteq> y\" and n: \"n \\<in> period_set x\""], ["proof (state)\nthis:\n  (x, y) \\<in> communicating\n  x \\<noteq> y\n  n \\<in> period_set x\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "from c"], ["proof (chain)\npicking this:\n  (x, y) \\<in> communicating\n  x \\<noteq> y", "obtain l k where \"0 < p x y l\" \"0 < p y x k\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> communicating\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (\\<And>l k.\n        \\<lbrakk>0 < p x y l; 0 < p y x k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: communicating_def dest!: accD_pos)"], ["proof (state)\nthis:\n  0 < p x y l\n  0 < p y x k\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "moreover"], ["proof (state)\nthis:\n  0 < p x y l\n  0 < p y x k\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  0 < p x y l\n  0 < p y x k", "have \"l \\<noteq> 0 \\<and> k \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  0 < p x y l\n  0 < p y x k\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0 \\<and> k \\<noteq> 0", "by (intro notI conjI) (auto simp: p_0)"], ["proof (state)\nthis:\n  l \\<noteq> 0 \\<and> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "ultimately"], ["proof (chain)\npicking this:\n  0 < p x y l\n  0 < p y x k\n  l \\<noteq> 0 \\<and> k \\<noteq> 0", "have pos: \"0 < l\" \"0 < k\" and l: \"0 < p x y l\" and k: \"0 < p y x k\""], ["proof (prove)\nusing this:\n  0 < p x y l\n  0 < p y x k\n  l \\<noteq> 0 \\<and> k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (0 < l &&& 0 < k) &&& 0 < p x y l &&& 0 < p y x k", "by auto"], ["proof (state)\nthis:\n  0 < l\n  0 < k\n  0 < p x y l\n  0 < p y x k\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "from mult_pos_pos[OF k l] prob_reachable_le[of k \"k + l\" y x y] c"], ["proof (chain)\npicking this:\n  0 < p y x k * p x y l\n  k \\<le> k + l \\<Longrightarrow>\n  p y x k * p x y (k + l - k) \\<le> p y y (k + l)\n  (x, y) \\<in> communicating\n  x \\<noteq> y", "have k_l: \"0 < p y y (k + l)\""], ["proof (prove)\nusing this:\n  0 < p y x k * p x y l\n  k \\<le> k + l \\<Longrightarrow>\n  p y x k * p x y (k + l - k) \\<le> p y y (k + l)\n  (x, y) \\<in> communicating\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < p y y (k + l)", "by simp"], ["proof (state)\nthis:\n  0 < p y y (k + l)\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "then"], ["proof (chain)\npicking this:\n  0 < p y y (k + l)", "have \"Gcd (period_set y) dvd k + l\""], ["proof (prove)\nusing this:\n  0 < p y y (k + l)\n\ngoal (1 subgoal):\n 1. Gcd (period_set y) dvd k + l", "using pos"], ["proof (prove)\nusing this:\n  0 < p y y (k + l)\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. Gcd (period_set y) dvd k + l", "by (auto intro!: Gcd_dvd_nat simp: period_set_def)"], ["proof (state)\nthis:\n  Gcd (period_set y) dvd k + l\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "moreover"], ["proof (state)\nthis:\n  Gcd (period_set y) dvd k + l\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "from n"], ["proof (chain)\npicking this:\n  n \\<in> period_set x", "have \"0 < p x x n\" \"0 < n\""], ["proof (prove)\nusing this:\n  n \\<in> period_set x\n\ngoal (1 subgoal):\n 1. 0 < p x x n &&& 0 < n", "by (auto simp: period_set_def)"], ["proof (state)\nthis:\n  0 < p x x n\n  0 < n\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "from mult_pos_pos[OF k this(1)] prob_reachable_le[of k \"k + n\" y x x] c"], ["proof (chain)\npicking this:\n  0 < p y x k * p x x n\n  k \\<le> k + n \\<Longrightarrow>\n  p y x k * p x x (k + n - k) \\<le> p y x (k + n)\n  (x, y) \\<in> communicating\n  x \\<noteq> y", "have \"0 < p y x (k + n)\""], ["proof (prove)\nusing this:\n  0 < p y x k * p x x n\n  k \\<le> k + n \\<Longrightarrow>\n  p y x k * p x x (k + n - k) \\<le> p y x (k + n)\n  (x, y) \\<in> communicating\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < p y x (k + n)", "by simp"], ["proof (state)\nthis:\n  0 < p y x (k + n)\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "from mult_pos_pos[OF this(1) l] prob_reachable_le[of \"k + n\" \"(k + n) + l\" y x y] c"], ["proof (chain)\npicking this:\n  0 < p y x (k + n) * p x y l\n  k + n \\<le> k + n + l \\<Longrightarrow>\n  p y x (k + n) * p x y (k + n + l - (k + n)) \\<le> p y y (k + n + l)\n  (x, y) \\<in> communicating\n  x \\<noteq> y", "have \"0 < p y y (k + n + l)\""], ["proof (prove)\nusing this:\n  0 < p y x (k + n) * p x y l\n  k + n \\<le> k + n + l \\<Longrightarrow>\n  p y x (k + n) * p x y (k + n + l - (k + n)) \\<le> p y y (k + n + l)\n  (x, y) \\<in> communicating\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. 0 < p y y (k + n + l)", "by simp"], ["proof (state)\nthis:\n  0 < p y y (k + n + l)\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "then"], ["proof (chain)\npicking this:\n  0 < p y y (k + n + l)", "have \"Gcd (period_set y) dvd (k + l) + n\""], ["proof (prove)\nusing this:\n  0 < p y y (k + n + l)\n\ngoal (1 subgoal):\n 1. Gcd (period_set y) dvd k + l + n", "using pos"], ["proof (prove)\nusing this:\n  0 < p y y (k + n + l)\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. Gcd (period_set y) dvd k + l + n", "by (auto intro!: Gcd_dvd_nat simp: period_set_def ac_simps)"], ["proof (state)\nthis:\n  Gcd (period_set y) dvd k + l + n\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "ultimately"], ["proof (chain)\npicking this:\n  Gcd (period_set y) dvd k + l\n  Gcd (period_set y) dvd k + l + n", "have \"Gcd (period_set y) dvd n\""], ["proof (prove)\nusing this:\n  Gcd (period_set y) dvd k + l\n  Gcd (period_set y) dvd k + l + n\n\ngoal (1 subgoal):\n 1. Gcd (period_set y) dvd n", "by (metis dvd_add_left_iff add.commute)"], ["proof (state)\nthis:\n  Gcd (period_set y) dvd n\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa6, ?ya6) \\<in> communicating; ?xa6 \\<noteq> ?ya6;\n   ?n6 \\<in> period_set ?xa6\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set ?ya6) dvd ?n6\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "note this[of x y] this[of y x] c"], ["proof (state)\nthis:\n  \\<lbrakk>(x, y) \\<in> communicating; x \\<noteq> y;\n   ?n6 \\<in> period_set x\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set y) dvd ?n6\n  \\<lbrakk>(y, x) \\<in> communicating; y \\<noteq> x;\n   ?n6 \\<in> period_set y\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set x) dvd ?n6\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>(x, y) \\<in> communicating; x \\<noteq> y;\n   ?n6 \\<in> period_set x\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set y) dvd ?n6\n  \\<lbrakk>(y, x) \\<in> communicating; y \\<noteq> x;\n   ?n6 \\<in> period_set y\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set x) dvd ?n6\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "have \"(y, x) \\<in> communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<in> communicating", "using c"], ["proof (prove)\nusing this:\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> communicating", "by (simp add: communicating_def)"], ["proof (state)\nthis:\n  (y, x) \\<in> communicating\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>(x, y) \\<in> communicating; x \\<noteq> y;\n   ?n6 \\<in> period_set x\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set y) dvd ?n6\n  \\<lbrakk>(y, x) \\<in> communicating; y \\<noteq> x;\n   ?n6 \\<in> period_set y\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set x) dvd ?n6\n  (x, y) \\<in> communicating\n  (y, x) \\<in> communicating", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(x, y) \\<in> communicating; x \\<noteq> y;\n   ?n6 \\<in> period_set x\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set y) dvd ?n6\n  \\<lbrakk>(y, x) \\<in> communicating; y \\<noteq> x;\n   ?n6 \\<in> period_set y\\<rbrakk>\n  \\<Longrightarrow> Gcd (period_set x) dvd ?n6\n  (x, y) \\<in> communicating\n  (y, x) \\<in> communicating\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) = Gcd (period_set y)", "by (auto intro: dvd_antisym Gcd_greatest Gcd_dvd)"], ["proof (state)\nthis:\n  Gcd (period_set x) = Gcd (period_set y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma period_eq:\n  assumes \"C \\<in> UNIV // communicating\" \"x \\<in> C\"\n  shows \"period C = Gcd (period_set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. period C = Gcd (period_set x)", "unfolding period_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME d. \\<forall>x\\<in>C. d = Gcd (period_set x)) = Gcd (period_set x)", "using assms"], ["proof (prove)\nusing this:\n  C \\<in> UNIV // communicating\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. (SOME d. \\<forall>x\\<in>C. d = Gcd (period_set x)) = Gcd (period_set x)", "by (rule_tac someI2[where a=\"Gcd (period_set x)\"])\n     (auto intro!: Gcd_period_set_invariant irreducibleD)"], ["", "definition \"aperiodic C \\<longleftrightarrow> C \\<in> UNIV // communicating \\<and> period C = 1\""], ["", "definition \"not_ephemeral C \\<longleftrightarrow> C \\<in> UNIV // communicating \\<and> \\<not> (\\<exists>x. C = {x} \\<and> p x x 1 = 0)\""], ["", "lemma not_ephemeralD:\n  assumes C: \"not_ephemeral C\" \"x \\<in> C\"\n  shows \"\\<exists>n>0. 0 < p x x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "assume \"\\<exists>x. C = {x}\""], ["proof (state)\nthis:\n  \\<exists>x. C = {x}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> C\n  \\<exists>x. C = {x}", "have \"C = {x}\""], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<exists>x. C = {x}\n\ngoal (1 subgoal):\n 1. C = {x}", "by auto"], ["proof (state)\nthis:\n  C = {x}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with C p_nonneg[of x x 1]"], ["proof (chain)\npicking this:\n  not_ephemeral C\n  x \\<in> C\n  0 \\<le> p x x 1\n  C = {x}", "have \"0 < p x x 1\""], ["proof (prove)\nusing this:\n  not_ephemeral C\n  x \\<in> C\n  0 \\<le> p x x 1\n  C = {x}\n\ngoal (1 subgoal):\n 1. 0 < p x x 1", "by (auto simp: not_ephemeral_def less_le)"], ["proof (state)\nthis:\n  0 < p x x 1\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with \\<open>C = {x}\\<close>"], ["proof (chain)\npicking this:\n  C = {x}\n  0 < p x x 1", "show ?thesis"], ["proof (prove)\nusing this:\n  C = {x}\n  0 < p x x 1\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n>0. 0 < p x x n\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "from C"], ["proof (chain)\npicking this:\n  not_ephemeral C\n  x \\<in> C", "have irr: \"C \\<in> UNIV // communicating\""], ["proof (prove)\nusing this:\n  not_ephemeral C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating", "by (auto simp: not_ephemeral_def)"], ["proof (state)\nthis:\n  C \\<in> UNIV // communicating\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "assume \"\\<not>(\\<exists>x. C = {x})\""], ["proof (state)\nthis:\n  \\<nexists>x. C = {x}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "then"], ["proof (chain)\npicking this:\n  \\<nexists>x. C = {x}", "have \"\\<forall>x. C \\<noteq> {x}\""], ["proof (prove)\nusing this:\n  \\<nexists>x. C = {x}\n\ngoal (1 subgoal):\n 1. \\<forall>x. C \\<noteq> {x}", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. C \\<noteq> {x}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> C\n  \\<forall>x. C \\<noteq> {x}", "obtain y where \"y \\<in> C\" \"x \\<noteq> y\""], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<forall>x. C \\<noteq> {x}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> C; x \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> C\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with irreducibleD[OF irr, of x y] C \\<open>x \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> C; y \\<in> C\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> communicating\n  not_ephemeral C\n  x \\<in> C\n  x \\<in> C\n  y \\<in> C\n  x \\<noteq> y", "have c: \"(x, y) \\<in> communicating\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> C; y \\<in> C\\<rbrakk>\n  \\<Longrightarrow> (x, y) \\<in> communicating\n  not_ephemeral C\n  x \\<in> C\n  x \\<in> C\n  y \\<in> C\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> communicating", "by auto"], ["proof (state)\nthis:\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with accD_pos[of x y] accD_pos[of y x]"], ["proof (chain)\npicking this:\n  (x, y) \\<in> acc \\<Longrightarrow> \\<exists>n. 0 < p x y n\n  (y, x) \\<in> acc \\<Longrightarrow> \\<exists>n. 0 < p y x n\n  (x, y) \\<in> communicating", "obtain k l where pos: \"0 < p x y k\" \"0 < p y x l\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> acc \\<Longrightarrow> \\<exists>n. 0 < p x y n\n  (y, x) \\<in> acc \\<Longrightarrow> \\<exists>n. 0 < p y x n\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (\\<And>k l.\n        \\<lbrakk>0 < p x y k; 0 < p y x l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: communicating_def)"], ["proof (state)\nthis:\n  0 < p x y k\n  0 < p y x l\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "with \\<open>x \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> y\n  0 < p x y k\n  0 < p y x l", "have \"l \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  0 < p x y k\n  0 < p y x l\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "by (intro notI) (auto simp: p_0)"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "have \"0 < p x y k * p y x (k + l - k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p x y k * p y x (k + l - k)", "using pos"], ["proof (prove)\nusing this:\n  0 < p x y k\n  0 < p y x l\n\ngoal (1 subgoal):\n 1. 0 < p x y k * p y x (k + l - k)", "by auto"], ["proof (state)\nthis:\n  0 < p x y k * p y x (k + l - k)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "also"], ["proof (state)\nthis:\n  0 < p x y k * p y x (k + l - k)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "have \"p x y k * p y x (k + l - k) \\<le> p x x (k + l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y k * p y x (k + l - k) \\<le> p x x (k + l)", "using prob_reachable_le[of \"k\" \"k + l\" x y x] c"], ["proof (prove)\nusing this:\n  k \\<le> k + l \\<Longrightarrow>\n  p x y k * p y x (k + l - k) \\<le> p x x (k + l)\n  (x, y) \\<in> communicating\n\ngoal (1 subgoal):\n 1. p x y k * p y x (k + l - k) \\<le> p x x (k + l)", "by auto"], ["proof (state)\nthis:\n  p x y k * p y x (k + l - k) \\<le> p x x (k + l)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. C = {x} \\<Longrightarrow> \\<exists>n>0. 0 < p x x n", "finally"], ["proof (chain)\npicking this:\n  0 < p x x (k + l)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < p x x (k + l)\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "using \\<open>l \\<noteq> 0\\<close> \\<open>x \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  0 < p x x (k + l)\n  l \\<noteq> 0\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "by (auto intro!: exI[of _ \"k + l\"])"], ["proof (state)\nthis:\n  \\<exists>n>0. 0 < p x x n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_ephemeralD_pos_period:\n  assumes C: \"not_ephemeral C\"\n  shows \"0 < period C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < period C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < period C", "from C not_empty_irreducible[of C]"], ["proof (chain)\npicking this:\n  not_ephemeral C\n  C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}", "obtain x where \"x \\<in> C\""], ["proof (prove)\nusing this:\n  not_ephemeral C\n  C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: not_ephemeral_def)"], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. 0 < period C", "from not_ephemeralD[OF C this]"], ["proof (chain)\npicking this:\n  \\<exists>n>0. 0 < p x x n", "obtain n where n: \"0 < p x x n\" \"0 < n\""], ["proof (prove)\nusing this:\n  \\<exists>n>0. 0 < p x x n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>0 < p x x n; 0 < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < p x x n\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < period C", "have C': \"C \\<in> UNIV // communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating", "using C"], ["proof (prove)\nusing this:\n  not_ephemeral C\n\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating", "by (auto simp: not_ephemeral_def)"], ["proof (state)\nthis:\n  C \\<in> UNIV // communicating\n\ngoal (1 subgoal):\n 1. 0 < period C", "have \"period C \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. period C \\<noteq> 0", "unfolding period_eq [OF C' \\<open>x \\<in> C\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd (period_set x) \\<noteq> 0", "using n"], ["proof (prove)\nusing this:\n  0 < p x x n\n  0 < n\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) \\<noteq> 0", "by (auto simp: period_set_def)"], ["proof (state)\nthis:\n  period C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < period C", "then"], ["proof (chain)\npicking this:\n  period C \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  period C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < period C", "by auto"], ["proof (state)\nthis:\n  0 < period C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma period_posD:\n  assumes C: \"C \\<in> UNIV // communicating\" and \"0 < period C\" \"x \\<in> C\"\n  shows \"\\<exists>n>0. 0 < p x x n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "from \\<open>0 < period C\\<close>"], ["proof (chain)\npicking this:\n  0 < period C", "have \"period C \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < period C\n\ngoal (1 subgoal):\n 1. period C \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  period C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "then"], ["proof (chain)\npicking this:\n  period C \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  period C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "unfolding period_eq [OF C \\<open>x \\<in> C\\<close>]"], ["proof (prove)\nusing this:\n  Gcd (period_set x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "unfolding period_set_def"], ["proof (prove)\nusing this:\n  Gcd {i. 0 < i \\<and> 0 < p x x i} \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>n>0. 0 < p x x n", "by auto"], ["proof (state)\nthis:\n  \\<exists>n>0. 0 < p x x n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_ephemeralD_pos_period':\n  assumes C: \"C \\<in> UNIV // communicating\"\n  shows \"not_ephemeral C \\<longleftrightarrow> 0 < period C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not_ephemeral C = (0 < period C)", "proof (auto dest!: not_ephemeralD_pos_period intro: C)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < period C \\<Longrightarrow> not_ephemeral C", "from C not_empty_irreducible[of C]"], ["proof (chain)\npicking this:\n  C \\<in> UNIV // communicating\n  C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}", "obtain x where \"x \\<in> C\""], ["proof (prove)\nusing this:\n  C \\<in> UNIV // communicating\n  C \\<in> UNIV // communicating \\<Longrightarrow> C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto simp: not_ephemeral_def)"], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. 0 < period C \\<Longrightarrow> not_ephemeral C", "assume \"0 < period C\""], ["proof (state)\nthis:\n  0 < period C\n\ngoal (1 subgoal):\n 1. 0 < period C \\<Longrightarrow> not_ephemeral C", "then"], ["proof (chain)\npicking this:\n  0 < period C", "show \"not_ephemeral C\""], ["proof (prove)\nusing this:\n  0 < period C\n\ngoal (1 subgoal):\n 1. not_ephemeral C", "apply (auto simp: not_ephemeral_def C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>0 < period {x}; C = {x}; p x x (Suc 0) = 0\\<rbrakk>\n       \\<Longrightarrow> False", "oops \\<comment> \\<open>should be easy to finish\\<close>"], ["", "lemma eventually_periodic:\n  assumes C: \"C \\<in> UNIV // communicating\" \"0 < period C\" \"x \\<in> C\"\n  shows \"eventually (\\<lambda>m. 0 < p x x (m * period C)) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "from period_posD[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>n>0. 0 < p x x n", "obtain n where n: \"0 < p x x n\" \"0 < n\""], ["proof (prove)\nusing this:\n  \\<exists>n>0. 0 < p x x n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>0 < p x x n; 0 < n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < p x x n\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "have C': \"C \\<in> UNIV // communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating", "using C"], ["proof (prove)\nusing this:\n  C \\<in> UNIV // communicating\n  0 < period C\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating", "by auto"], ["proof (state)\nthis:\n  C \\<in> UNIV // communicating\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "have \"period C \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. period C \\<noteq> 0", "unfolding period_eq [OF C' \\<open>x \\<in> C\\<close>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd (period_set x) \\<noteq> 0", "using n"], ["proof (prove)\nusing this:\n  0 < p x x n\n  0 < n\n\ngoal (1 subgoal):\n 1. Gcd (period_set x) \\<noteq> 0", "by (auto simp: period_set_def)"], ["proof (state)\nthis:\n  period C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "have \"eventually (\\<lambda>m. m * Gcd (period_set x) \\<in> (period_set x)) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       m * Gcd (period_set x) \\<in> period_set x", "proof (rule eventually_mult_Gcd)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x\n 2. ?s \\<in> period_set x\n 3. 0 < ?s", "show \"n > 0\" \"n \\<in> period_set x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n &&& n \\<in> period_set x", "using n"], ["proof (prove)\nusing this:\n  0 < p x x n\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 < n &&& n \\<in> period_set x", "by (auto simp add: period_set_def)"], ["proof (state)\nthis:\n  0 < n\n  n \\<in> period_set x\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x", "fix k l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x", "assume \"k \\<in> period_set x\" \"l \\<in> period_set x\""], ["proof (state)\nthis:\n  k \\<in> period_set x\n  l \\<in> period_set x\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x", "then"], ["proof (chain)\npicking this:\n  k \\<in> period_set x\n  l \\<in> period_set x", "have \"0 < p x x k * p x x l\" \"0 < l\" \"0 < k\""], ["proof (prove)\nusing this:\n  k \\<in> period_set x\n  l \\<in> period_set x\n\ngoal (1 subgoal):\n 1. 0 < p x x k * p x x l &&& 0 < l &&& 0 < k", "by (auto simp: period_set_def)"], ["proof (state)\nthis:\n  0 < p x x k * p x x l\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x", "moreover"], ["proof (state)\nthis:\n  0 < p x x k * p x x l\n  0 < l\n  0 < k\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x", "have \"p x x k * p x x l \\<le> p x x (k + l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x x k * p x x l \\<le> p x x (k + l)", "using prob_reachable_le[of k \"k + l\" x x x] \\<open>x \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  k \\<le> k + l \\<Longrightarrow>\n  p x x k * p x x (k + l - k) \\<le> p x x (k + l)\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. p x x k * p x x l \\<le> p x x (k + l)", "by auto"], ["proof (state)\nthis:\n  p x x k * p x x l \\<le> p x x (k + l)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>s \\<in> period_set x; t \\<in> period_set x\\<rbrakk>\n       \\<Longrightarrow> s + t \\<in> period_set x", "ultimately"], ["proof (chain)\npicking this:\n  0 < p x x k * p x x l\n  0 < l\n  0 < k\n  p x x k * p x x l \\<le> p x x (k + l)", "show \"k + l \\<in> period_set x\""], ["proof (prove)\nusing this:\n  0 < p x x k * p x x l\n  0 < l\n  0 < k\n  p x x k * p x x l \\<le> p x x (k + l)\n\ngoal (1 subgoal):\n 1. k + l \\<in> period_set x", "using \\<open>0 < l\\<close>"], ["proof (prove)\nusing this:\n  0 < p x x k * p x x l\n  0 < l\n  0 < k\n  p x x k * p x x l \\<le> p x x (k + l)\n  0 < l\n\ngoal (1 subgoal):\n 1. k + l \\<in> period_set x", "by (auto simp: period_set_def)"], ["proof (state)\nthis:\n  k + l \\<in> period_set x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     m * Gcd (period_set x) \\<in> period_set x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "with eventually_ge_at_top[of 1]"], ["proof (chain)\npicking this:\n  eventually ((\\<le>) (1::?'a4)) at_top\n  \\<forall>\\<^sub>F m in sequentially.\n     m * Gcd (period_set x) \\<in> period_set x", "show \"eventually (\\<lambda>m. 0 < p x x (m * period C)) sequentially\""], ["proof (prove)\nusing this:\n  eventually ((\\<le>) (1::?'a4)) at_top\n  \\<forall>\\<^sub>F m in sequentially.\n     m * Gcd (period_set x) \\<in> period_set x\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)", "by eventually_elim \n       (insert \\<open>period C \\<noteq> 0\\<close> period_eq[OF C' \\<open>x \\<in> C\\<close>, symmetric], auto simp: period_set_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially. 0 < p x x (m * period C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aperiodic_eventually_recurrent:\n  \"aperiodic C \\<longleftrightarrow> C \\<in> UNIV // communicating \\<and> (\\<forall>x\\<in>C. eventually (\\<lambda>m. 0 < p x x m) sequentially)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aperiodic C =\n    (C \\<in> UNIV // communicating \\<and>\n     (\\<forall>x\\<in>C. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<And>x.\n       \\<lbrakk>aperiodic C; x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n 3. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<And>x.\n       \\<lbrakk>aperiodic C; x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n 3. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "assume \"x \\<in> C\" \"aperiodic C\""], ["proof (state)\nthis:\n  x \\<in> C\n  aperiodic C\n\ngoal (3 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<And>x.\n       \\<lbrakk>aperiodic C; x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n 3. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "with eventually_periodic[of C x]"], ["proof (chain)\npicking this:\n  \\<lbrakk>C \\<in> UNIV // communicating; 0 < period C; x \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                       0 < p x x (m * period C)\n  x \\<in> C\n  aperiodic C", "show \"eventually (\\<lambda>m. 0 < p x x m) sequentially\""], ["proof (prove)\nusing this:\n  \\<lbrakk>C \\<in> UNIV // communicating; 0 < period C; x \\<in> C\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                       0 < p x x (m * period C)\n  x \\<in> C\n  aperiodic C\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m", "by (auto simp add: aperiodic_def)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "assume \"\\<forall>x\\<in>C. eventually (\\<lambda>m. 0 < p x x m) sequentially\" and C: \"C \\<in> UNIV // communicating\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>C. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n  C \\<in> UNIV // communicating\n\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>C. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n  C \\<in> UNIV // communicating\n\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "from not_empty_irreducible[OF C]"], ["proof (chain)\npicking this:\n  C \\<noteq> {}", "obtain x where \"x \\<in> C\""], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>C. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n  C \\<in> UNIV // communicating\n  x \\<in> C", "obtain N where \"\\<And>M.  M\\<ge>N \\<Longrightarrow> 0 < p x x M\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>C. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\n  C \\<in> UNIV // communicating\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        (\\<And>M. N \\<le> M \\<Longrightarrow> 0 < p x x M) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_sequentially)"], ["proof (state)\nthis:\n  N \\<le> ?M4 \\<Longrightarrow> 0 < p x x ?M4\n\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "then"], ["proof (chain)\npicking this:\n  N \\<le> ?M4 \\<Longrightarrow> 0 < p x x ?M4", "have \"{N <..} \\<subseteq> period_set x\""], ["proof (prove)\nusing this:\n  N \\<le> ?M4 \\<Longrightarrow> 0 < p x x ?M4\n\ngoal (1 subgoal):\n 1. {N<..} \\<subseteq> period_set x", "by (auto simp: period_set_def)"], ["proof (state)\nthis:\n  {N<..} \\<subseteq> period_set x\n\ngoal (2 subgoals):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating\n 2. \\<lbrakk>C \\<in> UNIV // communicating;\n     \\<forall>x\\<in>C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m\\<rbrakk>\n    \\<Longrightarrow> aperiodic C", "from C"], ["proof (chain)\npicking this:\n  C \\<in> UNIV // communicating", "show \"aperiodic C\""], ["proof (prove)\nusing this:\n  C \\<in> UNIV // communicating\n\ngoal (1 subgoal):\n 1. aperiodic C", "unfolding period_eq [OF C \\<open>x \\<in> C\\<close>] aperiodic_def"], ["proof (prove)\nusing this:\n  C \\<in> UNIV // communicating\n\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating \\<and> Gcd (period_set x) = 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Gcd (period_set x) = 1", "show \"Gcd (period_set x) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gcd (period_set x) = 1", "proof (rule Gcd_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>b. b \\<in> period_set x \\<Longrightarrow> 1 dvd b\n 3. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "from one_dvd"], ["proof (chain)\npicking this:\n  (1::?'a) dvd ?a", "show \"1 dvd q\" for q :: nat"], ["proof (prove)\nusing this:\n  (1::?'a) dvd ?a\n\ngoal (1 subgoal):\n 1. 1 dvd q", "."], ["proof (state)\nthis:\n  1 dvd ?q4\n\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "assume \"\\<And>q. q \\<in> period_set x \\<Longrightarrow> m dvd q\""], ["proof (state)\nthis:\n  ?q4 \\<in> period_set x \\<Longrightarrow> m dvd ?q4\n\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "moreover"], ["proof (state)\nthis:\n  ?q4 \\<in> period_set x \\<Longrightarrow> m dvd ?q4\n\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "from \\<open>{N <..} \\<subseteq> period_set x\\<close>"], ["proof (chain)\npicking this:\n  {N<..} \\<subseteq> period_set x", "have \"{Suc N, Suc (Suc N)} \\<subseteq> period_set x\""], ["proof (prove)\nusing this:\n  {N<..} \\<subseteq> period_set x\n\ngoal (1 subgoal):\n 1. {Suc N, Suc (Suc N)} \\<subseteq> period_set x", "by auto"], ["proof (state)\nthis:\n  {Suc N, Suc (Suc N)} \\<subseteq> period_set x\n\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "ultimately"], ["proof (chain)\npicking this:\n  ?q4 \\<in> period_set x \\<Longrightarrow> m dvd ?q4\n  {Suc N, Suc (Suc N)} \\<subseteq> period_set x", "have \"m dvd Suc (Suc N)\" and \"m dvd Suc N\""], ["proof (prove)\nusing this:\n  ?q4 \\<in> period_set x \\<Longrightarrow> m dvd ?q4\n  {Suc N, Suc (Suc N)} \\<subseteq> period_set x\n\ngoal (1 subgoal):\n 1. m dvd Suc (Suc N) &&& m dvd Suc N", "by auto"], ["proof (state)\nthis:\n  m dvd Suc (Suc N)\n  m dvd Suc N\n\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "then"], ["proof (chain)\npicking this:\n  m dvd Suc (Suc N)\n  m dvd Suc N", "have \"m dvd Suc (Suc N) - Suc N\""], ["proof (prove)\nusing this:\n  m dvd Suc (Suc N)\n  m dvd Suc N\n\ngoal (1 subgoal):\n 1. m dvd Suc (Suc N) - Suc N", "by (rule dvd_diff_nat)"], ["proof (state)\nthis:\n  m dvd Suc (Suc N) - Suc N\n\ngoal (2 subgoals):\n 1. normalize 1 = 1\n 2. \\<And>c.\n       (\\<And>b.\n           b \\<in> period_set x \\<Longrightarrow> c dvd b) \\<Longrightarrow>\n       is_unit c", "then"], ["proof (chain)\npicking this:\n  m dvd Suc (Suc N) - Suc N", "show \"is_unit m\""], ["proof (prove)\nusing this:\n  m dvd Suc (Suc N) - Suc N\n\ngoal (1 subgoal):\n 1. is_unit m", "by simp"], ["proof (state)\nthis:\n  is_unit m\n\ngoal (1 subgoal):\n 1. normalize 1 = 1", "qed simp"], ["proof (state)\nthis:\n  Gcd (period_set x) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aperiodic C\n\ngoal (1 subgoal):\n 1. aperiodic C \\<Longrightarrow> C \\<in> UNIV // communicating", "qed (simp add: aperiodic_def)"], ["", "lemma stationary_distributionD_emeasure:\n  assumes N: \"stationary_distribution N\"\n  shows \"emeasure N A = (\\<integral>\\<^sup>+s. emeasure (K s) A \\<partial>N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A =\n    \\<integral>\\<^sup>+ s. emeasure (measure_pmf (K s)) A\n                       \\<partial>measure_pmf N", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A =\n    \\<integral>\\<^sup>+ s. emeasure (measure_pmf (K s)) A\n                       \\<partial>measure_pmf N", "have \"prob_space (measure_pmf N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_space (measure_pmf N)", "by intro_locales"], ["proof (state)\nthis:\n  prob_space (measure_pmf N)\n\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A =\n    \\<integral>\\<^sup>+ s. emeasure (measure_pmf (K s)) A\n                       \\<partial>measure_pmf N", "then"], ["proof (chain)\npicking this:\n  prob_space (measure_pmf N)", "interpret subprob_space \"measure_pmf N\""], ["proof (prove)\nusing this:\n  prob_space (measure_pmf N)\n\ngoal (1 subgoal):\n 1. subprob_space (measure_pmf N)", "by (rule prob_space_imp_subprob_space)"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A =\n    \\<integral>\\<^sup>+ s. emeasure (measure_pmf (K s)) A\n                       \\<partial>measure_pmf N", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (measure_pmf N) A =\n    \\<integral>\\<^sup>+ s. emeasure (measure_pmf (K s)) A\n                       \\<partial>measure_pmf N", "unfolding measure_pmf.emeasure_eq_measure"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (measure_pmf.prob N A) =\n    \\<integral>\\<^sup>+ s. ennreal (measure_pmf.prob (K s) A)\n                       \\<partial>measure_pmf N", "apply (subst N[unfolded stationary_distribution_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (measure_pmf.prob (N \\<bind> K) A) =\n    \\<integral>\\<^sup>+ s. ennreal (measure_pmf.prob (K s) A)\n                       \\<partial>measure_pmf N", "apply (simp add: measure_pmf_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (Sigma_Algebra.measure\n       (measure_pmf N \\<bind> (\\<lambda>x. measure_pmf (K x))) A) =\n    \\<integral>\\<^sup>+ s. ennreal (measure_pmf.prob (K s) A)\n                       \\<partial>measure_pmf N", "apply (subst measure_pmf.measure_bind[where N=\"count_space UNIV\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. measure_pmf.random_variable N (subprob_algebra (count_space UNIV))\n     (\\<lambda>x. measure_pmf (K x))\n 2. A \\<in> sets (count_space UNIV)\n 3. ennreal\n     (measure_pmf.expectation N (\\<lambda>x. measure_pmf.prob (K x) A)) =\n    \\<integral>\\<^sup>+ s. ennreal (measure_pmf.prob (K s) A)\n                       \\<partial>measure_pmf N", "apply (rule measurable_compose[OF _ measurable_measure_pmf])"], ["proof (prove)\ngoal (3 subgoals):\n 1. measure_pmf.random_variable N (count_space UNIV) K\n 2. A \\<in> sets (count_space UNIV)\n 3. ennreal\n     (measure_pmf.expectation N (\\<lambda>x. measure_pmf.prob (K x) A)) =\n    \\<integral>\\<^sup>+ s. ennreal (measure_pmf.prob (K s) A)\n                       \\<partial>measure_pmf N", "apply (auto intro!: nn_integral_eq_integral[symmetric] measure_pmf.integrable_const_bound[where B=1])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  emeasure (measure_pmf N) A =\n  \\<integral>\\<^sup>+ s. emeasure (measure_pmf (K s)) A\n                     \\<partial>measure_pmf N\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma communicatingD1:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> (a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C \\<Longrightarrow> b \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> UNIV // communicating; (a, b) \\<in> communicating;\n     a \\<in> C\\<rbrakk>\n    \\<Longrightarrow> b \\<in> C", "by (auto elim!: quotientE) (auto simp add: communicating_def)"], ["", "lemma communicatingD2:\n  \"C \\<in> UNIV // communicating \\<Longrightarrow> (a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C \\<Longrightarrow> a \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C \\<in> UNIV // communicating; (a, b) \\<in> communicating;\n     b \\<in> C\\<rbrakk>\n    \\<Longrightarrow> a \\<in> C", "by (auto elim!: quotientE) (auto simp add: communicating_def)"], ["", "lemma acc_iff: \"(x, y) \\<in> acc \\<longleftrightarrow> (\\<exists>n. 0 < p x y n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> acc) = (\\<exists>n. 0 < p x y n)", "by (blast intro: accD_pos accI_pos)"], ["", "lemma communicating_iff: \"(x, y) \\<in> communicating \\<longleftrightarrow> (\\<exists>n. 0 < p x y n) \\<and> (\\<exists>n. 0 < p y x n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> communicating) =\n    ((\\<exists>n. 0 < p x y n) \\<and> (\\<exists>n. 0 < p y x n))", "by (auto simp add: acc_iff communicating_def)"], ["", "end"], ["", "context MC_pair\nbegin"], ["", "lemma p_eq_p1_p2:\n  \"p (x1, x2) (y1, y2) n = K1.p x1 y1 n * K2.p x2 y2 n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p (x1, x2) (y1, y2) n = K1.p x1 y1 n * K2.p x2 y2 n", "unfolding p_def K1.p_def K2.p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob (x1, x2)\n     {\\<omega> \\<in> space (T (x1, x2)).\n      ((x1, x2) ## \\<omega>) !! n = (y1, y2)} =\n    K1.T.prob x1\n     {\\<omega> \\<in> space (K1.T x1). (x1 ## \\<omega>) !! n = y1} *\n    K2.T.prob x2\n     {\\<omega> \\<in> space (K2.T x2). (x2 ## \\<omega>) !! n = y2}", "by (subst prod_eq_prob_T)\n     (auto intro!: arg_cong2[where f=measure] split: nat.splits simp: Stream_snth)"], ["", "lemma P_accD:\n  assumes \"((x1, x2), (y1, y2)) \\<in> acc\"shows \"(x1, y1) \\<in> K1.acc\" \"(x2, y2) \\<in> K2.acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> K1.acc &&& (x2, y2) \\<in> K2.acc", "using assms"], ["proof (prove)\nusing this:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> K1.acc &&& (x2, y2) \\<in> K2.acc", "by (auto simp: acc_iff K1.acc_iff K2.acc_iff p_eq_p1_p2 zero_less_mult_iff not_le[of 0, symmetric]\n                       cong: conj_cong)"], ["", "lemma aperiodicI_pair:\n  assumes C1: \"K1.aperiodic C1\" and C2: \"K2.aperiodic C2\"\n  shows \"aperiodic (C1 \\<times> C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aperiodic (C1 \\<times> C2)", "unfolding aperiodic_eventually_recurrent"], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating \\<and>\n    (\\<forall>x\\<in>C1 \\<times> C2.\n        \\<forall>\\<^sub>F m in sequentially. 0 < p x x m)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                            0 < p (a, b) (a, b) m", "from C1[unfolded K1.aperiodic_eventually_recurrent] C2[unfolded K2.aperiodic_eventually_recurrent]"], ["proof (chain)\npicking this:\n  C1 \\<in> UNIV // K1.communicating \\<and>\n  (\\<forall>x\\<in>C1. \\<forall>\\<^sub>F m in sequentially. 0 < K1.p x x m)\n  C2 \\<in> UNIV // K2.communicating \\<and>\n  (\\<forall>x\\<in>C2. \\<forall>\\<^sub>F m in sequentially. 0 < K2.p x x m)", "have C1: \"C1 \\<in> UNIV // K1.communicating\" and C2: \"C2 \\<in> UNIV // K2.communicating\" and\n    ev: \"\\<And>x. x \\<in> C1 \\<Longrightarrow> eventually (\\<lambda>m. 0 < K1.p x x m) sequentially\" \"\\<And>x. x \\<in> C2 \\<Longrightarrow> eventually (\\<lambda>m. 0 < K2.p x x m) sequentially\""], ["proof (prove)\nusing this:\n  C1 \\<in> UNIV // K1.communicating \\<and>\n  (\\<forall>x\\<in>C1. \\<forall>\\<^sub>F m in sequentially. 0 < K1.p x x m)\n  C2 \\<in> UNIV // K2.communicating \\<and>\n  (\\<forall>x\\<in>C2. \\<forall>\\<^sub>F m in sequentially. 0 < K2.p x x m)\n\ngoal (1 subgoal):\n 1. C1 \\<in> UNIV // K1.communicating &&&\n    C2 \\<in> UNIV // K2.communicating &&&\n    (\\<And>x.\n        x \\<in> C1 \\<Longrightarrow>\n        \\<forall>\\<^sub>F m in sequentially. 0 < K1.p x x m) &&&\n    (\\<And>x.\n        x \\<in> C2 \\<Longrightarrow>\n        \\<forall>\\<^sub>F m in sequentially. 0 < K2.p x x m)", "by auto"], ["proof (state)\nthis:\n  C1 \\<in> UNIV // K1.communicating\n  C2 \\<in> UNIV // K2.communicating\n  ?x4 \\<in> C1 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K1.p ?x4 ?x4 m\n  ?x4 \\<in> C2 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p ?x4 ?x4 m\n\ngoal (2 subgoals):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                            0 < p (a, b) (a, b) m", "{"], ["proof (state)\nthis:\n  C1 \\<in> UNIV // K1.communicating\n  C2 \\<in> UNIV // K2.communicating\n  ?x4 \\<in> C1 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K1.p ?x4 ?x4 m\n  ?x4 \\<in> C2 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p ?x4 ?x4 m\n\ngoal (2 subgoals):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                            0 < p (a, b) (a, b) m", "fix x1 x2"], ["proof (state)\ngoal (2 subgoals):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                            0 < p (a, b) (a, b) m", "assume x: \"x1 \\<in> C1\" \"x2 \\<in> C2\""], ["proof (state)\nthis:\n  x1 \\<in> C1\n  x2 \\<in> C2\n\ngoal (2 subgoals):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                            0 < p (a, b) (a, b) m", "from ev(1)[OF x(1)] ev(2)[OF x(2)]"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F m in sequentially. 0 < K1.p x1 x1 m\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p x2 x2 m", "show \"eventually (\\<lambda>m. 0 < p (x1, x2) (x1, x2) m) sequentially\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F m in sequentially. 0 < K1.p x1 x1 m\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p x2 x2 m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < p (x1, x2) (x1, x2) m", "by eventually_elim  (simp add: p_eq_p1_p2 x)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially. 0 < p (x1, x2) (x1, x2) m\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.6 \\<in> C1; ?x2.6 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                       0 < p (?x1.6, ?x2.6) (?x1.6, ?x2.6) m\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.6 \\<in> C1; ?x2.6 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> \\<forall>\\<^sub>F m in sequentially.\n                       0 < p (?x1.6, ?x2.6) (?x1.6, ?x2.6) m\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "fix x1 x2 y1 y2"], ["proof (state)\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "assume acc: \"(x1, y1) \\<in> K1.acc\" \"(x2, y2) \\<in> K2.acc\" \"x1 \\<in> C1\" \"y1 \\<in> C1\" \"x2 \\<in> C2\" \"y2 \\<in> C2\""], ["proof (state)\nthis:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "then"], ["proof (chain)\npicking this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2", "obtain k l where \"0 < K1.p x1 y1 l\" \"0 < K2.p x2 y2 k\""], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n\ngoal (1 subgoal):\n 1. (\\<And>l k.\n        \\<lbrakk>0 < K1.p x1 y1 l; 0 < K2.p x2 y2 k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: K1.accD_pos K2.accD_pos)"], ["proof (state)\nthis:\n  0 < K1.p x1 y1 l\n  0 < K2.p x2 y2 k\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "with acc ev(1)[of y1] ev(2)[of y2]"], ["proof (chain)\npicking this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  y1 \\<in> C1 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K1.p y1 y1 m\n  y2 \\<in> C2 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p y2 y2 m\n  0 < K1.p x1 y1 l\n  0 < K2.p x2 y2 k", "have \"eventually (\\<lambda>m. 0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m) sequentially\""], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  y1 \\<in> C1 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K1.p y1 y1 m\n  y2 \\<in> C2 \\<Longrightarrow>\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p y2 y2 m\n  0 < K1.p x1 y1 l\n  0 < K2.p x2 y2 k\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and>\n       0 < K2.p x2 y2 k * K2.p y2 y2 m", "by (auto elim: eventually_elim2)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m", "have \"eventually (\\<lambda>m. 0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)) sequentially\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and>\n       0 < K2.p x2 y2 k * K2.p y2 y2 m \\<Longrightarrow>\n       0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and>\n       0 < K2.p x2 y2 k * K2.p y2 y2 m \\<Longrightarrow>\n       0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)", "assume \"0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m\""], ["proof (state)\nthis:\n  0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and>\n       0 < K2.p x2 y2 k * K2.p y2 y2 m \\<Longrightarrow>\n       0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)", "with acc\n        K1.prob_reachable_le[of l \"l + m\" x1 y1 y1]\n        K2.prob_reachable_le[of k \"k + m\" x2 y2 y2]"], ["proof (chain)\npicking this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  l \\<le> l + m \\<Longrightarrow>\n  K1.p x1 y1 l * K1.p y1 y1 (l + m - l) \\<le> K1.p x1 y1 (l + m)\n  k \\<le> k + m \\<Longrightarrow>\n  K2.p x2 y2 k * K2.p y2 y2 (k + m - k) \\<le> K2.p x2 y2 (k + m)\n  0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m", "show \"0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)\""], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  l \\<le> l + m \\<Longrightarrow>\n  K1.p x1 y1 l * K1.p y1 y1 (l + m - l) \\<le> K1.p x1 y1 (l + m)\n  k \\<le> k + m \\<Longrightarrow>\n  K2.p x2 y2 k * K2.p y2 y2 (k + m - k) \\<le> K2.p x2 y2 (k + m)\n  0 < K1.p x1 y1 l * K1.p y1 y1 m \\<and> 0 < K2.p x2 y2 k * K2.p y2 y2 m\n\ngoal (1 subgoal):\n 1. 0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)", "by (auto simp add: ac_simps)"], ["proof (state)\nthis:\n  0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)", "have \"eventually (\\<lambda>m. 0 < K1.p x1 y1 m \\<and> 0 < K2.p x2 y2 m) sequentially\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 (m + l) \\<and> 0 < K2.p x2 y2 (m + k)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially.\n       0 < K1.p x1 y1 m \\<and> 0 < K2.p x2 y2 m", "unfolding eventually_conj_iff"], ["proof (prove)\nusing this:\n  (\\<forall>\\<^sub>F m in sequentially. 0 < K1.p x1 y1 (m + l)) \\<and>\n  (\\<forall>\\<^sub>F m in sequentially. 0 < K2.p x2 y2 (m + k))\n\ngoal (1 subgoal):\n 1. (\\<forall>\\<^sub>F m in sequentially. 0 < K1.p x1 y1 m) \\<and>\n    (\\<forall>\\<^sub>F m in sequentially. 0 < K2.p x2 y2 m)", "by (subst (asm) (1 2) eventually_sequentially_seg) (auto elim: eventually_elim2)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 m \\<and> 0 < K2.p x2 y2 m\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 m \\<and> 0 < K2.p x2 y2 m", "obtain N where \"0 < K1.p x1 y1 N\" \"0 < K2.p x2 y2 N\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F m in sequentially.\n     0 < K1.p x1 y1 m \\<and> 0 < K2.p x2 y2 m\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>0 < K1.p x1 y1 N; 0 < K2.p x2 y2 N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_sequentially)"], ["proof (state)\nthis:\n  0 < K1.p x1 y1 N\n  0 < K2.p x2 y2 N\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "with acc"], ["proof (chain)\npicking this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  0 < K1.p x1 y1 N\n  0 < K2.p x2 y2 N", "have \"0 < p (x1, x2) (y1, y2) N\""], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  0 < K1.p x1 y1 N\n  0 < K2.p x2 y2 N\n\ngoal (1 subgoal):\n 1. 0 < p (x1, x2) (y1, y2) N", "by (auto simp add: p_eq_p1_p2)"], ["proof (state)\nthis:\n  0 < p (x1, x2) (y1, y2) N\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "with acc"], ["proof (chain)\npicking this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  0 < p (x1, x2) (y1, y2) N", "have \"((x1, x2), (y1, y2)) \\<in> acc\""], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.acc\n  (x2, y2) \\<in> K2.acc\n  x1 \\<in> C1\n  y1 \\<in> C1\n  x2 \\<in> C2\n  y2 \\<in> C2\n  0 < p (x1, x2) (y1, y2) N\n\ngoal (1 subgoal):\n 1. ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*", "by (auto intro!: accI_pos)"], ["proof (state)\nthis:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x1.6, ?y1.6) \\<in> K1.acc; (?x2.6, ?y2.6) \\<in> K2.acc;\n   ?x1.6 \\<in> C1; ?y1.6 \\<in> C1; ?x2.6 \\<in> C2; ?y2.6 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> ((?x1.6, ?x2.6), ?y1.6, ?y2.6)\n                    \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "note 1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?x1.6, ?y1.6) \\<in> K1.acc; (?x2.6, ?y2.6) \\<in> K2.acc;\n   ?x1.6 \\<in> C1; ?y1.6 \\<in> C1; ?x2.6 \\<in> C2; ?y2.6 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> ((?x1.6, ?x2.6), ?y1.6, ?y2.6)\n                    \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?x1.6, ?y1.6) \\<in> K1.acc; (?x2.6, ?y2.6) \\<in> K2.acc;\n   ?x1.6 \\<in> C1; ?y1.6 \\<in> C1; ?x2.6 \\<in> C2; ?y2.6 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> ((?x1.6, ?x2.6), ?y1.6, ?y2.6)\n                    \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "fix x1 x2 y1 y2"], ["proof (state)\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "assume acc:\"((x1, x2), (y1, y2)) \\<in> acc\""], ["proof (state)\nthis:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "moreover"], ["proof (state)\nthis:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "from acc"], ["proof (chain)\npicking this:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*", "obtain k where \"0 < p (x1, x2) (y1, y2) k\""], ["proof (prove)\nusing this:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        0 < p (x1, x2) (y1, y2) k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest!: accD_pos)"], ["proof (state)\nthis:\n  0 < p (x1, x2) (y1, y2) k\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "ultimately"], ["proof (chain)\npicking this:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n  0 < p (x1, x2) (y1, y2) k", "have \"(x1, y1) \\<in> K1.acc \\<and> (x2, y2) \\<in> K2.acc\""], ["proof (prove)\nusing this:\n  ((x1, x2), y1, y2) \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n  0 < p (x1, x2) (y1, y2) k\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> K1.acc \\<and> (x2, y2) \\<in> K2.acc", "by (subst (asm) p_eq_p1_p2)\n         (auto intro!: K1.accI_pos K2.accI_pos simp: zero_less_mult_iff not_le[of 0, symmetric])"], ["proof (state)\nthis:\n  (x1, y1) \\<in> K1.acc \\<and> (x2, y2) \\<in> K2.acc\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "}"], ["proof (state)\nthis:\n  ((?x1.6, ?x2.6), ?y1.6, ?y2.6)\n  \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>* \\<Longrightarrow>\n  (?x1.6, ?y1.6) \\<in> K1.acc \\<and> (?x2.6, ?y2.6) \\<in> K2.acc\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "note 2 = this"], ["proof (state)\nthis:\n  ((?x1.6, ?x2.6), ?y1.6, ?y2.6)\n  \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>* \\<Longrightarrow>\n  (?x1.6, ?y1.6) \\<in> K1.acc \\<and> (?x2.6, ?y2.6) \\<in> K2.acc\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "from K1.not_empty_irreducible[OF C1] K2.not_empty_irreducible[OF C2]"], ["proof (chain)\npicking this:\n  C1 \\<noteq> {}\n  C2 \\<noteq> {}", "obtain x1 x2 where xC: \"x1 \\<in> C1\" \"x2 \\<in> C2\""], ["proof (prove)\nusing this:\n  C1 \\<noteq> {}\n  C2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        \\<lbrakk>x1 \\<in> C1; x2 \\<in> C2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x1 \\<in> C1\n  x2 \\<in> C2\n\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "show \"C1 \\<times> C2 \\<in> UNIV // communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C1 \\<times> C2 \\<in> UNIV // communicating", "apply (simp add: quotient_def Image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b. C1 \\<times> C2 = {y. ((a, b), y) \\<in> communicating}", "apply (safe intro!: exI[of _ x1] exI[of _ x2])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> ((x1, x2), a, b) \\<in> communicating\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 3. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> ((x1, x2), a, b) \\<in> communicating\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 3. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "fix y1 y2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> ((x1, x2), a, b) \\<in> communicating\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 3. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "assume yC: \"y1 \\<in> C1\" \"y2 \\<in> C2\""], ["proof (state)\nthis:\n  y1 \\<in> C1\n  y2 \\<in> C2\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> C1; b \\<in> C2\\<rbrakk>\n       \\<Longrightarrow> ((x1, x2), a, b) \\<in> communicating\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 3. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "from K1.irreducibleD[OF C1 \\<open>x1 \\<in> C1\\<close> \\<open>y1 \\<in> C1\\<close>] K2.irreducibleD[OF C2 \\<open>x2 \\<in> C2\\<close> \\<open>y2 \\<in> C2\\<close>]"], ["proof (chain)\npicking this:\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating", "show \"((x1, x2), (y1, y2)) \\<in> communicating\""], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating\n\ngoal (1 subgoal):\n 1. ((x1, x2), y1, y2) \\<in> communicating", "using 1[of x1 y1 x2 y2] 1[of y1 x1 y2 x2] xC yC"], ["proof (prove)\nusing this:\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating\n  \\<lbrakk>(x1, y1) \\<in> K1.acc; (x2, y2) \\<in> K2.acc; x1 \\<in> C1;\n   y1 \\<in> C1; x2 \\<in> C2; y2 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> ((x1, x2), y1, y2)\n                    \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n  \\<lbrakk>(y1, x1) \\<in> K1.acc; (y2, x2) \\<in> K2.acc; y1 \\<in> C1;\n   x1 \\<in> C1; y2 \\<in> C2; x2 \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> ((y1, y2), x1, x2)\n                    \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>*\n  x1 \\<in> C1\n  x2 \\<in> C2\n  y1 \\<in> C1\n  y2 \\<in> C2\n\ngoal (1 subgoal):\n 1. ((x1, x2), y1, y2) \\<in> communicating", "by (auto simp: communicating_def K1.communicating_def K2.communicating_def)"], ["proof (state)\nthis:\n  ((x1, x2), y1, y2) \\<in> communicating\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "fix y1 y2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "assume \"((x1, x2), (y1, y2)) \\<in> communicating\""], ["proof (state)\nthis:\n  ((x1, x2), y1, y2) \\<in> communicating\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "with 2[of x1 x2 y1 y2] 2[of y1 y2 x1 x2]"], ["proof (chain)\npicking this:\n  ((x1, x2), y1, y2)\n  \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>* \\<Longrightarrow>\n  (x1, y1) \\<in> K1.acc \\<and> (x2, y2) \\<in> K2.acc\n  ((y1, y2), x1, x2)\n  \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>* \\<Longrightarrow>\n  (y1, x1) \\<in> K1.acc \\<and> (y2, x2) \\<in> K2.acc\n  ((x1, x2), y1, y2) \\<in> communicating", "have \"(x1, y1) \\<in> K1.communicating\" \"(x2, y2) \\<in> K2.communicating\""], ["proof (prove)\nusing this:\n  ((x1, x2), y1, y2)\n  \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>* \\<Longrightarrow>\n  (x1, y1) \\<in> K1.acc \\<and> (x2, y2) \\<in> K2.acc\n  ((y1, y2), x1, x2)\n  \\<in> (SIGMA x:UNIV. set_pmf (Kp x))\\<^sup>* \\<Longrightarrow>\n  (y1, x1) \\<in> K1.acc \\<and> (y2, x2) \\<in> K2.acc\n  ((x1, x2), y1, y2) \\<in> communicating\n\ngoal (1 subgoal):\n 1. (x1, y1) \\<in> K1.communicating &&& (x2, y2) \\<in> K2.communicating", "by (auto simp: communicating_def K1.communicating_def K2.communicating_def)"], ["proof (state)\nthis:\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> a \\<in> C1\n 2. \\<And>a b.\n       ((x1, x2), a, b) \\<in> communicating \\<Longrightarrow> b \\<in> C2", "with xC"], ["proof (chain)\npicking this:\n  x1 \\<in> C1\n  x2 \\<in> C2\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating", "show \"y1 \\<in> C1\" \"y2 \\<in> C2\""], ["proof (prove)\nusing this:\n  x1 \\<in> C1\n  x2 \\<in> C2\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating\n\ngoal (1 subgoal):\n 1. y1 \\<in> C1 &&& y2 \\<in> C2", "using K1.communicatingD1[OF C1] K2.communicatingD1[OF C2]"], ["proof (prove)\nusing this:\n  x1 \\<in> C1\n  x2 \\<in> C2\n  (x1, y1) \\<in> K1.communicating\n  (x2, y2) \\<in> K2.communicating\n  \\<lbrakk>(?a, ?b) \\<in> K1.communicating; ?a \\<in> C1\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> C1\n  \\<lbrakk>(?a, ?b) \\<in> K2.communicating; ?a \\<in> C2\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> C2\n\ngoal (1 subgoal):\n 1. y1 \\<in> C1 &&& y2 \\<in> C2", "by auto"], ["proof (state)\nthis:\n  y1 \\<in> C1\n  y2 \\<in> C2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C1 \\<times> C2 \\<in> UNIV // communicating\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stationary_distributionI_pair:\n  assumes N1: \"K1.stationary_distribution N1\"\n  assumes N2: \"K2.stationary_distribution N2\"\n  shows \"stationary_distribution (pair_pmf N1 N2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stationary_distribution (pair_pmf N1 N2)", "unfolding stationary_distribution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_pmf N1 N2 = pair_pmf N1 N2 \\<bind> Kp", "unfolding Kp_def pair_pmf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<bind> (\\<lambda>x. N2 \\<bind> (\\<lambda>y. return_pmf (x, y))) =\n    N1 \\<bind>\n    (\\<lambda>x. N2 \\<bind> (\\<lambda>y. return_pmf (x, y))) \\<bind>\n    (\\<lambda>(a, b).\n        K1 a \\<bind>\n        (\\<lambda>x. K2 b \\<bind> (\\<lambda>y. return_pmf (x, y))))", "apply (subst N1[unfolded K1.stationary_distribution_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<bind> K1 \\<bind>\n    (\\<lambda>x. N2 \\<bind> (\\<lambda>y. return_pmf (x, y))) =\n    N1 \\<bind>\n    (\\<lambda>x. N2 \\<bind> (\\<lambda>y. return_pmf (x, y))) \\<bind>\n    (\\<lambda>(a, b).\n        K1 a \\<bind>\n        (\\<lambda>x. K2 b \\<bind> (\\<lambda>y. return_pmf (x, y))))", "apply (subst N2[unfolded K2.stationary_distribution_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<bind> K1 \\<bind>\n    (\\<lambda>x. N2 \\<bind> K2 \\<bind> (\\<lambda>y. return_pmf (x, y))) =\n    N1 \\<bind>\n    (\\<lambda>x. N2 \\<bind> (\\<lambda>y. return_pmf (x, y))) \\<bind>\n    (\\<lambda>(a, b).\n        K1 a \\<bind>\n        (\\<lambda>x. K2 b \\<bind> (\\<lambda>y. return_pmf (x, y))))", "apply (simp add: bind_assoc_pmf bind_return_pmf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<bind>\n    (\\<lambda>x.\n        K1 x \\<bind>\n        (\\<lambda>x.\n            N2 \\<bind>\n            (\\<lambda>xa. K2 xa \\<bind> (\\<lambda>y. return_pmf (x, y))))) =\n    N1 \\<bind>\n    (\\<lambda>x.\n        N2 \\<bind>\n        (\\<lambda>xa.\n            K1 x \\<bind>\n            (\\<lambda>x. K2 xa \\<bind> (\\<lambda>y. return_pmf (x, y)))))", "apply (subst bind_commute_pmf[of N2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. N1 \\<bind>\n    (\\<lambda>x.\n        K1 x \\<bind>\n        (\\<lambda>x.\n            N2 \\<bind>\n            (\\<lambda>xa. K2 xa \\<bind> (\\<lambda>y. return_pmf (x, y))))) =\n    N1 \\<bind>\n    (\\<lambda>x.\n        K1 x \\<bind>\n        (\\<lambda>y.\n            N2 \\<bind>\n            (\\<lambda>x. K2 x \\<bind> (\\<lambda>ya. return_pmf (y, ya)))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context MC_syntax\nbegin"], ["", "lemma stationary_distribution_imp_limit:\n  assumes C: \"aperiodic C\" \"essential_class C\" \"countable C\" and N: \"stationary_distribution N\" \"N \\<subseteq> C\"\n  assumes [simp]: \"y \\<in> C\"\n  shows \"(\\<lambda>n. \\<integral>x. \\<bar>p y x n - pmf N x\\<bar> \\<partial>count_space C) \\<longlonglongrightarrow> 0\"\n    (is \"?L \\<longlonglongrightarrow> 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "from \\<open>essential_class C\\<close>"], ["proof (chain)\npicking this:\n  essential_class C", "have C_comm: \"C \\<in> UNIV // communicating\""], ["proof (prove)\nusing this:\n  essential_class C\n\ngoal (1 subgoal):\n 1. C \\<in> UNIV // communicating", "by (simp add: essential_class_def)"], ["proof (state)\nthis:\n  C \\<in> UNIV // communicating\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "define K' where \"K' = (\\<lambda>Some x \\<Rightarrow> map_pmf Some (K x) | None \\<Rightarrow> map_pmf Some N)\""], ["proof (state)\nthis:\n  K' =\n  (\\<lambda>xa.\n      case xa of None \\<Rightarrow> map_pmf Some N\n      | Some x \\<Rightarrow> map_pmf Some (K x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "interpret K2: MC_syntax K'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "interpret KN: MC_pair K K'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "from stationary_distributionD[OF C(2,3) N]"], ["proof (chain)\npicking this:\n  Ball C pos_recurrent\n  measure_pmf N = stat C", "have pos: \"\\<And>x. x \\<in> C \\<Longrightarrow> pos_recurrent x\" and \"measure_pmf N = stat C\""], ["proof (prove)\nusing this:\n  Ball C pos_recurrent\n  measure_pmf N = stat C\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> C \\<Longrightarrow> pos_recurrent x) &&&\n    measure_pmf N = stat C", "by auto"], ["proof (state)\nthis:\n  ?x4 \\<in> C \\<Longrightarrow> pos_recurrent ?x4\n  measure_pmf N = stat C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have pos: \"\\<And>x. x \\<in> C \\<Longrightarrow> 0 < emeasure N {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> 0 < emeasure (measure_pmf N) {x}", "using pos"], ["proof (prove)\nusing this:\n  ?x4 \\<in> C \\<Longrightarrow> pos_recurrent ?x4\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> 0 < emeasure (measure_pmf N) {x}", "unfolding stat_def \\<open>measure_pmf N = stat C\\<close>"], ["proof (prove)\nusing this:\n  ?x4 \\<in> C \\<Longrightarrow> pos_recurrent ?x4\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       0 < emeasure\n            (point_measure UNIV (\\<lambda>x. indicator C x / U' x x)) {x}", "by (subst emeasure_point_measure_finite2)\n       (auto simp: U'_def pos_recurrent_def nn_integral_add ennreal_zero_less_divide less_top)"], ["proof (state)\nthis:\n  ?x4 \\<in> C \\<Longrightarrow> 0 < emeasure (measure_pmf N) {?x4}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  ?x4 \\<in> C \\<Longrightarrow> 0 < emeasure (measure_pmf N) {?x4}", "have rpos: \"\\<And>x. x \\<in> C \\<Longrightarrow> 0 < pmf N x\""], ["proof (prove)\nusing this:\n  ?x4 \\<in> C \\<Longrightarrow> 0 < emeasure (measure_pmf N) {?x4}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> C \\<Longrightarrow> 0 < pmf N x", "by (simp add: measure_pmf.emeasure_eq_measure pmf.rep_eq)"], ["proof (state)\nthis:\n  ?x4 \\<in> C \\<Longrightarrow> 0 < pmf N ?x4\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have eq: \"\\<And>x y. (if x = y then 1 else 0) = indicator {y} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (if x = y then 1::'b else (0::'b)) = indicator {y} x", "by auto"], ["proof (state)\nthis:\n  (if ?x4 = ?y4 then 1::?'b5 else (0::?'b5)) = indicator {?y4} ?x4\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have intK: \"\\<And>f x. (\\<integral>x. (f x :: real) \\<partial>K' (Some x)) = (\\<integral>x. f (Some x) \\<partial>K x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x.\n       measure_pmf.expectation (K' (Some x)) f =\n       measure_pmf.expectation (K x) (\\<lambda>x. f (Some x))", "by (simp add: K'_def integral_distr map_pmf_rep_eq)"], ["proof (state)\nthis:\n  measure_pmf.expectation (K' (Some ?x5)) ?f5 =\n  measure_pmf.expectation (K ?x5) (\\<lambda>x. ?f5 (Some x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "{"], ["proof (state)\nthis:\n  measure_pmf.expectation (K' (Some ?x5)) ?f5 =\n  measure_pmf.expectation (K ?x5) (\\<lambda>x. ?f5 (Some x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "fix m and x y :: 's"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"K2.p (Some x) (Some y) m = p x y m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K2.p (Some x) (Some y) m = p x y m", "by (induct m arbitrary: x)\n         (auto intro!: integral_cong simp add: K2.p_Suc' p_Suc' intK K2.p_0 p_0)"], ["proof (state)\nthis:\n  K2.p (Some x) (Some y) m = p x y m\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "}"], ["proof (state)\nthis:\n  K2.p (Some ?x7) (Some ?ya7) ?m7 = p ?x7 ?ya7 ?m7\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "note K_p_eq = this"], ["proof (state)\nthis:\n  K2.p (Some ?x7) (Some ?ya7) ?m7 = p ?x7 ?ya7 ?m7\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "{"], ["proof (state)\nthis:\n  K2.p (Some ?x7) (Some ?ya7) ?m7 = p ?x7 ?ya7 ?m7\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "fix n and x :: 's"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"K2.p (Some x) None n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K2.p (Some x) None n = 0", "by (induct n arbitrary: x) (auto simp: K2.p_Suc' K2.p_0 intK cong: integral_cong)"], ["proof (state)\nthis:\n  K2.p (Some x) None n = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "}"], ["proof (state)\nthis:\n  K2.p (Some ?x7) None ?n7 = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "note K_S_None = this"], ["proof (state)\nthis:\n  K2.p (Some ?x7) None ?n7 = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "from not_empty_irreducible[OF C_comm]"], ["proof (chain)\npicking this:\n  C \\<noteq> {}", "obtain c0 where c0: \"c0 \\<in> C\""], ["proof (prove)\nusing this:\n  C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>c0. c0 \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  c0 \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have K2_acc: \"\\<And>x y. (Some x, y) \\<in> K2.acc \\<longleftrightarrow> (\\<exists>z. y = Some z \\<and> (x, z) \\<in> acc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       ((Some x, y) \\<in> K2.acc) =\n       (\\<exists>z. y = Some z \\<and> (x, z) \\<in> acc)", "apply (auto simp: K2.acc_iff acc_iff K_p_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y n.\n       0 < K2.p (Some x) y n \\<Longrightarrow>\n       \\<exists>z. y = Some z \\<and> (\\<exists>n. 0 < p x z n)", "apply (case_tac y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y n.\n       \\<lbrakk>0 < K2.p (Some x) y n; y = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z.\n                            y = Some z \\<and> (\\<exists>n. 0 < p x z n)\n 2. \\<And>x y n a.\n       \\<lbrakk>0 < K2.p (Some x) y n; y = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>z.\n                            y = Some z \\<and> (\\<exists>n. 0 < p x z n)", "apply (auto simp: K_p_eq K_S_None)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ((Some ?x5, ?y5) \\<in> K2.acc) =\n  (\\<exists>z. ?y5 = Some z \\<and> (?x5, z) \\<in> acc)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have K2_communicating: \"\\<And>c x. c \\<in> C \\<Longrightarrow> (Some c, x) \\<in> K2.communicating \\<longleftrightarrow> (\\<exists>c'\\<in>C. x = Some c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       c \\<in> C \\<Longrightarrow>\n       ((Some c, x) \\<in> K2.communicating) =\n       (\\<exists>c'\\<in>C. x = Some c')", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<in> C; (Some c, x) \\<in> K2.communicating\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'\\<in>C. x = Some c'\n 2. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "fix x c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<in> C; (Some c, x) \\<in> K2.communicating\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'\\<in>C. x = Some c'\n 2. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "assume \"c \\<in> C\" \"(Some c, x) \\<in> K2.communicating\""], ["proof (state)\nthis:\n  c \\<in> C\n  (Some c, x) \\<in> K2.communicating\n\ngoal (2 subgoals):\n 1. \\<And>c x.\n       \\<lbrakk>c \\<in> C; (Some c, x) \\<in> K2.communicating\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c'\\<in>C. x = Some c'\n 2. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "then"], ["proof (chain)\npicking this:\n  c \\<in> C\n  (Some c, x) \\<in> K2.communicating", "show \"\\<exists>c'\\<in>C. x = Some c'\""], ["proof (prove)\nusing this:\n  c \\<in> C\n  (Some c, x) \\<in> K2.communicating\n\ngoal (1 subgoal):\n 1. \\<exists>c'\\<in>C. x = Some c'", "by (cases x)\n         (auto simp: communicating_iff K2.communicating_iff K_p_eq K_S_None intro!: irreducibleD2[OF C_comm \\<open>c\\<in>C\\<close>])"], ["proof (state)\nthis:\n  \\<exists>c'\\<in>C. x = Some c'\n\ngoal (1 subgoal):\n 1. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "fix c c' x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "assume \"c \\<in> C\" \"c' \\<in> C\""], ["proof (state)\nthis:\n  c \\<in> C\n  c' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>c x c'.\n       \\<lbrakk>c \\<in> C; c' \\<in> C\\<rbrakk>\n       \\<Longrightarrow> (Some c, Some c') \\<in> K2.communicating", "with irreducibleD[OF C_comm this]"], ["proof (chain)\npicking this:\n  (c, c') \\<in> communicating\n  c \\<in> C\n  c' \\<in> C", "show \"(Some c, Some c') \\<in> K2.communicating\""], ["proof (prove)\nusing this:\n  (c, c') \\<in> communicating\n  c \\<in> C\n  c' \\<in> C\n\ngoal (1 subgoal):\n 1. (Some c, Some c') \\<in> K2.communicating", "by (auto simp: K2.communicating_iff communicating_iff K_p_eq)"], ["proof (state)\nthis:\n  (Some c, Some c') \\<in> K2.communicating\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?c5 \\<in> C \\<Longrightarrow>\n  ((Some ?c5, ?x5) \\<in> K2.communicating) =\n  (\\<exists>c'\\<in>C. ?x5 = Some c')\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"Some ` C \\<in> UNIV // K2.communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ` C \\<in> UNIV // K2.communicating", "by (auto simp add: quotient_def Image_def c0 K2_communicating\n             intro!: exI[of _ \"Some c0\"])"], ["proof (state)\nthis:\n  Some ` C \\<in> UNIV // K2.communicating\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  Some ` C \\<in> UNIV // K2.communicating", "have \"K2.essential_class (Some ` C)\""], ["proof (prove)\nusing this:\n  Some ` C \\<in> UNIV // K2.communicating\n\ngoal (1 subgoal):\n 1. K2.essential_class (Some ` C)", "by (rule K2.essential_classI)\n       (auto simp: K2_acc essential_classD2[OF \\<open>essential_class C\\<close>])"], ["proof (state)\nthis:\n  K2.essential_class (Some ` C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"K2.aperiodic (Some ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K2.aperiodic (Some ` C)", "unfolding K2.aperiodic_eventually_recurrent"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some ` C \\<in> UNIV // K2.communicating \\<and>\n    (\\<forall>x\\<in>Some ` C.\n        \\<forall>\\<^sub>F m in sequentially. 0 < K2.p x x m)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. Some ` C \\<in> UNIV // K2.communicating\n 2. \\<And>x xa.\n       xa \\<in> C \\<Longrightarrow>\n       \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some xa) (Some xa) m", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. Some ` C \\<in> UNIV // K2.communicating\n 2. \\<And>x xa.\n       xa \\<in> C \\<Longrightarrow>\n       \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some xa) (Some xa) m", "assume \"x \\<in> C\""], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (2 subgoals):\n 1. Some ` C \\<in> UNIV // K2.communicating\n 2. \\<And>x xa.\n       xa \\<in> C \\<Longrightarrow>\n       \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some xa) (Some xa) m", "then"], ["proof (chain)\npicking this:\n  x \\<in> C", "show \"eventually (\\<lambda>m. 0 < K2.p (Some x) (Some x) m) sequentially\""], ["proof (prove)\nusing this:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some x) (Some x) m", "using \\<open>aperiodic C\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> C\n  aperiodic C\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some x) (Some x) m", "unfolding aperiodic_eventually_recurrent"], ["proof (prove)\nusing this:\n  x \\<in> C\n  C \\<in> UNIV // communicating \\<and>\n  (\\<forall>x\\<in>C. \\<forall>\\<^sub>F m in sequentially. 0 < p x x m)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some x) (Some x) m", "by (auto elim!: eventually_mono simp: K_p_eq)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F m in sequentially. 0 < K2.p (Some x) (Some x) m\n\ngoal (1 subgoal):\n 1. Some ` C \\<in> UNIV // K2.communicating", "qed fact"], ["proof (state)\nthis:\n  K2.aperiodic (Some ` C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  K2.aperiodic (Some ` C)", "have aperiodic: \"KN.aperiodic (C \\<times> Some ` C)\""], ["proof (prove)\nusing this:\n  K2.aperiodic (Some ` C)\n\ngoal (1 subgoal):\n 1. KN.aperiodic (C \\<times> Some ` C)", "by (rule KN.aperiodicI_pair[OF \\<open>aperiodic C\\<close>])"], ["proof (state)\nthis:\n  KN.aperiodic (C \\<times> Some ` C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have KN_essential: \"KN.essential_class (C \\<times> Some ` C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.essential_class (C \\<times> Some ` C)", "proof (rule KN.essential_classI)"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<times> Some ` C \\<in> UNIV // KN.communicating\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> C \\<times> Some ` C;\n        (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C \\<times> Some ` C", "show \"C \\<times> Some ` C \\<in> UNIV // KN.communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<times> Some ` C \\<in> UNIV // KN.communicating", "using aperiodic"], ["proof (prove)\nusing this:\n  KN.aperiodic (C \\<times> Some ` C)\n\ngoal (1 subgoal):\n 1. C \\<times> Some ` C \\<in> UNIV // KN.communicating", "by (simp add: KN.aperiodic_def)"], ["proof (state)\nthis:\n  C \\<times> Some ` C \\<in> UNIV // KN.communicating\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> C \\<times> Some ` C;\n        (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C \\<times> Some ` C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> C \\<times> Some ` C;\n        (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C \\<times> Some ` C", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> C \\<times> Some ` C;\n        (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C \\<times> Some ` C", "assume \"x \\<in> C \\<times> Some ` C\" \"(x, y) \\<in> KN.acc\""], ["proof (state)\nthis:\n  x \\<in> C \\<times> Some ` C\n  (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> C \\<times> Some ` C;\n        (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> y \\<in> C \\<times> Some ` C", "with KN.P_accD[of \"fst x\" \"snd x\" \"fst y\" \"snd y\"]"], ["proof (chain)\npicking this:\n  ((fst x, snd x), fst y, snd y)\n  \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>* \\<Longrightarrow>\n  (fst x, fst y) \\<in> acc\n  ((fst x, snd x), fst y, snd y)\n  \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>* \\<Longrightarrow>\n  (snd x, snd y) \\<in> K2.acc\n  x \\<in> C \\<times> Some ` C\n  (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*", "show \"y \\<in> C \\<times> Some ` C\""], ["proof (prove)\nusing this:\n  ((fst x, snd x), fst y, snd y)\n  \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>* \\<Longrightarrow>\n  (fst x, fst y) \\<in> acc\n  ((fst x, snd x), fst y, snd y)\n  \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>* \\<Longrightarrow>\n  (snd x, snd y) \\<in> K2.acc\n  x \\<in> C \\<times> Some ` C\n  (x, y) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. y \\<in> C \\<times> Some ` C", "by (cases x y rule: prod.exhaust[case_product prod.exhaust])\n         (auto simp: K2_acc essential_classD2[OF \\<open>essential_class C\\<close>])"], ["proof (state)\nthis:\n  y \\<in> C \\<times> Some ` C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KN.essential_class (C \\<times> Some ` C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "{"], ["proof (state)\nthis:\n  KN.essential_class (C \\<times> Some ` C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "fix n and x y :: 's"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"measure N {y} = \\<P>(\\<omega> in K2.T None. (None ## \\<omega>) !! (Suc n) = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} =\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None).\n      (None ## \\<omega>) !! Suc n = Some y}", "unfolding stationary_distribution_iterate'[OF N(1), of y n]"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n) =\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None).\n      (None ## \\<omega>) !! Suc n = Some y}", "apply (subst K2.p_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n) =\n    K2.p None (Some y) (Suc n)", "apply (subst K2.p_Suc')"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n) =\n    measure_pmf.expectation (K' None) (\\<lambda>x'. K2.p x' (Some y) n)", "apply (subst K'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation N (\\<lambda>x. p x y n) =\n    measure_pmf.expectation\n     (case None of None \\<Rightarrow> map_pmf Some N\n      | Some x \\<Rightarrow> map_pmf Some (K x))\n     (\\<lambda>x'. K2.p x' (Some y) n)", "apply (simp add: map_pmf_rep_eq integral_distr K_p_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} =\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). (None ## \\<omega>) !! Suc n = Some y}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "then"], ["proof (chain)\npicking this:\n  measure_pmf.prob N {y} =\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). (None ## \\<omega>) !! Suc n = Some y}", "have \"measure N {y} = \\<P>(\\<omega> in K2.T None. \\<omega> !! n = Some y)\""], ["proof (prove)\nusing this:\n  measure_pmf.prob N {y} =\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). (None ## \\<omega>) !! Suc n = Some y}\n\ngoal (1 subgoal):\n 1. measure_pmf.prob N {y} =\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some y}", "by simp"], ["proof (state)\nthis:\n  measure_pmf.prob N {y} =\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some y}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "}"], ["proof (state)\nthis:\n  measure_pmf.prob N {?ya7} =\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). \\<omega> !! ?n7 = Some ?ya7}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "note measure_y_eq = this"], ["proof (state)\nthis:\n  measure_pmf.prob N {?ya7} =\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). \\<omega> !! ?n7 = Some ?ya7}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "define D where \"D = {x::'s \\<times> 's option. Some (fst x) = snd x}\""], ["proof (state)\nthis:\n  D = {x. Some (fst x) = snd x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have [measurable]:\n    \"\\<And>P::('s \\<times> 's option \\<Rightarrow> bool). P \\<in> measurable (count_space UNIV) (count_space UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. Measurable.pred (count_space UNIV) P", "by simp"], ["proof (state)\nthis:\n  Measurable.pred (count_space UNIV) ?P5\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "{"], ["proof (state)\nthis:\n  Measurable.pred (count_space UNIV) ?P5\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "fix n and x :: 's"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<P>(\\<omega> in KN.T (y, None). \\<exists>i<n. snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>) =\n      (\\<Sum>i<n. \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<exists>i<n.\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n    (\\<Sum>i<n.\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>})", "by (subst KN.T.finite_measure_finite_Union[symmetric])\n         (auto simp: disjoint_family_on_def intro!: arg_cong2[where f=measure] dest: ev_at_unique)"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n.\n       snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n.\n       snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = (\\<Sum>i<n. \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>}) =\n    (\\<Sum>i<n.\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>})", "proof (intro sum.cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       KN.T.prob (y, None)\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) xa \\<omega>} =\n       KN.T.prob (y, None)\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) xa \\<omega>}", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       KN.T.prob (y, None)\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) xa \\<omega>} =\n       KN.T.prob (y, None)\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) xa \\<omega>}", "assume i: \"i \\<in> {..< n}\""], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..<n} \\<Longrightarrow>\n       KN.T.prob (y, None)\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) xa \\<omega>} =\n       KN.T.prob (y, None)\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) xa \\<omega>}", "show \"\\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>) =\n        \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}", "apply (subst (1 2) KN.prob_T_split[where n=\"Suc i\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>)\n 2. Measurable.pred (stream_space (count_space UNIV))\n     (\\<lambda>\\<omega>.\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>)\n 3. KN.T.expectation (y, None)\n     (\\<lambda>\\<omega>.\n         KN.T.prob (((y, None) ## \\<omega>) !! Suc i)\n          {\\<omega>' \\<in> space (KN.T (((y, None) ## \\<omega>) !! Suc i)).\n           snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n           ev_at (HLD D) i (stake (Suc i) \\<omega> @- \\<omega>')}) =\n    KN.T.expectation (y, None)\n     (\\<lambda>\\<omega>.\n         KN.T.prob (((y, None) ## \\<omega>) !! Suc i)\n          {\\<omega>' \\<in> space (KN.T (((y, None) ## \\<omega>) !! Suc i)).\n           fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n           ev_at (HLD D) i (stake (Suc i) \\<omega> @- \\<omega>')})", "apply (simp_all add: ev_at_shift snth_Stream del: stake.simps KN.space_T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.expectation (y, None)\n     (\\<lambda>\\<omega>.\n         KN.T.prob (\\<omega> !! i)\n          {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n           snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n           ev_at (HLD D) i \\<omega>}) =\n    KN.T.expectation (y, None)\n     (\\<lambda>\\<omega>.\n         KN.T.prob (\\<omega> !! i)\n          {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n           fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n           ev_at (HLD D) i \\<omega>})", "unfolding ev_at_shift snth_Stream"], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.expectation (y, None)\n     (\\<lambda>\\<omega>.\n         KN.T.prob (\\<omega> !! i)\n          {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n           snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n           ev_at (HLD D) i \\<omega>}) =\n    KN.T.expectation (y, None)\n     (\\<lambda>\\<omega>.\n         KN.T.prob (\\<omega> !! i)\n          {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n           fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n           ev_at (HLD D) i \\<omega>})", "proof (intro Bochner_Integration.integral_cong refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (KN.T (y, None)) \\<Longrightarrow>\n       KN.T.prob (xa !! i)\n        {\\<omega>' \\<in> space (KN.T (xa !! i)).\n         snd ((stake (Suc i) xa @- \\<omega>') !! n) = Some x \\<and>\n         ev_at (HLD D) i xa} =\n       KN.T.prob (xa !! i)\n        {\\<omega>' \\<in> space (KN.T (xa !! i)).\n         fst ((stake (Suc i) xa @- \\<omega>') !! n) = x \\<and>\n         ev_at (HLD D) i xa}", "fix \\<omega> :: \"('s \\<times> 's option) stream\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (KN.T (y, None)) \\<Longrightarrow>\n       KN.T.prob (xa !! i)\n        {\\<omega>' \\<in> space (KN.T (xa !! i)).\n         snd ((stake (Suc i) xa @- \\<omega>') !! n) = Some x \\<and>\n         ev_at (HLD D) i xa} =\n       KN.T.prob (xa !! i)\n        {\\<omega>' \\<in> space (KN.T (xa !! i)).\n         fst ((stake (Suc i) xa @- \\<omega>') !! n) = x \\<and>\n         ev_at (HLD D) i xa}", "let ?s = \"\\<lambda>\\<omega>'. stake (Suc i) \\<omega> @- \\<omega>'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> space (KN.T (y, None)) \\<Longrightarrow>\n       KN.T.prob (xa !! i)\n        {\\<omega>' \\<in> space (KN.T (xa !! i)).\n         snd ((stake (Suc i) xa @- \\<omega>') !! n) = Some x \\<and>\n         ev_at (HLD D) i xa} =\n       KN.T.prob (xa !! i)\n        {\\<omega>' \\<in> space (KN.T (xa !! i)).\n         fst ((stake (Suc i) xa @- \\<omega>') !! n) = x \\<and>\n         ev_at (HLD D) i xa}", "show \"\\<P>(\\<omega>' in KN.T (\\<omega> !! i). snd (?s \\<omega>' !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>) =\n          \\<P>(\\<omega>' in KN.T (\\<omega> !! i). fst (?s \\<omega>' !! n) = x \\<and> ev_at (HLD D) i \\<omega>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "assume \"ev_at (HLD D) i \\<omega>\""], ["proof (state)\nthis:\n  ev_at (HLD D) i \\<omega>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "from ev_at_imp_snth[OF this]"], ["proof (chain)\npicking this:\n  HLD D (sdrop i \\<omega>)", "have eq: \"snd (\\<omega> !! i) = Some (fst (\\<omega> !! i))\""], ["proof (prove)\nusing this:\n  HLD D (sdrop i \\<omega>)\n\ngoal (1 subgoal):\n 1. snd (\\<omega> !! i) = Some (fst (\\<omega> !! i))", "by (simp add: D_def HLD_iff)"], ["proof (state)\nthis:\n  snd (\\<omega> !! i) = Some (fst (\\<omega> !! i))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "have \"\\<P>(\\<omega>' in KN.T (\\<omega> !! i). fst (\\<omega>' !! (n - Suc i)) = x) =\n            \\<P>(\\<omega>' in T (fst (\\<omega> !! i)). \\<omega>' !! (n - Suc i) = x) * \\<P>(\\<omega>' in K2.T (snd (\\<omega> !! i)). True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst (\\<omega>' !! (n - Suc i)) = x} =\n    T.prob (fst (\\<omega> !! i))\n     {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n      \\<omega>' !! (n - Suc i) = x} *\n    K2.T.prob (snd (\\<omega> !! i))\n     {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True}", "by (subst KN.prod_eq_prob_T) simp_all"], ["proof (state)\nthis:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst (\\<omega>' !! (n - Suc i)) = x} =\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = x} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "also"], ["proof (state)\nthis:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst (\\<omega>' !! (n - Suc i)) = x} =\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = x} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "have \"\\<dots> = p (fst (\\<omega> !! i)) x (Suc (n - Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob (fst (\\<omega> !! i))\n     {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n      \\<omega>' !! (n - Suc i) = x} *\n    K2.T.prob (snd (\\<omega> !! i))\n     {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True} =\n    p (fst (\\<omega> !! i)) x (Suc (n - Suc i))", "using K2.T.prob_space"], ["proof (prove)\nusing this:\n  K2.T.prob ?s (space (K2.T ?s)) = 1\n\ngoal (1 subgoal):\n 1. T.prob (fst (\\<omega> !! i))\n     {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n      \\<omega>' !! (n - Suc i) = x} *\n    K2.T.prob (snd (\\<omega> !! i))\n     {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True} =\n    p (fst (\\<omega> !! i)) x (Suc (n - Suc i))", "by (simp add: p_def)"], ["proof (state)\nthis:\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = x} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True} =\n  p (fst (\\<omega> !! i)) x (Suc (n - Suc i))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "also"], ["proof (state)\nthis:\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = x} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))). True} =\n  p (fst (\\<omega> !! i)) x (Suc (n - Suc i))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "have \"\\<dots> = K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p (fst (\\<omega> !! i)) x (Suc (n - Suc i)) =\n    K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i))", "by (simp add: K_p_eq eq)"], ["proof (state)\nthis:\n  p (fst (\\<omega> !! i)) x (Suc (n - Suc i)) =\n  K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "also"], ["proof (state)\nthis:\n  p (fst (\\<omega> !! i)) x (Suc (n - Suc i)) =\n  K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "have \"\\<dots> = \\<P>(\\<omega>' in T (fst (\\<omega> !! i)). True) * \\<P>(\\<omega>' in K2.T (snd (\\<omega> !! i)). \\<omega>' !! (n - Suc i) = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i)) =\n    T.prob (fst (\\<omega> !! i))\n     {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))). True} *\n    K2.T.prob (snd (\\<omega> !! i))\n     {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))).\n      \\<omega>' !! (n - Suc i) = Some x}", "using T.prob_space"], ["proof (prove)\nusing this:\n  T.prob ?s (space (T ?s)) = 1\n\ngoal (1 subgoal):\n 1. K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i)) =\n    T.prob (fst (\\<omega> !! i))\n     {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))). True} *\n    K2.T.prob (snd (\\<omega> !! i))\n     {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))).\n      \\<omega>' !! (n - Suc i) = Some x}", "by (simp add: K2.p_def)"], ["proof (state)\nthis:\n  K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i)) =\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))). True} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = Some x}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "also"], ["proof (state)\nthis:\n  K2.p (snd (\\<omega> !! i)) (Some x) (Suc (n - Suc i)) =\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))). True} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = Some x}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "have \"\\<dots> = \\<P>(\\<omega>' in KN.T (\\<omega> !! i). snd (\\<omega>' !! (n - Suc i)) = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob (fst (\\<omega> !! i))\n     {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))). True} *\n    K2.T.prob (snd (\\<omega> !! i))\n     {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))).\n      \\<omega>' !! (n - Suc i) = Some x} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd (\\<omega>' !! (n - Suc i)) = Some x}", "by (subst KN.prod_eq_prob_T) simp_all"], ["proof (state)\nthis:\n  T.prob (fst (\\<omega> !! i))\n   {\\<omega>' \\<in> space (T (fst (\\<omega> !! i))). True} *\n  K2.T.prob (snd (\\<omega> !! i))\n   {\\<omega>' \\<in> space (K2.T (snd (\\<omega> !! i))).\n    \\<omega>' !! (n - Suc i) = Some x} =\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    snd (\\<omega>' !! (n - Suc i)) = Some x}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}\n 2. \\<not> ?P \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "finally"], ["proof (chain)\npicking this:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst (\\<omega>' !! (n - Suc i)) = x} =\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    snd (\\<omega>' !! (n - Suc i)) = Some x}", "show ?thesis"], ["proof (prove)\nusing this:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst (\\<omega>' !! (n - Suc i)) = x} =\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    snd (\\<omega>' !! (n - Suc i)) = Some x}\n\ngoal (1 subgoal):\n 1. KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "using \\<open>ev_at (HLD D) i \\<omega>\\<close> i"], ["proof (prove)\nusing this:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst (\\<omega>' !! (n - Suc i)) = x} =\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    snd (\\<omega>' !! (n - Suc i)) = Some x}\n  ev_at (HLD D) i \\<omega>\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "by (simp del: stake.simps)"], ["proof (state)\nthis:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n    ev_at (HLD D) i \\<omega>} =\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n    ev_at (HLD D) i \\<omega>}\n\ngoal (1 subgoal):\n 1. \\<not> ev_at (HLD D) i \\<omega> \\<Longrightarrow>\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n      ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (\\<omega> !! i)\n     {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n      fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n      ev_at (HLD D) i \\<omega>}", "qed simp"], ["proof (state)\nthis:\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    snd ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = Some x \\<and>\n    ev_at (HLD D) i \\<omega>} =\n  KN.T.prob (\\<omega> !! i)\n   {\\<omega>' \\<in> space (KN.T (\\<omega> !! i)).\n    fst ((stake (Suc i) \\<omega> @- \\<omega>') !! n) = x \\<and>\n    ev_at (HLD D) i \\<omega>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>}) =\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>}) =\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = \\<P>(\\<omega> in KN.T (y, None). (\\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}) =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}", "by (subst KN.T.finite_measure_finite_Union[symmetric])\n         (auto simp add: disjoint_family_on_def dest: ev_at_unique\n               intro!: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}) =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n.\n       snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}", "have eq: \"\\<P>(\\<omega> in KN.T (y, None). (\\<exists>i<n. snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>)) =\n      \\<P>(\\<omega> in KN.T (y, None). (\\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\nusing this:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n.\n       snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}\n\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<exists>i<n.\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}", "."], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n.\n       snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"p y x (Suc n) - measure N {x} = \\<P>(\\<omega> in T y. \\<omega> !! n = x) - \\<P>(\\<omega> in K2.T None. \\<omega> !! n = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p y x (Suc n) - measure_pmf.prob N {x} =\n    T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} -\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob y {\\<omega> \\<in> space (T y). (y ## \\<omega>) !! Suc n = x} -\n    measure_pmf.prob N {x} =\n    T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} -\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}", "by (subst measure_y_eq) simp_all"], ["proof (state)\nthis:\n  p y x (Suc n) - measure_pmf.prob N {x} =\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} -\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  p y x (Suc n) - measure_pmf.prob N {x} =\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} -\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<P>(\\<omega> in T y. \\<omega> !! n = x) = \\<P>(\\<omega> in T y. \\<omega> !! n = x) * \\<P>(\\<omega> in K2.T None. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} =\n    T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n    K2.T.prob None {\\<omega> \\<in> space (K2.T None). True}", "using K2.T.prob_space"], ["proof (prove)\nusing this:\n  K2.T.prob ?s (space (K2.T ?s)) = 1\n\ngoal (1 subgoal):\n 1. T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} =\n    T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n    K2.T.prob None {\\<omega> \\<in> space (K2.T None). True}", "by simp"], ["proof (state)\nthis:\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} =\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). True}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} =\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). True}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n    K2.T.prob None {\\<omega> \\<in> space (K2.T None). True} =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)). fst (\\<omega> !! n) = x}", "by (subst KN.prod_eq_prob_T) auto"], ["proof (state)\nthis:\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). True} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). fst (\\<omega> !! n) = x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  T.prob y {\\<omega> \\<in> space (T y). \\<omega> !! n = x} *\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). True} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). fst (\\<omega> !! n) = x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = \\<P>(\\<omega> in KN.T (y, None). (\\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>)) +\n      \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)). fst (\\<omega> !! n) = x} =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<exists>i<n.\n         fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      fst (\\<omega> !! n) = x \\<and>\n      \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "by (subst KN.T.finite_measure_Union[symmetric])\n         (auto intro!: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). fst (\\<omega> !! n) = x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    fst (\\<omega> !! n) = x \\<and>\n    \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). fst (\\<omega> !! n) = x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    fst (\\<omega> !! n) = x \\<and>\n    \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<P>(\\<omega> in K2.T None. \\<omega> !! n = Some x) = \\<P>(\\<omega> in T y. True) * \\<P>(\\<omega> in K2.T None. \\<omega> !! n = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n    T.prob y {\\<omega> \\<in> space (T y). True} *\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}", "using T.prob_space"], ["proof (prove)\nusing this:\n  T.prob ?s (space (T ?s)) = 1\n\ngoal (1 subgoal):\n 1. K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n    T.prob y {\\<omega> \\<in> space (T y). True} *\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}", "by simp"], ["proof (state)\nthis:\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n  T.prob y {\\<omega> \\<in> space (T y). True} *\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n  T.prob y {\\<omega> \\<in> space (T y). True} *\n  K2.T.prob None {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T.prob y {\\<omega> \\<in> space (T y). True} *\n    K2.T.prob None\n     {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)). snd (\\<omega> !! n) = Some x}", "by (subst KN.prod_eq_prob_T) auto"], ["proof (state)\nthis:\n  T.prob y {\\<omega> \\<in> space (T y). True} *\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). snd (\\<omega> !! n) = Some x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  T.prob y {\\<omega> \\<in> space (T y). True} *\n  K2.T.prob None\n   {\\<omega> \\<in> space (K2.T None). \\<omega> !! n = Some x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). snd (\\<omega> !! n) = Some x}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = \\<P>(\\<omega> in KN.T (y, None). (\\<exists>i<n. snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>)) +\n      \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)). snd (\\<omega> !! n) = Some x} =\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<exists>i<n.\n         snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} +\n    KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      snd (\\<omega> !! n) = Some x \\<and>\n      \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "by (subst KN.T.finite_measure_Union[symmetric])\n         (auto intro!: arg_cong2[where f=measure])"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)). snd (\\<omega> !! n) = Some x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n.\n       snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} +\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    snd (\\<omega> !! n) = Some x \\<and>\n    \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  p y x (Suc n) - measure_pmf.prob N {x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    fst (\\<omega> !! n) = x \\<and>\n    \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n  (KN.T.prob (y, None)\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     \\<exists>i<n.\n        snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} +\n   KN.T.prob (y, None)\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     snd (\\<omega> !! n) = Some x \\<and>\n     \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})", "have \"\\<bar> p y x (Suc n) - measure N {x} \\<bar> =\n      \\<bar> \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) -\n      \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) \\<bar>\""], ["proof (prove)\nusing this:\n  p y x (Suc n) - measure_pmf.prob N {x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    fst (\\<omega> !! n) = x \\<and>\n    \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n  (KN.T.prob (y, None)\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     \\<exists>i<n.\n        snd (\\<omega> !! n) = Some x \\<and> ev_at (HLD D) i \\<omega>} +\n   KN.T.prob (y, None)\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     snd (\\<omega> !! n) = Some x \\<and>\n     \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar> =\n    \\<bar>KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>", "unfolding eq"], ["proof (prove)\nusing this:\n  p y x (Suc n) - measure_pmf.prob N {x} =\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    \\<exists>i<n. fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    fst (\\<omega> !! n) = x \\<and>\n    \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n  (KN.T.prob (y, None)\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     \\<exists>i<n.\n        fst (\\<omega> !! n) = x \\<and> ev_at (HLD D) i \\<omega>} +\n   KN.T.prob (y, None)\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     snd (\\<omega> !! n) = Some x \\<and>\n     \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar> =\n    \\<bar>KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar> =\n  \\<bar>KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar> =\n  \\<bar>KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> \\<le> \\<bar> \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) \\<bar> +\n      \\<bar> \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) \\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n    \\<le> \\<bar>KN.T.prob (y, None)\n                 {\\<omega> \\<in> space (KN.T (y, None)).\n                  fst (\\<omega> !! n) = x \\<and>\n                  \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar> +\n          \\<bar>KN.T.prob (y, None)\n                 {\\<omega> \\<in> space (KN.T (y, None)).\n                  snd (\\<omega> !! n) = Some x \\<and>\n                  \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>", "by (rule abs_triangle_ineq4)"], ["proof (state)\nthis:\n  \\<bar>KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n  \\<le> \\<bar>KN.T.prob (y, None)\n               {\\<omega> \\<in> space (KN.T (y, None)).\n                fst (\\<omega> !! n) = x \\<and>\n                \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar> +\n        \\<bar>KN.T.prob (y, None)\n               {\\<omega> \\<in> space (KN.T (y, None)).\n                snd (\\<omega> !! n) = Some x \\<and>\n                \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  \\<bar>KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} -\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n  \\<le> \\<bar>KN.T.prob (y, None)\n               {\\<omega> \\<in> space (KN.T (y, None)).\n                fst (\\<omega> !! n) = x \\<and>\n                \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar> +\n        \\<bar>KN.T.prob (y, None)\n               {\\<omega> \\<in> space (KN.T (y, None)).\n                snd (\\<omega> !! n) = Some x \\<and>\n                \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> \\<le> \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) +\n      \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar> +\n    \\<bar>KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n    \\<le> KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} +\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "by simp"], ["proof (state)\nthis:\n  \\<bar>KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar> +\n  \\<bar>KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "have \"\\<bar> p y x (Suc n) - measure N {x} \\<bar> \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n    \\<le> KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} +\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "."], ["proof (state)\nthis:\n  \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "}"], ["proof (state)\nthis:\n  \\<bar>p y ?x7 (Suc ?n7) - measure_pmf.prob N {?x7}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! ?n7) = ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! ?n7) = Some ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "note mono = this"], ["proof (state)\nthis:\n  \\<bar>p y ?x7 (Suc ?n7) - measure_pmf.prob N {?x7}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! ?n7) = ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! ?n7) = Some ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "{"], ["proof (state)\nthis:\n  \\<bar>p y ?x7 (Suc ?n7) - measure_pmf.prob N {?x7}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! ?n7) = ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! ?n7) = Some ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"(\\<integral>\\<^sup>+x. \\<bar> p y x (Suc n) - measure N {x} \\<bar> \\<partial>count_space C) \\<le>\n      (\\<integral>\\<^sup>+x. ennreal (\\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))) +\n      ennreal (\\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))) \\<partial>count_space C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            \\<bar>p y x (Suc n) -\n                                  measure_pmf.prob N {x}\\<bar>\n                       \\<partial>count_space C\n    \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                  (KN.T.prob (y, None)\n                                    {\\<omega> \\<in> space (KN.T (y, None)).\n                                     fst (\\<omega> !! n) = x \\<and>\n                                     \\<not> (\\<exists>i<n.\n          ev_at (HLD D) i \\<omega>)}) +\n                                 ennreal\n                                  (KN.T.prob (y, None)\n                                    {\\<omega> \\<in> space (KN.T (y, None)).\n                                     snd (\\<omega> !! n) = Some x \\<and>\n                                     \\<not> (\\<exists>i<n.\n          ev_at (HLD D) i \\<omega>)})\n                             \\<partial>count_space C", "using mono"], ["proof (prove)\nusing this:\n  \\<bar>p y ?x7 (Suc ?n7) - measure_pmf.prob N {?x7}\\<bar>\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! ?n7) = ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)} +\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! ?n7) = Some ?x7 \\<and>\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            \\<bar>p y x (Suc n) -\n                                  measure_pmf.prob N {x}\\<bar>\n                       \\<partial>count_space C\n    \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                  (KN.T.prob (y, None)\n                                    {\\<omega> \\<in> space (KN.T (y, None)).\n                                     fst (\\<omega> !! n) = x \\<and>\n                                     \\<not> (\\<exists>i<n.\n          ev_at (HLD D) i \\<omega>)}) +\n                                 ennreal\n                                  (KN.T.prob (y, None)\n                                    {\\<omega> \\<in> space (KN.T (y, None)).\n                                     snd (\\<omega> !! n) = Some x \\<and>\n                                     \\<not> (\\<exists>i<n.\n          ev_at (HLD D) i \\<omega>)})\n                             \\<partial>count_space C", "by (intro nn_integral_mono) (simp add: ennreal_plus[symmetric] del: ennreal_plus)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n                     \\<partial>count_space C\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (KN.T.prob (y, None)\n                                  {\\<omega> \\<in> space (KN.T (y, None)).\n                                   fst (\\<omega> !! n) = x \\<and>\n                                   \\<not> (\\<exists>i<n.\n        ev_at (HLD D) i \\<omega>)}) +\n                               ennreal\n                                (KN.T.prob (y, None)\n                                  {\\<omega> \\<in> space (KN.T (y, None)).\n                                   snd (\\<omega> !! n) = Some x \\<and>\n                                   \\<not> (\\<exists>i<n.\n        ev_at (HLD D) i \\<omega>)})\n                           \\<partial>count_space C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n                     \\<partial>count_space C\n  \\<le> \\<integral>\\<^sup>+ x. ennreal\n                                (KN.T.prob (y, None)\n                                  {\\<omega> \\<in> space (KN.T (y, None)).\n                                   fst (\\<omega> !! n) = x \\<and>\n                                   \\<not> (\\<exists>i<n.\n        ev_at (HLD D) i \\<omega>)}) +\n                               ennreal\n                                (KN.T.prob (y, None)\n                                  {\\<omega> \\<in> space (KN.T (y, None)).\n                                   snd (\\<omega> !! n) = Some x \\<and>\n                                   \\<not> (\\<exists>i<n.\n        ev_at (HLD D) i \\<omega>)})\n                           \\<partial>count_space C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = (\\<integral>\\<^sup>+x. \\<P>(\\<omega> in KN.T (y, None). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) \\<partial>count_space C) +\n      (\\<integral>\\<^sup>+x. \\<P>(\\<omega> in KN.T (y, None). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)) \\<partial>count_space C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (KN.T.prob (y, None)\n                              {\\<omega> \\<in> space (KN.T (y, None)).\n                               fst (\\<omega> !! n) = x \\<and>\n                               \\<not> (\\<exists>i<n.\n    ev_at (HLD D) i \\<omega>)}) +\n                           ennreal\n                            (KN.T.prob (y, None)\n                              {\\<omega> \\<in> space (KN.T (y, None)).\n                               snd (\\<omega> !! n) = Some x \\<and>\n                               \\<not> (\\<exists>i<n.\n    ev_at (HLD D) i \\<omega>)})\n                       \\<partial>count_space C =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (KN.T.prob (y, None)\n                              {\\<omega> \\<in> space (KN.T (y, None)).\n                               fst (\\<omega> !! n) = x \\<and>\n                               \\<not> (\\<exists>i<n.\n    ev_at (HLD D) i \\<omega>)})\n                       \\<partial>count_space C +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (KN.T.prob (y, None)\n                              {\\<omega> \\<in> space (KN.T (y, None)).\n                               snd (\\<omega> !! n) = Some x \\<and>\n                               \\<not> (\\<exists>i<n.\n    ev_at (HLD D) i \\<omega>)})\n                       \\<partial>count_space C", "by (subst nn_integral_add) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             fst (\\<omega> !! n) = x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)}) +\n                         ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             snd (\\<omega> !! n) = Some x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             fst (\\<omega> !! n) = x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             snd (\\<omega> !! n) = Some x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             fst (\\<omega> !! n) = x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)}) +\n                         ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             snd (\\<omega> !! n) = Some x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             fst (\\<omega> !! n) = x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             snd (\\<omega> !! n) = Some x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = emeasure (KN.T (y, None)) (\\<Union>x\\<in>C. {\\<omega>\\<in>space (KN.T (y, None)). fst (\\<omega> !! n) = x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n      emeasure (KN.T (y, None)) (\\<Union>x\\<in>C. {\\<omega>\\<in>space (KN.T (y, None)). snd (\\<omega> !! n) = Some x \\<and> \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. ennreal\n                            (KN.T.prob (y, None)\n                              {\\<omega> \\<in> space (KN.T (y, None)).\n                               fst (\\<omega> !! n) = x \\<and>\n                               \\<not> (\\<exists>i<n.\n    ev_at (HLD D) i \\<omega>)})\n                       \\<partial>count_space C +\n    \\<integral>\\<^sup>+ x. ennreal\n                            (KN.T.prob (y, None)\n                              {\\<omega> \\<in> space (KN.T (y, None)).\n                               snd (\\<omega> !! n) = Some x \\<and>\n                               \\<not> (\\<exists>i<n.\n    ev_at (HLD D) i \\<omega>)})\n                       \\<partial>count_space C =\n    emeasure (KN.T (y, None))\n     (\\<Union>x\\<in>C.\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n    emeasure (KN.T (y, None))\n     (\\<Union>x\\<in>C.\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})", "by (subst (1 2) emeasure_UN_countable)\n         (auto simp add: disjoint_family_on_def KN.T.emeasure_eq_measure C)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             fst (\\<omega> !! n) = x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             snd (\\<omega> !! n) = Some x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C =\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             fst (\\<omega> !! n) = x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C +\n  \\<integral>\\<^sup>+ x. ennreal\n                          (KN.T.prob (y, None)\n                            {\\<omega> \\<in> space (KN.T (y, None)).\n                             snd (\\<omega> !! n) = Some x \\<and>\n                             \\<not> (\\<exists>i<n.\n  ev_at (HLD D) i \\<omega>)})\n                     \\<partial>count_space C =\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> \\<le> ennreal (\\<P>(\\<omega> in KN.T (y, None). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))) + ennreal (\\<P>(\\<omega> in KN.T (y, None). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure (KN.T (y, None))\n     (\\<Union>x\\<in>C.\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          fst (\\<omega> !! n) = x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n    emeasure (KN.T (y, None))\n     (\\<Union>x\\<in>C.\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          snd (\\<omega> !! n) = Some x \\<and>\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n    \\<le> ennreal\n           (KN.T.prob (y, None)\n             {\\<omega> \\<in> space (KN.T (y, None)).\n              \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n          ennreal\n           (KN.T.prob (y, None)\n             {\\<omega> \\<in> space (KN.T (y, None)).\n              \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})", "unfolding KN.T.emeasure_eq_measure"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (KN.T.prob (y, None)\n       (\\<Union>x\\<in>C.\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            fst (\\<omega> !! n) = x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})) +\n    ennreal\n     (KN.T.prob (y, None)\n       (\\<Union>x\\<in>C.\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            snd (\\<omega> !! n) = Some x \\<and>\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}))\n    \\<le> ennreal\n           (KN.T.prob (y, None)\n             {\\<omega> \\<in> space (KN.T (y, None)).\n              \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n          ennreal\n           (KN.T.prob (y, None)\n             {\\<omega> \\<in> space (KN.T (y, None)).\n              \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})", "by (intro add_mono) (auto intro!: KN.T.finite_measure_mono)"], ["proof (state)\nthis:\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<le> ennreal\n         (KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n        ennreal\n         (KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        fst (\\<omega> !! n) = x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n  emeasure (KN.T (y, None))\n   (\\<Union>x\\<in>C.\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        snd (\\<omega> !! n) = Some x \\<and>\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<le> ennreal\n         (KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n        ennreal\n         (KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> \\<le> 2 * \\<P>(\\<omega> in KN.T (y, None). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n    ennreal\n     (KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n    \\<le> ennreal\n           (2 *\n            KN.T.prob (y, None)\n             {\\<omega> \\<in> space (KN.T (y, None)).\n              \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})", "by (simp add: ennreal_plus[symmetric] del: ennreal_plus)"], ["proof (state)\nthis:\n  ennreal\n   (KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) +\n  ennreal\n   (KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<le> ennreal\n         (2 *\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n                     \\<partial>count_space C\n  \\<le> ennreal\n         (2 *\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})", "have \"?L (Suc n) \\<le> 2 * \\<P>(\\<omega> in KN.T (y, None). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))\""], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          \\<bar>p y x (Suc n) - measure_pmf.prob N {x}\\<bar>\n                     \\<partial>count_space C\n  \\<le> ennreal\n         (2 *\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>\n    \\<le> 2 *\n          KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "by (auto intro!: integral_real_bounded simp add: pmf.rep_eq)"], ["proof (state)\nthis:\n  LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>\n  \\<le> 2 *\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "}"], ["proof (state)\nthis:\n  LINT x|count_space C. \\<bar>p y x (Suc ?n7) - pmf N x\\<bar>\n  \\<le> 2 *\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "note le_2 = this"], ["proof (state)\nthis:\n  LINT x|count_space C. \\<bar>p y x (Suc ?n7) - pmf N x\\<bar>\n  \\<le> 2 *\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have c0_D: \"(c0, Some c0) \\<in> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c0, Some c0) \\<in> D", "by (simp add: D_def c0)"], ["proof (state)\nthis:\n  (c0, Some c0) \\<in> D\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "let ?N' = \"map_pmf Some N\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "interpret NP: pair_prob_space N ?N'"], ["proof (prove)\ngoal (1 subgoal):\n 1. pair_prob_space (measure_pmf N) (measure_pmf (map_pmf Some N))", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have pos_recurrent: \"\\<forall>x\\<in>C \\<times> Some ` C. KN.pos_recurrent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (C \\<times> Some ` C) KN.pos_recurrent", "proof (rule KN.stationary_distributionD(1)[OF KN_essential _ KN.stationary_distributionI_pair[OF N(1)]])"], ["proof (state)\ngoal (3 subgoals):\n 1. countable (C \\<times> Some ` C)\n 2. K2.stationary_distribution ?N2.1\n 3. set_pmf (pair_pmf N ?N2.1) \\<subseteq> C \\<times> Some ` C", "show \"K2.stationary_distribution ?N'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. K2.stationary_distribution (map_pmf Some N)", "unfolding K2.stationary_distribution_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf Some N = map_pmf Some N \\<bind> K'", "by (subst N(1)[unfolded stationary_distribution_def])\n         (auto intro!: bind_pmf_cong simp: K'_def map_pmf_def bind_assoc_pmf bind_return_pmf)"], ["proof (state)\nthis:\n  K2.stationary_distribution (map_pmf Some N)\n\ngoal (2 subgoals):\n 1. countable (C \\<times> Some ` C)\n 2. set_pmf (pair_pmf N (map_pmf Some N)) \\<subseteq> C \\<times> Some ` C", "show \"countable (C \\<times> Some`C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable (C \\<times> Some ` C)", "using C"], ["proof (prove)\nusing this:\n  aperiodic C\n  essential_class C\n  countable C\n\ngoal (1 subgoal):\n 1. countable (C \\<times> Some ` C)", "by auto"], ["proof (state)\nthis:\n  countable (C \\<times> Some ` C)\n\ngoal (1 subgoal):\n 1. set_pmf (pair_pmf N (map_pmf Some N)) \\<subseteq> C \\<times> Some ` C", "show \"set_pmf (pair_pmf N (map_pmf Some N)) \\<subseteq> C \\<times> Some ` C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_pmf (pair_pmf N (map_pmf Some N)) \\<subseteq> C \\<times> Some ` C", "using \\<open>N \\<subseteq> C\\<close>"], ["proof (prove)\nusing this:\n  set_pmf N \\<subseteq> C\n\ngoal (1 subgoal):\n 1. set_pmf (pair_pmf N (map_pmf Some N)) \\<subseteq> C \\<times> Some ` C", "by auto"], ["proof (state)\nthis:\n  set_pmf (pair_pmf N (map_pmf Some N)) \\<subseteq> C \\<times> Some ` C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball (C \\<times> Some ` C) KN.pos_recurrent\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "from c0_D"], ["proof (chain)\npicking this:\n  (c0, Some c0) \\<in> D", "have \"\\<P>(\\<omega> in KN.T (y, None). alw (not (HLD D)) \\<omega>) \\<le> \\<P>(\\<omega> in KN.T (y, None). alw (not (HLD {(c0, Some c0)})) \\<omega>)\""], ["proof (prove)\nusing this:\n  (c0, Some c0) \\<in> D\n\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n    \\<le> KN.T.prob (y, None)\n           {\\<omega> \\<in> space (KN.T (y, None)).\n            alw (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) \\<omega>}", "apply (auto intro!: KN.T.finite_measure_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(c0, Some c0) \\<in> D;\n        x \\<in> space (stream_space (count_space UNIV));\n        alw (\\<lambda>xs. \\<not> HLD D xs) x\\<rbrakk>\n       \\<Longrightarrow> alw (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) x", "apply (rule alw_mono, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>(c0, Some c0) \\<in> D;\n        x \\<in> space (stream_space (count_space UNIV));\n        alw (\\<lambda>xs. \\<not> HLD D xs) x; \\<not> HLD D xs\\<rbrakk>\n       \\<Longrightarrow> \\<not> HLD {(c0, Some c0)} xs", "apply (auto simp: HLD_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          alw (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n  \\<le> KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          alw (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      alw (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) \\<omega>} =\n    0", "apply (rule KN.T.prob_eq_0_AE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AE \\<omega> in KN.T\n                    (y, None). \\<not> alw\n (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) \\<omega>", "apply (simp add: not_ev_iff[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (KN.T (y, None)) (ev (HLD {(c0, Some c0)}))", "apply (subst KN.AE_T_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Measurable.pred (stream_space (count_space UNIV))\n     (ev (HLD {(c0, Some c0)}))\n 2. \\<forall>y\\<in>set_pmf (KN.Kp (y, None)).\n       AE \\<omega> in KN.T y. ev (HLD {(c0, Some c0)}) (y ## \\<omega>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set_pmf (KN.Kp (y, None)).\n       AE \\<omega> in KN.T y. ev (HLD {(c0, Some c0)}) (y ## \\<omega>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "assume t: \"t \\<in> KN.Kp (y, None)\""], ["proof (state)\nthis:\n  t \\<in> set_pmf (KN.Kp (y, None))\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "then"], ["proof (chain)\npicking this:\n  t \\<in> set_pmf (KN.Kp (y, None))", "obtain a b where t_eq: \"t = (a, Some b)\" \"a \\<in> K y\" \"b \\<in> N\""], ["proof (prove)\nusing this:\n  t \\<in> set_pmf (KN.Kp (y, None))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>t = (a, Some b); a \\<in> set_pmf (K y);\n         b \\<in> set_pmf N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding KN.Kp_def"], ["proof (prove)\nusing this:\n  t \\<in> set_pmf\n           (case (y, None) of (a, b) \\<Rightarrow> pair_pmf (K a) (K' b))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>t = (a, Some b); a \\<in> set_pmf (K y);\n         b \\<in> set_pmf N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: K'_def)"], ["proof (state)\nthis:\n  t = (a, Some b)\n  a \\<in> set_pmf (K y)\n  b \\<in> set_pmf N\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "with \\<open>y \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> C\n  t = (a, Some b)\n  a \\<in> set_pmf (K y)\n  b \\<in> set_pmf N", "have \"a \\<in> C\""], ["proof (prove)\nusing this:\n  y \\<in> C\n  t = (a, Some b)\n  a \\<in> set_pmf (K y)\n  b \\<in> set_pmf N\n\ngoal (1 subgoal):\n 1. a \\<in> C", "using essential_classD2[OF \\<open>essential_class C\\<close> \\<open>y \\<in> C\\<close>]"], ["proof (prove)\nusing this:\n  y \\<in> C\n  t = (a, Some b)\n  a \\<in> set_pmf (K y)\n  b \\<in> set_pmf N\n  (y, ?y) \\<in> acc \\<Longrightarrow> ?y \\<in> C\n\ngoal (1 subgoal):\n 1. a \\<in> C", "by auto"], ["proof (state)\nthis:\n  a \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "have \"b \\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> C", "using \\<open>N \\<subseteq> C\\<close> \\<open>b \\<in> N\\<close>"], ["proof (prove)\nusing this:\n  set_pmf N \\<subseteq> C\n  b \\<in> set_pmf N\n\ngoal (1 subgoal):\n 1. b \\<in> C", "by auto"], ["proof (state)\nthis:\n  b \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "from pos_recurrent[THEN bspec, of \"(c0, Some c0)\"]"], ["proof (chain)\npicking this:\n  (c0, Some c0) \\<in> C \\<times> Some ` C \\<Longrightarrow>\n  KN.pos_recurrent (c0, Some c0)", "have recurrent_c0: \"KN.recurrent (c0, Some c0)\""], ["proof (prove)\nusing this:\n  (c0, Some c0) \\<in> C \\<times> Some ` C \\<Longrightarrow>\n  KN.pos_recurrent (c0, Some c0)\n\ngoal (1 subgoal):\n 1. KN.recurrent (c0, Some c0)", "by (simp add: KN.pos_recurrent_def c0)"], ["proof (state)\nthis:\n  KN.recurrent (c0, Some c0)\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "have \"C \\<times> Some ` C \\<in> UNIV // KN.communicating\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<times> Some ` C \\<in> UNIV // KN.communicating", "using aperiodic"], ["proof (prove)\nusing this:\n  KN.aperiodic (C \\<times> Some ` C)\n\ngoal (1 subgoal):\n 1. C \\<times> Some ` C \\<in> UNIV // KN.communicating", "by (simp add: KN.aperiodic_def)"], ["proof (state)\nthis:\n  C \\<times> Some ` C \\<in> UNIV // KN.communicating\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "then"], ["proof (chain)\npicking this:\n  C \\<times> Some ` C \\<in> UNIV // KN.communicating", "have \"((c0, Some c0), t) \\<in> KN.communicating\""], ["proof (prove)\nusing this:\n  C \\<times> Some ` C \\<in> UNIV // KN.communicating\n\ngoal (1 subgoal):\n 1. ((c0, Some c0), t) \\<in> KN.communicating", "by (rule KN.irreducibleD) (simp_all add: t_eq c0 \\<open>b \\<in> C\\<close> \\<open>a \\<in> C\\<close>)"], ["proof (state)\nthis:\n  ((c0, Some c0), t) \\<in> KN.communicating\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "then"], ["proof (chain)\npicking this:\n  ((c0, Some c0), t) \\<in> KN.communicating", "have \"((c0, Some c0), t) \\<in> KN.acc\""], ["proof (prove)\nusing this:\n  ((c0, Some c0), t) \\<in> KN.communicating\n\ngoal (1 subgoal):\n 1. ((c0, Some c0), t) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*", "by (simp add: KN.communicating_def)"], ["proof (state)\nthis:\n  ((c0, Some c0), t) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "then"], ["proof (chain)\npicking this:\n  ((c0, Some c0), t) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*", "have \"KN.U t (c0, Some c0) = 1\""], ["proof (prove)\nusing this:\n  ((c0, Some c0), t) \\<in> (SIGMA x:UNIV. set_pmf (KN.Kp x))\\<^sup>*\n\ngoal (1 subgoal):\n 1. KN.U t (c0, Some c0) = 1", "by (rule KN.recurrent_acc(1)[OF recurrent_c0])"], ["proof (state)\nthis:\n  KN.U t (c0, Some c0) = 1\n\ngoal (1 subgoal):\n 1. \\<And>ya.\n       ya \\<in> set_pmf (KN.Kp (y, None)) \\<Longrightarrow>\n       AE \\<omega> in KN.T ya. ev (HLD {(c0, Some c0)}) (ya ## \\<omega>)", "then"], ["proof (chain)\npicking this:\n  KN.U t (c0, Some c0) = 1", "show \"AE \\<omega> in KN.T t. ev (HLD {(c0, Some c0)}) (t ## \\<omega>)\""], ["proof (prove)\nusing this:\n  KN.U t (c0, Some c0) = 1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in KN.T t. ev (HLD {(c0, Some c0)}) (t ## \\<omega>)", "unfolding KN.U_def"], ["proof (prove)\nusing this:\n  KN.T.prob t\n   {\\<omega> \\<in> space (KN.T t). ev (HLD {(c0, Some c0)}) \\<omega>} =\n  1\n\ngoal (1 subgoal):\n 1. AE \\<omega> in KN.T t. ev (HLD {(c0, Some c0)}) (t ## \\<omega>)", "by (subst (asm) KN.T.prob_Collect_eq_1) (auto simp add: ev_Stream)"], ["proof (state)\nthis:\n  AE \\<omega> in KN.T t. ev (HLD {(c0, Some c0)}) (t ## \\<omega>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD {(c0, Some c0)} xs) \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n  \\<le> 0", "have \"\\<P>(\\<omega> in KN.T (y, None). alw (not (HLD D)) \\<omega>) = 0\""], ["proof (prove)\nusing this:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>} =\n    0", "by (intro antisym measure_nonneg)"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"(\\<lambda>n. \\<P>(\\<omega> in KN.T (y, None). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))) \\<longlonglongrightarrow>\n    measure (KN.T (y, None)) (\\<Inter>n. {\\<omega>\\<in>space (KN.T (y, None)). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n    \\<longlonglongrightarrow> KN.T.prob (y, None)\n                               (\\<Inter>n.\n                                   {\\<omega> \\<in> space (KN.T (y, None)).\n                                    \\<not> (\\<exists>i<n.\n         ev_at (HLD D) i \\<omega>)})", "by (rule KN.T.finite_Lim_measure_decseq) (auto simp: decseq_def)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<longlonglongrightarrow> KN.T.prob (y, None)\n                             (\\<Inter>n.\n                                 {\\<omega> \\<in> space (KN.T (y, None)).\n                                  \\<not> (\\<exists>i<n.\n       ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<longlonglongrightarrow> KN.T.prob (y, None)\n                             (\\<Inter>n.\n                                 {\\<omega> \\<in> space (KN.T (y, None)).\n                                  \\<not> (\\<exists>i<n.\n       ev_at (HLD D) i \\<omega>)})\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"(\\<Inter>n. {\\<omega>\\<in>space (KN.T (y, None)). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) =\n    {\\<omega>\\<in>space (KN.T (y, None)). alw (not (HLD D)) \\<omega>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Inter>n.\n        {\\<omega> \\<in> space (KN.T (y, None)).\n         \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) =\n    {\\<omega> \\<in> space (KN.T (y, None)).\n     alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}", "by (auto simp: not_ev_iff[symmetric] ev_iff_ev_at)"], ["proof (state)\nthis:\n  (\\<Inter>n.\n      {\\<omega> \\<in> space (KN.T (y, None)).\n       \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) =\n  {\\<omega> \\<in> space (KN.T (y, None)).\n   alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "also"], ["proof (state)\nthis:\n  (\\<Inter>n.\n      {\\<omega> \\<in> space (KN.T (y, None)).\n       \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}) =\n  {\\<omega> \\<in> space (KN.T (y, None)).\n   alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "have \"\\<P>(\\<omega> in KN.T (y, None). alw (not (HLD D)) \\<omega>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. KN.T.prob (y, None)\n     {\\<omega> \\<in> space (KN.T (y, None)).\n      alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>} =\n    0", "by fact"], ["proof (state)\nthis:\n  KN.T.prob (y, None)\n   {\\<omega> \\<in> space (KN.T (y, None)).\n    alw (\\<lambda>xs. \\<not> HLD D xs) \\<omega>} =\n  0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<longlonglongrightarrow> 0", "have *: \"(\\<lambda>n. 2 * \\<P>(\\<omega> in KN.T (y, None). \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>))) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>n.\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        2 *\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n    \\<longlonglongrightarrow> 0", "by (intro tendsto_eq_intros) auto"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      2 *\n      KN.T.prob (y, None)\n       {\\<omega> \\<in> space (KN.T (y, None)).\n        \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)})\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "apply (rule LIMSEQ_imp_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>)\n    \\<longlonglongrightarrow> 0", "apply (rule tendsto_sandwich[OF _ _ tendsto_const *])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>\n       \\<le> 2 *\n             KN.T.prob (y, None)\n              {\\<omega> \\<in> space (KN.T (y, None)).\n               \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "using le_2"], ["proof (prove)\nusing this:\n  LINT x|count_space C. \\<bar>p y x (Suc ?n7) - pmf N x\\<bar>\n  \\<le> 2 *\n        KN.T.prob (y, None)\n         {\\<omega> \\<in> space (KN.T (y, None)).\n          \\<not> (\\<exists>i<?n7. ev_at (HLD D) i \\<omega>)}\n\ngoal (2 subgoals):\n 1. \\<forall>\\<^sub>F n in sequentially.\n       0 \\<le> LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>\n 2. \\<forall>\\<^sub>F n in sequentially.\n       LINT x|count_space C. \\<bar>p y x (Suc n) - pmf N x\\<bar>\n       \\<le> 2 *\n             KN.T.prob (y, None)\n              {\\<omega> \\<in> space (KN.T (y, None)).\n               \\<not> (\\<exists>i<n. ev_at (HLD D) i \\<omega>)}", "apply (simp_all add: integral_nonneg_AE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<lambda>n. LINT x|count_space C. \\<bar>p y x n - pmf N x\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stationary_distribution_imp_p_limit:\n  assumes \"aperiodic C\" \"essential_class C\" and [simp]: \"countable C\"\n  assumes N: \"stationary_distribution N\" \"N \\<subseteq> C\"\n  assumes [simp]: \"x \\<in> C\" \"y \\<in> C\"\n  shows \"p x y \\<longlonglongrightarrow> pmf N y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "define D where \"D y n = \\<bar>p x y n - pmf N y\\<bar>\" for y n"], ["proof (state)\nthis:\n  D ?y ?n = \\<bar>p x ?y ?n - pmf N ?y\\<bar>\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "from stationary_distribution_imp_limit[OF assms(1,2,3,4,5,6)]"], ["proof (chain)\npicking this:\n  (\\<lambda>n. LINT xa|count_space C. \\<bar>p x xa n - pmf N xa\\<bar>)\n  \\<longlonglongrightarrow> 0", "have INT: \"(\\<lambda>n. \\<integral>y. D y n \\<partial>count_space C) \\<longlonglongrightarrow> 0\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. LINT xa|count_space C. \\<bar>p x xa n - pmf N xa\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT y|count_space C. D y n) \\<longlonglongrightarrow> 0", "unfolding D_def"], ["proof (prove)\nusing this:\n  (\\<lambda>n. LINT xa|count_space C. \\<bar>p x xa n - pmf N xa\\<bar>)\n  \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LINT y|count_space C. \\<bar>p x y n - pmf N y\\<bar>)\n    \\<longlonglongrightarrow> 0", "."], ["proof (state)\nthis:\n  (\\<lambda>n. LINT y|count_space C. D y n) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "{"], ["proof (state)\nthis:\n  (\\<lambda>n. LINT y|count_space C. D y n) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "have \"D y n \\<le> (\\<integral>z. D y n * indicator {y} z \\<partial>count_space C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D y n \\<le> LINT z|count_space C. D y n * indicat_real {y} z", "by simp"], ["proof (state)\nthis:\n  D y n \\<le> LINT z|count_space C. D y n * indicat_real {y} z\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "also"], ["proof (state)\nthis:\n  D y n \\<le> LINT z|count_space C. D y n * indicat_real {y} z\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "have \"\\<dots> \\<le> (\\<integral>y. D y n \\<partial>count_space C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LINT z|count_space C. D y n * indicat_real {y} z\n    \\<le> LINT y|count_space C. D y n", "by (intro integral_mono)\n         (auto split: split_indicator simp: D_def p_def disjoint_family_on_def\n               intro!: Bochner_Integration.integrable_diff integrable_pmf T.integrable_measure)"], ["proof (state)\nthis:\n  LINT z|count_space C. D y n * indicat_real {y} z\n  \\<le> LINT y|count_space C. D y n\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "finally"], ["proof (chain)\npicking this:\n  D y n \\<le> LINT y|count_space C. D y n", "have \"D y n \\<le> (\\<integral>y. D y n \\<partial>count_space C)\""], ["proof (prove)\nusing this:\n  D y n \\<le> LINT y|count_space C. D y n\n\ngoal (1 subgoal):\n 1. D y n \\<le> LINT y|count_space C. D y n", "."], ["proof (state)\nthis:\n  D y n \\<le> LINT y|count_space C. D y n\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "}"], ["proof (state)\nthis:\n  D y ?n6 \\<le> LINT y|count_space C. D y ?n6\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "note * = this"], ["proof (state)\nthis:\n  D y ?n6 \\<le> LINT y|count_space C. D y ?n6\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "have D_nonneg: \"\\<And>n. 0 \\<le> D y n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. 0 \\<le> D y n", "by (simp add: D_def)"], ["proof (state)\nthis:\n  0 \\<le> D y ?n4\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "have \"D y \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D y \\<longlonglongrightarrow> 0", "by (rule tendsto_sandwich[OF _ _ tendsto_const INT])\n       (auto simp: eventually_sequentially * D_nonneg)"], ["proof (state)\nthis:\n  D y \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "then"], ["proof (chain)\npicking this:\n  D y \\<longlonglongrightarrow> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  D y \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "using Lim_null[where l=\"pmf N y\" and net=sequentially and f=\"p x y\"]"], ["proof (prove)\nusing this:\n  D y \\<longlonglongrightarrow> 0\n  p x y \\<longlonglongrightarrow> pmf N y =\n  (\\<lambda>xa. p x y xa - pmf N y) \\<longlonglongrightarrow> 0\n\ngoal (1 subgoal):\n 1. p x y \\<longlonglongrightarrow> pmf N y", "by (simp add: D_def [abs_def] tendsto_rabs_zero_iff)"], ["proof (state)\nthis:\n  p x y \\<longlonglongrightarrow> pmf N y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in MC_syntax) essential_classI2:\n  assumes \"X \\<noteq> {}\"\n  assumes accI: \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> (x, y) \\<in> acc\"\n  assumes ED: \"\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> set_pmf (K x) \\<Longrightarrow> y \\<in> X\"\n  shows \"essential_class X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essential_class X", "proof (rule essential_classI)"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<in> UNIV // communicating\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X; (x, y) \\<in> acc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> X", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<in> UNIV // communicating\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X; (x, y) \\<in> acc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> X", "fix x y"], ["proof (state)\ngoal (2 subgoals):\n 1. X \\<in> UNIV // communicating\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X; (x, y) \\<in> acc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> X", "assume \"(x, y) \\<in> acc\" \"x \\<in> X\""], ["proof (state)\nthis:\n  (x, y) \\<in> acc\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. X \\<in> UNIV // communicating\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> X; (x, y) \\<in> acc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> X", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> acc\n  x \\<in> X", "show \"y \\<in> X\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> acc\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. y \\<in> X", "by induct (auto dest: ED)"], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // communicating", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?x6, ?y6) \\<in> acc; ?x6 \\<in> X\\<rbrakk>\n  \\<Longrightarrow> ?y6 \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // communicating", "note accD = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?x6, ?y6) \\<in> acc; ?x6 \\<in> X\\<rbrakk>\n  \\<Longrightarrow> ?y6 \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // communicating", "from \\<open>X \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  X \\<noteq> {}", "obtain x where \"x \\<in> X\""], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> X \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // communicating", "from \\<open>x \\<in> X\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> X", "show \"X \\<in> UNIV // communicating\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<in> UNIV // communicating", "by (auto simp add: quotient_def Image_def communicating_def accI dest: accD intro!: exI[of _ x])"], ["proof (state)\nthis:\n  X \\<in> UNIV // communicating\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}