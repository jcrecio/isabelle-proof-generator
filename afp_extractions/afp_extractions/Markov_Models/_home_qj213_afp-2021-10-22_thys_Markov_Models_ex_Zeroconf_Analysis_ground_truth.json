{"file_name": "/home/qj213/afp-2021-10-22/thys/Markov_Models/ex/Zeroconf_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Markov_Models", "problem_names": ["lemma inj_probe: \"inj_on probe X\"", "lemma p_bounds[simp]: \"0 \\<le> p\" \"p \\<le> 1\"", "lemma q_bounds[simp]: \"0 \\<le> q\" \"q \\<le> 1\"", "lemma \\<rho>_nonneg'[simp]: \"0 \\<le> \\<rho> s t\"", "lemma enabled_ok: \"enabled ok \\<omega> \\<longleftrightarrow> \\<omega> = sconst ok\"", "lemma finite_E[intro, simp]: \"finite (E s)\"", "lemma E_closed: \"s \\<in> states \\<Longrightarrow> E s \\<subseteq> states\"", "lemma enabled_error: \"enabled error \\<omega> \\<longleftrightarrow> \\<omega> = sconst error\"", "lemma pos_neg_q_pn: \"0 < 1 - q * (1 - p^Suc N)\"", "lemma to_error: assumes \"n \\<le> N\" shows \"(probe n, error) \\<in> acc\"", "lemma P_err:\n  defines \"p_start == (q * p ^ Suc N) / (1 - q * (1 - p ^ Suc N))\"\n  defines \"p_probe == (\\<lambda>n. p ^ Suc (N - n) + (1 - p^Suc (N - n)) * p_start)\"\n  assumes s: \"s \\<in> states - {ok, error}\"\n  shows \"P_err s = (case s of ok \\<Rightarrow> 0 | error \\<Rightarrow> 1 | probe n \\<Rightarrow> p_probe n | start \\<Rightarrow> p_start)\"\n    (is \"\\<dots> = ?E s\")", "lemma P_err_start: \"P_err start = (q * p ^ Suc N) / (1 - q * (1 - p ^ Suc N))\"", "lemma states_closed:\n  assumes \"s \\<in> states\"\n  assumes \"(s, t) \\<in> acc_on (- {error, ok})\"\n  shows \"t \\<in> states\"", "lemma finite_reached:\n  assumes s: \"s \\<in> states\" shows \"finite (acc_on (- {error, ok}) `` {s})\"", "lemma AE_reaches_error_or_ok:\n  assumes s: \"s \\<in> states\"\n  shows \"AE \\<omega> in T s. ev (HLD {error, ok}) \\<omega>\"", "lemma R_iter: \"s \\<noteq> error \\<Longrightarrow> s \\<noteq> ok \\<Longrightarrow> R s = (\\<integral>\\<^sup>+t. ennreal (\\<rho> s t) + R t \\<partial>\\<tau> s)\"", "lemma R_finite:\n  assumes s: \"s \\<in> states\"\n  shows \"R s \\<noteq> \\<infinity>\"", "lemma R_less_top: \"s \\<in> states \\<Longrightarrow> R s < top\"", "lemma R'_iter: assumes s: \"s \\<in> states\" \"s \\<noteq> error\" \"s \\<noteq> ok\" shows \"R' s = (\\<integral>t. \\<rho> s t + R' t \\<partial>\\<tau> s)\"", "lemma cost_from_start:\n  \"R' start =\n    (q * (r + p^Suc N * e + r * p * (1 - p^N) / (1 - p)) + (1 - q) * (r * Suc N)) /\n    (1 - q + q * p^Suc N)\"", "lemma \"ZC.P_err start \\<le> 1 / 10^12\"", "lemma \"ZC.R' start \\<le> 0.007\""], "translations": [["", "lemma inj_probe: \"inj_on probe X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on probe X", "by (auto simp: inj_on_def)"], ["", "text \\<open>Countability of @{typ zc_state} simplifies measurability of functions on @{typ zc_state}.\\<close>"], ["", "instance zc_state :: countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(zc_state, countable_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "have \"countable ({start, ok, error} \\<union> probe`UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable ({start, ok, error} \\<union> range probe)", "by auto"], ["proof (state)\nthis:\n  countable ({start, ok, error} \\<union> range probe)\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "also"], ["proof (state)\nthis:\n  countable ({start, ok, error} \\<union> range probe)\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "have \"{start, ok, error} \\<union> probe`UNIV = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {start, ok, error} \\<union> range probe = UNIV", "using zc_state.nchotomy"], ["proof (prove)\nusing this:\n  \\<forall>zc_state.\n     zc_state = start \\<or>\n     (\\<exists>x2. zc_state = probe x2) \\<or>\n     zc_state = ok \\<or> zc_state = error\n\ngoal (1 subgoal):\n 1. {start, ok, error} \\<union> range probe = UNIV", "by auto"], ["proof (state)\nthis:\n  {start, ok, error} \\<union> range probe = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>to_nat. inj to_nat", "finally"], ["proof (chain)\npicking this:\n  countable UNIV", "show \"\\<exists>f::zc_state \\<Rightarrow> nat. inj f\""], ["proof (prove)\nusing this:\n  countable UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>f. inj f", "using inj_on_to_nat_on[of \"UNIV :: zc_state set\"]"], ["proof (prove)\nusing this:\n  countable UNIV\n  countable UNIV \\<Longrightarrow> inj (to_nat_on UNIV)\n\ngoal (1 subgoal):\n 1. \\<exists>f. inj f", "by auto"], ["proof (state)\nthis:\n  \\<exists>f. inj f\n\ngoal:\nNo subgoals!", "qed"], ["", "locale Zeroconf_Analysis =\n  fixes N :: nat and p q r e :: real\n  assumes p: \"0 < p\" \"p < 1\" and q: \"0 < q\" \"q < 1\"\n  assumes r[simp]: \"0 \\<le> r\" and e[simp]: \"0 \\<le> e\"\nbegin"], ["", "lemma p_bounds[simp]: \"0 \\<le> p\" \"p \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p &&& p \\<le> 1", "using p"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> p &&& p \\<le> 1", "by auto"], ["", "lemma q_bounds[simp]: \"0 \\<le> q\" \"q \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> q &&& q \\<le> 1", "using q"], ["proof (prove)\nusing this:\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> q &&& q \\<le> 1", "by auto"], ["", "abbreviation states where\n  \"states \\<equiv> probe ` {.. N} \\<union> {start, ok, error}\""], ["", "primrec \\<tau> :: \"zc_state \\<Rightarrow> zc_state pmf\" where\n  \"\\<tau> start     = map_pmf (\\<lambda>True \\<Rightarrow> probe 0 | False \\<Rightarrow> ok) (bernoulli_pmf q)\"\n| \"\\<tau> (probe n) = map_pmf (\\<lambda>True \\<Rightarrow> (if n < N then probe (Suc n) else error) | False \\<Rightarrow> start) (bernoulli_pmf p)\"\n| \"\\<tau> ok        = return_pmf ok\"\n| \"\\<tau> error     = return_pmf error\""], ["", "primrec \\<rho> :: \"zc_state \\<Rightarrow> zc_state \\<Rightarrow> real\" where\n  \"\\<rho> start     = (\\<lambda>_. 0) (probe 0 := r, ok := r * (N + 1))\"\n| \"\\<rho> (probe n) = (if n < N then (\\<lambda>_. 0) (probe (Suc n) := r) else (\\<lambda>_. 0) (error := e))\"\n| \"\\<rho> ok        = (\\<lambda>_. 0) (ok := 0)\"\n| \"\\<rho> error     = (\\<lambda>_. 0) (error := 0)\""], ["", "lemma \\<rho>_nonneg'[simp]: \"0 \\<le> \\<rho> s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<rho> s t", "using r e"], ["proof (prove)\nusing this:\n  0 \\<le> r\n  0 \\<le> e\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<rho> s t", "by (cases s) auto"], ["", "sublocale MC_with_rewards \\<tau> \\<rho> \"\\<lambda>s. 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MC_with_rewards (\\<lambda>x xa. ennreal (\\<rho> x xa)) (\\<lambda>s. 0)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s t. 0 \\<le> ennreal (\\<rho> s t)\n 2. \\<And>s. 0 \\<le> 0\n 3. (\\<lambda>(a, b). ennreal (\\<rho> a b))\n    \\<in> borel_measurable\n           (count_space UNIV \\<Otimes>\\<^sub>M count_space UNIV)", "qed (simp_all add: pair_measure_countable)"], ["", "subsection \\<open>The allocation run is a rewarded DTMC\\<close>"], ["", "abbreviation \"E s \\<equiv> set_pmf (\\<tau> s)\""], ["", "lemma enabled_ok: \"enabled ok \\<omega> \\<longleftrightarrow> \\<omega> = sconst ok\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled ok \\<omega> = (\\<omega> = sconst ok)", "by (simp add: enabled_iff_sconst)"], ["", "lemma finite_E[intro, simp]: \"finite (E s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E s)", "by (cases s) auto"], ["", "lemma E_closed: \"s \\<in> states \\<Longrightarrow> E s \\<subseteq> states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> states \\<Longrightarrow> E s \\<subseteq> states", "using p q"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. s \\<in> states \\<Longrightarrow> E s \\<subseteq> states", "by (cases s) (auto split: bool.splits)"], ["", "lemma enabled_error: \"enabled error \\<omega> \\<longleftrightarrow> \\<omega> = sconst error\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled error \\<omega> = (\\<omega> = sconst error)", "by (simp add: enabled_iff_sconst)"], ["", "lemma pos_neg_q_pn: \"0 < 1 - q * (1 - p^Suc N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 - q * (1 - p ^ Suc N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < 1 - q * (1 - p ^ Suc N)", "have \"p ^ Suc N \\<le> 1 ^ Suc N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ Suc N \\<le> 1 ^ Suc N", "using p"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. p ^ Suc N \\<le> 1 ^ Suc N", "by (intro power_mono) auto"], ["proof (state)\nthis:\n  p ^ Suc N \\<le> 1 ^ Suc N\n\ngoal (1 subgoal):\n 1. 0 < 1 - q * (1 - p ^ Suc N)", "with p q"], ["proof (chain)\npicking this:\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n  p ^ Suc N \\<le> 1 ^ Suc N", "have \"q * (1 - p^Suc N) < 1 * 1\""], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n  p ^ Suc N \\<le> 1 ^ Suc N\n\ngoal (1 subgoal):\n 1. q * (1 - p ^ Suc N) < 1 * 1", "by (intro mult_strict_mono) (auto simp: field_simps simp del: power_Suc)"], ["proof (state)\nthis:\n  q * (1 - p ^ Suc N) < 1 * 1\n\ngoal (1 subgoal):\n 1. 0 < 1 - q * (1 - p ^ Suc N)", "then"], ["proof (chain)\npicking this:\n  q * (1 - p ^ Suc N) < 1 * 1", "show ?thesis"], ["proof (prove)\nusing this:\n  q * (1 - p ^ Suc N) < 1 * 1\n\ngoal (1 subgoal):\n 1. 0 < 1 - q * (1 - p ^ Suc N)", "by simp"], ["proof (state)\nthis:\n  0 < 1 - q * (1 - p ^ Suc N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma to_error: assumes \"n \\<le> N\" shows \"(probe n, error) \\<in> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (probe n, error) \\<in> (Sigma UNIV E)\\<^sup>*", "using \\<open>n \\<le> N\\<close>"], ["proof (prove)\nusing this:\n  n \\<le> N\n\ngoal (1 subgoal):\n 1. (probe n, error) \\<in> (Sigma UNIV E)\\<^sup>*", "proof (induction rule: inc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (probe N, error) \\<in> (Sigma UNIV E)\\<^sup>*\n 2. \\<And>na.\n       \\<lbrakk>n \\<le> na; na < N;\n        (probe (Suc na), error) \\<in> (Sigma UNIV E)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (probe na, error) \\<in> (Sigma UNIV E)\\<^sup>*", "case (step n')"], ["proof (state)\nthis:\n  n \\<le> n'\n  n' < N\n  (probe (Suc n'), error) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (2 subgoals):\n 1. (probe N, error) \\<in> (Sigma UNIV E)\\<^sup>*\n 2. \\<And>na.\n       \\<lbrakk>n \\<le> na; na < N;\n        (probe (Suc na), error) \\<in> (Sigma UNIV E)\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (probe na, error) \\<in> (Sigma UNIV E)\\<^sup>*", "with p"], ["proof (chain)\npicking this:\n  0 < p\n  p < 1\n  n \\<le> n'\n  n' < N\n  (probe (Suc n'), error) \\<in> (Sigma UNIV E)\\<^sup>*", "show ?case"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  n \\<le> n'\n  n' < N\n  (probe (Suc n'), error) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (probe n', error) \\<in> (Sigma UNIV E)\\<^sup>*", "by (intro rtrancl_trans[OF r_into_rtrancl step.IH]) auto"], ["proof (state)\nthis:\n  (probe n', error) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (probe N, error) \\<in> (Sigma UNIV E)\\<^sup>*", "qed (insert p, auto)"], ["", "subsection \\<open>Probability of a erroneous allocation\\<close>"], ["", "definition \"P_err s = \\<P>(\\<omega> in T s. ev (HLD {error}) (s ## \\<omega>))\""], ["", "lemma P_err:\n  defines \"p_start == (q * p ^ Suc N) / (1 - q * (1 - p ^ Suc N))\"\n  defines \"p_probe == (\\<lambda>n. p ^ Suc (N - n) + (1 - p^Suc (N - n)) * p_start)\"\n  assumes s: \"s \\<in> states - {ok, error}\"\n  shows \"P_err s = (case s of ok \\<Rightarrow> 0 | error \\<Rightarrow> 1 | probe n \\<Rightarrow> p_probe n | start \\<Rightarrow> p_start)\"\n    (is \"\\<dots> = ?E s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P_err s =\n    (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n     | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1)", "using s"], ["proof (prove)\nusing this:\n  s \\<in> states - {ok, error}\n\ngoal (1 subgoal):\n 1. P_err s =\n    (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n     | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1)", "proof (rule unique_les)"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<Union>s\\<in>states - {ok, error}. set_pmf (?K s))\n    \\<subseteq> states - {ok, error} \\<union> ?N\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       \\<exists>t\\<in>?N.\n          (s, t) \\<in> (SIGMA x:UNIV. set_pmf (?K x))\\<^sup>*\n 5. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1) =\n       measure_pmf.expectation (?K s)\n        (\\<lambda>t.\n            case t of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1) +\n       ?c s\n 6. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (?K s) P_err + ?c s\n 7. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 8. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> ?N))", "have [arith]: \"0 \\<le> p * (q * p ^ N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> p * (q * p ^ N)", "using p q"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. 0 \\<le> p * (q * p ^ N)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> p * (q * p ^ N)\n\ngoal (8 subgoals):\n 1. (\\<Union>s\\<in>states - {ok, error}. set_pmf (?K s))\n    \\<subseteq> states - {ok, error} \\<union> ?N\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       \\<exists>t\\<in>?N.\n          (s, t) \\<in> (SIGMA x:UNIV. set_pmf (?K x))\\<^sup>*\n 5. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1) =\n       measure_pmf.expectation (?K s)\n        (\\<lambda>t.\n            case t of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1) +\n       ?c s\n 6. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (?K s) P_err + ?c s\n 7. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 8. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> ?N))", "have p_eq: \"p_start = p_probe 0 * q\"\n    \"\\<And>n. n < N \\<Longrightarrow> p_probe n = p_probe (Suc n) * p + p_start * (1 - p)\"\n    \"p_probe N = p + p_start * (1 - p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_start = p_probe 0 * q &&&\n    (\\<And>n.\n        n < N \\<Longrightarrow>\n        p_probe n = p_probe (Suc n) * p + p_start * (1 - p)) &&&\n    p_probe N = p + p_start * (1 - p)", "using p q"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. p_start = p_probe 0 * q &&&\n    (\\<And>n.\n        n < N \\<Longrightarrow>\n        p_probe n = p_probe (Suc n) * p + p_start * (1 - p)) &&&\n    p_probe N = p + p_start * (1 - p)", "by (auto simp: p_probe_def p_start_def power_Suc[symmetric] Suc_diff_Suc divide_simps\n             simp del: power_Suc)\n       (auto simp: field_simps)"], ["proof (state)\nthis:\n  p_start = p_probe 0 * q\n  ?n1 < N \\<Longrightarrow>\n  p_probe ?n1 = p_probe (Suc ?n1) * p + p_start * (1 - p)\n  p_probe N = p + p_start * (1 - p)\n\ngoal (8 subgoals):\n 1. (\\<Union>s\\<in>states - {ok, error}. set_pmf (?K s))\n    \\<subseteq> states - {ok, error} \\<union> ?N\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       \\<exists>t\\<in>?N.\n          (s, t) \\<in> (SIGMA x:UNIV. set_pmf (?K x))\\<^sup>*\n 5. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1) =\n       measure_pmf.expectation (?K s)\n        (\\<lambda>t.\n            case t of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1) +\n       ?c s\n 6. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (?K s) P_err + ?c s\n 7. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 8. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> ?N))", "fix s"], ["proof (state)\ngoal (8 subgoals):\n 1. (\\<Union>s\\<in>states - {ok, error}. set_pmf (?K s))\n    \\<subseteq> states - {ok, error} \\<union> ?N\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       \\<exists>t\\<in>?N.\n          (s, t) \\<in> (SIGMA x:UNIV. set_pmf (?K x))\\<^sup>*\n 5. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1) =\n       measure_pmf.expectation (?K s)\n        (\\<lambda>t.\n            case t of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1) +\n       ?c s\n 6. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (?K s) P_err + ?c s\n 7. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 8. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> ?N))", "assume s: \"s \\<in> states - {ok, error}\""], ["proof (state)\nthis:\n  s \\<in> states - {ok, error}\n\ngoal (8 subgoals):\n 1. (\\<Union>s\\<in>states - {ok, error}. set_pmf (?K s))\n    \\<subseteq> states - {ok, error} \\<union> ?N\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (?K s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       \\<exists>t\\<in>?N.\n          (s, t) \\<in> (SIGMA x:UNIV. set_pmf (?K x))\\<^sup>*\n 5. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1) =\n       measure_pmf.expectation (?K s)\n        (\\<lambda>t.\n            case t of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1) +\n       ?c s\n 6. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (?K s) P_err + ?c s\n 7. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 8. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> ?N))", "then"], ["proof (chain)\npicking this:\n  s \\<in> states - {ok, error}", "show \"?E s = (\\<integral>t. ?E t \\<partial>\\<tau> s) + 0\""], ["proof (prove)\nusing this:\n  s \\<in> states - {ok, error}\n\ngoal (1 subgoal):\n 1. (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n     | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1) =\n    measure_pmf.expectation (\\<tau> s)\n     (\\<lambda>t.\n         case t of start \\<Rightarrow> p_start\n         | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n         | error \\<Rightarrow> 1) +\n    0", "using p q"], ["proof (prove)\nusing this:\n  s \\<in> states - {ok, error}\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n     | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1) =\n    measure_pmf.expectation (\\<tau> s)\n     (\\<lambda>t.\n         case t of start \\<Rightarrow> p_start\n         | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n         | error \\<Rightarrow> 1) +\n    0", "by (auto intro: p_eq)"], ["proof (state)\nthis:\n  (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n   | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1) =\n  measure_pmf.expectation (\\<tau> s)\n   (\\<lambda>t.\n       case t of start \\<Rightarrow> p_start\n       | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n       | error \\<Rightarrow> 1) +\n  0\n\ngoal (7 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> ?N\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       \\<exists>t\\<in>?N. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n 5. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (\\<tau> s) P_err + 0\n 6. \\<And>s.\n       s \\<in> ?N \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 7. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> ?N))", "show \"\\<exists>t\\<in>{ok, error}. (s, t) \\<in> acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{ok, error}. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*", "using s q to_error"], ["proof (prove)\nusing this:\n  s \\<in> states - {ok, error}\n  0 < q\n  q < 1\n  ?n \\<le> N \\<Longrightarrow>\n  (probe ?n, error) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>t\\<in>{ok, error}. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t\\<in>{ok, error}. (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (6 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> {ok, error}\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       P_err s = measure_pmf.expectation (\\<tau> s) P_err + 0\n 5. \\<And>s.\n       s \\<in> {ok, error} \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 6. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> {ok, error}))", "from s"], ["proof (chain)\npicking this:\n  s \\<in> states - {ok, error}", "show \"P_err s = integral\\<^sup>L (measure_pmf (\\<tau> s)) P_err + 0\""], ["proof (prove)\nusing this:\n  s \\<in> states - {ok, error}\n\ngoal (1 subgoal):\n 1. P_err s = measure_pmf.expectation (\\<tau> s) P_err + 0", "unfolding P_err_def[abs_def]"], ["proof (prove)\nusing this:\n  s \\<in> states - {ok, error}\n\ngoal (1 subgoal):\n 1. T.prob s\n     {\\<omega> \\<in> space (T s). ev (HLD {error}) (s ## \\<omega>)} =\n    measure_pmf.expectation (\\<tau> s)\n     (\\<lambda>s.\n         T.prob s\n          {\\<omega> \\<in> space (T s). ev (HLD {error}) (s ## \\<omega>)}) +\n    0", "by (subst prob_T) (auto simp: ev_Stream simp del: UNIV_bool)"], ["proof (state)\nthis:\n  P_err s = measure_pmf.expectation (\\<tau> s) P_err + 0\n\ngoal (5 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> {ok, error}\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. \\<And>s.\n       s \\<in> {ok, error} \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 5. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> {ok, error}))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> {ok, error}\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. \\<And>s.\n       s \\<in> {ok, error} \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 5. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> {ok, error}))", "fix s"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> {ok, error}\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. \\<And>s.\n       s \\<in> {ok, error} \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 5. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> {ok, error}))", "assume \"s \\<in> {ok, error}\""], ["proof (state)\nthis:\n  s \\<in> {ok, error}\n\ngoal (5 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> {ok, error}\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. \\<And>s.\n       s \\<in> {ok, error} \\<Longrightarrow>\n       P_err s =\n       (case s of start \\<Rightarrow> p_start\n        | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n        | error \\<Rightarrow> 1)\n 5. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> {ok, error}))", "then"], ["proof (chain)\npicking this:\n  s \\<in> {ok, error}", "show \"P_err s = ?E s\""], ["proof (prove)\nusing this:\n  s \\<in> {ok, error}\n\ngoal (1 subgoal):\n 1. P_err s =\n    (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n     | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1)", "by (auto intro!: T.prob_eq_0_AE T.prob_Collect_eq_1[THEN iffD2]\n             simp: P_err_def AE_sconst ev_sconst HLD_iff ev_Stream T.prob_space\n             simp del: space_T sets_T )"], ["proof (state)\nthis:\n  P_err s =\n  (case s of start \\<Rightarrow> p_start | probe n \\<Rightarrow> p_probe n\n   | ok \\<Rightarrow> 0 | error \\<Rightarrow> 1)\n\ngoal (4 subgoals):\n 1. \\<Union> (E ` (states - {ok, error}))\n    \\<subseteq> states - {ok, error} \\<union> {ok, error}\n 2. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s))\n        (\\<lambda>a.\n            case a of start \\<Rightarrow> p_start\n            | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n            | error \\<Rightarrow> 1)\n 3. \\<And>s.\n       s \\<in> states - {ok, error} \\<Longrightarrow>\n       integrable (measure_pmf (\\<tau> s)) P_err\n 4. finite\n     ((\\<lambda>x.\n          P_err x -\n          (case x of start \\<Rightarrow> p_start\n           | probe n \\<Rightarrow> p_probe n | ok \\<Rightarrow> 0\n           | error \\<Rightarrow> 1)) `\n      (states - {ok, error} \\<union> {ok, error}))", "qed (insert p q, auto intro!: integrable_measure_pmf_finite split: if_split_asm)"], ["", "lemma P_err_start: \"P_err start = (q * p ^ Suc N) / (1 - q * (1 - p ^ Suc N))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P_err start = q * p ^ Suc N / (1 - q * (1 - p ^ Suc N))", "by (simp add: P_err)"], ["", "subsection \\<open>An allocation run terminates almost surely\\<close>"], ["", "lemma states_closed:\n  assumes \"s \\<in> states\"\n  assumes \"(s, t) \\<in> acc_on (- {error, ok})\"\n  shows \"t \\<in> states\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> states", "using assms(2,1) p q"], ["proof (prove)\nusing this:\n  (s, t) \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*\n  s \\<in> states\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. t \\<in> states", "by induction (auto split: if_split_asm)"], ["", "lemma finite_reached:\n  assumes s: \"s \\<in> states\" shows \"finite (acc_on (- {error, ok}) `` {s})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "using states_closed[OF s]"], ["proof (prove)\nusing this:\n  (s, ?t)\n  \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n  ?t \\<in> states\n\ngoal (1 subgoal):\n 1. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "by (rule_tac finite_subset[of _ states]) auto"], ["", "lemma AE_reaches_error_or_ok:\n  assumes s: \"s \\<in> states\"\n  shows \"AE \\<omega> in T s. ev (HLD {error, ok}) \\<omega>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_everywhere (T s) (ev (HLD {error, ok}))", "proof (rule AE_T_ev_HLD)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>{error, ok}. (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>{error, ok}. (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>{error, ok}. (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "assume t: \"(s, t) \\<in> acc_on (- {error, ok})\""], ["proof (state)\nthis:\n  (s, t) \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       \\<exists>t'\\<in>{error, ok}. (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n 2. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "with states_closed[OF s t] to_error p q"], ["proof (chain)\npicking this:\n  t \\<in> states\n  ?n \\<le> N \\<Longrightarrow>\n  (probe ?n, error) \\<in> (Sigma UNIV E)\\<^sup>*\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n  (s, t) \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*", "show \"\\<exists>t'\\<in>{error, ok}. (t, t') \\<in> acc\""], ["proof (prove)\nusing this:\n  t \\<in> states\n  ?n \\<le> N \\<Longrightarrow>\n  (probe ?n, error) \\<in> (Sigma UNIV E)\\<^sup>*\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n  (s, t) \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>t'\\<in>{error, ok}. (t, t') \\<in> (Sigma UNIV E)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>t'\\<in>{error, ok}. (t, t') \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "}"], ["proof (state)\nthis:\n  (s, ?t3)\n  \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n  \\<exists>t'\\<in>{error, ok}. (?t3, t') \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (1 subgoal):\n 1. finite ((SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>* `` {s})", "qed (rule finite_reached[OF s])"], ["", "subsection \\<open>Expected runtime of an allocation run\\<close>"], ["", "definition \"R s = (\\<integral>\\<^sup>+ \\<omega>. reward_until {error, ok} s \\<omega> \\<partial>T s)\""], ["", "definition \"R' s = enn2real (R s)\""], ["", "lemma R_iter: \"s \\<noteq> error \\<Longrightarrow> s \\<noteq> ok \\<Longrightarrow> R s = (\\<integral>\\<^sup>+t. ennreal (\\<rho> s t) + R t \\<partial>\\<tau> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> error; s \\<noteq> ok\\<rbrakk>\n    \\<Longrightarrow> R s =\n                      \\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n   \\<partial>measure_pmf (\\<tau> s)", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> error; s \\<noteq> ok\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (T s) (reward_until {error, ok} s) =\n                      \\<integral>\\<^sup>+ t.\n     ennreal (\\<rho> s t) +\n     integral\\<^sup>N (T t) (reward_until {error, ok} t)\n   \\<partial>measure_pmf (\\<tau> s)", "using T.emeasure_space_1"], ["proof (prove)\nusing this:\n  emeasure (T ?s) (space (T ?s)) = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<noteq> error; s \\<noteq> ok\\<rbrakk>\n    \\<Longrightarrow> integral\\<^sup>N (T s) (reward_until {error, ok} s) =\n                      \\<integral>\\<^sup>+ t.\n     ennreal (\\<rho> s t) +\n     integral\\<^sup>N (T t) (reward_until {error, ok} t)\n   \\<partial>measure_pmf (\\<tau> s)", "by (subst nn_integral_T)\n     (auto simp del: \\<tau>.simps \\<rho>.simps simp add: AE_measure_pmf_iff nn_integral_add\n           intro!: nn_integral_cong_AE)"], ["", "lemma R_finite:\n  assumes s: \"s \\<in> states\"\n  shows \"R s \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R s \\<noteq> \\<infinity>", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>N (T s) (reward_until {error, ok} s) \\<noteq> \\<infinity>", "proof (rule nn_integral_reward_until_finite)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "fix t"], ["proof (state)\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "assume \"(s, t) \\<in> acc\""], ["proof (state)\nthis:\n  (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "from this s p q"], ["proof (chain)\npicking this:\n  (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n  s \\<in> states\n  0 < p\n  p < 1\n  0 < q\n  q < 1", "have \"t \\<in> states\""], ["proof (prove)\nusing this:\n  (s, t) \\<in> (Sigma UNIV E)\\<^sup>*\n  s \\<in> states\n  0 < p\n  p < 1\n  0 < q\n  q < 1\n\ngoal (1 subgoal):\n 1. t \\<in> states", "by induction (auto split: if_split_asm)"], ["proof (state)\nthis:\n  t \\<in> states\n\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "}"], ["proof (state)\nthis:\n  (s, ?t3) \\<in> (Sigma UNIV E)\\<^sup>* \\<Longrightarrow> ?t3 \\<in> states\n\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "then"], ["proof (chain)\npicking this:\n  (s, ?t3) \\<in> (Sigma UNIV E)\\<^sup>* \\<Longrightarrow> ?t3 \\<in> states", "have \"acc `` {s} \\<subseteq> states\""], ["proof (prove)\nusing this:\n  (s, ?t3) \\<in> (Sigma UNIV E)\\<^sup>* \\<Longrightarrow> ?t3 \\<in> states\n\ngoal (1 subgoal):\n 1. (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> states", "by auto"], ["proof (state)\nthis:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> states\n\ngoal (4 subgoals):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})\n 2. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 3. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 4. almost_everywhere (T s) (ev (HLD {error, ok}))", "then"], ["proof (chain)\npicking this:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> states", "show \"finite (acc `` {s})\""], ["proof (prove)\nusing this:\n  (Sigma UNIV E)\\<^sup>* `` {s} \\<subseteq> states\n\ngoal (1 subgoal):\n 1. finite ((Sigma UNIV E)\\<^sup>* `` {s})", "by (auto dest: finite_subset)"], ["proof (state)\nthis:\n  finite ((Sigma UNIV E)\\<^sup>* `` {s})\n\ngoal (3 subgoals):\n 1. \\<And>t.\n       (s, t)\n       \\<in> (SIGMA s:UNIV.\n                 E s \\<inter> - {error, ok})\\<^sup>* \\<Longrightarrow>\n       0 < \\<infinity>\n 2. \\<And>t t'.\n       \\<lbrakk>(s, t)\n                \\<in> (SIGMA s:UNIV. E s \\<inter> - {error, ok})\\<^sup>*;\n        t' \\<in> E t\\<rbrakk>\n       \\<Longrightarrow> ennreal (\\<rho> t t') < \\<infinity>\n 3. almost_everywhere (T s) (ev (HLD {error, ok}))", "qed (auto simp: AE_reaches_error_or_ok[OF s])"], ["", "lemma R_less_top: \"s \\<in> states \\<Longrightarrow> R s < top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> states \\<Longrightarrow> R s < \\<top>", "using R_finite[of s]"], ["proof (prove)\nusing this:\n  s \\<in> states \\<Longrightarrow> R s \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. s \\<in> states \\<Longrightarrow> R s < \\<top>", "by (subst less_top[symmetric]) simp"], ["", "lemma R'_iter: assumes s: \"s \\<in> states\" \"s \\<noteq> error\" \"s \\<noteq> ok\" shows \"R' s = (\\<integral>t. \\<rho> s t + R' t \\<partial>\\<tau> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R' s =\n    measure_pmf.expectation (\\<tau> s) (\\<lambda>t. \\<rho> s t + R' t)", "unfolding R'_def R_iter[OF s(2,3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real\n     (\\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n                         \\<partial>measure_pmf (\\<tau> s)) =\n    measure_pmf.expectation (\\<tau> s)\n     (\\<lambda>t. \\<rho> s t + enn2real (R t))", "proof (rule enn2real_nn_integral_eq_integral)"], ["proof (state)\ngoal (4 subgoals):\n 1. AE t in measure_pmf\n             (\\<tau>\n               s). ennreal (\\<rho> s t) + R t =\n                   ennreal (\\<rho> s t + enn2real (R t))\n 2. AE t in measure_pmf (\\<tau> s). 0 \\<le> \\<rho> s t + enn2real (R t)\n 3. \\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n                       \\<partial>measure_pmf (\\<tau> s)\n    < \\<top>\n 4. measure_pmf.random_variable (\\<tau> s) borel\n     (\\<lambda>x. \\<rho> s x + enn2real (R x))", "have \"t \\<in> E s \\<Longrightarrow> R t < top\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> E s \\<Longrightarrow> R t < \\<top>", "using \\<open>s\\<in>states\\<close> E_closed[of s]"], ["proof (prove)\nusing this:\n  s \\<in> states\n  s \\<in> states \\<Longrightarrow> E s \\<subseteq> states\n\ngoal (1 subgoal):\n 1. t \\<in> E s \\<Longrightarrow> R t < \\<top>", "by (intro R_less_top) auto"], ["proof (state)\nthis:\n  ?t1 \\<in> E s \\<Longrightarrow> R ?t1 < \\<top>\n\ngoal (4 subgoals):\n 1. AE t in measure_pmf\n             (\\<tau>\n               s). ennreal (\\<rho> s t) + R t =\n                   ennreal (\\<rho> s t + enn2real (R t))\n 2. AE t in measure_pmf (\\<tau> s). 0 \\<le> \\<rho> s t + enn2real (R t)\n 3. \\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n                       \\<partial>measure_pmf (\\<tau> s)\n    < \\<top>\n 4. measure_pmf.random_variable (\\<tau> s) borel\n     (\\<lambda>x. \\<rho> s x + enn2real (R x))", "then"], ["proof (chain)\npicking this:\n  ?t1 \\<in> E s \\<Longrightarrow> R ?t1 < \\<top>", "show \"AE t in \\<tau> s. ennreal (\\<rho> s t) + R t = ennreal (\\<rho> s t + enn2real (R t))\""], ["proof (prove)\nusing this:\n  ?t1 \\<in> E s \\<Longrightarrow> R ?t1 < \\<top>\n\ngoal (1 subgoal):\n 1. AE t in measure_pmf\n             (\\<tau>\n               s). ennreal (\\<rho> s t) + R t =\n                   ennreal (\\<rho> s t + enn2real (R t))", "by (auto simp: AE_measure_pmf_iff intro!: ennreal_enn2real[symmetric])"], ["proof (state)\nthis:\n  AE t in measure_pmf\n           (\\<tau>\n             s). ennreal (\\<rho> s t) + R t =\n                 ennreal (\\<rho> s t + enn2real (R t))\n\ngoal (3 subgoals):\n 1. AE t in measure_pmf (\\<tau> s). 0 \\<le> \\<rho> s t + enn2real (R t)\n 2. \\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n                       \\<partial>measure_pmf (\\<tau> s)\n    < \\<top>\n 3. measure_pmf.random_variable (\\<tau> s) borel\n     (\\<lambda>x. \\<rho> s x + enn2real (R x))", "show \"(\\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t \\<partial>\\<tau> s) < \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n                       \\<partial>measure_pmf (\\<tau> s)\n    < \\<top>", "unfolding R_iter[symmetric, OF s(2,3)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. R s < \\<top>", "by (rule R_less_top) fact"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ t. ennreal (\\<rho> s t) + R t\n                     \\<partial>measure_pmf (\\<tau> s)\n  < \\<top>\n\ngoal (2 subgoals):\n 1. AE t in measure_pmf (\\<tau> s). 0 \\<le> \\<rho> s t + enn2real (R t)\n 2. measure_pmf.random_variable (\\<tau> s) borel\n     (\\<lambda>x. \\<rho> s x + enn2real (R x))", "qed auto"], ["", "lemma cost_from_start:\n  \"R' start =\n    (q * (r + p^Suc N * e + r * p * (1 - p^N) / (1 - p)) + (1 - q) * (r * Suc N)) /\n    (1 - q + q * p^Suc N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "have ok_error: \"R' ok = 0 \\<and> R' error = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R' ok = 0 \\<and> R' error = 0", "unfolding R'_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. enn2real (integral\\<^sup>N (T ok) (reward_until {error, ok} ok)) =\n    0 \\<and>\n    enn2real (integral\\<^sup>N (T error) (reward_until {error, ok} error)) =\n    0", "by (subst (1 2) reward_until_unfold[abs_def]) simp"], ["proof (state)\nthis:\n  R' ok = 0 \\<and> R' error = 0\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "then"], ["proof (chain)\npicking this:\n  R' ok = 0 \\<and> R' error = 0", "have R_start: \"R' start = q * (r + R' (probe 0)) + (1 - q) * (r * (N + 1))\""], ["proof (prove)\nusing this:\n  R' ok = 0 \\<and> R' error = 0\n\ngoal (1 subgoal):\n 1. R' start = q * (r + R' (probe 0)) + (1 - q) * (r * real (N + 1))", "using q r"], ["proof (prove)\nusing this:\n  R' ok = 0 \\<and> R' error = 0\n  0 < q\n  q < 1\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. R' start = q * (r + R' (probe 0)) + (1 - q) * (r * real (N + 1))", "by (subst R'_iter) (simp_all add: field_simps)"], ["proof (state)\nthis:\n  R' start = q * (r + R' (probe 0)) + (1 - q) * (r * real (N + 1))\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "have R_probe: \"\\<And>n. n < N \\<Longrightarrow> R' (probe n) = p * R' (probe (Suc n)) + p * r + (1 - p) * R' start\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < N \\<Longrightarrow>\n       R' (probe n) = p * R' (probe (Suc n)) + p * r + (1 - p) * R' start", "using p r"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 \\<le> r\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n < N \\<Longrightarrow>\n       R' (probe n) = p * R' (probe (Suc n)) + p * r + (1 - p) * R' start", "by (subst R'_iter) (simp_all add: field_simps distrib_right)"], ["proof (state)\nthis:\n  ?n1 < N \\<Longrightarrow>\n  R' (probe ?n1) = p * R' (probe (Suc ?n1)) + p * r + (1 - p) * R' start\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "have R_N: \"R' (probe N) = p * e + (1 - p) * R' start\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R' (probe N) = p * e + (1 - p) * R' start", "using p e ok_error"], ["proof (prove)\nusing this:\n  0 < p\n  p < 1\n  0 \\<le> e\n  R' ok = 0 \\<and> R' error = 0\n\ngoal (1 subgoal):\n 1. R' (probe N) = p * e + (1 - p) * R' start", "by (subst R'_iter) (auto simp: mult.commute )"], ["proof (state)\nthis:\n  R' (probe N) = p * e + (1 - p) * R' start\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "{"], ["proof (state)\nthis:\n  R' (probe N) = p * e + (1 - p) * R' start\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "assume \"n \\<le> N\""], ["proof (state)\nthis:\n  n \\<le> N\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "then"], ["proof (chain)\npicking this:\n  n \\<le> N", "have \"R' (probe (N - n)) =\n      p ^ Suc n * e + (1 - p^n) * r * p / (1 - p) + (1 - p^Suc n) * R' start\""], ["proof (prove)\nusing this:\n  n \\<le> N\n\ngoal (1 subgoal):\n 1. R' (probe (N - n)) =\n    p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n    (1 - p ^ Suc n) * R' start", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<Longrightarrow>\n    R' (probe (N - 0)) =\n    p ^ Suc 0 * e + (1 - p ^ 0) * r * p / (1 - p) +\n    (1 - p ^ Suc 0) * R' start\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "case 0"], ["proof (state)\nthis:\n  0 \\<le> N\n\ngoal (2 subgoals):\n 1. 0 \\<le> N \\<Longrightarrow>\n    R' (probe (N - 0)) =\n    p ^ Suc 0 * e + (1 - p ^ 0) * r * p / (1 - p) +\n    (1 - p ^ Suc 0) * R' start\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "with R_N"], ["proof (chain)\npicking this:\n  R' (probe N) = p * e + (1 - p) * R' start\n  0 \\<le> N", "show ?case"], ["proof (prove)\nusing this:\n  R' (probe N) = p * e + (1 - p) * R' start\n  0 \\<le> N\n\ngoal (1 subgoal):\n 1. R' (probe (N - 0)) =\n    p ^ Suc 0 * e + (1 - p ^ 0) * r * p / (1 - p) +\n    (1 - p ^ Suc 0) * R' start", "by simp"], ["proof (state)\nthis:\n  R' (probe (N - 0)) =\n  p ^ Suc 0 * e + (1 - p ^ 0) * r * p / (1 - p) + (1 - p ^ Suc 0) * R' start\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "moreover"], ["proof (state)\nthis:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "then"], ["proof (chain)\npicking this:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N", "have \"Suc (N - Suc n) = N - n\""], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N\n\ngoal (1 subgoal):\n 1. Suc (N - Suc n) = N - n", "by simp"], ["proof (state)\nthis:\n  Suc (N - Suc n) = N - n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> N \\<Longrightarrow>\n                R' (probe (N - n)) =\n                p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) +\n                (1 - p ^ Suc n) * R' start;\n        Suc n \\<le> N\\<rbrakk>\n       \\<Longrightarrow> R' (probe (N - Suc n)) =\n                         p ^ Suc (Suc n) * e +\n                         (1 - p ^ Suc n) * r * p / (1 - p) +\n                         (1 - p ^ Suc (Suc n)) * R' start", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N\n  Suc (N - Suc n) = N - n", "show ?case"], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N\n  Suc (N - Suc n) = N - n\n\ngoal (1 subgoal):\n 1. R' (probe (N - Suc n)) =\n    p ^ Suc (Suc n) * e + (1 - p ^ Suc n) * r * p / (1 - p) +\n    (1 - p ^ Suc (Suc n)) * R' start", "using R_probe[of \"N - Suc n\"] p"], ["proof (prove)\nusing this:\n  n \\<le> N \\<Longrightarrow>\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n  Suc n \\<le> N\n  Suc (N - Suc n) = N - n\n  N - Suc n < N \\<Longrightarrow>\n  R' (probe (N - Suc n)) =\n  p * R' (probe (Suc (N - Suc n))) + p * r + (1 - p) * R' start\n  0 < p\n  p < 1\n\ngoal (1 subgoal):\n 1. R' (probe (N - Suc n)) =\n    p ^ Suc (Suc n) * e + (1 - p ^ Suc n) * r * p / (1 - p) +\n    (1 - p ^ Suc (Suc n)) * R' start", "by (simp_all add: field_simps Suc)"], ["proof (state)\nthis:\n  R' (probe (N - Suc n)) =\n  p ^ Suc (Suc n) * e + (1 - p ^ Suc n) * r * p / (1 - p) +\n  (1 - p ^ Suc (Suc n)) * R' start\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R' (probe (N - n)) =\n  p ^ Suc n * e + (1 - p ^ n) * r * p / (1 - p) + (1 - p ^ Suc n) * R' start\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "}"], ["proof (state)\nthis:\n  ?n3 \\<le> N \\<Longrightarrow>\n  R' (probe (N - ?n3)) =\n  p ^ Suc ?n3 * e + (1 - p ^ ?n3) * r * p / (1 - p) +\n  (1 - p ^ Suc ?n3) * R' start\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "from this[of N]"], ["proof (chain)\npicking this:\n  N \\<le> N \\<Longrightarrow>\n  R' (probe (N - N)) =\n  p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p) + (1 - p ^ Suc N) * R' start", "have [simp]: \"R' (probe 0) = p ^ Suc N * e + (1 - p^N) * r * p / (1 - p) + (1 - p^Suc N) * R' start\""], ["proof (prove)\nusing this:\n  N \\<le> N \\<Longrightarrow>\n  R' (probe (N - N)) =\n  p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p) + (1 - p ^ Suc N) * R' start\n\ngoal (1 subgoal):\n 1. R' (probe 0) =\n    p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p) +\n    (1 - p ^ Suc N) * R' start", "by simp"], ["proof (state)\nthis:\n  R' (probe 0) =\n  p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p) + (1 - p ^ Suc N) * R' start\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "have \"R' start - q * (1 - p^Suc N) * R' start =\n    q * (r + p^Suc N * e + (1 - p^N) * r * p / (1 - p)) + (1 - q) * (r * (N + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R' start - q * (1 - p ^ Suc N) * R' start =\n    q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n    (1 - q) * (r * real (N + 1))", "by (subst R_start) (simp_all add: field_simps)"], ["proof (state)\nthis:\n  R' start - q * (1 - p ^ Suc N) * R' start =\n  q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n  (1 - q) * (r * real (N + 1))\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "then"], ["proof (chain)\npicking this:\n  R' start - q * (1 - p ^ Suc N) * R' start =\n  q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n  (1 - q) * (r * real (N + 1))", "have \"R' start = (q * (r + p^Suc N * e + (1 - p^N) * r * p / (1 - p)) + (1 - q) * (r * Suc N)) /\n    (1 - q * (1 - p^Suc N))\""], ["proof (prove)\nusing this:\n  R' start - q * (1 - p ^ Suc N) * R' start =\n  q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n  (1 - q) * (r * real (N + 1))\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q * (1 - p ^ Suc N))", "using pos_neg_q_pn"], ["proof (prove)\nusing this:\n  R' start - q * (1 - p ^ Suc N) * R' start =\n  q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n  (1 - q) * (r * real (N + 1))\n  0 < 1 - q * (1 - p ^ Suc N)\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q * (1 - p ^ Suc N))", "by (simp_all add: field_simps)"], ["proof (state)\nthis:\n  R' start =\n  (q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n   (1 - q) * (r * real (Suc N))) /\n  (1 - q * (1 - p ^ Suc N))\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "then"], ["proof (chain)\npicking this:\n  R' start =\n  (q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n   (1 - q) * (r * real (Suc N))) /\n  (1 - q * (1 - p ^ Suc N))", "show ?thesis"], ["proof (prove)\nusing this:\n  R' start =\n  (q * (r + p ^ Suc N * e + (1 - p ^ N) * r * p / (1 - p)) +\n   (1 - q) * (r * real (Suc N))) /\n  (1 - q * (1 - p ^ Suc N))\n\ngoal (1 subgoal):\n 1. R' start =\n    (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n     (1 - q) * (r * real (Suc N))) /\n    (1 - q + q * p ^ Suc N)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  R' start =\n  (q * (r + p ^ Suc N * e + r * p * (1 - p ^ N) / (1 - p)) +\n   (1 - q) * (r * real (Suc N))) /\n  (1 - q + q * p ^ Suc N)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "interpretation ZC: Zeroconf_Analysis 2 \"16 / 65024 :: real\" \"0.01\" \"0.002\" \"3600\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Zeroconf_Analysis (16 / 65024) (1 / 10\\<^sup>2) (2 / 10 ^ 3) 3600", "by standard auto"], ["", "lemma \"ZC.P_err start \\<le> 1 / 10^12\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZC.P_err start \\<le> 1 / 10 ^ 12", "unfolding ZC.P_err_start"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 10\\<^sup>2 * (16 / 65024) ^ Suc 2 /\n    (1 - 1 / 10\\<^sup>2 * (1 - (16 / 65024) ^ Suc 2))\n    \\<le> 1 / 10 ^ 12", "by (simp add: power_divide power_one_over[symmetric])"], ["", "lemma \"ZC.R' start \\<le> 0.007\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ZC.R' start \\<le> 7 / 10 ^ 3", "unfolding ZC.cost_from_start"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 10\\<^sup>2 *\n     (2 / 10 ^ 3 + (16 / 65024) ^ Suc 2 * 3600 +\n      2 / 10 ^ 3 * (16 / 65024) * (1 - (16 / 65024)\\<^sup>2) /\n      (1 - 16 / 65024)) +\n     (1 - 1 / 10\\<^sup>2) * (2 / 10 ^ 3 * real (Suc 2))) /\n    (1 - 1 / 10\\<^sup>2 + 1 / 10\\<^sup>2 * (16 / 65024) ^ Suc 2)\n    \\<le> 7 / 10 ^ 3", "by (simp add: power_divide power_one_over[symmetric])"], ["", "end"]]}