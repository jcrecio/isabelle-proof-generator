{"file_name": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path/GraphGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path", "problem_names": ["lemma gga_from_list_correct:\n    fixes \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\"\n    assumes \"graph_empty \\<alpha> invar e\"\n    assumes \"graph_add_node \\<alpha> invar a\"\n    assumes \"graph_add_edge \\<alpha> invar u\"\n    shows \"graph_from_list \\<alpha> invar (gga_from_list e a u)\"", "lemma gga_edges_list_it_impl:\n      shows \"graph_edges_it \\<alpha> invar gga_edges_list_it\"", "lemma gga_to_list_correct:\n      shows \"graph_to_list \\<alpha> invar gga_to_list\""], "translations": [["", "lemma gga_from_list_correct:\n    fixes \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\"\n    assumes \"graph_empty \\<alpha> invar e\"\n    assumes \"graph_add_node \\<alpha> invar a\"\n    assumes \"graph_add_edge \\<alpha> invar u\"\n    shows \"graph_from_list \\<alpha> invar (gga_from_list e a u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "interpret \n      graph_empty \\<alpha> invar e + \n      graph_add_node \\<alpha> invar a + \n      graph_add_edge \\<alpha> invar u"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_empty \\<alpha> invar e &&&\n    graph_add_node \\<alpha> invar a &&& graph_add_edge \\<alpha> invar u", "by fact+"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "fix nl el"], ["proof (state)\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "define g1 where \"g1 = foldl (\\<lambda>g v. a v g) (e ()) nl\""], ["proof (state)\nthis:\n  g1 = foldl (\\<lambda>g v. a v g) (e ()) nl\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "define g2 where \"g2 = foldl (\\<lambda>g (v,e,v'). u v e v' g) g1 el\""], ["proof (state)\nthis:\n  g2 = foldl (\\<lambda>g (v, e, v'). u v e v' g) g1 el\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "have \"invar g1 \\<and> \\<alpha> g1 = \\<lparr> nodes = set nl, edges = {} \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g1 \\<and> \\<alpha> g1 = \\<lparr>nodes = set nl, edges = {}\\<rparr>", "unfolding g1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (foldl (\\<lambda>g v. a v g) (e ()) nl) \\<and>\n    \\<alpha> (foldl (\\<lambda>g v. a v g) (e ()) nl) =\n    \\<lparr>nodes = set nl, edges = {}\\<rparr>", "by (induct nl rule: rev_induct)\n           (auto simp: empty_correct add_node_correct empty_def add_node_def)"], ["proof (state)\nthis:\n  invar g1 \\<and> \\<alpha> g1 = \\<lparr>nodes = set nl, edges = {}\\<rparr>\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "hence \"invar g2 \n        \\<and> \\<alpha> g2 = \\<lparr> nodes = set nl \\<union> fst`set el \\<union> snd`snd`set el,\n                    edges = set el \\<rparr>\""], ["proof (prove)\nusing this:\n  invar g1 \\<and> \\<alpha> g1 = \\<lparr>nodes = set nl, edges = {}\\<rparr>\n\ngoal (1 subgoal):\n 1. invar g2 \\<and>\n    \\<alpha> g2 =\n    \\<lparr>nodes =\n              set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n       edges = set el\\<rparr>", "unfolding g2_def"], ["proof (prove)\nusing this:\n  invar g1 \\<and> \\<alpha> g1 = \\<lparr>nodes = set nl, edges = {}\\<rparr>\n\ngoal (1 subgoal):\n 1. invar (foldl (\\<lambda>g (v, e, v'). u v e v' g) g1 el) \\<and>\n    \\<alpha> (foldl (\\<lambda>g (v, e, v'). u v e v' g) g1 el) =\n    \\<lparr>nodes =\n              set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n       edges = set el\\<rparr>", "by (induct el rule: rev_induct) (auto simp: add_edge_correct add_edge_def)"], ["proof (state)\nthis:\n  invar g2 \\<and>\n  \\<alpha> g2 =\n  \\<lparr>nodes = set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n     edges = set el\\<rparr>\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "hence \"invar g2 \\<and> adjl_\\<alpha> (nl,el) = \\<alpha> g2\""], ["proof (prove)\nusing this:\n  invar g2 \\<and>\n  \\<alpha> g2 =\n  \\<lparr>nodes = set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n     edges = set el\\<rparr>\n\ngoal (1 subgoal):\n 1. invar g2 \\<and> adjl_\\<alpha> (nl, el) = \\<alpha> g2", "unfolding adjl_\\<alpha>_def"], ["proof (prove)\nusing this:\n  invar g2 \\<and>\n  \\<alpha> g2 =\n  \\<lparr>nodes = set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n     edges = set el\\<rparr>\n\ngoal (1 subgoal):\n 1. invar g2 \\<and>\n    (let (nl, el) = (nl, el)\n     in \\<lparr>nodes =\n                  set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n           edges = set el\\<rparr>) =\n    \\<alpha> g2", "by auto"], ["proof (state)\nthis:\n  invar g2 \\<and> adjl_\\<alpha> (nl, el) = \\<alpha> g2\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "}"], ["proof (state)\nthis:\n  invar\n   (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n     (foldl (\\<lambda>g v. a v g) (e ()) ?nl2) ?el2) \\<and>\n  adjl_\\<alpha> (?nl2, ?el2) =\n  \\<alpha>\n   (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n     (foldl (\\<lambda>g v. a v g) (e ()) ?nl2) ?el2)\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar\n   (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n     (foldl (\\<lambda>g v. a v g) (e ()) ?nl2) ?el2) \\<and>\n  adjl_\\<alpha> (?nl2, ?el2) =\n  \\<alpha>\n   (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n     (foldl (\\<lambda>g v. a v g) (e ()) ?nl2) ?el2)\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar (gga_from_list e a u)", "unfolding gga_from_list_def [abs_def]"], ["proof (prove)\nusing this:\n  invar\n   (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n     (foldl (\\<lambda>g v. a v g) (e ()) ?nl2) ?el2) \\<and>\n  adjl_\\<alpha> (?nl2, ?el2) =\n  \\<alpha>\n   (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n     (foldl (\\<lambda>g v. a v g) (e ()) ?nl2) ?el2)\n\ngoal (1 subgoal):\n 1. graph_from_list \\<alpha> invar\n     (\\<lambda>l.\n         let (nl, el) = l; g1 = foldl (\\<lambda>g v. a v g) (e ()) nl\n         in foldl (\\<lambda>g (v, e, v'). u v e v' g) g1 el)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       (\\<And>nl el.\n           invar\n            (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n              (foldl (\\<lambda>g v. a v g) (e ()) nl) el) \\<and>\n           adjl_\\<alpha> (nl, el) =\n           \\<alpha>\n            (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n              (foldl (\\<lambda>g v. a v g) (e ()) nl) el)) \\<Longrightarrow>\n       invar\n        (let (nl, el) = l; g1 = foldl (\\<lambda>g v. a v g) (e ()) nl\n         in foldl (\\<lambda>g (v, e, v'). u v e v' g) g1 el)\n 2. \\<And>l.\n       (\\<And>nl el.\n           invar\n            (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n              (foldl (\\<lambda>g v. a v g) (e ()) nl) el) \\<and>\n           adjl_\\<alpha> (nl, el) =\n           \\<alpha>\n            (foldl (\\<lambda>g (v, e, v'). u v e v' g)\n              (foldl (\\<lambda>g v. a v g) (e ()) nl) el)) \\<Longrightarrow>\n       \\<alpha>\n        (let (nl, el) = l; g1 = foldl (\\<lambda>g v. a v g) (e ()) nl\n         in foldl (\\<lambda>g (v, e, v'). u v e v' g) g1 el) =\n       adjl_\\<alpha> l", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  graph_from_list \\<alpha> invar (gga_from_list e a u)\n\ngoal:\nNo subgoals!", "qed"], ["", "term map_iterator_product"], ["", "locale gga_edges_it_defs =\n    graph_nodes_it_defs nodes_list_it +\n    graph_succ_it_defs succ_list_it\n    for nodes_list_it :: \"('V,'W,'V list,'G) graph_nodes_it\"\n    and succ_list_it :: \"('V,'W,('W\\<times>'V) list,'G) graph_succ_it\"\n  begin"], ["", "definition gga_edges_list_it ::\n      \"('V,'W,('V\\<times>'W\\<times>'V) list,'G) graph_edges_it\"\n      where \"gga_edges_list_it G \\<equiv> set_iterator_product \n        (nodes_it G) (succ_it G)\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term gga_edges_list_it}\\<close>"], ["", "end"], ["", "setup \\<open>\n    (Record_Intf.add_unf_thms_global @{thms \n      gga_edges_it_defs.gga_edges_list_it_def[abs_def]\n    })\n\\<close>"], ["", "locale gga_edges_it = gga_edges_it_defs nodes_list_it succ_list_it \n    + graph \\<alpha> invar\n    + graph_nodes_it \\<alpha> invar nodes_list_it\n    + graph_succ_it \\<alpha> invar succ_list_it\n    for \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\" \n    and invar \n    and nodes_list_it :: \"('V,'W,'V list,'G) graph_nodes_it\"\n    and succ_list_it :: \"('V,'W,('W\\<times>'V) list,'G) graph_succ_it\"  \n  begin"], ["", "lemma gga_edges_list_it_impl:\n      shows \"graph_edges_it \\<alpha> invar gga_edges_list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_edges_it \\<alpha> invar gga_edges_list_it", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow>\n       set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow>\n       set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "assume INV: \"invar g\""], ["proof (state)\nthis:\n  invar g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow>\n       set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "from set_iterator_product_correct[OF \n        nodes_it_correct[OF INV] succ_it_correct[OF INV]]"], ["proof (chain)\npicking this:\n  set_iterator\n   (set_iterator_product (nodes_it g) (\\<lambda>a. succ_it g (?v1 a)))\n   (SIGMA a:nodes (\\<alpha> g). succ (\\<alpha> g) (?v1 a))", "have \"set_iterator (set_iterator_product (nodes_it g) (\\<lambda>v. succ_it g v))\n        (SIGMA v:nodes (\\<alpha> g). succ (\\<alpha> g) v)\n        \""], ["proof (prove)\nusing this:\n  set_iterator\n   (set_iterator_product (nodes_it g) (\\<lambda>a. succ_it g (?v1 a)))\n   (SIGMA a:nodes (\\<alpha> g). succ (\\<alpha> g) (?v1 a))\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n     (Sigma (nodes (\\<alpha> g)) (succ (\\<alpha> g)))", "."], ["proof (state)\nthis:\n  set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n   (Sigma (nodes (\\<alpha> g)) (succ (\\<alpha> g)))\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow>\n       set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "also"], ["proof (state)\nthis:\n  set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n   (Sigma (nodes (\\<alpha> g)) (succ (\\<alpha> g)))\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow>\n       set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "have \"(SIGMA v:nodes (\\<alpha> g). succ (\\<alpha> g) v) = edges (\\<alpha> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma (nodes (\\<alpha> g)) (succ (\\<alpha> g)) = edges (\\<alpha> g)", "unfolding succ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SIGMA v:nodes (\\<alpha> g).\n        {(w, v'). (v, w, v') \\<in> edges (\\<alpha> g)}) =\n    edges (\\<alpha> g)", "by (auto dest: valid_graph.E_validD[OF valid[OF INV]])"], ["proof (state)\nthis:\n  Sigma (nodes (\\<alpha> g)) (succ (\\<alpha> g)) = edges (\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow>\n       set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "finally"], ["proof (chain)\npicking this:\n  set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n   (edges (\\<alpha> g))", "show \"set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))\""], ["proof (prove)\nusing this:\n  set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n   (edges (\\<alpha> g))\n\ngoal (1 subgoal):\n 1. set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))", "unfolding gga_edges_list_it_def"], ["proof (prove)\nusing this:\n  set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n   (edges (\\<alpha> g))\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product (nodes_it g) (succ_it g))\n     (edges (\\<alpha> g))", "."], ["proof (state)\nthis:\n  set_iterator (gga_edges_list_it g) (edges (\\<alpha> g))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale gga_to_list_defs_loc = \n    graph_nodes_it_defs nodes_list_it\n    + graph_edges_it_defs edges_list_it\n    for nodes_list_it :: \"('V,'W,'V list,'G) graph_nodes_it\"\n    and edges_list_it :: \"('V,'W,('V\\<times>'W\\<times>'V) list,'G) graph_edges_it\"  \n  begin"], ["", "definition gga_to_list :: \n      \"('V,'W,'G) graph_to_list\"\n      where \n      \"gga_to_list g \\<equiv> \n        (nodes_it g (\\<lambda>_. True) (#) [], edges_it g (\\<lambda>_. True) (#) [])\n      \""], ["", "end"], ["", "locale gga_to_list_loc = gga_to_list_defs_loc nodes_list_it edges_list_it +\n    graph \\<alpha> invar \n    + graph_nodes_it \\<alpha> invar nodes_list_it\n    + graph_edges_it \\<alpha> invar edges_list_it\n    for \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\" and invar\n    and nodes_list_it :: \"('V,'W,'V list,'G) graph_nodes_it\"\n    and edges_list_it :: \"('V,'W,('V\\<times>'W\\<times>'V) list,'G) graph_edges_it\"  \n  begin"], ["", "lemma gga_to_list_correct:\n      shows \"graph_to_list \\<alpha> invar gga_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_to_list \\<alpha> invar gga_to_list", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "assume [simp, intro!]: \"invar g\""], ["proof (state)\nthis:\n  invar g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "then"], ["proof (chain)\npicking this:\n  invar g", "interpret valid_graph \"\\<alpha> g\""], ["proof (prove)\nusing this:\n  invar g\n\ngoal (1 subgoal):\n 1. valid_graph (\\<alpha> g)", "by (rule valid)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "have \"set (nodes_it g (\\<lambda>_. True) (#) []) = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (nodes_it g (\\<lambda>_. True) (#) []) = V", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. set \\<sigma> = V - it\" \n          in set_iterator_rule_P[OF nodes_it_correct])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar g\n 2. set [] = V - V\n 3. \\<And>S \\<sigma> x.\n       \\<lbrakk>True; x \\<in> S; set \\<sigma> = V - S;\n        S \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> set (x # \\<sigma>) = V - (S - {x})\n 4. \\<And>\\<sigma>. set \\<sigma> = V - {} \\<Longrightarrow> set \\<sigma> = V\n 5. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> V; S \\<noteq> {}; \\<not> True;\n        set \\<sigma> = V - S\\<rbrakk>\n       \\<Longrightarrow> set \\<sigma> = V", "by auto"], ["proof (state)\nthis:\n  set (nodes_it g (\\<lambda>_. True) (#) []) = V\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "moreover"], ["proof (state)\nthis:\n  set (nodes_it g (\\<lambda>_. True) (#) []) = V\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "have \"set (edges_it g (\\<lambda>_. True) (#) []) = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (edges_it g (\\<lambda>_. True) (#) []) = E", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. set \\<sigma> = E - it\" \n          in set_iterator_rule_P[OF edges_it_correct])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar g\n 2. set [] = E - E\n 3. \\<And>S \\<sigma> x.\n       \\<lbrakk>True; x \\<in> S; set \\<sigma> = E - S;\n        S \\<subseteq> E\\<rbrakk>\n       \\<Longrightarrow> set (x # \\<sigma>) = E - (S - {x})\n 4. \\<And>\\<sigma>. set \\<sigma> = E - {} \\<Longrightarrow> set \\<sigma> = E\n 5. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> E; S \\<noteq> {}; \\<not> True;\n        set \\<sigma> = E - S\\<rbrakk>\n       \\<Longrightarrow> set \\<sigma> = E", "by auto"], ["proof (state)\nthis:\n  set (edges_it g (\\<lambda>_. True) (#) []) = E\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       invar g \\<Longrightarrow> adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "ultimately"], ["proof (chain)\npicking this:\n  set (nodes_it g (\\<lambda>_. True) (#) []) = V\n  set (edges_it g (\\<lambda>_. True) (#) []) = E", "show \"adjl_\\<alpha> (gga_to_list g) = \\<alpha> g\""], ["proof (prove)\nusing this:\n  set (nodes_it g (\\<lambda>_. True) (#) []) = V\n  set (edges_it g (\\<lambda>_. True) (#) []) = E\n\ngoal (1 subgoal):\n 1. adjl_\\<alpha> (gga_to_list g) = \\<alpha> g", "unfolding adjl_\\<alpha>_def gga_to_list_def"], ["proof (prove)\nusing this:\n  set (nodes_it g (\\<lambda>_. True) (#) []) = V\n  set (edges_it g (\\<lambda>_. True) (#) []) = E\n\ngoal (1 subgoal):\n 1. (let (nl, el) =\n           (nodes_it g (\\<lambda>_. True) (#) [],\n            edges_it g (\\<lambda>_. True) (#) [])\n     in \\<lparr>nodes =\n                  set nl \\<union> fst ` set el \\<union> snd ` snd ` set el,\n           edges = set el\\<rparr>) =\n    \\<alpha> g", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (nodes_it g (\\<lambda>_. True) (#) []) = V;\n     set (edges_it g (\\<lambda>_. True) (#) []) = E\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes =\n                                V \\<union> fst ` E \\<union> snd ` snd ` E,\n                         edges = E\\<rparr> =\n                      \\<alpha> g", "apply (rule graph.equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set (nodes_it g (\\<lambda>_. True) (#) []) = V;\n     set (edges_it g (\\<lambda>_. True) (#) []) = E\\<rbrakk>\n    \\<Longrightarrow> nodes\n                       \\<lparr>nodes =\n                                 V \\<union> fst ` E \\<union> snd ` snd ` E,\n                          edges = E\\<rparr> =\n                      V\n 2. \\<lbrakk>set (nodes_it g (\\<lambda>_. True) (#) []) = V;\n     set (edges_it g (\\<lambda>_. True) (#) []) = E\\<rbrakk>\n    \\<Longrightarrow> edges\n                       \\<lparr>nodes =\n                                 V \\<union> fst ` E \\<union> snd ` snd ` E,\n                          edges = E\\<rparr> =\n                      E\n 3. \\<lbrakk>set (nodes_it g (\\<lambda>_. True) (#) []) = V;\n     set (edges_it g (\\<lambda>_. True) (#) []) = E\\<rbrakk>\n    \\<Longrightarrow> graph.more\n                       \\<lparr>nodes =\n                                 V \\<union> fst ` E \\<union> snd ` snd ` E,\n                          edges = E\\<rparr> =\n                      graph.more (\\<alpha> g)", "apply (auto intro: E_validD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  adjl_\\<alpha> (gga_to_list g) = \\<alpha> g\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}