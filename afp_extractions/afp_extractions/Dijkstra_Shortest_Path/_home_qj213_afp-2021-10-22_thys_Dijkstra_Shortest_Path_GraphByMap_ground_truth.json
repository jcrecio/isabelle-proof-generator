{"file_name": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path/GraphByMap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path", "problem_names": ["lemma map_Sigma_alt: \"map_Sigma M1 F2 = Sigma (dom M1) (\\<lambda>x.\n  F2 (the (M1 x)))\"", "lemma ranE: \n  assumes \"v\\<in>ran m\"\n  obtains k where \"m k = Some v\"", "lemma option_bind_alt:\n  \"Option.bind x f = (case x of None \\<Rightarrow> None | Some v \\<Rightarrow> f v)\"", "lemma gbm_nodes_list_it_unf:\n    \"it_to_it (gbm_nodes_list_it g) \n    \\<equiv> map_iterator_dom (it_to_it (m1.list_it g))\"", "lemma gbm_edges_list_it_unf:\n    \"it_to_it (gbm_edges_list_it g) \n    \\<equiv> set_iterator_image \n      (\\<lambda>((v1,m1),(v2,m2),w). (v1,w,v2)) \n      (set_iterator_product (it_to_it (m1.list_it g)) \n        (\\<lambda>(v,m2). set_iterator_product \n          (it_to_it (m2.list_it m2)) (\\<lambda>(w,s3). (it_to_it (s3.list_it s3)))))\n    \"", "lemma gbm_succ_list_it_unf:\n  \"it_to_it (gbm_succ_list_it g v) \\<equiv> \n    case m1.lookup v g of\n      None \\<Rightarrow> set_iterator_emp |\n      Some m2 \\<Rightarrow> \n        set_iterator_image (\\<lambda>((v',m2),w). (w,v')) \n          (set_iterator_product (it_to_it (m2.list_it m2)) \n            (\\<lambda>(v',s). (it_to_it (s3.list_it s))))\n      \"", "lemma gbm_invar_split: \n    assumes \"gbm_invar g\"\n    shows\n    \"m1.invar g\"\n    \"\\<And>v m2. m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.invar m2\"\n    \"\\<And>v m2 v' s3. m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.\\<alpha> m2 v' = Some s3 \\<Longrightarrow> s3.invar s3\"\n    \"valid_graph (gbm_\\<alpha> g)\"", "lemma gbm_empty_impl: \n    \"graph_empty gbm_\\<alpha> gbm_invar gbm_empty\"", "lemma gbm_add_node_impl:\n    \"graph_add_node gbm_\\<alpha> gbm_invar gbm_add_node\"", "lemma gbm_delete_node_impl:\n    \"graph_delete_node gbm_\\<alpha> gbm_invar gbm_delete_node\"", "lemma gbm_add_edge_impl:\n    \"graph_add_edge gbm_\\<alpha> gbm_invar gbm_add_edge\"", "lemma gbm_delete_edge_impl:\n    \"graph_delete_edge gbm_\\<alpha> gbm_invar gbm_delete_edge\"", "lemma gbm_nodes_list_it_impl:\n    shows \"graph_nodes_it gbm_\\<alpha> gbm_invar gbm_nodes_list_it\"", "lemma gbm_edges_list_it_impl:\n    shows \"graph_edges_it gbm_\\<alpha> gbm_invar gbm_edges_list_it\"", "lemma gbm_succ_list_it_impl:\n    shows \"graph_succ_it gbm_\\<alpha> gbm_invar gbm_succ_list_it\"", "lemma gbm_from_list_impl:\n    shows \"graph_from_list gbm_\\<alpha> gbm_invar gbm_from_list\"", "lemma gbm_to_list_impl: \"graph_to_list gbm_\\<alpha> gbm_invar gga_to_list\"", "lemma gbm_ops_impl: \"StdGraph gbm_ops\""], "translations": [["", "lemma map_Sigma_alt: \"map_Sigma M1 F2 = Sigma (dom M1) (\\<lambda>x.\n  F2 (the (M1 x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_Sigma M1 F2 = (SIGMA x:dom M1. F2 (the (M1 x)))", "unfolding map_Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). \\<exists>v. M1 x = Some v \\<and> y \\<in> F2 v} =\n    (SIGMA x:dom M1. F2 (the (M1 x)))", "by auto"], ["", "(* TODO: Move to Misc *)"], ["", "lemma ranE: \n  assumes \"v\\<in>ran m\"\n  obtains k where \"m k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. m k = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> ran m\n\ngoal (1 subgoal):\n 1. (\\<And>k. m k = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ran_restrictD restrict_map_self)"], ["", "lemma option_bind_alt:\n  \"Option.bind x f = (case x of None \\<Rightarrow> None | Some v \\<Rightarrow> f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<bind> f =\n    (case x of None \\<Rightarrow> None | Some v \\<Rightarrow> f v)", "by (auto split: option.split)"], ["", "locale GraphByMapDefs = \n  m1: StdMapDefs m1_ops +\n  m2: StdMapDefs m2_ops +\n  s3: StdSetDefs s3_ops\n  for m1_ops::\"('V,'m2,'m1,_) map_ops_scheme\"\n  and m2_ops::\"('V,'s3,'m2,_) map_ops_scheme\"\n  and s3_ops::\"('W,'s3,_) set_ops_scheme\"\n  and m1_mvif :: \"('V \\<Rightarrow> 'm2 \\<rightharpoonup> 'm2) \\<Rightarrow> 'm1 \\<Rightarrow> 'm1\"\nbegin"], ["", "definition gbm_\\<alpha> :: \"('V,'W,'m1) graph_\\<alpha>\" where\n    \"gbm_\\<alpha> m1 \\<equiv>\n    \\<lparr> nodes = dom (m1.\\<alpha> m1),\n      edges = {(v,w,v'). \n        \\<exists>m2 s3. m1.\\<alpha> m1 v = Some m2 \n          \\<and> m2.\\<alpha> m2 v' = Some s3\n          \\<and> w\\<in>s3.\\<alpha> s3\n      }\n    \\<rparr>\""], ["", "definition \"gbm_invar m1 \\<equiv>\n    m1.invar m1 \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> m1). m2.invar m2 \\<and>\n      (\\<forall>s3\\<in>ran (m2.\\<alpha> m2). s3.invar s3)\n    ) \\<and> valid_graph (gbm_\\<alpha> m1)\""], ["", "definition gbm_empty :: \"('V,'W,'m1) graph_empty\" where \n    \"gbm_empty \\<equiv> m1.empty\""], ["", "definition gbm_add_node :: \"('V,'W,'m1) graph_add_node\" where\n    \"gbm_add_node v g \\<equiv> case m1.lookup v g of\n    None \\<Rightarrow> m1.update v (m2.empty ()) g |\n    Some _ \\<Rightarrow> g\""], ["", "definition gbm_delete_node :: \"('V,'W,'m1) graph_delete_node\" where\n    \"gbm_delete_node v g \\<equiv> let g=m1.delete v g in\n    m1_mvif (\\<lambda>_ m2. Some (m2.delete v m2)) g\""], ["", "definition gbm_add_edge :: \"('V,'W,'m1) graph_add_edge\" where\n    \"gbm_add_edge v e v' g \\<equiv> \n    let g = (case m1.lookup v' g of \n      None \\<Rightarrow> m1.update v' (m2.empty ()) g | Some _ \\<Rightarrow> g\n    ) in\n    case m1.lookup v g of \n      None \\<Rightarrow> (m1.update v (m2.sng v' (s3.sng e)) g) |\n      Some m2 \\<Rightarrow> (case m2.lookup v' m2 of\n        None \\<Rightarrow> m1.update v (m2.update v' (s3.sng e) m2) g |\n        Some s3 \\<Rightarrow> m1.update v (m2.update v' (s3.ins e s3) m2) g)\n    \""], ["", "definition gbm_delete_edge :: \"('V,'W,'m1) graph_delete_edge\" where\n    \"gbm_delete_edge v e v' g \\<equiv>\n    case m1.lookup v g of\n      None \\<Rightarrow> g |\n      Some m2 \\<Rightarrow> (\n        case m2.lookup v' m2 of\n          None \\<Rightarrow> g |\n          Some s3 \\<Rightarrow> m1.update v (m2.update v' (s3.delete e s3) m2) g\n      )\n    \""], ["", "definition gbm_nodes_list_it \n    :: \"('V,'W,'V list,'m1) graph_nodes_it\"\n    where\n    \"gbm_nodes_list_it g \\<equiv> map_iterator_dom (m1.iteratei g)\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term gbm_nodes_list_it}\\<close>"], ["", "definition gbm_edges_list_it \n    :: \"('V,'W,('V\\<times>'W\\<times>'V) list,'m1) graph_edges_it\"\n    where\n    \"gbm_edges_list_it g \\<equiv> set_iterator_image \n      (\\<lambda>((v1,m1),(v2,m2),w). (v1,w,v2)) \n      (set_iterator_product (m1.iteratei g) \n        (\\<lambda>(v,m2). set_iterator_product \n          (m2.iteratei m2) (\\<lambda>(w,s3). s3.iteratei s3)))\n    \""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term gbm_edges_list_it}\\<close>"], ["", "definition gbm_succ_list_it ::\n    \"('V,'W,('W\\<times>'V) list,'m1) graph_succ_it\"\n    where\n  \"gbm_succ_list_it g v \\<equiv> case m1.lookup v g of\n    None \\<Rightarrow> set_iterator_emp |\n    Some m2 \\<Rightarrow> \n      set_iterator_image (\\<lambda>((v',m2),w). (w,v')) \n        (set_iterator_product (m2.iteratei m2) (\\<lambda>(v',s). s3.iteratei s))\n    \""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term gbm_succ_list_it}\\<close>"], ["", "definition \n    \"gbm_from_list \\<equiv> gga_from_list gbm_empty gbm_add_node gbm_add_edge\""], ["", "lemma gbm_nodes_list_it_unf:\n    \"it_to_it (gbm_nodes_list_it g) \n    \\<equiv> map_iterator_dom (it_to_it (m1.list_it g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (gbm_nodes_list_it g) \\<equiv>\n    map_iterator_dom (it_to_it (m1.list_it g))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (gbm_nodes_list_it g) =\n    map_iterator_dom (it_to_it (m1.list_it g))", "apply (rule it_to_it_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (gbm_nodes_list_it g)\n     (map_iterator_dom (it_to_it (m1.list_it g)))", "unfolding gbm_nodes_list_it_def m1.iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (map_iterator_dom (it_to_it (m1.list_it g)))\n     (map_iterator_dom (it_to_it (m1.list_it g)))", "by (intro icf_proper_iteratorI)"], ["", "lemma gbm_edges_list_it_unf:\n    \"it_to_it (gbm_edges_list_it g) \n    \\<equiv> set_iterator_image \n      (\\<lambda>((v1,m1),(v2,m2),w). (v1,w,v2)) \n      (set_iterator_product (it_to_it (m1.list_it g)) \n        (\\<lambda>(v,m2). set_iterator_product \n          (it_to_it (m2.list_it m2)) (\\<lambda>(w,s3). (it_to_it (s3.list_it s3)))))\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (gbm_edges_list_it g) \\<equiv>\n    set_iterator_image (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (set_iterator_product (it_to_it (m1.list_it g))\n       (\\<lambda>(v, m2).\n           set_iterator_product (it_to_it (m2.list_it m2))\n            (\\<lambda>(w, s3). it_to_it (s3.list_it s3))))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (gbm_edges_list_it g) =\n    set_iterator_image (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (set_iterator_product (it_to_it (m1.list_it g))\n       (\\<lambda>(v, m2).\n           set_iterator_product (it_to_it (m2.list_it m2))\n            (\\<lambda>(w, s3). it_to_it (s3.list_it s3))))", "apply (rule it_to_it_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (gbm_edges_list_it g)\n     (set_iterator_image (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n       (set_iterator_product (it_to_it (m1.list_it g))\n         (\\<lambda>(v, m2).\n             set_iterator_product (it_to_it (m2.list_it m2))\n              (\\<lambda>(w, s3). it_to_it (s3.list_it s3)))))", "unfolding gbm_edges_list_it_def \n      m1.iteratei_def m2.iteratei_def s3.iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_image (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n       (set_iterator_product (it_to_it (m1.list_it g))\n         (\\<lambda>(v, m2).\n             set_iterator_product (it_to_it (m2.list_it m2))\n              (\\<lambda>(w, s3). it_to_it (s3.list_it s3)))))\n     (set_iterator_image (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n       (set_iterator_product (it_to_it (m1.list_it g))\n         (\\<lambda>(v, m2).\n             set_iterator_product (it_to_it (m2.list_it m2))\n              (\\<lambda>(w, s3). it_to_it (s3.list_it s3)))))", "apply (intro icf_proper_iteratorI allI impI, (simp split: prod.split)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gbm_succ_list_it_unf:\n  \"it_to_it (gbm_succ_list_it g v) \\<equiv> \n    case m1.lookup v g of\n      None \\<Rightarrow> set_iterator_emp |\n      Some m2 \\<Rightarrow> \n        set_iterator_image (\\<lambda>((v',m2),w). (w,v')) \n          (set_iterator_product (it_to_it (m2.list_it m2)) \n            (\\<lambda>(v',s). (it_to_it (s3.list_it s))))\n      \""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (gbm_succ_list_it g v) \\<equiv>\n    case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n    | Some m2 \\<Rightarrow>\n        set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n         (set_iterator_product (it_to_it (m2.list_it m2))\n           (\\<lambda>(v', s). it_to_it (s3.list_it s)))", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (gbm_succ_list_it g v) =\n    (case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n     | Some m2 \\<Rightarrow>\n         set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n          (set_iterator_product (it_to_it (m2.list_it m2))\n            (\\<lambda>(v', s). it_to_it (s3.list_it s))))", "apply (rule it_to_it_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (gbm_succ_list_it g v)\n     (case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n      | Some m2 \\<Rightarrow>\n          set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (it_to_it (m2.list_it m2))\n             (\\<lambda>(v', s). it_to_it (s3.list_it s))))", "unfolding gbm_succ_list_it_def \n      m2.iteratei_def s3.iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n      | Some m2 \\<Rightarrow>\n          set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (it_to_it (m2.list_it m2))\n             (\\<lambda>(v', s). it_to_it (s3.list_it s))))\n     (case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n      | Some m2 \\<Rightarrow>\n          set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (it_to_it (m2.list_it m2))\n             (\\<lambda>(v', s). it_to_it (s3.list_it s))))", "apply (simp split: prod.split option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1.lookup v g = None \\<longrightarrow>\n     proper_it set_iterator_emp set_iterator_emp) \\<and>\n    (\\<forall>x2.\n        m1.lookup v g = Some x2 \\<longrightarrow>\n        proper_it\n         (set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (it_to_it (m2.list_it x2))\n             (\\<lambda>(v', s). it_to_it (s3.list_it s))))\n         (set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (it_to_it (m2.list_it x2))\n             (\\<lambda>(v', s). it_to_it (s3.list_it s)))))", "apply (intro icf_proper_iteratorI allI impI conjI, \n      (simp split: prod.split option.split)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "sublocale GraphByMapDefs < graph_nodes_it_defs gbm_nodes_list_it"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale GraphByMapDefs < graph_edges_it_defs gbm_edges_list_it"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale GraphByMapDefs < graph_succ_it_defs gbm_succ_list_it"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale GraphByMapDefs \n  < gga_to_list_defs_loc gbm_nodes_list_it gbm_edges_list_it"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context GraphByMapDefs\nbegin"], ["", "definition [icf_rec_def]: \"gbm_ops \\<equiv> \\<lparr>\n    gop_\\<alpha> = gbm_\\<alpha>,\n    gop_invar = gbm_invar,\n    gop_empty = gbm_empty,\n    gop_add_node = gbm_add_node,\n    gop_delete_node = gbm_delete_node,\n    gop_add_edge = gbm_add_edge,\n    gop_delete_edge = gbm_delete_edge,\n    gop_from_list = gbm_from_list,\n    gop_to_list = gga_to_list,\n    gop_nodes_list_it = gbm_nodes_list_it,\n    gop_edges_list_it = gbm_edges_list_it,\n    gop_succ_list_it  = gbm_succ_list_it\n    \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term gbm_ops}\\<close>"], ["", "end"], ["", "locale GraphByMap = GraphByMapDefs m1_ops m2_ops s3_ops m1_mvif +\n  m1: StdMap m1_ops +\n  m2: StdMap m2_ops +\n  s3: StdSet s3_ops +\n  m1: map_value_image_filter m1.\\<alpha> m1.invar m1.\\<alpha> m1.invar m1_mvif\n  for m1_ops::\"('V,'m2,'m1,_) map_ops_scheme\"\n  and m2_ops::\"('V,'s3,'m2,_) map_ops_scheme\"\n  and s3_ops::\"('W,'s3,_) set_ops_scheme\"\n  and m1_mvif :: \"('V \\<Rightarrow> 'm2 \\<rightharpoonup> 'm2) \\<Rightarrow> 'm1 \\<Rightarrow> 'm1\"\nbegin"], ["", "lemma gbm_invar_split: \n    assumes \"gbm_invar g\"\n    shows\n    \"m1.invar g\"\n    \"\\<And>v m2. m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.invar m2\"\n    \"\\<And>v m2 v' s3. m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.\\<alpha> m2 v' = Some s3 \\<Longrightarrow> s3.invar s3\"\n    \"valid_graph (gbm_\\<alpha> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1.invar g &&&\n     (\\<And>v m2.\n         m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.invar m2)) &&&\n    (\\<And>v m2 v' s3.\n        \\<lbrakk>m1.\\<alpha> g v = Some m2;\n         m2.\\<alpha> m2 v' = Some s3\\<rbrakk>\n        \\<Longrightarrow> s3.invar s3) &&&\n    valid_graph (gbm_\\<alpha> g)", "using assms"], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. (m1.invar g &&&\n     (\\<And>v m2.\n         m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.invar m2)) &&&\n    (\\<And>v m2 v' s3.\n        \\<lbrakk>m1.\\<alpha> g v = Some m2;\n         m2.\\<alpha> m2 v' = Some s3\\<rbrakk>\n        \\<Longrightarrow> s3.invar s3) &&&\n    valid_graph (gbm_\\<alpha> g)", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. (m1.invar g &&&\n     (\\<And>v m2.\n         m1.\\<alpha> g v = Some m2 \\<Longrightarrow> m2.invar m2)) &&&\n    (\\<And>v m2 v' s3.\n        \\<lbrakk>m1.\\<alpha> g v = Some m2;\n         m2.\\<alpha> m2 v' = Some s3\\<rbrakk>\n        \\<Longrightarrow> s3.invar s3) &&&\n    valid_graph (gbm_\\<alpha> g)", "by (auto intro: ranI)"], ["", "end"], ["", "sublocale GraphByMap < graph gbm_\\<alpha> gbm_invar"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph gbm_\\<alpha> gbm_invar", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (nodes (gbm_\\<alpha> g))\n 2. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))\n 3. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       fst ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)\n 4. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       snd ` snd ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)", "fix g"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (nodes (gbm_\\<alpha> g))\n 2. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))\n 3. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       fst ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)\n 4. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       snd ` snd ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (4 subgoals):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (nodes (gbm_\\<alpha> g))\n 2. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))\n 3. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       fst ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)\n 4. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       snd ` snd ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)", "then"], ["proof (chain)\npicking this:\n  gbm_invar g", "interpret vg: valid_graph \"(gbm_\\<alpha> g)\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. valid_graph (gbm_\\<alpha> g)", "by (simp add: gbm_invar_def)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (nodes (gbm_\\<alpha> g))\n 2. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))\n 3. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       fst ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)\n 4. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       snd ` snd ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)", "from vg.E_valid"], ["proof (chain)\npicking this:\n  fst ` vg.E \\<subseteq> vg.V\n  snd ` snd ` vg.E \\<subseteq> vg.V", "show \"fst ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)\" and\n    \"snd ` snd ` edges (gbm_\\<alpha> g) \\<subseteq> nodes (gbm_\\<alpha> g)\""], ["proof (prove)\nusing this:\n  fst ` vg.E \\<subseteq> vg.V\n  snd ` snd ` vg.E \\<subseteq> vg.V\n\ngoal (1 subgoal):\n 1. fst ` vg.E \\<subseteq> vg.V &&& snd ` snd ` vg.E \\<subseteq> vg.V", "."], ["proof (state)\nthis:\n  fst ` vg.E \\<subseteq> vg.V\n  snd ` snd ` vg.E \\<subseteq> vg.V\n\ngoal (2 subgoals):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (nodes (gbm_\\<alpha> g))\n 2. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))", "from INV"], ["proof (chain)\npicking this:\n  gbm_invar g", "show \"finite (nodes (gbm_\\<alpha> g))\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. finite vg.V", "unfolding gbm_invar_def gbm_\\<alpha>_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph\n   \\<lparr>nodes = dom (m1.\\<alpha> g),\n      edges =\n        {(v, w, v').\n         \\<exists>m2 s3.\n            m1.\\<alpha> g v = Some m2 \\<and>\n            m2.\\<alpha> m2 v' = Some s3 \\<and>\n            w \\<in> s3.\\<alpha> s3}\\<rparr>\n\ngoal (1 subgoal):\n 1. finite\n     (nodes\n       \\<lparr>nodes = dom (m1.\\<alpha> g),\n          edges =\n            {(v, w, v').\n             \\<exists>m2 s3.\n                m1.\\<alpha> g v = Some m2 \\<and>\n                m2.\\<alpha> m2 v' = Some s3 \\<and>\n                w \\<in> s3.\\<alpha> s3}\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  finite vg.V\n\ngoal (1 subgoal):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))", "note [simp] = gbm_invar_split[OF INV]"], ["proof (state)\nthis:\n  m1.invar g\n  m1.\\<alpha> g ?v = Some ?m2.0 \\<Longrightarrow> m2.invar ?m2.0\n  \\<lbrakk>m1.\\<alpha> g ?v = Some ?m2.0;\n   m2.\\<alpha> ?m2.0 ?v' = Some ?s3.0\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s3.0\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>g. gbm_invar g \\<Longrightarrow> finite (edges (gbm_\\<alpha> g))", "show \"finite (edges (gbm_\\<alpha> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite vg.E", "apply (rule finite_imageD[where f=\"\\<lambda>(v,e,v'). (v,v',e)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ((\\<lambda>(v, e, v'). (v, v', e)) ` vg.E)\n 2. inj_on (\\<lambda>(v, e, v'). (v, v', e)) vg.E", "apply (rule finite_subset[where B=\n      \"map_Sigma (m1.\\<alpha> g) (\\<lambda>m2. map_Sigma (m2.\\<alpha> m2) (s3.\\<alpha>))\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>(v, e, v'). (v, v', e)) ` vg.E\n    \\<subseteq> map_Sigma (m1.\\<alpha> g)\n                 (\\<lambda>m2. map_Sigma (m2.\\<alpha> m2) s3.\\<alpha>)\n 2. finite\n     (map_Sigma (m1.\\<alpha> g)\n       (\\<lambda>m2. map_Sigma (m2.\\<alpha> m2) s3.\\<alpha>))\n 3. inj_on (\\<lambda>(v, e, v'). (v, v', e)) vg.E", "apply (auto simp add: map_Sigma_def gbm_\\<alpha>_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (map_Sigma (m1.\\<alpha> g)\n       (\\<lambda>m2. map_Sigma (m2.\\<alpha> m2) s3.\\<alpha>))\n 2. inj_on (\\<lambda>(v, e, v'). (v, v', e)) vg.E", "apply (unfold map_Sigma_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     (SIGMA x:dom (m1.\\<alpha> g).\n         SIGMA xa:dom (m2.\\<alpha> (the (m1.\\<alpha> g x))).\n            s3.\\<alpha> (the (m2.\\<alpha> (the (m1.\\<alpha> g x)) xa)))\n 2. inj_on (\\<lambda>(v, e, v'). (v, v', e)) vg.E", "apply (auto intro!: finite_SigmaI inj_onI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  finite vg.E\n\ngoal:\nNo subgoals!", "qed"], ["", "context GraphByMap\nbegin"], ["", "lemma gbm_empty_impl: \n    \"graph_empty gbm_\\<alpha> gbm_invar gbm_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_empty gbm_\\<alpha> gbm_invar gbm_empty", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. gbm_\\<alpha> (gbm_empty ()) = Graph.empty\n 2. gbm_invar (gbm_empty ())", "unfolding gbm_\\<alpha>_def gbm_invar_def gbm_empty_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lparr>nodes = dom (m1.\\<alpha> (m1.empty ())),\n       edges =\n         {(v, w, v').\n          \\<exists>m2 s3.\n             m1.\\<alpha> (m1.empty ()) v = Some m2 \\<and>\n             m2.\\<alpha> m2 v' = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    Graph.empty\n 2. m1.invar (m1.empty ()) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (m1.empty ())).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n    valid_graph\n     \\<lparr>nodes = dom (m1.\\<alpha> (m1.empty ())),\n        edges =\n          {(v, w, v').\n           \\<exists>m2 s3.\n              m1.\\<alpha> (m1.empty ()) v = Some m2 \\<and>\n              m2.\\<alpha> m2 v' = Some s3 \\<and>\n              w \\<in> s3.\\<alpha> s3}\\<rparr>", "apply (auto simp: m1.correct Graph.empty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph \\<lparr>nodes = {}, edges = {(v, w, v'). False}\\<rparr>", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fst ` edges \\<lparr>nodes = {}, edges = {(v, w, v'). False}\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = {}, edges = {(v, w, v'). False}\\<rparr>\n 2. snd `\n    snd ` edges \\<lparr>nodes = {}, edges = {(v, w, v'). False}\\<rparr>\n    \\<subseteq> nodes\n                 \\<lparr>nodes = {}, edges = {(v, w, v'). False}\\<rparr>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gbm_add_node_impl:\n    \"graph_add_node gbm_\\<alpha> gbm_invar gbm_add_node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_add_node gbm_\\<alpha> gbm_invar gbm_add_node", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)", "fix g v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)", "note [simp]= gbm_invar_split[OF INV]"], ["proof (state)\nthis:\n  m1.invar g\n  m1.\\<alpha> g ?v = Some ?m2.0 \\<Longrightarrow> m2.invar ?m2.0\n  \\<lbrakk>m1.\\<alpha> g ?v = Some ?m2.0;\n   m2.\\<alpha> ?m2.0 ?v' = Some ?s3.0\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s3.0\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)", "show \"gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)", "unfolding gbm_\\<alpha>_def gbm_add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (case m1.lookup v g of\n                     None \\<Rightarrow> m1.update v (m2.empty ()) g\n                     | Some x \\<Rightarrow> g)),\n       edges =\n         {(va, w, v').\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (case m1.lookup v g of\n               None \\<Rightarrow> m1.update v (m2.empty ()) g\n               | Some x \\<Rightarrow> g)\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v' = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    add_node v\n     \\<lparr>nodes = dom (m1.\\<alpha> g),\n        edges =\n          {(v, w, v').\n           \\<exists>m2 s3.\n              m1.\\<alpha> g v = Some m2 \\<and>\n              m2.\\<alpha> m2 v' = Some s3 \\<and>\n              w \\<in> s3.\\<alpha> s3}\\<rparr>", "by (auto simp: m1.correct m2.correct s3.correct add_node_def\n        split: option.split if_split_asm)"], ["proof (state)\nthis:\n  gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_node v g)", "thus \"gbm_invar (gbm_add_node v g)\""], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. gbm_invar (gbm_add_node v g)", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_add_node v g) = add_node v (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar (gbm_add_node v g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_add_node v g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n    valid_graph (gbm_\\<alpha> (gbm_add_node v g))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_add_node v g) =\n    add_node v (gbm_\\<alpha> g) \\<Longrightarrow>\n    m1.invar (gbm_add_node v g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_add_node v g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "unfolding gbm_\\<alpha>_def gbm_add_node_def add_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (case m1.lookup v g of\n                     None \\<Rightarrow> m1.update v (m2.empty ()) g\n                     | Some x \\<Rightarrow> g)),\n       edges =\n         {(va, w, v').\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (case m1.lookup v g of\n               None \\<Rightarrow> m1.update v (m2.empty ()) g\n               | Some x \\<Rightarrow> g)\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v' = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    \\<lparr>nodes =\n              insert v\n               (nodes\n                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                    edges =\n                      {(v, w, v').\n                       \\<exists>m2 s3.\n                          m1.\\<alpha> g v = Some m2 \\<and>\n                          m2.\\<alpha> m2 v' = Some s3 \\<and>\n                          w \\<in> s3.\\<alpha> s3}\\<rparr>),\n       edges =\n         edges\n          \\<lparr>nodes = dom (m1.\\<alpha> g),\n             edges =\n               {(v, w, v').\n                \\<exists>m2 s3.\n                   m1.\\<alpha> g v = Some m2 \\<and>\n                   m2.\\<alpha> m2 v' = Some s3 \\<and>\n                   w \\<in> s3.\\<alpha> s3}\\<rparr>\\<rparr> \\<Longrightarrow>\n    m1.invar\n     (case m1.lookup v g of None \\<Rightarrow> m1.update v (m2.empty ()) g\n      | Some x \\<Rightarrow> g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha>\n                           (case m1.lookup v g of\n                            None \\<Rightarrow> m1.update v (m2.empty ()) g\n                            | Some x \\<Rightarrow> g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "apply (auto simp: m1.correct m2.correct s3.correct add_node_def\n        split: option.split if_split_asm elim!: ranE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gbm_invar (gbm_add_node v g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_delete_node_impl:\n    \"graph_delete_node gbm_\\<alpha> gbm_invar gbm_delete_node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_delete_node gbm_\\<alpha> gbm_invar gbm_delete_node", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)", "fix g v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)", "note [simp]= gbm_invar_split[OF INV]"], ["proof (state)\nthis:\n  m1.invar g\n  m1.\\<alpha> g ?v = Some ?m2.0 \\<Longrightarrow> m2.invar ?m2.0\n  \\<lbrakk>m1.\\<alpha> g ?v = Some ?m2.0;\n   m2.\\<alpha> ?m2.0 ?v' = Some ?s3.0\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s3.0\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (2 subgoals):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_node v g)\n 2. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)", "show \"gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)", "unfolding gbm_\\<alpha>_def gbm_delete_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (Let (m1.delete v g)\n                      (m1_mvif (\\<lambda>_ m2. Some (m2.delete v m2))))),\n       edges =\n         {(va, w, v').\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (Let (m1.delete v g)\n                (m1_mvif (\\<lambda>_ m2. Some (m2.delete v m2))))\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v' = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    delete_node v\n     \\<lparr>nodes = dom (m1.\\<alpha> g),\n        edges =\n          {(v, w, v').\n           \\<exists>m2 s3.\n              m1.\\<alpha> g v = Some m2 \\<and>\n              m2.\\<alpha> m2 v' = Some s3 \\<and>\n              w \\<in> s3.\\<alpha> s3}\\<rparr>", "by (auto simp: restrict_map_def option_bind_alt\n        m1.correct m2.correct s3.correct m1.map_value_image_filter_correct\n        delete_node_def\n        split: option.split if_split_asm option.split_asm)"], ["proof (state)\nthis:\n  gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>g v. gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_node v g)", "thus \"gbm_invar (gbm_delete_node v g)\""], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. gbm_invar (gbm_delete_node v g)", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_delete_node v g) = delete_node v (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar (gbm_delete_node v g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_delete_node v g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n    valid_graph (gbm_\\<alpha> (gbm_delete_node v g))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_delete_node v g) =\n    delete_node v (gbm_\\<alpha> g) \\<Longrightarrow>\n    m1.invar (gbm_delete_node v g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_delete_node v g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "unfolding gbm_\\<alpha>_def gbm_delete_node_def delete_node_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (Let (m1.delete v g)\n                      (m1_mvif (\\<lambda>_ m2. Some (m2.delete v m2))))),\n       edges =\n         {(va, w, v').\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (Let (m1.delete v g)\n                (m1_mvif (\\<lambda>_ m2. Some (m2.delete v m2))))\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v' = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = dom (m1.\\<alpha> g),\n                  edges =\n                    {(v, w, v').\n                     \\<exists>m2 s3.\n                        m1.\\<alpha> g v = Some m2 \\<and>\n                        m2.\\<alpha> m2 v' = Some s3 \\<and>\n                        w \\<in> s3.\\<alpha> s3}\\<rparr> -\n              {v},\n       edges =\n         edges\n          \\<lparr>nodes = dom (m1.\\<alpha> g),\n             edges =\n               {(v, w, v').\n                \\<exists>m2 s3.\n                   m1.\\<alpha> g v = Some m2 \\<and>\n                   m2.\\<alpha> m2 v' = Some s3 \\<and>\n                   w \\<in> s3.\\<alpha> s3}\\<rparr> \\<inter>\n         (- {v}) \\<times> UNIV \\<times> - {v}\\<rparr> \\<Longrightarrow>\n    m1.invar\n     (Let (m1.delete v g)\n       (m1_mvif (\\<lambda>_ m2. Some (m2.delete v m2)))) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha>\n                           (Let (m1.delete v g)\n                             (m1_mvif\n                               (\\<lambda>_ m2. Some (m2.delete v m2))))).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "apply (auto simp: restrict_map_def option_bind_alt\n        m1.correct m2.correct s3.correct m1.map_value_image_filter_correct\n        split: option.split if_split_asm option.split_asm elim!: ranE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gbm_invar (gbm_delete_node v g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_add_edge_impl:\n    \"graph_add_edge gbm_\\<alpha> gbm_invar gbm_add_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_add_edge gbm_\\<alpha> gbm_invar gbm_add_edge", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_edge v e v' g) =\n       add_edge v e v' (gbm_\\<alpha> g)", "fix g v e v'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_edge v e v' g) =\n       add_edge v e v' (gbm_\\<alpha> g)", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_edge v e v' g) =\n       add_edge v e v' (gbm_\\<alpha> g)", "note [simp]= gbm_invar_split[OF INV]"], ["proof (state)\nthis:\n  m1.invar g\n  m1.\\<alpha> g ?v = Some ?m2.0 \\<Longrightarrow> m2.invar ?m2.0\n  \\<lbrakk>m1.\\<alpha> g ?v = Some ?m2.0;\n   m2.\\<alpha> ?m2.0 ?v' = Some ?s3.0\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s3.0\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_add_edge v e v' g) =\n       add_edge v e v' (gbm_\\<alpha> g)", "show \"gbm_\\<alpha> (gbm_add_edge v e v' g) = add_edge v e v' (gbm_\\<alpha> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_add_edge v e v' g) = add_edge v e v' (gbm_\\<alpha> g)", "unfolding gbm_\\<alpha>_def gbm_add_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (let g = case m1.lookup v' g of\n                             None \\<Rightarrow> m1.update v' (m2.empty ()) g\n                             | Some x \\<Rightarrow> g\n                     in case m1.lookup v g of\n                        None \\<Rightarrow>\n                          m1.update v (m2.sng v' (s3.sng e)) g\n                        | Some m2 \\<Rightarrow>\n                            case m2.lookup v' m2 of\n                            None \\<Rightarrow>\n                              m1.update v (m2.update v' (s3.sng e) m2) g\n                            | Some s3 \\<Rightarrow>\n                                m1.update v (m2.update v' (s3.ins e s3) m2)\n                                 g)),\n       edges =\n         {(va, w, v'a).\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (let g = case m1.lookup v' g of\n                       None \\<Rightarrow> m1.update v' (m2.empty ()) g\n                       | Some x \\<Rightarrow> g\n               in case m1.lookup v g of\n                  None \\<Rightarrow> m1.update v (m2.sng v' (s3.sng e)) g\n                  | Some m2 \\<Rightarrow>\n                      case m2.lookup v' m2 of\n                      None \\<Rightarrow>\n                        m1.update v (m2.update v' (s3.sng e) m2) g\n                      | Some s3 \\<Rightarrow>\n                          m1.update v (m2.update v' (s3.ins e s3) m2) g)\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v'a = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    add_edge v e v'\n     \\<lparr>nodes = dom (m1.\\<alpha> g),\n        edges =\n          {(v, w, v').\n           \\<exists>m2 s3.\n              m1.\\<alpha> g v = Some m2 \\<and>\n              m2.\\<alpha> m2 v' = Some s3 \\<and>\n              w \\<in> s3.\\<alpha> s3}\\<rparr>", "apply (auto simp: m1.correct m2.correct s3.correct \n        Let_def\n        split: option.split if_split_asm)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>v = v'; m1.\\<alpha> g v' = None\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                         edges =\n                           {(v, w, v'a).\n                            \\<exists>m2.\n                               (if v = v'\n                                then Some\n(m2.update v' (s3.sng e) (m2.empty ()))\n                                else m1.\\<alpha> g v) =\n                               Some m2 \\<and>\n                               (\\<exists>s3.\n                                   m2.\\<alpha> m2 v'a = Some s3 \\<and>\n                                   w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                      add_edge v' e v'\n                       \\<lparr>nodes = dom (m1.\\<alpha> g),\n                          edges =\n                            {(v, w, v').\n                             \\<exists>m2.\n                                m1.\\<alpha> g v = Some m2 \\<and>\n                                (\\<exists>s3.\n                                    m2.\\<alpha> m2 v' = Some s3 \\<and>\n                                    w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 2. \\<And>x2.\n       \\<lbrakk>v = v'; m2.\\<alpha> x2 v' = None;\n        m1.\\<alpha> g v' = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(v, w, v'a).\n                               \\<exists>m2.\n                                  (if v = v'\n                                   then Some (m2.update v' (s3.sng e) x2)\n                                   else m1.\\<alpha> g v) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v' e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 3. \\<And>x2 x2b.\n       \\<lbrakk>v = v'; m2.\\<alpha> x2 v' = Some x2b;\n        m1.\\<alpha> g v' = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(v, w, v'a).\n                               \\<exists>m2.\n                                  (if v = v'\n                                   then Some\n   (m2.update v' (s3.ins e x2b) x2)\n                                   else m1.\\<alpha> g v) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v' e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 4. \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n     m1.\\<alpha> g v = None\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes =\n                                insert v (insert v' (dom (m1.\\<alpha> g))),\n                         edges =\n                           {(va, w, v'a).\n                            \\<exists>m2.\n                               (if va = v then Some (m2.sng v' (s3.sng e))\n                                else m1.\\<alpha>\n(m1.update v' (m2.empty ()) g) va) =\n                               Some m2 \\<and>\n                               (\\<exists>s3.\n                                   m2.\\<alpha> m2 v'a = Some s3 \\<and>\n                                   w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                      add_edge v e v'\n                       \\<lparr>nodes = dom (m1.\\<alpha> g),\n                          edges =\n                            {(v, w, v').\n                             \\<exists>m2.\n                                m1.\\<alpha> g v = Some m2 \\<and>\n                                (\\<exists>s3.\n                                    m2.\\<alpha> m2 v' = Some s3 \\<and>\n                                    w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 5. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n        m2.\\<alpha> x2 v' = None; m1.\\<alpha> g v = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes =\n                                   insert v\n                                    (insert v' (dom (m1.\\<alpha> g))),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.update v' (s3.sng e) x2)\n                                   else (m1.\\<alpha> g(v' \\<mapsto>\n   m2.empty ()))\n   va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 6. \\<And>x2 x2a.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n        m2.\\<alpha> x2 v' = Some x2a; m1.\\<alpha> g v = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes =\n                                   insert v\n                                    (insert v' (dom (m1.\\<alpha> g))),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some\n   (m2.update v' (s3.ins e x2a) x2)\n                                   else (m1.\\<alpha> g(v' \\<mapsto>\n   m2.empty ()))\n   va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 7. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m1.\\<alpha> g v = None\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.sng v' (s3.sng e))\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 8. \\<And>x2 x2a.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m2.\\<alpha> x2a v' = None; m1.\\<alpha> g v = Some x2a\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.update v' (s3.sng e) x2a)\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>\n 9. \\<And>x2 x2a x2b.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m2.\\<alpha> x2a v' = Some x2b; m1.\\<alpha> g v = Some x2a\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some\n   (m2.update v' (s3.ins e x2b) x2a)\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         add_edge v e v'\n                          \\<lparr>nodes = dom (m1.\\<alpha> g),\n                             edges =\n                               {(v, w, v').\n                                \\<exists>m2.\n                                   m1.\\<alpha> g v = Some m2 \\<and>\n                                   (\\<exists>s3.\n m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>", "unfolding add_edge_def"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>v = v'; m1.\\<alpha> g v' = None\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                         edges =\n                           {(v, w, v'a).\n                            \\<exists>m2.\n                               (if v = v'\n                                then Some\n(m2.update v' (s3.sng e) (m2.empty ()))\n                                else m1.\\<alpha> g v) =\n                               Some m2 \\<and>\n                               (\\<exists>s3.\n                                   m2.\\<alpha> m2 v'a = Some s3 \\<and>\n                                   w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                      \\<lparr>nodes =\n                                {v', v'} \\<union>\n                                nodes\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                         edges =\n                           insert (v', e, v')\n                            (edges\n                              \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                 edges =\n                                   {(v, w, v').\n                                    \\<exists>m2.\n m1.\\<alpha> g v = Some m2 \\<and>\n (\\<exists>s3.\n     m2.\\<alpha> m2 v' = Some s3 \\<and>\n     w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 2. \\<And>x2.\n       \\<lbrakk>v = v'; m2.\\<alpha> x2 v' = None;\n        m1.\\<alpha> g v' = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(v, w, v'a).\n                               \\<exists>m2.\n                                  (if v = v'\n                                   then Some (m2.update v' (s3.sng e) x2)\n                                   else m1.\\<alpha> g v) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v', v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v', e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 3. \\<And>x2 x2b.\n       \\<lbrakk>v = v'; m2.\\<alpha> x2 v' = Some x2b;\n        m1.\\<alpha> g v' = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(v, w, v'a).\n                               \\<exists>m2.\n                                  (if v = v'\n                                   then Some\n   (m2.update v' (s3.ins e x2b) x2)\n                                   else m1.\\<alpha> g v) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v', v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v', e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 4. \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n     m1.\\<alpha> g v = None\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes =\n                                insert v (insert v' (dom (m1.\\<alpha> g))),\n                         edges =\n                           {(va, w, v'a).\n                            \\<exists>m2.\n                               (if va = v then Some (m2.sng v' (s3.sng e))\n                                else m1.\\<alpha>\n(m1.update v' (m2.empty ()) g) va) =\n                               Some m2 \\<and>\n                               (\\<exists>s3.\n                                   m2.\\<alpha> m2 v'a = Some s3 \\<and>\n                                   w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                      \\<lparr>nodes =\n                                {v, v'} \\<union>\n                                nodes\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                         edges =\n                           insert (v, e, v')\n                            (edges\n                              \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                 edges =\n                                   {(v, w, v').\n                                    \\<exists>m2.\n m1.\\<alpha> g v = Some m2 \\<and>\n (\\<exists>s3.\n     m2.\\<alpha> m2 v' = Some s3 \\<and>\n     w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 5. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n        m2.\\<alpha> x2 v' = None; m1.\\<alpha> g v = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes =\n                                   insert v\n                                    (insert v' (dom (m1.\\<alpha> g))),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.update v' (s3.sng e) x2)\n                                   else (m1.\\<alpha> g(v' \\<mapsto>\n   m2.empty ()))\n   va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 6. \\<And>x2 x2a.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n        m2.\\<alpha> x2 v' = Some x2a; m1.\\<alpha> g v = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes =\n                                   insert v\n                                    (insert v' (dom (m1.\\<alpha> g))),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some\n   (m2.update v' (s3.ins e x2a) x2)\n                                   else (m1.\\<alpha> g(v' \\<mapsto>\n   m2.empty ()))\n   va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 7. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m1.\\<alpha> g v = None\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.sng v' (s3.sng e))\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 8. \\<And>x2 x2a.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m2.\\<alpha> x2a v' = None; m1.\\<alpha> g v = Some x2a\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.update v' (s3.sng e) x2a)\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 9. \\<And>x2 x2a x2b.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m2.\\<alpha> x2a v' = Some x2b; m1.\\<alpha> g v = Some x2a\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some\n   (m2.update v' (s3.ins e x2b) x2a)\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>", "(* Strange: This is at the limit of auto's capabilities:\n        Iterated auto [] works., but auto on all goals seems not to\n        terminate. Using fastforce instead.\n        *)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>v = v'; m1.\\<alpha> g v' = None\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                         edges =\n                           {(v, w, v'a).\n                            \\<exists>m2.\n                               (if v = v'\n                                then Some\n(m2.update v' (s3.sng e) (m2.empty ()))\n                                else m1.\\<alpha> g v) =\n                               Some m2 \\<and>\n                               (\\<exists>s3.\n                                   m2.\\<alpha> m2 v'a = Some s3 \\<and>\n                                   w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                      \\<lparr>nodes =\n                                {v', v'} \\<union>\n                                nodes\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                         edges =\n                           insert (v', e, v')\n                            (edges\n                              \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                 edges =\n                                   {(v, w, v').\n                                    \\<exists>m2.\n m1.\\<alpha> g v = Some m2 \\<and>\n (\\<exists>s3.\n     m2.\\<alpha> m2 v' = Some s3 \\<and>\n     w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 2. \\<And>x2.\n       \\<lbrakk>v = v'; m2.\\<alpha> x2 v' = None;\n        m1.\\<alpha> g v' = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(v, w, v'a).\n                               \\<exists>m2.\n                                  (if v = v'\n                                   then Some (m2.update v' (s3.sng e) x2)\n                                   else m1.\\<alpha> g v) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v', v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v', e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 3. \\<And>x2 x2b.\n       \\<lbrakk>v = v'; m2.\\<alpha> x2 v' = Some x2b;\n        m1.\\<alpha> g v' = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v' (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(v, w, v'a).\n                               \\<exists>m2.\n                                  (if v = v'\n                                   then Some\n   (m2.update v' (s3.ins e x2b) x2)\n                                   else m1.\\<alpha> g v) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v', v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v', e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 4. \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n     m1.\\<alpha> g v = None\\<rbrakk>\n    \\<Longrightarrow> \\<lparr>nodes =\n                                insert v (insert v' (dom (m1.\\<alpha> g))),\n                         edges =\n                           {(va, w, v'a).\n                            \\<exists>m2.\n                               (if va = v then Some (m2.sng v' (s3.sng e))\n                                else m1.\\<alpha>\n(m1.update v' (m2.empty ()) g) va) =\n                               Some m2 \\<and>\n                               (\\<exists>s3.\n                                   m2.\\<alpha> m2 v'a = Some s3 \\<and>\n                                   w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                      \\<lparr>nodes =\n                                {v, v'} \\<union>\n                                nodes\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                         edges =\n                           insert (v, e, v')\n                            (edges\n                              \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                 edges =\n                                   {(v, w, v').\n                                    \\<exists>m2.\n m1.\\<alpha> g v = Some m2 \\<and>\n (\\<exists>s3.\n     m2.\\<alpha> m2 v' = Some s3 \\<and>\n     w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 5. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n        m2.\\<alpha> x2 v' = None; m1.\\<alpha> g v = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes =\n                                   insert v\n                                    (insert v' (dom (m1.\\<alpha> g))),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.update v' (s3.sng e) x2)\n                                   else (m1.\\<alpha> g(v' \\<mapsto>\n   m2.empty ()))\n   va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 6. \\<And>x2 x2a.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = None;\n        m2.\\<alpha> x2 v' = Some x2a; m1.\\<alpha> g v = Some x2\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes =\n                                   insert v\n                                    (insert v' (dom (m1.\\<alpha> g))),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some\n   (m2.update v' (s3.ins e x2a) x2)\n                                   else (m1.\\<alpha> g(v' \\<mapsto>\n   m2.empty ()))\n   va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 7. \\<And>x2.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m1.\\<alpha> g v = None\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.sng v' (s3.sng e))\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 8. \\<And>x2 x2a.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m2.\\<alpha> x2a v' = None; m1.\\<alpha> g v = Some x2a\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some (m2.update v' (s3.sng e) x2a)\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>\n 9. \\<And>x2 x2a x2b.\n       \\<lbrakk>v \\<noteq> v'; m1.\\<alpha> g v' = Some x2;\n        m2.\\<alpha> x2a v' = Some x2b; m1.\\<alpha> g v = Some x2a\\<rbrakk>\n       \\<Longrightarrow> \\<lparr>nodes = insert v (dom (m1.\\<alpha> g)),\n                            edges =\n                              {(va, w, v'a).\n                               \\<exists>m2.\n                                  (if va = v\n                                   then Some\n   (m2.update v' (s3.ins e x2b) x2a)\n                                   else m1.\\<alpha> g va) =\n                                  Some m2 \\<and>\n                                  (\\<exists>s3.\nm2.\\<alpha> m2 v'a = Some s3 \\<and> w \\<in> s3.\\<alpha> s3)}\\<rparr> =\n                         \\<lparr>nodes =\n                                   {v, v'} \\<union>\n                                   nodes\n                                    \\<lparr>nodes = dom (m1.\\<alpha> g),\n edges =\n   {(v, w, v').\n    \\<exists>m2.\n       m1.\\<alpha> g v = Some m2 \\<and>\n       (\\<exists>s3.\n           m2.\\<alpha> m2 v' = Some s3 \\<and>\n           w \\<in> s3.\\<alpha> s3)}\\<rparr>,\n                            edges =\n                              insert (v, e, v')\n                               (edges\n                                 \\<lparr>nodes = dom (m1.\\<alpha> g),\n                                    edges =\n{(v, w, v').\n \\<exists>m2.\n    m1.\\<alpha> g v = Some m2 \\<and>\n    (\\<exists>s3.\n        m2.\\<alpha> m2 v' = Some s3 \\<and>\n        w \\<in> s3.\\<alpha> s3)}\\<rparr>)\\<rparr>", "apply (fastforce split: if_split_asm\n        simp: m1.correct m2.correct s3.correct \n      )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gbm_\\<alpha> (gbm_add_edge v e v' g) = add_edge v e v' (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_add_edge v e v' g)", "thus \"gbm_invar (gbm_add_edge v e v' g)\""], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_add_edge v e v' g) = add_edge v e v' (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. gbm_invar (gbm_add_edge v e v' g)", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_add_edge v e v' g) = add_edge v e v' (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar (gbm_add_edge v e v' g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_add_edge v e v' g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n    valid_graph (gbm_\\<alpha> (gbm_add_edge v e v' g))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_add_edge v e v' g) =\n    add_edge v e v' (gbm_\\<alpha> g) \\<Longrightarrow>\n    m1.invar (gbm_add_edge v e v' g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_add_edge v e v' g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "unfolding gbm_\\<alpha>_def gbm_add_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (let g = case m1.lookup v' g of\n                             None \\<Rightarrow> m1.update v' (m2.empty ()) g\n                             | Some x \\<Rightarrow> g\n                     in case m1.lookup v g of\n                        None \\<Rightarrow>\n                          m1.update v (m2.sng v' (s3.sng e)) g\n                        | Some m2 \\<Rightarrow>\n                            case m2.lookup v' m2 of\n                            None \\<Rightarrow>\n                              m1.update v (m2.update v' (s3.sng e) m2) g\n                            | Some s3 \\<Rightarrow>\n                                m1.update v (m2.update v' (s3.ins e s3) m2)\n                                 g)),\n       edges =\n         {(va, w, v'a).\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (let g = case m1.lookup v' g of\n                       None \\<Rightarrow> m1.update v' (m2.empty ()) g\n                       | Some x \\<Rightarrow> g\n               in case m1.lookup v g of\n                  None \\<Rightarrow> m1.update v (m2.sng v' (s3.sng e)) g\n                  | Some m2 \\<Rightarrow>\n                      case m2.lookup v' m2 of\n                      None \\<Rightarrow>\n                        m1.update v (m2.update v' (s3.sng e) m2) g\n                      | Some s3 \\<Rightarrow>\n                          m1.update v (m2.update v' (s3.ins e s3) m2) g)\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v'a = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    add_edge v e v'\n     \\<lparr>nodes = dom (m1.\\<alpha> g),\n        edges =\n          {(v, w, v').\n           \\<exists>m2 s3.\n              m1.\\<alpha> g v = Some m2 \\<and>\n              m2.\\<alpha> m2 v' = Some s3 \\<and>\n              w \\<in> s3.\\<alpha> s3}\\<rparr> \\<Longrightarrow>\n    m1.invar\n     (let g = case m1.lookup v' g of\n              None \\<Rightarrow> m1.update v' (m2.empty ()) g\n              | Some x \\<Rightarrow> g\n      in case m1.lookup v g of\n         None \\<Rightarrow> m1.update v (m2.sng v' (s3.sng e)) g\n         | Some m2 \\<Rightarrow>\n             case m2.lookup v' m2 of\n             None \\<Rightarrow> m1.update v (m2.update v' (s3.sng e) m2) g\n             | Some s3 \\<Rightarrow>\n                 m1.update v (m2.update v' (s3.ins e s3) m2) g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha>\n                           (let g = case m1.lookup v' g of\n                                    None \\<Rightarrow>\nm1.update v' (m2.empty ()) g\n                                    | Some x \\<Rightarrow> g\n                            in case m1.lookup v g of\n                               None \\<Rightarrow>\n                                 m1.update v (m2.sng v' (s3.sng e)) g\n                               | Some m2 \\<Rightarrow>\n                                   case m2.lookup v' m2 of\n                                   None \\<Rightarrow>\n                                     m1.update v\n(m2.update v' (s3.sng e) m2) g\n                                   | Some s3 \\<Rightarrow>\n m1.update v (m2.update v' (s3.ins e s3) m2) g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "apply (force simp: m1.correct m2.correct s3.correct\n        Let_def\n        split: option.split if_split_asm elim!: ranE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gbm_invar (gbm_add_edge v e v' g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_delete_edge_impl:\n    \"graph_delete_edge gbm_\\<alpha> gbm_invar gbm_delete_edge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_delete_edge gbm_\\<alpha> gbm_invar gbm_delete_edge", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n       delete_edge v e v' (gbm_\\<alpha> g)", "fix g v e v'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n       delete_edge v e v' (gbm_\\<alpha> g)", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n       delete_edge v e v' (gbm_\\<alpha> g)", "note [simp]= gbm_invar_split[OF INV]"], ["proof (state)\nthis:\n  m1.invar g\n  m1.\\<alpha> g ?v = Some ?m2.0 \\<Longrightarrow> m2.invar ?m2.0\n  \\<lbrakk>m1.\\<alpha> g ?v = Some ?m2.0;\n   m2.\\<alpha> ?m2.0 ?v' = Some ?s3.0\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s3.0\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (2 subgoals):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_edge v e v' g)\n 2. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow>\n       gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n       delete_edge v e v' (gbm_\\<alpha> g)", "show \"gbm_\\<alpha> (gbm_delete_edge v e v' g) = delete_edge v e v' (gbm_\\<alpha> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n    delete_edge v e v' (gbm_\\<alpha> g)", "unfolding gbm_\\<alpha>_def gbm_delete_edge_def delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (case m1.lookup v g of None \\<Rightarrow> g\n                     | Some m2 \\<Rightarrow>\n                         case m2.lookup v' m2 of None \\<Rightarrow> g\n                         | Some s3 \\<Rightarrow>\n                             m1.update v (m2.update v' (s3.delete e s3) m2)\n                              g)),\n       edges =\n         {(va, w, v'a).\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (case m1.lookup v g of None \\<Rightarrow> g\n               | Some m2 \\<Rightarrow>\n                   case m2.lookup v' m2 of None \\<Rightarrow> g\n                   | Some s3 \\<Rightarrow>\n                       m1.update v (m2.update v' (s3.delete e s3) m2) g)\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v'a = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    \\<lparr>nodes =\n              nodes\n               \\<lparr>nodes = dom (m1.\\<alpha> g),\n                  edges =\n                    {(v, w, v').\n                     \\<exists>m2 s3.\n                        m1.\\<alpha> g v = Some m2 \\<and>\n                        m2.\\<alpha> m2 v' = Some s3 \\<and>\n                        w \\<in> s3.\\<alpha> s3}\\<rparr>,\n       edges =\n         edges\n          \\<lparr>nodes = dom (m1.\\<alpha> g),\n             edges =\n               {(v, w, v').\n                \\<exists>m2 s3.\n                   m1.\\<alpha> g v = Some m2 \\<and>\n                   m2.\\<alpha> m2 v' = Some s3 \\<and>\n                   w \\<in> s3.\\<alpha> s3}\\<rparr> -\n         {(v, e, v')}\\<rparr>", "apply (auto simp: m1.correct m2.correct s3.correct \n        Let_def\n        split: option.split if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n  delete_edge v e v' (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>g v e v'.\n       gbm_invar g \\<Longrightarrow> gbm_invar (gbm_delete_edge v e v' g)", "thus \"gbm_invar (gbm_delete_edge v e v' g)\""], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n  delete_edge v e v' (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. gbm_invar (gbm_delete_edge v e v' g)", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n  delete_edge v e v' (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar (gbm_delete_edge v e v' g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_delete_edge v e v' g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n    valid_graph (gbm_\\<alpha> (gbm_delete_edge v e v' g))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. gbm_\\<alpha> (gbm_delete_edge v e v' g) =\n    delete_edge v e v' (gbm_\\<alpha> g) \\<Longrightarrow>\n    m1.invar (gbm_delete_edge v e v' g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha> (gbm_delete_edge v e v' g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "unfolding gbm_\\<alpha>_def gbm_delete_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lparr>nodes =\n              dom (m1.\\<alpha>\n                    (case m1.lookup v g of None \\<Rightarrow> g\n                     | Some m2 \\<Rightarrow>\n                         case m2.lookup v' m2 of None \\<Rightarrow> g\n                         | Some s3 \\<Rightarrow>\n                             m1.update v (m2.update v' (s3.delete e s3) m2)\n                              g)),\n       edges =\n         {(va, w, v'a).\n          \\<exists>m2 s3.\n             m1.\\<alpha>\n              (case m1.lookup v g of None \\<Rightarrow> g\n               | Some m2 \\<Rightarrow>\n                   case m2.lookup v' m2 of None \\<Rightarrow> g\n                   | Some s3 \\<Rightarrow>\n                       m1.update v (m2.update v' (s3.delete e s3) m2) g)\n              va =\n             Some m2 \\<and>\n             m2.\\<alpha> m2 v'a = Some s3 \\<and>\n             w \\<in> s3.\\<alpha> s3}\\<rparr> =\n    delete_edge v e v'\n     \\<lparr>nodes = dom (m1.\\<alpha> g),\n        edges =\n          {(v, w, v').\n           \\<exists>m2 s3.\n              m1.\\<alpha> g v = Some m2 \\<and>\n              m2.\\<alpha> m2 v' = Some s3 \\<and>\n              w \\<in> s3.\\<alpha> s3}\\<rparr> \\<Longrightarrow>\n    m1.invar\n     (case m1.lookup v g of None \\<Rightarrow> g\n      | Some m2 \\<Rightarrow>\n          case m2.lookup v' m2 of None \\<Rightarrow> g\n          | Some s3 \\<Rightarrow>\n              m1.update v (m2.update v' (s3.delete e s3) m2) g) \\<and>\n    (\\<forall>m2\\<in>ran (m1.\\<alpha>\n                           (case m1.lookup v g of None \\<Rightarrow> g\n                            | Some m2 \\<Rightarrow>\n                                case m2.lookup v' m2 of None \\<Rightarrow> g\n                                | Some s3 \\<Rightarrow>\n                                    m1.update v\n                                     (m2.update v' (s3.delete e s3) m2) g)).\n        m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar)", "apply (auto simp: m1.correct m2.correct s3.correct\n        Let_def\n        split: option.split if_split_asm elim!: ranE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gbm_invar (gbm_delete_edge v e v' g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_nodes_list_it_impl:\n    shows \"graph_nodes_it gbm_\\<alpha> gbm_invar gbm_nodes_list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_nodes_it gbm_\\<alpha> gbm_invar gbm_nodes_list_it", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))", "assume \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))", "hence MINV: \"map_op_invar m1_ops g\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. m1.invar g", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar g", "by auto"], ["proof (state)\nthis:\n  m1.invar g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))", "from map_iterator_dom_correct[OF m1.iteratei_correct[OF MINV]]"], ["proof (chain)\npicking this:\n  set_iterator (map_iterator_dom (m1.iteratei g)) (dom (m1.\\<alpha> g))", "show \"set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))\""], ["proof (prove)\nusing this:\n  set_iterator (map_iterator_dom (m1.iteratei g)) (dom (m1.\\<alpha> g))\n\ngoal (1 subgoal):\n 1. set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))", "unfolding gbm_nodes_list_it_def gbm_\\<alpha>_def"], ["proof (prove)\nusing this:\n  set_iterator (map_iterator_dom (m1.iteratei g)) (dom (m1.\\<alpha> g))\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_dom (m1.iteratei g))\n     (nodes\n       \\<lparr>nodes = dom (m1.\\<alpha> g),\n          edges =\n            {(v, w, v').\n             \\<exists>m2 s3.\n                m1.\\<alpha> g v = Some m2 \\<and>\n                m2.\\<alpha> m2 v' = Some s3 \\<and>\n                w \\<in> s3.\\<alpha> s3}\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  set_iterator (gbm_nodes_list_it g) (nodes (gbm_\\<alpha> g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_edges_list_it_impl:\n    shows \"graph_edges_it gbm_\\<alpha> gbm_invar gbm_edges_list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_edges_it gbm_\\<alpha> gbm_invar gbm_edges_list_it", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "from INV"], ["proof (chain)\npicking this:\n  gbm_invar g", "have I1: \"m1.invar g\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. m1.invar g", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar g", "by auto"], ["proof (state)\nthis:\n  m1.invar g\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "from INV"], ["proof (chain)\npicking this:\n  gbm_invar g", "have I2: \"\\<And>v m2. (v,m2)\\<in>map_to_set (m1.\\<alpha> g) \\<Longrightarrow> m2.invar m2\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. \\<And>v m2.\n       (v, m2) \\<in> map_to_set (m1.\\<alpha> g) \\<Longrightarrow>\n       m2.invar m2", "unfolding gbm_invar_def map_to_set_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>v m2.\n       (v, m2) \\<in> {(k, v). m1.\\<alpha> g k = Some v} \\<Longrightarrow>\n       m2.invar m2", "by (auto simp: ran_def)"], ["proof (state)\nthis:\n  (?v2, ?m2.2) \\<in> map_to_set (m1.\\<alpha> g) \\<Longrightarrow>\n  m2.invar ?m2.2\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "from INV"], ["proof (chain)\npicking this:\n  gbm_invar g", "have I3: \"\\<And>v m2 v' s. \\<lbrakk>\n      (v,m2)\\<in>map_to_set (m1.\\<alpha> g); \n      (v',s)\\<in>map_to_set (m2.\\<alpha> m2)\\<rbrakk> \n      \\<Longrightarrow> s3.invar s\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. \\<And>v m2 v' s.\n       \\<lbrakk>(v, m2) \\<in> map_to_set (m1.\\<alpha> g);\n        (v', s) \\<in> map_to_set (m2.\\<alpha> m2)\\<rbrakk>\n       \\<Longrightarrow> s3.invar s", "unfolding gbm_invar_def map_to_set_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. \\<And>v m2 v' s.\n       \\<lbrakk>(v, m2) \\<in> {(k, v). m1.\\<alpha> g k = Some v};\n        (v', s) \\<in> {(k, v). m2.\\<alpha> m2 k = Some v}\\<rbrakk>\n       \\<Longrightarrow> s3.invar s", "by (auto simp: ran_def)"], ["proof (state)\nthis:\n  \\<lbrakk>(?v2, ?m2.2) \\<in> map_to_set (m1.\\<alpha> g);\n   (?v'2, ?s2) \\<in> map_to_set (m2.\\<alpha> ?m2.2)\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s2\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "show \"set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))", "unfolding gbm_edges_list_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator\n     (set_iterator_image (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n       (set_iterator_product (m1.iteratei g)\n         (\\<lambda>(v, m2).\n             set_iterator_product (m2.iteratei m2)\n              (\\<lambda>(w, y). s3.iteratei y))))\n     (edges (gbm_\\<alpha> g))", "apply (rule set_iterator_image_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set_iterator\n     (set_iterator_product (m1.iteratei g)\n       (\\<lambda>(v, m2).\n           set_iterator_product (m2.iteratei m2)\n            (\\<lambda>(w, y). s3.iteratei y)))\n     ?S\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) ?S\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) ` ?S", "apply (rule set_iterator_product_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set_iterator (m1.iteratei g) ?S_a4\n 2. \\<And>a.\n       a \\<in> ?S_a4 \\<Longrightarrow>\n       set_iterator\n        (case a of\n         (v, m2) \\<Rightarrow>\n           set_iterator_product (m2.iteratei m2)\n            (\\<lambda>(w, y). s3.iteratei y))\n        (?S_b4 a)\n 3. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (Sigma ?S_a4 ?S_b4)\n 4. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) ` Sigma ?S_a4 ?S_b4", "apply (rule m1.iteratei_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. m1.invar g\n 2. \\<And>a.\n       a \\<in> map_to_set (m1.\\<alpha> g) \\<Longrightarrow>\n       set_iterator\n        (case a of\n         (v, m2) \\<Rightarrow>\n           set_iterator_product (m2.iteratei m2)\n            (\\<lambda>(w, y). s3.iteratei y))\n        (?S_b4 a)\n 3. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4)\n 4. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4", "apply (rule I1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       a \\<in> map_to_set (m1.\\<alpha> g) \\<Longrightarrow>\n       set_iterator\n        (case a of\n         (v, m2) \\<Rightarrow>\n           set_iterator_product (m2.iteratei m2)\n            (\\<lambda>(w, y). s3.iteratei y))\n        (?S_b4 a)\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4)\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4", "apply (case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>a \\<in> map_to_set (m1.\\<alpha> g); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of\n                           (v, m2) \\<Rightarrow>\n                             set_iterator_product (m2.iteratei m2)\n                              (\\<lambda>(w, y). s3.iteratei y))\n                          (?S_b4 a)\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4)\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba.\n       (aa, ba) \\<in> map_to_set (m1.\\<alpha> g) \\<Longrightarrow>\n       set_iterator\n        (set_iterator_product (m2.iteratei ba)\n          (\\<lambda>(w, y). s3.iteratei y))\n        (?S_b4 (aa, ba))\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4)\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    Sigma (map_to_set (m1.\\<alpha> g)) ?S_b4", "apply (rule set_iterator_product_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba.\n       (aa, ba) \\<in> map_to_set (m1.\\<alpha> g) \\<Longrightarrow>\n       set_iterator (m2.iteratei ba) (?S_a18 (aa, ba))\n 2. \\<And>aa ba a.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        a \\<in> ?S_a18 (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (w, x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b17 (aa, ba) a)\n 3. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g). Sigma (?S_a18 a) (?S_b17 a))\n 4. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g). Sigma (?S_a18 a) (?S_b17 a))", "apply (drule I2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba.\n       m2.invar ba \\<Longrightarrow>\n       set_iterator (m2.iteratei ba) (?S_a18 (aa, ba))\n 2. \\<And>aa ba a.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        a \\<in> ?S_a18 (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (w, x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b17 (aa, ba) a)\n 3. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g). Sigma (?S_a18 a) (?S_b17 a))\n 4. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g). Sigma (?S_a18 a) (?S_b17 a))", "apply (subgoal_tac \"map_iterator (m2.iteratei ba) \n        (map_op_\\<alpha> m2_ops (snd (aa,ba)))\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>m2.invar ba;\n        map_iterator (m2.iteratei ba) (m2.\\<alpha> (snd (aa, ba)))\\<rbrakk>\n       \\<Longrightarrow> set_iterator (m2.iteratei ba) (?S_a18 (aa, ba))\n 2. \\<And>aa ba.\n       m2.invar ba \\<Longrightarrow>\n       map_iterator (m2.iteratei ba) (m2.\\<alpha> (snd (aa, ba)))\n 3. \\<And>aa ba a.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        a \\<in> ?S_a18 (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (w, x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b17 (aa, ba) a)\n 4. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g). Sigma (?S_a18 a) (?S_b17 a))\n 5. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g). Sigma (?S_a18 a) (?S_b17 a))", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba.\n       m2.invar ba \\<Longrightarrow>\n       map_iterator (m2.iteratei ba) (m2.\\<alpha> (snd (aa, ba)))\n 2. \\<And>aa ba a.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        a \\<in> map_to_set (m2.\\<alpha> (snd (aa, ba)))\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (w, x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b17 (aa, ba) a)\n 3. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))\n 4. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))", "apply (simp add: m2.iteratei_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba a.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        a \\<in> map_to_set (m2.\\<alpha> (snd (aa, ba)))\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (w, x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b17 (aa, ba) a)\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))", "apply (case_tac a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba a ab b.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        a \\<in> map_to_set (m2.\\<alpha> (snd (aa, ba)));\n        a = (ab, b)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (w, x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b17 (aa, ba) a)\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ab bb.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        (ab, bb) \\<in> map_to_set (m2.\\<alpha> ba)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei bb)\n                          (?S_b17 (aa, ba) (ab, bb))\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))", "apply (subgoal_tac \"set_iterator (s3.iteratei bb) \n        (s3.\\<alpha> (snd (ab,bb)))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa ba ab bb.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        (ab, bb) \\<in> map_to_set (m2.\\<alpha> ba);\n        set_iterator (s3.iteratei bb) (s3.\\<alpha> (snd (ab, bb)))\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei bb)\n                          (?S_b17 (aa, ba) (ab, bb))\n 2. \\<And>aa ba ab bb.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        (ab, bb) \\<in> map_to_set (m2.\\<alpha> ba)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei bb)\n                          (s3.\\<alpha> (snd (ab, bb)))\n 3. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))\n 4. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        Sigma (map_to_set (m2.\\<alpha> (snd a))) (?S_b17 a))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa ba ab bb.\n       \\<lbrakk>(aa, ba) \\<in> map_to_set (m1.\\<alpha> g);\n        (ab, bb) \\<in> map_to_set (m2.\\<alpha> ba)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei bb)\n                          (s3.\\<alpha> (snd (ab, bb)))\n 2. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         SIGMA a:map_to_set (m2.\\<alpha> (snd a)). s3.\\<alpha> (snd a))\n 3. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        SIGMA a:map_to_set (m2.\\<alpha> (snd a)). s3.\\<alpha> (snd a))", "apply (simp add: s3.iteratei_correct I3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2))\n     (SIGMA a:map_to_set (m1.\\<alpha> g).\n         SIGMA a:map_to_set (m2.\\<alpha> (snd a)). s3.\\<alpha> (snd a))\n 2. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        SIGMA a:map_to_set (m2.\\<alpha> (snd a)). s3.\\<alpha> (snd a))", "apply (auto simp: inj_on_def map_to_set_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. edges (gbm_\\<alpha> g) =\n    (\\<lambda>((v1, m1), (v2, m2), w). (v1, w, v2)) `\n    (SIGMA a:map_to_set (m1.\\<alpha> g).\n        SIGMA a:map_to_set (m2.\\<alpha> (snd a)). s3.\\<alpha> (snd a))", "apply (force simp: gbm_\\<alpha>_def map_to_set_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator (gbm_edges_list_it g) (edges (gbm_\\<alpha> g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_succ_list_it_impl:\n    shows \"graph_succ_it gbm_\\<alpha> gbm_invar gbm_succ_list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_succ_it gbm_\\<alpha> gbm_invar gbm_succ_list_it", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "fix g v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "assume INV: \"gbm_invar g\""], ["proof (state)\nthis:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "hence I1[simp]: \"m1.invar g\""], ["proof (prove)\nusing this:\n  gbm_invar g\n\ngoal (1 subgoal):\n 1. m1.invar g", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m1.invar g", "by auto"], ["proof (state)\nthis:\n  m1.invar g\n\ngoal (1 subgoal):\n 1. \\<And>g v.\n       gbm_invar g \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "show \"set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "proof (cases \"m1.lookup v g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m1.lookup v g = None \\<Longrightarrow>\n    set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\n 2. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "case None"], ["proof (state)\nthis:\n  m1.lookup v g = None\n\ngoal (2 subgoals):\n 1. m1.lookup v g = None \\<Longrightarrow>\n    set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\n 2. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "hence \"(succ (gbm_\\<alpha> g) v) = {}\""], ["proof (prove)\nusing this:\n  m1.lookup v g = None\n\ngoal (1 subgoal):\n 1. succ (gbm_\\<alpha> g) v = {}", "unfolding succ_def gbm_\\<alpha>_def"], ["proof (prove)\nusing this:\n  m1.lookup v g = None\n\ngoal (1 subgoal):\n 1. {(w, v').\n     (v, w, v')\n     \\<in> edges\n            \\<lparr>nodes = dom (m1.\\<alpha> g),\n               edges =\n                 {(v, w, v').\n                  \\<exists>m2 s3.\n                     m1.\\<alpha> g v = Some m2 \\<and>\n                     m2.\\<alpha> m2 v' = Some s3 \\<and>\n                     w \\<in> s3.\\<alpha> s3}\\<rparr>} =\n    {}", "by (auto simp: m1.lookup_correct)"], ["proof (state)\nthis:\n  succ (gbm_\\<alpha> g) v = {}\n\ngoal (2 subgoals):\n 1. m1.lookup v g = None \\<Longrightarrow>\n    set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\n 2. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "with None"], ["proof (chain)\npicking this:\n  m1.lookup v g = None\n  succ (gbm_\\<alpha> g) v = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  m1.lookup v g = None\n  succ (gbm_\\<alpha> g) v = {}\n\ngoal (1 subgoal):\n 1. set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "unfolding gbm_succ_list_it_def"], ["proof (prove)\nusing this:\n  m1.lookup v g = None\n  succ (gbm_\\<alpha> g) v = {}\n\ngoal (1 subgoal):\n 1. set_iterator\n     (case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n      | Some m2 \\<Rightarrow>\n          set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (m2.iteratei m2)\n             (\\<lambda>(v', y). s3.iteratei y)))\n     (succ (gbm_\\<alpha> g) v)", "by (auto simp: set_iterator_emp_correct)"], ["proof (state)\nthis:\n  set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "case (Some m2)"], ["proof (state)\nthis:\n  m1.lookup v g = Some m2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "hence [simp]: \"m2.invar m2\""], ["proof (prove)\nusing this:\n  m1.lookup v g = Some m2\n\ngoal (1 subgoal):\n 1. m2.invar m2", "using gbm_invar_split[OF INV]"], ["proof (prove)\nusing this:\n  m1.lookup v g = Some m2\n  m1.invar g\n  m1.\\<alpha> g ?v = Some ?m2.0 \\<Longrightarrow> m2.invar ?m2.0\n  \\<lbrakk>m1.\\<alpha> g ?v = Some ?m2.0;\n   m2.\\<alpha> ?m2.0 ?v' = Some ?s3.0\\<rbrakk>\n  \\<Longrightarrow> s3.invar ?s3.0\n  valid_graph (gbm_\\<alpha> g)\n\ngoal (1 subgoal):\n 1. m2.invar m2", "by (simp add: m1.lookup_correct)"], ["proof (state)\nthis:\n  m2.invar m2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "from INV Some"], ["proof (chain)\npicking this:\n  gbm_invar g\n  m1.lookup v g = Some m2", "have \n        I2: \"\\<And>v' s. (v', s) \\<in> map_to_set (map_op_\\<alpha> m2_ops m2) \\<Longrightarrow> s3.invar s\""], ["proof (prove)\nusing this:\n  gbm_invar g\n  m1.lookup v g = Some m2\n\ngoal (1 subgoal):\n 1. \\<And>v' s.\n       (v', s) \\<in> map_to_set (m2.\\<alpha> m2) \\<Longrightarrow>\n       s3.invar s", "unfolding gbm_invar_def"], ["proof (prove)\nusing this:\n  m1.invar g \\<and>\n  (\\<forall>m2\\<in>ran (m1.\\<alpha> g).\n      m2.invar m2 \\<and> Ball (ran (m2.\\<alpha> m2)) s3.invar) \\<and>\n  valid_graph (gbm_\\<alpha> g)\n  m1.lookup v g = Some m2\n\ngoal (1 subgoal):\n 1. \\<And>v' s.\n       (v', s) \\<in> map_to_set (m2.\\<alpha> m2) \\<Longrightarrow>\n       s3.invar s", "by (auto simp: map_to_set_def ran_def m1.lookup_correct)"], ["proof (state)\nthis:\n  (?v'2, ?s2) \\<in> map_to_set (m2.\\<alpha> m2) \\<Longrightarrow>\n  s3.invar ?s2\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m1.lookup v g = Some a \\<Longrightarrow>\n       set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "from Some"], ["proof (chain)\npicking this:\n  m1.lookup v g = Some m2", "show ?thesis"], ["proof (prove)\nusing this:\n  m1.lookup v g = Some m2\n\ngoal (1 subgoal):\n 1. set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)", "unfolding gbm_succ_list_it_def"], ["proof (prove)\nusing this:\n  m1.lookup v g = Some m2\n\ngoal (1 subgoal):\n 1. set_iterator\n     (case m1.lookup v g of None \\<Rightarrow> set_iterator_emp\n      | Some m2 \\<Rightarrow>\n          set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n           (set_iterator_product (m2.iteratei m2)\n             (\\<lambda>(v', y). s3.iteratei y)))\n     (succ (gbm_\\<alpha> g) v)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1.lookup v g = Some m2 \\<Longrightarrow>\n    set_iterator\n     (set_iterator_image (\\<lambda>((v', m2), w). (w, v'))\n       (set_iterator_product (m2.iteratei m2)\n         (\\<lambda>(v', y). s3.iteratei y)))\n     (succ (gbm_\\<alpha> g) v)", "apply (rule set_iterator_image_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. m1.lookup v g = Some m2 \\<Longrightarrow>\n    set_iterator\n     (set_iterator_product (m2.iteratei m2)\n       (\\<lambda>(v', y). s3.iteratei y))\n     ?S2\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v')) ?S2\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v = (\\<lambda>((v', m2), w). (w, v')) ` ?S2", "apply (rule set_iterator_product_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. m1.lookup v g = Some m2 \\<Longrightarrow>\n    set_iterator (m2.iteratei m2) ?S_a6\n 2. \\<And>a.\n       \\<lbrakk>m1.lookup v g = Some m2; a \\<in> ?S_a6\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (v', x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b6 a)\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v')) (Sigma ?S_a6 ?S_b6)\n 4. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) ` Sigma ?S_a6 ?S_b6", "apply (rule m2.iteratei_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. m1.lookup v g = Some m2 \\<Longrightarrow> m2.invar m2\n 2. \\<And>a.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        a \\<in> map_to_set (m2.\\<alpha> m2)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (v', x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b6 a)\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6)\n 4. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        a \\<in> map_to_set (m2.\\<alpha> m2)\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of (v', x) \\<Rightarrow> s3.iteratei x)\n                          (?S_b6 a)\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6)\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6", "apply (case_tac a, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        (aa, b) \\<in> map_to_set (m2.\\<alpha> m2); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei b) (?S_b6 (aa, b))\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6)\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6", "apply (subgoal_tac \"set_iterator (s3.iteratei b) (s3.\\<alpha> (snd (aa, b)))\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        (aa, b) \\<in> map_to_set (m2.\\<alpha> m2); a = (aa, b);\n        set_iterator (s3.iteratei b) (s3.\\<alpha> (snd (aa, b)))\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei b) (?S_b6 (aa, b))\n 2. \\<And>a aa b.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        (aa, b) \\<in> map_to_set (m2.\\<alpha> m2); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei b)\n                          (s3.\\<alpha> (snd (aa, b)))\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6)\n 4. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    Sigma (map_to_set (m2.\\<alpha> m2)) ?S_b6", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        (aa, b) \\<in> map_to_set (m2.\\<alpha> m2); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei b)\n                          (s3.\\<alpha> (snd (aa, b)))\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        (aa, b) \\<in> map_to_set (m2.\\<alpha> m2); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (s3.iteratei b) (s3.\\<alpha> b)\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))", "apply (rule s3.iteratei_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b.\n       \\<lbrakk>m1.lookup v g = Some m2;\n        (aa, b) \\<in> map_to_set (m2.\\<alpha> m2); a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> s3.invar b\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))\n 3. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))", "apply (simp add: I2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m1.lookup v g = Some m2 \\<Longrightarrow>\n    inj_on (\\<lambda>((v', m2), w). (w, v'))\n     (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))\n 2. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))", "apply (auto simp: inj_on_def map_to_set_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1.lookup v g = Some m2 \\<Longrightarrow>\n    succ (gbm_\\<alpha> g) v =\n    (\\<lambda>((v', m2), w). (w, v')) `\n    (SIGMA a:map_to_set (m2.\\<alpha> m2). s3.\\<alpha> (snd a))", "apply (force simp: succ_def gbm_\\<alpha>_def map_to_set_def m1.lookup_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_iterator (gbm_succ_list_it g v) (succ (gbm_\\<alpha> g) v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gbm_from_list_impl:\n    shows \"graph_from_list gbm_\\<alpha> gbm_invar gbm_from_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_from_list gbm_\\<alpha> gbm_invar gbm_from_list", "unfolding gbm_from_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_from_list gbm_\\<alpha> gbm_invar\n     (gga_from_list gbm_empty gbm_add_node gbm_add_edge)", "apply (rule gga_from_list_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. graph_empty gbm_\\<alpha> gbm_invar gbm_empty\n 2. graph_add_node gbm_\\<alpha> gbm_invar gbm_add_node\n 3. graph_add_edge gbm_\\<alpha> gbm_invar gbm_add_edge", "apply (rule gbm_empty_impl gbm_add_node_impl gbm_add_edge_impl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "sublocale GraphByMap < graph_nodes_it gbm_\\<alpha> gbm_invar gbm_nodes_list_it"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_nodes_it gbm_\\<alpha> gbm_invar gbm_nodes_list_it", "by (rule gbm_nodes_list_it_impl)"], ["", "sublocale GraphByMap < graph_edges_it gbm_\\<alpha> gbm_invar gbm_edges_list_it"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_edges_it gbm_\\<alpha> gbm_invar gbm_edges_list_it", "by (rule gbm_edges_list_it_impl)"], ["", "sublocale GraphByMap < graph_succ_it gbm_\\<alpha> gbm_invar gbm_succ_list_it"], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_succ_it gbm_\\<alpha> gbm_invar gbm_succ_list_it", "by (rule gbm_succ_list_it_impl)"], ["", "sublocale GraphByMap\n  < gga_to_list_loc gbm_\\<alpha> gbm_invar gbm_nodes_list_it gbm_edges_list_it"], ["proof (prove)\ngoal (1 subgoal):\n 1. gga_to_list_loc gbm_\\<alpha> gbm_invar gbm_nodes_list_it\n     gbm_edges_list_it", "by unfold_locales"], ["", "context GraphByMap\nbegin"], ["", "lemma gbm_to_list_impl: \"graph_to_list gbm_\\<alpha> gbm_invar gga_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph_to_list gbm_\\<alpha> gbm_invar gga_to_list", "by (rule gga_to_list_correct)"], ["", "lemma gbm_ops_impl: \"StdGraph gbm_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdGraph gbm_ops", "apply (rule StdGraph.intro)"], ["proof (prove)\ngoal (11 subgoals):\n 1. graph (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n 2. graph_empty (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_empty gbm_ops)\n 3. graph_add_node (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_add_node gbm_ops)\n 4. graph_delete_node (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_delete_node gbm_ops)\n 5. graph_add_edge (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_add_edge gbm_ops)\n 6. graph_delete_edge (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_delete_edge gbm_ops)\n 7. graph_from_list (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_from_list gbm_ops)\n 8. graph_to_list (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_to_list gbm_ops)\n 9. graph_nodes_it (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n     (gop_nodes_list_it gbm_ops)\n 10. graph_edges_it (gop_\\<alpha> gbm_ops) (gop_invar gbm_ops)\n      (gop_edges_list_it gbm_ops)\nA total of 11 subgoals...", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (11 subgoals):\n 1. graph gbm_\\<alpha> gbm_invar\n 2. graph_empty gbm_\\<alpha> gbm_invar gbm_empty\n 3. graph_add_node gbm_\\<alpha> gbm_invar gbm_add_node\n 4. graph_delete_node gbm_\\<alpha> gbm_invar gbm_delete_node\n 5. graph_add_edge gbm_\\<alpha> gbm_invar gbm_add_edge\n 6. graph_delete_edge gbm_\\<alpha> gbm_invar gbm_delete_edge\n 7. graph_from_list gbm_\\<alpha> gbm_invar gbm_from_list\n 8. graph_to_list gbm_\\<alpha> gbm_invar gga_to_list\n 9. graph_nodes_it gbm_\\<alpha> gbm_invar gbm_nodes_list_it\n 10. graph_edges_it gbm_\\<alpha> gbm_invar gbm_edges_list_it\nA total of 11 subgoals...", "apply icf_locales"], ["proof (prove)\ngoal (7 subgoals):\n 1. graph_empty gbm_\\<alpha> gbm_invar gbm_empty\n 2. graph_add_node gbm_\\<alpha> gbm_invar gbm_add_node\n 3. graph_delete_node gbm_\\<alpha> gbm_invar gbm_delete_node\n 4. graph_add_edge gbm_\\<alpha> gbm_invar gbm_add_edge\n 5. graph_delete_edge gbm_\\<alpha> gbm_invar gbm_delete_edge\n 6. graph_from_list gbm_\\<alpha> gbm_invar gbm_from_list\n 7. graph_to_list gbm_\\<alpha> gbm_invar gga_to_list", "apply (rule gbm_empty_impl gbm_add_node_impl gbm_delete_node_impl \n      gbm_add_edge_impl gbm_delete_edge_impl gbm_from_list_impl\n      gbm_to_list_impl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "setup \\<open>\n  (Record_Intf.add_unf_thms_global @{thms \n    GraphByMapDefs.gbm_nodes_list_it_unf\n    GraphByMapDefs.gbm_edges_list_it_unf\n    GraphByMapDefs.gbm_succ_list_it_unf\n  })\n\\<close>"], ["", "end"]]}