{"file_name": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path/Dijkstra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path", "problem_names": ["lemma path_nonneg_weight: \"is_path v p v' \\<Longrightarrow> 0 \\<le> path_weight p\"", "lemma invar_imp_correct: \"dinvar ({},res) \\<Longrightarrow> is_shortest_path_map v0 res\"", "lemma dinit_invar: \"dinit \\<le> SPEC dinvar\"", "theorem dijkstra_correct: \"dijkstra \\<le> SPEC (is_shortest_path_map v0)\"", "lemma update'_refines:\n    assumes \"v'=v\" and \"\\<sigma>'=\\<sigma>\"\n    shows \"update' v' \\<sigma>' \\<le> \\<Down>Id (update v \\<sigma>)\"", "lemma dijkstra'_refines: \"dijkstra' \\<le> \\<Down>Id dijkstra\"", "lemma mpath_weight'_correct: \"\\<lbrakk>dinvarm (wl,res)\\<rbrakk> \\<Longrightarrow>\n    mpath_weight' (res v) = path_weight' (\\<alpha>r res v)\n    \"", "lemma mpath'_correct: \"\\<lbrakk>dinvarm (wl,res)\\<rbrakk> \\<Longrightarrow>\n    mpath' (res v) = map_option rev (\\<alpha>r res v)\"", "lemma wl_weight_correct:\n    assumes INV: \"dinvarm (wl,res)\" \n    assumes WLV: \"wl v = Some w\" \n    shows \"path_weight' (\\<alpha>r res v) = w\"", "lemma mdinit_refines: \"mdinit \\<le> \\<Down>(build_rel \\<alpha>s dinvarm) dinit\"", "lemma mpop_min_refines:\n    \"\\<lbrakk> (\\<sigma>,\\<sigma>') \\<in> build_rel \\<alpha>s dinvarm \\<rbrakk> \\<Longrightarrow> \n      mpop_min \\<sigma> \\<le> \n       \\<Down>(build_rel \n          (\\<lambda>(v,w,\\<sigma>). (v,\\<alpha>s \\<sigma>)) \n          (\\<lambda>(v,w,\\<sigma>). dinvarm \\<sigma> \\<and> w = mpath_weight' (snd \\<sigma> v)))\n      (pop_min \\<sigma>')\"\n    \\<comment> \\<open>The two algorithms are structurally different, so we use the\n      nofail/inres method to prove refinement.\\<close>", "lemma mupdate_refines: \n    assumes SREF: \"(\\<sigma>,\\<sigma>')\\<in>build_rel \\<alpha>s dinvarm\"\n    assumes WV: \"wv = mpath_weight' (snd \\<sigma> v)\"\n    assumes VV': \"v'=v\"\n    shows \"mupdate v wv \\<sigma> \\<le> \\<Down>(build_rel \\<alpha>s dinvarm) (update' v' \\<sigma>')\"", "lemma mdijkstra_refines: \"mdijkstra \\<le> \\<Down>(build_rel \\<alpha>r res_invarm) dijkstra'\""], "translations": [["", "lemma path_nonneg_weight: \"is_path v p v' \\<Longrightarrow> 0 \\<le> path_weight p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path v p v' \\<Longrightarrow> (0::'W) \\<le> path_weight p", "by (induct rule: is_path.induct) auto"], ["", "text \\<open>Invariant of the main loop: \n    \\begin{itemize}\n      \\item The workset only contains nodes of the graph.\n      \\item If the result set contains a path for a node, it is actually a path,\n        and uses only intermediate vertices outside the workset.\n      \\item For all vertices outside the workset, the result map contains the \n        shortest path.\n      \\item For all vertices in the workset, the result map contains the\n        shortest path among all paths that only use intermediate vertices outside\n        the workset.\n    \\end{itemize}\n\\<close>"], ["", "definition \"dinvar \\<sigma> \\<equiv> let (wl,res)=\\<sigma> in\n    wl \\<subseteq> V \\<and>\n    (\\<forall>v\\<in>V. \\<forall>p. res v = Some p \\<longrightarrow> is_path v0 p v \\<and> int_vertices p \\<subseteq> V-wl) \\<and>\n    (\\<forall>v\\<in>V-wl. \\<forall>p. is_path v0 p v \n       \\<longrightarrow> path_weight' (res v) \\<le> path_weight' (Some p)) \\<and>\n    (\\<forall>v\\<in>wl. \\<forall>p. is_path v0 p v \\<and> int_vertices p \\<subseteq> V-wl\n       \\<longrightarrow> path_weight' (res v) \\<le> path_weight' (Some p)\n    )\n    \""], ["", "text \\<open>Sanity check: The invariant is strong enough to imply correctness \n    of result.\\<close>"], ["", "lemma invar_imp_correct: \"dinvar ({},res) \\<Longrightarrow> is_shortest_path_map v0 res\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dinvar ({}, res) \\<Longrightarrow> is_shortest_path_map v0 res", "unfolding dinvar_def is_shortest_path_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (wl, res) = ({}, res)\n    in wl \\<subseteq> V \\<and>\n       (\\<forall>v\\<in>V.\n           \\<forall>p.\n              res v = Some p \\<longrightarrow>\n              is_path v0 p v \\<and>\n              int_vertices p \\<subseteq> V - wl) \\<and>\n       (\\<forall>v\\<in>V - wl.\n           \\<forall>p.\n              is_path v0 p v \\<longrightarrow>\n              path_weight' (res v) \\<le> path_weight' (Some p)) \\<and>\n       (\\<forall>v\\<in>wl.\n           \\<forall>p.\n              is_path v0 p v \\<and>\n              int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n              path_weight' (res v)\n              \\<le> path_weight' (Some p)) \\<Longrightarrow>\n    \\<forall>v\\<in>V.\n       case res v of None \\<Rightarrow> \\<nexists>p. is_path v0 p v\n       | Some p \\<Rightarrow>\n           is_path v0 p v \\<and>\n           (\\<forall>p'.\n               is_path v0 p' v \\<longrightarrow>\n               path_weight p \\<le> path_weight p')", "by (auto simp: infty_unbox split: option.split)"], ["", "text \\<open>\n    The initial workset contains all vertices. The initial result maps\n    \\<open>v0\\<close> to the empty path, and all other vertices to \\<open>None\\<close>.\n\\<close>"], ["", "definition dinit :: \"('V,'W) state nres\" where\n    \"dinit \\<equiv> SPEC ( \\<lambda>(wl,res) . \n        wl=V \\<and> res v0 = Some [] \\<and> (\\<forall>v\\<in>V-{v0}. res v = None))\""], ["", "text \\<open>\n    The initial state satisfies the invariant.\n\\<close>"], ["", "lemma dinit_invar: \"dinit \\<le> SPEC dinvar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dinit \\<le> SPEC dinvar", "unfolding dinit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>(wl, res).\n         wl = V \\<and>\n         res v0 = Some [] \\<and> (\\<forall>v\\<in>V - {v0}. res v = None))\n    \\<le> SPEC dinvar", "apply (intro refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       dinvar x", "apply (force simp: dinvar_def split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n    In each iteration, the main loop of the algorithm pops a minimal node from\n    the workset, and then updates the result map accordingly.\n\\<close>"], ["", "text \\<open>\n    Pop a minimal node from the workset. The node is minimal in the sense that\n    the length of the current path for that node is minimal.\n\\<close>"], ["", "definition pop_min :: \"('V,'W) state \\<Rightarrow> ('V \\<times> ('V,'W) state) nres\" where\n    \"pop_min \\<sigma> \\<equiv> do {\n      let (wl,res)=\\<sigma>;\n      ASSERT (wl\\<noteq>{}); \n      v \\<leftarrow> RES (least_map (path_weight' \\<circ> res) wl);\n      RETURN (v,(wl-{v},res))\n    }\""], ["", "text \\<open>\n    Updating the result according to a node \\<open>v\\<close> is done by checking, \n    for each successor node, whether the path over \\<open>v\\<close> is shorter than \n    the path currently stored into the result map.\n\\<close>"], ["", "inductive update_spec :: \"'V \\<Rightarrow> ('V,'W) state \\<Rightarrow> ('V,'W) state \\<Rightarrow> bool\"\n    where\n    \"\\<lbrakk> \\<forall>v'\\<in>V. \n      res' v' \\<in> least_map path_weight' (\n        { res v' } \\<union> { Some (p@[(v,w,v')]) | p w. res v = Some p \\<and> (v,w,v')\\<in>E }\n      )\n     \\<rbrakk> \\<Longrightarrow> update_spec v (wl,res) (wl,res')\""], ["", "text \\<open>\n    In order to ease the refinement proof, we will assert the following \n    precondition for updating.\n\\<close>"], ["", "definition update_pre :: \"'V \\<Rightarrow> ('V,'W) state \\<Rightarrow> bool\" where\n    \"update_pre v \\<sigma> \\<equiv> let (wl,res)=\\<sigma> in v\\<in>V \n      \\<and> (\\<forall>v'\\<in>V-wl. v'\\<noteq>v \\<longrightarrow> (\\<forall>p. is_path v0 p v' \n          \\<longrightarrow> path_weight' (res v') \\<le> path_weight' (Some p)))\n      \\<and> (\\<forall>v'\\<in>V. \\<forall>p. res v' = Some p \\<longrightarrow> is_path v0 p v')\""], ["", "definition update :: \"'V \\<Rightarrow> ('V,'W) state \\<Rightarrow> ('V,'W) state nres\" where \n    \"update v \\<sigma> \\<equiv> do {ASSERT (update_pre v \\<sigma>); SPEC (update_spec v \\<sigma>)}\""], ["", "text \\<open>Finally, we define Dijkstra's algorithm:\\<close>"], ["", "definition dijkstra where\n    \"dijkstra \\<equiv> do {\n       \\<sigma>0\\<leftarrow>dinit; \n       (_,res) \\<leftarrow> WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup> (\\<lambda>(wl,_). wl\\<noteq>{}) \n            (\\<lambda>\\<sigma>. \n              do { (v,\\<sigma>') \\<leftarrow> pop_min \\<sigma>; update v \\<sigma>' }\n            )\n            \\<sigma>0;\n       RETURN res }\n    \""], ["", "text \\<open>The following theorem states (total) correctness of Dijkstra's \n    algorithm.\\<close>"], ["", "theorem dijkstra_correct: \"dijkstra \\<le> SPEC (is_shortest_path_map v0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstra \\<le> SPEC (is_shortest_path_map v0)", "unfolding dijkstra_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dinit \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n         (\\<lambda>(wl, uu_). wl \\<noteq> {})\n         (\\<lambda>\\<sigma>.\n             pop_min \\<sigma> \\<bind> (\\<lambda>(x, y). update x y))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> SPEC (is_shortest_path_map v0)", "unfolding dinit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>(wl, res).\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None)) \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n         (\\<lambda>(wl, uu_). wl \\<noteq> {})\n         (\\<lambda>\\<sigma>.\n             pop_min \\<sigma> \\<bind> (\\<lambda>(x, y). update x y))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> SPEC (is_shortest_path_map v0)", "unfolding pop_min_def update_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>(wl, res).\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None)) \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n         (\\<lambda>(wl, uu_). wl \\<noteq> {})\n         (\\<lambda>\\<sigma>.\n             (let (wl, res) = \\<sigma>\n              in ASSERT (wl \\<noteq> {}) \\<bind>\n                 (\\<lambda>_.\n                     RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n                     (\\<lambda>v. RETURN (v, wl - {v}, res)))) \\<bind>\n             (\\<lambda>(v, \\<sigma>').\n                 ASSERT (update_pre v \\<sigma>') \\<bind>\n                 (\\<lambda>_. SPEC (update_spec v \\<sigma>'))))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> SPEC (is_shortest_path_map v0)", "thm refine_vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>(wl, res).\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None)) \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n         (\\<lambda>(wl, uu_). wl \\<noteq> {})\n         (\\<lambda>\\<sigma>.\n             (let (wl, res) = \\<sigma>\n              in ASSERT (wl \\<noteq> {}) \\<bind>\n                 (\\<lambda>_.\n                     RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n                     (\\<lambda>v. RETURN (v, wl - {v}, res)))) \\<bind>\n             (\\<lambda>(v, \\<sigma>').\n                 ASSERT (update_pre v \\<sigma>') \\<bind>\n                 (\\<lambda>_. SPEC (update_spec v \\<sigma>'))))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> SPEC (is_shortest_path_map v0)", "apply (refine_rcg\n      WHILEIT_rule[where R=\"inv_image {(x,y). x<y} (card \\<circ> fst)\"]\n      refine_vcg \n    )"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       dinvar x\n 3. \\<And>x s a b.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> {}\n 4. \\<And>x s a b xa aa ba.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa ba\n 5. \\<And>x s a b xa aa ba xb.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba); update_pre aa ba;\n        update_spec aa ba xb\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 6. \\<And>x s a b xa aa ba xb.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba); update_pre aa ba;\n        update_spec aa ba xb\\<rbrakk>\n       \\<Longrightarrow> (xb, s)\n                         \\<in> inv_image {(x, y). x < y} (card \\<circ> fst)\n 7. \\<And>x s a b.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; \\<not> (case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {});\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "(* TODO/FIXME: Should we built in such massaging of the goal into \n        refine_rcg ?*)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       dinvar x\n 3. \\<And>x s a b.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> {}\n 4. \\<And>x s a b xa aa ba.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa ba\n 5. \\<And>x s a b xa aa ba xb.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba); update_pre aa ba;\n        update_spec aa ba xb\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 6. \\<And>x s a b xa aa ba xb.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba); update_pre aa ba;\n        update_spec aa ba xb\\<rbrakk>\n       \\<Longrightarrow> (xb, s)\n                         \\<in> inv_image {(x, y). x < y} (card \\<circ> fst)\n 7. \\<And>x s a b.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; \\<not> (case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {});\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "supply [[simproc del: defined_all]]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x.\n       case x of\n       (wl, res) \\<Rightarrow>\n         wl = V \\<and>\n         res v0 = Some [] \\<and>\n         (\\<forall>v\\<in>V - {v0}. res v = None) \\<Longrightarrow>\n       dinvar x\n 3. \\<And>x s a b.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> {}\n 4. \\<And>x s a b xa aa ba.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa ba\n 5. \\<And>x s a b xa aa ba xb.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba); update_pre aa ba;\n        update_spec aa ba xb\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 6. \\<And>x s a b xa aa ba xb.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        s = (a, b); a \\<noteq> {};\n        xa \\<in> least_map (path_weight' \\<circ> b) a;\n        (xa, a - {xa}, b) = (aa, ba); update_pre aa ba;\n        update_spec aa ba xb\\<rbrakk>\n       \\<Longrightarrow> (xb, s)\n                         \\<in> inv_image {(x, y). x < y} (card \\<circ> fst)\n 7. \\<And>x s a b.\n       \\<lbrakk>case x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None);\n        dinvar s; \\<not> (case s of (wl, uu_) \\<Rightarrow> wl \\<noteq> {});\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "apply (simp_all split: prod.split_asm)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x x1 x2.\n       \\<lbrakk>x = (V, x2);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x x1 x2.\n       \\<lbrakk>x = (V, x2);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar (V, x2)\n 3. \\<And>x s a b xa aa ba x1 x2.\n       \\<lbrakk>dinvar (a, b); s = (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a; xa = aa;\n        (a - {aa}, b) = ba; x = (V, x2);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa ba\n 4. \\<And>x s a b xa aa ba xb x1 x2.\n       \\<lbrakk>dinvar (a, b); s = (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a; update_pre aa ba;\n        update_spec aa ba xb; xa = aa; (a - {aa}, b) = ba; x = (V, x2);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>x s a b xa aa ba xb x1 x2.\n       \\<lbrakk>dinvar (a, b); s = (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a; update_pre aa ba;\n        update_spec aa ba xb; xa = aa; (a - {aa}, b) = ba; x = (V, x2);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>x s a b x1 x2.\n       \\<lbrakk>dinvar ({}, b); a = {}; s = ({}, b); x = (V, x2);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "apply (tactic \\<open>\n      ALLGOALS ((REPEAT_DETERM o Hypsubst.bound_hyp_subst_tac @{context})\n      THEN' asm_full_simp_tac @{context}\n      )\\<close>)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "fix wl res v"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "assume INV: \"dinvar (wl,res)\"\n    and LM: \"v\\<in>least_map (path_weight' \\<circ> res) wl\""], ["proof (state)\nthis:\n  dinvar (wl, res)\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "hence \"v\\<in>V\""], ["proof (prove)\nusing this:\n  dinvar (wl, res)\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n\ngoal (1 subgoal):\n 1. v \\<in> V", "unfolding dinvar_def"], ["proof (prove)\nusing this:\n  let (wl, res) = (wl, res)\n  in wl \\<subseteq> V \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>p.\n            res v = Some p \\<longrightarrow>\n            is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl) \\<and>\n     (\\<forall>v\\<in>V - wl.\n         \\<forall>p.\n            is_path v0 p v \\<longrightarrow>\n            path_weight' (res v) \\<le> path_weight' (Some p)) \\<and>\n     (\\<forall>v\\<in>wl.\n         \\<forall>p.\n            is_path v0 p v \\<and>\n            int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n            path_weight' (res v) \\<le> path_weight' (Some p))\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n\ngoal (1 subgoal):\n 1. v \\<in> V", "by (auto dest: least_map_elemD)"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "moreover"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "from INV"], ["proof (chain)\npicking this:\n  dinvar (wl, res)", "have \" \\<forall>v'\\<in>V - (wl-{v}). v' \\<noteq> v \\<longrightarrow> \n      (\\<forall>p. is_path v0 p v' \\<longrightarrow> path_weight' (res v') \\<le> Num (path_weight p))\""], ["proof (prove)\nusing this:\n  dinvar (wl, res)\n\ngoal (1 subgoal):\n 1. \\<forall>v'\\<in>V - (wl - {v}).\n       v' \\<noteq> v \\<longrightarrow>\n       (\\<forall>p.\n           is_path v0 p v' \\<longrightarrow>\n           path_weight' (res v') \\<le> Num (path_weight p))", "by (auto simp: dinvar_def)"], ["proof (state)\nthis:\n  \\<forall>v'\\<in>V - (wl - {v}).\n     v' \\<noteq> v \\<longrightarrow>\n     (\\<forall>p.\n         is_path v0 p v' \\<longrightarrow>\n         path_weight' (res v') \\<le> Num (path_weight p))\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "moreover"], ["proof (state)\nthis:\n  \\<forall>v'\\<in>V - (wl - {v}).\n     v' \\<noteq> v \\<longrightarrow>\n     (\\<forall>p.\n         is_path v0 p v' \\<longrightarrow>\n         path_weight' (res v') \\<le> Num (path_weight p))\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "from INV"], ["proof (chain)\npicking this:\n  dinvar (wl, res)", "have \"\\<forall>v'\\<in>V. \\<forall>p. res v'=Some p \\<longrightarrow> is_path v0 p v'\""], ["proof (prove)\nusing this:\n  dinvar (wl, res)\n\ngoal (1 subgoal):\n 1. \\<forall>v'\\<in>V.\n       \\<forall>p. res v' = Some p \\<longrightarrow> is_path v0 p v'", "by (auto simp: dinvar_def)"], ["proof (state)\nthis:\n  \\<forall>v'\\<in>V.\n     \\<forall>p. res v' = Some p \\<longrightarrow> is_path v0 p v'\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> update_pre aa (a - {aa}, b)\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 5. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 6. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> V\n  \\<forall>v'\\<in>V - (wl - {v}).\n     v' \\<noteq> v \\<longrightarrow>\n     (\\<forall>p.\n         is_path v0 p v' \\<longrightarrow>\n         path_weight' (res v') \\<le> Num (path_weight p))\n  \\<forall>v'\\<in>V.\n     \\<forall>p. res v' = Some p \\<longrightarrow> is_path v0 p v'", "show \"update_pre v (wl-{v},res)\""], ["proof (prove)\nusing this:\n  v \\<in> V\n  \\<forall>v'\\<in>V - (wl - {v}).\n     v' \\<noteq> v \\<longrightarrow>\n     (\\<forall>p.\n         is_path v0 p v' \\<longrightarrow>\n         path_weight' (res v') \\<le> Num (path_weight p))\n  \\<forall>v'\\<in>V.\n     \\<forall>p. res v' = Some p \\<longrightarrow> is_path v0 p v'\n\ngoal (1 subgoal):\n 1. update_pre v (wl - {v}, res)", "by (auto simp: update_pre_def)"], ["proof (state)\nthis:\n  update_pre v (wl - {v}, res)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 5. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 5. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "fix res"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 5. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "assume \"dinvar ({}, res)\""], ["proof (state)\nthis:\n  dinvar ({}, res)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a\n 5. \\<And>b x1 x2.\n       \\<lbrakk>dinvar ({}, b);\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> is_shortest_path_map v0 b", "thus \"is_shortest_path_map v0 res\""], ["proof (prove)\nusing this:\n  dinvar ({}, res)\n\ngoal (1 subgoal):\n 1. is_shortest_path_map v0 res", "by (rule invar_imp_correct)"], ["proof (state)\nthis:\n  is_shortest_path_map v0 res\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n 2. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 4. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "show \"wf (inv_image {(x, y). x < y} (card \\<circ> fst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image {(x, y). x < y} (card \\<circ> fst))", "by (blast intro: wf_less)"], ["proof (state)\nthis:\n  wf (inv_image {(x, y). x < y} (card \\<circ> fst))\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "fix wl res v \\<sigma>''"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "assume \n      LM: \"v\\<in>least_map (path_weight' \\<circ> res) wl\" and \n      UD: \"update_spec v (wl-{v},res) \\<sigma>''\" and\n      INV: \"dinvar (wl,res)\""], ["proof (state)\nthis:\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n  update_spec v (wl - {v}, res) \\<sigma>''\n  dinvar (wl, res)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "from LM"], ["proof (chain)\npicking this:\n  v \\<in> least_map (path_weight' \\<circ> res) wl", "have \"v\\<in>wl\""], ["proof (prove)\nusing this:\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n\ngoal (1 subgoal):\n 1. v \\<in> wl", "by (auto dest: least_map_elemD)"], ["proof (state)\nthis:\n  v \\<in> wl\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "moreover"], ["proof (state)\nthis:\n  v \\<in> wl\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "from UD"], ["proof (chain)\npicking this:\n  update_spec v (wl - {v}, res) \\<sigma>''", "have \"fst \\<sigma>'' = wl-{v}\""], ["proof (prove)\nusing this:\n  update_spec v (wl - {v}, res) \\<sigma>''\n\ngoal (1 subgoal):\n 1. fst \\<sigma>'' = wl - {v}", "by (auto elim: update_spec.cases)"], ["proof (state)\nthis:\n  fst \\<sigma>'' = wl - {v}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "moreover"], ["proof (state)\nthis:\n  fst \\<sigma>'' = wl - {v}\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "from INV"], ["proof (chain)\npicking this:\n  dinvar (wl, res)", "have \"finite wl\""], ["proof (prove)\nusing this:\n  dinvar (wl, res)\n\ngoal (1 subgoal):\n 1. finite wl", "unfolding dinvar_def"], ["proof (prove)\nusing this:\n  let (wl, res) = (wl, res)\n  in wl \\<subseteq> V \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>p.\n            res v = Some p \\<longrightarrow>\n            is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl) \\<and>\n     (\\<forall>v\\<in>V - wl.\n         \\<forall>p.\n            is_path v0 p v \\<longrightarrow>\n            path_weight' (res v) \\<le> path_weight' (Some p)) \\<and>\n     (\\<forall>v\\<in>wl.\n         \\<forall>p.\n            is_path v0 p v \\<and>\n            int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n            path_weight' (res v) \\<le> path_weight' (Some p))\n\ngoal (1 subgoal):\n 1. finite wl", "by (auto dest: finite_subset)"], ["proof (state)\nthis:\n  finite wl\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb\n 3. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> card (fst xb) < card a", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> wl\n  fst \\<sigma>'' = wl - {v}\n  finite wl", "show \"card (fst \\<sigma>'') < card wl\""], ["proof (prove)\nusing this:\n  v \\<in> wl\n  fst \\<sigma>'' = wl - {v}\n  finite wl\n\ngoal (1 subgoal):\n 1. card (fst \\<sigma>'') < card wl", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> wl; fst \\<sigma>'' = wl - {v}; finite wl\\<rbrakk>\n    \\<Longrightarrow> card wl - Suc 0 < card wl", "by (metis card_gt_0_iff diff_Suc_less empty_iff)"], ["proof (state)\nthis:\n  card (fst \\<sigma>'') < card wl\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "fix a and res :: \"'V \\<rightharpoonup> ('V,'W) path\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "assume \"a = V \\<and> res v0 = Some [] \\<and> (\\<forall>v\\<in>V-{v0}. res v = None)\""], ["proof (state)\nthis:\n  a = V \\<and>\n  res v0 = Some [] \\<and> (\\<forall>v\\<in>V - {v0}. res v = None)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       x1 = V \\<and>\n       x2 v0 = Some [] \\<and>\n       (\\<forall>v\\<in>V - {v0}. x2 v = None) \\<Longrightarrow>\n       dinvar (V, x2)\n 2. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "thus \"dinvar (V,res)\""], ["proof (prove)\nusing this:\n  a = V \\<and>\n  res v0 = Some [] \\<and> (\\<forall>v\\<in>V - {v0}. res v = None)\n\ngoal (1 subgoal):\n 1. dinvar (V, res)", "by (force simp: dinvar_def split: option.split)"], ["proof (state)\nthis:\n  dinvar (V, res)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "fix wl res"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "assume INV: \"dinvar (wl,res)\""], ["proof (state)\nthis:\n  dinvar (wl, res)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "hence  \n      WL_SUBSET: \"wl \\<subseteq> V\" and\n      PATH_VALID: \"\\<forall>v\\<in>V. \\<forall>p. res v = Some p \n        \\<longrightarrow> is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl\" and\n      NWL_MIN: \"\\<forall>v\\<in>V - wl. \\<forall>p. is_path v0 p v \n        \\<longrightarrow> path_weight' (res v) \\<le> Num (path_weight p)\" and\n      WL_MIN: \"\\<forall>v\\<in>wl. \\<forall>p. is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl \n        \\<longrightarrow> path_weight' (res v) \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  dinvar (wl, res)\n\ngoal (1 subgoal):\n 1. (wl \\<subseteq> V &&&\n     \\<forall>v\\<in>V.\n        \\<forall>p.\n           res v = Some p \\<longrightarrow>\n           is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl) &&&\n    \\<forall>v\\<in>V - wl.\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res v) \\<le> Num (path_weight p) &&&\n    \\<forall>v\\<in>wl.\n       \\<forall>p.\n          is_path v0 p v \\<and>\n          int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n          path_weight' (res v) \\<le> Num (path_weight p)", "unfolding dinvar_def"], ["proof (prove)\nusing this:\n  let (wl, res) = (wl, res)\n  in wl \\<subseteq> V \\<and>\n     (\\<forall>v\\<in>V.\n         \\<forall>p.\n            res v = Some p \\<longrightarrow>\n            is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl) \\<and>\n     (\\<forall>v\\<in>V - wl.\n         \\<forall>p.\n            is_path v0 p v \\<longrightarrow>\n            path_weight' (res v) \\<le> path_weight' (Some p)) \\<and>\n     (\\<forall>v\\<in>wl.\n         \\<forall>p.\n            is_path v0 p v \\<and>\n            int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n            path_weight' (res v) \\<le> path_weight' (Some p))\n\ngoal (1 subgoal):\n 1. (wl \\<subseteq> V &&&\n     \\<forall>v\\<in>V.\n        \\<forall>p.\n           res v = Some p \\<longrightarrow>\n           is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl) &&&\n    \\<forall>v\\<in>V - wl.\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res v) \\<le> Num (path_weight p) &&&\n    \\<forall>v\\<in>wl.\n       \\<forall>p.\n          is_path v0 p v \\<and>\n          int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n          path_weight' (res v) \\<le> Num (path_weight p)", "by auto"], ["proof (state)\nthis:\n  wl \\<subseteq> V\n  \\<forall>v\\<in>V.\n     \\<forall>p.\n        res v = Some p \\<longrightarrow>\n        is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl\n  \\<forall>v\\<in>V - wl.\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n  \\<forall>v\\<in>wl.\n     \\<forall>p.\n        is_path v0 p v \\<and>\n        int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "fix v \\<sigma>''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "assume V_LEAST: \"v\\<in>least_map (path_weight' o res) wl\" \n      and \"update_spec v (wl-{v},res) \\<sigma>''\""], ["proof (state)\nthis:\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n  update_spec v (wl - {v}, res) \\<sigma>''\n\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "then"], ["proof (chain)\npicking this:\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n  update_spec v (wl - {v}, res) \\<sigma>''", "obtain res' where\n      [simp]: \"\\<sigma>''=(wl-{v},res')\"\n      and CONSIDERED_NEW_PATHS: \"\\<forall>v'\\<in>V. res' v' \\<in> least_map path_weight' \n        (insert (res v') \n              ({ Some (p@[(v,w,v')]) | p w. res v = Some p \\<and> (v,w,v')\\<in>E }))\""], ["proof (prove)\nusing this:\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n  update_spec v (wl - {v}, res) \\<sigma>''\n\ngoal (1 subgoal):\n 1. (\\<And>res'.\n        \\<lbrakk>\\<sigma>'' = (wl - {v}, res');\n         \\<forall>v'\\<in>V.\n            res' v'\n            \\<in> least_map path_weight'\n                   (insert (res v')\n                     {Some (p @ [(v, w, v')]) |p w.\n                      res v = Some p \\<and> (v, w, v') \\<in> E})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: update_spec.cases)"], ["proof (state)\nthis:\n  \\<sigma>'' = (wl - {v}, res')\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "from V_LEAST"], ["proof (chain)\npicking this:\n  v \\<in> least_map (path_weight' \\<circ> res) wl", "have V_MEM: \"v\\<in>wl\""], ["proof (prove)\nusing this:\n  v \\<in> least_map (path_weight' \\<circ> res) wl\n\ngoal (1 subgoal):\n 1. v \\<in> wl", "by (blast intro: least_map_elemD)"], ["proof (state)\nthis:\n  v \\<in> wl\n\ngoal (1 subgoal):\n 1. \\<And>a b aa xb x1 x2.\n       \\<lbrakk>dinvar (a, b); a \\<noteq> {};\n        aa \\<in> least_map (path_weight' \\<circ> b) a;\n        update_pre aa (a - {aa}, b); update_spec aa (a - {aa}, b) xb;\n        x1 = V \\<and>\n        x2 v0 = Some [] \\<and>\n        (\\<forall>v\\<in>V - {v0}. x2 v = None)\\<rbrakk>\n       \\<Longrightarrow> dinvar xb", "show \"dinvar \\<sigma>''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dinvar \\<sigma>''", "apply (unfold dinvar_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wl - {v} \\<subseteq> V \\<and>\n    (\\<forall>va\\<in>V.\n        \\<forall>p.\n           res' va = Some p \\<longrightarrow>\n           is_path v0 p va \\<and>\n           int_vertices p \\<subseteq> V - (wl - {v})) \\<and>\n    (\\<forall>v\\<in>V - (wl - {v}).\n        \\<forall>p.\n           is_path v0 p v \\<longrightarrow>\n           path_weight' (res' v) \\<le> Num (path_weight p)) \\<and>\n    (\\<forall>va\\<in>wl - {v}.\n        \\<forall>p.\n           is_path v0 p va \\<and>\n           int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n           path_weight' (res' va) \\<le> Num (path_weight p))", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. wl - {v} \\<subseteq> V\n 2. \\<forall>va\\<in>V.\n       \\<forall>p.\n          res' va = Some p \\<longrightarrow>\n          is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})\n 3. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 4. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. wl - {v} \\<subseteq> V\n 2. \\<forall>va\\<in>V.\n       \\<forall>p.\n          res' va = Some p \\<longrightarrow>\n          is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})\n 3. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 4. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "from WL_SUBSET"], ["proof (chain)\npicking this:\n  wl \\<subseteq> V", "show \"wl-{v} \\<subseteq> V\""], ["proof (prove)\nusing this:\n  wl \\<subseteq> V\n\ngoal (1 subgoal):\n 1. wl - {v} \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  wl - {v} \\<subseteq> V\n\ngoal (3 subgoals):\n 1. \\<forall>va\\<in>V.\n       \\<forall>p.\n          res' va = Some p \\<longrightarrow>\n          is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})\n 2. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 3. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "show \"\\<forall>va\\<in>V. \\<forall>p. res' va = Some p \n        \\<longrightarrow> is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>va\\<in>V.\n       \\<forall>p.\n          res' va = Some p \\<longrightarrow>\n          is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})", "proof (intro ballI conjI impI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "fix v' p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "assume V'_MEM: \"v'\\<in>V\" and [simp]: \"res' v' = Some p\""], ["proof (state)\nthis:\n  v' \\<in> V\n  res' v' = Some p\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "txt \\<open>The new paths that we have added are valid and only use \n          intermediate vertices outside the workset. \n          \n          This proof works as follows: A path @{term \"res' v'\"} is either\n          the old path, or has been assembled as a path over node @{term v}.\n          In the former case the proposition follows straightforwardly from the\n          invariant for the old state. In the latter case we get, by the invariant\n          for the old state, that the path over node @{term v} is valid. \n          Then, we observe that appending an edge to a valid path yields a valid \n          path again. Also, adding @{term v} as intermediate node is legal, as we \n          just removed @{term v} from the workset.\n\\<close>"], ["proof (state)\nthis:\n  v' \\<in> V\n  res' v' = Some p\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "with CONSIDERED_NEW_PATHS"], ["proof (chain)\npicking this:\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})\n  v' \\<in> V\n  res' v' = Some p", "have \"res' v' \\<in> (insert (res v') \n          ({ Some (p@[(v,w,v')]) | p w. res v = Some p \\<and> (v,w,v')\\<in>E }))\""], ["proof (prove)\nusing this:\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})\n  v' \\<in> V\n  res' v' = Some p\n\ngoal (1 subgoal):\n 1. res' v'\n    \\<in> insert (res v')\n           {Some (p @ [(v, w, v')]) |p w.\n            res v = Some p \\<and> (v, w, v') \\<in> E}", "by (rule_tac least_map_elemD) blast"], ["proof (state)\nthis:\n  res' v'\n  \\<in> insert (res v')\n         {Some (p @ [(v, w, v')]) |p w.\n          res v = Some p \\<and> (v, w, v') \\<in> E}\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "moreover"], ["proof (state)\nthis:\n  res' v'\n  \\<in> insert (res v')\n         {Some (p @ [(v, w, v')]) |p w.\n          res v = Some p \\<and> (v, w, v') \\<in> E}\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "{"], ["proof (state)\nthis:\n  res' v'\n  \\<in> insert (res v')\n         {Some (p @ [(v, w, v')]) |p w.\n          res v = Some p \\<and> (v, w, v') \\<in> E}\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "assume [symmetric,simp]: \"res' v' = res v'\""], ["proof (state)\nthis:\n  res v' = res' v'\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "from V'_MEM PATH_VALID"], ["proof (chain)\npicking this:\n  v' \\<in> V\n  \\<forall>v\\<in>V.\n     \\<forall>p.\n        res v = Some p \\<longrightarrow>\n        is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl", "have \n            \"is_path v0 p v'\" \n            \"int_vertices p \\<subseteq> V - (wl-{v})\""], ["proof (prove)\nusing this:\n  v' \\<in> V\n  \\<forall>v\\<in>V.\n     \\<forall>p.\n        res v = Some p \\<longrightarrow>\n        is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl\n\ngoal (1 subgoal):\n 1. is_path v0 p v' &&& int_vertices p \\<subseteq> V - (wl - {v})", "by force+"], ["proof (state)\nthis:\n  is_path v0 p v'\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "}"], ["proof (state)\nthis:\n  res' v' = res v' \\<Longrightarrow> is_path v0 p v'\n  res' v' = res v' \\<Longrightarrow>\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "moreover"], ["proof (state)\nthis:\n  res' v' = res v' \\<Longrightarrow> is_path v0 p v'\n  res' v' = res v' \\<Longrightarrow>\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "{"], ["proof (state)\nthis:\n  res' v' = res v' \\<Longrightarrow> is_path v0 p v'\n  res' v' = res v' \\<Longrightarrow>\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "fix pv w"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "assume \"res' v' = Some (pv@[(v,w,v')])\" \n            and [simp]: \"res v = Some pv\" \n            and EDGE: \"(v,w,v')\\<in>E\""], ["proof (state)\nthis:\n  res' v' = Some (pv @ [(v, w, v')])\n  res v = Some pv\n  (v, w, v') \\<in> E\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "hence [simp]: \"p = pv@[(v,w,v')]\""], ["proof (prove)\nusing this:\n  res' v' = Some (pv @ [(v, w, v')])\n  res v = Some pv\n  (v, w, v') \\<in> E\n\ngoal (1 subgoal):\n 1. p = pv @ [(v, w, v')]", "by simp"], ["proof (state)\nthis:\n  p = pv @ [(v, w, v')]\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "from bspec[OF PATH_VALID rev_subsetD[OF V_MEM WL_SUBSET]]"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     res v = Some p \\<longrightarrow>\n     is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl", "have \n            PATHV: \"is_path v0 pv v\" and IVV: \"int_vertices pv \\<subseteq> V - wl\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     res v = Some p \\<longrightarrow>\n     is_path v0 p v \\<and> int_vertices p \\<subseteq> V - wl\n\ngoal (1 subgoal):\n 1. is_path v0 pv v &&& int_vertices pv \\<subseteq> V - wl", "by auto"], ["proof (state)\nthis:\n  is_path v0 pv v\n  int_vertices pv \\<subseteq> V - wl\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "hence \n            \"is_path v0 p v'\" \n            \"int_vertices p \\<subseteq> V - (wl-{v})\""], ["proof (prove)\nusing this:\n  is_path v0 pv v\n  int_vertices pv \\<subseteq> V - wl\n\ngoal (1 subgoal):\n 1. is_path v0 p v' &&& int_vertices p \\<subseteq> V - (wl - {v})", "by (auto simp: EDGE V'_MEM)"], ["proof (state)\nthis:\n  is_path v0 p v'\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>res' v' = Some (?pv2 @ [(v, ?w2, v')]); res v = Some ?pv2;\n   (v, ?w2, v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> is_path v0 p v'\n  \\<lbrakk>res' v' = Some (?pv2 @ [(v, ?w2, v')]); res v = Some ?pv2;\n   (v, ?w2, v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> is_path v0 p va\n 2. \\<And>va p.\n       \\<lbrakk>va \\<in> V; res' va = Some p\\<rbrakk>\n       \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "ultimately"], ["proof (chain)\npicking this:\n  res' v'\n  \\<in> insert (res v')\n         {Some (p @ [(v, w, v')]) |p w.\n          res v = Some p \\<and> (v, w, v') \\<in> E}\n  res' v' = res v' \\<Longrightarrow> is_path v0 p v'\n  res' v' = res v' \\<Longrightarrow>\n  int_vertices p \\<subseteq> V - (wl - {v})\n  \\<lbrakk>res' v' = Some (?pv2 @ [(v, ?w2, v')]); res v = Some ?pv2;\n   (v, ?w2, v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> is_path v0 p v'\n  \\<lbrakk>res' v' = Some (?pv2 @ [(v, ?w2, v')]); res v = Some ?pv2;\n   (v, ?w2, v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})", "show \n          \"is_path v0 p v'\" \n          \"int_vertices p \\<subseteq> V - (wl-{v})\""], ["proof (prove)\nusing this:\n  res' v'\n  \\<in> insert (res v')\n         {Some (p @ [(v, w, v')]) |p w.\n          res v = Some p \\<and> (v, w, v') \\<in> E}\n  res' v' = res v' \\<Longrightarrow> is_path v0 p v'\n  res' v' = res v' \\<Longrightarrow>\n  int_vertices p \\<subseteq> V - (wl - {v})\n  \\<lbrakk>res' v' = Some (?pv2 @ [(v, ?w2, v')]); res v = Some ?pv2;\n   (v, ?w2, v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> is_path v0 p v'\n  \\<lbrakk>res' v' = Some (?pv2 @ [(v, ?w2, v')]); res v = Some ?pv2;\n   (v, ?w2, v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (1 subgoal):\n 1. is_path v0 p v' &&& int_vertices p \\<subseteq> V - (wl - {v})", "by blast+"], ["proof (state)\nthis:\n  is_path v0 p v'\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>va\\<in>V.\n     \\<forall>p.\n        res' va = Some p \\<longrightarrow>\n        is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 2. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "txt \\<open>\n        We show that already the {\\em original} result stores the minimal \n        path for all vertices not in the {\\em new} workset. \n        For vertices also not in the original workset, this follows \n        straightforwardly from the invariant.\n        \n        For the vertex \\<open>v\\<close>, that has been removed from the\n        workset, we split a path \\<open>p'\\<close> to \\<open>v\\<close> at the point\n        \\<open>u\\<close> where it first enters the original workset.  \n\n        As we chose \\<open>v\\<close> to be the vertex in the workset with the\n        minimal weight, its weight is less than the current weight of\n        \\<open>u\\<close>.  As the vertices of the prefix of \\<open>p'\\<close> up to\n        \\<open>u\\<close> are not in the workset, the current weight of\n        \\<open>u\\<close> is less than the weight of the prefix of \\<open>p'\\<close>, and thus less than the weight of \\<open>p'\\<close>. \n        Together, the current weight of \\<open>v\\<close> is less than the weight of\n        \\<open>p'\\<close>.\\<close>"], ["proof (state)\nthis:\n  \\<forall>va\\<in>V.\n     \\<forall>p.\n        res' va = Some p \\<longrightarrow>\n        is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (2 subgoals):\n 1. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 2. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "have RES_MIN: \"\\<forall>v\\<in>V - (wl - {v}). \\<forall>p. is_path v0 p v \n        \\<longrightarrow> path_weight' (res v) \\<le> Num (path_weight p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res v) \\<le> Num (path_weight p)", "proof (intro ballI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res va) \\<le> Num (path_weight p)", "fix v' p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res va) \\<le> Num (path_weight p)", "assume NOT_IN_WL: \"v' \\<in> V - (wl - {v})\" \n          and PATH: \"is_path v0 p' v'\""], ["proof (state)\nthis:\n  v' \\<in> V - (wl - {v})\n  is_path v0 p' v'\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res va) \\<le> Num (path_weight p)", "hence [simp, intro!]: \"v'\\<in>V\""], ["proof (prove)\nusing this:\n  v' \\<in> V - (wl - {v})\n  is_path v0 p' v'\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by auto"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res va) \\<le> Num (path_weight p)", "show \"path_weight' (res v') \\<le> Num (path_weight p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight p')", "proof (cases \"v' = v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')\n 2. v' \\<noteq> v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "assume NE[simp]: \"v'\\<noteq>v\""], ["proof (state)\nthis:\n  v' \\<noteq> v\n\ngoal (2 subgoals):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')\n 2. v' \\<noteq> v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "from bspec[OF NWL_MIN, of v'] NOT_IN_WL PATH"], ["proof (chain)\npicking this:\n  v' \\<in> V - wl \\<Longrightarrow>\n  \\<forall>p.\n     is_path v0 p v' \\<longrightarrow>\n     path_weight' (res v') \\<le> Num (path_weight p)\n  v' \\<in> V - (wl - {v})\n  is_path v0 p' v'", "show\n            \"path_weight' (res v') \\<le> Num (path_weight p')\""], ["proof (prove)\nusing this:\n  v' \\<in> V - wl \\<Longrightarrow>\n  \\<forall>p.\n     is_path v0 p v' \\<longrightarrow>\n     path_weight' (res v') \\<le> Num (path_weight p)\n  v' \\<in> V - (wl - {v})\n  is_path v0 p' v'\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight p')", "by auto"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight p')\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "assume EQ[simp]: \"v'=v\""], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "from path_split_set'[OF PATH, of wl] V_MEM"], ["proof (chain)\npicking this:\n  \\<lbrakk>v' \\<in> wl;\n   \\<And>p1 p2 u.\n      \\<lbrakk>p' = p1 @ p2; is_path v0 p1 u; is_path u p2 v';\n       int_vertices p1 \\<subseteq> - wl; u \\<in> wl\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  v \\<in> wl", "obtain p1 p2 u where\n            [simp]: \"p'=p1@p2\" \n              and P1: \"is_path v0 p1 u\" \n              and P2: \"is_path u p2 v'\" \n              and P1V: \"int_vertices p1 \\<subseteq> -wl\" \n              and [simp]: \"u\\<in>wl\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v' \\<in> wl;\n   \\<And>p1 p2 u.\n      \\<lbrakk>p' = p1 @ p2; is_path v0 p1 u; is_path u p2 v';\n       int_vertices p1 \\<subseteq> - wl; u \\<in> wl\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  v \\<in> wl\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2 u.\n        \\<lbrakk>p' = p1 @ p2; is_path v0 p1 u; is_path u p2 v';\n         int_vertices p1 \\<subseteq> - wl; u \\<in> wl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p' = p1 @ p2\n  is_path v0 p1 u\n  is_path u p2 v'\n  int_vertices p1 \\<subseteq> - wl\n  u \\<in> wl\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "from least_map_leD[OF V_LEAST]"], ["proof (chain)\npicking this:\n  ?y \\<in> wl \\<Longrightarrow>\n  (path_weight' \\<circ> res) v \\<le> (path_weight' \\<circ> res) ?y", "have \"path_weight' (res v') \\<le> path_weight' (res u)\""], ["proof (prove)\nusing this:\n  ?y \\<in> wl \\<Longrightarrow>\n  (path_weight' \\<circ> res) v \\<le> (path_weight' \\<circ> res) ?y\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> path_weight' (res u)", "by auto"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> path_weight' (res u)\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "also"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> path_weight' (res u)\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "from bspec[OF WL_MIN, of u] P1 P1V int_vertices_subset[OF P1]"], ["proof (chain)\npicking this:\n  u \\<in> wl \\<Longrightarrow>\n  \\<forall>p.\n     is_path v0 p u \\<and>\n     int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n     path_weight' (res u) \\<le> Num (path_weight p)\n  is_path v0 p1 u\n  int_vertices p1 \\<subseteq> - wl\n  int_vertices p1 \\<subseteq> V", "have \"path_weight' (res u) \\<le> Num (path_weight p1)\""], ["proof (prove)\nusing this:\n  u \\<in> wl \\<Longrightarrow>\n  \\<forall>p.\n     is_path v0 p u \\<and>\n     int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n     path_weight' (res u) \\<le> Num (path_weight p)\n  is_path v0 p1 u\n  int_vertices p1 \\<subseteq> - wl\n  int_vertices p1 \\<subseteq> V\n\ngoal (1 subgoal):\n 1. path_weight' (res u) \\<le> Num (path_weight p1)", "by auto"], ["proof (state)\nthis:\n  path_weight' (res u) \\<le> Num (path_weight p1)\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "also"], ["proof (state)\nthis:\n  path_weight' (res u) \\<le> Num (path_weight p1)\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "have \"\\<dots> \\<le> Num (path_weight p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Num (path_weight p1) \\<le> Num (path_weight p')", "using path_nonneg_weight[OF P2]"], ["proof (prove)\nusing this:\n  (0::'W) \\<le> path_weight p2\n\ngoal (1 subgoal):\n 1. Num (path_weight p1) \\<le> Num (path_weight p')", "apply (auto simp: infty_unbox )"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'W) \\<le> path_weight p2 \\<Longrightarrow>\n    path_weight p1 \\<le> path_weight p1 + path_weight p2", "by (metis add_0_right add_left_mono)"], ["proof (state)\nthis:\n  Num (path_weight p1) \\<le> Num (path_weight p')\n\ngoal (1 subgoal):\n 1. v' = v \\<Longrightarrow>\n    path_weight' (res v') \\<le> Num (path_weight p')", "finally"], ["proof (chain)\npicking this:\n  path_weight' (res v') \\<le> Num (path_weight p')", "show ?thesis"], ["proof (prove)\nusing this:\n  path_weight' (res v') \\<le> Num (path_weight p')\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight p')", "."], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight p')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight p')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V - (wl - {v}).\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n\ngoal (2 subgoals):\n 1. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 2. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "txt \\<open>With the previous statement, we easily show the\n        third part of the invariant, as the new paths are not longer than the\n        old ones.\n\\<close>"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V - (wl - {v}).\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n\ngoal (2 subgoals):\n 1. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)\n 2. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "show \"\\<forall>v\\<in>V - (wl - {v}). \\<forall>p. is_path v0 p v \n        \\<longrightarrow> path_weight' (res' v) \\<le> Num (path_weight p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - (wl - {v}).\n       \\<forall>p.\n          is_path v0 p v \\<longrightarrow>\n          path_weight' (res' v) \\<le> Num (path_weight p)", "proof (intro allI ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "fix v' p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "assume NOT_IN_WL: \"v' \\<in> V - (wl - {v})\" \n          and PATH: \"is_path v0 p v'\""], ["proof (state)\nthis:\n  v' \\<in> V - (wl - {v})\n  is_path v0 p v'\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "hence [simp, intro!]: \"v'\\<in>V\""], ["proof (prove)\nusing this:\n  v' \\<in> V - (wl - {v})\n  is_path v0 p v'\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by auto"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from bspec[OF CONSIDERED_NEW_PATHS, of v']"], ["proof (chain)\npicking this:\n  v' \\<in> V \\<Longrightarrow>\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (p @ [(v, w, v')]) |p w.\n            res v = Some p \\<and> (v, w, v') \\<in> E})", "have \"path_weight' (res' v') \\<le> path_weight' (res v')\""], ["proof (prove)\nusing this:\n  v' \\<in> V \\<Longrightarrow>\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (p @ [(v, w, v')]) |p w.\n            res v = Some p \\<and> (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res v')", "by (auto dest: least_map_leD)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "also"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from bspec[OF RES_MIN NOT_IN_WL] PATH"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     is_path v0 p v' \\<longrightarrow>\n     path_weight' (res v') \\<le> Num (path_weight p)\n  is_path v0 p v'", "have \"path_weight' (res v') \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     is_path v0 p v' \\<longrightarrow>\n     path_weight' (res v') \\<le> Num (path_weight p)\n  is_path v0 p v'\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight p)", "by blast"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> V - (wl - {v}); is_path v0 p va\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "finally"], ["proof (chain)\npicking this:\n  path_weight' (res' v') \\<le> Num (path_weight p)", "show \"path_weight' (res' v') \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> Num (path_weight p)", "."], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V - (wl - {v}).\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res' v) \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "txt \\<open>\n        Finally, we have to show that for nodes on the worklist,\n        the stored paths are not longer than any path using only nodes not\n        on the worklist. Compared to the situation before the step, those\n        path may also use the node \\<open>v\\<close>.\n\\<close>"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V - (wl - {v}).\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res' v) \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "show \"\\<forall>va\\<in>wl - {v}. \\<forall>p. \n        is_path v0 p va \\<and> int_vertices p \\<subseteq> V - (wl - {v}) \n        \\<longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>va\\<in>wl - {v}.\n       \\<forall>p.\n          is_path v0 p va \\<and>\n          int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n          path_weight' (res' va) \\<le> Num (path_weight p)", "proof (intro allI impI ballI, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "fix v' p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "assume IWS: \"v'\\<in>wl - {v}\" \n          and PATH: \"is_path v0 p v'\" \n          and VERTICES: \"int_vertices p \\<subseteq> V - (wl - {v})\""], ["proof (state)\nthis:\n  v' \\<in> wl - {v}\n  is_path v0 p v'\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from IWS WL_SUBSET"], ["proof (chain)\npicking this:\n  v' \\<in> wl - {v}\n  wl \\<subseteq> V", "have [simp, intro!]: \"v'\\<in>V\""], ["proof (prove)\nusing this:\n  v' \\<in> wl - {v}\n  wl \\<subseteq> V\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by auto"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "{"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "txt \\<open>\n            If the path is empty, the proposition follows easily from the\n            invariant for the original states, as no intermediate nodes are \n            used at all.\n\\<close>"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "assume [simp]: \"p=[]\""], ["proof (state)\nthis:\n  p = []\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from bspec[OF CONSIDERED_NEW_PATHS, of v']"], ["proof (chain)\npicking this:\n  v' \\<in> V \\<Longrightarrow>\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (p @ [(v, w, v')]) |p w.\n            res v = Some p \\<and> (v, w, v') \\<in> E})", "have\n            \"path_weight' (res' v') \\<le> path_weight' (res v')\""], ["proof (prove)\nusing this:\n  v' \\<in> V \\<Longrightarrow>\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (p @ [(v, w, v')]) |p w.\n            res v = Some p \\<and> (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res v')", "using IWS WL_SUBSET"], ["proof (prove)\nusing this:\n  v' \\<in> V \\<Longrightarrow>\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (p @ [(v, w, v')]) |p w.\n            res v = Some p \\<and> (v, w, v') \\<in> E})\n  v' \\<in> wl - {v}\n  wl \\<subseteq> V\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res v')", "by (auto dest: least_map_leD)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "also"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "have \"int_vertices p \\<subseteq> V-wl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_vertices p \\<subseteq> V - wl", "by auto"], ["proof (state)\nthis:\n  int_vertices p \\<subseteq> V - wl\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "with WL_MIN IWS PATH"], ["proof (chain)\npicking this:\n  \\<forall>v\\<in>wl.\n     \\<forall>p.\n        is_path v0 p v \\<and>\n        int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n  v' \\<in> wl - {v}\n  is_path v0 p v'\n  int_vertices p \\<subseteq> V - wl", "have \"path_weight' (res v') \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>wl.\n     \\<forall>p.\n        is_path v0 p v \\<and>\n        int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n  v' \\<in> wl - {v}\n  is_path v0 p v'\n  int_vertices p \\<subseteq> V - wl\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight p)", "by (auto simp del: path_weight_empty)"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "finally"], ["proof (chain)\npicking this:\n  path_weight' (res' v') \\<le> Num (path_weight p)", "have \"path_weight' (res' v') \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> Num (path_weight p)", "."], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "}"], ["proof (state)\nthis:\n  p = [] \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "moreover"], ["proof (state)\nthis:\n  p = [] \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "{"], ["proof (state)\nthis:\n  p = [] \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "fix p1 u w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "assume [simp]: \"p = p1@[(u,w,v')]\""], ["proof (state)\nthis:\n  p = p1 @ [(u, w, v')]\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "txt \\<open>If the path is not empty, we pick the last but one vertex, and\n            call it @{term u}.\\<close>"], ["proof (state)\nthis:\n  p = p1 @ [(u, w, v')]\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from PATH"], ["proof (chain)\npicking this:\n  is_path v0 p v'", "have PATH1: \"is_path v0 p1 u\" and EDGE: \"(u,w,v')\\<in>E\""], ["proof (prove)\nusing this:\n  is_path v0 p v'\n\ngoal (1 subgoal):\n 1. is_path v0 p1 u &&& (u, w, v') \\<in> E", "by auto"], ["proof (state)\nthis:\n  is_path v0 p1 u\n  (u, w, v') \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from VERTICES"], ["proof (chain)\npicking this:\n  int_vertices p \\<subseteq> V - (wl - {v})", "have NIV: \"u\\<in>V - (wl-{v})\""], ["proof (prove)\nusing this:\n  int_vertices p \\<subseteq> V - (wl - {v})\n\ngoal (1 subgoal):\n 1. u \\<in> V - (wl - {v})", "by simp"], ["proof (state)\nthis:\n  u \\<in> V - (wl - {v})\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "hence U_MEM[simp]: \"u\\<in>V\""], ["proof (prove)\nusing this:\n  u \\<in> V - (wl - {v})\n\ngoal (1 subgoal):\n 1. u \\<in> V", "by auto"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "txt \\<open>From @{thm [source] RES_MIN}, we know that @{term \"res u\"} holds\n            the shortest path to @{term u}. Thus \\<open>p\\<close> is longer than the \n            path that is constructed by replacing the prefix of @{term p} by \n            {term \"res u\"}\\<close>"], ["proof (state)\nthis:\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from NIV RES_MIN PATH1"], ["proof (chain)\npicking this:\n  u \\<in> V - (wl - {v})\n  \\<forall>v\\<in>V - (wl - {v}).\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n  is_path v0 p1 u", "have G: \"Num (path_weight p1) \\<ge> path_weight' (res u)\""], ["proof (prove)\nusing this:\n  u \\<in> V - (wl - {v})\n  \\<forall>v\\<in>V - (wl - {v}).\n     \\<forall>p.\n        is_path v0 p v \\<longrightarrow>\n        path_weight' (res v) \\<le> Num (path_weight p)\n  is_path v0 p1 u\n\ngoal (1 subgoal):\n 1. path_weight' (res u) \\<le> Num (path_weight p1)", "by simp"], ["proof (state)\nthis:\n  path_weight' (res u) \\<le> Num (path_weight p1)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "then"], ["proof (chain)\npicking this:\n  path_weight' (res u) \\<le> Num (path_weight p1)", "obtain pu where [simp]: \"res u = Some pu\""], ["proof (prove)\nusing this:\n  path_weight' (res u) \\<le> Num (path_weight p1)\n\ngoal (1 subgoal):\n 1. (\\<And>pu. res u = Some pu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"res u\") (auto simp: infty_unbox)"], ["proof (state)\nthis:\n  res u = Some pu\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "from G"], ["proof (chain)\npicking this:\n  path_weight' (res u) \\<le> Num (path_weight p1)", "have \"Num (path_weight p) \\<ge> path_weight' (res u) + Num w\""], ["proof (prove)\nusing this:\n  path_weight' (res u) \\<le> Num (path_weight p1)\n\ngoal (1 subgoal):\n 1. path_weight' (res u) + Num w \\<le> Num (path_weight p)", "by (auto simp: infty_unbox add_right_mono)"], ["proof (state)\nthis:\n  path_weight' (res u) + Num w \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "also"], ["proof (state)\nthis:\n  path_weight' (res u) + Num w \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "have \"path_weight' (res u) + Num w \\<ge> path_weight' (res' v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "txt \\<open>\n              The remaining argument depends on wether @{term u} \n              equals @{term v}. \n              In the case @{term \"u\\<noteq>v\"}, all vertices of @{term \"res u\"} are\n              outside the original workset. Thus, appending the edge \n              @{term \"(u,w,v')\"} to @{term \"res u\"} yields a path to @{term v}\n              over intermediate nodes only outside the workset. By the invariant\n              for the original state, @{term \"res v'\"} is shorter than this path.\n              As a step does not replace paths by longer ones, also \n              @{term \"res' v'\"} is shorter.\n\n              In the case @{term \"u=v\"}, the step has\n              considered the path to \\<open>v'\\<close> over \\<open>v\\<close>, and thus the\n              result path is not longer.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "proof (cases \"u=v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "assume \"u\\<noteq>v\""], ["proof (state)\nthis:\n  u \\<noteq> v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "with NIV"], ["proof (chain)\npicking this:\n  u \\<in> V - (wl - {v})\n  u \\<noteq> v", "have NIV': \"u\\<in>V-wl\""], ["proof (prove)\nusing this:\n  u \\<in> V - (wl - {v})\n  u \\<noteq> v\n\ngoal (1 subgoal):\n 1. u \\<in> V - wl", "by auto"], ["proof (state)\nthis:\n  u \\<in> V - wl\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "from bspec[OF PATH_VALID U_MEM] NIV'"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     res u = Some p \\<longrightarrow>\n     is_path v0 p u \\<and> int_vertices p \\<subseteq> V - wl\n  u \\<in> V - wl", "have \"is_path v0 pu u\" and VU: \"int_vertices (pu@[(u,w,v')]) \\<subseteq> V-wl\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     res u = Some p \\<longrightarrow>\n     is_path v0 p u \\<and> int_vertices p \\<subseteq> V - wl\n  u \\<in> V - wl\n\ngoal (1 subgoal):\n 1. is_path v0 pu u &&& int_vertices (pu @ [(u, w, v')]) \\<subseteq> V - wl", "by auto"], ["proof (state)\nthis:\n  is_path v0 pu u\n  int_vertices (pu @ [(u, w, v')]) \\<subseteq> V - wl\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "with EDGE"], ["proof (chain)\npicking this:\n  (u, w, v') \\<in> E\n  is_path v0 pu u\n  int_vertices (pu @ [(u, w, v')]) \\<subseteq> V - wl", "have PV': \"is_path v0 (pu@[(u,w,v')]) v'\""], ["proof (prove)\nusing this:\n  (u, w, v') \\<in> E\n  is_path v0 pu u\n  int_vertices (pu @ [(u, w, v')]) \\<subseteq> V - wl\n\ngoal (1 subgoal):\n 1. is_path v0 (pu @ [(u, w, v')]) v'", "by auto"], ["proof (state)\nthis:\n  is_path v0 (pu @ [(u, w, v')]) v'\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "with bspec[OF WL_MIN, of v'] IWS VU"], ["proof (chain)\npicking this:\n  v' \\<in> wl \\<Longrightarrow>\n  \\<forall>p.\n     is_path v0 p v' \\<and>\n     int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n     path_weight' (res v') \\<le> Num (path_weight p)\n  v' \\<in> wl - {v}\n  int_vertices (pu @ [(u, w, v')]) \\<subseteq> V - wl\n  is_path v0 (pu @ [(u, w, v')]) v'", "have \n              \"path_weight' (res v') \\<le> Num (path_weight (pu@[(u,w,v')]))\""], ["proof (prove)\nusing this:\n  v' \\<in> wl \\<Longrightarrow>\n  \\<forall>p.\n     is_path v0 p v' \\<and>\n     int_vertices p \\<subseteq> V - wl \\<longrightarrow>\n     path_weight' (res v') \\<le> Num (path_weight p)\n  v' \\<in> wl - {v}\n  int_vertices (pu @ [(u, w, v')]) \\<subseteq> V - wl\n  is_path v0 (pu @ [(u, w, v')]) v'\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight (pu @ [(u, w, v')]))", "by blast"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight (pu @ [(u, w, v')]))\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "hence \"path_weight' (res u) + Num w \\<ge> path_weight' (res v')\""], ["proof (prove)\nusing this:\n  path_weight' (res v') \\<le> Num (path_weight (pu @ [(u, w, v')]))\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> path_weight' (res u) + Num w", "by (auto simp: infty_unbox)"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> path_weight' (res u) + Num w\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "also"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> path_weight' (res u) + Num w\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "from CONSIDERED_NEW_PATHS"], ["proof (chain)\npicking this:\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})", "have \n              \"path_weight' (res v') \\<ge> path_weight' (res' v')\""], ["proof (prove)\nusing this:\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res v')", "by (auto dest: least_map_leD)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n 2. u \\<noteq> v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "finally (order_trans[rotated])"], ["proof (chain)\npicking this:\n  path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "show ?thesis"], ["proof (prove)\nusing this:\n  path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "."], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "assume [symmetric,simp]: \"u=v\""], ["proof (state)\nthis:\n  v = u\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "from CONSIDERED_NEW_PATHS EDGE"], ["proof (chain)\npicking this:\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})\n  (u, w, v') \\<in> E", "have \n              \"path_weight' (res' v') \\<le> path_weight' (Some (pu@[(v,w,v')]))\""], ["proof (prove)\nusing this:\n  \\<forall>v'\\<in>V.\n     res' v'\n     \\<in> least_map path_weight'\n            (insert (res v')\n              {Some (p @ [(v, w, v')]) |p w.\n               res v = Some p \\<and> (v, w, v') \\<in> E})\n  (u, w, v') \\<in> E\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (Some (pu @ [(v, w, v')]))", "by (rule_tac least_map_leD) auto"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (Some (pu @ [(v, w, v')]))\n\ngoal (1 subgoal):\n 1. u = v \\<Longrightarrow>\n    path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "thus ?thesis"], ["proof (prove)\nusing this:\n  path_weight' (res' v') \\<le> path_weight' (Some (pu @ [(v, w, v')]))\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res u) + Num w", "by (auto simp: infty_unbox)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res u) + Num w\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "finally (order_trans[rotated])"], ["proof (chain)\npicking this:\n  path_weight' (res' v') \\<le> Num (path_weight p)", "have \n            \"path_weight' (res' v') \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> Num (path_weight p)", "."], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "}"], ["proof (state)\nthis:\n  p = ?p1.2 @ [(?u2, ?w2, v')] \\<Longrightarrow>\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. \\<And>va p.\n       \\<lbrakk>va \\<in> wl - {v}; is_path v0 p va;\n        int_vertices p \\<subseteq> V - (wl - {v})\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' va) \\<le> Num (path_weight p)", "ultimately"], ["proof (chain)\npicking this:\n  p = [] \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n  p = ?p1.2 @ [(?u2, ?w2, v')] \\<Longrightarrow>\n  path_weight' (res' v') \\<le> Num (path_weight p)", "show \"path_weight' (res' v') \\<le> Num (path_weight p)\""], ["proof (prove)\nusing this:\n  p = [] \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n  p = ?p1.2 @ [(?u2, ?w2, v')] \\<Longrightarrow>\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> Num (path_weight p)", "using PATH"], ["proof (prove)\nusing this:\n  p = [] \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n  p = ?p1.2 @ [(?u2, ?w2, v')] \\<Longrightarrow>\n  path_weight' (res' v') \\<le> Num (path_weight p)\n  is_path v0 p v'\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> Num (path_weight p)", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p = [] \\<Longrightarrow>\n             path_weight' (res' v') \\<le> Num (path_weight p);\n     \\<And>p1 u w.\n        p = p1 @ [(u, w, v')] \\<Longrightarrow>\n        path_weight' (res' v') \\<le> Num (path_weight p);\n     is_path v0 p v'; p = []\\<rbrakk>\n    \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)\n 2. \\<And>ys y.\n       \\<lbrakk>p = [] \\<Longrightarrow>\n                path_weight' (res' v') \\<le> Num (path_weight p);\n        \\<And>p1 u w.\n           p = p1 @ [(u, w, v')] \\<Longrightarrow>\n           path_weight' (res' v') \\<le> Num (path_weight p);\n        is_path v0 p v'; p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> path_weight' (res' v') \\<le> Num (path_weight p)", "by auto"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> Num (path_weight p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>va\\<in>wl - {v}.\n     \\<forall>p.\n        is_path v0 p va \\<and>\n        int_vertices p \\<subseteq> V - (wl - {v}) \\<longrightarrow>\n        path_weight' (res' va) \\<le> Num (path_weight p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dinvar \\<sigma>''\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Structural Refinement of Update\\<close>"], ["", "text \\<open>\n    Now that we have proved correct the initial version of the algorithm, we start\n    refinement towards an efficient implementation.\n\\<close>"], ["", "text \\<open>\n    First, the update function is refined to iterate over each successor of the\n    selected node, and update the result on demand.\n\\<close>"], ["", "definition uinvar \n    :: \"'V \\<Rightarrow> 'V set \\<Rightarrow> _ \\<Rightarrow> ('W\\<times>'V) set \\<Rightarrow> ('V,'W) state \\<Rightarrow> bool\" where\n    \"uinvar v wl res it \\<sigma> \\<equiv> let (wl',res')=\\<sigma> in wl'=wl \n    \\<and> (\\<forall>v'\\<in>V. \n      res' v' \\<in> least_map path_weight' (\n        { res v' } \\<union> { Some (p@[(v,w,v')]) | p w. res v = Some p \n          \\<and> (w,v') \\<in> succ G v - it }\n      ))\n    \\<and> (\\<forall>v'\\<in>V. \\<forall>p. res' v' = Some p \\<longrightarrow> is_path v0 p v')\n    \\<and> res' v = res v\n    \""], ["", "definition update' :: \"'V \\<Rightarrow> ('V,'W) state \\<Rightarrow> ('V,'W) state nres\" where \n    \"update' v \\<sigma> \\<equiv> do {\n      ASSERT (update_pre v \\<sigma>);\n      let (wl,res) = \\<sigma>;\n      let wv = path_weight' (res v);\n      let pv = res v;\n      FOREACH\\<^bsup>uinvar v wl res\\<^esup> (succ G v) (\\<lambda>(w',v') (wl,res). \n        if (wv + Num w' < path_weight' (res v')) then do {\n            ASSERT (v'\\<in>wl \\<and> pv\\<noteq>None); \n            RETURN (wl,res(v' \\<mapsto> the pv@[(v,w',v')]))\n        } else RETURN (wl,res)\n      ) (wl,res)}\""], ["", "lemma update'_refines:\n    assumes \"v'=v\" and \"\\<sigma>'=\\<sigma>\"\n    shows \"update' v' \\<sigma>' \\<le> \\<Down>Id (update v \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update' v' \\<sigma>' \\<le> \\<Down> Id (update v \\<sigma>)", "apply (simp only: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. update' v \\<sigma> \\<le> \\<Down> Id (update v \\<sigma>)", "unfolding update'_def update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (update_pre v \\<sigma>) \\<bind>\n    (\\<lambda>_.\n        let (wl, res) = \\<sigma>; wv = path_weight' (res v); pv = res v\n        in FOREACH\\<^bsup>uinvar v wl res\\<^esup> (succ G v)\n            (\\<lambda>(w', v') (wl, res).\n                if wv + Num w' < path_weight' (res v')\n                then ASSERT (v' \\<in> wl \\<and> pv \\<noteq> None) \\<bind>\n                     (\\<lambda>_.\n                         RETURN\n                          (wl, res(v' \\<mapsto> the pv @ [(v, w', v')])))\n                else RETURN (wl, res))\n            (wl, res))\n    \\<le> \\<Down> Id\n           (ASSERT (update_pre v \\<sigma>) \\<bind>\n            (\\<lambda>_. SPEC (update_spec v \\<sigma>)))", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (succ G v) (a, b)\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {x})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 6. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {x}) (wl, res)\n 7. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v \\<sigma> \\<sigma>'", "(*apply (intro refine_vcg conjI)*)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (succ G v) (a, b)\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {x})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 6. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); x \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it \\<sigma>'; x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {x}) (wl, res)\n 7. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v \\<sigma>; update_pre v \\<sigma>;\n        \\<sigma> = (a, b); uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v \\<sigma> \\<sigma>'", "apply (simp_all only: singleton_iff)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (succ G v) (a, b)\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 6. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 7. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "proof -"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (succ G v) (a, b)\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 6. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 7. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "fix wl res"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (succ G v) (a, b)\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 6. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 7. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume \"update_pre v (wl,res)\""], ["proof (state)\nthis:\n  update_pre v (wl, res)\n\ngoal (7 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (succ G v) (a, b)\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 6. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 7. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "thus \"uinvar v wl res (succ G v) (wl,res)\""], ["proof (prove)\nusing this:\n  update_pre v (wl, res)\n\ngoal (1 subgoal):\n 1. uinvar v wl res (succ G v) (wl, res)", "by (simp add: uinvar_def update_pre_def)"], ["proof (state)\nthis:\n  uinvar v wl res (succ G v) (wl, res)\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "fix wl res it wl' res' v' w'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume PRE: \"update_pre v (wl,res)\""], ["proof (state)\nthis:\n  update_pre v (wl, res)\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume INV: \"uinvar v wl res it (wl',res')\""], ["proof (state)\nthis:\n  uinvar v wl res it (wl', res')\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume MEM: \"(w',v')\\<in>it\""], ["proof (state)\nthis:\n  (w', v') \\<in> it\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume IT_SS: \"it\\<subseteq> succ G v\""], ["proof (state)\nthis:\n  it \\<subseteq> succ G v\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume LESS: \"path_weight' (res v) + Num w' < path_weight' (res' v')\""], ["proof (state)\nthis:\n  path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "from PRE"], ["proof (chain)\npicking this:\n  update_pre v (wl, res)", "have [simp, intro!]: \"v\\<in>V\""], ["proof (prove)\nusing this:\n  update_pre v (wl, res)\n\ngoal (1 subgoal):\n 1. v \\<in> V", "by (simp add: update_pre_def)"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "from MEM IT_SS"], ["proof (chain)\npicking this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v", "have [simp,intro!]: \"v'\\<in>V\""], ["proof (prove)\nusing this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "using succ_subset"], ["proof (prove)\nusing this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v\n  succ G ?v \\<subseteq> UNIV \\<times> V\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by auto"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "from LESS"], ["proof (chain)\npicking this:\n  path_weight' (res v) + Num w' < path_weight' (res' v')", "obtain pv where [simp]: \"res v = Some pv\""], ["proof (prove)\nusing this:\n  path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. (\\<And>pv. res v = Some pv \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"res v\") auto"], ["proof (state)\nthis:\n  res v = Some pv\n\ngoal (6 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> b v \\<noteq> None\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 5. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 6. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "thus \"res v \\<noteq> None\""], ["proof (prove)\nusing this:\n  res v = Some pv\n\ngoal (1 subgoal):\n 1. res v \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  res v \\<noteq> None\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "have [simp]: \"wl'=wl\" and [simp]: \"res' v = res v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wl' = wl &&& res' v = res v", "using INV"], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n\ngoal (1 subgoal):\n 1. wl' = wl &&& res' v = res v", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n\ngoal (1 subgoal):\n 1. wl' = wl &&& res' v = res v", "by auto"], ["proof (state)\nthis:\n  wl' = wl\n  res' v = res v\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "from MEM IT_SS"], ["proof (chain)\npicking this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v", "have EDGE[simp]: \"(v,w',v')\\<in>E\""], ["proof (prove)\nusing this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v\n\ngoal (1 subgoal):\n 1. (v, w', v') \\<in> E", "unfolding succ_def"], ["proof (prove)\nusing this:\n  (w', v') \\<in> it\n  it \\<subseteq> {(w, v'). (v, w, v') \\<in> E}\n\ngoal (1 subgoal):\n 1. (v, w', v') \\<in> E", "by auto"], ["proof (state)\nthis:\n  (v, w', v') \\<in> E\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "with INV"], ["proof (chain)\npicking this:\n  uinvar v wl res it (wl', res')\n  (v, w', v') \\<in> E", "have [simp]: \"is_path v0 pv v\""], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n  (v, w', v') \\<in> E\n\ngoal (1 subgoal):\n 1. is_path v0 pv v", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n  (v, w', v') \\<in> E\n\ngoal (1 subgoal):\n 1. is_path v0 pv v", "by auto"], ["proof (state)\nthis:\n  is_path v0 pv v\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "have \"0\\<le>w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'W) \\<le> w'", "by (rule nonneg_weights[OF EDGE])"], ["proof (state)\nthis:\n  (0::'W) \\<le> w'\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "hence [simp]: \"v'\\<noteq>v\""], ["proof (prove)\nusing this:\n  (0::'W) \\<le> w'\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v", "using LESS"], ["proof (prove)\nusing this:\n  (0::'W) \\<le> w'\n  path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. v' \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  v' \\<noteq> v\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "hence [simp]: \"v\\<noteq>v'\""], ["proof (prove)\nusing this:\n  v' \\<noteq> v\n\ngoal (1 subgoal):\n 1. v \\<noteq> v'", "by blast"], ["proof (state)\nthis:\n  v \\<noteq> v'\n\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> wl\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 4. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 5. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "show [simp]: \"v'\\<in>wl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v' \\<in> wl'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "assume [simp]: \"v'\\<notin>wl'\""], ["proof (state)\nthis:\n  v' \\<notin> wl'\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "hence [simp]: \"v'\\<in>V-wl\" and [simp]: \"v'\\<notin>wl\""], ["proof (prove)\nusing this:\n  v' \\<notin> wl'\n\ngoal (1 subgoal):\n 1. v' \\<in> V - wl &&& v' \\<notin> wl", "by auto"], ["proof (state)\nthis:\n  v' \\<in> V - wl\n  v' \\<notin> wl\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "note LESS"], ["proof (state)\nthis:\n  path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "from INV"], ["proof (chain)\npicking this:\n  uinvar v wl res it (wl', res')", "have \"path_weight' (res' v') \\<le> path_weight' (res v')\""], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res v')", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (res v')", "by (auto dest: least_map_leD)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (res v')\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "from PRE"], ["proof (chain)\npicking this:\n  update_pre v (wl, res)", "have PW: \"\\<And>p. is_path v0 p v' \\<Longrightarrow> \n        path_weight' (res v') \\<le> path_weight' (Some p)\""], ["proof (prove)\nusing this:\n  update_pre v (wl, res)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       is_path v0 p v' \\<Longrightarrow>\n       path_weight' (res v') \\<le> path_weight' (Some p)", "unfolding update_pre_def"], ["proof (prove)\nusing this:\n  let (wl, res) = (wl, res)\n  in v \\<in> V \\<and>\n     (\\<forall>v'\\<in>V - wl.\n         v' \\<noteq> v \\<longrightarrow>\n         (\\<forall>p.\n             is_path v0 p v' \\<longrightarrow>\n             path_weight' (res v') \\<le> path_weight' (Some p))) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p. res v' = Some p \\<longrightarrow> is_path v0 p v')\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       is_path v0 p v' \\<Longrightarrow>\n       path_weight' (res v') \\<le> path_weight' (Some p)", "by auto"], ["proof (state)\nthis:\n  is_path v0 ?p v' \\<Longrightarrow>\n  path_weight' (res v') \\<le> path_weight' (Some ?p)\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "have P: \"is_path v0 (pv@[(v,w',v')]) v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_path v0 (pv @ [(v, w', v')]) v'", "by simp"], ["proof (state)\nthis:\n  is_path v0 (pv @ [(v, w', v')]) v'\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "from PW[OF P]"], ["proof (chain)\npicking this:\n  path_weight' (res v') \\<le> path_weight' (Some (pv @ [(v, w', v')]))", "have \n        \"path_weight' (res v') \\<le> Num (path_weight (pv@[(v,w',v')]))\""], ["proof (prove)\nusing this:\n  path_weight' (res v') \\<le> path_weight' (Some (pv @ [(v, w', v')]))\n\ngoal (1 subgoal):\n 1. path_weight' (res v') \\<le> Num (path_weight (pv @ [(v, w', v')]))", "by auto"], ["proof (state)\nthis:\n  path_weight' (res v') \\<le> Num (path_weight (pv @ [(v, w', v')]))\n\ngoal (1 subgoal):\n 1. v' \\<notin> wl' \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  path_weight' (res v) + Num w' < Num (path_weight (pv @ [(v, w', v')]))", "show False"], ["proof (prove)\nusing this:\n  path_weight' (res v) + Num w' < Num (path_weight (pv @ [(v, w', v')]))\n\ngoal (1 subgoal):\n 1. False", "by (simp add: infty_unbox)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v' \\<in> wl'\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        path_weight' (b v) + Num w' < path_weight' (res v');\n        v' \\<in> wl \\<and> b v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')})\n                          (wl, res(v' \\<mapsto> the (b v) @ [(v, w', v')]))\n 3. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 4. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "show \"uinvar v wl res (it-{(w',v')}) (wl',res'(v'\\<mapsto>the (res v)@[(v,w',v')]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "have \"(res'(v'\\<mapsto>the (res v)@[(v,w',v')])) v = res' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v", "by simp"], ["proof (state)\nthis:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "moreover"], ["proof (state)\nthis:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "{"], ["proof (state)\nthis:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "fix v''"], ["proof (state)\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "assume VMEM: \"v''\\<in>V\""], ["proof (state)\nthis:\n  v'' \\<in> V\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "have \"(res'(v'\\<mapsto>the (res v)@[(v,w',v')])) v'' \\<in> least_map path_weight' (\n          { res v'' } \\<union> { Some (p@[(v,w,v'')]) | p w. res v = Some p \n          \\<and> (w,v'') \\<in> succ G v - (it - {(w',v')}) }\n          ) \\<and> (\\<forall>p. (res'(v'\\<mapsto>the (res v)@[(v,w',v')])) v'' = Some p \n                \\<longrightarrow> is_path v0 p v'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "proof (cases \"v''=v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')\n 2. v'' \\<noteq> v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "case [simp]: False"], ["proof (state)\nthis:\n  v'' \\<noteq> v'\n\ngoal (2 subgoals):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')\n 2. v'' \\<noteq> v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "have \"{ Some (p@[(v,w,v'')]) | p w. res v = Some p \n          \\<and> (w,v'') \\<in> succ G v - (it - {(w',v')}) } = \n            { Some (p@[(v,w,v'')]) | p w. res v = Some p \n          \\<and> (w,v'') \\<in> succ G v - it }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n    {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - it}", "by auto"], ["proof (state)\nthis:\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - it}\n\ngoal (2 subgoals):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')\n 2. v'' \\<noteq> v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "with INV VMEM"], ["proof (chain)\npicking this:\n  uinvar v wl res it (wl', res')\n  v'' \\<in> V\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - it}", "show ?thesis"], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n  v'' \\<in> V\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - it}\n\ngoal (1 subgoal):\n 1. (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n  v'' \\<in> V\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - it}\n\ngoal (1 subgoal):\n 1. (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "by simp"], ["proof (state)\nthis:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n  \\<in> least_map path_weight'\n         ({res v''} \\<union>\n          {Some (p @ [(v, w, v'')]) |p w.\n           res v = Some p \\<and>\n           (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n      Some p \\<longrightarrow>\n      is_path v0 p v'')\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "case [simp]: True"], ["proof (state)\nthis:\n  v'' = v'\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "have EQ: \"{ res v'' } \\<union> { Some (p@[(v,w,v'')]) | p w. res v = Some p \n          \\<and> (w,v'') \\<in> succ G v - (it - {(w',v')}) } =\n          insert (Some (pv@[(v,w',v')])) (\n            { res v'' } \\<union> { Some (p@[(v,w,v'')]) | p w. res v = Some p \n          \\<and> (w,v'') \\<in> succ G v - it })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {res v''} \\<union>\n    {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n    insert (Some (pv @ [(v, w', v')]))\n     ({res v''} \\<union>\n      {Some (p @ [(v, w, v'')]) |p w.\n       res v = Some p \\<and> (w, v'') \\<in> succ G v - it})", "using MEM IT_SS"], ["proof (prove)\nusing this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v\n\ngoal (1 subgoal):\n 1. {res v''} \\<union>\n    {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n    insert (Some (pv @ [(v, w', v')]))\n     ({res v''} \\<union>\n      {Some (p @ [(v, w, v'')]) |p w.\n       res v = Some p \\<and> (w, v'') \\<in> succ G v - it})", "by auto"], ["proof (state)\nthis:\n  {res v''} \\<union>\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n  insert (Some (pv @ [(v, w', v')]))\n   ({res v''} \\<union>\n    {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - it})\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "apply (subst EQ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n    \\<in> least_map path_weight'\n           (insert (Some (pv @ [(v, w', v')]))\n             ({res v''} \\<union>\n              {Some (p @ [(v, w, v'')]) |p w.\n               res v = Some p \\<and> (w, v'') \\<in> succ G v - it})) \\<and>\n    (\\<forall>p.\n        (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n        Some p \\<longrightarrow>\n        is_path v0 p v'')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (pv @ [(v, w', v')])\n    \\<in> least_map path_weight'\n           (insert (Some (pv @ [(v, w', v')]))\n             (insert (res v')\n               {Some (pv @ [(v, w, v')]) |w.\n                (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}))", "apply (rule least_map_insert_min)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>insert (res v')\n                    {Some (pv @ [(v, w, v')]) |w.\n                     (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}.\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "fix r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "assume A: \n              \"r' \\<in> insert (res v') \n               {Some (pv @ [(v, w, v')]) |w. (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}\""], ["proof (state)\nthis:\n  r' \\<in> insert (res v')\n            {Some (pv @ [(v, w, v')]) |w.\n             (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "from LESS"], ["proof (chain)\npicking this:\n  path_weight' (res v) + Num w' < path_weight' (res' v')", "have \n              \"path_weight' (Some (pv @ [(v, w', v')])) < path_weight' (res' v')\""], ["proof (prove)\nusing this:\n  path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. path_weight' (Some (pv @ [(v, w', v')])) < path_weight' (res' v')", "by (auto simp: infty_unbox)"], ["proof (state)\nthis:\n  path_weight' (Some (pv @ [(v, w', v')])) < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "also"], ["proof (state)\nthis:\n  path_weight' (Some (pv @ [(v, w', v')])) < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "from INV[unfolded uinvar_def]"], ["proof (chain)\npicking this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v", "have \n              \"res' v' \\<in> least_map path_weight' (\n                insert (res v') \n                {Some (pv @ [(v, w, v')]) |w. (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}\n              )\""], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n\ngoal (1 subgoal):\n 1. res' v'\n    \\<in> least_map path_weight'\n           (insert (res v')\n             {Some (pv @ [(v, w, v')]) |w.\n              (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it})", "by auto"], ["proof (state)\nthis:\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (pv @ [(v, w, v')]) |w.\n            (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it})\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "with A"], ["proof (chain)\npicking this:\n  r' \\<in> insert (res v')\n            {Some (pv @ [(v, w, v')]) |w.\n             (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (pv @ [(v, w, v')]) |w.\n            (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it})", "have \"path_weight' (res' v') \\<le> path_weight' r'\""], ["proof (prove)\nusing this:\n  r' \\<in> insert (res v')\n            {Some (pv @ [(v, w, v')]) |w.\n             (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it}\n  res' v'\n  \\<in> least_map path_weight'\n         (insert (res v')\n           {Some (pv @ [(v, w, v')]) |w.\n            (w, v') \\<in> succ G v \\<and> (w, v') \\<notin> it})\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' r'", "by (auto dest: least_map_leD)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' r'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> insert (res v')\n                {Some (pv @ [(v, w, v')]) |w.\n                 (w, v') \\<in> succ G v \\<and>\n                 (w, v') \\<notin> it} \\<Longrightarrow>\n       path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' y", "finally"], ["proof (chain)\npicking this:\n  path_weight' (Some (pv @ [(v, w', v')])) < path_weight' r'", "show \n              \"path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' r'\""], ["proof (prove)\nusing this:\n  path_weight' (Some (pv @ [(v, w', v')])) < path_weight' r'\n\ngoal (1 subgoal):\n 1. path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' r'", "by simp"], ["proof (state)\nthis:\n  path_weight' (Some (pv @ [(v, w', v')])) \\<le> path_weight' r'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n  \\<in> least_map path_weight'\n         ({res v''} \\<union>\n          {Some (p @ [(v, w, v'')]) |p w.\n           res v = Some p \\<and>\n           (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n      Some p \\<longrightarrow>\n      is_path v0 p v'')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v''\n  \\<in> least_map path_weight'\n         ({res v''} \\<union>\n          {Some (p @ [(v, w, v'')]) |p w.\n           res v = Some p \\<and>\n           (w, v'') \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v'' =\n      Some p \\<longrightarrow>\n      is_path v0 p v'')\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "}"], ["proof (state)\nthis:\n  ?v''2 \\<in> V \\<Longrightarrow>\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2 =\n      Some p \\<longrightarrow>\n      is_path v0 p ?v''2)\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "ultimately"], ["proof (chain)\npicking this:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v\n  ?v''2 \\<in> V \\<Longrightarrow>\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2 =\n      Some p \\<longrightarrow>\n      is_path v0 p ?v''2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v\n  ?v''2 \\<in> V \\<Longrightarrow>\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2 =\n      Some p \\<longrightarrow>\n      is_path v0 p ?v''2)\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')})\n     (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))", "unfolding uinvar_def Let_def"], ["proof (prove)\nusing this:\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) v = res' v\n  ?v''2 \\<in> V \\<Longrightarrow>\n  (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})}) \\<and>\n  (\\<forall>p.\n      (res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) ?v''2 =\n      Some p \\<longrightarrow>\n      is_path v0 p ?v''2)\n\ngoal (1 subgoal):\n 1. case (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')])) of\n    (wl', res') \\<Rightarrow>\n      wl' = wl \\<and>\n      (\\<forall>v'\\<in>V.\n          res' v'\n          \\<in> least_map path_weight'\n                 ({res v'} \\<union>\n                  {Some (p @ [(v, w, v')]) |p w.\n                   res v = Some p \\<and>\n                   (w, v') \\<in> succ G v - (it - {(w', v')})})) \\<and>\n      (\\<forall>v'\\<in>V.\n          \\<forall>p.\n             res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n      res' v = res v", "by auto"], ["proof (state)\nthis:\n  uinvar v wl res (it - {(w', v')})\n   (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uinvar v wl res (it - {(w', v')})\n   (wl', res'(v' \\<mapsto> the (res v) @ [(v, w', v')]))\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 3. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 3. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "fix wl res it w' v' wl' res'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 3. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume INV: \"uinvar v wl res it (wl',res')\"\n    and NLESS: \"\\<not> path_weight' (res v) + Num w' < path_weight' (res' v')\"\n    and IN_IT: \"(w',v')\\<in>it\"\n    and IT_SS: \"it \\<subseteq> succ G v\""], ["proof (state)\nthis:\n  uinvar v wl res it (wl', res')\n  \\<not> path_weight' (res v) + Num w' < path_weight' (res' v')\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 3. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "from IN_IT IT_SS"], ["proof (chain)\npicking this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v", "have [simp, intro!]: \"(w',v')\\<in>succ G v\""], ["proof (prove)\nusing this:\n  (w', v') \\<in> it\n  it \\<subseteq> succ G v\n\ngoal (1 subgoal):\n 1. (w', v') \\<in> succ G v", "by auto"], ["proof (state)\nthis:\n  (w', v') \\<in> succ G v\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 3. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "hence [simp,intro!]: \"v'\\<in>V\""], ["proof (prove)\nusing this:\n  (w', v') \\<in> succ G v\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "using succ_subset"], ["proof (prove)\nusing this:\n  (w', v') \\<in> succ G v\n  succ G ?v \\<subseteq> UNIV \\<times> V\n\ngoal (1 subgoal):\n 1. v' \\<in> V", "by auto"], ["proof (state)\nthis:\n  v' \\<in> V\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b x it \\<sigma>' w' v' wl res.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        (w', v') \\<in> it; it \\<subseteq> succ G v;\n        uinvar v a b it (wl, res); x = (w', v'); \\<sigma>' = (wl, res);\n        \\<not> path_weight' (b v) + Num w' < path_weight' (res v')\\<rbrakk>\n       \\<Longrightarrow> uinvar v a b (it - {(w', v')}) (wl, res)\n 3. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "show \"uinvar v wl res (it - {(w',v')}) (wl',res')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')}) (wl', res')", "proof (cases \"res v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. res v = None \\<Longrightarrow>\n    uinvar v wl res (it - {(w', v')}) (wl', res')\n 2. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "case [simp]: None"], ["proof (state)\nthis:\n  res v = None\n\ngoal (2 subgoals):\n 1. res v = None \\<Longrightarrow>\n    uinvar v wl res (it - {(w', v')}) (wl', res')\n 2. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "from INV"], ["proof (chain)\npicking this:\n  uinvar v wl res it (wl', res')", "show ?thesis"], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')}) (wl', res')", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n\ngoal (1 subgoal):\n 1. let (wl', res') = (wl', res')\n    in wl' = wl \\<and>\n       (\\<forall>v'\\<in>V.\n           res' v'\n           \\<in> least_map path_weight'\n                  ({res v'} \\<union>\n                   {Some (p @ [(v, w, v')]) |p w.\n                    res v = Some p \\<and>\n                    (w, v') \\<in> succ G v - (it - {(w', v')})})) \\<and>\n       (\\<forall>v'\\<in>V.\n           \\<forall>p.\n              res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n       res' v = res v", "by auto"], ["proof (state)\nthis:\n  uinvar v wl res (it - {(w', v')}) (wl', res')\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "case [simp]: (Some p)"], ["proof (state)\nthis:\n  res v = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "{"], ["proof (state)\nthis:\n  res v = Some p\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "fix v''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "assume [simp, intro!]: \"v''\\<in>V\""], ["proof (state)\nthis:\n  v'' \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "have \"res' v'' \\<in> least_map path_weight' (\n          { res v'' } \\<union> { Some (p@[(v,w,v'')]) | p w. res v = Some p \n          \\<and> (w,v'') \\<in> succ G v - (it - {(w',v')}) }\n          )\" (is \"_ \\<in> least_map path_weight' ?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "proof (cases \"v''=v'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})\n 2. v'' \\<noteq> v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "case False"], ["proof (state)\nthis:\n  v'' \\<noteq> v'\n\ngoal (2 subgoals):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})\n 2. v'' \\<noteq> v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "with INV"], ["proof (chain)\npicking this:\n  uinvar v wl res it (wl', res')\n  v'' \\<noteq> v'", "show ?thesis"], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n  v'' \\<noteq> v'\n\ngoal (1 subgoal):\n 1. res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n  v'' \\<noteq> v'\n\ngoal (1 subgoal):\n 1. res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "by auto"], ["proof (state)\nthis:\n  res' v''\n  \\<in> least_map path_weight'\n         ({res v''} \\<union>\n          {Some (p @ [(v, w, v'')]) |p w.\n           res v = Some p \\<and>\n           (w, v'') \\<in> succ G v - (it - {(w', v')})})\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "case [simp]: True"], ["proof (state)\nthis:\n  v'' = v'\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "have EQ: \"?S = insert (Some (p@[(v,w',v')])) (\n            { res v' } \\<union> { Some (p@[(v,w,v'')]) | p w. res v = Some p \n                            \\<and> (w,v'') \\<in> succ G v - it }\n            )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {res v''} \\<union>\n    {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n    insert (Some (p @ [(v, w', v')]))\n     ({res v'} \\<union>\n      {Some (p @ [(v, w, v'')]) |p w.\n       res v = Some p \\<and> (w, v'') \\<in> succ G v - it})", "by auto"], ["proof (state)\nthis:\n  {res v''} \\<union>\n  {Some (p @ [(v, w, v'')]) |p w.\n   res v = Some p \\<and> (w, v'') \\<in> succ G v - (it - {(w', v')})} =\n  insert (Some (p @ [(v, w', v')]))\n   ({res v'} \\<union>\n    {Some (p @ [(v, w, v'')]) |p w.\n     res v = Some p \\<and> (w, v'') \\<in> succ G v - it})\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "from NLESS"], ["proof (chain)\npicking this:\n  \\<not> path_weight' (res v) + Num w' < path_weight' (res' v')", "have \n            \"path_weight' (res' v') \\<le> path_weight' (Some (p@[(v,w',v')]))\""], ["proof (prove)\nusing this:\n  \\<not> path_weight' (res v) + Num w' < path_weight' (res' v')\n\ngoal (1 subgoal):\n 1. path_weight' (res' v') \\<le> path_weight' (Some (p @ [(v, w', v')]))", "by (auto simp: infty_unbox)"], ["proof (state)\nthis:\n  path_weight' (res' v') \\<le> path_weight' (Some (p @ [(v, w', v')]))\n\ngoal (1 subgoal):\n 1. v'' = v' \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "thus ?thesis"], ["proof (prove)\nusing this:\n  path_weight' (res' v') \\<le> path_weight' (Some (p @ [(v, w', v')]))\n\ngoal (1 subgoal):\n 1. res' v''\n    \\<in> least_map path_weight'\n           ({res v''} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and>\n             (w, v'') \\<in> succ G v - (it - {(w', v')})})", "apply (subst EQ)"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           (insert (Some (p @ [(v, w', v')]))\n             ({res v'} \\<union>\n              {Some (p @ [(v, w, v'')]) |p w.\n               res v = Some p \\<and> (w, v'') \\<in> succ G v - it}))", "apply (rule least_map_insert_nmin)"], ["proof (prove)\ngoal (2 subgoals):\n 1. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v'} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and> (w, v'') \\<in> succ G v - it})\n 2. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    path_weight' (res' v'') \\<le> path_weight' (Some (p @ [(v, w', v')]))", "using INV"], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n\ngoal (2 subgoals):\n 1. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v'} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and> (w, v'') \\<in> succ G v - it})\n 2. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    path_weight' (res' v'') \\<le> path_weight' (Some (p @ [(v, w', v')]))", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n\ngoal (2 subgoals):\n 1. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    res' v''\n    \\<in> least_map path_weight'\n           ({res v'} \\<union>\n            {Some (p @ [(v, w, v'')]) |p w.\n             res v = Some p \\<and> (w, v'') \\<in> succ G v - it})\n 2. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    path_weight' (res' v'') \\<le> path_weight' (Some (p @ [(v, w', v')]))", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weight' (res' v')\n    \\<le> path_weight' (Some (p @ [(v, w', v')])) \\<Longrightarrow>\n    path_weight' (res' v'') \\<le> path_weight' (Some (p @ [(v, w', v')]))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  res' v''\n  \\<in> least_map path_weight'\n         ({res v''} \\<union>\n          {Some (p @ [(v, w, v'')]) |p w.\n           res v = Some p \\<and>\n           (w, v'') \\<in> succ G v - (it - {(w', v')})})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  res' v''\n  \\<in> least_map path_weight'\n         ({res v''} \\<union>\n          {Some (p @ [(v, w, v'')]) |p w.\n           res v = Some p \\<and>\n           (w, v'') \\<in> succ G v - (it - {(w', v')})})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "}"], ["proof (state)\nthis:\n  ?v''2 \\<in> V \\<Longrightarrow>\n  res' ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       res v = Some a \\<Longrightarrow>\n       uinvar v wl res (it - {(w', v')}) (wl', res')", "with INV"], ["proof (chain)\npicking this:\n  uinvar v wl res it (wl', res')\n  ?v''2 \\<in> V \\<Longrightarrow>\n  res' ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})})", "show ?thesis"], ["proof (prove)\nusing this:\n  uinvar v wl res it (wl', res')\n  ?v''2 \\<in> V \\<Longrightarrow>\n  res' ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})})\n\ngoal (1 subgoal):\n 1. uinvar v wl res (it - {(w', v')}) (wl', res')", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = (wl', res')\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - it})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n  ?v''2 \\<in> V \\<Longrightarrow>\n  res' ?v''2\n  \\<in> least_map path_weight'\n         ({res ?v''2} \\<union>\n          {Some (p @ [(v, w, ?v''2)]) |p w.\n           res v = Some p \\<and>\n           (w, ?v''2) \\<in> succ G v - (it - {(w', v')})})\n\ngoal (1 subgoal):\n 1. let (wl', res') = (wl', res')\n    in wl' = wl \\<and>\n       (\\<forall>v'\\<in>V.\n           res' v'\n           \\<in> least_map path_weight'\n                  ({res v'} \\<union>\n                   {Some (p @ [(v, w, v')]) |p w.\n                    res v = Some p \\<and>\n                    (w, v') \\<in> succ G v - (it - {(w', v')})})) \\<and>\n       (\\<forall>v'\\<in>V.\n           \\<forall>p.\n              res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n       res' v = res v", "by auto"], ["proof (state)\nthis:\n  uinvar v wl res (it - {(w', v')}) (wl', res')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uinvar v wl res (it - {(w', v')}) (wl', res')\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "fix wl res \\<sigma>'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "assume \"uinvar v wl res {} \\<sigma>'\""], ["proof (state)\nthis:\n  uinvar v wl res {} \\<sigma>'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b);\n        uinvar v a b {} \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> update_spec v (a, b) \\<sigma>'", "thus \"update_spec v (wl,res) \\<sigma>'\""], ["proof (prove)\nusing this:\n  uinvar v wl res {} \\<sigma>'\n\ngoal (1 subgoal):\n 1. update_spec v (wl, res) \\<sigma>'", "unfolding uinvar_def"], ["proof (prove)\nusing this:\n  let (wl', res') = \\<sigma>'\n  in wl' = wl \\<and>\n     (\\<forall>v'\\<in>V.\n         res' v'\n         \\<in> least_map path_weight'\n                ({res v'} \\<union>\n                 {Some (p @ [(v, w, v')]) |p w.\n                  res v = Some p \\<and>\n                  (w, v') \\<in> succ G v - {}})) \\<and>\n     (\\<forall>v'\\<in>V.\n         \\<forall>p.\n            res' v' = Some p \\<longrightarrow> is_path v0 p v') \\<and>\n     res' v = res v\n\ngoal (1 subgoal):\n 1. update_spec v (wl, res) \\<sigma>'", "apply (cases \\<sigma>')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>let (wl', res') = \\<sigma>'\n                in wl' = wl \\<and>\n                   (\\<forall>v'\\<in>V.\n                       res' v'\n                       \\<in> least_map path_weight'\n                              ({res v'} \\<union>\n                               {Some (p @ [(v, w, v')]) |p w.\n                                res v = Some p \\<and>\n                                (w, v') \\<in> succ G v - {}})) \\<and>\n                   (\\<forall>v'\\<in>V.\n                       \\<forall>p.\n                          res' v' = Some p \\<longrightarrow>\n                          is_path v0 p v') \\<and>\n                   res' v = res v;\n        \\<sigma>' = (a, b)\\<rbrakk>\n       \\<Longrightarrow> update_spec v (wl, res) \\<sigma>'", "apply (auto intro: update_spec.intros simp: succ_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  update_spec v (wl, res) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>update_pre v (a, b); True; \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> finite (succ G v)", "show \"finite (succ G v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (succ G v)", "by simp"], ["proof (state)\nthis:\n  finite (succ G v)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We integrate the new update function into the main algorithm:\\<close>"], ["", "definition dijkstra' where\n    \"dijkstra' \\<equiv> do {\n      \\<sigma>0 \\<leftarrow> dinit; \n      (_,res) \\<leftarrow> WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup> (\\<lambda>(wl,_). wl\\<noteq>{}) \n            (\\<lambda>\\<sigma>. do {(v,\\<sigma>') \\<leftarrow> pop_min \\<sigma>; update' v \\<sigma>'})\n            \\<sigma>0;\n      RETURN res\n    }\""], ["", "lemma dijkstra'_refines: \"dijkstra' \\<le> \\<Down>Id dijkstra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstra' \\<le> \\<Down> Id dijkstra", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dijkstra' \\<le> \\<Down> Id dijkstra", "note [refine] = update'_refines"], ["proof (state)\nthis:\n  \\<lbrakk>?v' = ?v; ?\\<sigma>' = ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> update' ?v' ?\\<sigma>'\n                    \\<le> \\<Down> Id (update ?v ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. dijkstra' \\<le> \\<Down> Id dijkstra", "have [refine]: \"\\<And>\\<sigma> \\<sigma>'. \\<sigma>=\\<sigma>' \\<Longrightarrow> pop_min \\<sigma> \\<le> \\<Down>Id (pop_min \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<sigma> = \\<sigma>' \\<Longrightarrow>\n       pop_min \\<sigma> \\<le> \\<Down> Id (pop_min \\<sigma>')", "by simp"], ["proof (state)\nthis:\n  ?\\<sigma> = ?\\<sigma>' \\<Longrightarrow>\n  pop_min ?\\<sigma> \\<le> \\<Down> Id (pop_min ?\\<sigma>')\n\ngoal (1 subgoal):\n 1. dijkstra' \\<le> \\<Down> Id dijkstra", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstra' \\<le> \\<Down> Id dijkstra", "unfolding dijkstra_def dijkstra'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dinit \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n         (\\<lambda>(wl, uu_). wl \\<noteq> {})\n         (\\<lambda>\\<sigma>.\n             pop_min \\<sigma> \\<bind> (\\<lambda>(x, y). update' x y))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> \\<Down> Id\n           (dinit \\<bind>\n            (\\<lambda>\\<sigma>0.\n                WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n                 (\\<lambda>(wl, uu_). wl \\<noteq> {})\n                 (\\<lambda>\\<sigma>.\n                     pop_min \\<sigma> \\<bind> (\\<lambda>(x, y). update x y))\n                 \\<sigma>0 \\<bind>\n                (\\<lambda>(uu_, res). RETURN res)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<sigma>0 \\<sigma>0a x x'.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> Id; (x, x') \\<in> Id;\n        dinvar x'\\<rbrakk>\n       \\<Longrightarrow> dinvar x\n 2. \\<And>\\<sigma>0 \\<sigma>0a x x' x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> Id; (x, x') \\<in> Id;\n        dinvar x; dinvar x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x1 \\<noteq> {}) = (x1a \\<noteq> {})\n 3. \\<And>\\<sigma>0 \\<sigma>0a x x'.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        case x' of (wl, uu_) \\<Rightarrow> wl \\<noteq> {}; dinvar x;\n        dinvar x'\\<rbrakk>\n       \\<Longrightarrow> x = x'\n 4. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        case x' of (wl, uu_) \\<Rightarrow> wl \\<noteq> {}; dinvar x;\n        dinvar x'; (xa, x'a) \\<in> Id; x'a = (x1, x2);\n        xa = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> x1a = x1\n 5. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of (wl, uu_) \\<Rightarrow> wl \\<noteq> {};\n        case x' of (wl, uu_) \\<Rightarrow> wl \\<noteq> {}; dinvar x;\n        dinvar x'; (xa, x'a) \\<in> Id; x'a = (x1, x2);\n        xa = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> x2a = x2\n 6. \\<And>\\<sigma>0 \\<sigma>0a x x' x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> Id; (x, x') \\<in> Id;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> Id", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dijkstra' \\<le> \\<Down> Id dijkstra\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Refinement to Cached Weights\\<close>"], ["", "text \\<open>\n  Next, we refine the data types of the workset and the result map.\n  The workset becomes a map from nodes to their current weights.\n  The result map stores, in addition to the shortest path, also the\n  weight of the shortest path. Moreover, we store the shortest paths\n  in reversed order, which makes appending new edges more effcient.\n\n  These refinements allow to implement the workset as a priority queue,\n  and save recomputation of the path weights in the inner loop of the\n  algorithm.\n\\<close>"], ["", "type_synonym ('V,'W) mwl = \"('V \\<rightharpoonup> 'W infty)\""], ["", "type_synonym ('V,'W) mres = \"('V \\<rightharpoonup> (('V,'W) path \\<times> 'W))\""], ["", "type_synonym ('V,'W) mstate = \"('V,'W) mwl \\<times> ('V,'W) mres\""], ["", "text \\<open>\n  Map a path with cached weight to one without cached weight.\n\\<close>"], ["", "fun mpath' :: \"(('V,'W) path \\<times> 'W) option \\<rightharpoonup> ('V,'W) path\" where\n  \"mpath' None = None\" |\n  \"mpath' (Some (p,w)) = Some p\""], ["", "fun mpath_weight' :: \"(('V,'W) path \\<times> 'W) option \\<Rightarrow> ('W::weight) infty\" where\n  \"mpath_weight' None = top\" |\n  \"mpath_weight' (Some (p,w)) = Num w\""], ["", "context Dijkstra\nbegin"], ["", "definition \\<alpha>w::\"('V,'W) mwl \\<Rightarrow> 'V set\" where \"\\<alpha>w \\<equiv> dom\""], ["", "definition \\<alpha>r::\"('V,'W) mres \\<Rightarrow> 'V \\<rightharpoonup> ('V,'W) path\" where \n    \"\\<alpha>r \\<equiv> \\<lambda>res v. case res v of None \\<Rightarrow> None | Some (p,w) \\<Rightarrow> Some (rev p)\""], ["", "definition \\<alpha>s:: \"('V,'W) mstate \\<Rightarrow> ('V,'W) state\" where\n    \"\\<alpha>s \\<equiv> map_prod \\<alpha>w \\<alpha>r\""], ["", "text \\<open>Additional invariants for the new state. They guarantee that\n    the cached weights are consistent.\\<close>"], ["", "definition res_invarm :: \"('V \\<rightharpoonup> (('V,'W) path\\<times>'W)) \\<Rightarrow> bool\" where\n    \"res_invarm res \\<equiv> (\\<forall>v. case res v of \n        None \\<Rightarrow> True | \n        Some (p,w) \\<Rightarrow> w = path_weight (rev p))\""], ["", "definition dinvarm :: \"('V,'W) mstate \\<Rightarrow> bool\" where\n    \"dinvarm \\<sigma> \\<equiv> let (wl,res) = \\<sigma> in\n      (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and> res_invarm res\n    \""], ["", "lemma mpath_weight'_correct: \"\\<lbrakk>dinvarm (wl,res)\\<rbrakk> \\<Longrightarrow>\n    mpath_weight' (res v) = path_weight' (\\<alpha>r res v)\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. dinvarm (wl, res) \\<Longrightarrow>\n    mpath_weight' (res v) = path_weight' (\\<alpha>r res v)", "unfolding dinvarm_def res_invarm_def \\<alpha>r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (wl, res) = (wl, res)\n    in (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and>\n       (\\<forall>v.\n           case res v of None \\<Rightarrow> True\n           | Some (p, w) \\<Rightarrow>\n               w = path_weight (rev p)) \\<Longrightarrow>\n    mpath_weight' (res v) =\n    path_weight'\n     (case res v of None \\<Rightarrow> None\n      | Some (p, w) \\<Rightarrow> Some (rev p))", "by (auto split: option.split option.split_asm)"], ["", "lemma mpath'_correct: \"\\<lbrakk>dinvarm (wl,res)\\<rbrakk> \\<Longrightarrow>\n    mpath' (res v) = map_option rev (\\<alpha>r res v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dinvarm (wl, res) \\<Longrightarrow>\n    mpath' (res v) = map_option rev (\\<alpha>r res v)", "unfolding dinvarm_def \\<alpha>r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (wl, res) = (wl, res)\n    in (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and>\n       res_invarm res \\<Longrightarrow>\n    mpath' (res v) =\n    map_option rev\n     (case res v of None \\<Rightarrow> None\n      | Some (p, w) \\<Rightarrow> Some (rev p))", "by (auto split: option.split option.split_asm)"], ["", "lemma wl_weight_correct:\n    assumes INV: \"dinvarm (wl,res)\" \n    assumes WLV: \"wl v = Some w\" \n    shows \"path_weight' (\\<alpha>r res v) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_weight' (\\<alpha>r res v) = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path_weight' (\\<alpha>r res v) = w", "from INV WLV"], ["proof (chain)\npicking this:\n  dinvarm (wl, res)\n  wl v = Some w", "have \"w = mpath_weight' (res v)\""], ["proof (prove)\nusing this:\n  dinvarm (wl, res)\n  wl v = Some w\n\ngoal (1 subgoal):\n 1. w = mpath_weight' (res v)", "unfolding dinvarm_def"], ["proof (prove)\nusing this:\n  let (wl, res) = (wl, res)\n  in (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and>\n     res_invarm res\n  wl v = Some w\n\ngoal (1 subgoal):\n 1. w = mpath_weight' (res v)", "by force"], ["proof (state)\nthis:\n  w = mpath_weight' (res v)\n\ngoal (1 subgoal):\n 1. path_weight' (\\<alpha>r res v) = w", "also"], ["proof (state)\nthis:\n  w = mpath_weight' (res v)\n\ngoal (1 subgoal):\n 1. path_weight' (\\<alpha>r res v) = w", "from mpath_weight'_correct[OF INV]"], ["proof (chain)\npicking this:\n  mpath_weight' (res ?v) = path_weight' (\\<alpha>r res ?v)", "have \n      \"\\<dots> = path_weight' (\\<alpha>r res v)\""], ["proof (prove)\nusing this:\n  mpath_weight' (res ?v) = path_weight' (\\<alpha>r res ?v)\n\ngoal (1 subgoal):\n 1. mpath_weight' (res v) = path_weight' (\\<alpha>r res v)", "."], ["proof (state)\nthis:\n  mpath_weight' (res v) = path_weight' (\\<alpha>r res v)\n\ngoal (1 subgoal):\n 1. path_weight' (\\<alpha>r res v) = w", "finally"], ["proof (chain)\npicking this:\n  w = path_weight' (\\<alpha>r res v)", "show ?thesis"], ["proof (prove)\nusing this:\n  w = path_weight' (\\<alpha>r res v)\n\ngoal (1 subgoal):\n 1. path_weight' (\\<alpha>r res v) = w", "by simp"], ["proof (state)\nthis:\n  path_weight' (\\<alpha>r res v) = w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The initial state is constructed using an iterator:\\<close>"], ["", "definition mdinit :: \"('V,'W) mstate nres\" where\n    \"mdinit \\<equiv> do {\n      wl \\<leftarrow> FOREACH V (\\<lambda>v wl. RETURN (wl(v\\<mapsto>Infty))) Map.empty;\n      RETURN (wl(v0\\<mapsto>Num 0),[v0 \\<mapsto> ([],0)])\n    }\""], ["", "lemma mdinit_refines: \"mdinit \\<le> \\<Down>(build_rel \\<alpha>s dinvarm) dinit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mdinit \\<le> \\<Down> (br \\<alpha>s dinvarm) dinit", "unfolding mdinit_def dinit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n     Map.empty \\<bind>\n    (\\<lambda>wl.\n        RETURN (wl(v0 \\<mapsto> Num (0::'W)), [v0 \\<mapsto> ([], 0::'W)]))\n    \\<le> \\<Down> (br \\<alpha>s dinvarm)\n           (SPEC\n             (\\<lambda>(wl, res).\n                 wl = V \\<and>\n                 res v0 = Some [] \\<and>\n                 (\\<forall>v\\<in>V - {v0}. res v = None)))", "apply (rule build_rel_SPEC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n     Map.empty \\<bind>\n    (\\<lambda>wl.\n        RETURN (wl(v0 \\<mapsto> Num (0::'W)), [v0 \\<mapsto> ([], 0::'W)]))\n    \\<le> SPEC\n           (\\<lambda>x.\n               (case \\<alpha>s x of\n                (wl, res) \\<Rightarrow>\n                  wl = V \\<and>\n                  res v0 = Some [] \\<and>\n                  (\\<forall>v\\<in>V - {v0}. res v = None)) \\<and>\n               dinvarm x)", "apply (intro FOREACH_rule[where I=\"\\<lambda>it wl. (\\<forall>v\\<in>V-it. wl v = Some Infty) \\<and> \n      dom wl = V-it\"]\n           refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite V\n 2. (\\<forall>v\\<in>V - V. None = Some infty.Infty) \\<and>\n    dom Map.empty = V - V\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V;\n        (\\<forall>v\\<in>V - it. \\<sigma> v = Some infty.Infty) \\<and>\n        dom \\<sigma> = V - it\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>v\\<in>V - (it - {x}).\n                             (\\<sigma>(x \\<mapsto> infty.Infty)) v =\n                             Some infty.Infty) \\<and>\n                         dom (\\<sigma>(x \\<mapsto> infty.Infty)) =\n                         V - (it - {x})\n 4. \\<And>\\<sigma>.\n       (\\<forall>v\\<in>V - {}. \\<sigma> v = Some infty.Infty) \\<and>\n       dom \\<sigma> = V - {} \\<Longrightarrow>\n       (case \\<alpha>s\n              (\\<sigma>(v0 \\<mapsto> Num (0::'W)),\n               [v0 \\<mapsto> ([], 0::'W)]) of\n        (wl, res) \\<Rightarrow>\n          wl = V \\<and>\n          res v0 = Some [] \\<and>\n          (\\<forall>v\\<in>V - {v0}. res v = None)) \\<and>\n       dinvarm\n        (\\<sigma>(v0 \\<mapsto> Num (0::'W)), [v0 \\<mapsto> ([], 0::'W)])", "apply (auto \n      simp: \\<alpha>s_def \\<alpha>w_def \\<alpha>r_def dinvarm_def res_invarm_def infty_unbox\n      split: if_split_asm\n    )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The new pop function:\\<close>"], ["", "definition \n    mpop_min :: \"('V,'W) mstate \\<Rightarrow> ('V \\<times> 'W infty \\<times> ('V,'W) mstate) nres\" \n    where\n    \"mpop_min \\<sigma> \\<equiv> do {\n      let (wl,res) = \\<sigma>; \n      (v,w,wl')\\<leftarrow>prio_pop_min wl;\n      RETURN (v,w,(wl',res))\n    }\""], ["", "lemma mpop_min_refines:\n    \"\\<lbrakk> (\\<sigma>,\\<sigma>') \\<in> build_rel \\<alpha>s dinvarm \\<rbrakk> \\<Longrightarrow> \n      mpop_min \\<sigma> \\<le> \n       \\<Down>(build_rel \n          (\\<lambda>(v,w,\\<sigma>). (v,\\<alpha>s \\<sigma>)) \n          (\\<lambda>(v,w,\\<sigma>). dinvarm \\<sigma> \\<and> w = mpath_weight' (snd \\<sigma> v)))\n      (pop_min \\<sigma>')\"\n    \\<comment> \\<open>The two algorithms are structurally different, so we use the\n      nofail/inres method to prove refinement.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm \\<Longrightarrow>\n    mpop_min \\<sigma>\n    \\<le> \\<Down>\n           (br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n             (\\<lambda>(v, w, \\<sigma>).\n                 dinvarm \\<sigma> \\<and>\n                 w = mpath_weight' (snd \\<sigma> v)))\n           (pop_min \\<sigma>')", "unfolding mpop_min_def pop_min_def prio_pop_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm \\<Longrightarrow>\n    (let (wl, res) = \\<sigma>\n     in ASSERT (dom wl \\<noteq> {}) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>(e, w, q').\n                 q' = wl(e := None) \\<and>\n                 wl e = Some w \\<and>\n                 (\\<forall>e' w'.\n                     wl e' = Some w' \\<longrightarrow> w \\<le> w'))) \\<bind>\n        (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res)))\n    \\<le> \\<Down>\n           (br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n             (\\<lambda>(v, w, \\<sigma>).\n                 dinvarm \\<sigma> \\<and>\n                 w = mpath_weight' (snd \\<sigma> v)))\n           (let (wl, res) = \\<sigma>'\n            in ASSERT (wl \\<noteq> {}) \\<bind>\n               (\\<lambda>_.\n                   RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n                   (\\<lambda>v. RETURN (v, wl - {v}, res))))", "apply (rule pw_ref_I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm \\<Longrightarrow>\n    nofail\n     (let (wl, res) = \\<sigma>'\n      in ASSERT (wl \\<noteq> {}) \\<bind>\n         (\\<lambda>_.\n             RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n             (\\<lambda>v. RETURN (v, wl - {v}, res)))) \\<longrightarrow>\n    nofail\n     (let (wl, res) = \\<sigma>\n      in ASSERT (dom wl \\<noteq> {}) \\<bind>\n         (\\<lambda>_.\n             SPEC\n              (\\<lambda>(e, w, q').\n                  q' = wl(e := None) \\<and>\n                  wl e = Some w \\<and>\n                  (\\<forall>e' w'.\n                      wl e' = Some w' \\<longrightarrow>\n                      w \\<le> w'))) \\<bind>\n         (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<and>\n    (\\<forall>x.\n        inres\n         (let (wl, res) = \\<sigma>\n          in ASSERT (dom wl \\<noteq> {}) \\<bind>\n             (\\<lambda>_.\n                 SPEC\n                  (\\<lambda>(e, w, q').\n                      q' = wl(e := None) \\<and>\n                      wl e = Some w \\<and>\n                      (\\<forall>e' w'.\n                          wl e' = Some w' \\<longrightarrow>\n                          w \\<le> w'))) \\<bind>\n             (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res)))\n         x \\<longrightarrow>\n        (\\<exists>s'.\n            (x, s')\n            \\<in> br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n                   (\\<lambda>(v, w, \\<sigma>).\n                       dinvarm \\<sigma> \\<and>\n                       w = mpath_weight' (snd \\<sigma> v)) \\<and>\n            inres\n             (let (wl, res) = \\<sigma>'\n              in ASSERT (wl \\<noteq> {}) \\<bind>\n                 (\\<lambda>_.\n                     RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n                     (\\<lambda>v. RETURN (v, wl - {v}, res))))\n             s'))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n     nofail\n      (let (wl, res) = \\<sigma>'\n       in ASSERT (wl \\<noteq> {}) \\<bind>\n          (\\<lambda>_.\n              RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n              (\\<lambda>v. RETURN (v, wl - {v}, res))))\\<rbrakk>\n    \\<Longrightarrow> nofail\n                       (let (wl, res) = \\<sigma>\n                        in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                           (\\<lambda>_.\n                               SPEC\n                                (\\<lambda>(e, w, q').\n                                    q' = wl(e := None) \\<and>\n                                    wl e = Some w \\<and>\n                                    (\\<forall>e' w'.\n  wl e' = Some w' \\<longrightarrow> w \\<le> w'))) \\<bind>\n                           (\\<lambda>(v, w, wl').\n                               RETURN (v, w, wl', res))) \\<and>\n                      (\\<forall>x.\n                          inres\n                           (let (wl, res) = \\<sigma>\n                            in ASSERT (dom wl \\<noteq> {}) \\<bind>\n                               (\\<lambda>_.\n                                   SPEC\n                                    (\\<lambda>(e, w, q').\n  q' = wl(e := None) \\<and>\n  wl e = Some w \\<and>\n  (\\<forall>e' w'. wl e' = Some w' \\<longrightarrow> w \\<le> w'))) \\<bind>\n                               (\\<lambda>(v, w, wl').\n                                   RETURN (v, w, wl', res)))\n                           x \\<longrightarrow>\n                          (\\<exists>s'.\n                              (x, s')\n                              \\<in> br (\\<lambda>(v, w, \\<sigma>).\n     (v, \\<alpha>s \\<sigma>))\n                                     (\\<lambda>(v, w, \\<sigma>).\n   dinvarm \\<sigma> \\<and> w = mpath_weight' (snd \\<sigma> v)) \\<and>\n                              inres\n                               (let (wl, res) = \\<sigma>'\n                                in ASSERT (wl \\<noteq> {}) \\<bind>\n                                   (\\<lambda>_.\n RES (least_map (path_weight' \\<circ> res) wl) \\<bind>\n (\\<lambda>v. RETURN (v, wl - {v}, res))))\n                               s'))", "apply (auto simp add: refine_pw_simps \\<alpha>s_def \\<alpha>w_def refine_rel_defs\n      split: prod.split prod.split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1a x a aa b y.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a x = Some y\\<rbrakk>\n       \\<Longrightarrow> dinvarm (x1a(a := None), b)\n 2. \\<And>x1a x a aa b y.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a x = Some y\\<rbrakk>\n       \\<Longrightarrow> aa = mpath_weight' (b a)\n 3. \\<And>x1a x a aa b y.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; x1a x = Some y\\<rbrakk>\n       \\<Longrightarrow> a \\<in> least_map\n                                  ((path_weight' \\<circ>\\<circ> \\<alpha>r)\n                                    b)\n                                  (dom x1a)\n 4. \\<And>x1a x a aa b xa y ya.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; (if xa = a then None else x1a xa) = Some y;\n        x1a x = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x1a xa = Some y", "apply (auto simp: dinvarm_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1a x a aa b y.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a x = Some y\\<rbrakk>\n       \\<Longrightarrow> aa = mpath_weight' (b a)\n 2. \\<And>x1a x a aa b y.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; x1a x = Some y\\<rbrakk>\n       \\<Longrightarrow> a \\<in> least_map\n                                  ((path_weight' \\<circ>\\<circ> \\<alpha>r)\n                                    b)\n                                  (dom x1a)\n 3. \\<And>x1a x a aa b xa y ya.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; (if xa = a then None else x1a xa) = Some y;\n        x1a x = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x1a xa = Some y", "apply (auto simp: mpath_weight'_correct wl_weight_correct) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1a x a aa b y.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; x1a x = Some y\\<rbrakk>\n       \\<Longrightarrow> a \\<in> least_map\n                                  ((path_weight' \\<circ>\\<circ> \\<alpha>r)\n                                    b)\n                                  (dom x1a)\n 2. \\<And>x1a x a aa b xa y ya.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; (if xa = a then None else x1a xa) = Some y;\n        x1a x = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x1a xa = Some y", "apply (auto \n      simp: wl_weight_correct \n      intro!: least_map.intros\n    ) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1a x a aa b xa y ya.\n       \\<lbrakk>\\<sigma>' = (dom x1a, \\<alpha>r b); dinvarm (x1a, b);\n        \\<sigma> = (x1a, b); x1a a = Some aa;\n        \\<forall>e' w'. x1a e' = Some w' \\<longrightarrow> aa \\<le> w';\n        x1a \\<noteq> Map.empty; (if xa = a then None else x1a xa) = Some y;\n        x1a x = Some ya\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. x1a xa = Some y", "apply (metis restrict_map_eq(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The new update function:\\<close>"], ["", "definition \"uinvarm v wl res it \\<sigma> \\<equiv> \n    uinvar v wl res it (\\<alpha>s \\<sigma>) \\<and> dinvarm \\<sigma>\""], ["", "definition mupdate :: \"'V \\<Rightarrow> 'W infty \\<Rightarrow> ('V,'W) mstate \\<Rightarrow> ('V,'W) mstate nres\"\n   where \n    \"mupdate v wv \\<sigma> \\<equiv> do {\n      ASSERT (update_pre v (\\<alpha>s \\<sigma>) \\<and> wv=mpath_weight' (snd \\<sigma> v));\n      let (wl,res) = \\<sigma>;\n      let pv = mpath' (res v);\n      FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl) (\\<alpha>r res)\\<^esup> (succ G v) (\\<lambda>(w',v') (wl,res). \n        if (wv + Num w' < mpath_weight' (res v')) then do {\n          ASSERT (v'\\<in>dom wl \\<and> pv \\<noteq> None);\n          ASSERT (wv \\<noteq> Infty);\n          RETURN (wl(v'\\<mapsto>wv + Num w'),\n                    res(v' \\<mapsto> ((v,w',v')#the pv,val wv + w') ))\n        } else RETURN (wl,res)\n        ) (wl,res)\n    }\""], ["", "lemma mupdate_refines: \n    assumes SREF: \"(\\<sigma>,\\<sigma>')\\<in>build_rel \\<alpha>s dinvarm\"\n    assumes WV: \"wv = mpath_weight' (snd \\<sigma> v)\"\n    assumes VV': \"v'=v\"\n    shows \"mupdate v wv \\<sigma> \\<le> \\<Down>(build_rel \\<alpha>s dinvarm) (update' v' \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v' \\<sigma>')", "proof (simp only: VV')"], ["proof (state)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "txt \\<open>Show that IF-condition is a refinement:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "fix wl res wl' res' it w' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "assume \"uinvarm v (\\<alpha>w wl) (\\<alpha>r res) it (wl',res')\" \n        and \"dinvarm (wl,res)\""], ["proof (state)\nthis:\n  uinvarm v (\\<alpha>w wl) (\\<alpha>r res) it (wl', res')\n  dinvarm (wl, res)\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "hence \"mpath_weight' (res v) + Num w' < mpath_weight' (res' v') \\<longleftrightarrow>\n        path_weight' (\\<alpha>r res v) + Num w' < path_weight' (\\<alpha>r res' v')\""], ["proof (prove)\nusing this:\n  uinvarm v (\\<alpha>w wl) (\\<alpha>r res) it (wl', res')\n  dinvarm (wl, res)\n\ngoal (1 subgoal):\n 1. (mpath_weight' (res v) + Num w' < mpath_weight' (res' v')) =\n    (path_weight' (\\<alpha>r res v) + Num w'\n     < path_weight' (\\<alpha>r res' v'))", "unfolding uinvarm_def"], ["proof (prove)\nusing this:\n  uinvar v (\\<alpha>w wl) (\\<alpha>r res) it (\\<alpha>s (wl', res')) \\<and>\n  dinvarm (wl', res')\n  dinvarm (wl, res)\n\ngoal (1 subgoal):\n 1. (mpath_weight' (res v) + Num w' < mpath_weight' (res' v')) =\n    (path_weight' (\\<alpha>r res v) + Num w'\n     < path_weight' (\\<alpha>r res' v'))", "by (auto simp add: mpath_weight'_correct)"], ["proof (state)\nthis:\n  (mpath_weight' (res v) + Num w' < mpath_weight' (res' v')) =\n  (path_weight' (\\<alpha>r res v) + Num w'\n   < path_weight' (\\<alpha>r res' v'))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2)\\<rbrakk>\n  \\<Longrightarrow> (mpath_weight' (?res2 v) + Num ?w'2\n                     < mpath_weight' (?res'2 ?v'a2)) =\n                    (path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n                     < path_weight' (\\<alpha>r ?res'2 ?v'a2))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "note COND_refine=this"], ["proof (state)\nthis:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2)\\<rbrakk>\n  \\<Longrightarrow> (mpath_weight' (?res2 v) + Num ?w'2\n                     < mpath_weight' (?res'2 ?v'a2)) =\n                    (path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n                     < path_weight' (\\<alpha>r ?res'2 ?v'a2))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "{"], ["proof (state)\nthis:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2)\\<rbrakk>\n  \\<Longrightarrow> (mpath_weight' (?res2 v) + Num ?w'2\n                     < mpath_weight' (?res'2 ?v'a2)) =\n                    (path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n                     < path_weight' (\\<alpha>r ?res'2 ?v'a2))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "txt \\<open>THEN-case:\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2)\\<rbrakk>\n  \\<Longrightarrow> (mpath_weight' (?res2 v) + Num ?w'2\n                     < mpath_weight' (?res'2 ?v'a2)) =\n                    (path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n                     < path_weight' (\\<alpha>r ?res'2 ?v'a2))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "fix wl res wl' res' it w' v'"], ["proof (state)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "assume UINV: \"uinvarm v (\\<alpha>w wl) (\\<alpha>r res) it (wl',res')\"\n        and DINV: \"dinvarm (wl,res)\"\n        and \"mpath_weight' (res v) + Num w' < mpath_weight' (res' v')\"\n        and \"path_weight' (\\<alpha>r res v) + Num w' < path_weight' (\\<alpha>r res' v')\"\n        and V'MEM: \"v'\\<in>\\<alpha>w wl'\"\n        and NN: \"\\<alpha>r res v \\<noteq> None\""], ["proof (state)\nthis:\n  uinvarm v (\\<alpha>w wl) (\\<alpha>r res) it (wl', res')\n  dinvarm (wl, res)\n  mpath_weight' (res v) + Num w' < mpath_weight' (res' v')\n  path_weight' (\\<alpha>r res v) + Num w' < path_weight' (\\<alpha>r res' v')\n  v' \\<in> \\<alpha>w wl'\n  \\<alpha>r res v \\<noteq> None\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "from NN"], ["proof (chain)\npicking this:\n  \\<alpha>r res v \\<noteq> None", "obtain pv wv where\n        ARV: \"\\<alpha>r res v = Some (rev pv)\" and\n        RV: \"res v = Some (pv,wv)\""], ["proof (prove)\nusing this:\n  \\<alpha>r res v \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>pv wv.\n        \\<lbrakk>\\<alpha>r res v = Some (rev pv);\n         res v = Some (pv, wv)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<alpha>r_def"], ["proof (prove)\nusing this:\n  (case res v of None \\<Rightarrow> None\n   | Some (p, w) \\<Rightarrow> Some (rev p)) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. (\\<And>pv wv.\n        \\<lbrakk>(case res v of None \\<Rightarrow> None\n                  | Some (p, w) \\<Rightarrow> Some (rev p)) =\n                 Some (rev pv);\n         res v = Some (pv, wv)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.split_asm)"], ["proof (state)\nthis:\n  \\<alpha>r res v = Some (rev pv)\n  res v = Some (pv, wv)\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "with DINV"], ["proof (chain)\npicking this:\n  dinvarm (wl, res)\n  \\<alpha>r res v = Some (rev pv)\n  res v = Some (pv, wv)", "have [simp]: \"wv = path_weight (rev pv)\""], ["proof (prove)\nusing this:\n  dinvarm (wl, res)\n  \\<alpha>r res v = Some (rev pv)\n  res v = Some (pv, wv)\n\ngoal (1 subgoal):\n 1. wv = path_weight (rev pv)", "unfolding dinvarm_def res_invarm_def"], ["proof (prove)\nusing this:\n  let (wl, res) = (wl, res)\n  in (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and>\n     (\\<forall>v.\n         case res v of None \\<Rightarrow> True\n         | Some (p, w) \\<Rightarrow> w = path_weight (rev p))\n  \\<alpha>r res v = Some (rev pv)\n  res v = Some (pv, wv)\n\ngoal (1 subgoal):\n 1. wv = path_weight (rev pv)", "by (auto split: option.split_asm)"], ["proof (state)\nthis:\n  wv = path_weight (rev pv)\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "note [simp] = ARV RV"], ["proof (state)\nthis:\n  \\<alpha>r res v = Some (rev pv)\n  res v = Some (pv, wv)\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "from V'MEM NN"], ["proof (chain)\npicking this:\n  v' \\<in> \\<alpha>w wl'\n  \\<alpha>r res v \\<noteq> None", "have \"v'\\<in>dom wl'\" (is \"?G1\") \n        and \"mpath' (res v) \\<noteq> None\" (is \"?G2\")"], ["proof (prove)\nusing this:\n  v' \\<in> \\<alpha>w wl'\n  \\<alpha>r res v \\<noteq> None\n\ngoal (1 subgoal):\n 1. v' \\<in> dom wl' &&& mpath' (res v) \\<noteq> None", "unfolding \\<alpha>w_def \\<alpha>r_def"], ["proof (prove)\nusing this:\n  v' \\<in> dom wl'\n  (case res v of None \\<Rightarrow> None\n   | Some (p, w) \\<Rightarrow> Some (rev p)) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. v' \\<in> dom wl' &&& mpath' (res v) \\<noteq> None", "by (auto split: option.split_asm)"], ["proof (state)\nthis:\n  v' \\<in> dom wl'\n  mpath' (res v) \\<noteq> None\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "hence \"\\<And>x. \\<alpha>w wl' = \\<alpha>w (wl'(v'\\<mapsto>x))\""], ["proof (prove)\nusing this:\n  v' \\<in> dom wl'\n  mpath' (res v) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<alpha>w wl' = \\<alpha>w (wl'(v' \\<mapsto> x))", "by (auto simp: \\<alpha>w_def)"], ["proof (state)\nthis:\n  \\<alpha>w wl' = \\<alpha>w (wl'(v' \\<mapsto> ?x))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "moreover"], ["proof (state)\nthis:\n  \\<alpha>w wl' = \\<alpha>w (wl'(v' \\<mapsto> ?x))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "have \"mpath' (res v) = map_option rev (\\<alpha>r res v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpath' (res v) = map_option rev (\\<alpha>r res v)", "using DINV"], ["proof (prove)\nusing this:\n  dinvarm (wl, res)\n\ngoal (1 subgoal):\n 1. mpath' (res v) = map_option rev (\\<alpha>r res v)", "by (simp add: mpath'_correct)"], ["proof (state)\nthis:\n  mpath' (res v) = map_option rev (\\<alpha>r res v)\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha>w wl' = \\<alpha>w (wl'(v' \\<mapsto> ?x))\n  mpath' (res v) = map_option rev (\\<alpha>r res v)", "have\n        \"\\<alpha>w wl' = \\<alpha>w (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w')) \n        \\<and> (\\<alpha>r res')(v' \\<mapsto> the (\\<alpha>r res v)@[(v, w', v')]) \n           = \\<alpha>r (res'(v' \\<mapsto> ((v, w', v')#the (mpath' (res v)), \n                 val (mpath_weight' (res v)) + w')))\" (is ?G3)"], ["proof (prove)\nusing this:\n  \\<alpha>w wl' = \\<alpha>w (wl'(v' \\<mapsto> ?x))\n  mpath' (res v) = map_option rev (\\<alpha>r res v)\n\ngoal (1 subgoal):\n 1. \\<alpha>w wl' =\n    \\<alpha>w (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w')) \\<and>\n    \\<alpha>r res'(v' \\<mapsto> the (\\<alpha>r res v) @ [(v, w', v')]) =\n    \\<alpha>r\n     (res'(v' \\<mapsto>\n      ((v, w', v') # the (mpath' (res v)),\n       val (mpath_weight' (res v)) + w')))", "by (auto simp add: \\<alpha>r_def intro!: ext)"], ["proof (state)\nthis:\n  \\<alpha>w wl' =\n  \\<alpha>w (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w')) \\<and>\n  \\<alpha>r res'(v' \\<mapsto> the (\\<alpha>r res v) @ [(v, w', v')]) =\n  \\<alpha>r\n   (res'(v' \\<mapsto>\n    ((v, w', v') # the (mpath' (res v)), val (mpath_weight' (res v)) + w')))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "have\n        \"(dinvarm (wl'(v'\\<mapsto>mpath_weight' (res v) + Num w'),\n                           res'(v' \\<mapsto> ((v,w',v') # the (mpath' (res v)),\n                                       val (mpath_weight' (res v)) + w'\n                                      ))))\" (is ?G4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dinvarm\n     (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w'), res'(v' \\<mapsto>\n      ((v, w', v') # the (mpath' (res v)),\n       val (mpath_weight' (res v)) + w')))", "using UINV"], ["proof (prove)\nusing this:\n  uinvarm v (\\<alpha>w wl) (\\<alpha>r res) it (wl', res')\n\ngoal (1 subgoal):\n 1. dinvarm\n     (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w'), res'(v' \\<mapsto>\n      ((v, w', v') # the (mpath' (res v)),\n       val (mpath_weight' (res v)) + w')))", "unfolding uinvarm_def dinvarm_def res_invarm_def"], ["proof (prove)\nusing this:\n  uinvar v (\\<alpha>w wl) (\\<alpha>r res) it (\\<alpha>s (wl', res')) \\<and>\n  (let (wl, res) = (wl', res')\n   in (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and>\n      (\\<forall>v.\n          case res v of None \\<Rightarrow> True\n          | Some (p, w) \\<Rightarrow> w = path_weight (rev p)))\n\ngoal (1 subgoal):\n 1. let (wl, res) =\n          (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w'), res'(v' \n           \\<mapsto>\n           ((v, w', v') # the (mpath' (res v)),\n            val (mpath_weight' (res v)) + w')))\n    in (\\<forall>v\\<in>dom wl. the (wl v) = mpath_weight' (res v)) \\<and>\n       (\\<forall>v.\n           case res v of None \\<Rightarrow> True\n           | Some (p, w) \\<Rightarrow> w = path_weight (rev p))", "by (auto simp: infty_unbox split: option.split option.split_asm)"], ["proof (state)\nthis:\n  dinvarm\n   (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w'), res'(v' \\<mapsto>\n    ((v, w', v') # the (mpath' (res v)), val (mpath_weight' (res v)) + w')))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "note \\<open>?G1\\<close> \\<open>?G2\\<close> \\<open>?G3\\<close> \\<open>?G4\\<close>"], ["proof (state)\nthis:\n  v' \\<in> dom wl'\n  mpath' (res v) \\<noteq> None\n  \\<alpha>w wl' =\n  \\<alpha>w (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w')) \\<and>\n  \\<alpha>r res'(v' \\<mapsto> the (\\<alpha>r res v) @ [(v, w', v')]) =\n  \\<alpha>r\n   (res'(v' \\<mapsto>\n    ((v, w', v') # the (mpath' (res v)), val (mpath_weight' (res v)) + w')))\n  dinvarm\n   (wl'(v' \\<mapsto> mpath_weight' (res v) + Num w'), res'(v' \\<mapsto>\n    ((v, w', v') # the (mpath' (res v)), val (mpath_weight' (res v)) + w')))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ?v'a2 \\<in> dom ?wl'2\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> mpath' (?res2 v) \\<noteq> None\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<alpha>w ?wl'2 =\n                    \\<alpha>w\n                     (?wl'2(?v'a2 \\<mapsto>\n                      mpath_weight' (?res2 v) + Num ?w'2)) \\<and>\n                    \\<alpha>r ?res'2(?v'a2 \\<mapsto>\n                    the (\\<alpha>r ?res2 v) @ [(v, ?w'2, ?v'a2)]) =\n                    \\<alpha>r\n                     (?res'2(?v'a2 \\<mapsto>\n                      ((v, ?w'2, ?v'a2) # the (mpath' (?res2 v)),\n                       val (mpath_weight' (?res2 v)) + ?w'2)))\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> dinvarm\n                     (?wl'2(?v'a2 \\<mapsto>\n                      mpath_weight' (?res2 v) + Num ?w'2), ?res'2(?v'a2 \n                      \\<mapsto>\n                      ((v, ?w'2, ?v'a2) # the (mpath' (?res2 v)),\n                       val (mpath_weight' (?res2 v)) + ?w'2)))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "note THEN_refine=this"], ["proof (state)\nthis:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> ?v'a2 \\<in> dom ?wl'2\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> mpath' (?res2 v) \\<noteq> None\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<alpha>w ?wl'2 =\n                    \\<alpha>w\n                     (?wl'2(?v'a2 \\<mapsto>\n                      mpath_weight' (?res2 v) + Num ?w'2)) \\<and>\n                    \\<alpha>r ?res'2(?v'a2 \\<mapsto>\n                    the (\\<alpha>r ?res2 v) @ [(v, ?w'2, ?v'a2)]) =\n                    \\<alpha>r\n                     (?res'2(?v'a2 \\<mapsto>\n                      ((v, ?w'2, ?v'a2) # the (mpath' (?res2 v)),\n                       val (mpath_weight' (?res2 v)) + ?w'2)))\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> dinvarm\n                     (?wl'2(?v'a2 \\<mapsto>\n                      mpath_weight' (?res2 v) + Num ?w'2), ?res'2(?v'a2 \n                      \\<mapsto>\n                      ((v, ?w'2, ?v'a2) # the (mpath' (?res2 v)),\n                       val (mpath_weight' (?res2 v)) + ?w'2)))\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "note [refine2] = inj_on_id"], ["proof (state)\nthis:\n  inj_on id ?A\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "note [simp] = refine_rel_defs"], ["proof (state)\nthis:\n  br ?\\<alpha> ?I \\<equiv> {(c, a). a = ?\\<alpha> c \\<and> ?I c}\n  \\<langle>?R\\<rangle>old_set_rel \\<equiv>\n  {(S, S'). S' = ?R `` S \\<and> S \\<subseteq> Domain ?R}\n  \\<langle>?R\\<rangle>set_rel \\<equiv>\n  {(A, B).\n   (\\<forall>x\\<in>A. \\<exists>y\\<in>B. (x, y) \\<in> ?R) \\<and>\n   (\\<forall>y\\<in>B. \\<exists>x\\<in>A. (x, y) \\<in> ?R)}\n  \\<langle>?R\\<rangle>list_rel \\<equiv>\n  {(l, l'). list_all2 (\\<lambda>x x'. (x, x') \\<in> ?R) l l'}\n  \\<langle>?Rl, ?Rr\\<rangle>sum_rel \\<equiv>\n  {(Inl a, Inl a') |a a'. (a, a') \\<in> ?Rl} \\<union>\n  {(Inr a, Inr a') |a a'. (a, a') \\<in> ?Rr}\n  \\<langle>?R\\<rangle>option_rel \\<equiv>\n  {(Some a, Some a') |a a'. (a, a') \\<in> ?R} \\<union> {(None, None)}\n  ?R1.0 \\<times>\\<^sub>r ?R2.0 \\<equiv>\n  {((a, b), a', b'). (a, a') \\<in> ?R1.0 \\<and> (b, b') \\<in> ?R2.0}\n  ?A \\<rightarrow> ?B \\<equiv>\n  {(f, f'). \\<forall>(a, a')\\<in>?A. (f a, f' a') \\<in> ?B}\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "show \"mupdate v wv \\<sigma> \\<le> \\<Down>(build_rel \\<alpha>s dinvarm) (update' v \\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "using SREF WV"], ["proof (prove)\nusing this:\n  (\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm\n  wv = mpath_weight' (snd \\<sigma> v)\n\ngoal (1 subgoal):\n 1. mupdate v wv \\<sigma>\n    \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')", "unfolding mupdate_def update'_def"], ["proof (prove)\nusing this:\n  (\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm\n  wv = mpath_weight' (snd \\<sigma> v)\n\ngoal (1 subgoal):\n 1. ASSERT\n     (update_pre v (\\<alpha>s \\<sigma>) \\<and>\n      wv = mpath_weight' (snd \\<sigma> v)) \\<bind>\n    (\\<lambda>_.\n        let (wl, res) = \\<sigma>; pv = mpath' (res v)\n        in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl) (\\<alpha>r res)\\<^esup>\n            (succ G v)\n            (\\<lambda>(w', v') (wl, res).\n                if wv + Num w' < mpath_weight' (res v')\n                then ASSERT\n                      (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n                     (\\<lambda>_.\n                         ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n                         (\\<lambda>_.\n                             RETURN\n                              (wl(v' \\<mapsto> wv + Num w'), res(v' \n                               \\<mapsto>\n                               ((v, w', v') # the pv, val wv + w')))))\n                else RETURN (wl, res))\n            (wl, res))\n    \\<le> \\<Down> (br \\<alpha>s dinvarm)\n           (ASSERT (update_pre v \\<sigma>') \\<bind>\n            (\\<lambda>_.\n                let (wl, res) = \\<sigma>'; wv = path_weight' (res v);\n                    pv = res v\n                in FOREACH\\<^bsup>uinvar v wl res\\<^esup> (succ G v)\n                    (\\<lambda>(w', v') (wl, res).\n                        if wv + Num w' < path_weight' (res v')\n                        then ASSERT\n                              (v' \\<in> wl \\<and> pv \\<noteq> None) \\<bind>\n                             (\\<lambda>_.\n                                 RETURN\n                                  (wl, res(v' \\<mapsto>\n                                   the pv @ [(v, w', v')])))\n                        else RETURN (wl, res))\n                    (wl, res)))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n     wv = mpath_weight' (snd \\<sigma> v)\\<rbrakk>\n    \\<Longrightarrow> ASSERT\n                       (update_pre v (\\<alpha>s \\<sigma>) \\<and>\n                        wv = mpath_weight' (snd \\<sigma> v)) \\<bind>\n                      (\\<lambda>_.\n                          let (wl, res) = \\<sigma>; pv = mpath' (res v)\n                          in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n       (\\<alpha>r res)\\<^esup>\n                              (succ G v)\n                              (\\<lambda>(w', v') (wl, res).\n                                  if wv + Num w' < mpath_weight' (res v')\n                                  then ASSERT\n  (v' \\<in> dom wl \\<and> pv \\<noteq> None) \\<bind>\n (\\<lambda>_.\n     ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n     (\\<lambda>_.\n         RETURN\n          (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n           ((v, w', v') # the pv, val wv + w')))))\n                                  else RETURN (wl, res))\n                              (wl, res))\n                      \\<le> \\<Down> (br \\<alpha>s dinvarm)\n                             (ASSERT (update_pre v \\<sigma>') \\<bind>\n                              (\\<lambda>_.\n                                  let (wl, res) = \\<sigma>';\nwv = path_weight' (res v); pv = res v\n                                  in FOREACH\\<^bsup>uinvar v wl res\\<^esup>\n(succ G v)\n(\\<lambda>(w', v') (wl, res).\n    if wv + Num w' < path_weight' (res v')\n    then ASSERT (v' \\<in> wl \\<and> pv \\<noteq> None) \\<bind>\n         (\\<lambda>_. RETURN (wl, res(v' \\<mapsto> the pv @ [(v, w', v')])))\n    else RETURN (wl, res))\n(wl, res)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n     wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>'\\<rbrakk>\n    \\<Longrightarrow> update_pre v (\\<alpha>s \\<sigma>)\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> succ G v = id ` succ G v\n 3. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((x1a, x2a), x1, x2) \\<in> br \\<alpha>s dinvarm\n 4. \\<And>x1 x2 x1a x2a it \\<sigma>'' it' \\<sigma>'''.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); it' = id ` it;\n        it \\<subseteq> succ G v; it' \\<subseteq> succ G v;\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm\\<rbrakk>\n       \\<Longrightarrow> uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it\n                          \\<sigma>''\n 5. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (wv + Num x1d < mpath_weight' (x2e x2d)) =\n                         (path_weight' (x2 v) + Num x1b\n                          < path_weight' (x2c x2b))\n 6. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x2d \\<in> dom x1e\n 7. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mpath' (x2a v) \\<noteq> None\n 8. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> wv \\<noteq> infty.Infty\n 9. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None;\n        wv \\<noteq> infty.Infty\\<rbrakk>\n       \\<Longrightarrow> ((x1e(x2d \\<mapsto> wv + Num x1d), x2e(x2d \n                           \\<mapsto>\n                           ((v, x1d, x2d) # the (mpath' (x2a v)),\n                            val wv + x1d))),\n                          x1c, x2c(x2b \\<mapsto>\n                          the (x2 v) @ [(v, x1b, x2b)]))\n                         \\<in> br \\<alpha>s dinvarm\n 10. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n        x1d x2d x1e x2e.\n        \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n         wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n         update_pre v (\\<alpha>s \\<sigma>) \\<and>\n         wv = mpath_weight' (snd \\<sigma> v);\n         \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n         x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n         it' \\<subseteq> succ G v;\n         uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n         uinvar v x1 x2 it' \\<sigma>''';\n         (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n         \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n         x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n         \\<not> path_weight' (x2 v) + Num x1b\n                < path_weight' (x2c x2b)\\<rbrakk>\n        \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "apply simp_all [3]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 x1a x2a it \\<sigma>'' it' \\<sigma>'''.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); it' = id ` it;\n        it \\<subseteq> succ G v; it' \\<subseteq> succ G v;\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm\\<rbrakk>\n       \\<Longrightarrow> uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it\n                          \\<sigma>''\n 2. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (wv + Num x1d < mpath_weight' (x2e x2d)) =\n                         (path_weight' (x2 v) + Num x1b\n                          < path_weight' (x2c x2b))\n 3. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x2d \\<in> dom x1e\n 4. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mpath' (x2a v) \\<noteq> None\n 5. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> wv \\<noteq> infty.Infty\n 6. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None;\n        wv \\<noteq> infty.Infty\\<rbrakk>\n       \\<Longrightarrow> ((x1e(x2d \\<mapsto> wv + Num x1d), x2e(x2d \n                           \\<mapsto>\n                           ((v, x1d, x2d) # the (mpath' (x2a v)),\n                            val wv + x1d))),\n                          x1c, x2c(x2b \\<mapsto>\n                          the (x2 v) @ [(v, x1b, x2b)]))\n                         \\<in> br \\<alpha>s dinvarm\n 7. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "apply (simp add: \\<alpha>s_def uinvarm_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (wv + Num x1d < mpath_weight' (x2e x2d)) =\n                         (path_weight' (x2 v) + Num x1b\n                          < path_weight' (x2c x2b))\n 2. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> x2d \\<in> dom x1e\n 3. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> mpath' (x2a v) \\<noteq> None\n 4. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> wv \\<noteq> infty.Infty\n 5. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None;\n        wv \\<noteq> infty.Infty\\<rbrakk>\n       \\<Longrightarrow> ((x1e(x2d \\<mapsto> wv + Num x1d), x2e(x2d \n                           \\<mapsto>\n                           ((v, x1d, x2d) # the (mpath' (x2a v)),\n                            val wv + x1d))),\n                          x1c, x2c(x2b \\<mapsto>\n                          the (x2 v) @ [(v, x1b, x2b)]))\n                         \\<in> br \\<alpha>s dinvarm\n 6. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "apply (simp_all add: \\<alpha>s_def COND_refine THEN_refine(1-2)) [3]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> wv \\<noteq> infty.Infty\n 2. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None;\n        wv \\<noteq> infty.Infty\\<rbrakk>\n       \\<Longrightarrow> ((x1e(x2d \\<mapsto> wv + Num x1d), x2e(x2d \n                           \\<mapsto>\n                           ((v, x1d, x2d) # the (mpath' (x2a v)),\n                            val wv + x1d))),\n                          x1c, x2c(x2b \\<mapsto>\n                          the (x2 v) @ [(v, x1b, x2b)]))\n                         \\<in> br \\<alpha>s dinvarm\n 3. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "apply (rule ccontr,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None;\n        wv \\<noteq> infty.Infty\\<rbrakk>\n       \\<Longrightarrow> ((x1e(x2d \\<mapsto> wv + Num x1d), x2e(x2d \n                           \\<mapsto>\n                           ((v, x1d, x2d) # the (mpath' (x2a v)),\n                            val wv + x1d))),\n                          x1c, x2c(x2b \\<mapsto>\n                          the (x2 v) @ [(v, x1b, x2b)]))\n                         \\<in> br \\<alpha>s dinvarm\n 2. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "using THEN_refine(3,4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> \\<alpha>w ?wl'2 =\n                    \\<alpha>w\n                     (?wl'2(?v'a2 \\<mapsto>\n                      mpath_weight' (?res2 v) + Num ?w'2)) \\<and>\n                    \\<alpha>r ?res'2(?v'a2 \\<mapsto>\n                    the (\\<alpha>r ?res2 v) @ [(v, ?w'2, ?v'a2)]) =\n                    \\<alpha>r\n                     (?res'2(?v'a2 \\<mapsto>\n                      ((v, ?w'2, ?v'a2) # the (mpath' (?res2 v)),\n                       val (mpath_weight' (?res2 v)) + ?w'2)))\n  \\<lbrakk>uinvarm v (\\<alpha>w ?wl2) (\\<alpha>r ?res2) ?it2\n            (?wl'2, ?res'2);\n   dinvarm (?wl2, ?res2);\n   mpath_weight' (?res2 v) + Num ?w'2 < mpath_weight' (?res'2 ?v'a2);\n   path_weight' (\\<alpha>r ?res2 v) + Num ?w'2\n   < path_weight' (\\<alpha>r ?res'2 ?v'a2);\n   ?v'a2 \\<in> \\<alpha>w ?wl'2; \\<alpha>r ?res2 v \\<noteq> None\\<rbrakk>\n  \\<Longrightarrow> dinvarm\n                     (?wl'2(?v'a2 \\<mapsto>\n                      mpath_weight' (?res2 v) + Num ?w'2), ?res'2(?v'a2 \n                      \\<mapsto>\n                      ((v, ?w'2, ?v'a2) # the (mpath' (?res2 v)),\n                       val (mpath_weight' (?res2 v)) + ?w'2)))\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); wv + Num x1d < mpath_weight' (x2e x2d);\n        path_weight' (x2 v) + Num x1b < path_weight' (x2c x2b);\n        x2b \\<in> x1c \\<and> x2 v \\<noteq> None;\n        x2d \\<in> dom x1e \\<and> mpath' (x2a v) \\<noteq> None;\n        wv \\<noteq> infty.Infty\\<rbrakk>\n       \\<Longrightarrow> ((x1e(x2d \\<mapsto> wv + Num x1d), x2e(x2d \n                           \\<mapsto>\n                           ((v, x1d, x2d) # the (mpath' (x2a v)),\n                            val wv + x1d))),\n                          x1c, x2c(x2b \\<mapsto>\n                          the (x2 v) @ [(v, x1b, x2b)]))\n                         \\<in> br \\<alpha>s dinvarm\n 2. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "apply (auto simp: \\<alpha>s_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "txt \\<open>The ELSE-case is trivial:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a x it \\<sigma>'' x' it' \\<sigma>''' x1b x2b x1c x2c\n       x1d x2d x1e x2e.\n       \\<lbrakk>(\\<sigma>, \\<sigma>') \\<in> br \\<alpha>s dinvarm;\n        wv = mpath_weight' (snd \\<sigma> v); update_pre v \\<sigma>';\n        update_pre v (\\<alpha>s \\<sigma>) \\<and>\n        wv = mpath_weight' (snd \\<sigma> v);\n        \\<sigma>' = (x1, x2); \\<sigma> = (x1a, x2a); x' = id x; x \\<in> it;\n        x' \\<in> it'; it' = id ` it; it \\<subseteq> succ G v;\n        it' \\<subseteq> succ G v;\n        uinvarm v (\\<alpha>w x1a) (\\<alpha>r x2a) it \\<sigma>'';\n        uinvar v x1 x2 it' \\<sigma>''';\n        (\\<sigma>'', \\<sigma>''') \\<in> br \\<alpha>s dinvarm;\n        \\<sigma>''' = (x1c, x2c); x' = (x1b, x2b); \\<sigma>'' = (x1e, x2e);\n        x = (x1d, x2d); \\<not> wv + Num x1d < mpath_weight' (x2e x2d);\n        \\<not> path_weight' (x2 v) + Num x1b\n               < path_weight' (x2c x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x2e), x1c, x2c) \\<in> br \\<alpha>s dinvarm", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mupdate v wv \\<sigma>\n  \\<le> \\<Down> (br \\<alpha>s dinvarm) (update' v \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we assemble the refined algorithm:\\<close>"], ["", "definition mdijkstra where\n    \"mdijkstra \\<equiv> do {\n      \\<sigma>0 \\<leftarrow> mdinit; \n      (_,res) \\<leftarrow> WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup> (\\<lambda>(wl,_). dom wl\\<noteq>{}) \n            (\\<lambda>\\<sigma>. do { (v,wv,\\<sigma>') \\<leftarrow> mpop_min \\<sigma>; mupdate v wv \\<sigma>' } )\n            \\<sigma>0;\n      RETURN res\n    }\""], ["", "lemma mdijkstra_refines: \"mdijkstra \\<le> \\<Down>(build_rel \\<alpha>r res_invarm) dijkstra'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'", "note [refine] = mdinit_refines mpop_min_refines mupdate_refines"], ["proof (state)\nthis:\n  mdinit \\<le> \\<Down> (br \\<alpha>s dinvarm) dinit\n  (?\\<sigma>, ?\\<sigma>') \\<in> br \\<alpha>s dinvarm \\<Longrightarrow>\n  mpop_min ?\\<sigma>\n  \\<le> \\<Down>\n         (br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n           (\\<lambda>(v, w, \\<sigma>).\n               dinvarm \\<sigma> \\<and> w = mpath_weight' (snd \\<sigma> v)))\n         (pop_min ?\\<sigma>')\n  \\<lbrakk>(?\\<sigma>, ?\\<sigma>') \\<in> br \\<alpha>s dinvarm;\n   ?wv = mpath_weight' (snd ?\\<sigma> ?v); ?v' = ?v\\<rbrakk>\n  \\<Longrightarrow> mupdate ?v ?wv ?\\<sigma>\n                    \\<le> \\<Down> (br \\<alpha>s dinvarm)\n                           (update' ?v' ?\\<sigma>')\n\ngoal (1 subgoal):\n 1. mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'", "unfolding mdijkstra_def dijkstra'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mdinit \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n         (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n         (\\<lambda>\\<sigma>.\n             mpop_min \\<sigma> \\<bind>\n             (\\<lambda>(v, wv, \\<sigma>'). mupdate v wv \\<sigma>'))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> \\<Down> (br \\<alpha>r res_invarm)\n           (dinit \\<bind>\n            (\\<lambda>\\<sigma>0.\n                WHILE\\<^sub>T\\<^bsup>dinvar\\<^esup>\n                 (\\<lambda>(wl, uu_). wl \\<noteq> {})\n                 (\\<lambda>\\<sigma>.\n                     pop_min \\<sigma> \\<bind>\n                     (\\<lambda>(x, y). update' x y))\n                 \\<sigma>0 \\<bind>\n                (\\<lambda>(uu_, res). RETURN res)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<sigma>0 \\<sigma>0a x x'.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> br \\<alpha>s dinvarm;\n        (x, x') \\<in> br \\<alpha>s dinvarm; dinvar x'\\<rbrakk>\n       \\<Longrightarrow> dinvarm x\n 2. \\<And>\\<sigma>0 \\<sigma>0a x x' x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> br \\<alpha>s dinvarm;\n        (x, x') \\<in> br \\<alpha>s dinvarm; dinvarm x; dinvar x';\n        x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (dom x1 \\<noteq> {}) = (x1a \\<noteq> {})\n 3. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> br \\<alpha>s dinvarm;\n        (x, x') \\<in> br \\<alpha>s dinvarm;\n        case x of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {};\n        case x' of (wl, uu_) \\<Rightarrow> wl \\<noteq> {}; dinvarm x;\n        dinvar x';\n        (xa, x'a)\n        \\<in> br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n               (\\<lambda>(v, w, \\<sigma>).\n                   dinvarm \\<sigma> \\<and>\n                   w = mpath_weight' (snd \\<sigma> v));\n        x'a = (x1, x2); x2a = (x1b, x2b); xa = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2b, x2) \\<in> br \\<alpha>s dinvarm\n 4. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> br \\<alpha>s dinvarm;\n        (x, x') \\<in> br \\<alpha>s dinvarm;\n        case x of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {};\n        case x' of (wl, uu_) \\<Rightarrow> wl \\<noteq> {}; dinvarm x;\n        dinvar x';\n        (xa, x'a)\n        \\<in> br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n               (\\<lambda>(v, w, \\<sigma>).\n                   dinvarm \\<sigma> \\<and>\n                   w = mpath_weight' (snd \\<sigma> v));\n        x'a = (x1, x2); x2a = (x1b, x2b); xa = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> x1b = mpath_weight' (snd x2b x1a)\n 5. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a x1b x2b.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> br \\<alpha>s dinvarm;\n        (x, x') \\<in> br \\<alpha>s dinvarm;\n        case x of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {};\n        case x' of (wl, uu_) \\<Rightarrow> wl \\<noteq> {}; dinvarm x;\n        dinvar x';\n        (xa, x'a)\n        \\<in> br (\\<lambda>(v, w, \\<sigma>). (v, \\<alpha>s \\<sigma>))\n               (\\<lambda>(v, w, \\<sigma>).\n                   dinvarm \\<sigma> \\<and>\n                   w = mpath_weight' (snd \\<sigma> v));\n        x'a = (x1, x2); x2a = (x1b, x2b); xa = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> x1 = x1a\n 6. \\<And>\\<sigma>0 \\<sigma>0a x x' x1 x2 x1a x2a.\n       \\<lbrakk>(\\<sigma>0, \\<sigma>0a) \\<in> br \\<alpha>s dinvarm;\n        (x, x') \\<in> br \\<alpha>s dinvarm; x' = (x1, x2);\n        x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> br \\<alpha>r res_invarm", "apply (simp_all split: prod.split\n        add: \\<alpha>s_def \\<alpha>w_def dinvarm_def refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}