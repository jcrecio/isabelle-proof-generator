{"file_name": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path/Dijkstra_Impl_Adet.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path", "problem_names": ["lemma infty_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>infty_rel = {(Num a, Num a')| a a'. (a,a')\\<in>R} \\<union> {(Infty,Infty)}\"", "lemma infty_relI: \n  \"(Infty,Infty)\\<in>\\<langle>R\\<rangle>infty_rel\"\n  \"(a,a')\\<in>R \\<Longrightarrow> (Num a, Num a')\\<in>\\<langle>R\\<rangle>infty_rel\"", "lemma infty_relE:\n  assumes \"(x,x')\\<in>\\<langle>R\\<rangle>infty_rel\"\n  obtains \"x=Infty\" and \"x'=Infty\"\n  | a a' where \"x=Num a\" and \"x'=Num a'\" and \"(a,a')\\<in>R\"", "lemma infty_rel_simps[simp]:\n  \"(Infty,x')\\<in>\\<langle>R\\<rangle>infty_rel \\<longleftrightarrow> x'=Infty\"\n  \"(x,Infty)\\<in>\\<langle>R\\<rangle>infty_rel \\<longleftrightarrow> x=Infty\"\n  \"(Num a, Num a')\\<in>\\<langle>R\\<rangle>infty_rel \\<longleftrightarrow> (a,a')\\<in>R\"", "lemma infty_rel_sv[relator_props]: \n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>infty_rel)\"", "lemma infty_rel_id[simp, relator_props]: \"\\<langle>Id\\<rangle>infty_rel = Id\"", "lemmas [autoref_rel_intf] = REL_INTFI[of infty_rel i_infty]", "lemma autoref_infty[param,autoref_rules]:\n  \"(Infty,Infty)\\<in>\\<langle>R\\<rangle>infty_rel\"\n  \"(Num,Num)\\<in>R\\<rightarrow>\\<langle>R\\<rangle>infty_rel\"\n  \"(case_infty,case_infty)\\<in>Rr\\<rightarrow>(R\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>infty_rel\\<rightarrow>Rr\"\n  \"(rec_infty,rec_infty)\\<in>Rr\\<rightarrow>(R\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>infty_rel\\<rightarrow>Rr\"", "lemma pat_is_Infty[autoref_op_pat]: \n  \"x=Infty \\<equiv> (OP is_Infty :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_infty \\<rightarrow>\\<^sub>i i_bool)$x\"\n  \"Infty=x \\<equiv> (OP is_Infty :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_infty \\<rightarrow>\\<^sub>i i_bool)$x\"", "lemma autoref_is_Infty[autoref_rules]: \n  \"(is_Infty, is_Infty)\\<in>\\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel\"", "lemma infty_eq_autoref[autoref_rules (overloaded)]:\n  \"\\<lbrakk> GEN_OP eq (=) (R\\<rightarrow>R\\<rightarrow>bool_rel) \\<rbrakk> \n  \\<Longrightarrow> (infty_eq eq,(=))\\<in>\\<langle>R\\<rangle>infty_rel\\<rightarrow>\\<langle>R\\<rangle>infty_rel\\<rightarrow>bool_rel\"", "lemma infty_eq_expand[autoref_struct_expand]: \"(=) = infty_eq (=)\"", "lemma infty_val_autoref[autoref_rules]: \n  \"\\<lbrakk>SIDE_PRECOND (x\\<noteq>Infty); (xi,x)\\<in>\\<langle>R\\<rangle>infty_rel\\<rbrakk> \n  \\<Longrightarrow> (val xi,(OP val ::: \\<langle>R\\<rangle>infty_rel \\<rightarrow> R) $ x)\\<in>R\"", "lemma infty_plus_param[param]:\n  \"(infty_plus,infty_plus) \\<in> (R\\<rightarrow>R\\<rightarrow>R) \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel\"", "lemma infty_plus_eq_plus: \"infty_plus (+) = (+)\"", "lemma infty_plus_autoref[autoref_rules]:\n  \"GEN_OP pl (+) (R\\<rightarrow>R\\<rightarrow>R) \n  \\<Longrightarrow> (infty_plus pl,(+)) \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel\"", "lemma graph_more_rel_def[refine_rel_defs]: \n  \"\\<langle>Rm,Rv,Rw\\<rangle>graph_more_rel \\<equiv> { (g,g'). \n    (graph.nodes g, graph.nodes g')\\<in>\\<langle>Rv\\<rangle>set_rel     \n  \\<and> (graph.edges g, graph.edges g')\\<in>\\<langle>\\<langle>Rv,\\<langle>Rw,Rv\\<rangle>prod_rel\\<rangle>prod_rel\\<rangle>set_rel\n  \\<and> (graph.more g, graph.more g')\\<in>Rm}\"", "lemmas graph_rel_def = graph_more_rel_def[where Rm=unit_rel, simplified]", "lemma graph_rel_id[simp]: \"\\<langle>Id,Id\\<rangle>graph_rel = Id\"", "lemma graph_more_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rw\\<rangle>graph_more_rel)\"", "lemma [autoref_itype]: \n  \"graph.nodes ::\\<^sub>i \\<langle>Iv,Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_set\"", "lemma nodes_to_list_itype[autoref_itype]: \"nodes_to_list ::\\<^sub>i \\<langle>Iv,Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\"", "lemma nodes_to_list_pat[autoref_op_pat]: \"it_to_sorted_list (\\<lambda>_ _. True) (graph.nodes g) \\<equiv> nodes_to_list g\"", "lemma succ_to_list_itype[autoref_itype]: \n  \"succ_to_list ::\\<^sub>i \\<langle>Iv,Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Iw,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\"", "lemma succ_to_list_pat[autoref_op_pat]: \"it_to_sorted_list (\\<lambda>_ _. True) (Graph.succ g v) \\<equiv> succ_to_list g v\"", "lemma rel_def: \"\\<langle>Rv,Rw\\<rangle>rel \\<equiv> br \\<alpha> invar O \\<langle>Rv,Rw\\<rangle>graph_rel\"", "lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\"", "lemma rel_sv[relator_props]: \n    \"\\<lbrakk>single_valued Rv; single_valued Rw\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Rv,Rw\\<rangle>rel)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_graph]", "lemma (in graph_nodes_it) autoref_nodes_it[autoref_rules]: \n  assumes ID: \"PREFER_id Rv\"\n  shows \"(\\<lambda>s. RETURN (it_to_list nodes_it s),nodes_to_list) \\<in> \\<langle>Rv,Rw\\<rangle>rel \\<rightarrow> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma (in graph_succ_it) autoref_succ_it[autoref_rules]: \n  assumes ID: \"PREFER_id Rv\" \"PREFER_id Rw\"\n  shows \"(\\<lambda>s v. RETURN (it_to_list (\\<lambda>s. succ_it s v) s),succ_to_list) \n    \\<in> \\<langle>Rv,Rw\\<rangle>rel \\<rightarrow> Rv \\<rightarrow> \\<langle>\\<langle>\\<langle>Rw,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\"", "lemmas [autoref_rel_intf] = REL_INTFI[of v_rel i_node]", "lemmas [autoref_rel_intf] = REL_INTFI[of w_rel i_weight]", "lemma weight_plus_autoref[autoref_rules]: \n    \"(0,0) \\<in> w_rel\"\n    \"((+),(+)) \\<in> w_rel \\<rightarrow> w_rel \\<rightarrow> w_rel\" \n    \"((+),(+)) \\<in> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel\" \n    \"((<),(<)) \\<in> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> bool_rel\"", "lemma [autoref_rules]: \"(g,ga)\\<in>\\<langle>v_rel,w_rel\\<rangle>g.rel\"", "lemma [autoref_rules]: \"(v0,v0)\\<in>v_rel\"", "lemma [autoref_rules]: \n    \"(mpath_weight',mpath_weight') \n      \\<in> \\<langle>\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<times>\\<^sub>rw_rel\\<rangle>option_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel\"\n    \"(mpath', mpath') \n      \\<in> \\<langle>\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<times>\\<^sub>rw_rel\\<rangle>option_rel \n        \\<rightarrow> \\<langle>\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<rangle>option_rel\"", "lemmas [autoref_tyrel] = \n    ty_REL[where R=v_rel]\n    ty_REL[where R=w_rel]\n    ty_REL[where R=\"\\<langle>w_rel\\<rangle>infty_rel\"]\n    ty_REL[where R=\"\\<langle>v_rel,\\<langle>w_rel\\<rangle>infty_rel\\<rangle>qw.rel\"]\n    ty_REL[where R=\"\\<langle>v_rel,\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<times>\\<^sub>rw_rel\\<rangle>mr.rel\"]\n    ty_REL[where R=\"\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\"]", "lemmas [autoref_op_pat] = uprio_pats[where 'e = 'V and 'a = \"'W infty\"]", "lemma cdijkstra_refines: \n    \"RETURN (cdijkstra g v0) \\<le> \\<Down>(build_rel mr.\\<alpha> mr.invar) mdijkstra\"", "theorem cdijkstra_correct:\n    shows\n    \"weighted_graph.is_shortest_path_map ga v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\"\n    (is ?G1)\n    and \"mr.invar (cdijkstra g v0)\" (is ?G2) \n    and \"res_invarm (mr.\\<alpha> (cdijkstra g v0))\" (is ?G3)", "theorem (in dijkstraC) cdijkstra_correct:\n  assumes INV: \"g.invar g\"\n  assumes V0: \"v0 \\<in> nodes (g.\\<alpha> g)\"\n  assumes nonneg_weights: \"\\<And>v w v'. (v,w,v')\\<in>edges (g.\\<alpha> g) \\<Longrightarrow> 0\\<le>w\"\n  shows \n  \"weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0 \n      (Dijkstra.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\" (is ?G1)\n  and \"Dijkstra.res_invarm (mr.\\<alpha> (cdijkstra g v0))\" (is ?G2)", "lemmas hrf_dijkstra_correct = hrf.cdijkstra_correct[folded hrf_dijkstra_def]", "lemmas hrfn_dijkstra_correct = \n  hrf_dijkstra_correct[where ?'a = nat and ?'b = nat, folded hrfn_dijkstra_def]"], "translations": [["", "lemma infty_rel_def[refine_rel_defs]: \n  \"\\<langle>R\\<rangle>infty_rel = {(Num a, Num a')| a a'. (a,a')\\<in>R} \\<union> {(Infty,Infty)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>infty_rel =\n    {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n    {(infty.Infty, infty.Infty)}", "unfolding infty_rel_internal_def relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n    {(infty.Infty, infty.Infty)} =\n    {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n    {(infty.Infty, infty.Infty)}", "by simp"], ["", "lemma infty_relI: \n  \"(Infty,Infty)\\<in>\\<langle>R\\<rangle>infty_rel\"\n  \"(a,a')\\<in>R \\<Longrightarrow> (Num a, Num a')\\<in>\\<langle>R\\<rangle>infty_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (infty.Infty, infty.Infty) \\<in> \\<langle>R\\<rangle>infty_rel &&&\n    ((a, a') \\<in> R \\<Longrightarrow>\n     (Num a, Num a') \\<in> \\<langle>R\\<rangle>infty_rel)", "unfolding infty_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (infty.Infty, infty.Infty)\n    \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n          {(infty.Infty, infty.Infty)} &&&\n    ((a, a') \\<in> R \\<Longrightarrow>\n     (Num a, Num a')\n     \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n           {(infty.Infty, infty.Infty)})", "by auto"], ["", "lemma infty_relE:\n  assumes \"(x,x')\\<in>\\<langle>R\\<rangle>infty_rel\"\n  obtains \"x=Infty\" and \"x'=Infty\"\n  | a a' where \"x=Num a\" and \"x'=Num a'\" and \"(a,a')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x = infty.Infty; x' = infty.Infty\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>a a'.\n        \\<lbrakk>x = Num a; x' = Num a'; (a, a') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  (x, x') \\<in> \\<langle>R\\<rangle>infty_rel\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x = infty.Infty; x' = infty.Infty\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>a a'.\n        \\<lbrakk>x = Num a; x' = Num a'; (a, a') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding infty_rel_def"], ["proof (prove)\nusing this:\n  (x, x')\n  \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n        {(infty.Infty, infty.Infty)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>x = infty.Infty; x' = infty.Infty\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<And>a a'.\n        \\<lbrakk>x = Num a; x' = Num a'; (a, a') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma infty_rel_simps[simp]:\n  \"(Infty,x')\\<in>\\<langle>R\\<rangle>infty_rel \\<longleftrightarrow> x'=Infty\"\n  \"(x,Infty)\\<in>\\<langle>R\\<rangle>infty_rel \\<longleftrightarrow> x=Infty\"\n  \"(Num a, Num a')\\<in>\\<langle>R\\<rangle>infty_rel \\<longleftrightarrow> (a,a')\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((infty.Infty, x') \\<in> \\<langle>R\\<rangle>infty_rel) =\n    (x' = infty.Infty) &&&\n    ((x, infty.Infty) \\<in> \\<langle>R\\<rangle>infty_rel) =\n    (x = infty.Infty) &&&\n    ((Num a, Num a') \\<in> \\<langle>R\\<rangle>infty_rel) = ((a, a') \\<in> R)", "unfolding infty_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((infty.Infty, x')\n     \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n           {(infty.Infty, infty.Infty)}) =\n    (x' = infty.Infty) &&&\n    ((x, infty.Infty)\n     \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n           {(infty.Infty, infty.Infty)}) =\n    (x = infty.Infty) &&&\n    ((Num a, Num a')\n     \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n           {(infty.Infty, infty.Infty)}) =\n    ((a, a') \\<in> R)", "by auto"], ["", "lemma infty_rel_sv[relator_props]: \n  \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>infty_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>infty_rel)", "unfolding infty_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued\n     ({(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n      {(infty.Infty, infty.Infty)})", "by (auto intro: single_valuedI dest: single_valuedD)"], ["", "lemma infty_rel_id[simp, relator_props]: \"\\<langle>Id\\<rangle>infty_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>infty_rel = Id", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<langle>Id\\<rangle>infty_rel \\<subseteq> Id\n 2. Id \\<subseteq> \\<langle>Id\\<rangle>infty_rel", "apply (auto elim: infty_relE) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. Id \\<subseteq> \\<langle>Id\\<rangle>infty_rel", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. (b, b) \\<in> \\<langle>Id\\<rangle>infty_rel", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       b = infty.Infty \\<Longrightarrow>\n       (b, b) \\<in> \\<langle>Id\\<rangle>infty_rel\n 2. \\<And>a b x2.\n       b = Num x2 \\<Longrightarrow>\n       (b, b) \\<in> \\<langle>Id\\<rangle>infty_rel", "by auto"], ["", "consts i_infty :: \"interface \\<Rightarrow> interface\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of infty_rel i_infty]"], ["", "lemma autoref_infty[param,autoref_rules]:\n  \"(Infty,Infty)\\<in>\\<langle>R\\<rangle>infty_rel\"\n  \"(Num,Num)\\<in>R\\<rightarrow>\\<langle>R\\<rangle>infty_rel\"\n  \"(case_infty,case_infty)\\<in>Rr\\<rightarrow>(R\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>infty_rel\\<rightarrow>Rr\"\n  \"(rec_infty,rec_infty)\\<in>Rr\\<rightarrow>(R\\<rightarrow>Rr)\\<rightarrow>\\<langle>R\\<rangle>infty_rel\\<rightarrow>Rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((infty.Infty, infty.Infty) \\<in> \\<langle>R\\<rangle>infty_rel &&&\n     (Num, Num) \\<in> R \\<rightarrow> \\<langle>R\\<rangle>infty_rel) &&&\n    (case_infty, case_infty)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow> Rr &&&\n    (rec_infty, rec_infty)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow> Rr", "unfolding infty_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((infty.Infty, infty.Infty)\n     \\<in> {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n           {(infty.Infty, infty.Infty)} &&&\n     (Num, Num)\n     \\<in> R \\<rightarrow>\n           {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n           {(infty.Infty, infty.Infty)}) &&&\n    (case_infty, case_infty)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n          {(infty.Infty, infty.Infty)} \\<rightarrow>\n          Rr &&&\n    (rec_infty, rec_infty)\n    \\<in> Rr \\<rightarrow>\n          (R \\<rightarrow> Rr) \\<rightarrow>\n          {(Num a, Num a') |a a'. (a, a') \\<in> R} \\<union>\n          {(infty.Infty, infty.Infty)} \\<rightarrow>\n          Rr", "by (auto dest: fun_relD)"], ["", "definition [simp]: \"is_Infty x \\<equiv> case x of Infty \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma pat_is_Infty[autoref_op_pat]: \n  \"x=Infty \\<equiv> (OP is_Infty :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_infty \\<rightarrow>\\<^sub>i i_bool)$x\"\n  \"Infty=x \\<equiv> (OP is_Infty :::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_infty \\<rightarrow>\\<^sub>i i_bool)$x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = infty.Infty \\<equiv>\n     (OP is_Infty :::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_infty \\<rightarrow>\\<^sub>i i_bool) $\n     x) &&&\n    infty.Infty = x \\<equiv>\n    (OP is_Infty :::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_infty \\<rightarrow>\\<^sub>i i_bool) $\n    x", "by (auto intro!: eq_reflection split: infty.splits)"], ["", "end"], ["", "lemma autoref_is_Infty[autoref_rules]: \n  \"(is_Infty, is_Infty)\\<in>\\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (is_Infty, is_Infty)\n    \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel", "by (auto split: infty.splits)"], ["", "definition \"infty_eq eq v1 v2 \\<equiv> \n  case (v1,v2) of\n    (Infty,Infty) \\<Rightarrow> True\n  | (Num a1, Num a2) \\<Rightarrow> eq a1 a2\n  | _ \\<Rightarrow> False\""], ["", "lemma infty_eq_autoref[autoref_rules (overloaded)]:\n  \"\\<lbrakk> GEN_OP eq (=) (R\\<rightarrow>R\\<rightarrow>bool_rel) \\<rbrakk> \n  \\<Longrightarrow> (infty_eq eq,(=))\\<in>\\<langle>R\\<rangle>infty_rel\\<rightarrow>\\<langle>R\\<rangle>infty_rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP eq (=)\n     (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<Longrightarrow>\n    (infty_eq eq, (=))\n    \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel", "unfolding infty_eq_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP eq (=)\n     (R \\<rightarrow> R \\<rightarrow> bool_rel) \\<Longrightarrow>\n    (\\<lambda>v1 v2.\n        case (v1, v2) of (infty.Infty, infty.Infty) \\<Rightarrow> True\n        | (infty.Infty, Num a) \\<Rightarrow> False\n        | (Num a1, infty.Infty) \\<Rightarrow> False\n        | (Num a1, Num x) \\<Rightarrow> eq a1 x,\n     (=))\n    \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow> bool_rel", "by (auto split: infty.splits dest: fun_relD elim!: infty_relE)"], ["", "lemma infty_eq_expand[autoref_struct_expand]: \"(=) = infty_eq (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (=) = infty_eq (=)", "by (auto intro!: ext simp: infty_eq_def split: infty.splits)"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma infty_val_autoref[autoref_rules]: \n  \"\\<lbrakk>SIDE_PRECOND (x\\<noteq>Infty); (xi,x)\\<in>\\<langle>R\\<rangle>infty_rel\\<rbrakk> \n  \\<Longrightarrow> (val xi,(OP val ::: \\<langle>R\\<rangle>infty_rel \\<rightarrow> R) $ x)\\<in>R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SIDE_PRECOND (x \\<noteq> infty.Infty);\n     (xi, x) \\<in> \\<langle>R\\<rangle>infty_rel\\<rbrakk>\n    \\<Longrightarrow> (val xi,\n                       (OP val :::\n                        \\<langle>R\\<rangle>infty_rel \\<rightarrow> R) $\n                       x)\n                      \\<in> R", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>SIDE_PRECOND (x \\<noteq> infty.Infty);\n     (xi, x) \\<in> \\<langle>R\\<rangle>infty_rel; x = infty.Infty\\<rbrakk>\n    \\<Longrightarrow> (val xi,\n                       (OP val :::\n                        \\<langle>R\\<rangle>infty_rel \\<rightarrow> R) $\n                       x)\n                      \\<in> R\n 2. \\<And>x2.\n       \\<lbrakk>SIDE_PRECOND (x \\<noteq> infty.Infty);\n        (xi, x) \\<in> \\<langle>R\\<rangle>infty_rel; x = Num x2\\<rbrakk>\n       \\<Longrightarrow> (val xi,\n                          (OP val :::\n                           \\<langle>R\\<rangle>infty_rel \\<rightarrow> R) $\n                          x)\n                         \\<in> R", "apply (auto elim: infty_relE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "definition infty_plus where\n  \"infty_plus pl a b \\<equiv> case (a,b) of (Num a, Num b) \\<Rightarrow> Num (pl a b) | _ \\<Rightarrow> Infty \""], ["", "lemma infty_plus_param[param]:\n  \"(infty_plus,infty_plus) \\<in> (R\\<rightarrow>R\\<rightarrow>R) \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (infty_plus, infty_plus)\n    \\<in> (R \\<rightarrow> R \\<rightarrow> R) \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel", "unfolding infty_plus_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>pl a b.\n        case (a, b) of (infty.Infty, ba) \\<Rightarrow> infty.Infty\n        | (Num a, infty.Infty) \\<Rightarrow> infty.Infty\n        | (Num a, Num b) \\<Rightarrow> Num (pl a b),\n     \\<lambda>pl a b.\n        case (a, b) of (infty.Infty, ba) \\<Rightarrow> infty.Infty\n        | (Num a, infty.Infty) \\<Rightarrow> infty.Infty\n        | (Num a, Num b) \\<Rightarrow> Num (pl a b))\n    \\<in> (R \\<rightarrow> R \\<rightarrow> R) \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel", "by parametricity"], ["", "lemma infty_plus_eq_plus: \"infty_plus (+) = (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infty_plus (+) = (+)", "unfolding infty_plus_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b.\n        case (a, b) of (infty.Infty, ba) \\<Rightarrow> infty.Infty\n        | (Num a, infty.Infty) \\<Rightarrow> infty.Infty\n        | (Num a, Num b) \\<Rightarrow> Num (a + b)) =\n    (+)", "by (auto intro!: ext split: infty.split)"], ["", "lemma infty_plus_autoref[autoref_rules]:\n  \"GEN_OP pl (+) (R\\<rightarrow>R\\<rightarrow>R) \n  \\<Longrightarrow> (infty_plus pl,(+)) \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel \\<rightarrow> \\<langle>R\\<rangle>infty_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP pl (+) (R \\<rightarrow> R \\<rightarrow> R) \\<Longrightarrow>\n    (infty_plus pl, (+))\n    \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel", "apply (fold infty_plus_eq_plus)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GEN_OP pl (+) (R \\<rightarrow> R \\<rightarrow> R) \\<Longrightarrow>\n    (infty_plus pl, infty_plus (+))\n    \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pl, (+)) \\<in> R \\<rightarrow> R \\<rightarrow> R \\<Longrightarrow>\n    (infty_plus pl, infty_plus (+))\n    \\<in> \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>R\\<rangle>infty_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Graph\\<close>"], ["", "consts i_graph :: \"interface \\<Rightarrow> interface \\<Rightarrow> interface\""], ["", "definition graph_more_rel_internal_def:\n  \"graph_more_rel Rm Rv Rw \\<equiv> { (g,g'). \n    (graph.nodes g, graph.nodes g')\\<in>\\<langle>Rv\\<rangle>set_rel     \n  \\<and> (graph.edges g, graph.edges g')\\<in>\\<langle>\\<langle>Rv,\\<langle>Rw,Rv\\<rangle>prod_rel\\<rangle>prod_rel\\<rangle>set_rel\n  \\<and> (graph.more g, graph.more g')\\<in>Rm}\""], ["", "lemma graph_more_rel_def[refine_rel_defs]: \n  \"\\<langle>Rm,Rv,Rw\\<rangle>graph_more_rel \\<equiv> { (g,g'). \n    (graph.nodes g, graph.nodes g')\\<in>\\<langle>Rv\\<rangle>set_rel     \n  \\<and> (graph.edges g, graph.edges g')\\<in>\\<langle>\\<langle>Rv,\\<langle>Rw,Rv\\<rangle>prod_rel\\<rangle>prod_rel\\<rangle>set_rel\n  \\<and> (graph.more g, graph.more g')\\<in>Rm}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rm, Rv, Rw\\<rangle>graph_more_rel \\<equiv>\n    {(g, g').\n     (nodes g, nodes g') \\<in> \\<langle>Rv\\<rangle>set_rel \\<and>\n     (edges g, edges g')\n     \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                    Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel \\<and>\n     (graph.more g, graph.more g') \\<in> Rm}", "unfolding relAPP_def graph_more_rel_internal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(g, g').\n     (nodes g, nodes g') \\<in> set_rel Rv \\<and>\n     (edges g, edges g') \\<in> set_rel (prod_rel Rv (prod_rel Rw Rv)) \\<and>\n     (graph.more g, graph.more g') \\<in> Rm} \\<equiv>\n    {(g, g').\n     (nodes g, nodes g') \\<in> set_rel Rv \\<and>\n     (edges g, edges g') \\<in> set_rel (prod_rel Rv (prod_rel Rw Rv)) \\<and>\n     (graph.more g, graph.more g') \\<in> Rm}", "by simp"], ["", "abbreviation \"graph_rel \\<equiv> \\<langle>unit_rel\\<rangle>graph_more_rel\""], ["", "lemmas graph_rel_def = graph_more_rel_def[where Rm=unit_rel, simplified]"], ["", "lemma graph_rel_id[simp]: \"\\<langle>Id,Id\\<rangle>graph_rel = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>graph_rel = Id", "unfolding graph_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(g, g').\n     (nodes g, nodes g') \\<in> \\<langle>Id\\<rangle>set_rel \\<and>\n     (edges g, edges g')\n     \\<in> \\<langle>Id \\<times>\\<^sub>r\n                    Id \\<times>\\<^sub>r Id\\<rangle>set_rel} =\n    Id", "by auto"], ["", "lemma graph_more_rel_sv[relator_props]: \n  \"\\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rm,Rv,Rw\\<rangle>graph_more_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rm, Rv, Rw\\<rangle>graph_more_rel)", "unfolding graph_more_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       {(g, g').\n                        (nodes g, nodes g')\n                        \\<in> \\<langle>Rv\\<rangle>set_rel \\<and>\n                        (edges g, edges g')\n                        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel \\<and>\n                        (graph.more g, graph.more g') \\<in> Rm}", "apply (rule single_valuedI, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw;\n        (nodes x, nodes y) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (nodes x, nodes z) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (edges x, edges y)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more y) \\<in> Rm;\n        (edges x, edges z)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more z) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> y = z", "apply (rule graph.equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw;\n        (nodes x, nodes y) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (nodes x, nodes z) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (edges x, edges y)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more y) \\<in> Rm;\n        (edges x, edges z)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more z) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> nodes y = nodes z\n 2. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw;\n        (nodes x, nodes y) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (nodes x, nodes z) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (edges x, edges y)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more y) \\<in> Rm;\n        (edges x, edges z)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more z) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> edges y = edges z\n 3. \\<And>x y z.\n       \\<lbrakk>single_valued Rm; single_valued Rv; single_valued Rw;\n        (nodes x, nodes y) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (nodes x, nodes z) \\<in> \\<langle>Rv\\<rangle>set_rel;\n        (edges x, edges y)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more y) \\<in> Rm;\n        (edges x, edges z)\n        \\<in> \\<langle>Rv \\<times>\\<^sub>r\n                       Rw \\<times>\\<^sub>r Rv\\<rangle>set_rel;\n        (graph.more x, graph.more z) \\<in> Rm\\<rbrakk>\n       \\<Longrightarrow> graph.more y = graph.more z", "apply (erule (1) single_valuedD[rotated], tagged_solver)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [autoref_itype]: \n  \"graph.nodes ::\\<^sub>i \\<langle>Iv,Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes ::\\<^sub>i\n    \\<langle>Iv, Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i\n    \\<langle>Iv\\<rangle>\\<^sub>ii_set", "by simp_all"], ["", "thm is_map_to_sorted_list_def"], ["", "definition \"nodes_to_list g \\<equiv> it_to_sorted_list (\\<lambda>_ _. True) (graph.nodes g)\""], ["", "lemma nodes_to_list_itype[autoref_itype]: \"nodes_to_list ::\\<^sub>i \\<langle>Iv,Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodes_to_list ::\\<^sub>i\n    \\<langle>Iv, Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>Iv\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "lemma nodes_to_list_pat[autoref_op_pat]: \"it_to_sorted_list (\\<lambda>_ _. True) (graph.nodes g) \\<equiv> nodes_to_list g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list (\\<lambda>_ _. True) (nodes g) \\<equiv>\n    nodes_to_list g", "unfolding nodes_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list (\\<lambda>_ _. True) (nodes g) \\<equiv>\n    it_to_sorted_list (\\<lambda>_ _. True) (nodes g)", "by simp"], ["", "definition \"succ_to_list g v \\<equiv> it_to_sorted_list (\\<lambda>_ _. True) (Graph.succ g v)\""], ["", "lemma succ_to_list_itype[autoref_itype]: \n  \"succ_to_list ::\\<^sub>i \\<langle>Iv,Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Iw,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ_to_list ::\\<^sub>i\n    \\<langle>Iv, Iw\\<rangle>\\<^sub>ii_graph \\<rightarrow>\\<^sub>i\n    Iv \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Iw,\n    Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "lemma succ_to_list_pat[autoref_op_pat]: \"it_to_sorted_list (\\<lambda>_ _. True) (Graph.succ g v) \\<equiv> succ_to_list g v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list (\\<lambda>_ _. True) (succ g v) \\<equiv>\n    succ_to_list g v", "unfolding succ_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list (\\<lambda>_ _. True) (succ g v) \\<equiv>\n    it_to_sorted_list (\\<lambda>_ _. True) (succ g v)", "by simp"], ["", "context graph begin"], ["", "definition rel_def_internal: \"rel Rv Rw \\<equiv> br \\<alpha> invar O \\<langle>Rv,Rw\\<rangle>graph_rel\""], ["", "lemma rel_def: \"\\<langle>Rv,Rw\\<rangle>rel \\<equiv> br \\<alpha> invar O \\<langle>Rv,Rw\\<rangle>graph_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rv, Rw\\<rangle>rel \\<equiv>\n    br \\<alpha> invar O \\<langle>Rv, Rw\\<rangle>graph_rel", "unfolding relAPP_def rel_def_internal"], ["proof (prove)\ngoal (1 subgoal):\n 1. br \\<alpha> invar O graph_more_rel unit_rel Rv Rw \\<equiv>\n    br \\<alpha> invar O graph_more_rel unit_rel Rv Rw", "by simp"], ["", "lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>rel = br \\<alpha> invar", "by (simp add: rel_def)"], ["", "lemma rel_sv[relator_props]: \n    \"\\<lbrakk>single_valued Rv; single_valued Rw\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Rv,Rw\\<rangle>rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rv; single_valued Rw\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Rv, Rw\\<rangle>rel)", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rv; single_valued Rw\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (br \\<alpha> invar O \\<langle>Rv,\n                        Rw\\<rangle>graph_rel)", "by tagged_solver"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_graph]"], ["", "end"], ["", "lemma (in graph_nodes_it) autoref_nodes_it[autoref_rules]: \n  assumes ID: \"PREFER_id Rv\"\n  shows \"(\\<lambda>s. RETURN (it_to_list nodes_it s),nodes_to_list) \\<in> \\<langle>Rv,Rw\\<rangle>rel \\<rightarrow> \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (it_to_list nodes_it s), nodes_to_list)\n    \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<rightarrow>\n          \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel", "unfolding nodes_to_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (it_to_list nodes_it s),\n     \\<lambda>g. it_to_sorted_list (\\<lambda>_ _. True) (nodes g))\n    \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<rightarrow>\n          \\<langle>\\<langle>Rv\\<rangle>list_rel\\<rangle>nres_rel", "proof (intro fun_relI nres_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<Longrightarrow>\n       RETURN (it_to_list nodes_it a)\n       \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n              (it_to_sorted_list (\\<lambda>_ _. True) (nodes a'))", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<Longrightarrow>\n       RETURN (it_to_list nodes_it a)\n       \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n              (it_to_sorted_list (\\<lambda>_ _. True) (nodes a'))", "from ID"], ["proof (chain)\npicking this:\n  PREFER_id Rv", "have [simp]: \"Rv = Id\""], ["proof (prove)\nusing this:\n  PREFER_id Rv\n\ngoal (1 subgoal):\n 1. Rv = Id", "by simp"], ["proof (state)\nthis:\n  Rv = Id\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<Longrightarrow>\n       RETURN (it_to_list nodes_it a)\n       \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n              (it_to_sorted_list (\\<lambda>_ _. True) (nodes a'))", "assume \"(s,s')\\<in>\\<langle>Rv,Rw\\<rangle>rel\""], ["proof (state)\nthis:\n  (s, s') \\<in> \\<langle>Rv, Rw\\<rangle>rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<Longrightarrow>\n       RETURN (it_to_list nodes_it a)\n       \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n              (it_to_sorted_list (\\<lambda>_ _. True) (nodes a'))", "hence INV: \"invar s\" and [simp]: \"nodes s' = nodes (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> \\<langle>Rv, Rw\\<rangle>rel\n\ngoal (1 subgoal):\n 1. invar s &&& nodes s' = nodes (\\<alpha> s)", "unfolding rel_def"], ["proof (prove)\nusing this:\n  (s, s') \\<in> br \\<alpha> invar O \\<langle>Rv, Rw\\<rangle>graph_rel\n\ngoal (1 subgoal):\n 1. invar s &&& nodes s' = nodes (\\<alpha> s)", "by (auto simp add: br_def graph_rel_def)"], ["proof (state)\nthis:\n  invar s\n  nodes s' = nodes (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<Longrightarrow>\n       RETURN (it_to_list nodes_it a)\n       \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n              (it_to_sorted_list (\\<lambda>_ _. True) (nodes a'))", "obtain l where \n    [simp]: \"distinct l\" \"nodes (\\<alpha> s) = set l\" \"it_to_list nodes_it s = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; nodes (\\<alpha> s) = set l;\n         it_to_list nodes_it s = l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding it_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; nodes (\\<alpha> s) = set l;\n         nodes_it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [] =\n         l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis nodes_it_correct[OF INV, unfolded set_iterator_def set_iterator_genord_def] \n      foldli_snoc_id self_append_conv2)"], ["proof (state)\nthis:\n  distinct l\n  nodes (\\<alpha> s) = set l\n  it_to_list nodes_it s = l\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<Longrightarrow>\n       RETURN (it_to_list nodes_it a)\n       \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n              (it_to_sorted_list (\\<lambda>_ _. True) (nodes a'))", "show \"RETURN (it_to_list nodes_it s)\n          \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel) (it_to_sorted_list (\\<lambda>_ _. True) (nodes s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (it_to_list nodes_it s)\n    \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n           (it_to_sorted_list (\\<lambda>_ _. True) (nodes s'))", "by (simp add: it_to_sorted_list_def)"], ["proof (state)\nthis:\n  RETURN (it_to_list nodes_it s)\n  \\<le> \\<Down> (\\<langle>Rv\\<rangle>list_rel)\n         (it_to_sorted_list (\\<lambda>_ _. True) (nodes s'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in graph_succ_it) autoref_succ_it[autoref_rules]: \n  assumes ID: \"PREFER_id Rv\" \"PREFER_id Rw\"\n  shows \"(\\<lambda>s v. RETURN (it_to_list (\\<lambda>s. succ_it s v) s),succ_to_list) \n    \\<in> \\<langle>Rv,Rw\\<rangle>rel \\<rightarrow> Rv \\<rightarrow> \\<langle>\\<langle>\\<langle>Rw,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s v. RETURN (it_to_list (\\<lambda>s. succ_it s v) s),\n     succ_to_list)\n    \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>\\<langle>Rw \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>nres_rel", "unfolding succ_to_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s v. RETURN (it_to_list (\\<lambda>s. succ_it s v) s),\n     \\<lambda>g v. it_to_sorted_list (\\<lambda>_ _. True) (succ g v))\n    \\<in> \\<langle>Rv, Rw\\<rangle>rel \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>\\<langle>Rw \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>nres_rel", "proof (intro fun_relI nres_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "fix s s' v v'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "from ID"], ["proof (chain)\npicking this:\n  PREFER_id Rv\n  PREFER_id Rw", "have [simp]: \"Rv = Id\" \"Rw=Id\""], ["proof (prove)\nusing this:\n  PREFER_id Rv\n  PREFER_id Rw\n\ngoal (1 subgoal):\n 1. Rv = Id &&& Rw = Id", "by simp_all"], ["proof (state)\nthis:\n  Rv = Id\n  Rw = Id\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "assume \"(v,v')\\<in>Rv\""], ["proof (state)\nthis:\n  (v, v') \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "hence [simp]: \"v'=v\""], ["proof (prove)\nusing this:\n  (v, v') \\<in> Rv\n\ngoal (1 subgoal):\n 1. v' = v", "by simp"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "assume \"(s,s')\\<in>\\<langle>Rv,Rw\\<rangle>rel\""], ["proof (state)\nthis:\n  (s, s') \\<in> \\<langle>Rv, Rw\\<rangle>rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "hence INV: \"invar s\" and [simp]: \"Graph.succ s' = Graph.succ (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> \\<langle>Rv, Rw\\<rangle>rel\n\ngoal (1 subgoal):\n 1. invar s &&& succ s' = succ (\\<alpha> s)", "unfolding rel_def"], ["proof (prove)\nusing this:\n  (s, s') \\<in> br \\<alpha> invar O \\<langle>Rv, Rw\\<rangle>graph_rel\n\ngoal (1 subgoal):\n 1. invar s &&& succ s' = succ (\\<alpha> s)", "by (auto simp add: br_def graph_rel_def succ_def)"], ["proof (state)\nthis:\n  invar s\n  succ s' = succ (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "obtain l where \n    [simp]: \"distinct l\" \"succ (\\<alpha> s) v = set l\" \"it_to_list (\\<lambda>s. succ_it s v) s = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; succ (\\<alpha> s) v = set l;\n         it_to_list (\\<lambda>s. succ_it s v) s = l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding it_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; succ (\\<alpha> s) v = set l;\n         succ_it s v (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [] =\n         l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis succ_it_correct[OF INV, unfolded set_iterator_def set_iterator_genord_def] \n      foldli_snoc_id self_append_conv2)"], ["proof (state)\nthis:\n  distinct l\n  succ (\\<alpha> s) v = set l\n  it_to_list (\\<lambda>s. succ_it s v) s = l\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rv, Rw\\<rangle>rel;\n        (aa, a'a) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> RETURN (it_to_list (\\<lambda>s. succ_it s aa) a)\n                         \\<le> \\<Down>\n                                (\\<langle>Rw \\<times>\\<^sub>r\n    Rv\\<rangle>list_rel)\n                                (it_to_sorted_list (\\<lambda>_ _. True)\n                                  (succ a' a'a))", "show \"RETURN (it_to_list (\\<lambda>s. succ_it s v) s)\n          \\<le> \\<Down> (\\<langle>\\<langle>Rw,Rv\\<rangle>prod_rel\\<rangle>list_rel) (it_to_sorted_list (\\<lambda>_ _. True) (succ s' v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (it_to_list (\\<lambda>s. succ_it s v) s)\n    \\<le> \\<Down> (\\<langle>Rw \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n           (it_to_sorted_list (\\<lambda>_ _. True) (succ s' v'))", "by (simp add: it_to_sorted_list_def)"], ["proof (state)\nthis:\n  RETURN (it_to_list (\\<lambda>s. succ_it s v) s)\n  \\<le> \\<Down> (\\<langle>Rw \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n         (it_to_sorted_list (\\<lambda>_ _. True) (succ s' v'))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Refinement\\<close>"], ["", "locale dijkstraC =\n  g: StdGraph g_ops + \n  mr: StdMap mr_ops +\n  qw: StdUprio qw_ops \n  for g_ops :: \"('V,'W::weight,'G,'moreg) graph_ops_scheme\"\n  and mr_ops :: \"('V, (('V,'W) path \\<times> 'W), 'mr,'more_mr) map_ops_scheme\"\n  and qw_ops :: \"('V ,'W infty,'qw,'more_qw) uprio_ops_scheme\" \nbegin"], ["", "end"], ["", "locale dijkstraC_fixg = dijkstraC g_ops mr_ops qw_ops +\n  Dijkstra ga v0 \n  for g_ops :: \"('V,'W::weight,'G,'moreg) graph_ops_scheme\"\n  and mr_ops :: \"('V, (('V,'W) path \\<times> 'W), 'mr,'more_mr) map_ops_scheme\"\n  and qw_ops :: \"('V ,'W infty,'qw,'more_qw) uprio_ops_scheme\" \n  and ga::\"('V,'W) graph\" and \"v0\"::'V and g :: 'G+\n  assumes ga_trans: \"(g,ga)\\<in>br g.\\<alpha> g.invar\"\nbegin"], ["", "abbreviation \"v_rel \\<equiv> Id :: ('V\\<times>'V) set\""], ["", "abbreviation \"w_rel \\<equiv> Id :: ('W\\<times>'W) set\""], ["", "definition i_node :: interface where \"i_node \\<equiv> undefined\""], ["", "definition i_weight :: interface where \"i_weight \\<equiv> undefined\""], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of v_rel i_node]"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of w_rel i_weight]"], ["", "lemma weight_plus_autoref[autoref_rules]: \n    \"(0,0) \\<in> w_rel\"\n    \"((+),(+)) \\<in> w_rel \\<rightarrow> w_rel \\<rightarrow> w_rel\" \n    \"((+),(+)) \\<in> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel\" \n    \"((<),(<)) \\<in> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'W, 0::'W) \\<in> w_rel &&&\n     ((+), (+)) \\<in> w_rel \\<rightarrow> w_rel \\<rightarrow> w_rel) &&&\n    ((+), (+))\n    \\<in> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>w_rel\\<rangle>infty_rel &&&\n    ((<), (<))\n    \\<in> \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow>\n          \\<langle>w_rel\\<rangle>infty_rel \\<rightarrow> bool_rel", "by simp_all"], ["", "lemma [autoref_rules]: \"(g,ga)\\<in>\\<langle>v_rel,w_rel\\<rangle>g.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g, ga) \\<in> \\<langle>v_rel, w_rel\\<rangle>g.rel", "using ga_trans"], ["proof (prove)\nusing this:\n  (g, ga) \\<in> br g.\\<alpha> g.invar\n\ngoal (1 subgoal):\n 1. (g, ga) \\<in> \\<langle>v_rel, w_rel\\<rangle>g.rel", "by (simp add: g.rel_def)"], ["", "lemma [autoref_rules]: \"(v0,v0)\\<in>v_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v0, v0) \\<in> v_rel", "by simp"], ["", "term mpath_weight'"], ["", "lemma [autoref_rules]: \n    \"(mpath_weight',mpath_weight') \n      \\<in> \\<langle>\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<times>\\<^sub>rw_rel\\<rangle>option_rel \\<rightarrow> \\<langle>w_rel\\<rangle>infty_rel\"\n    \"(mpath', mpath') \n      \\<in> \\<langle>\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<times>\\<^sub>rw_rel\\<rangle>option_rel \n        \\<rightarrow> \\<langle>\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mpath_weight', mpath_weight')\n    \\<in> \\<langle>\\<langle>v_rel \\<times>\\<^sub>r\n                            w_rel \\<times>\\<^sub>r\n                            v_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   w_rel\\<rangle>option_rel \\<rightarrow>\n          \\<langle>w_rel\\<rangle>infty_rel &&&\n    (mpath', mpath')\n    \\<in> \\<langle>\\<langle>v_rel \\<times>\\<^sub>r\n                            w_rel \\<times>\\<^sub>r\n                            v_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   w_rel\\<rangle>option_rel \\<rightarrow>\n          \\<langle>\\<langle>v_rel \\<times>\\<^sub>r\n                            w_rel \\<times>\\<^sub>r\n                            v_rel\\<rangle>list_rel\\<rangle>option_rel", "by auto"], ["", "term mdinit"], ["", "lemmas [autoref_tyrel] = \n    ty_REL[where R=v_rel]\n    ty_REL[where R=w_rel]\n    ty_REL[where R=\"\\<langle>w_rel\\<rangle>infty_rel\"]\n    ty_REL[where R=\"\\<langle>v_rel,\\<langle>w_rel\\<rangle>infty_rel\\<rangle>qw.rel\"]\n    ty_REL[where R=\"\\<langle>v_rel,\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\\<times>\\<^sub>rw_rel\\<rangle>mr.rel\"]\n    ty_REL[where R=\"\\<langle>v_rel\\<times>\\<^sub>rw_rel\\<times>\\<^sub>rv_rel\\<rangle>list_rel\"]"], ["", "lemmas [autoref_op_pat] = uprio_pats[where 'e = 'V and 'a = \"'W infty\"]"], ["", "schematic_goal cdijkstra_refines_aux:\n    shows \"(?c::?'c, \n      mdijkstra\n    ) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, mdijkstra) \\<in> ?R", "apply (simp only: mdijkstra_def mdinit_def mpop_min_def[abs_def] mupdate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n      Map.empty \\<bind>\n     (\\<lambda>wl.\n         RETURN\n          (wl(v0 \\<mapsto> Num (0::'W)),\n           [v0 \\<mapsto> ([], 0::'W)])) \\<bind>\n     (\\<lambda>\\<sigma>0.\n         WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n          (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n          (\\<lambda>\\<sigma>.\n              (let (wl, res) = \\<sigma>\n               in prio_pop_min wl \\<bind>\n                  (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<bind>\n              (\\<lambda>(v, wv, \\<sigma>').\n                  ASSERT\n                   (update_pre v (\\<alpha>s \\<sigma>') \\<and>\n                    wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                  (\\<lambda>_.\n                      let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                      in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n   (\\<alpha>r res)\\<^esup>\n                          (succ ga v)\n                          (\\<lambda>(w', v') (wl, res).\n                              if wv + Num w' < mpath_weight' (res v')\n                              then ASSERT\n                                    (v' \\<in> dom wl \\<and>\n                                     pv \\<noteq> None) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n       ((v, w', v') # the pv, val wv + w')))))\n                              else RETURN (wl, res))\n                          (wl, res))))\n          \\<sigma>0 \\<bind>\n         (\\<lambda>(uu_, res). RETURN res)))\n    \\<in> ?R", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n      Map.empty \\<bind>\n     (\\<lambda>wl.\n         RETURN\n          (wl(v0 \\<mapsto> Num (0::'W)),\n           [v0 \\<mapsto> ([], 0::'W)])) \\<bind>\n     (\\<lambda>\\<sigma>0.\n         WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n          (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n          (\\<lambda>\\<sigma>.\n              (let (wl, res) = \\<sigma>\n               in prio_pop_min wl \\<bind>\n                  (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<bind>\n              (\\<lambda>(v, wv, \\<sigma>').\n                  ASSERT\n                   (update_pre v (\\<alpha>s \\<sigma>') \\<and>\n                    wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                  (\\<lambda>_.\n                      let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                      in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n   (\\<alpha>r res)\\<^esup>\n                          (succ ga v)\n                          (\\<lambda>(w', v') (wl, res).\n                              if wv + Num w' < mpath_weight' (res v')\n                              then ASSERT\n                                    (v' \\<in> dom wl \\<and>\n                                     pv \\<noteq> None) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n       ((v, w', v') # the pv, val wv + w')))))\n                              else RETURN (wl, res))\n                          (wl, res))))\n          \\<sigma>0 \\<bind>\n         (\\<lambda>(uu_, res). RETURN res)))\n    \\<in> ?R", "apply (fold op_map_empty_def[where 'a=\"'V\" and 'b = \"('V\\<times>'W\\<times>'V) list \\<times> 'W\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n      Map.empty \\<bind>\n     (\\<lambda>wl.\n         RETURN\n          (wl(v0 \\<mapsto> Num (0::'W)), op_map_empty(v0 \\<mapsto>\n           ([], 0::'W)))) \\<bind>\n     (\\<lambda>\\<sigma>0.\n         WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n          (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n          (\\<lambda>\\<sigma>.\n              (let (wl, res) = \\<sigma>\n               in prio_pop_min wl \\<bind>\n                  (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<bind>\n              (\\<lambda>(v, wv, \\<sigma>').\n                  ASSERT\n                   (update_pre v (\\<alpha>s \\<sigma>') \\<and>\n                    wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                  (\\<lambda>_.\n                      let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                      in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n   (\\<alpha>r res)\\<^esup>\n                          (succ ga v)\n                          (\\<lambda>(w', v') (wl, res).\n                              if wv + Num w' < mpath_weight' (res v')\n                              then ASSERT\n                                    (v' \\<in> dom wl \\<and>\n                                     pv \\<noteq> None) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n       ((v, w', v') # the pv, val wv + w')))))\n                              else RETURN (wl, res))\n                          (wl, res))))\n          \\<sigma>0 \\<bind>\n         (\\<lambda>(uu_, res). RETURN res)))\n    \\<in> ?R", "apply (fold op_uprio_empty_def[where 'a=\"'V\" and 'b = \"'W infty\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n      op_uprio_empty \\<bind>\n     (\\<lambda>wl.\n         RETURN\n          (wl(v0 \\<mapsto> Num (0::'W)), op_map_empty(v0 \\<mapsto>\n           ([], 0::'W)))) \\<bind>\n     (\\<lambda>\\<sigma>0.\n         WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n          (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n          (\\<lambda>\\<sigma>.\n              (let (wl, res) = \\<sigma>\n               in prio_pop_min wl \\<bind>\n                  (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<bind>\n              (\\<lambda>(v, wv, \\<sigma>').\n                  ASSERT\n                   (update_pre v (\\<alpha>s \\<sigma>') \\<and>\n                    wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                  (\\<lambda>_.\n                      let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                      in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n   (\\<alpha>r res)\\<^esup>\n                          (succ ga v)\n                          (\\<lambda>(w', v') (wl, res).\n                              if wv + Num w' < mpath_weight' (res v')\n                              then ASSERT\n                                    (v' \\<in> dom wl \\<and>\n                                     pv \\<noteq> None) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n       ((v, w', v') # the pv, val wv + w')))))\n                              else RETURN (wl, res))\n                          (wl, res))))\n          \\<sigma>0 \\<bind>\n         (\\<lambda>(uu_, res). RETURN res)))\n    \\<in> ?R", "(*using [[autoref_trace_intf_unif]]*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n      op_uprio_empty \\<bind>\n     (\\<lambda>wl.\n         RETURN\n          (wl(v0 \\<mapsto> Num (0::'W)), op_map_empty(v0 \\<mapsto>\n           ([], 0::'W)))) \\<bind>\n     (\\<lambda>\\<sigma>0.\n         WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n          (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n          (\\<lambda>\\<sigma>.\n              (let (wl, res) = \\<sigma>\n               in prio_pop_min wl \\<bind>\n                  (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<bind>\n              (\\<lambda>(v, wv, \\<sigma>').\n                  ASSERT\n                   (update_pre v (\\<alpha>s \\<sigma>') \\<and>\n                    wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                  (\\<lambda>_.\n                      let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                      in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n   (\\<alpha>r res)\\<^esup>\n                          (succ ga v)\n                          (\\<lambda>(w', v') (wl, res).\n                              if wv + Num w' < mpath_weight' (res v')\n                              then ASSERT\n                                    (v' \\<in> dom wl \\<and>\n                                     pv \\<noteq> None) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n       ((v, w', v') # the pv, val wv + w')))))\n                              else RETURN (wl, res))\n                          (wl, res))))\n          \\<sigma>0 \\<bind>\n         (\\<lambda>(uu_, res). RETURN res)))\n    \\<in> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     FOREACH V (\\<lambda>v wl. RETURN (wl(v \\<mapsto> infty.Infty)))\n      op_uprio_empty \\<bind>\n     (\\<lambda>wl.\n         RETURN\n          (wl(v0 \\<mapsto> Num (0::'W)), op_map_empty(v0 \\<mapsto>\n           ([], 0::'W)))) \\<bind>\n     (\\<lambda>\\<sigma>0.\n         WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n          (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n          (\\<lambda>\\<sigma>.\n              (let (wl, res) = \\<sigma>\n               in prio_pop_min wl \\<bind>\n                  (\\<lambda>(v, w, wl'). RETURN (v, w, wl', res))) \\<bind>\n              (\\<lambda>(v, wv, \\<sigma>').\n                  ASSERT\n                   (update_pre v (\\<alpha>s \\<sigma>') \\<and>\n                    wv = mpath_weight' (snd \\<sigma>' v)) \\<bind>\n                  (\\<lambda>_.\n                      let (wl, res) = \\<sigma>'; pv = mpath' (res v)\n                      in FOREACH\\<^bsup>uinvarm v (\\<alpha>w wl)\n   (\\<alpha>r res)\\<^esup>\n                          (succ ga v)\n                          (\\<lambda>(w', v') (wl, res).\n                              if wv + Num w' < mpath_weight' (res v')\n                              then ASSERT\n                                    (v' \\<in> dom wl \\<and>\n                                     pv \\<noteq> None) \\<bind>\n                                   (\\<lambda>_.\n ASSERT (wv \\<noteq> infty.Infty) \\<bind>\n (\\<lambda>_.\n     RETURN\n      (wl(v' \\<mapsto> wv + Num w'), res(v' \\<mapsto>\n       ((v, w', v') # the pv, val wv + w')))))\n                              else RETURN (wl, res))\n                          (wl, res))))\n          \\<sigma>0 \\<bind>\n         (\\<lambda>(uu_, res). RETURN res)))\n    \\<in> ?R", "apply (autoref_monadic (plain,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context dijkstraC \nbegin"], ["", "concrete_definition cdijkstra for g ?v0.0  \n    uses dijkstraC_fixg.cdijkstra_refines_aux\n    [of g_ops mr_ops qw_ops]"], ["", "term cdijkstra"], ["", "end"], ["", "context dijkstraC_fixg\nbegin"], ["", "term cdijkstra"], ["", "term mdijkstra"], ["", "lemma cdijkstra_refines: \n    \"RETURN (cdijkstra g v0) \\<le> \\<Down>(build_rel mr.\\<alpha> mr.invar) mdijkstra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (cdijkstra g v0)\n    \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra", "apply (rule cdijkstra.refine[THEN nres_relD, simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstraC_fixg g_ops mr_ops qw_ops ga v0 g", "apply unfold_locales"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem cdijkstra_correct:\n    shows\n    \"weighted_graph.is_shortest_path_map ga v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\"\n    (is ?G1)\n    and \"mr.invar (cdijkstra g v0)\" (is ?G2) \n    and \"res_invarm (mr.\\<alpha> (cdijkstra g v0))\" (is ?G3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0))) &&&\n    mr.invar (cdijkstra g v0) &&& res_invarm (mr.\\<alpha> (cdijkstra g v0))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "note cdijkstra_refines"], ["proof (state)\nthis:\n  RETURN (cdijkstra g v0) \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "also"], ["proof (state)\nthis:\n  RETURN (cdijkstra g v0) \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "note mdijkstra_refines"], ["proof (state)\nthis:\n  mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "finally"], ["proof (chain)\npicking this:\n  RETURN (cdijkstra g v0)\n  \\<le> \\<Down> (br mr.\\<alpha> mr.invar)\n         (\\<Down> (br \\<alpha>r res_invarm) dijkstra')", "have Z: \"RETURN (cdijkstra g v0) \\<le> \n      \\<Down>(build_rel (\\<alpha>r \\<circ> mr.\\<alpha>) (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m))) \n        dijkstra'\""], ["proof (prove)\nusing this:\n  RETURN (cdijkstra g v0)\n  \\<le> \\<Down> (br mr.\\<alpha> mr.invar)\n         (\\<Down> (br \\<alpha>r res_invarm) dijkstra')\n\ngoal (1 subgoal):\n 1. RETURN (cdijkstra g v0)\n    \\<le> \\<Down>\n           (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n             (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n           dijkstra'", "apply (subst (asm) conc_fun_chain)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (cdijkstra g v0)\n    \\<le> \\<Down> (br mr.\\<alpha> mr.invar O br \\<alpha>r res_invarm)\n           dijkstra' \\<Longrightarrow>\n    RETURN (cdijkstra g v0)\n    \\<le> \\<Down>\n           (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n             (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n           dijkstra'", "apply (simp only: br_chain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  RETURN (cdijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         dijkstra'\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "also"], ["proof (state)\nthis:\n  RETURN (cdijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         dijkstra'\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "note dijkstra'_refines[simplified]"], ["proof (state)\nthis:\n  dijkstra' \\<le> dijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "also"], ["proof (state)\nthis:\n  dijkstra' \\<le> dijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "note dijkstra_correct"], ["proof (state)\nthis:\n  dijkstra \\<le> SPEC (is_shortest_path_map v0)\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. mr.invar (cdijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (cdijkstra g v0))", "finally"], ["proof (chain)\npicking this:\n  RETURN (cdijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         (SPEC (is_shortest_path_map v0))", "show ?G1 ?G2 ?G3"], ["proof (prove)\nusing this:\n  RETURN (cdijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         (SPEC (is_shortest_path_map v0))\n\ngoal (1 subgoal):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0))) &&&\n    mr.invar (cdijkstra g v0) &&& res_invarm (mr.\\<alpha> (cdijkstra g v0))", "by (auto elim: RETURN_ref_SPECD simp: refine_rel_defs)"], ["proof (state)\nthis:\n  is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n  mr.invar (cdijkstra g v0)\n  res_invarm (mr.\\<alpha> (cdijkstra g v0))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "theorem (in dijkstraC) cdijkstra_correct:\n  assumes INV: \"g.invar g\"\n  assumes V0: \"v0 \\<in> nodes (g.\\<alpha> g)\"\n  assumes nonneg_weights: \"\\<And>v w v'. (v,w,v')\\<in>edges (g.\\<alpha> g) \\<Longrightarrow> 0\\<le>w\"\n  shows \n  \"weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0 \n      (Dijkstra.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\" (is ?G1)\n  and \"Dijkstra.res_invarm (mr.\\<alpha> (cdijkstra g v0))\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0\n     (Dijkstra.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0))) &&&\n    Dijkstra.res_invarm (mr.\\<alpha> (cdijkstra g v0))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0\n     (Dijkstra.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. Dijkstra.res_invarm (mr.\\<alpha> (cdijkstra g v0))", "interpret hlgv: valid_graph \"g.\\<alpha> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph (g.\\<alpha> g)", "using g.valid INV"], ["proof (prove)\nusing this:\n  g.invar ?g \\<Longrightarrow> valid_graph (g.\\<alpha> ?g)\n  g.invar g\n\ngoal (1 subgoal):\n 1. valid_graph (g.\\<alpha> g)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0\n     (Dijkstra.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. Dijkstra.res_invarm (mr.\\<alpha> (cdijkstra g v0))", "interpret dc: dijkstraC_fixg g_ops mr_ops qw_ops \"g.\\<alpha> g\" v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstraC_fixg g_ops mr_ops qw_ops (g.\\<alpha> g) v0 g", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite hlgv.V\n 2. finite hlgv.E\n 3. v0 \\<in> hlgv.V\n 4. \\<And>v w v'. (v, w, v') \\<in> hlgv.E \\<Longrightarrow> (0::'W) \\<le> w\n 5. (g, g.\\<alpha> g) \\<in> br g.\\<alpha> g.invar", "apply (simp_all \n      add: hlg.finite INV V0 hlg_ops_def nonneg_weights refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (2 subgoals):\n 1. dc.is_shortest_path_map v0 (dc.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n 2. dc.res_invarm (mr.\\<alpha> (cdijkstra g v0))", "from dc.cdijkstra_correct"], ["proof (chain)\npicking this:\n  dc.is_shortest_path_map v0 (dc.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n  mr.invar (cdijkstra g v0)\n  dc.res_invarm (mr.\\<alpha> (cdijkstra g v0))", "show ?G1 ?G2"], ["proof (prove)\nusing this:\n  dc.is_shortest_path_map v0 (dc.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n  mr.invar (cdijkstra g v0)\n  dc.res_invarm (mr.\\<alpha> (cdijkstra g v0))\n\ngoal (1 subgoal):\n 1. dc.is_shortest_path_map v0\n     (dc.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0))) &&&\n    dc.res_invarm (mr.\\<alpha> (cdijkstra g v0))", "by auto"], ["proof (state)\nthis:\n  dc.is_shortest_path_map v0 (dc.\\<alpha>r (mr.\\<alpha> (cdijkstra g v0)))\n  dc.res_invarm (mr.\\<alpha> (cdijkstra g v0))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Example instantiation with HashSet.based graph, \n  red-black-tree based result map, and finger-tree based priority queue.\n\\<close>"], ["", "setup Locale_Code.open_block"], ["", "interpretation hrf: dijkstraC hlg_ops rm_ops aluprioi_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstraC hlg_ops rm_ops aluprioi_ops", "by unfold_locales"], ["", "setup Locale_Code.close_block"], ["", "definition \"hrf_dijkstra \\<equiv> hrf.cdijkstra\""], ["", "lemmas hrf_dijkstra_correct = hrf.cdijkstra_correct[folded hrf_dijkstra_def]"], ["", "export_code hrf_dijkstra checking SML"], ["", "export_code hrf_dijkstra in OCaml"], ["", "export_code hrf_dijkstra in Haskell"], ["", "export_code hrf_dijkstra checking Scala"], ["", "definition hrfn_dijkstra :: \"(nat,nat) hlg \\<Rightarrow> _\" \n  where \"hrfn_dijkstra \\<equiv> hrf_dijkstra\""], ["", "export_code hrfn_dijkstra checking SML"], ["", "lemmas hrfn_dijkstra_correct = \n  hrf_dijkstra_correct[where ?'a = nat and ?'b = nat, folded hrfn_dijkstra_def]"], ["", "end"]]}