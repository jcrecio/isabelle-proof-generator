{"file_name": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path/GraphSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path", "problem_names": ["lemma nodes_it_correct: \n      \"invar g \\<Longrightarrow> set_iterator (nodes_it g) (Graph.nodes (\\<alpha> g))\"", "lemma pi_nodes_it[icf_proper_iteratorI]: \n      \"proper_it (nodes_it S) (nodes_it S)\"", "lemma nodes_it_proper[proper_it]:\n      \"proper_it' nodes_it nodes_it\"", "lemma edges_it_correct: \n      \"invar g \\<Longrightarrow> set_iterator (edges_it g) (Graph.edges (\\<alpha> g))\"", "lemma pi_edges_it[icf_proper_iteratorI]: \n      \"proper_it (edges_it S) (edges_it S)\"", "lemma edges_it_proper[proper_it]:\n      \"proper_it' edges_it edges_it\"", "lemma succ_it_correct: \n      \"invar g \\<Longrightarrow> set_iterator (succ_it g v) (Graph.succ (\\<alpha> g) v)\"", "lemma pi_succ_it[icf_proper_iteratorI]: \n      \"proper_it (succ_it S v) (succ_it S v)\"", "lemma succ_it_proper[proper_it]:\n      \"proper_it' (\\<lambda>S. succ_it S v) (\\<lambda>S. succ_it S v)\"", "lemma adjl_is_graph: \"graph adjl_\\<alpha> (\\<lambda>_. True)\"", "lemmas correct = empty_correct add_node_correct delete_node_correct \n      add_edge_correct delete_edge_correct\n      from_list_correct to_list_correct", "lemma (in graph_nodes_it) nodes_it_is_iterator[refine_transfer]:\n    \"invar g \\<Longrightarrow> set_iterator (nodes_it g) (nodes (\\<alpha> g))\"", "lemma (in graph_edges_it) edges_it_is_iterator[refine_transfer]:\n    \"invar g \\<Longrightarrow> set_iterator (edges_it g) (edges (\\<alpha> g))\"", "lemma (in graph_succ_it) succ_it_is_iterator[refine_transfer]:\n    \"invar g \\<Longrightarrow> set_iterator (succ_it g v) (Graph.succ (\\<alpha> g) v)\"", "lemma (in graph) drh[refine_dref_RELATES]: \"RELATES (build_rel \\<alpha> invar)\""], "translations": [["", "lemma nodes_it_correct: \n      \"invar g \\<Longrightarrow> set_iterator (nodes_it g) (Graph.nodes (\\<alpha> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> set_iterator (nodes_it g) (nodes (\\<alpha> g))", "unfolding nodes_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (it_to_it (nodes_list_it g)) (nodes (\\<alpha> g))", "apply (rule it_to_it_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (nodes_list_it g) (nodes (\\<alpha> g))", "by (rule nodes_list_it_correct)"], ["", "lemma pi_nodes_it[icf_proper_iteratorI]: \n      \"proper_it (nodes_it S) (nodes_it S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (nodes_it S) (nodes_it S)", "unfolding nodes_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (nodes_list_it S)) (it_to_it (nodes_list_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma nodes_it_proper[proper_it]:\n      \"proper_it' nodes_it nodes_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' nodes_it nodes_it", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (nodes_it s) (nodes_it s)", "by (rule pi_nodes_it)"], ["", "end"], ["", "type_synonym ('V,'W,'\\<sigma>,'G) graph_edges_it \n    = \"'G \\<Rightarrow> (('V\\<times>'W\\<times>'V),'\\<sigma>) set_iterator\""], ["", "locale graph_edges_it_defs =\n    fixes edges_list_it :: \"('V,'W,('V\\<times>'W\\<times>'V) list,'G) graph_edges_it\"\n  begin"], ["", "definition \"edges_it g \\<equiv> it_to_it (edges_list_it g)\""], ["", "end"], ["", "locale graph_edges_it = graph \\<alpha> invar + graph_edges_it_defs edges_list_it\n    for \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\" and invar and\n    edges_list_it :: \"('V,'W,('V\\<times>'W\\<times>'V) list,'G) graph_edges_it\" \n    +\n    assumes edges_list_it_correct:\n      \"invar g \\<Longrightarrow> set_iterator (edges_list_it g) (Graph.edges (\\<alpha> g))\"\n  begin"], ["", "lemma edges_it_correct: \n      \"invar g \\<Longrightarrow> set_iterator (edges_it g) (Graph.edges (\\<alpha> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> set_iterator (edges_it g) (edges (\\<alpha> g))", "unfolding edges_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (it_to_it (edges_list_it g)) (edges (\\<alpha> g))", "apply (rule it_to_it_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (edges_list_it g) (edges (\\<alpha> g))", "by (rule edges_list_it_correct)"], ["", "lemma pi_edges_it[icf_proper_iteratorI]: \n      \"proper_it (edges_it S) (edges_it S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (edges_it S) (edges_it S)", "unfolding edges_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (edges_list_it S)) (it_to_it (edges_list_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma edges_it_proper[proper_it]:\n      \"proper_it' edges_it edges_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' edges_it edges_it", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (edges_it s) (edges_it s)", "by (rule pi_edges_it)"], ["", "end"], ["", "type_synonym ('V,'W,'\\<sigma>,'G) graph_succ_it = \n    \"'G \\<Rightarrow> 'V \\<Rightarrow> ('W\\<times>'V,'\\<sigma>) set_iterator\""], ["", "locale graph_succ_it_defs =\n    fixes succ_list_it :: \"'G \\<Rightarrow> 'V \\<Rightarrow> ('W\\<times>'V,('W\\<times>'V) list) set_iterator\"\n  begin"], ["", "definition \"succ_it g v \\<equiv> it_to_it (succ_list_it g v)\""], ["", "end"], ["", "locale graph_succ_it = graph \\<alpha> invar + graph_succ_it_defs succ_list_it\n    for \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\" and invar and\n    succ_list_it :: \"'G \\<Rightarrow> 'V \\<Rightarrow> ('W\\<times>'V,('W\\<times>'V) list) set_iterator\" +\n    assumes succ_list_it_correct:\n      \"invar g \\<Longrightarrow> set_iterator (succ_list_it g v) (Graph.succ (\\<alpha> g) v)\"\n  begin"], ["", "lemma succ_it_correct: \n      \"invar g \\<Longrightarrow> set_iterator (succ_it g v) (Graph.succ (\\<alpha> g) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (succ_it g v) (succ (\\<alpha> g) v)", "unfolding succ_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (it_to_it (succ_list_it g v)) (succ (\\<alpha> g) v)", "apply (rule it_to_it_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (succ_list_it g v) (succ (\\<alpha> g) v)", "by (rule succ_list_it_correct)"], ["", "lemma pi_succ_it[icf_proper_iteratorI]: \n      \"proper_it (succ_it S v) (succ_it S v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (succ_it S v) (succ_it S v)", "unfolding succ_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (succ_list_it S v)) (it_to_it (succ_list_it S v))", "by (intro icf_proper_iteratorI)"], ["", "lemma succ_it_proper[proper_it]:\n      \"proper_it' (\\<lambda>S. succ_it S v) (\\<lambda>S. succ_it S v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' (\\<lambda>S. succ_it S v) (\\<lambda>S. succ_it S v)", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (succ_it s v) (succ_it s v)", "by (rule pi_succ_it)"], ["", "end"], ["", "subsection \"Adjacency Lists\""], ["", "type_synonym ('V,'W) adj_list = \"'V list \\<times> ('V\\<times>'W\\<times>'V) list\""], ["", "definition adjl_\\<alpha> :: \"('V,'W) adj_list \\<Rightarrow> ('V,'W) graph\" where\n    \"adjl_\\<alpha> l \\<equiv> let (nl,el) = l in \\<lparr>\n      nodes = set nl \\<union> fst`set el \\<union> snd`snd`set el,\n      edges = set el\n    \\<rparr>\""], ["", "(* TODO: Do we have naming conventions for such a lemma ? *)"], ["", "lemma adjl_is_graph: \"graph adjl_\\<alpha> (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. graph adjl_\\<alpha> (\\<lambda>_. True)", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g. True \\<Longrightarrow> finite (nodes (adjl_\\<alpha> g))\n 2. \\<And>g. True \\<Longrightarrow> finite (edges (adjl_\\<alpha> g))\n 3. \\<And>g.\n       True \\<Longrightarrow>\n       fst ` edges (adjl_\\<alpha> g) \\<subseteq> nodes (adjl_\\<alpha> g)\n 4. \\<And>g.\n       True \\<Longrightarrow>\n       snd ` snd ` edges (adjl_\\<alpha> g)\n       \\<subseteq> nodes (adjl_\\<alpha> g)", "unfolding adjl_\\<alpha>_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g.\n       True \\<Longrightarrow>\n       finite\n        (nodes\n          (let (nl, el) = g\n           in \\<lparr>nodes =\n                        set nl \\<union> fst ` set el \\<union>\n                        snd ` snd ` set el,\n                 edges = set el\\<rparr>))\n 2. \\<And>g.\n       True \\<Longrightarrow>\n       finite\n        (edges\n          (let (nl, el) = g\n           in \\<lparr>nodes =\n                        set nl \\<union> fst ` set el \\<union>\n                        snd ` snd ` set el,\n                 edges = set el\\<rparr>))\n 3. \\<And>g.\n       True \\<Longrightarrow>\n       fst `\n       edges\n        (let (nl, el) = g\n         in \\<lparr>nodes =\n                      set nl \\<union> fst ` set el \\<union>\n                      snd ` snd ` set el,\n               edges = set el\\<rparr>)\n       \\<subseteq> nodes\n                    (let (nl, el) = g\n                     in \\<lparr>nodes =\n                                  set nl \\<union> fst ` set el \\<union>\n                                  snd ` snd ` set el,\n                           edges = set el\\<rparr>)\n 4. \\<And>g.\n       True \\<Longrightarrow>\n       snd `\n       snd `\n       edges\n        (let (nl, el) = g\n         in \\<lparr>nodes =\n                      set nl \\<union> fst ` set el \\<union>\n                      snd ` snd ` set el,\n               edges = set el\\<rparr>)\n       \\<subseteq> nodes\n                    (let (nl, el) = g\n                     in \\<lparr>nodes =\n                                  set nl \\<union> fst ` set el \\<union>\n                                  snd ` snd ` set el,\n                           edges = set el\\<rparr>)", "by force+"], ["", "type_synonym ('V,'W,'G) graph_from_list = \"('V,'W) adj_list \\<Rightarrow> 'G\""], ["", "locale graph_from_list = graph +\n    constrains \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\"\n    fixes from_list :: \"('V,'W) adj_list \\<Rightarrow> 'G\"\n    assumes from_list_correct:\n      \"invar (from_list l)\"\n      \"\\<alpha> (from_list l) = adjl_\\<alpha> l\""], ["", "type_synonym ('V,'W,'G) graph_to_list = \"'G \\<Rightarrow> ('V,'W) adj_list\""], ["", "locale graph_to_list = graph +\n    constrains \\<alpha> :: \"'G \\<Rightarrow> ('V,'W) graph\"\n    fixes to_list :: \"'G \\<Rightarrow> ('V,'W) adj_list\"\n    assumes to_list_correct:\n      \"invar g \\<Longrightarrow> adjl_\\<alpha> (to_list g) = \\<alpha> g\""], ["", "subsection \\<open>Record Based Interface\\<close>"], ["", "record ('V,'W,'G) graph_ops =\n    gop_\\<alpha> :: \"('V,'W,'G) graph_\\<alpha>\"\n    gop_invar :: \"'G \\<Rightarrow> bool\"\n    gop_empty :: \"('V,'W,'G) graph_empty\"\n    gop_add_node :: \"('V,'W,'G) graph_add_node\"\n    gop_delete_node :: \"('V,'W,'G) graph_delete_node\"\n    gop_add_edge :: \"('V,'W,'G) graph_add_edge\"\n    gop_delete_edge :: \"('V,'W,'G) graph_delete_edge\"\n    gop_from_list :: \"('V,'W,'G) graph_from_list\"\n    gop_to_list :: \"('V,'W,'G) graph_to_list\"\n    gop_nodes_list_it :: \"'G \\<Rightarrow> ('V,'V list) set_iterator\"\n    gop_edges_list_it :: \"('V,'W,('V\\<times>'W\\<times>'V) list,'G) graph_edges_it\"\n    gop_succ_list_it :: \"'G \\<Rightarrow> 'V \\<Rightarrow> ('W\\<times>'V,('W\\<times>'V) list) set_iterator\""], ["", "locale StdGraphDefs = \n    graph_nodes_it_defs \"gop_nodes_list_it ops\"\n    + graph_edges_it_defs \"gop_edges_list_it ops\"\n    + graph_succ_it_defs \"gop_succ_list_it ops\"\n    for ops :: \"('V,'W,'G,'m) graph_ops_scheme\"\n  begin"], ["", "abbreviation \\<alpha> where \"\\<alpha> \\<equiv> gop_\\<alpha> ops\""], ["", "abbreviation invar where \"invar \\<equiv> gop_invar ops\""], ["", "abbreviation empty where \"empty \\<equiv> gop_empty ops\""], ["", "abbreviation add_node where \"add_node \\<equiv> gop_add_node ops\""], ["", "abbreviation delete_node where \"delete_node \\<equiv> gop_delete_node ops\""], ["", "abbreviation add_edge where \"add_edge \\<equiv> gop_add_edge ops\""], ["", "abbreviation delete_edge where \"delete_edge \\<equiv> gop_delete_edge ops\""], ["", "abbreviation from_list where \"from_list \\<equiv> gop_from_list ops\""], ["", "abbreviation to_list where \"to_list \\<equiv> gop_to_list ops\""], ["", "abbreviation nodes_list_it where \"nodes_list_it \\<equiv> gop_nodes_list_it ops\""], ["", "abbreviation edges_list_it where \"edges_list_it \\<equiv> gop_edges_list_it ops\""], ["", "abbreviation succ_list_it  where \"succ_list_it \\<equiv> gop_succ_list_it ops\""], ["", "end"], ["", "locale StdGraph = StdGraphDefs +\n    graph \\<alpha> invar +\n    graph_empty \\<alpha> invar empty +\n    graph_add_node \\<alpha> invar add_node +\n    graph_delete_node \\<alpha> invar delete_node +\n    graph_add_edge \\<alpha> invar add_edge +\n    graph_delete_edge \\<alpha> invar delete_edge +\n    graph_from_list \\<alpha> invar from_list +\n    graph_to_list \\<alpha> invar to_list +\n    graph_nodes_it \\<alpha> invar nodes_list_it +\n    graph_edges_it \\<alpha> invar edges_list_it +\n    graph_succ_it \\<alpha> invar succ_list_it\n  begin"], ["", "lemmas correct = empty_correct add_node_correct delete_node_correct \n      add_edge_correct delete_edge_correct\n      from_list_correct to_list_correct"], ["", "end"], ["", "subsection \\<open>Refinement Framework Bindings\\<close>"], ["", "lemma (in graph_nodes_it) nodes_it_is_iterator[refine_transfer]:\n    \"invar g \\<Longrightarrow> set_iterator (nodes_it g) (nodes (\\<alpha> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> set_iterator (nodes_it g) (nodes (\\<alpha> g))", "by (rule nodes_it_correct)"], ["", "lemma (in graph_edges_it) edges_it_is_iterator[refine_transfer]:\n    \"invar g \\<Longrightarrow> set_iterator (edges_it g) (edges (\\<alpha> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow> set_iterator (edges_it g) (edges (\\<alpha> g))", "by (rule edges_it_correct)"], ["", "lemma (in graph_succ_it) succ_it_is_iterator[refine_transfer]:\n    \"invar g \\<Longrightarrow> set_iterator (succ_it g v) (Graph.succ (\\<alpha> g) v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar g \\<Longrightarrow>\n    set_iterator (succ_it g v) (succ (\\<alpha> g) v)", "by (rule succ_it_correct)"], ["", "lemma (in graph) drh[refine_dref_RELATES]: \"RELATES (build_rel \\<alpha> invar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (br \\<alpha> invar)", "by (simp add: RELATES_def)"], ["", "(*text {* Autodet bindings: *}\n\n  lemma (in graph_nodes_it) graph_nodes_it_t[trans_uc]:\n    \"DETREFe g (build_rel \\<alpha> invar) g' \\<Longrightarrow> \n      set_iterator (nodes_it g) (nodes g')\"\n    using nodes_it_correct by auto\n\n  lemma (in graph_succ_it) graph_succ_it_t[trans_uc]:\n    \"DETREFe g (build_rel \\<alpha> invar) g' \\<Longrightarrow> DETREFe v Id v' \\<Longrightarrow>\n      set_iterator (succ_it g v) (succ g' v')\"\n    using succ_it_correct by auto\n\n  lemma (in graph_edges_it) graph_edges_it_t[trans_uc]:\n    \"DETREFe g (build_rel \\<alpha> invar) g' \\<Longrightarrow> \n      set_iterator (edges_it g) (edges g')\"\n    using edges_it_correct by auto*)"], ["", "end"]]}