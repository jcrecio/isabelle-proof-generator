{"file_name": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path/Dijkstra_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dijkstra_Shortest_Path", "problem_names": ["lemma cdijkstra_refines: \n    \"cdijkstra g v0 \\<le> \\<Down>(build_rel mr.\\<alpha> mr.invar) mdijkstra\"", "lemma idijkstra_refines: \n    assumes \"g.invar g\"\n    shows \"RETURN (idijkstra g v0) \\<le> cdijkstra g v0\"", "theorem (in dijkstraC_fixg) idijkstra_correct:\n  shows\n  \"weighted_graph.is_shortest_path_map ga v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\" \n    (is ?G1)\n  and \"mr.invar (idijkstra g v0)\" (is ?G2) \n  and \"Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))\" (is ?G3)", "theorem (in dijkstraC) idijkstra_correct:\n  assumes INV: \"g.invar g\"\n  assumes V0: \"v0 \\<in> nodes (g.\\<alpha> g)\"\n  assumes nonneg_weights: \"\\<And>v w v'. (v,w,v')\\<in>edges (g.\\<alpha> g) \\<Longrightarrow> 0\\<le>w\"\n  shows \n  \"weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0 \n      (Dijkstra.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\" (is ?G1)\n  and \"Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))\" (is ?G2)", "lemmas hrf_dijkstra_correct = hrf.idijkstra_correct[folded hrf_dijkstra_def]", "lemmas hrfn_dijkstra_correct = \n  hrf_dijkstra_correct[where ?'a = nat and ?'b = nat, folded hrfn_dijkstra_def]"], "translations": [["", "lemma cdijkstra_refines: \n    \"cdijkstra g v0 \\<le> \\<Down>(build_rel mr.\\<alpha> mr.invar) mdijkstra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra", "note [refine] = cdinit_refines cpop_min_refines cupdate_refines"], ["proof (state)\nthis:\n  cdinit g v0\n  \\<le> \\<Down>\n         (br qw.\\<alpha> qw.invar \\<times>\\<^sub>r br mr.\\<alpha> mr.invar)\n         mdinit\n  (?\\<sigma>, ?\\<sigma>') \\<in> br \\<alpha>sc dinvarC_add \\<Longrightarrow>\n  cpop_min ?\\<sigma>\n  \\<le> \\<Down>\n         (Id \\<times>\\<^sub>r\n          Id \\<times>\\<^sub>r\n          br qw.\\<alpha> qw.invar \\<times>\\<^sub>r br mr.\\<alpha> mr.invar)\n         (mpop_min ?\\<sigma>')\n  \\<lbrakk>(?\\<sigma>, ?\\<sigma>') \\<in> br \\<alpha>sc dinvarC_add;\n   ?v = ?v'; ?wv = ?wv'\\<rbrakk>\n  \\<Longrightarrow> cupdate g ?v ?wv ?\\<sigma>\n                    \\<le> \\<Down>\n                           (br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n                            br mr.\\<alpha> mr.invar)\n                           (mupdate ?v' ?wv' ?\\<sigma>')\n\ngoal (1 subgoal):\n 1. cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra", "unfolding cdijkstra_def mdijkstra_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cdinit g v0 \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T (\\<lambda>(wl, uu_). \\<not> qw.isEmpty wl)\n         (\\<lambda>\\<sigma>.\n             cpop_min \\<sigma> \\<bind>\n             (\\<lambda>(v, wv, \\<sigma>'). cupdate g v wv \\<sigma>'))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> \\<Down> (br mr.\\<alpha> mr.invar)\n           (mdinit \\<bind>\n            (\\<lambda>\\<sigma>0.\n                WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n                 (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n                 (\\<lambda>\\<sigma>.\n                     mpop_min \\<sigma> \\<bind>\n                     (\\<lambda>(v, wv, \\<sigma>'). mupdate v wv \\<sigma>'))\n                 \\<sigma>0 \\<bind>\n                (\\<lambda>(uu_, res). RETURN res)))", "using g_rel"], ["proof (prove)\nusing this:\n  (g, ga) \\<in> br g.\\<alpha> g.invar\n\ngoal (1 subgoal):\n 1. cdinit g v0 \\<bind>\n    (\\<lambda>\\<sigma>0.\n        WHILE\\<^sub>T (\\<lambda>(wl, uu_). \\<not> qw.isEmpty wl)\n         (\\<lambda>\\<sigma>.\n             cpop_min \\<sigma> \\<bind>\n             (\\<lambda>(v, wv, \\<sigma>'). cupdate g v wv \\<sigma>'))\n         \\<sigma>0 \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<le> \\<Down> (br mr.\\<alpha> mr.invar)\n           (mdinit \\<bind>\n            (\\<lambda>\\<sigma>0.\n                WHILE\\<^sub>T\\<^bsup>dinvarm\\<^esup>\n                 (\\<lambda>(wl, uu_). dom wl \\<noteq> {})\n                 (\\<lambda>\\<sigma>.\n                     mpop_min \\<sigma> \\<bind>\n                     (\\<lambda>(v, wv, \\<sigma>'). mupdate v wv \\<sigma>'))\n                 \\<sigma>0 \\<bind>\n                (\\<lambda>(uu_, res). RETURN res)))", "apply (refine_rcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<sigma>0 \\<sigma>0a x x' x1 x2 x1a x2a.\n       \\<lbrakk>(g, ga) \\<in> br g.\\<alpha> g.invar;\n        (\\<sigma>0, \\<sigma>0a)\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        (x, x')\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        dinvarm x'; x = (x1, x2); x' = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> qw.isEmpty x1) = (dom x1a \\<noteq> {})\n 2. \\<And>\\<sigma>0 \\<sigma>0a x x'.\n       \\<lbrakk>(g, ga) \\<in> br g.\\<alpha> g.invar;\n        (\\<sigma>0, \\<sigma>0a)\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        (x, x')\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        case x of (wl, uu_) \\<Rightarrow> \\<not> qw.isEmpty wl;\n        case x' of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {};\n        dinvarm x'\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> br \\<alpha>sc dinvarC_add\n 3. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(g, ga) \\<in> br g.\\<alpha> g.invar;\n        (\\<sigma>0, \\<sigma>0a)\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        (x, x')\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        case x of (wl, uu_) \\<Rightarrow> \\<not> qw.isEmpty wl;\n        case x' of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {}; dinvarm x';\n        (xa, x'a)\n        \\<in> Id \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        x2 = (x1a, x2a); x'a = (x1, x2); x2b = (x1c, x2c);\n        xa = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x2c, x2a) \\<in> br \\<alpha>sc dinvarC_add\n 4. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(g, ga) \\<in> br g.\\<alpha> g.invar;\n        (\\<sigma>0, \\<sigma>0a)\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        (x, x')\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        case x of (wl, uu_) \\<Rightarrow> \\<not> qw.isEmpty wl;\n        case x' of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {}; dinvarm x';\n        (xa, x'a)\n        \\<in> Id \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        x2 = (x1a, x2a); x'a = (x1, x2); x2b = (x1c, x2c);\n        xa = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> x1b = x1\n 5. \\<And>\\<sigma>0 \\<sigma>0a x x' xa x'a x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(g, ga) \\<in> br g.\\<alpha> g.invar;\n        (\\<sigma>0, \\<sigma>0a)\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        (x, x')\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        case x of (wl, uu_) \\<Rightarrow> \\<not> qw.isEmpty wl;\n        case x' of (wl, uu_) \\<Rightarrow> dom wl \\<noteq> {}; dinvarm x';\n        (xa, x'a)\n        \\<in> Id \\<times>\\<^sub>r\n              Id \\<times>\\<^sub>r\n              br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        x2 = (x1a, x2a); x'a = (x1, x2); x2b = (x1c, x2c);\n        xa = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> x1c = x1a\n 6. \\<And>\\<sigma>0 \\<sigma>0a x x' x1 x2 x1a x2a.\n       \\<lbrakk>(g, ga) \\<in> br g.\\<alpha> g.invar;\n        (\\<sigma>0, \\<sigma>0a)\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        (x, x')\n        \\<in> br qw.\\<alpha> qw.invar \\<times>\\<^sub>r\n              br mr.\\<alpha> mr.invar;\n        x' = (x1, x2); x = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> (x2a, x2) \\<in> br mr.\\<alpha> mr.invar", "apply (auto\n        split: prod.split prod.split_asm \n        simp add: qw.correct mr.correct dinvarC_add_def \\<alpha>sc_def refine_hsimp\n          refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context dijkstraC\nbegin"], ["", "thm g.nodes_it_is_iterator"], ["", "schematic_goal idijkstra_refines_aux: \n    assumes \"g.invar g\"\n    shows \"RETURN ?f \\<le> cdijkstra g v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f \\<le> cdijkstra g v0", "using assms"], ["proof (prove)\nusing this:\n  g.invar g\n\ngoal (1 subgoal):\n 1. RETURN ?f \\<le> cdijkstra g v0", "unfolding cdijkstra_def cdinit_def cpop_min_def cupdate_def"], ["proof (prove)\nusing this:\n  g.invar g\n\ngoal (1 subgoal):\n 1. RETURN ?f\n    \\<le> FOREACH (nodes (g.\\<alpha> g))\n           (\\<lambda>v wl. RETURN (qw.insert wl v infty.Infty))\n           (qw.empty ()) \\<bind>\n          (\\<lambda>wl.\n              RETURN\n               (qw.insert wl v0 (Num (0::'W)),\n                mr.sng v0 ([], 0::'W))) \\<bind>\n          (\\<lambda>\\<sigma>0.\n              WHILE\\<^sub>T (\\<lambda>(wl, uu_). \\<not> qw.isEmpty wl)\n               (\\<lambda>\\<sigma>.\n                   (let (wl, res) = \\<sigma>; (v, w, wl') = qw.pop wl\n                    in RETURN (v, w, wl', res)) \\<bind>\n                   (\\<lambda>(v, wv, \\<sigma>').\n                       ASSERT (dinvarC_add \\<sigma>') \\<bind>\n                       (\\<lambda>_.\n                           let (wl, res) = \\<sigma>';\n                               pv = mpath' (mr.lookup v res)\n                           in FOREACH (succ (g.\\<alpha> g) v)\n                               (\\<lambda>(w', v') (wl, res).\n                                   if wv + Num w'\n< mpath_weight' (mr.lookup v' res)\n                                   then RETURN\n   (qw.insert wl v' (wv + Num w'),\n    mr.update v' ((v, w', v') # the pv, val wv + w') res)\n                                   else RETURN (wl, res))\n                               (wl, res))))\n               \\<sigma>0 \\<bind>\n              (\\<lambda>(uu_, res). RETURN res))", "apply (refine_transfer)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition idijkstra for g ?v0.0 uses idijkstra_refines_aux"], ["", "lemma idijkstra_refines: \n    assumes \"g.invar g\"\n    shows \"RETURN (idijkstra g v0) \\<le> cdijkstra g v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (idijkstra g v0) \\<le> cdijkstra g v0", "using assms"], ["proof (prove)\nusing this:\n  g.invar g\n\ngoal (1 subgoal):\n 1. RETURN (idijkstra g v0) \\<le> cdijkstra g v0", "by (rule idijkstra.refine)"], ["", "end"], ["", "text \\<open>\n  The following theorem states correctness of the algorithm independent\n  from the refinement framework.\n\n  Intuitively, the first goal states that the abstraction of the returned \n  result is correct, the second goal states that the result\n  datastructure satisfies its invariant, and the third goal states \n  that the cached weights in the returned result are correct.\n\n  Note that this is the main theorem for a user of Dijkstra's algorithm in some \n  bigger context. It may also be specialized for concrete instances of the\n  implementation, as exemplarily done below.\n\\<close>"], ["", "theorem (in dijkstraC_fixg) idijkstra_correct:\n  shows\n  \"weighted_graph.is_shortest_path_map ga v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\" \n    (is ?G1)\n  and \"mr.invar (idijkstra g v0)\" (is ?G2) \n  and \"Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))\" (is ?G3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0))) &&&\n    mr.invar (idijkstra g v0) &&& res_invarm (mr.\\<alpha> (idijkstra g v0))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "from g_rel"], ["proof (chain)\npicking this:\n  (g, ga) \\<in> br g.\\<alpha> g.invar", "have I: \"g.invar g\""], ["proof (prove)\nusing this:\n  (g, ga) \\<in> br g.\\<alpha> g.invar\n\ngoal (1 subgoal):\n 1. g.invar g", "by (simp add: refine_rel_defs)"], ["proof (state)\nthis:\n  g.invar g\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "note idijkstra_refines[OF I]"], ["proof (state)\nthis:\n  RETURN (idijkstra g ?v0.0) \\<le> cdijkstra g ?v0.0\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "also"], ["proof (state)\nthis:\n  RETURN (idijkstra g ?v0.0) \\<le> cdijkstra g ?v0.0\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "note cdijkstra_refines"], ["proof (state)\nthis:\n  cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "also"], ["proof (state)\nthis:\n  cdijkstra g v0 \\<le> \\<Down> (br mr.\\<alpha> mr.invar) mdijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "note mdijkstra_refines"], ["proof (state)\nthis:\n  mdijkstra \\<le> \\<Down> (br \\<alpha>r res_invarm) dijkstra'\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "finally"], ["proof (chain)\npicking this:\n  RETURN (idijkstra g v0)\n  \\<le> \\<Down> (br mr.\\<alpha> mr.invar)\n         (\\<Down> (br \\<alpha>r res_invarm) dijkstra')", "have Z: \"RETURN (idijkstra g v0) \\<le> \n    \\<Down>(build_rel (\\<alpha>r \\<circ> mr.\\<alpha>) (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m))) \n      dijkstra'\""], ["proof (prove)\nusing this:\n  RETURN (idijkstra g v0)\n  \\<le> \\<Down> (br mr.\\<alpha> mr.invar)\n         (\\<Down> (br \\<alpha>r res_invarm) dijkstra')\n\ngoal (1 subgoal):\n 1. RETURN (idijkstra g v0)\n    \\<le> \\<Down>\n           (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n             (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n           dijkstra'", "apply (subst (asm) conc_fun_chain)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (idijkstra g v0)\n    \\<le> \\<Down> (br mr.\\<alpha> mr.invar O br \\<alpha>r res_invarm)\n           dijkstra' \\<Longrightarrow>\n    RETURN (idijkstra g v0)\n    \\<le> \\<Down>\n           (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n             (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n           dijkstra'", "apply (simp only: br_chain)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  RETURN (idijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         dijkstra'\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "also"], ["proof (state)\nthis:\n  RETURN (idijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         dijkstra'\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "note dijkstra'_refines[simplified]"], ["proof (state)\nthis:\n  dijkstra' \\<le> dijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "also"], ["proof (state)\nthis:\n  dijkstra' \\<le> dijkstra\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "note dijkstra_correct"], ["proof (state)\nthis:\n  dijkstra \\<le> SPEC (is_shortest_path_map v0)\n\ngoal (3 subgoals):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. mr.invar (idijkstra g v0)\n 3. res_invarm (mr.\\<alpha> (idijkstra g v0))", "finally"], ["proof (chain)\npicking this:\n  RETURN (idijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         (SPEC (is_shortest_path_map v0))", "show ?G1 ?G2 ?G3"], ["proof (prove)\nusing this:\n  RETURN (idijkstra g v0)\n  \\<le> \\<Down>\n         (br ((\\<alpha>r \\<circ>\\<circ> map_op_\\<alpha>) mr_ops)\n           (\\<lambda>m. mr.invar m \\<and> res_invarm (mr.\\<alpha> m)))\n         (SPEC (is_shortest_path_map v0))\n\ngoal (1 subgoal):\n 1. is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0))) &&&\n    mr.invar (idijkstra g v0) &&& res_invarm (mr.\\<alpha> (idijkstra g v0))", "by (auto elim: RETURN_ref_SPECD simp: refine_rel_defs)"], ["proof (state)\nthis:\n  is_shortest_path_map v0 (\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n  mr.invar (idijkstra g v0)\n  res_invarm (mr.\\<alpha> (idijkstra g v0))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem (in dijkstraC) idijkstra_correct:\n  assumes INV: \"g.invar g\"\n  assumes V0: \"v0 \\<in> nodes (g.\\<alpha> g)\"\n  assumes nonneg_weights: \"\\<And>v w v'. (v,w,v')\\<in>edges (g.\\<alpha> g) \\<Longrightarrow> 0\\<le>w\"\n  shows \n  \"weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0 \n      (Dijkstra.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\" (is ?G1)\n  and \"Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0\n     (Dijkstra.\\<alpha>r (mr.\\<alpha> (idijkstra g v0))) &&&\n    Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0\n     (Dijkstra.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))", "interpret gv: valid_graph \"g.\\<alpha> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_graph (g.\\<alpha> g)", "using g.valid INV"], ["proof (prove)\nusing this:\n  g.invar ?g \\<Longrightarrow> valid_graph (g.\\<alpha> ?g)\n  g.invar g\n\ngoal (1 subgoal):\n 1. valid_graph (g.\\<alpha> g)", "."], ["proof (state)\ngoal (2 subgoals):\n 1. weighted_graph.is_shortest_path_map (g.\\<alpha> g) v0\n     (Dijkstra.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. Dijkstra.res_invarm (mr.\\<alpha> (idijkstra g v0))", "interpret dcg: dijkstraC_fixg g_ops mr_ops qw_ops \"g.\\<alpha> g\" v0 g"], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstraC_fixg g_ops mr_ops qw_ops (g.\\<alpha> g) v0 g", "apply (rule dijkstraC_fixg.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. dijkstraC g_ops mr_ops qw_ops\n 2. Dijkstra (g.\\<alpha> g) v0\n 3. dijkstraC_fixg_axioms g_ops (g.\\<alpha> g) g", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. finite gv.V\n 2. finite gv.E\n 3. v0 \\<in> gv.V\n 4. \\<And>v w v'. (v, w, v') \\<in> gv.E \\<Longrightarrow> (0::'W) \\<le> w\n 5. (g, g.\\<alpha> g) \\<in> br g.\\<alpha> g.invar", "apply (simp_all add: hlg.finite INV V0 hlg_ops_def \n      nonneg_weights refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\ngoal (2 subgoals):\n 1. dcg.is_shortest_path_map v0\n     (dcg.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n 2. dcg.res_invarm (mr.\\<alpha> (idijkstra g v0))", "from dcg.idijkstra_correct"], ["proof (chain)\npicking this:\n  dcg.is_shortest_path_map v0 (dcg.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n  mr.invar (idijkstra g v0)\n  dcg.res_invarm (mr.\\<alpha> (idijkstra g v0))", "show ?G1 ?G2"], ["proof (prove)\nusing this:\n  dcg.is_shortest_path_map v0 (dcg.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n  mr.invar (idijkstra g v0)\n  dcg.res_invarm (mr.\\<alpha> (idijkstra g v0))\n\ngoal (1 subgoal):\n 1. dcg.is_shortest_path_map v0\n     (dcg.\\<alpha>r (mr.\\<alpha> (idijkstra g v0))) &&&\n    dcg.res_invarm (mr.\\<alpha> (idijkstra g v0))", "by simp_all"], ["proof (state)\nthis:\n  dcg.is_shortest_path_map v0 (dcg.\\<alpha>r (mr.\\<alpha> (idijkstra g v0)))\n  dcg.res_invarm (mr.\\<alpha> (idijkstra g v0))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Example instantiation with HashSet.based graph, \n  red-black-tree based result map, and finger-tree based priority queue.\n\\<close>"], ["", "setup Locale_Code.open_block"], ["", "interpretation hrf: dijkstraC hlg_ops rm_ops aluprioi_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. dijkstraC hlg_ops rm_ops aluprioi_ops", "by unfold_locales"], ["", "setup Locale_Code.close_block"], ["", "definition \"hrf_dijkstra \\<equiv> hrf.idijkstra\""], ["", "lemmas hrf_dijkstra_correct = hrf.idijkstra_correct[folded hrf_dijkstra_def]"], ["", "export_code hrf_dijkstra checking SML"], ["", "export_code hrf_dijkstra in OCaml"], ["", "export_code hrf_dijkstra in Haskell"], ["", "export_code hrf_dijkstra checking Scala"], ["", "definition hrfn_dijkstra :: \"(nat,nat) hlg \\<Rightarrow> _\" \n  where \"hrfn_dijkstra \\<equiv> hrf_dijkstra\""], ["", "export_code hrfn_dijkstra in SML"], ["", "lemmas hrfn_dijkstra_correct = \n  hrf_dijkstra_correct[where ?'a = nat and ?'b = nat, folded hrfn_dijkstra_def]"], ["", "term hrfn_dijkstra"], ["", "term hlg.from_list"], ["", "definition \"test_hrfn_dijkstra \n  \\<equiv> rm.to_list \n    (hrfn_dijkstra (hlg.from_list ([0..<4],[(0,3,1),(0,4,2),(2,1,3),(1,4,3)])) 0)\""], ["", "ML_val \\<open>\n  @{code test_hrfn_dijkstra}\n\n\\<close>"], ["", "end"]]}