{"file_name": "/home/qj213/afp-2021-10-22/thys/RSAPSS/RSAPSS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/RSAPSS", "problem_names": ["lemma length_emsapss_encode:\n  \"emsapss_encode m x \\<noteq> [] \\<Longrightarrow> length (emsapss_encode m x) = roundup x 8 * 8\"", "lemma bv_to_nat_emsapss_encode_le: \"emsapss_encode m x \\<noteq> [] \\<Longrightarrow> bv_to_nat (emsapss_encode m x) < 2^(roundup x 8 * 8)\"", "lemma length_helper1: shows \"length\n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))))@\n  sha1 (generate_M' (sha1 m) salt) @ BC)\n  = length \n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))))) + 168\"", "lemma MGFLen_helper: \"MGF z l ~= [] \\<Longrightarrow> l <= 2^32*(length (sha1 z))\"", "lemma length_helper2: assumes p: \"prime p\" and q: \"prime q\" \n                      and mgf: \"(MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))) ~= []\" \n  and len: \"length (sha1 M) + sLen + 16 \\<le> (length (nat_to_bv (p * q))) - Suc 0\"\n  shows \"length\n  (\n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))))\n  ) = (roundup (length (nat_to_bv (p * q)) - Suc 0) 8) * 8 - 168\"", "lemma emBits_roundup_cancel: \"emBits mod 8 ~= 0 \\<Longrightarrow> (roundup emBits 8)*8 - emBits = 8-(emBits mod 8)\"", "lemma emBits_roundup_cancel2: \"emBits mod 8 ~=0 \\<Longrightarrow> (roundup emBits 8) * 8 - (8-(emBits mod 8)) = emBits\"", "lemma length_bound: \"\\<lbrakk>emBits mod 8 ~=0; 8 <= (length maskedDB)\\<rbrakk> \\<Longrightarrow> length (remzero ((maskedDB_zero maskedDB emBits)@a@b)) <= length (maskedDB@a@b) - (8-(emBits mod 8))\"", "lemma length_bound2: \"8<=length ( (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))))))\"", "lemma length_helper: assumes p: \"prime p\" and q: \"prime q\" and x: \"(length (nat_to_bv (p * q)) - Suc 0) mod 8 ~= 0\" and mgf: \"(MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))) ~= []\"  \n  and len: \"length (sha1 M) + sLen + 16 \\<le> (length (nat_to_bv (p * q))) - Suc 0\"\n  shows \"length\n  (remzero\n  (maskedDB_zero\n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))))\n  (length (nat_to_bv (p * q)) - Suc 0) @\n  sha1 (generate_M' (sha1 m) salt) @ BC))\n  < length (nat_to_bv (p * q))\"", "lemma length_emsapss_smaller_pq: \"\\<lbrakk>prime p; prime q; emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []; (length (nat_to_bv (p * q)) - Suc 0) mod 8 ~= 0\\<rbrakk> \\<Longrightarrow>  length (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))) < length (nat_to_bv (p*q))\"", "lemma bv_to_nat_emsapss_smaller_pq: assumes a: \"prime p\" and b: \"prime q\" and pneq: \"p ~= q\" and c: \"emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\" shows \"bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p*q\"", "lemma rsa_pss_verify: \"\\<lbrakk> prime p; prime q; p \\<noteq> q; n = p*q; e*d mod ((pred p)*(pred q)) = 1; rsapss_sign m e n \\<noteq> []; s = rsapss_sign m e n \\<rbrakk> \\<Longrightarrow> rsapss_verify m s d n = True\""], "translations": [["", "lemma length_emsapss_encode:\n  \"emsapss_encode m x \\<noteq> [] \\<Longrightarrow> length (emsapss_encode m x) = roundup x 8 * 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emsapss_encode m x \\<noteq> [] \\<Longrightarrow>\n    length (emsapss_encode m x) = roundup x 8 * 8", "apply (atomize (full))"], ["proof (prove)\ngoal (1 subgoal):\n 1. emsapss_encode m x \\<noteq> [] \\<longrightarrow>\n    length (emsapss_encode m x) = roundup x 8 * 8", "apply (simp add: emsapss_encode_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help1 (sha1 m) x \\<noteq> [] \\<longrightarrow>\n    length (emsapss_encode_help1 (sha1 m) x) = roundup x 8 * 8", "apply (simp add: emsapss_encode_help1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help2 (generate_M' (sha1 m) salt) x \\<noteq>\n    [] \\<longrightarrow>\n    length (emsapss_encode_help2 (generate_M' (sha1 m) salt) x) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help3 (sha1 (generate_M' (sha1 m) salt)) x \\<noteq>\n    [] \\<longrightarrow>\n    length (emsapss_encode_help3 (sha1 (generate_M' (sha1 m) salt)) x) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help4\n     (generate_PS x (length (sha1 (generate_M' (sha1 m) salt))))\n     (sha1 (generate_M' (sha1 m) salt)) x \\<noteq>\n    [] \\<longrightarrow>\n    length\n     (emsapss_encode_help4\n       (generate_PS x (length (sha1 (generate_M' (sha1 m) salt))))\n       (sha1 (generate_M' (sha1 m) salt)) x) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help4_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help5\n     (generate_DB\n       (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n     (sha1 (generate_M' (sha1 m) salt)) x \\<noteq>\n    [] \\<longrightarrow>\n    length\n     (emsapss_encode_help5\n       (generate_DB\n         (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n       (sha1 (generate_M' (sha1 m) salt)) x) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help5_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help6\n     (generate_DB\n       (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))))\n     (sha1 (generate_M' (sha1 m) salt)) x \\<noteq>\n    [] \\<longrightarrow>\n    length\n     (emsapss_encode_help6\n       (generate_DB\n         (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))))\n       (sha1 (generate_M' (sha1 m) salt)) x) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help6_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS x\n           (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help7\n     (bvxor\n       (generate_DB\n         (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS x (length (sha1 (generate_M' (sha1 m) salt))))))))\n     (sha1 (generate_M' (sha1 m) salt)) x \\<noteq>\n    [] \\<longrightarrow>\n    length\n     (emsapss_encode_help7\n       (bvxor\n         (generate_DB\n           (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS x\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (sha1 (generate_M' (sha1 m) salt)) x) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help7_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS x\n           (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    emsapss_encode_help8\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS x\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       x)\n     (sha1 (generate_M' (sha1 m) salt)) \\<noteq>\n    [] \\<longrightarrow>\n    length\n     (emsapss_encode_help8\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS x\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         x)\n       (sha1 (generate_M' (sha1 m) salt))) =\n    roundup x 8 * 8", "apply (simp add: emsapss_encode_help8_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS x\n           (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     maskedDB_zero\n      (bvxor (generate_DB (generate_PS x 0))\n        (MGF [] (length (generate_DB (generate_PS x 0)))))\n      x =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    length\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS x\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       x) +\n    (length (sha1 (generate_M' (sha1 m) salt)) + length BC) =\n    roundup x 8 * 8", "apply (simp add: maskedDB_zero_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS x\n           (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     bv_prepend (roundup x 8 * 8 - x) \\<zero>\n      (drop (roundup x 8 * 8 - x)\n        (bvxor (generate_DB (generate_PS x 0))\n          (MGF [] (length (generate_DB (generate_PS x 0)))))) =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    length\n     (bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bvxor\n           (generate_DB\n             (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS x\n                   (length (sha1 (generate_M' (sha1 m) salt)))))))))) +\n    (length (sha1 (generate_M' (sha1 m) salt)) + length BC) =\n    roundup x 8 * 8", "apply (simp add: length_generate_DB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))) +\n      8 +\n      sLen) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < length (sha1 m) + sLen + 16 \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     bv_prepend (roundup x 8 * 8 - x) \\<zero>\n      (drop (roundup x 8 * 8 - x)\n        (bvxor (generate_DB (generate_PS x 0))\n          (MGF [] (length (generate_PS x 0) + 8 + sLen)))) =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    length\n     (bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bvxor\n           (generate_DB\n             (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_PS x (length (sha1 (generate_M' (sha1 m) salt)))) +\n              8 +\n              sLen))))) +\n    (length (sha1 (generate_M' (sha1 m) salt)) + length BC) =\n    roundup x 8 * 8", "apply (simp add: sha1len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length (generate_PS x 160) + 8 + sLen) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < 176 + sLen \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     bv_prepend (roundup x 8 * 8 - x) \\<zero>\n      (drop (roundup x 8 * 8 - x)\n        (bvxor (generate_DB (generate_PS x 0))\n          (MGF [] (length (generate_PS x 0) + 8 + sLen)))) =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    length\n     (bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bvxor (generate_DB (generate_PS x 160))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length (generate_PS x 160) + 8 + sLen))))) +\n    (160 + length BC) =\n    roundup x 8 * 8", "apply (simp add: bvxor)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length (generate_PS x 160) + 8 + sLen) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < 176 + sLen \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     bv_prepend (roundup x 8 * 8 - x) \\<zero>\n      (drop (roundup x 8 * 8 - x)\n        (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n          (MGF [] (length (generate_PS x 0) + 8 + sLen)))) =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    length\n     (bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 160))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length (generate_PS x 160) + 8 + sLen))))) +\n    (160 + length BC) =\n    roundup x 8 * 8", "apply (simp add: length_generate_PS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < 176 + sLen \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     bv_prepend (roundup x 8 * 8 - x) \\<zero>\n      (drop (roundup x 8 * 8 - x)\n        (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n          (MGF [] (length (generate_PS x 0) + 8 + sLen)))) =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    length\n     (bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 160))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (roundup x 8 * 8 - (176 + sLen) + 8 + sLen))))) +\n    (160 + length BC) =\n    roundup x 8 * 8", "apply (simp add: length_bv_prepend)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < 176 + sLen \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n     bv_prepend (roundup x 8 * 8 - x) \\<zero>\n      (drop (roundup x 8 * 8 - x)\n        (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n          (MGF [] (length (generate_PS x 0) + 8 + sLen)))) =\n     [] \\<longrightarrow>\n     BC \\<noteq> []) \\<longrightarrow>\n    roundup x 8 * 8 - x +\n    (max (length (generate_DB (generate_PS x 160)))\n      (length\n        (MGF (sha1 (generate_M' (sha1 m) salt))\n          (roundup x 8 * 8 - (176 + sLen) + 8 + sLen))) -\n     (roundup x 8 * 8 - x)) +\n    (160 + length BC) =\n    roundup x 8 * 8", "apply (simp add: MGF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (4294967296 * length (sha1 [])\n     < length (generate_PS x 0) + 8 + sLen \\<longrightarrow>\n     \\<not> 4294967296 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n            < roundup x 8 * 8 - (176 + sLen) + 8 + sLen \\<longrightarrow>\n     MGF1 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n        (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n       Suc 0)\n      (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           [])) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (length\n         (MGF1 (sha1 (generate_M' (sha1 m) salt))\n           (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n             (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n            Suc 0)\n           (roundup x 8 * 8 - (176 + sLen) + 8 + sLen))) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8) \\<and>\n    (\\<not> 4294967296 * length (sha1 [])\n            < length (generate_PS x 0) + 8 + sLen \\<longrightarrow>\n     \\<not> 4294967296 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n            < roundup x 8 * 8 - (176 + sLen) + 8 + sLen \\<longrightarrow>\n     MGF1 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n        (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n       Suc 0)\n      (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           (MGF1 []\n             (roundup (length (generate_PS x 0) + 8 + sLen)\n               (length (sha1 [])) -\n              Suc 0)\n             (length (generate_PS x 0) + 8 + sLen)))) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (length\n         (MGF1 (sha1 (generate_M' (sha1 m) salt))\n           (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n             (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n            Suc 0)\n           (roundup x 8 * 8 - (176 + sLen) + 8 + sLen))) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8)", "apply (simp add: MGF1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (4294967296 * length (sha1 [])\n     < length (generate_PS x 0) + 8 + sLen \\<longrightarrow>\n     \\<not> 4294967296 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n            < roundup x 8 * 8 - (176 + sLen) + 8 + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n        (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           [])) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (min (length\n              (MGF2 (sha1 (generate_M' (sha1 m) salt))\n                (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n                  (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n                 Suc 0)))\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8) \\<and>\n    (\\<not> 4294967296 * length (sha1 [])\n            < length (generate_PS x 0) + 8 + sLen \\<longrightarrow>\n     \\<not> 4294967296 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n            < roundup x 8 * 8 - (176 + sLen) + 8 + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n        (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           (take (length (generate_PS x 0) + 8 + sLen)\n             (MGF2 []\n               (roundup (length (generate_PS x 0) + 8 + sLen)\n                 (length (sha1 [])) -\n                Suc 0))))) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (min (length\n              (MGF2 (sha1 (generate_M' (sha1 m) salt))\n                (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n                  (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n                 Suc 0)))\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8)", "apply (simp add: length_MGF2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (4294967296 * length (sha1 [])\n     < length (generate_PS x 0) + 8 + sLen \\<longrightarrow>\n     \\<not> 4294967296 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n            < roundup x 8 * 8 - (176 + sLen) + 8 + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n        (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           [])) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (min (length\n              (sha1\n                (sha1 (generate_M' (sha1 m) salt) @\n                 nat_to_bv_length\n                  (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n                    (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n                   Suc 0)\n                  32)) +\n             (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n               (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n              Suc 0) *\n             length\n              (sha1\n                (sha1 (generate_M' (sha1 m) salt) @\n                 nat_to_bv_length\n                  (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n                    (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n                   Suc 0)\n                  32)))\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8) \\<and>\n    (\\<not> 4294967296 * length (sha1 [])\n            < length (generate_PS x 0) + 8 + sLen \\<longrightarrow>\n     \\<not> 4294967296 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n            < roundup x 8 * 8 - (176 + sLen) + 8 + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n        (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           (take (length (generate_PS x 0) + 8 + sLen)\n             (MGF2 []\n               (roundup (length (generate_PS x 0) + 8 + sLen)\n                 (length (sha1 [])) -\n                Suc 0))))) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (min (length\n              (sha1\n                (sha1 (generate_M' (sha1 m) salt) @\n                 nat_to_bv_length\n                  (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n                    (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n                   Suc 0)\n                  32)) +\n             (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n               (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n              Suc 0) *\n             length\n              (sha1\n                (sha1 (generate_M' (sha1 m) salt) @\n                 nat_to_bv_length\n                  (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)\n                    (length (sha1 (sha1 (generate_M' (sha1 m) salt)))) -\n                   Suc 0)\n                  32)))\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8)", "apply (simp add: sha1len)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (687194767352 < length (generate_PS x 0) + sLen \\<longrightarrow>\n     \\<not> 687194767352\n            < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           [])) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (min (160 +\n             (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n              Suc 0) *\n             160)\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8) \\<and>\n    (\\<not> 687194767352 < length (generate_PS x 0) + sLen \\<longrightarrow>\n     \\<not> 687194767352\n            < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           (take (length (generate_PS x 0) + 8 + sLen)\n             (MGF2 []\n               (roundup (length (generate_PS x 0) + 8 + sLen) 160 -\n                Suc 0))))) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_DB (generate_PS x 160)))\n       (min (160 +\n             (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n              Suc 0) *\n             160)\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8)", "apply (simp add: length_generate_DB)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (687194767352 < length (generate_PS x 0) + sLen \\<longrightarrow>\n     \\<not> 687194767352\n            < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           [])) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_PS x 160) + 8 + sLen)\n       (min (160 +\n             (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n              Suc 0) *\n             160)\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8) \\<and>\n    (\\<not> 687194767352 < length (generate_PS x 0) + sLen \\<longrightarrow>\n     \\<not> 687194767352\n            < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           (take (length (generate_PS x 0) + 8 + sLen)\n             (MGF2 []\n               (roundup (length (generate_PS x 0) + 8 + sLen) 160 -\n                Suc 0))))) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     roundup x 8 * 8 - x +\n     (max (length (generate_PS x 160) + 8 + sLen)\n       (min (160 +\n             (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n              Suc 0) *\n             160)\n         (roundup x 8 * 8 - (176 + sLen) + 8 + sLen)) -\n      (roundup x 8 * 8 - x)) +\n     (160 + length BC) =\n     roundup x 8 * 8)", "apply (simp add: length_generate_PS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (687194767352 < length (generate_PS x 0) + sLen \\<longrightarrow>\n     \\<not> 687194767352\n            < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           [])) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     168 + (roundup x 8 * 8 - (176 + sLen) + (sLen + length BC)) =\n     roundup x 8 * 8) \\<and>\n    (\\<not> 687194767352 < length (generate_PS x 0) + sLen \\<longrightarrow>\n     \\<not> 687194767352\n            < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [] \\<longrightarrow>\n     \\<not> x < 176 + sLen \\<longrightarrow>\n     \\<not> 18446744073709551616 \\<le> length m \\<and>\n     \\<not> 687194767360 < x \\<longrightarrow>\n     (sha1 (generate_M' (sha1 m) salt) = [] \\<longrightarrow>\n      bv_prepend (roundup x 8 * 8 - x) \\<zero>\n       (drop (roundup x 8 * 8 - x)\n         (bv_mapzip (\\<oplus>\\<^sub>b) (generate_DB (generate_PS x 0))\n           (take (length (generate_PS x 0) + 8 + sLen)\n             (MGF2 []\n               (roundup (length (generate_PS x 0) + 8 + sLen) 160 -\n                Suc 0))))) =\n      [] \\<longrightarrow>\n      BC \\<noteq> []) \\<longrightarrow>\n     168 + (roundup x 8 * 8 - (176 + sLen) + (sLen + length BC)) =\n     roundup x 8 * 8)", "apply (simp add: BC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 687194767352\n           < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n    MGF2 (sha1 (generate_M' (sha1 m) salt))\n     (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n      Suc 0) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < 176 + sLen \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    176 + (roundup x 8 * 8 - (176 + sLen) + sLen) = roundup x 8 * 8", "apply (insert roundup_ge_emBits [of x 8])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 < x; 0 < 8\\<rbrakk>\n     \\<Longrightarrow> x \\<le> roundup x 8 * 8) \\<Longrightarrow>\n    \\<not> 687194767352\n           < roundup x 8 * 8 - (176 + sLen) + sLen \\<longrightarrow>\n    MGF2 (sha1 (generate_M' (sha1 m) salt))\n     (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n      Suc 0) \\<noteq>\n    [] \\<longrightarrow>\n    \\<not> x < 176 + sLen \\<longrightarrow>\n    \\<not> 18446744073709551616 \\<le> length m \\<and>\n    \\<not> 687194767360 < x \\<longrightarrow>\n    176 + (roundup x 8 * 8 - (176 + sLen) + sLen) = roundup x 8 * 8", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>0 < x; 0 < 8\\<rbrakk>\n             \\<Longrightarrow> x \\<le> roundup x 8 * 8;\n     \\<not> 687194767352 < roundup x 8 * 8 - (176 + sLen) + sLen;\n     MGF2 (sha1 (generate_M' (sha1 m) salt))\n      (roundup (roundup x 8 * 8 - (176 + sLen) + 8 + sLen) 160 -\n       Suc 0) \\<noteq>\n     [];\n     \\<not> x < 176 + sLen; \\<not> 18446744073709551616 \\<le> length m;\n     \\<not> 687194767360 < x\\<rbrakk>\n    \\<Longrightarrow> 176 + (roundup x 8 * 8 - (176 + sLen) + sLen) =\n                      roundup x 8 * 8", "apply (simp add: max.absorb1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bv_to_nat_emsapss_encode_le: \"emsapss_encode m x \\<noteq> [] \\<Longrightarrow> bv_to_nat (emsapss_encode m x) < 2^(roundup x 8 * 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emsapss_encode m x \\<noteq> [] \\<Longrightarrow>\n    bv_to_nat (emsapss_encode m x) < 2 ^ (roundup x 8 * 8)", "apply (insert length_emsapss_encode [of m x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>emsapss_encode m x \\<noteq> [];\n     emsapss_encode m x \\<noteq> [] \\<Longrightarrow>\n     length (emsapss_encode m x) = roundup x 8 * 8\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (emsapss_encode m x) < 2 ^ (roundup x 8 * 8)", "apply (insert bv_to_nat_upper_range [of \"emsapss_encode m x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>emsapss_encode m x \\<noteq> [];\n     emsapss_encode m x \\<noteq> [] \\<Longrightarrow>\n     length (emsapss_encode m x) = roundup x 8 * 8;\n     bv_to_nat (emsapss_encode m x)\n     < 2 ^ length (emsapss_encode m x)\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (emsapss_encode m x) < 2 ^ (roundup x 8 * 8)", "by (simp)"], ["", "lemma length_helper1: shows \"length\n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))))@\n  sha1 (generate_M' (sha1 m) salt) @ BC)\n  = length \n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))))) + 168\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "have a: \"length BC = 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length BC = 8", "by (simp add: BC_def)"], ["proof (state)\nthis:\n  length BC = 8\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "have b: \"length (sha1 (generate_M' (sha1 m) salt)) = 160\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (sha1 (generate_M' (sha1 m) salt)) = 160", "by (simp add: sha1len)"], ["proof (state)\nthis:\n  length (sha1 (generate_M' (sha1 m) salt)) = 160\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "have c: \"\\<And> a b c. length (a@b@c) = length a + length b + length c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. length (a @ b @ c) = length a + length b + length c", "by simp"], ["proof (state)\nthis:\n  length (?a @ ?b @ ?c) = length ?a + length ?b + length ?c\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "from a and b"], ["proof (chain)\npicking this:\n  length BC = 8\n  length (sha1 (generate_M' (sha1 m) salt)) = 160", "show ?thesis"], ["proof (prove)\nusing this:\n  length BC = 8\n  length (sha1 (generate_M' (sha1 m) salt)) = 160\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "using c"], ["proof (prove)\nusing this:\n  length BC = 8\n  length (sha1 (generate_M' (sha1 m) salt)) = 160\n  length (?a @ ?b @ ?c) = length ?a + length ?b + length ?c\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "by simp"], ["proof (state)\nthis:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) @\n    sha1 (generate_M' (sha1 m) salt) @ BC) =\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n  168\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MGFLen_helper: \"MGF z l ~= [] \\<Longrightarrow> l <= 2^32*(length (sha1 z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MGF z l \\<noteq> [] \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "proof (cases \"2^32*length (sha1 z) < l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>MGF z l \\<noteq> []; 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)\n 2. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "assume x: \"MGF z l ~= []\""], ["proof (state)\nthis:\n  MGF z l \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MGF z l \\<noteq> []; 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)\n 2. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "assume a: \"2 ^ 32 * length (sha1 z) < l\""], ["proof (state)\nthis:\n  2 ^ 32 * length (sha1 z) < l\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MGF z l \\<noteq> []; 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)\n 2. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "then"], ["proof (chain)\npicking this:\n  2 ^ 32 * length (sha1 z) < l", "have \"MGF z l = []\""], ["proof (prove)\nusing this:\n  2 ^ 32 * length (sha1 z) < l\n\ngoal (1 subgoal):\n 1. MGF z l = []", "proof (cases \"l=0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l = 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []\n 2. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []", "assume \"l=0\""], ["proof (state)\nthis:\n  l = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l = 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []\n 2. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []", "then"], ["proof (chain)\npicking this:\n  l = 0", "show \"MGF z l = []\""], ["proof (prove)\nusing this:\n  l = 0\n\ngoal (1 subgoal):\n 1. MGF z l = []", "by (simp add: MGF_def)"], ["proof (state)\nthis:\n  MGF z l = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []", "assume \"l~=0\""], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []", "then"], ["proof (chain)\npicking this:\n  l \\<noteq> 0", "have \"(l = 0 \\<or> 2^32*length(sha1 z) < l) = True\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (l = 0 \\<or> 2 ^ 32 * length (sha1 z) < l) = True", "using a"], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n  2 ^ 32 * length (sha1 z) < l\n\ngoal (1 subgoal):\n 1. (l = 0 \\<or> 2 ^ 32 * length (sha1 z) < l) = True", "by fast"], ["proof (state)\nthis:\n  (l = 0 \\<or> 2 ^ 32 * length (sha1 z) < l) = True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>2 ^ 32 * length (sha1 z) < l; l \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> MGF z l = []", "then"], ["proof (chain)\npicking this:\n  (l = 0 \\<or> 2 ^ 32 * length (sha1 z) < l) = True", "show \"MGF z l = []\""], ["proof (prove)\nusing this:\n  (l = 0 \\<or> 2 ^ 32 * length (sha1 z) < l) = True\n\ngoal (1 subgoal):\n 1. MGF z l = []", "apply (simp only: MGF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l = 0 \\<or> 2 ^ 32 * length (sha1 z) < l) = True \\<Longrightarrow>\n    (if True then [] else MGF1 z (roundup l (length (sha1 z)) - 1) l) = []", "by simp"], ["proof (state)\nthis:\n  MGF z l = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MGF z l = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>MGF z l \\<noteq> []; 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)\n 2. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "then"], ["proof (chain)\npicking this:\n  MGF z l = []", "show ?thesis"], ["proof (prove)\nusing this:\n  MGF z l = []\n\ngoal (1 subgoal):\n 1. l \\<le> 2 ^ 32 * length (sha1 z)", "using x"], ["proof (prove)\nusing this:\n  MGF z l = []\n  MGF z l \\<noteq> []\n\ngoal (1 subgoal):\n 1. l \\<le> 2 ^ 32 * length (sha1 z)", "by simp"], ["proof (state)\nthis:\n  l \\<le> 2 ^ 32 * length (sha1 z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "assume \"\\<not> 2 ^ 32 * length (sha1 z) < l\""], ["proof (state)\nthis:\n  \\<not> 2 ^ 32 * length (sha1 z) < l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>MGF z l \\<noteq> [];\n     \\<not> 2 ^ 32 * length (sha1 z) < l\\<rbrakk>\n    \\<Longrightarrow> l \\<le> 2 ^ 32 * length (sha1 z)", "then"], ["proof (chain)\npicking this:\n  \\<not> 2 ^ 32 * length (sha1 z) < l", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 2 ^ 32 * length (sha1 z) < l\n\ngoal (1 subgoal):\n 1. l \\<le> 2 ^ 32 * length (sha1 z)", "by simp"], ["proof (state)\nthis:\n  l \\<le> 2 ^ 32 * length (sha1 z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_helper2: assumes p: \"prime p\" and q: \"prime q\" \n                      and mgf: \"(MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))) ~= []\" \n  and len: \"length (sha1 M) + sLen + 16 \\<le> (length (nat_to_bv (p * q))) - Suc 0\"\n  shows \"length\n  (\n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))))\n  ) = (roundup (length (nat_to_bv (p * q)) - Suc 0) 8) * 8 - 168\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "have a: \"length (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))) = (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "have \"0 < (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))", "by (simp add: generate_DB_def)"], ["proof (state)\nthis:\n  0 < length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "moreover"], ["proof (state)\nthis:\n  0 < length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "have \"(length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))) \\<le> 2^32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n    \\<le> 2 ^ 32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))", "using mgf and MGFLen_helper"], ["proof (prove)\nusing this:\n  MGF (sha1 (generate_M' (sha1 m) salt))\n   (length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n  []\n  MGF ?z ?l \\<noteq> [] \\<Longrightarrow> ?l \\<le> 2 ^ 32 * length (sha1 ?z)\n\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n    \\<le> 2 ^ 32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))", "by simp"], ["proof (state)\nthis:\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n  \\<le> 2 ^ 32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "ultimately"], ["proof (chain)\npicking this:\n  0 < length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n  \\<le> 2 ^ 32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n  \\<le> 2 ^ 32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "using length_MGF"], ["proof (prove)\nusing this:\n  0 < length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n  \\<le> 2 ^ 32 * length (sha1 (sha1 (generate_M' (sha1 m) salt)))\n  \\<lbrakk>0 < ?l; ?l \\<le> 2 ^ 32 * length (sha1 ?x)\\<rbrakk>\n  \\<Longrightarrow> length (MGF ?x ?l) = ?l\n\ngoal (1 subgoal):\n 1. length\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) =\n    length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))", "by simp"], ["proof (state)\nthis:\n  length\n   (MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt))))))) =\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt))))))) =\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "have b: \"length (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))) = ((roundup ((length (nat_to_bv (p * q))) - Suc 0) 8) * 8 - 168)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "have \"0 <= (length (nat_to_bv (p * q))) - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "from p"], ["proof (chain)\npicking this:\n  prime p", "have p2: \"1<p\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 1 < p", "by (simp add: prime_nat_iff)"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "moreover"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "from q"], ["proof (chain)\npicking this:\n  prime q", "have \"1<q\""], ["proof (prove)\nusing this:\n  prime q\n\ngoal (1 subgoal):\n 1. 1 < q", "by (simp add: prime_nat_iff)"], ["proof (state)\nthis:\n  1 < q\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "ultimately"], ["proof (chain)\npicking this:\n  1 < p\n  1 < q", "have \"p<p*q\""], ["proof (prove)\nusing this:\n  1 < p\n  1 < q\n\ngoal (1 subgoal):\n 1. p < p * q", "by simp"], ["proof (state)\nthis:\n  p < p * q\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "then"], ["proof (chain)\npicking this:\n  p < p * q", "have \"1<p*q\""], ["proof (prove)\nusing this:\n  p < p * q\n\ngoal (1 subgoal):\n 1. 1 < p * q", "using p2"], ["proof (prove)\nusing this:\n  p < p * q\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p * q", "by arith"], ["proof (state)\nthis:\n  1 < p * q\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "then"], ["proof (chain)\npicking this:\n  1 < p * q", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < p * q\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "using len_nat_to_bv_pos"], ["proof (prove)\nusing this:\n  1 < p * q\n  1 < ?a \\<Longrightarrow> 0 < length (nat_to_bv ?a)\n\ngoal (1 subgoal):\n 1. 0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "by simp"], ["proof (state)\nthis:\n  0 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "then"], ["proof (chain)\npicking this:\n  0 \\<le> length (nat_to_bv (p * q)) - Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "using solve_length_generate_DB"], ["proof (prove)\nusing this:\n  0 \\<le> length (nat_to_bv (p * q)) - Suc 0\n  \\<lbrakk>0 < ?emBits; length (sha1 ?M) + sLen + 16 \\<le> ?emBits\\<rbrakk>\n  \\<Longrightarrow> length\n                     (generate_DB\n                       (generate_PS ?emBits (length (sha1 ?x)))) =\n                    roundup ?emBits 8 * 8 - 168\n\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "using len"], ["proof (prove)\nusing this:\n  0 \\<le> length (nat_to_bv (p * q)) - Suc 0\n  \\<lbrakk>0 < ?emBits; length (sha1 ?M) + sLen + 16 \\<le> ?emBits\\<rbrakk>\n  \\<Longrightarrow> length\n                     (generate_DB\n                       (generate_PS ?emBits (length (sha1 ?x)))) =\n                    roundup ?emBits 8 * 8 - 168\n  length (sha1 M) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "by simp"], ["proof (state)\nthis:\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "have c: \"length (bvxor\n    (generate_DB\n    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n    (length (sha1 (generate_M' (sha1 m) salt)))))\n    (MGF (sha1 (generate_M' (sha1 m) salt))\n    (length\n    (generate_DB\n    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n    (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "using a and b and length_bvxor"], ["proof (prove)\nusing this:\n  length\n   (MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt))))))) =\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt)))))\n  length\n   (generate_DB\n     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n       (length (sha1 (generate_M' (sha1 m) salt))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n  length ?a = length ?b \\<Longrightarrow> length (bvxor ?a ?b) = length ?a\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "by simp"], ["proof (state)\nthis:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "then"], ["proof (chain)\npicking this:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "by simp"], ["proof (state)\nthis:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emBits_roundup_cancel: \"emBits mod 8 ~= 0 \\<Longrightarrow> (roundup emBits 8)*8 - emBits = 8-(emBits mod 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emBits mod 8 \\<noteq> 0 \\<Longrightarrow>\n    roundup emBits 8 * 8 - emBits = 8 - emBits mod 8", "apply (auto simp add: roundup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < emBits mod 8 \\<Longrightarrow>\n    8 + emBits div 8 * 8 - emBits = 8 - emBits mod 8", "by (arith)"], ["", "lemma emBits_roundup_cancel2: \"emBits mod 8 ~=0 \\<Longrightarrow> (roundup emBits 8) * 8 - (8-(emBits mod 8)) = emBits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emBits mod 8 \\<noteq> 0 \\<Longrightarrow>\n    roundup emBits 8 * 8 - (8 - emBits mod 8) = emBits", "by (auto simp add: roundup)"], ["", "lemma length_bound: \"\\<lbrakk>emBits mod 8 ~=0; 8 <= (length maskedDB)\\<rbrakk> \\<Longrightarrow> length (remzero ((maskedDB_zero maskedDB emBits)@a@b)) <= length (maskedDB@a@b) - (8-(emBits mod 8))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>emBits mod 8 \\<noteq> 0; 8 \\<le> length maskedDB\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n                      \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>emBits mod 8 \\<noteq> 0; 8 \\<le> length maskedDB\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n                      \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "assume a: \"emBits mod 8 ~=0\""], ["proof (state)\nthis:\n  emBits mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>emBits mod 8 \\<noteq> 0; 8 \\<le> length maskedDB\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n                      \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "assume len: \"8 <= (length maskedDB)\""], ["proof (state)\nthis:\n  8 \\<le> length maskedDB\n\ngoal (1 subgoal):\n 1. \\<lbrakk>emBits mod 8 \\<noteq> 0; 8 \\<le> length maskedDB\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n                      \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "have b:\" \\<And> a. length (remzero a) <= length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. length (remzero a) \\<le> length a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. length (remzero a) \\<le> length a", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. length (remzero a) \\<le> length a", "show \"length (remzero a) <= length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remzero a) \\<le> length a", "proof (induct a)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (remzero []) \\<le> length []\n 2. \\<And>a1 a2.\n       length (remzero a2) \\<le> length a2 \\<Longrightarrow>\n       length (remzero (a1 # a2)) \\<le> length (a1 # a2)", "show \"(length (remzero [])) <= length []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remzero []) \\<le> length []", "by (simp)"], ["proof (state)\nthis:\n  length (remzero []) \\<le> length []\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       length (remzero a2) \\<le> length a2 \\<Longrightarrow>\n       length (remzero (a1 # a2)) \\<le> length (a1 # a2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       length (remzero a2) \\<le> length a2 \\<Longrightarrow>\n       length (remzero (a1 # a2)) \\<le> length (a1 # a2)", "case (Cons hd tl)"], ["proof (state)\nthis:\n  length (remzero tl) \\<le> length tl\n\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       length (remzero a2) \\<le> length a2 \\<Longrightarrow>\n       length (remzero (a1 # a2)) \\<le> length (a1 # a2)", "show \"(length (remzero (hd#tl))) <= length (hd#tl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (remzero (hd # tl)) \\<le> length (hd # tl)", "proof (cases hd)"], ["proof (state)\ngoal (2 subgoals):\n 1. hd = \\<zero> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)\n 2. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "assume \"hd=\\<zero>\""], ["proof (state)\nthis:\n  hd = \\<zero>\n\ngoal (2 subgoals):\n 1. hd = \\<zero> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)\n 2. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "then"], ["proof (chain)\npicking this:\n  hd = \\<zero>", "have \"remzero (hd#tl) = remzero tl\""], ["proof (prove)\nusing this:\n  hd = \\<zero>\n\ngoal (1 subgoal):\n 1. remzero (hd # tl) = remzero tl", "by simp"], ["proof (state)\nthis:\n  remzero (hd # tl) = remzero tl\n\ngoal (2 subgoals):\n 1. hd = \\<zero> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)\n 2. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "then"], ["proof (chain)\npicking this:\n  remzero (hd # tl) = remzero tl", "show ?thesis"], ["proof (prove)\nusing this:\n  remzero (hd # tl) = remzero tl\n\ngoal (1 subgoal):\n 1. length (remzero (hd # tl)) \\<le> length (hd # tl)", "using Cons"], ["proof (prove)\nusing this:\n  remzero (hd # tl) = remzero tl\n  length (remzero tl) \\<le> length tl\n\ngoal (1 subgoal):\n 1. length (remzero (hd # tl)) \\<le> length (hd # tl)", "by simp"], ["proof (state)\nthis:\n  length (remzero (hd # tl)) \\<le> length (hd # tl)\n\ngoal (1 subgoal):\n 1. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "assume \"hd=\\<one>\""], ["proof (state)\nthis:\n  hd = \\<one>\n\ngoal (1 subgoal):\n 1. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "then"], ["proof (chain)\npicking this:\n  hd = \\<one>", "have \"remzero (hd#tl) = hd#tl\""], ["proof (prove)\nusing this:\n  hd = \\<one>\n\ngoal (1 subgoal):\n 1. remzero (hd # tl) = hd # tl", "by simp"], ["proof (state)\nthis:\n  remzero (hd # tl) = hd # tl\n\ngoal (1 subgoal):\n 1. hd = \\<one> \\<Longrightarrow>\n    length (remzero (hd # tl)) \\<le> length (hd # tl)", "then"], ["proof (chain)\npicking this:\n  remzero (hd # tl) = hd # tl", "show ?thesis"], ["proof (prove)\nusing this:\n  remzero (hd # tl) = hd # tl\n\ngoal (1 subgoal):\n 1. length (remzero (hd # tl)) \\<le> length (hd # tl)", "by simp"], ["proof (state)\nthis:\n  length (remzero (hd # tl)) \\<le> length (hd # tl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (remzero (hd # tl)) \\<le> length (hd # tl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (remzero a) \\<le> length a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (remzero ?a) \\<le> length ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>emBits mod 8 \\<noteq> 0; 8 \\<le> length maskedDB\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n                      \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "from len"], ["proof (chain)\npicking this:\n  8 \\<le> length maskedDB", "show \"length (remzero (maskedDB_zero maskedDB emBits @ a @ b)) \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)\""], ["proof (prove)\nusing this:\n  8 \\<le> length maskedDB\n\ngoal (1 subgoal):\n 1. length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 8 \\<le> length maskedDB \\<Longrightarrow>\n    length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "have \"remzero(bv_prepend ((roundup emBits 8) * 8 - emBits)\n      \\<zero> (drop ((roundup emBits 8)*8 - emBits) maskedDB)@a@b) = remzero ((drop ((roundup emBits 8)*8 -emBits) maskedDB)@a@b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remzero\n     (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n       (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n      a @ b) =\n    remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)", "using remzero_replicate"], ["proof (prove)\nusing this:\n  remzero (replicate ?n \\<zero> @ ?l) = remzero ?l\n\ngoal (1 subgoal):\n 1. remzero\n     (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n       (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n      a @ b) =\n    remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)", "by (simp add: bv_prepend)"], ["proof (state)\nthis:\n  remzero\n   (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n     (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n    a @ b) =\n  remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)\n\ngoal (1 subgoal):\n 1. 8 \\<le> length maskedDB \\<Longrightarrow>\n    length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "moreover"], ["proof (state)\nthis:\n  remzero\n   (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n     (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n    a @ b) =\n  remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)\n\ngoal (1 subgoal):\n 1. 8 \\<le> length maskedDB \\<Longrightarrow>\n    length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "from emBits_roundup_cancel"], ["proof (chain)\npicking this:\n  ?emBits mod 8 \\<noteq> 0 \\<Longrightarrow>\n  roundup ?emBits 8 * 8 - ?emBits = 8 - ?emBits mod 8", "have \"roundup emBits 8 * 8 - emBits = 8 - emBits mod 8\""], ["proof (prove)\nusing this:\n  ?emBits mod 8 \\<noteq> 0 \\<Longrightarrow>\n  roundup ?emBits 8 * 8 - ?emBits = 8 - ?emBits mod 8\n\ngoal (1 subgoal):\n 1. roundup emBits 8 * 8 - emBits = 8 - emBits mod 8", "using a"], ["proof (prove)\nusing this:\n  ?emBits mod 8 \\<noteq> 0 \\<Longrightarrow>\n  roundup ?emBits 8 * 8 - ?emBits = 8 - ?emBits mod 8\n  emBits mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. roundup emBits 8 * 8 - emBits = 8 - emBits mod 8", "by simp"], ["proof (state)\nthis:\n  roundup emBits 8 * 8 - emBits = 8 - emBits mod 8\n\ngoal (1 subgoal):\n 1. 8 \\<le> length maskedDB \\<Longrightarrow>\n    length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "moreover"], ["proof (state)\nthis:\n  roundup emBits 8 * 8 - emBits = 8 - emBits mod 8\n\ngoal (1 subgoal):\n 1. 8 \\<le> length maskedDB \\<Longrightarrow>\n    length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "have \"length ((drop (8-emBits mod 8) maskedDB)@a@b) = length (maskedDB@a@b) - (8-emBits mod 8)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n    length (maskedDB @ a @ b) - (8 - emBits mod 8)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n    length (maskedDB @ a @ b) - (8 - emBits mod 8)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n    length (maskedDB @ a @ b) - (8 - emBits mod 8)", "using length_drop[of \"(8-emBits mod 8)\" maskedDB]"], ["proof (prove)\nusing this:\n  length (drop (8 - emBits mod 8) maskedDB) =\n  length maskedDB - (8 - emBits mod 8)\n\ngoal (1 subgoal):\n 1. length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n    length (maskedDB @ a @ b) - (8 - emBits mod 8)", "proof (simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n    length maskedDB + (length a + length b) + emBits mod 8 - 8", "have \"0 <= emBits mod 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> emBits mod 8", "by simp"], ["proof (state)\nthis:\n  0 \\<le> emBits mod 8\n\ngoal (1 subgoal):\n 1. length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n    length maskedDB + (length a + length b) + emBits mod 8 - 8", "then"], ["proof (chain)\npicking this:\n  0 \\<le> emBits mod 8", "have \"8-(emBits mod 8) <= 8\""], ["proof (prove)\nusing this:\n  0 \\<le> emBits mod 8\n\ngoal (1 subgoal):\n 1. 8 - emBits mod 8 \\<le> 8", "by simp"], ["proof (state)\nthis:\n  8 - emBits mod 8 \\<le> 8\n\ngoal (1 subgoal):\n 1. length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n    length maskedDB + (length a + length b) + emBits mod 8 - 8", "then"], ["proof (chain)\npicking this:\n  8 - emBits mod 8 \\<le> 8", "show  \"length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n          length maskedDB + (length a + length b) + emBits mod 8 - 8\""], ["proof (prove)\nusing this:\n  8 - emBits mod 8 \\<le> 8\n\ngoal (1 subgoal):\n 1. length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n    length maskedDB + (length a + length b) + emBits mod 8 - 8", "using len"], ["proof (prove)\nusing this:\n  8 - emBits mod 8 \\<le> 8\n  8 \\<le> length maskedDB\n\ngoal (1 subgoal):\n 1. length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n    length maskedDB + (length a + length b) + emBits mod 8 - 8", "by arith"], ["proof (state)\nthis:\n  length maskedDB + emBits mod 8 - 8 + (length a + length b) =\n  length maskedDB + (length a + length b) + emBits mod 8 - 8\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n  length (maskedDB @ a @ b) - (8 - emBits mod 8)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n  length (maskedDB @ a @ b) - (8 - emBits mod 8)\n\ngoal (1 subgoal):\n 1. 8 \\<le> length maskedDB \\<Longrightarrow>\n    length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "ultimately"], ["proof (chain)\npicking this:\n  remzero\n   (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n     (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n    a @ b) =\n  remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)\n  roundup emBits 8 * 8 - emBits = 8 - emBits mod 8\n  length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n  length (maskedDB @ a @ b) - (8 - emBits mod 8)", "show ?thesis"], ["proof (prove)\nusing this:\n  remzero\n   (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n     (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n    a @ b) =\n  remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)\n  roundup emBits 8 * 8 - emBits = 8 - emBits mod 8\n  length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n  length (maskedDB @ a @ b) - (8 - emBits mod 8)\n\ngoal (1 subgoal):\n 1. length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "using b[of \"(drop ((roundup emBits 8)*8 - emBits) maskedDB)@a@b\"]"], ["proof (prove)\nusing this:\n  remzero\n   (bv_prepend (roundup emBits 8 * 8 - emBits) \\<zero>\n     (drop (roundup emBits 8 * 8 - emBits) maskedDB) @\n    a @ b) =\n  remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)\n  roundup emBits 8 * 8 - emBits = 8 - emBits mod 8\n  length (drop (8 - emBits mod 8) maskedDB @ a @ b) =\n  length (maskedDB @ a @ b) - (8 - emBits mod 8)\n  length (remzero (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b))\n  \\<le> length (drop (roundup emBits 8 * 8 - emBits) maskedDB @ a @ b)\n\ngoal (1 subgoal):\n 1. length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n    \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)", "by (simp add: maskedDB_zero_def)"], ["proof (state)\nthis:\n  length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n  \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (remzero (maskedDB_zero maskedDB emBits @ a @ b))\n  \\<le> length (maskedDB @ a @ b) - (8 - emBits mod 8)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_bound2: \"8<=length ( (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 \\<le> length\n             (bvxor\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt)))))\n               (MGF (sha1 (generate_M' (sha1 m) salt))\n                 (length\n                   (generate_DB\n                     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                       (length (sha1 (generate_M' (sha1 m) salt))))))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 8 \\<le> length\n             (bvxor\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt)))))\n               (MGF (sha1 (generate_M' (sha1 m) salt))\n                 (length\n                   (generate_DB\n                     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                       (length (sha1 (generate_M' (sha1 m) salt))))))))", "have \"8 <= length (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 8 \\<le> length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))", "by (simp add: generate_DB_def)"], ["proof (state)\nthis:\n  8 \\<le> length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n\ngoal (1 subgoal):\n 1. 8 \\<le> length\n             (bvxor\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt)))))\n               (MGF (sha1 (generate_M' (sha1 m) salt))\n                 (length\n                   (generate_DB\n                     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                       (length (sha1 (generate_M' (sha1 m) salt))))))))", "then"], ["proof (chain)\npicking this:\n  8 \\<le> length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))", "show ?thesis"], ["proof (prove)\nusing this:\n  8 \\<le> length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n\ngoal (1 subgoal):\n 1. 8 \\<le> length\n             (bvxor\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt)))))\n               (MGF (sha1 (generate_M' (sha1 m) salt))\n                 (length\n                   (generate_DB\n                     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                       (length (sha1 (generate_M' (sha1 m) salt))))))))", "using length_bvxor_bound"], ["proof (prove)\nusing this:\n  8 \\<le> length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n  ?a \\<le> length ?l \\<Longrightarrow> ?a \\<le> length (bvxor ?l ?l2.0)\n\ngoal (1 subgoal):\n 1. 8 \\<le> length\n             (bvxor\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt)))))\n               (MGF (sha1 (generate_M' (sha1 m) salt))\n                 (length\n                   (generate_DB\n                     (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                       (length (sha1 (generate_M' (sha1 m) salt))))))))", "by simp"], ["proof (state)\nthis:\n  8 \\<le> length\n           (bvxor\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 m) salt))\n               (length\n                 (generate_DB\n                   (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                     (length (sha1 (generate_M' (sha1 m) salt))))))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_helper: assumes p: \"prime p\" and q: \"prime q\" and x: \"(length (nat_to_bv (p * q)) - Suc 0) mod 8 ~= 0\" and mgf: \"(MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))) ~= []\"  \n  and len: \"length (sha1 M) + sLen + 16 \\<le> (length (nat_to_bv (p * q))) - Suc 0\"\n  shows \"length\n  (remzero\n  (maskedDB_zero\n  (bvxor\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt)))))\n  (MGF (sha1 (generate_M' (sha1 m) salt))\n  (length\n  (generate_DB\n  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n  (length (sha1 (generate_M' (sha1 m) salt))))))))\n  (length (nat_to_bv (p * q)) - Suc 0) @\n  sha1 (generate_M' (sha1 m) salt) @ BC))\n  < length (nat_to_bv (p * q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "from mgf"], ["proof (chain)\npicking this:\n  MGF (sha1 (generate_M' (sha1 m) salt))\n   (length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n  []", "have round: \"168 <= roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\""], ["proof (prove)\nusing this:\n  MGF (sha1 (generate_M' (sha1 m) salt))\n   (length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. 168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "proof (simp only: sha1len sLen_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0) 160))) \\<noteq>\n    [] \\<Longrightarrow>\n    168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "from len"], ["proof (chain)\npicking this:\n  length (sha1 M) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0", "have \"160 + sLen +16 \\<le> length (nat_to_bv (p * q)) - Suc 0\""], ["proof (prove)\nusing this:\n  length (sha1 M) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. 160 + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0", "by (simp add: sha1len)"], ["proof (state)\nthis:\n  160 + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0) 160))) \\<noteq>\n    [] \\<Longrightarrow>\n    168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "then"], ["proof (chain)\npicking this:\n  160 + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0", "have len1: \"176 <= length (nat_to_bv (p * q)) - Suc 0\""], ["proof (prove)\nusing this:\n  160 + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. 176 \\<le> length (nat_to_bv (p * q)) - Suc 0", "by simp"], ["proof (state)\nthis:\n  176 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0) 160))) \\<noteq>\n    [] \\<Longrightarrow>\n    168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "have \"length (nat_to_bv (p*q)) - Suc 0 <= (roundup (length (nat_to_bv (p * q)) - Suc 0) 8) * 8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv (p * q)) - Suc 0\n    \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "unfolding roundup"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "proof (cases \"(length (nat_to_bv (p*q)) - Suc 0) mod 8 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8\n 2. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "assume len2: \"(length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\""], ["proof (state)\nthis:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n\ngoal (2 subgoals):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8\n 2. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "then"], ["proof (chain)\npicking this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0", "have \"(if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 then (length (nat_to_bv (p * q)) - Suc 0) div 8 else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8 = (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8\""], ["proof (prove)\nusing this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n\ngoal (1 subgoal):\n 1. (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n     then (length (nat_to_bv (p * q)) - Suc 0) div 8\n     else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n    8 =\n    (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8", "by simp"], ["proof (state)\nthis:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8\n\ngoal (2 subgoals):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8\n 2. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "moreover"], ["proof (state)\nthis:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8\n\ngoal (2 subgoals):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8\n 2. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "have \"(length (nat_to_bv (p * q)) - Suc 0) div 8 * 8 = (length (nat_to_bv (p * q)) - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8 =\n    length (nat_to_bv (p * q)) - Suc 0", "using len2"], ["proof (prove)\nusing this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8 =\n    length (nat_to_bv (p * q)) - Suc 0", "by auto"], ["proof (state)\nthis:\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8 =\n  length (nat_to_bv (p * q)) - Suc 0\n\ngoal (2 subgoals):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8\n 2. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "ultimately"], ["proof (chain)\npicking this:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8 =\n  length (nat_to_bv (p * q)) - Suc 0", "show \"length (nat_to_bv (p * q)) - Suc 0\n        \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 then (length (nat_to_bv (p * q)) - Suc 0) div 8 else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\""], ["proof (prove)\nusing this:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8\n  (length (nat_to_bv (p * q)) - Suc 0) div 8 * 8 =\n  length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "by simp"], ["proof (state)\nthis:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n         then (length (nat_to_bv (p * q)) - Suc 0) div 8\n         else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n        8\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "assume len2: \"(length (nat_to_bv (p*q)) - Suc 0) mod 8 ~= 0\""], ["proof (state)\nthis:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "then"], ["proof (chain)\npicking this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0", "have \"(if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 then (length (nat_to_bv (p * q)) - Suc 0) div 8 else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8 = ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\""], ["proof (prove)\nusing this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n     then (length (nat_to_bv (p * q)) - Suc 0) div 8\n     else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n    8 =\n    ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8", "by simp"], ["proof (state)\nthis:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "moreover"], ["proof (state)\nthis:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "have \"length (nat_to_bv (p*q)) - Suc 0 <= ((length (nat_to_bv (p*q)) - Suc 0) div 8 + 1)*8\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv (p * q)) - Suc 0\n    \\<le> ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8", "by auto"], ["proof (state)\nthis:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0 \\<Longrightarrow>\n    length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "ultimately"], ["proof (chain)\npicking this:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8", "show \"length (nat_to_bv (p * q)) - Suc 0\n        \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0 then (length (nat_to_bv (p * q)) - Suc 0) div 8 else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\""], ["proof (prove)\nusing this:\n  (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n   then (length (nat_to_bv (p * q)) - Suc 0) div 8\n   else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n  8 =\n  ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> ((length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) * 8\n\ngoal (1 subgoal):\n 1. length (nat_to_bv (p * q)) - Suc 0\n    \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n           then (length (nat_to_bv (p * q)) - Suc 0) div 8\n           else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n          8", "by simp"], ["proof (state)\nthis:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> (if (length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0\n         then (length (nat_to_bv (p * q)) - Suc 0) div 8\n         else (length (nat_to_bv (p * q)) - Suc 0) div 8 + 1) *\n        8\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\n\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0) 160))) \\<noteq>\n    [] \\<Longrightarrow>\n    168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "then"], ["proof (chain)\npicking this:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "show \"168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\""], ["proof (prove)\nusing this:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\n\ngoal (1 subgoal):\n 1. 168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "using len1"], ["proof (prove)\nusing this:\n  length (nat_to_bv (p * q)) - Suc 0\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\n  176 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. 168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8", "by simp"], ["proof (state)\nthis:\n  168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "from x"], ["proof (chain)\npicking this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0", "have a: \"length\n    (remzero\n    (maskedDB_zero\n    (bvxor\n    (generate_DB\n    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n    (length (sha1 (generate_M' (sha1 m) salt)))))\n    (MGF (sha1 (generate_M' (sha1 m) salt))\n    (length\n    (generate_DB\n    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n    (length (sha1 (generate_M' (sha1 m) salt))))))))\n    (length (nat_to_bv (p * q)) - Suc 0) @\n    sha1 (generate_M' (sha1 m) salt) @ BC)) <= length ((bvxor\n    (generate_DB\n    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n    (length (sha1 (generate_M' (sha1 m) salt)))))\n    (MGF (sha1 (generate_M' (sha1 m) salt))\n    (length\n    (generate_DB\n    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n    (length (sha1 (generate_M' (sha1 m) salt)))))))) @\n    sha1 (generate_M' (sha1 m) salt) @ BC) - (8 - (length (nat_to_bv (p*q)) - Suc 0) mod 8)\""], ["proof (prove)\nusing this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    \\<le> length\n           (bvxor\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 m) salt))\n               (length\n                 (generate_DB\n                   (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                     (length (sha1 (generate_M' (sha1 m) salt))))))) @\n            sha1 (generate_M' (sha1 m) salt) @ BC) -\n          (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)", "using length_bound and length_bound2"], ["proof (prove)\nusing this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n  \\<lbrakk>?emBits mod 8 \\<noteq> 0; 8 \\<le> length ?maskedDB\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remzero (maskedDB_zero ?maskedDB ?emBits @ ?a @ ?b))\n                    \\<le> length (?maskedDB @ ?a @ ?b) - (8 - ?emBits mod 8)\n  8 \\<le> length\n           (bvxor\n             (generate_DB\n               (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 ?m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 ?m) salt))\n               (length\n                 (generate_DB\n                   (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n                     (length (sha1 (generate_M' (sha1 ?m) salt))))))))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    \\<le> length\n           (bvxor\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 m) salt))\n               (length\n                 (generate_DB\n                   (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                     (length (sha1 (generate_M' (sha1 m) salt))))))) @\n            sha1 (generate_M' (sha1 m) salt) @ BC) -\n          (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)", "by simp"], ["proof (state)\nthis:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> length\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))) @\n          sha1 (generate_M' (sha1 m) salt) @ BC) -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "have b: \" length (bvxor (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 m) salt)) (length (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt))))))) @\n            sha1 (generate_M' (sha1 m) salt) @ BC) =  length (bvxor (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 m) salt)) (length (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))))) +168\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "using length_helper1"], ["proof (prove)\nusing this:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 ?m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 ?m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 ?m) salt))))))) @\n    sha1 (generate_M' (sha1 ?m) salt) @ BC) =\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 ?m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 ?m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 ?m) salt)))))))) +\n  168\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))) @\n      sha1 (generate_M' (sha1 m) salt) @ BC) =\n    length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n    168", "by simp"], ["proof (state)\nthis:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) @\n    sha1 (generate_M' (sha1 m) salt) @ BC) =\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n  168\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "have c: \"length (bvxor (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt)) (length (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))))) = \n            (roundup (length (nat_to_bv (p * q)) - Suc 0) 8) * 8 - 168\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "using p and q and length_helper2 and mgf and len"], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  \\<lbrakk>prime ?p; prime ?q;\n   MGF (sha1 (generate_M' (sha1 ?m) salt))\n    (length\n      (generate_DB\n        (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n          (length (sha1 (generate_M' (sha1 ?m) salt)))))) \\<noteq>\n   [];\n   length (sha1 ?M) + sLen + 16\n   \\<le> length (nat_to_bv (?p * ?q)) - Suc 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (bvxor\n                       (generate_DB\n                         (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n                           (length (sha1 (generate_M' (sha1 ?m) salt)))))\n                       (MGF (sha1 (generate_M' (sha1 ?m) salt))\n                         (length\n                           (generate_DB\n                             (generate_PS\n                               (length (nat_to_bv (?p * ?q)) - Suc 0)\n                               (length\n                                 (sha1 (generate_M' (sha1 ?m) salt)))))))) =\n                    roundup (length (nat_to_bv (?p * ?q)) - Suc 0) 8 * 8 -\n                    168\n  MGF (sha1 (generate_M' (sha1 m) salt))\n   (length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n  []\n  length (sha1 M) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n    roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "by simp"], ["proof (state)\nthis:\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "from a and b and c"], ["proof (chain)\npicking this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> length\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))) @\n          sha1 (generate_M' (sha1 m) salt) @ BC) -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) @\n    sha1 (generate_M' (sha1 m) salt) @ BC) =\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n  168\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168", "have \" length (remzero (maskedDB_zero\n                    (bvxor (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))\n                      (MGF (sha1 (generate_M' (sha1 m) salt))\n                        (length (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt))))))))\n                    (length (nat_to_bv (p * q)) - Suc 0) @\n                   sha1 (generate_M' (sha1 m) salt) @ BC)) <=  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168 +168 - (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\""], ["proof (prove)\nusing this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> length\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))) @\n          sha1 (generate_M' (sha1 m) salt) @ BC) -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))) @\n    sha1 (generate_M' (sha1 m) salt) @ BC) =\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) +\n  168\n  length\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))))) =\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168 + 168 -\n          (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)", "by simp"], ["proof (state)\nthis:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168 + 168 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "then"], ["proof (chain)\npicking this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168 + 168 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)", "have \"length (remzero (maskedDB_zero\n                    (bvxor (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt)))))\n                      (MGF (sha1 (generate_M' (sha1 m) salt))\n                        (length (generate_DB (generate_PS (length (nat_to_bv (p * q)) - Suc 0) (length (sha1 (generate_M' (sha1 m) salt))))))))\n                    (length (nat_to_bv (p * q)) - Suc 0) @\n                   sha1 (generate_M' (sha1 m) salt) @ BC)) <= roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\""], ["proof (prove)\nusing this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168 + 168 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n          (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)", "using round"], ["proof (prove)\nusing this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - 168 + 168 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n  168 \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n          (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)", "by simp"], ["proof (state)\nthis:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "moreover"], ["proof (state)\nthis:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "have \"  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 - (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) = (length (nat_to_bv (p*q))-Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n    (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) =\n    length (nat_to_bv (p * q)) - Suc 0", "using x and emBits_roundup_cancel2"], ["proof (prove)\nusing this:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n  ?emBits mod 8 \\<noteq> 0 \\<Longrightarrow>\n  roundup ?emBits 8 * 8 - (8 - ?emBits mod 8) = ?emBits\n\ngoal (1 subgoal):\n 1. roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n    (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) =\n    length (nat_to_bv (p * q)) - Suc 0", "by simp"], ["proof (state)\nthis:\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n  (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) =\n  length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "moreover"], ["proof (state)\nthis:\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n  (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) =\n  length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "have \"0<length (nat_to_bv (p*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "from p"], ["proof (chain)\npicking this:\n  prime p", "have s: \"1<p\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 1 < p", "by (simp add: prime_nat_iff)"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "moreover"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "from q"], ["proof (chain)\npicking this:\n  prime q", "have \"1<q\""], ["proof (prove)\nusing this:\n  prime q\n\ngoal (1 subgoal):\n 1. 1 < q", "by (simp add: prime_nat_iff)"], ["proof (state)\nthis:\n  1 < q\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "ultimately"], ["proof (chain)\npicking this:\n  1 < p\n  1 < q", "have \"p<p*q\""], ["proof (prove)\nusing this:\n  1 < p\n  1 < q\n\ngoal (1 subgoal):\n 1. p < p * q", "by simp"], ["proof (state)\nthis:\n  p < p * q\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "then"], ["proof (chain)\npicking this:\n  p < p * q", "have \"1<p*q\""], ["proof (prove)\nusing this:\n  p < p * q\n\ngoal (1 subgoal):\n 1. 1 < p * q", "using s"], ["proof (prove)\nusing this:\n  p < p * q\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p * q", "by arith"], ["proof (state)\nthis:\n  1 < p * q\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "then"], ["proof (chain)\npicking this:\n  1 < p * q", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < p * q\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "using len_nat_to_bv_pos"], ["proof (prove)\nusing this:\n  1 < p * q\n  1 < ?a \\<Longrightarrow> 0 < length (nat_to_bv ?a)\n\ngoal (1 subgoal):\n 1. 0 < length (nat_to_bv (p * q))", "by simp"], ["proof (state)\nthis:\n  0 < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "ultimately"], ["proof (chain)\npicking this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n  (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) =\n  length (nat_to_bv (p * q)) - Suc 0\n  0 < length (nat_to_bv (p * q))", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  \\<le> roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n        (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8)\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 -\n  (8 - (length (nat_to_bv (p * q)) - Suc 0) mod 8) =\n  length (nat_to_bv (p * q)) - Suc 0\n  0 < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "by arith"], ["proof (state)\nthis:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_emsapss_smaller_pq: \"\\<lbrakk>prime p; prime q; emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []; (length (nat_to_bv (p * q)) - Suc 0) mod 8 ~= 0\\<rbrakk> \\<Longrightarrow>  length (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))) < length (nat_to_bv (p*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "assume a: \"emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\""], ["proof (state)\nthis:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "assume p: \"prime p\" and q: \"prime q\""], ["proof (state)\nthis:\n  prime p\n  prime q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "assume x: \"(length (nat_to_bv (p * q)) - Suc 0) mod 8 ~= 0\""], ["proof (state)\nthis:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "have b: \" emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)= emsapss_encode_help1 (sha1 m)\n    (length (nat_to_bv (p * q)) - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n    emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)", "proof (simp only: emsapss_encode_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (if 2 ^ 64 \\<le> length m \\<or>\n        2 ^ 32 * 160 < length (nat_to_bv (p * q)) - Suc 0\n     then []\n     else emsapss_encode_help1 (sha1 m)\n           (length (nat_to_bv (p * q)) - Suc 0)) =\n    emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)", "from a"], ["proof (chain)\npicking this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []", "show \"(if ((2^64 \\<le> length m) \\<or> (2^32 * 160 < (length (nat_to_bv (p*q)) - Suc 0)))\n      then []\n      else (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p*q))- Suc 0))) = (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p*q)) - Suc 0))\""], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (if 2 ^ 64 \\<le> length m \\<or>\n        2 ^ 32 * 160 < length (nat_to_bv (p * q)) - Suc 0\n     then []\n     else emsapss_encode_help1 (sha1 m)\n           (length (nat_to_bv (p * q)) - Suc 0)) =\n    emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)", "by (auto simp add: emsapss_encode_def)"], ["proof (state)\nthis:\n  (if 2 ^ 64 \\<le> length m \\<or>\n      2 ^ 32 * 160 < length (nat_to_bv (p * q)) - Suc 0\n   then []\n   else emsapss_encode_help1 (sha1 m)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "have c: \"length (remzero (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0))) < length (nat_to_bv (p*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "proof (simp only: emsapss_encode_help1_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n        then []\n        else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "from a and b"], ["proof (chain)\npicking this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)", "have d: \"(if ((length (nat_to_bv (p * q)) - Suc 0) < (length (sha1 m) + sLen + 16))\n      then []\n      else (emsapss_encode_help2 (generate_M' (sha1 m) salt)\n      (length (nat_to_bv (p * q)) - Suc 0))) = (emsapss_encode_help2 ((generate_M' (sha1 m)) salt) (length (nat_to_bv (p*q)) - Suc 0))\""], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n     then []\n     else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n           (length (nat_to_bv (p * q)) - Suc 0)) =\n    emsapss_encode_help2 (generate_M' (sha1 m) salt)\n     (length (nat_to_bv (p * q)) - Suc 0)", "by (auto simp add: emsapss_encode_def emsapss_encode_help1_def)"], ["proof (state)\nthis:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n        then []\n        else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "from d"], ["proof (chain)\npicking this:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)", "have len: \"length (sha1 m) + sLen + 16 <= (length (nat_to_bv (p*q))) - Suc 0\""], ["proof (prove)\nusing this:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0", "proof (cases \"length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     length (nat_to_bv (p * q)) - Suc 0\n     < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0\n 2. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "assume \"length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\""], ["proof (state)\nthis:\n  length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     length (nat_to_bv (p * q)) - Suc 0\n     < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0\n 2. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "then"], ["proof (chain)\npicking this:\n  length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16", "have len1: \"(if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16 then []\n      else emsapss_encode_help2 (generate_M' (sha1 m) salt) (length (nat_to_bv (p * q)) - Suc 0)) = []\""], ["proof (prove)\nusing this:\n  length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n\ngoal (1 subgoal):\n 1. (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n     then []\n     else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n           (length (nat_to_bv (p * q)) - Suc 0)) =\n    []", "by simp"], ["proof (state)\nthis:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     length (nat_to_bv (p * q)) - Suc 0\n     < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0\n 2. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "assume len2:  \"(if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16 then []\n      else emsapss_encode_help2 (generate_M' (sha1 m) salt) (length (nat_to_bv (p * q)) - Suc 0)) =\n     emsapss_encode_help2 (generate_M' (sha1 m) salt) (length (nat_to_bv (p * q)) - Suc 0)\""], ["proof (state)\nthis:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     length (nat_to_bv (p * q)) - Suc 0\n     < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0\n 2. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "from len1 and len2 and a and b"], ["proof (chain)\npicking this:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  []\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)", "show \"length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\""], ["proof (prove)\nusing this:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  []\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0", "by (auto simp add: emsapss_encode_def emsapss_encode_help1_def)"], ["proof (state)\nthis:\n  length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "assume \"\\<not> length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\""], ["proof (state)\nthis:\n  \\<not> length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if length (nat_to_bv (p * q)) - Suc 0\n                 < length (sha1 m) + sLen + 16\n              then []\n              else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n                    (length (nat_to_bv (p * q)) - Suc 0)) =\n             emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0);\n     \\<not> length (nat_to_bv (p * q)) - Suc 0\n            < length (sha1 m) + sLen + 16\\<rbrakk>\n    \\<Longrightarrow> length (sha1 m) + sLen + 16\n                      \\<le> length (nat_to_bv (p * q)) - Suc 0", "then"], ["proof (chain)\npicking this:\n  \\<not> length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16", "show \"length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\""], ["proof (prove)\nusing this:\n  \\<not> length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n\ngoal (1 subgoal):\n 1. length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0", "by simp"], ["proof (state)\nthis:\n  length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n        then []\n        else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "have e: \"length (remzero (emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0))) < length (nat_to_bv (p * q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "proof (simp only: emsapss_encode_help2_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help3 (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "show \"length\n          (remzero\n          (emsapss_encode_help3 (sha1 (generate_M' (sha1 m) salt))\n          (length (nat_to_bv (p * q)) - Suc 0)))\n          < length (nat_to_bv (p * q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help3 (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "proof (simp add: emsapss_encode_help3_def emsapss_encode_help4_def emsapss_encode_help5_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help6\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))))\n         (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "show \"length\n            (remzero\n            (emsapss_encode_help6\n            (generate_DB\n            (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n            (length (sha1 (generate_M' (sha1 m) salt)))))\n            (MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n            (generate_DB\n            (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n            (length (sha1 (generate_M' (sha1 m) salt)))))))\n            (sha1 (generate_M' (sha1 m) salt))\n            (length (nat_to_bv (p * q)) - Suc 0)))\n            < length (nat_to_bv (p * q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help6\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))))\n         (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "proof (simp only: emsapss_encode_help6_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))) =\n           []\n        then []\n        else emsapss_encode_help7\n              (bvxor\n                (generate_DB\n                  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                    (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                  (length\n                    (generate_DB\n                      (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                        (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "from a and b and d"], ["proof (chain)\npicking this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)", "have mgf: \"MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))) ~=\n              []\""], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. MGF (sha1 (generate_M' (sha1 m) salt))\n     (length\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n    []", "by (auto simp add: emsapss_encode_def emsapss_encode_help1_def emsapss_encode_help2_def emsapss_encode_help3_def emsapss_encode_help4_def emsapss_encode_help5_def emsapss_encode_help6_def)"], ["proof (state)\nthis:\n  MGF (sha1 (generate_M' (sha1 m) salt))\n   (length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))) =\n           []\n        then []\n        else emsapss_encode_help7\n              (bvxor\n                (generate_DB\n                  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                    (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                  (length\n                    (generate_DB\n                      (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                        (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "from a and b and d"], ["proof (chain)\npicking this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)", "have f: \"(if MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))) =\n              []\n              then []\n              else (emsapss_encode_help7\n              (bvxor\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))\n              (MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0))) = (emsapss_encode_help7\n              (bvxor\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))\n              (MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0))\""], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. (if MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))) =\n        []\n     then []\n     else emsapss_encode_help7\n           (bvxor\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt)))))\n             (MGF (sha1 (generate_M' (sha1 m) salt))\n               (length\n                 (generate_DB\n                   (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                     (length (sha1 (generate_M' (sha1 m) salt))))))))\n           (sha1 (generate_M' (sha1 m) salt))\n           (length (nat_to_bv (p * q)) - Suc 0)) =\n    emsapss_encode_help7\n     (bvxor\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt))))))))\n     (sha1 (generate_M' (sha1 m) salt)) (length (nat_to_bv (p * q)) - Suc 0)", "by (auto simp add: emsapss_encode_def emsapss_encode_help1_def emsapss_encode_help2_def\n                emsapss_encode_help3_def emsapss_encode_help4_def emsapss_encode_help5_def\n                emsapss_encode_help6_def)"], ["proof (state)\nthis:\n  (if MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))) =\n      []\n   then []\n   else emsapss_encode_help7\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help7\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))))\n   (sha1 (generate_M' (sha1 m) salt)) (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))) =\n           []\n        then []\n        else emsapss_encode_help7\n              (bvxor\n                (generate_DB\n                  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                    (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                  (length\n                    (generate_DB\n                      (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                        (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "have \"length (remzero (emsapss_encode_help7\n              (bvxor\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))\n              (MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt)) (length (nat_to_bv (p * q)) - Suc 0))) < length (nat_to_bv (p * q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (emsapss_encode_help7\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "proof (simp add: emsapss_encode_help7_def emsapss_encode_help8_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "from p and q and x"], ["proof (chain)\npicking this:\n  prime p\n  prime q\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0", "show \" length\n                (remzero\n                (maskedDB_zero\n                (bvxor\n                (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                (length\n                (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                (length (sha1 (generate_M' (sha1 m) salt))))))))\n                (length (nat_to_bv (p * q)) - Suc 0) @\n                sha1 (generate_M' (sha1 m) salt) @ BC))\n                < length (nat_to_bv (p * q))\""], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "using \"length_helper\" and len and mgf"], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n  \\<lbrakk>prime ?p; prime ?q;\n   (length (nat_to_bv (?p * ?q)) - Suc 0) mod 8 \\<noteq> 0;\n   MGF (sha1 (generate_M' (sha1 ?m) salt))\n    (length\n      (generate_DB\n        (generate_PS (length (nat_to_bv (?p * ?q)) - Suc 0)\n          (length (sha1 (generate_M' (sha1 ?m) salt)))))) \\<noteq>\n   [];\n   length (sha1 ?M) + sLen + 16\n   \\<le> length (nat_to_bv (?p * ?q)) - Suc 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remzero\n                       (maskedDB_zero\n                         (bvxor\n                           (generate_DB\n                             (generate_PS\n                               (length (nat_to_bv (?p * ?q)) - Suc 0)\n                               (length\n                                 (sha1 (generate_M' (sha1 ?m) salt)))))\n                           (MGF (sha1 (generate_M' (sha1 ?m) salt))\n                             (length\n                               (generate_DB\n                                 (generate_PS\n                                   (length (nat_to_bv (?p * ?q)) - Suc 0)\n                                   (length\n                                     (sha1\n (generate_M' (sha1 ?m) salt))))))))\n                         (length (nat_to_bv (?p * ?q)) - Suc 0) @\n                        sha1 (generate_M' (sha1 ?m) salt) @ BC))\n                    < length (nat_to_bv (?p * ?q))\n  length (sha1 m) + sLen + 16 \\<le> length (nat_to_bv (p * q)) - Suc 0\n  MGF (sha1 (generate_M' (sha1 m) salt))\n   (length\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (maskedDB_zero\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (length (nat_to_bv (p * q)) - Suc 0) @\n        sha1 (generate_M' (sha1 m) salt) @ BC))\n    < length (nat_to_bv (p * q))", "by simp"], ["proof (state)\nthis:\n  length\n   (remzero\n     (maskedDB_zero\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (length (nat_to_bv (p * q)) - Suc 0) @\n      sha1 (generate_M' (sha1 m) salt) @ BC))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (remzero\n     (emsapss_encode_help7\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (sha1 (generate_M' (sha1 m) salt))\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))) =\n           []\n        then []\n        else emsapss_encode_help7\n              (bvxor\n                (generate_DB\n                  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                    (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                  (length\n                    (generate_DB\n                      (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                        (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "then"], ["proof (chain)\npicking this:\n  length\n   (remzero\n     (emsapss_encode_help7\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (sha1 (generate_M' (sha1 m) salt))\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))", "show \"length\n              (remzero\n              (if MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))) =\n              []\n              then []\n              else emsapss_encode_help7\n              (bvxor\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt)))))\n              (MGF (sha1 (generate_M' (sha1 m) salt))\n              (length\n              (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n              (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n              < length (nat_to_bv (p * q))\""], ["proof (prove)\nusing this:\n  length\n   (remzero\n     (emsapss_encode_help7\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (sha1 (generate_M' (sha1 m) salt))\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))) =\n           []\n        then []\n        else emsapss_encode_help7\n              (bvxor\n                (generate_DB\n                  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                    (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                  (length\n                    (generate_DB\n                      (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                        (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "using f"], ["proof (prove)\nusing this:\n  length\n   (remzero\n     (emsapss_encode_help7\n       (bvxor\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))\n         (MGF (sha1 (generate_M' (sha1 m) salt))\n           (length\n             (generate_DB\n               (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                 (length (sha1 (generate_M' (sha1 m) salt))))))))\n       (sha1 (generate_M' (sha1 m) salt))\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n  (if MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt)))))) =\n      []\n   then []\n   else emsapss_encode_help7\n         (bvxor\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))\n           (MGF (sha1 (generate_M' (sha1 m) salt))\n             (length\n               (generate_DB\n                 (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                   (length (sha1 (generate_M' (sha1 m) salt))))))))\n         (sha1 (generate_M' (sha1 m) salt))\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help7\n   (bvxor\n     (generate_DB\n       (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n         (length (sha1 (generate_M' (sha1 m) salt)))))\n     (MGF (sha1 (generate_M' (sha1 m) salt))\n       (length\n         (generate_DB\n           (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n             (length (sha1 (generate_M' (sha1 m) salt))))))))\n   (sha1 (generate_M' (sha1 m) salt)) (length (nat_to_bv (p * q)) - Suc 0)\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if MGF (sha1 (generate_M' (sha1 m) salt))\n            (length\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))) =\n           []\n        then []\n        else emsapss_encode_help7\n              (bvxor\n                (generate_DB\n                  (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                    (length (sha1 (generate_M' (sha1 m) salt)))))\n                (MGF (sha1 (generate_M' (sha1 m) salt))\n                  (length\n                    (generate_DB\n                      (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                        (length (sha1 (generate_M' (sha1 m) salt))))))))\n              (sha1 (generate_M' (sha1 m) salt))\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "by simp"], ["proof (state)\nthis:\n  length\n   (remzero\n     (if MGF (sha1 (generate_M' (sha1 m) salt))\n          (length\n            (generate_DB\n              (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                (length (sha1 (generate_M' (sha1 m) salt)))))) =\n         []\n      then []\n      else emsapss_encode_help7\n            (bvxor\n              (generate_DB\n                (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                  (length (sha1 (generate_M' (sha1 m) salt)))))\n              (MGF (sha1 (generate_M' (sha1 m) salt))\n                (length\n                  (generate_DB\n                    (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n                      (length (sha1 (generate_M' (sha1 m) salt))))))))\n            (sha1 (generate_M' (sha1 m) salt))\n            (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (remzero\n     (emsapss_encode_help6\n       (generate_DB\n         (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n           (length (sha1 (generate_M' (sha1 m) salt)))))\n       (MGF (sha1 (generate_M' (sha1 m) salt))\n         (length\n           (generate_DB\n             (generate_PS (length (nat_to_bv (p * q)) - Suc 0)\n               (length (sha1 (generate_M' (sha1 m) salt)))))))\n       (sha1 (generate_M' (sha1 m) salt))\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (remzero\n     (emsapss_encode_help3 (sha1 (generate_M' (sha1 m) salt))\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (remzero\n     (emsapss_encode_help2 (generate_M' (sha1 m) salt)\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n        then []\n        else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "from d and e"], ["proof (chain)\npicking this:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n  length\n   (remzero\n     (emsapss_encode_help2 (generate_M' (sha1 m) salt)\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))", "show \"length\n      (remzero\n      (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n      then []\n      else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n      (length (nat_to_bv (p * q)) - Suc 0)))\n      < length (nat_to_bv (p * q))\""], ["proof (prove)\nusing this:\n  (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n   then []\n   else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n         (length (nat_to_bv (p * q)) - Suc 0)) =\n  emsapss_encode_help2 (generate_M' (sha1 m) salt)\n   (length (nat_to_bv (p * q)) - Suc 0)\n  length\n   (remzero\n     (emsapss_encode_help2 (generate_M' (sha1 m) salt)\n       (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length\n     (remzero\n       (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n        then []\n        else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n              (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "by simp"], ["proof (state)\nthis:\n  length\n   (remzero\n     (if length (nat_to_bv (p * q)) - Suc 0 < length (sha1 m) + sLen + 16\n      then []\n      else emsapss_encode_help2 (generate_M' (sha1 m) salt)\n            (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length\n   (remzero\n     (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (remzero\n                         (emsapss_encode m\n                           (length (nat_to_bv (p * q)) - Suc 0)))\n                      < length (nat_to_bv (p * q))", "from b and c"], ["proof (chain)\npicking this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n  length\n   (remzero\n     (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))", "show ?thesis"], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) =\n  emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)\n  length\n   (remzero\n     (emsapss_encode_help1 (sha1 m) (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. length (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n    < length (nat_to_bv (p * q))", "by simp"], ["proof (state)\nthis:\n  length (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n  < length (nat_to_bv (p * q))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat_emsapss_smaller_pq: assumes a: \"prime p\" and b: \"prime q\" and pneq: \"p ~= q\" and c: \"emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\" shows \"bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p*q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "from a and b and c"], ["proof (chain)\npicking this:\n  prime p\n  prime q\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "proof (cases \"8 dvd ((length (nat_to_bv (p * q))) - Suc 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q\n 2. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "assume d: \"8 dvd ((length (nat_to_bv (p * q))) - Suc 0)\""], ["proof (state)\nthis:\n  8 dvd length (nat_to_bv (p * q)) - Suc 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q\n 2. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "then"], ["proof (chain)\npicking this:\n  8 dvd length (nat_to_bv (p * q)) - Suc 0", "have \"2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p*q\""], ["proof (prove)\nusing this:\n  8 dvd length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "from d"], ["proof (chain)\npicking this:\n  8 dvd length (nat_to_bv (p * q)) - Suc 0", "have e: \"roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 = length (nat_to_bv (p * q)) - Suc 0\""], ["proof (prove)\nusing this:\n  8 dvd length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 =\n    length (nat_to_bv (p * q)) - Suc 0", "using rnddvd"], ["proof (prove)\nusing this:\n  8 dvd length (nat_to_bv (p * q)) - Suc 0\n  ?b dvd ?a \\<Longrightarrow> roundup ?a ?b * ?b = ?a\n\ngoal (1 subgoal):\n 1. roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 =\n    length (nat_to_bv (p * q)) - Suc 0", "by simp"], ["proof (state)\nthis:\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 =\n  length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "have \"p*q = bv_to_nat (nat_to_bv (p*q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * q = bv_to_nat (nat_to_bv (p * q))", "by simp"], ["proof (state)\nthis:\n  p * q = bv_to_nat (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "then"], ["proof (chain)\npicking this:\n  p * q = bv_to_nat (nat_to_bv (p * q))", "have \"2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p*q\""], ["proof (prove)\nusing this:\n  p * q = bv_to_nat (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p * q = bv_to_nat (nat_to_bv (p * q)) \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "have \"0<p*q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < p * q", "have \"0<p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < p", "using a"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. 0 < p", "by (simp add: prime_nat_iff)"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. 0 < p * q", "moreover"], ["proof (state)\nthis:\n  0 < p\n\ngoal (1 subgoal):\n 1. 0 < p * q", "have \"0<q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < q", "using b"], ["proof (prove)\nusing this:\n  prime q\n\ngoal (1 subgoal):\n 1. 0 < q", "by (simp add: prime_nat_iff)"], ["proof (state)\nthis:\n  0 < q\n\ngoal (1 subgoal):\n 1. 0 < p * q", "ultimately"], ["proof (chain)\npicking this:\n  0 < p\n  0 < q", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < p\n  0 < q\n\ngoal (1 subgoal):\n 1. 0 < p * q", "by simp"], ["proof (state)\nthis:\n  0 < p * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < p * q\n\ngoal (1 subgoal):\n 1. p * q = bv_to_nat (nat_to_bv (p * q)) \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "moreover"], ["proof (state)\nthis:\n  0 < p * q\n\ngoal (1 subgoal):\n 1. p * q = bv_to_nat (nat_to_bv (p * q)) \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "have \"2^(length (nat_to_bv (p*q)) - Suc 0) ~= p*q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "proof (cases \"2^(length (nat_to_bv (p*q)) - Suc 0) = p*q\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n 2. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n    p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "assume \"2^(length (nat_to_bv (p*q)) - Suc 0) = p*q\""], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q\n\ngoal (2 subgoals):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n 2. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n    p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "then"], ["proof (chain)\npicking this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q", "have \"p=q\""], ["proof (prove)\nusing this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q\n\ngoal (1 subgoal):\n 1. p = q", "using a and b and prime_equal"], ["proof (prove)\nusing this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q\n  prime p\n  prime q\n  \\<lbrakk>prime ?p; prime ?q; 2 ^ ?x = ?p * ?q\\<rbrakk>\n  \\<Longrightarrow> ?p = ?q\n\ngoal (1 subgoal):\n 1. p = q", "by simp"], ["proof (state)\nthis:\n  p = q\n\ngoal (2 subgoals):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) = p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n 2. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n    p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "then"], ["proof (chain)\npicking this:\n  p = q", "show ?thesis"], ["proof (prove)\nusing this:\n  p = q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "using pneq"], ["proof (prove)\nusing this:\n  p = q\n  p \\<noteq> q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n    p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n    p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "assume \"2^(length (nat_to_bv (p*q)) - Suc 0) ~= p*q\""], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n    p * q \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "then"], ["proof (chain)\npicking this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n\ngoal (1 subgoal):\n 1. p * q = bv_to_nat (nat_to_bv (p * q)) \\<Longrightarrow>\n    2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "ultimately"], ["proof (chain)\npicking this:\n  0 < p * q\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < p * q\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "using len_lower_bound[of \"p*q\"]"], ["proof (prove)\nusing this:\n  0 < p * q\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> p * q\n  0 < p * q \\<Longrightarrow>\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) \\<le> p * q\n\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "by (simp)"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q\n\ngoal (1 subgoal):\n 1. 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "then"], ["proof (chain)\npicking this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q\n\ngoal (1 subgoal):\n 1. 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "using e"], ["proof (prove)\nusing this:\n  2 ^ (length (nat_to_bv (p * q)) - Suc 0) < p * q\n  roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8 =\n  length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q", "by simp"], ["proof (state)\nthis:\n  2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q\n 2. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "moreover"], ["proof (state)\nthis:\n  2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q\n 2. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "from c"], ["proof (chain)\npicking this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []", "have \"bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0)8 * 8 )\""], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8)", "using bv_to_nat_emsapss_encode_le [of m \"(length (nat_to_bv (p * q)) - Suc 0)\"]"], ["proof (prove)\nusing this:\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n  [] \\<Longrightarrow>\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n  < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8)\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8)", "by auto"], ["proof (state)\nthis:\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n  < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q\n 2. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "ultimately"], ["proof (chain)\npicking this:\n  2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n  < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8) < p * q\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n  < 2 ^ (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8)\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "by simp"], ["proof (state)\nthis:\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p * q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "assume y: \"~(8 dvd (length (nat_to_bv (p*q)) - Suc 0))\""], ["proof (state)\nthis:\n  \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0))\n                      < p * q", "then"], ["proof (chain)\npicking this:\n  \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "from y"], ["proof (chain)\npicking this:\n  \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0", "have x: \"~((length (nat_to_bv (p * q)) - Suc 0) mod 8 = 0)\""], ["proof (prove)\nusing this:\n  \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0\n\ngoal (1 subgoal):\n 1. (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0", "by (simp add: dvd_eq_mod_eq_0)"], ["proof (state)\nthis:\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "from remzeroeq"], ["proof (chain)\npicking this:\n  bv_to_nat ?a = bv_to_nat (remzero ?a)", "have d: \"bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) = bv_to_nat (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\""], ["proof (prove)\nusing this:\n  bv_to_nat ?a = bv_to_nat (remzero ?a)\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n    bv_to_nat\n     (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))", "by simp"], ["proof (state)\nthis:\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n  bv_to_nat\n   (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n\ngoal (1 subgoal):\n 1. \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "from a and b and c and x and length_emsapss_smaller_pq[of p q m]"], ["proof (chain)\npicking this:\n  prime p\n  prime q\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n  \\<lbrakk>prime p; prime q;\n   emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n   (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remzero\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0)))\n                    < length (nat_to_bv (p * q))", "have \"bv_to_nat (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))) < bv_to_nat (nat_to_bv (p*q))\""], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n  \\<lbrakk>prime p; prime q;\n   emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n   (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remzero\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0)))\n                    < length (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. bv_to_nat\n     (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n    < bv_to_nat (nat_to_bv (p * q))", "using length_lower[of \"remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\" \"nat_to_bv (p * q)\"] and prime_hd_non_zero[of p q]"], ["proof (prove)\nusing this:\n  prime p\n  prime q\n  emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> []\n  (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\n  \\<lbrakk>prime p; prime q;\n   emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n   (length (nat_to_bv (p * q)) - Suc 0) mod 8 \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> length\n                     (remzero\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0)))\n                    < length (nat_to_bv (p * q))\n  \\<lbrakk>length\n            (remzero\n              (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n           < length (nat_to_bv (p * q));\n   hd (nat_to_bv (p * q)) \\<noteq> \\<zero>\\<rbrakk>\n  \\<Longrightarrow> bv_to_nat\n                     (remzero\n                       (emsapss_encode m\n                         (length (nat_to_bv (p * q)) - Suc 0)))\n                    < bv_to_nat (nat_to_bv (p * q))\n  \\<lbrakk>prime p; prime q\\<rbrakk>\n  \\<Longrightarrow> hd (nat_to_bv (p * q)) \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. bv_to_nat\n     (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n    < bv_to_nat (nat_to_bv (p * q))", "by (auto)"], ["proof (state)\nthis:\n  bv_to_nat\n   (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n  < bv_to_nat (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. \\<not> 8 dvd length (nat_to_bv (p * q)) - Suc 0 \\<Longrightarrow>\n    bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "then"], ["proof (chain)\npicking this:\n  bv_to_nat\n   (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n  < bv_to_nat (nat_to_bv (p * q))", "show \"bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p * q\""], ["proof (prove)\nusing this:\n  bv_to_nat\n   (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n  < bv_to_nat (nat_to_bv (p * q))\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "using d and bv_nat_bv"], ["proof (prove)\nusing this:\n  bv_to_nat\n   (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n  < bv_to_nat (nat_to_bv (p * q))\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n  bv_to_nat\n   (remzero (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n  bv_to_nat (nat_to_bv ?n) = ?n\n\ngoal (1 subgoal):\n 1. bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n    < p * q", "by simp"], ["proof (state)\nthis:\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p * q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) < p * q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsa_pss_verify: \"\\<lbrakk> prime p; prime q; p \\<noteq> q; n = p*q; e*d mod ((pred p)*(pred q)) = 1; rsapss_sign m e n \\<noteq> []; s = rsapss_sign m e n \\<rbrakk> \\<Longrightarrow> rsapss_verify m s d n = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = 1; rsapss_sign m e n \\<noteq> [];\n     s = rsapss_sign m e n\\<rbrakk>\n    \\<Longrightarrow> rsapss_verify m s d n = True", "apply (simp only: rsapss_sign_def rsapss_verify_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = 1;\n     (if emsapss_encode m (length (nat_to_bv (p * q)) - 1) = [] then []\n      else rsapss_sign_help1\n            (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - 1)))\n            e (p * q)) \\<noteq>\n     [];\n     s =\n     (if emsapss_encode m (length (nat_to_bv (p * q)) - 1) = [] then []\n      else rsapss_sign_help1\n            (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - 1)))\n            e (p * q))\\<rbrakk>\n    \\<Longrightarrow> (if length\n                           (if emsapss_encode m\n                                (length (nat_to_bv (p * q)) - 1) =\n                               []\n                            then []\n                            else rsapss_sign_help1\n                                  (bv_to_nat\n                                    (emsapss_encode m\n(length (nat_to_bv (p * q)) - 1)))\n                                  e (p * q)) \\<noteq>\n                          length (nat_to_bv (p * q))\n                       then False\n                       else let em = nat_to_bv_length\n(rsa_crypt\n  (bv_to_nat\n    (if emsapss_encode m (length (nat_to_bv (p * q)) - 1) = [] then []\n     else rsapss_sign_help1\n           (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - 1))) e\n           (p * q)))\n  d (p * q))\n(roundup (length (nat_to_bv (p * q)) - 1) 8 * 8)\n                            in emsapss_decode m em\n                                (length (nat_to_bv (p * q)) - 1)) =\n                      True", "apply (simp only: rsapss_sign_help1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = 1;\n     (if emsapss_encode m (length (nat_to_bv (p * q)) - 1) = [] then []\n      else nat_to_bv_length\n            (rsa_crypt\n              (bv_to_nat\n                (emsapss_encode m (length (nat_to_bv (p * q)) - 1)))\n              e (p * q))\n            (length (nat_to_bv (p * q)))) \\<noteq>\n     [];\n     s =\n     (if emsapss_encode m (length (nat_to_bv (p * q)) - 1) = [] then []\n      else nat_to_bv_length\n            (rsa_crypt\n              (bv_to_nat\n                (emsapss_encode m (length (nat_to_bv (p * q)) - 1)))\n              e (p * q))\n            (length (nat_to_bv (p * q))))\\<rbrakk>\n    \\<Longrightarrow> (if length\n                           (if emsapss_encode m\n                                (length (nat_to_bv (p * q)) - 1) =\n                               []\n                            then []\n                            else nat_to_bv_length\n                                  (rsa_crypt\n                                    (bv_to_nat\n(emsapss_encode m (length (nat_to_bv (p * q)) - 1)))\n                                    e (p * q))\n                                  (length (nat_to_bv (p * q)))) \\<noteq>\n                          length (nat_to_bv (p * q))\n                       then False\n                       else let em = nat_to_bv_length\n(rsa_crypt\n  (bv_to_nat\n    (if emsapss_encode m (length (nat_to_bv (p * q)) - 1) = [] then []\n     else nat_to_bv_length\n           (rsa_crypt\n             (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - 1)))\n             e (p * q))\n           (length (nat_to_bv (p * q)))))\n  d (p * q))\n(roundup (length (nat_to_bv (p * q)) - 1) 8 * 8)\n                            in emsapss_decode m em\n                                (length (nat_to_bv (p * q)) - 1)) =\n                      True", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n     []\\<rbrakk>\n    \\<Longrightarrow> length\n                       (nat_to_bv_length\n                         (rsa_crypt\n                           (bv_to_nat\n                             (emsapss_encode m\n                               (length (nat_to_bv (p * q)) - Suc 0)))\n                           e (p * q))\n                         (length (nat_to_bv (p * q)))) =\n                      length (nat_to_bv (p * q))\n 2. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q))\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (rsa_crypt\n                           (bv_to_nat\n                             (nat_to_bv_length\n                               (rsa_crypt\n                                 (bv_to_nat\n                                   (emsapss_encode m\n                                     (length (nat_to_bv (p * q)) - Suc 0)))\n                                 e (p * q))\n                               (length (nat_to_bv (p * q)))))\n                           d (p * q))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (simp add: length_nat_to_bv_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q))\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (rsa_crypt\n                           (bv_to_nat\n                             (nat_to_bv_length\n                               (rsa_crypt\n                                 (bv_to_nat\n                                   (emsapss_encode m\n                                     (length (nat_to_bv (p * q)) - Suc 0)))\n                                 e (p * q))\n                               (length (nat_to_bv (p * q)))))\n                           d (p * q))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (simp add: bv_to_nat_nat_to_bv_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q))\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (rsa_crypt\n                           (rsa_crypt\n                             (bv_to_nat\n                               (emsapss_encode m\n                                 (length (nat_to_bv (p * q)) - Suc 0)))\n                             e (p * q))\n                           d (p * q))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (insert length_emsapss_encode [of m \"(length (nat_to_bv (p * q)) - Suc 0)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n     [] \\<Longrightarrow>\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (rsa_crypt\n                           (rsa_crypt\n                             (bv_to_nat\n                               (emsapss_encode m\n                                 (length (nat_to_bv (p * q)) - Suc 0)))\n                             e (p * q))\n                           d (p * q))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (insert bv_to_nat_emsapss_smaller_pq [of p q m])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n     [] \\<Longrightarrow>\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8;\n     \\<lbrakk>prime p; prime q; p \\<noteq> q;\n      emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n      []\\<rbrakk>\n     \\<Longrightarrow> bv_to_nat\n                        (emsapss_encode m\n                          (length (nat_to_bv (p * q)) - Suc 0))\n                       < p * q\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (rsa_crypt\n                           (rsa_crypt\n                             (bv_to_nat\n                               (emsapss_encode m\n                                 (length (nat_to_bv (p * q)) - Suc 0)))\n                             e (p * q))\n                           d (p * q))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (simp add: cryptinverts)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q));\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8;\n     bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n     < p * q\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (bv_to_nat\n                           (emsapss_encode m\n                             (length (nat_to_bv (p * q)) - Suc 0)))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (insert length_emsapss_encode [of m \"(length (nat_to_bv (p * q)) - Suc 0)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q));\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8;\n     bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n     < p * q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n     [] \\<Longrightarrow>\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (bv_to_nat\n                           (emsapss_encode m\n                             (length (nat_to_bv (p * q)) - Suc 0)))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (insert nat_to_bv_length_bv_to_nat [of \"emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)\" \"roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>prime p; prime q; p \\<noteq> q; n = p * q;\n     e * d mod (pred p * pred q) = Suc 0;\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q))) \\<noteq>\n     [];\n     s =\n     nat_to_bv_length\n      (rsa_crypt\n        (bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n        e (p * q))\n      (length (nat_to_bv (p * q)));\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq> [];\n     length\n      (nat_to_bv_length\n        (rsa_crypt\n          (bv_to_nat\n            (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)))\n          e (p * q))\n        (length (nat_to_bv (p * q)))) =\n     length (nat_to_bv (p * q));\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8;\n     bv_to_nat (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0))\n     < p * q;\n     emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n     [] \\<Longrightarrow>\n     length (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n     roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8;\n     \\<lbrakk>length\n               (emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0)) =\n              roundup (length (nat_to_bv (p * q)) - Suc 0) 8 * 8;\n      emsapss_encode m (length (nat_to_bv (p * q)) - Suc 0) \\<noteq>\n      []\\<rbrakk>\n     \\<Longrightarrow> nat_to_bv_length\n                        (bv_to_nat\n                          (emsapss_encode m\n                            (length (nat_to_bv (p * q)) - Suc 0)))\n                        (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                         8) =\n                       emsapss_encode m\n                        (length (nat_to_bv (p * q)) - Suc 0)\\<rbrakk>\n    \\<Longrightarrow> emsapss_decode m\n                       (nat_to_bv_length\n                         (bv_to_nat\n                           (emsapss_encode m\n                             (length (nat_to_bv (p * q)) - Suc 0)))\n                         (roundup (length (nat_to_bv (p * q)) - Suc 0) 8 *\n                          8))\n                       (length (nat_to_bv (p * q)) - Suc 0)", "apply (simp add: verify)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}