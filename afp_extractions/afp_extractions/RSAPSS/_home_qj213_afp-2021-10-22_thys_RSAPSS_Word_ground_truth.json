{"file_name": "/home/qj213/afp-2021-10-22/thys/RSAPSS/Word.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/RSAPSS", "problem_names": ["lemma max_le [intro!]: \"[| x \\<le> z; y \\<le> z |] ==> max x y \\<le> z\"", "lemma max_mono:\n  fixes x :: \"'a::linorder\"\n  assumes mf: \"mono f\"\n  shows       \"max (f x) (f y) \\<le> f (max x y)\"", "lemma int_nat_two_exp: \"2 ^ k = int (2 ^ k)\"", "lemma bitnot_bitnot [simp]: \"(bitnot (bitnot b)) = b\"", "lemma bitand_cancel [simp]: \"(b \\<and>\\<^sub>b b) = b\"", "lemma bitor_cancel [simp]: \"(b \\<or>\\<^sub>b b) = b\"", "lemma bitxor_cancel [simp]: \"(b \\<oplus>\\<^sub>b b) = \\<zero>\"", "lemma bit_list_cases:\n  assumes empty: \"w = [] ==> P w\"\n  and     zero:  \"!!bs. w = \\<zero> # bs ==> P w\"\n  and     one:   \"!!bs. w = \\<one> # bs ==> P w\"\n  shows   \"P w\"", "lemma bit_list_induct:\n  assumes empty: \"P []\"\n  and     zero:  \"!!bs. P bs ==> P (\\<zero>#bs)\"\n  and     one:   \"!!bs. P bs ==> P (\\<one>#bs)\"\n  shows   \"P w\"", "lemma bv_length_extend [simp]: \"length w \\<le> i ==> length (bv_extend i b w) = i\"", "lemma bv_not_Nil [simp]: \"bv_not [] = []\"", "lemma bv_not_Cons [simp]: \"bv_not (b#bs) = (bitnot b) # bv_not bs\"", "lemma bv_not_bv_not [simp]: \"bv_not (bv_not w) = w\"", "lemma bv_msb_Nil [simp]: \"bv_msb [] = \\<zero>\"", "lemma bv_msb_Cons [simp]: \"bv_msb (b#bs) = b\"", "lemma bv_msb_bv_not [simp]: \"0 < length w ==> bv_msb (bv_not w) = (bitnot (bv_msb w))\"", "lemma bv_msb_one_length [simp,intro]: \"bv_msb w = \\<one> ==> 0 < length w\"", "lemma length_bv_not [simp]: \"length (bv_not w) = length w\"", "lemma bv_to_nat_Nil [simp]: \"bv_to_nat [] = 0\"", "lemma bv_to_nat_helper [simp]: \"bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs\"", "lemma bv_to_nat0 [simp]: \"bv_to_nat (\\<zero>#bs) = bv_to_nat bs\"", "lemma bv_to_nat1 [simp]: \"bv_to_nat (\\<one>#bs) = 2 ^ length bs + bv_to_nat bs\"", "lemma bv_to_nat_upper_range: \"bv_to_nat w < 2 ^ length w\"", "lemma bv_extend_longer [simp]:\n  assumes wn: \"n \\<le> length w\"\n  shows       \"bv_extend n b w = w\"", "lemma bv_extend_shorter [simp]:\n  assumes wn: \"length w < n\"\n  shows       \"bv_extend n b w = bv_extend n b (b#w)\"", "lemma rem_initial_length: \"length (rem_initial b w) \\<le> length w\"", "lemma rem_initial_equal:\n  assumes p: \"length (rem_initial b w) = length w\"\n  shows      \"rem_initial b w = w\"", "lemma bv_extend_rem_initial: \"bv_extend (length w) b (rem_initial b w) = w\"", "lemma rem_initial_append1:\n  assumes \"rem_initial b xs ~= []\"\n  shows   \"rem_initial b (xs @ ys) = rem_initial b xs @ ys\"", "lemma rem_initial_append2:\n  assumes \"rem_initial b xs = []\"\n  shows   \"rem_initial b (xs @ ys) = rem_initial b ys\"", "lemma norm_unsigned_Nil [simp]: \"norm_unsigned [] = []\"", "lemma norm_unsigned_Cons0 [simp]: \"norm_unsigned (\\<zero>#bs) = norm_unsigned bs\"", "lemma norm_unsigned_Cons1 [simp]: \"norm_unsigned (\\<one>#bs) = \\<one>#bs\"", "lemma norm_unsigned_idem [simp]: \"norm_unsigned (norm_unsigned w) = norm_unsigned w\"", "lemma nat_to_bv0 [simp]: \"nat_to_bv 0 = []\"", "lemmas [simp del] = nat_to_bv_helper.simps", "lemma n_div_2_cases:\n  assumes zero: \"(n::nat) = 0 ==> R\"\n  and     div : \"[| n div 2 < n ; 0 < n |] ==> R\"\n  shows         \"R\"", "lemma int_wf_ge_induct:\n  assumes ind :  \"!!i::int. (!!j. [| k \\<le> j ; j < i |] ==> P j) ==> P i\"\n  shows          \"P i\"", "lemma unfold_nat_to_bv_helper:\n  \"nat_to_bv_helper b l = nat_to_bv_helper b [] @ l\"", "lemma nat_to_bv_non0 [simp]: \"n\\<noteq>0 ==> nat_to_bv n = nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]\"", "lemma bv_to_nat_dist_append:\n  \"bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2\"", "lemma bv_nat_bv [simp]: \"bv_to_nat (nat_to_bv n) = n\"", "lemma bv_to_nat_type [simp]: \"bv_to_nat (norm_unsigned w) = bv_to_nat w\"", "lemma length_norm_unsigned_le [simp]: \"length (norm_unsigned w) \\<le> length w\"", "lemma bv_to_nat_rew_msb: \"bv_msb w = \\<one> ==> bv_to_nat w = 2 ^ (length w - 1) + bv_to_nat (tl w)\"", "lemma norm_unsigned_result: \"norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>\"", "lemma norm_empty_bv_to_nat_zero:\n  assumes nw: \"norm_unsigned w = []\"\n  shows       \"bv_to_nat w = 0\"", "lemma bv_to_nat_lower_limit:\n  assumes w0: \"0 < bv_to_nat w\"\n  shows \"2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w\"", "lemmas [simp del] = nat_to_bv_non0", "lemma norm_unsigned_length [intro!]: \"length (norm_unsigned w) \\<le> length w\"", "lemma norm_unsigned_equal:\n  \"length (norm_unsigned w) = length w ==> norm_unsigned w = w\"", "lemma bv_extend_norm_unsigned: \"bv_extend (length w) \\<zero> (norm_unsigned w) = w\"", "lemma norm_unsigned_append1 [simp]:\n  \"norm_unsigned xs \\<noteq> [] ==> norm_unsigned (xs @ ys) = norm_unsigned xs @ ys\"", "lemma norm_unsigned_append2 [simp]:\n  \"norm_unsigned xs = [] ==> norm_unsigned (xs @ ys) = norm_unsigned ys\"", "lemma bv_to_nat_zero_imp_empty:\n  \"bv_to_nat w = 0 \\<Longrightarrow> norm_unsigned w = []\"", "lemma bv_to_nat_nzero_imp_nempty:\n  \"bv_to_nat w \\<noteq> 0 \\<Longrightarrow> norm_unsigned w \\<noteq> []\"", "lemma nat_helper1:\n  assumes ass: \"nat_to_bv (bv_to_nat w) = norm_unsigned w\"\n  shows        \"nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\"", "lemma nat_helper2: \"nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs\"", "lemma nat_bv_nat [simp]: \"nat_to_bv (bv_to_nat w) = norm_unsigned w\"", "lemma bv_to_nat_qinj:\n  assumes one: \"bv_to_nat xs = bv_to_nat ys\"\n  and     len: \"length xs = length ys\"\n  shows        \"xs = ys\"", "lemma norm_unsigned_nat_to_bv [simp]:\n  \"norm_unsigned (nat_to_bv n) = nat_to_bv n\"", "lemma length_nat_to_bv_upper_limit:\n  assumes nk: \"n \\<le> 2 ^ k - 1\"\n  shows       \"length (nat_to_bv n) \\<le> k\"", "lemma length_nat_to_bv_lower_limit:\n  assumes nk: \"2 ^ k \\<le> n\"\n  shows       \"k < length (nat_to_bv n)\"", "lemma bv_add_type1 [simp]: \"bv_add (norm_unsigned w1) w2 = bv_add w1 w2\"", "lemma bv_add_type2 [simp]: \"bv_add w1 (norm_unsigned w2) = bv_add w1 w2\"", "lemma bv_add_returntype [simp]: \"norm_unsigned (bv_add w1 w2) = bv_add w1 w2\"", "lemma bv_add_length: \"length (bv_add w1 w2) \\<le> Suc (max (length w1) (length w2))\"", "lemma bv_mult_type1 [simp]: \"bv_mult (norm_unsigned w1) w2 = bv_mult w1 w2\"", "lemma bv_mult_type2 [simp]: \"bv_mult w1 (norm_unsigned w2) = bv_mult w1 w2\"", "lemma bv_mult_returntype [simp]: \"norm_unsigned (bv_mult w1 w2) = bv_mult w1 w2\"", "lemma bv_mult_length: \"length (bv_mult w1 w2) \\<le> length w1 + length w2\"", "lemma norm_signed0 [simp]: \"norm_signed [\\<zero>] = []\"", "lemma norm_signed1 [simp]: \"norm_signed [\\<one>] = [\\<one>]\"", "lemma norm_signed01 [simp]: \"norm_signed (\\<zero>#\\<one>#xs) = \\<zero>#\\<one>#xs\"", "lemma norm_signed00 [simp]: \"norm_signed (\\<zero>#\\<zero>#xs) = norm_signed (\\<zero>#xs)\"", "lemma norm_signed10 [simp]: \"norm_signed (\\<one>#\\<zero>#xs) = \\<one>#\\<zero>#xs\"", "lemma norm_signed11 [simp]: \"norm_signed (\\<one>#\\<one>#xs) = norm_signed (\\<one>#xs)\"", "lemmas [simp del] = norm_signed_Cons", "lemma int_to_bv_ge0 [simp]: \"0 \\<le> n ==> int_to_bv n = norm_signed (\\<zero> # nat_to_bv (nat n))\"", "lemma int_to_bv_lt0 [simp]:\n    \"n < 0 ==> int_to_bv n = norm_signed (bv_not (\\<zero>#nat_to_bv (nat (-n- 1))))\"", "lemma norm_signed_idem [simp]: \"norm_signed (norm_signed w) = norm_signed w\"", "lemma bv_to_int_Nil [simp]: \"bv_to_int [] = 0\"", "lemma bv_to_int_Cons0 [simp]: \"bv_to_int (\\<zero>#bs) = int (bv_to_nat bs)\"", "lemma bv_to_int_Cons1 [simp]: \"bv_to_int (\\<one>#bs) = - int (bv_to_nat (bv_not bs) + 1)\"", "lemma bv_to_int_type [simp]: \"bv_to_int (norm_signed w) = bv_to_int w\"", "lemma bv_to_int_upper_range: \"bv_to_int w < 2 ^ (length w - 1)\"", "lemma bv_to_int_lower_range: \"- (2 ^ (length w - 1)) \\<le> bv_to_int w\"", "lemma int_bv_int [simp]: \"int_to_bv (bv_to_int w) = norm_signed w\"", "lemma bv_int_bv [simp]: \"bv_to_int (int_to_bv i) = i\"", "lemma bv_msb_norm [simp]: \"bv_msb (norm_signed w) = bv_msb w\"", "lemma norm_signed_length: \"length (norm_signed w) \\<le> length w\"", "lemma norm_signed_equal: \"length (norm_signed w) = length w ==> norm_signed w = w\"", "lemma bv_extend_norm_signed: \"bv_msb w = b ==> bv_extend (length w) b (norm_signed w) = w\"", "lemma bv_to_int_qinj:\n  assumes one: \"bv_to_int xs = bv_to_int ys\"\n  and     len: \"length xs = length ys\"\n  shows        \"xs = ys\"", "lemma int_to_bv_returntype [simp]: \"norm_signed (int_to_bv w) = int_to_bv w\"", "lemma bv_to_int_msb0: \"0 \\<le> bv_to_int w1 ==> bv_msb w1 = \\<zero>\"", "lemma bv_to_int_msb1: \"bv_to_int w1 < 0 ==> bv_msb w1 = \\<one>\"", "lemma bv_to_int_lower_limit_gt0:\n  assumes w0: \"0 < bv_to_int w\"\n  shows       \"2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w\"", "lemma norm_signed_result: \"norm_signed w = [] \\<or> norm_signed w = [\\<one>] \\<or> bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\"", "lemma bv_to_int_upper_limit_lem1:\n  assumes w0: \"bv_to_int w < -1\"\n  shows       \"bv_to_int w < - (2 ^ (length (norm_signed w) - 2))\"", "lemma length_int_to_bv_upper_limit_gt0:\n  assumes w0: \"0 < i\"\n  and     wk: \"i \\<le> 2 ^ (k - 1) - 1\"\n  shows       \"length (int_to_bv i) \\<le> k\"", "lemma pos_length_pos:\n  assumes i0: \"0 < bv_to_int w\"\n  shows       \"0 < length w\"", "lemma neg_length_pos:\n  assumes i0: \"bv_to_int w < -1\"\n  shows       \"0 < length w\"", "lemma length_int_to_bv_lower_limit_gt0:\n  assumes wk: \"2 ^ (k - 1) \\<le> i\"\n  shows       \"k < length (int_to_bv i)\"", "lemma length_int_to_bv_upper_limit_lem1:\n  assumes w1: \"i < -1\"\n  and     wk: \"- (2 ^ (k - 1)) \\<le> i\"\n  shows       \"length (int_to_bv i) \\<le> k\"", "lemma length_int_to_bv_lower_limit_lem1:\n  assumes wk: \"i < -(2 ^ (k - 1))\"\n  shows       \"k < length (int_to_bv i)\"", "lemma utos_type [simp]: \"utos (norm_unsigned w) = utos w\"", "lemma utos_returntype [simp]: \"norm_signed (utos w) = utos w\"", "lemma utos_length: \"length (utos w) \\<le> Suc (length w)\"", "lemma bv_to_int_utos: \"bv_to_int (utos w) = int (bv_to_nat w)\"", "lemma bv_uminus_type [simp]: \"bv_uminus (norm_signed w) = bv_uminus w\"", "lemma bv_uminus_returntype [simp]: \"norm_signed (bv_uminus w) = bv_uminus w\"", "lemma bv_uminus_length: \"length (bv_uminus w) \\<le> Suc (length w)\"", "lemma bv_uminus_length_utos: \"length (bv_uminus (utos w)) \\<le> Suc (length w)\"", "lemma bv_sadd_type1 [simp]: \"bv_sadd (norm_signed w1) w2 = bv_sadd w1 w2\"", "lemma bv_sadd_type2 [simp]: \"bv_sadd w1 (norm_signed w2) = bv_sadd w1 w2\"", "lemma bv_sadd_returntype [simp]: \"norm_signed (bv_sadd w1 w2) = bv_sadd w1 w2\"", "lemma adder_helper:\n  assumes lw: \"0 < max (length w1) (length w2)\"\n  shows   \"((2::int) ^ (length w1 - 1)) + (2 ^ (length w2 - 1)) \\<le> 2 ^ max (length w1) (length w2)\"", "lemma bv_sadd_length: \"length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\"", "lemma bv_sub_type1 [simp]: \"bv_sub (norm_signed w1) w2 = bv_sub w1 w2\"", "lemma bv_sub_type2 [simp]: \"bv_sub w1 (norm_signed w2) = bv_sub w1 w2\"", "lemma bv_sub_returntype [simp]: \"norm_signed (bv_sub w1 w2) = bv_sub w1 w2\"", "lemma bv_sub_length: \"length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\"", "lemma bv_smult_type1 [simp]: \"bv_smult (norm_signed w1) w2 = bv_smult w1 w2\"", "lemma bv_smult_type2 [simp]: \"bv_smult w1 (norm_signed w2) = bv_smult w1 w2\"", "lemma bv_smult_returntype [simp]: \"norm_signed (bv_smult w1 w2) = bv_smult w1 w2\"", "lemma bv_smult_length: \"length (bv_smult w1 w2) \\<le> length w1 + length w2\"", "lemma bv_msb_one: \"bv_msb w = \\<one> ==> bv_to_nat w \\<noteq> 0\"", "lemma bv_smult_length_utos: \"length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\"", "lemma bv_smult_sym: \"bv_smult w1 w2 = bv_smult w2 w1\"", "lemma bv_select_rev:\n  assumes notnull: \"n < length w\"\n  shows            \"bv_select w n = rev w ! n\"", "lemma bv_chop_append: \"bv_chop (w1 @ w2) (length w2) = (w1,w2)\"", "lemma append_bv_chop_id: \"fst (bv_chop w l) @ snd (bv_chop w l) = w\"", "lemma bv_chop_length_fst [simp]: \"length (fst (bv_chop w i)) = length w - i\"", "lemma bv_chop_length_snd [simp]: \"length (snd (bv_chop w i)) = min i (length w)\"", "lemma bv_slice_length [simp]: \"[| j \\<le> i; i < length w |] ==> length (bv_slice w (i,j)) = i - j + 1\"", "lemma length_nat: \"length (nat_to_bv n) = length_nat n\"", "lemma length_nat_0 [simp]: \"length_nat 0 = 0\"", "lemma length_nat_non0:\n  assumes n0: \"n \\<noteq> 0\"\n  shows       \"length_nat n = Suc (length_nat (n div 2))\"", "lemma length_int: \"length (int_to_bv i) = length_int i\"", "lemma length_int_0 [simp]: \"length_int 0 = 0\"", "lemma length_int_gt0: \"0 < i ==> length_int i = Suc (length_nat (nat i))\"", "lemma length_int_lt0: \"i < 0 ==> length_int i = Suc (length_nat (nat (- i) - 1))\"", "lemma bv_chopI: \"[| w = w1 @ w2 ; i = length w2 |] ==> bv_chop w i = (w1,w2)\"", "lemma bv_sliceI: \"[| j \\<le> i ; i < length w ; w = w1 @ w2 @ w3 ; Suc i = length w2 + j ; j = length w3  |] ==> bv_slice w (i,j) = w2\"", "lemma bv_slice_bv_slice:\n  assumes ki: \"k \\<le> i\"\n  and     ij: \"i \\<le> j\"\n  and     jl: \"j \\<le> l\"\n  and     lw: \"l < length w\"\n  shows       \"bv_slice w (j,i) = bv_slice (bv_slice w (l,k)) (j-k,i-k)\"", "lemma bv_to_nat_extend [simp]: \"bv_to_nat (bv_extend n \\<zero> w) = bv_to_nat w\"", "lemma bv_msb_extend_same [simp]: \"bv_msb w = b ==> bv_msb (bv_extend n b w) = b\"", "lemma bv_to_int_extend [simp]:\n  assumes a: \"bv_msb w = b\"\n  shows      \"bv_to_int (bv_extend n b w) = bv_to_int w\"", "lemma length_nat_mono [simp]: \"x \\<le> y ==> length_nat x \\<le> length_nat y\"", "lemma length_nat_mono_int: \"x \\<le> y ==> length_nat x \\<le> length_nat y\"", "lemma length_nat_pos [simp,intro!]: \"0 < x ==> 0 < length_nat x\"", "lemma length_int_mono_gt0: \"[| 0 \\<le> x ; x \\<le> y |] ==> length_int x \\<le> length_int y\"", "lemma length_int_mono_lt0: \"[| x \\<le> y ; y \\<le> 0 |] ==> length_int y \\<le> length_int x\"", "lemmas [simp] = length_nat_non0", "lemma fast_bv_to_nat_Cons0: \"fast_bv_to_nat_helper (\\<zero>#bs) bin =\n    fast_bv_to_nat_helper bs (Num.Bit0 bin)\"", "lemma fast_bv_to_nat_Cons1: \"fast_bv_to_nat_helper (\\<one>#bs) bin =\n    fast_bv_to_nat_helper bs (Num.Bit1 bin)\"", "lemma mult_Bit0_left: \"Num.Bit0 m * n = Num.Bit0 (m * n)\"", "lemma fast_bv_to_nat_def:\n  \"bv_to_nat (\\<one> # bs) == numeral (fast_bv_to_nat_helper bs Num.One)\"", "lemma bv_length_bv_mapzip [simp]:\n    \"length (bv_mapzip f w1 w2) = max (length w1) (length w2)\"", "lemma bv_mapzip_Nil [simp]: \"bv_mapzip f [] [] = []\"", "lemma bv_mapzip_Cons [simp]: \"length w1 = length w2 ==>\n    bv_mapzip f (x#w1) (y#w2) = f x y # bv_mapzip f w1 w2\""], "translations": [["", "lemma max_le [intro!]: \"[| x \\<le> z; y \\<le> z |] ==> max x y \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> z; y \\<le> z\\<rbrakk> \\<Longrightarrow> max x y \\<le> z", "by (simp add: max_def)"], ["", "lemma max_mono:\n  fixes x :: \"'a::linorder\"\n  assumes mf: \"mono f\"\n  shows       \"max (f x) (f y) \\<le> f (max x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (f x) (f y) \\<le> f (max x y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. max (f x) (f y) \\<le> f (max x y)", "from mf and max.cobounded1 [of x y]"], ["proof (chain)\npicking this:\n  mono f\n  x \\<le> max x y", "have fx: \"f x \\<le> f (max x y)\""], ["proof (prove)\nusing this:\n  mono f\n  x \\<le> max x y\n\ngoal (1 subgoal):\n 1. f x \\<le> f (max x y)", "by (rule monoD)"], ["proof (state)\nthis:\n  f x \\<le> f (max x y)\n\ngoal (1 subgoal):\n 1. max (f x) (f y) \\<le> f (max x y)", "from mf and max.cobounded2 [of y x]"], ["proof (chain)\npicking this:\n  mono f\n  y \\<le> max x y", "have fy: \"f y \\<le> f (max x y)\""], ["proof (prove)\nusing this:\n  mono f\n  y \\<le> max x y\n\ngoal (1 subgoal):\n 1. f y \\<le> f (max x y)", "by (rule monoD)"], ["proof (state)\nthis:\n  f y \\<le> f (max x y)\n\ngoal (1 subgoal):\n 1. max (f x) (f y) \\<le> f (max x y)", "from fx and fy"], ["proof (chain)\npicking this:\n  f x \\<le> f (max x y)\n  f y \\<le> f (max x y)", "show \"max (f x) (f y) \\<le> f (max x y)\""], ["proof (prove)\nusing this:\n  f x \\<le> f (max x y)\n  f y \\<le> f (max x y)\n\ngoal (1 subgoal):\n 1. max (f x) (f y) \\<le> f (max x y)", "by auto"], ["proof (state)\nthis:\n  max (f x) (f y) \\<le> f (max x y)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare zero_le_power [intro]\n  and zero_less_power [intro]"], ["", "lemma int_nat_two_exp: \"2 ^ k = int (2 ^ k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ k = int (2 ^ k)", "by simp"], ["", "subsection \\<open>Bits\\<close>"], ["", "datatype bit =\n    Zero (\"\\<zero>\")\n  | One (\"\\<one>\")"], ["", "primrec bitval :: \"bit => nat\" where\n    \"bitval \\<zero> = 0\"\n  | \"bitval \\<one> = 1\""], ["", "primrec bitnot :: \"bit => bit\"  (\"\\<not>\\<^sub>b _\" [40] 40) where\n    bitnot_zero: \"(\\<not>\\<^sub>b \\<zero>) = \\<one>\"\n  | bitnot_one : \"(\\<not>\\<^sub>b \\<one>) = \\<zero>\""], ["", "primrec bitand :: \"bit => bit => bit\"  (infixr \"\\<and>\\<^sub>b\" 35) where\n    bitand_zero: \"(\\<zero> \\<and>\\<^sub>b y) = \\<zero>\"\n  | bitand_one:  \"(\\<one> \\<and>\\<^sub>b y) = y\""], ["", "primrec bitor :: \"bit => bit => bit\"  (infixr \"\\<or>\\<^sub>b\" 30) where\n    bitor_zero: \"(\\<zero> \\<or>\\<^sub>b y) = y\"\n  | bitor_one:  \"(\\<one> \\<or>\\<^sub>b y) = \\<one>\""], ["", "primrec bitxor :: \"bit => bit => bit\"  (infixr \"\\<oplus>\\<^sub>b\" 30) where\n    bitxor_zero: \"(\\<zero> \\<oplus>\\<^sub>b y) = y\"\n  | bitxor_one:  \"(\\<one> \\<oplus>\\<^sub>b y) = (bitnot y)\""], ["", "lemma bitnot_bitnot [simp]: \"(bitnot (bitnot b)) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not>\\<^sub>b \\<not>\\<^sub>b b) = b", "by (cases b) simp_all"], ["", "lemma bitand_cancel [simp]: \"(b \\<and>\\<^sub>b b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<and>\\<^sub>b b) = b", "by (cases b) simp_all"], ["", "lemma bitor_cancel [simp]: \"(b \\<or>\\<^sub>b b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<or>\\<^sub>b b) = b", "by (cases b) simp_all"], ["", "lemma bitxor_cancel [simp]: \"(b \\<oplus>\\<^sub>b b) = \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b \\<oplus>\\<^sub>b b) = \\<zero>", "by (cases b) simp_all"], ["", "subsection \\<open>Bit Vectors\\<close>"], ["", "text \\<open>First, a couple of theorems expressing case analysis and\ninduction principles for bit vectors.\\<close>"], ["", "lemma bit_list_cases:\n  assumes empty: \"w = [] ==> P w\"\n  and     zero:  \"!!bs. w = \\<zero> # bs ==> P w\"\n  and     one:   \"!!bs. w = \\<one> # bs ==> P w\"\n  shows   \"P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P w", "proof (cases w)"], ["proof (state)\ngoal (2 subgoals):\n 1. w = [] \\<Longrightarrow> P w\n 2. \\<And>a list. w = a # list \\<Longrightarrow> P w", "assume \"w = []\""], ["proof (state)\nthis:\n  w = []\n\ngoal (2 subgoals):\n 1. w = [] \\<Longrightarrow> P w\n 2. \\<And>a list. w = a # list \\<Longrightarrow> P w", "thus ?thesis"], ["proof (prove)\nusing this:\n  w = []\n\ngoal (1 subgoal):\n 1. P w", "by (rule empty)"], ["proof (state)\nthis:\n  P w\n\ngoal (1 subgoal):\n 1. \\<And>a list. w = a # list \\<Longrightarrow> P w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. w = a # list \\<Longrightarrow> P w", "fix b bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. w = a # list \\<Longrightarrow> P w", "assume [simp]: \"w = b # bs\""], ["proof (state)\nthis:\n  w = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list. w = a # list \\<Longrightarrow> P w", "show \"P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P w", "proof (cases b)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> P w\n 2. b = \\<one> \\<Longrightarrow> P w", "assume \"b = \\<zero>\""], ["proof (state)\nthis:\n  b = \\<zero>\n\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> P w\n 2. b = \\<one> \\<Longrightarrow> P w", "hence \"w = \\<zero> # bs\""], ["proof (prove)\nusing this:\n  b = \\<zero>\n\ngoal (1 subgoal):\n 1. w = \\<zero> # bs", "by simp"], ["proof (state)\nthis:\n  w = \\<zero> # bs\n\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> P w\n 2. b = \\<one> \\<Longrightarrow> P w", "thus ?thesis"], ["proof (prove)\nusing this:\n  w = \\<zero> # bs\n\ngoal (1 subgoal):\n 1. P w", "by (rule zero)"], ["proof (state)\nthis:\n  P w\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> P w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> P w", "assume \"b = \\<one>\""], ["proof (state)\nthis:\n  b = \\<one>\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> P w", "hence \"w = \\<one> # bs\""], ["proof (prove)\nusing this:\n  b = \\<one>\n\ngoal (1 subgoal):\n 1. w = \\<one> # bs", "by simp"], ["proof (state)\nthis:\n  w = \\<one> # bs\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> P w", "thus ?thesis"], ["proof (prove)\nusing this:\n  w = \\<one> # bs\n\ngoal (1 subgoal):\n 1. P w", "by (rule one)"], ["proof (state)\nthis:\n  P w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bit_list_induct:\n  assumes empty: \"P []\"\n  and     zero:  \"!!bs. P bs ==> P (\\<zero>#bs)\"\n  and     one:   \"!!bs. P bs ==> P (\\<one>#bs)\"\n  shows   \"P w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P w", "proof (induct w, simp_all add: empty)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w. P w \\<Longrightarrow> P (a # w)", "fix b bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w. P w \\<Longrightarrow> P (a # w)", "assume \"P bs\""], ["proof (state)\nthis:\n  P bs\n\ngoal (1 subgoal):\n 1. \\<And>a w. P w \\<Longrightarrow> P (a # w)", "then"], ["proof (chain)\npicking this:\n  P bs", "show \"P (b#bs)\""], ["proof (prove)\nusing this:\n  P bs\n\ngoal (1 subgoal):\n 1. P (b # bs)", "by (cases b) (auto intro!: zero one)"], ["proof (state)\nthis:\n  P (b # bs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  bv_msb :: \"bit list => bit\" where\n  \"bv_msb w = (if w = [] then \\<zero> else hd w)\""], ["", "definition\n  bv_extend :: \"[nat,bit,bit list]=>bit list\" where\n  \"bv_extend i b w = (replicate (i - length w) b) @ w\""], ["", "definition\n  bv_not :: \"bit list => bit list\" where\n  \"bv_not w = map bitnot w\""], ["", "lemma bv_length_extend [simp]: \"length w \\<le> i ==> length (bv_extend i b w) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w \\<le> i \\<Longrightarrow> length (bv_extend i b w) = i", "by (simp add: bv_extend_def)"], ["", "lemma bv_not_Nil [simp]: \"bv_not [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_not [] = []", "by (simp add: bv_not_def)"], ["", "lemma bv_not_Cons [simp]: \"bv_not (b#bs) = (bitnot b) # bv_not bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_not (b # bs) = (\\<not>\\<^sub>b b) # bv_not bs", "by (simp add: bv_not_def)"], ["", "lemma bv_not_bv_not [simp]: \"bv_not (bv_not w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_not (bv_not w) = w", "by (rule bit_list_induct [of _ w]) simp_all"], ["", "lemma bv_msb_Nil [simp]: \"bv_msb [] = \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb [] = \\<zero>", "by (simp add: bv_msb_def)"], ["", "lemma bv_msb_Cons [simp]: \"bv_msb (b#bs) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (b # bs) = b", "by (simp add: bv_msb_def)"], ["", "lemma bv_msb_bv_not [simp]: \"0 < length w ==> bv_msb (bv_not w) = (bitnot (bv_msb w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length w \\<Longrightarrow>\n    bv_msb (bv_not w) = (\\<not>\\<^sub>b bv_msb w)", "by (cases w) simp_all"], ["", "lemma bv_msb_one_length [simp,intro]: \"bv_msb w = \\<one> ==> 0 < length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow> 0 < length w", "by (cases w) simp_all"], ["", "lemma length_bv_not [simp]: \"length (bv_not w) = length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_not w) = length w", "by (induct w) simp_all"], ["", "definition\n  bv_to_nat :: \"bit list => nat\" where\n  \"bv_to_nat = foldl (%bn b. 2 * bn + bitval b) 0\""], ["", "lemma bv_to_nat_Nil [simp]: \"bv_to_nat [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat [] = 0", "by (simp add: bv_to_nat_def)"], ["", "lemma bv_to_nat_helper [simp]: \"bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs", "let ?bv_to_nat' = \"foldl (\\<lambda>bn b. 2 * bn + bitval b)\""], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs", "have helper: \"\\<And>base. ?bv_to_nat' base bs = base * 2 ^ length bs + ?bv_to_nat' 0 bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>base.\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base bs =\n       base * 2 ^ length bs + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs", "proof (induct bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>base.\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base [] =\n       base * 2 ^ length [] + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 []\n 2. \\<And>a bs base.\n       (\\<And>base.\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) base bs =\n           base * 2 ^ length bs +\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs) \\<Longrightarrow>\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base (a # bs) =\n       base * 2 ^ length (a # bs) +\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (a # bs)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>base.\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base [] =\n       base * 2 ^ length [] + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 []\n 2. \\<And>a bs base.\n       (\\<And>base.\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) base bs =\n           base * 2 ^ length bs +\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs) \\<Longrightarrow>\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base (a # bs) =\n       base * 2 ^ length (a # bs) +\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (a # bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>bn b. 2 * bn + bitval b) base [] =\n    base * 2 ^ length [] + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 []", "by simp"], ["proof (state)\nthis:\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) base [] =\n  base * 2 ^ length [] + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 []\n\ngoal (1 subgoal):\n 1. \\<And>a bs base.\n       (\\<And>base.\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) base bs =\n           base * 2 ^ length bs +\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs) \\<Longrightarrow>\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base (a # bs) =\n       base * 2 ^ length (a # bs) +\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (a # bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs base.\n       (\\<And>base.\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) base bs =\n           base * 2 ^ length bs +\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs) \\<Longrightarrow>\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base (a # bs) =\n       base * 2 ^ length (a # bs) +\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (a # bs)", "case (Cons x xs base)"], ["proof (state)\nthis:\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) ?base xs =\n  ?base * 2 ^ length xs + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 xs\n\ngoal (1 subgoal):\n 1. \\<And>a bs base.\n       (\\<And>base.\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) base bs =\n           base * 2 ^ length bs +\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs) \\<Longrightarrow>\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) base (a # bs) =\n       base * 2 ^ length (a # bs) +\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (a # bs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>bn b. 2 * bn + bitval b) base (x # xs) =\n    base * 2 ^ length (x # xs) +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (x # xs)", "apply (simp only: foldl_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>bn b. 2 * bn + bitval b) (2 * base + bitval x) xs =\n    base * 2 ^ length (x # xs) +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) (2 * 0 + bitval x) xs", "apply (subst Cons [of \"2 * base + bitval x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * base + bitval x) * 2 ^ length xs +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 xs =\n    base * 2 ^ length (x # xs) +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) (2 * 0 + bitval x) xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * base + bitval x) * 2 ^ length xs +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 xs =\n    base * (2 * 2 ^ length xs) +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) (bitval x) xs", "apply (subst Cons [of \"bitval x\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 * base + bitval x) * 2 ^ length xs +\n    foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 xs =\n    base * (2 * 2 ^ length xs) +\n    (bitval x * 2 ^ length xs +\n     foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 xs)", "apply (simp add: add_mult_distrib)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) base (x # xs) =\n  base * 2 ^ length (x # xs) +\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) ?base bs =\n  ?base * 2 ^ length bs + foldl (\\<lambda>bn b. 2 * bn + bitval b) 0 bs\n\ngoal (1 subgoal):\n 1. bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs", "by (simp add: bv_to_nat_def) (rule helper)"], ["proof (state)\nthis:\n  bv_to_nat (b # bs) = bitval b * 2 ^ length bs + bv_to_nat bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat0 [simp]: \"bv_to_nat (\\<zero>#bs) = bv_to_nat bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (\\<zero> # bs) = bv_to_nat bs", "by simp"], ["", "lemma bv_to_nat1 [simp]: \"bv_to_nat (\\<one>#bs) = 2 ^ length bs + bv_to_nat bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (\\<one> # bs) = 2 ^ length bs + bv_to_nat bs", "by simp"], ["", "lemma bv_to_nat_upper_range: \"bv_to_nat w < 2 ^ length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w < 2 ^ length w", "proof (induct w, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_to_nat w < 2 ^ length w \\<Longrightarrow>\n       bitval a * 2 ^ length w + bv_to_nat w < 2 * 2 ^ length w", "fix b bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_to_nat w < 2 ^ length w \\<Longrightarrow>\n       bitval a * 2 ^ length w + bv_to_nat w < 2 * 2 ^ length w", "assume \"bv_to_nat bs < 2 ^ length bs\""], ["proof (state)\nthis:\n  bv_to_nat bs < 2 ^ length bs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_to_nat w < 2 ^ length w \\<Longrightarrow>\n       bitval a * 2 ^ length w + bv_to_nat w < 2 * 2 ^ length w", "show \"bitval b * 2 ^ length bs + bv_to_nat bs < 2 * 2 ^ length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitval b * 2 ^ length bs + bv_to_nat bs < 2 * 2 ^ length bs", "proof (cases b, simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> bv_to_nat bs < 2 * 2 ^ length bs\n 2. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "have \"bv_to_nat bs < 2 ^ length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat bs < 2 ^ length bs", "by fact"], ["proof (state)\nthis:\n  bv_to_nat bs < 2 ^ length bs\n\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> bv_to_nat bs < 2 * 2 ^ length bs\n 2. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "also"], ["proof (state)\nthis:\n  bv_to_nat bs < 2 ^ length bs\n\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> bv_to_nat bs < 2 * 2 ^ length bs\n 2. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "have \"... < 2 * 2 ^ length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length bs < 2 * 2 ^ length bs", "by auto"], ["proof (state)\nthis:\n  2 ^ length bs < 2 * 2 ^ length bs\n\ngoal (2 subgoals):\n 1. b = \\<zero> \\<Longrightarrow> bv_to_nat bs < 2 * 2 ^ length bs\n 2. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "finally"], ["proof (chain)\npicking this:\n  bv_to_nat bs < 2 * 2 ^ length bs", "show \"bv_to_nat bs < 2 * 2 ^ length bs\""], ["proof (prove)\nusing this:\n  bv_to_nat bs < 2 * 2 ^ length bs\n\ngoal (1 subgoal):\n 1. bv_to_nat bs < 2 * 2 ^ length bs", "by simp"], ["proof (state)\nthis:\n  bv_to_nat bs < 2 * 2 ^ length bs\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "have \"bv_to_nat bs < 2 ^ length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat bs < 2 ^ length bs", "by fact"], ["proof (state)\nthis:\n  bv_to_nat bs < 2 ^ length bs\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "hence \"2 ^ length bs + bv_to_nat bs < 2 ^ length bs + 2 ^ length bs\""], ["proof (prove)\nusing this:\n  bv_to_nat bs < 2 ^ length bs\n\ngoal (1 subgoal):\n 1. 2 ^ length bs + bv_to_nat bs < 2 ^ length bs + 2 ^ length bs", "by arith"], ["proof (state)\nthis:\n  2 ^ length bs + bv_to_nat bs < 2 ^ length bs + 2 ^ length bs\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "also"], ["proof (state)\nthis:\n  2 ^ length bs + bv_to_nat bs < 2 ^ length bs + 2 ^ length bs\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "have \"... = 2 * (2 ^ length bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length bs + 2 ^ length bs = 2 * 2 ^ length bs", "by simp"], ["proof (state)\nthis:\n  2 ^ length bs + 2 ^ length bs = 2 * 2 ^ length bs\n\ngoal (1 subgoal):\n 1. b = \\<one> \\<Longrightarrow> bv_to_nat bs < 2 ^ length bs", "finally"], ["proof (chain)\npicking this:\n  2 ^ length bs + bv_to_nat bs < 2 * 2 ^ length bs", "show \"bv_to_nat bs < 2 ^ length bs\""], ["proof (prove)\nusing this:\n  2 ^ length bs + bv_to_nat bs < 2 * 2 ^ length bs\n\ngoal (1 subgoal):\n 1. bv_to_nat bs < 2 ^ length bs", "by simp"], ["proof (state)\nthis:\n  bv_to_nat bs < 2 ^ length bs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bitval b * 2 ^ length bs + bv_to_nat bs < 2 * 2 ^ length bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_extend_longer [simp]:\n  assumes wn: \"n \\<le> length w\"\n  shows       \"bv_extend n b w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend n b w = w", "by (simp add: bv_extend_def wn)"], ["", "lemma bv_extend_shorter [simp]:\n  assumes wn: \"length w < n\"\n  shows       \"bv_extend n b w = bv_extend n b (b#w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "from wn"], ["proof (chain)\npicking this:\n  length w < n", "have s: \"n - Suc (length w) + 1 = n - length w\""], ["proof (prove)\nusing this:\n  length w < n\n\ngoal (1 subgoal):\n 1. n - Suc (length w) + 1 = n - length w", "by arith"], ["proof (state)\nthis:\n  n - Suc (length w) + 1 = n - length w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "have \"bv_extend n b w = replicate (n - length w) b @ w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend n b w = replicate (n - length w) b @ w", "by (simp add: bv_extend_def)"], ["proof (state)\nthis:\n  bv_extend n b w = replicate (n - length w) b @ w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "also"], ["proof (state)\nthis:\n  bv_extend n b w = replicate (n - length w) b @ w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "have \"... = replicate (n - Suc (length w) + 1) b @ w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (n - length w) b @ w =\n    replicate (n - Suc (length w) + 1) b @ w", "by (subst s) rule"], ["proof (state)\nthis:\n  replicate (n - length w) b @ w = replicate (n - Suc (length w) + 1) b @ w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "also"], ["proof (state)\nthis:\n  replicate (n - length w) b @ w = replicate (n - Suc (length w) + 1) b @ w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "have \"... = (replicate (n - Suc (length w)) b @ replicate 1 b) @ w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (n - Suc (length w) + 1) b @ w =\n    (replicate (n - Suc (length w)) b @ replicate 1 b) @ w", "by (subst replicate_add) rule"], ["proof (state)\nthis:\n  replicate (n - Suc (length w) + 1) b @ w =\n  (replicate (n - Suc (length w)) b @ replicate 1 b) @ w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "also"], ["proof (state)\nthis:\n  replicate (n - Suc (length w) + 1) b @ w =\n  (replicate (n - Suc (length w)) b @ replicate 1 b) @ w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "have \"... = replicate (n - Suc (length w)) b @ b # w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate (n - Suc (length w)) b @ replicate 1 b) @ w =\n    replicate (n - Suc (length w)) b @ b # w", "by simp"], ["proof (state)\nthis:\n  (replicate (n - Suc (length w)) b @ replicate 1 b) @ w =\n  replicate (n - Suc (length w)) b @ b # w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "also"], ["proof (state)\nthis:\n  (replicate (n - Suc (length w)) b @ replicate 1 b) @ w =\n  replicate (n - Suc (length w)) b @ b # w\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "have \"... = bv_extend n b (b#w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (n - Suc (length w)) b @ b # w = bv_extend n b (b # w)", "by (simp add: bv_extend_def)"], ["proof (state)\nthis:\n  replicate (n - Suc (length w)) b @ b # w = bv_extend n b (b # w)\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "finally"], ["proof (chain)\npicking this:\n  bv_extend n b w = bv_extend n b (b # w)", "show \"bv_extend n b w = bv_extend n b (b#w)\""], ["proof (prove)\nusing this:\n  bv_extend n b w = bv_extend n b (b # w)\n\ngoal (1 subgoal):\n 1. bv_extend n b w = bv_extend n b (b # w)", "."], ["proof (state)\nthis:\n  bv_extend n b w = bv_extend n b (b # w)\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec rem_initial :: \"bit => bit list => bit list\" where\n    \"rem_initial b [] = []\"\n  | \"rem_initial b (x#xs) = (if b = x then rem_initial b xs else x#xs)\""], ["", "lemma rem_initial_length: \"length (rem_initial b w) \\<le> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rem_initial b w) \\<le> length w", "by (rule bit_list_induct [of _ w],simp_all (no_asm),safe,simp_all)"], ["", "lemma rem_initial_equal:\n  assumes p: \"length (rem_initial b w) = length w\"\n  shows      \"rem_initial b w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_initial b w = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rem_initial b w = w", "have \"length (rem_initial b w) = length w --> rem_initial b w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rem_initial b w) = length w \\<longrightarrow>\n    rem_initial b w = w", "proof (induct w, simp_all, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>length (rem_initial b w) = length w \\<longrightarrow>\n                rem_initial b w = w;\n        length (rem_initial b w) = Suc (length w)\\<rbrakk>\n       \\<Longrightarrow> rem_initial b w = b # w", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>length (rem_initial b w) = length w \\<longrightarrow>\n                rem_initial b w = w;\n        length (rem_initial b w) = Suc (length w)\\<rbrakk>\n       \\<Longrightarrow> rem_initial b w = b # w", "assume \"length (rem_initial b xs) = length xs --> rem_initial b xs = xs\""], ["proof (state)\nthis:\n  length (rem_initial b xs) = length xs \\<longrightarrow>\n  rem_initial b xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>length (rem_initial b w) = length w \\<longrightarrow>\n                rem_initial b w = w;\n        length (rem_initial b w) = Suc (length w)\\<rbrakk>\n       \\<Longrightarrow> rem_initial b w = b # w", "assume f: \"length (rem_initial b xs) = Suc (length xs)\""], ["proof (state)\nthis:\n  length (rem_initial b xs) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>length (rem_initial b w) = length w \\<longrightarrow>\n                rem_initial b w = w;\n        length (rem_initial b w) = Suc (length w)\\<rbrakk>\n       \\<Longrightarrow> rem_initial b w = b # w", "with rem_initial_length [of b xs]"], ["proof (chain)\npicking this:\n  length (rem_initial b xs) \\<le> length xs\n  length (rem_initial b xs) = Suc (length xs)", "show \"rem_initial b xs = b#xs\""], ["proof (prove)\nusing this:\n  length (rem_initial b xs) \\<le> length xs\n  length (rem_initial b xs) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. rem_initial b xs = b # xs", "by auto"], ["proof (state)\nthis:\n  rem_initial b xs = b # xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (rem_initial b w) = length w \\<longrightarrow> rem_initial b w = w\n\ngoal (1 subgoal):\n 1. rem_initial b w = w", "from this and p"], ["proof (chain)\npicking this:\n  length (rem_initial b w) = length w \\<longrightarrow> rem_initial b w = w\n  length (rem_initial b w) = length w", "show ?thesis"], ["proof (prove)\nusing this:\n  length (rem_initial b w) = length w \\<longrightarrow> rem_initial b w = w\n  length (rem_initial b w) = length w\n\ngoal (1 subgoal):\n 1. rem_initial b w = w", ".."], ["proof (state)\nthis:\n  rem_initial b w = w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_extend_rem_initial: \"bv_extend (length w) b (rem_initial b w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length w) b (rem_initial b w) = w", "proof (induct w, simp_all, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "assume ind: \"bv_extend (length xs) b (rem_initial b xs) = xs\""], ["proof (state)\nthis:\n  bv_extend (length xs) b (rem_initial b xs) = xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "from rem_initial_length [of b xs]"], ["proof (chain)\npicking this:\n  length (rem_initial b xs) \\<le> length xs", "have [simp]: \"Suc (length xs) - length (rem_initial b xs) =\n      1 + (length xs - length (rem_initial b xs))\""], ["proof (prove)\nusing this:\n  length (rem_initial b xs) \\<le> length xs\n\ngoal (1 subgoal):\n 1. Suc (length xs) - length (rem_initial b xs) =\n    1 + (length xs - length (rem_initial b xs))", "by arith"], ["proof (state)\nthis:\n  Suc (length xs) - length (rem_initial b xs) =\n  1 + (length xs - length (rem_initial b xs))\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "have \"bv_extend (Suc (length xs)) b (rem_initial b xs) =\n      replicate (Suc (length xs) - length (rem_initial b xs)) b @ (rem_initial b xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) b (rem_initial b xs) =\n    replicate (Suc (length xs) - length (rem_initial b xs)) b @\n    rem_initial b xs", "by (simp add: bv_extend_def)"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) b (rem_initial b xs) =\n  replicate (Suc (length xs) - length (rem_initial b xs)) b @\n  rem_initial b xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "also"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) b (rem_initial b xs) =\n  replicate (Suc (length xs) - length (rem_initial b xs)) b @\n  rem_initial b xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "have \"... =\n      replicate (1 + (length xs - length (rem_initial b xs))) b @ rem_initial b xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (Suc (length xs) - length (rem_initial b xs)) b @\n    rem_initial b xs =\n    replicate (1 + (length xs - length (rem_initial b xs))) b @\n    rem_initial b xs", "by simp"], ["proof (state)\nthis:\n  replicate (Suc (length xs) - length (rem_initial b xs)) b @\n  rem_initial b xs =\n  replicate (1 + (length xs - length (rem_initial b xs))) b @\n  rem_initial b xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "also"], ["proof (state)\nthis:\n  replicate (Suc (length xs) - length (rem_initial b xs)) b @\n  rem_initial b xs =\n  replicate (1 + (length xs - length (rem_initial b xs))) b @\n  rem_initial b xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "have \"... =\n      (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @ rem_initial b xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (1 + (length xs - length (rem_initial b xs))) b @\n    rem_initial b xs =\n    (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @\n    rem_initial b xs", "by (subst replicate_add) (rule refl)"], ["proof (state)\nthis:\n  replicate (1 + (length xs - length (rem_initial b xs))) b @\n  rem_initial b xs =\n  (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @\n  rem_initial b xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "also"], ["proof (state)\nthis:\n  replicate (1 + (length xs - length (rem_initial b xs))) b @\n  rem_initial b xs =\n  (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @\n  rem_initial b xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "have \"... = b # bv_extend (length xs) b (rem_initial b xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @\n    rem_initial b xs =\n    b # bv_extend (length xs) b (rem_initial b xs)", "by (auto simp add: bv_extend_def [symmetric])"], ["proof (state)\nthis:\n  (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @\n  rem_initial b xs =\n  b # bv_extend (length xs) b (rem_initial b xs)\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "also"], ["proof (state)\nthis:\n  (replicate 1 b @ replicate (length xs - length (rem_initial b xs)) b) @\n  rem_initial b xs =\n  b # bv_extend (length xs) b (rem_initial b xs)\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "have \"... = b # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b # bv_extend (length xs) b (rem_initial b xs) = b # xs", "by (simp add: ind)"], ["proof (state)\nthis:\n  b # bv_extend (length xs) b (rem_initial b xs) = b # xs\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       bv_extend (length w) b (rem_initial b w) = w \\<Longrightarrow>\n       bv_extend (Suc (length w)) b (rem_initial b w) = b # w", "finally"], ["proof (chain)\npicking this:\n  bv_extend (Suc (length xs)) b (rem_initial b xs) = b # xs", "show \"bv_extend (Suc (length xs)) b (rem_initial b xs) = b # xs\""], ["proof (prove)\nusing this:\n  bv_extend (Suc (length xs)) b (rem_initial b xs) = b # xs\n\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) b (rem_initial b xs) = b # xs", "."], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) b (rem_initial b xs) = b # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rem_initial_append1:\n  assumes \"rem_initial b xs ~= []\"\n  shows   \"rem_initial b (xs @ ys) = rem_initial b xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_initial b (xs @ ys) = rem_initial b xs @ ys", "using assms"], ["proof (prove)\nusing this:\n  rem_initial b xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. rem_initial b (xs @ ys) = rem_initial b xs @ ys", "by (induct xs) auto"], ["", "lemma rem_initial_append2:\n  assumes \"rem_initial b xs = []\"\n  shows   \"rem_initial b (xs @ ys) = rem_initial b ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_initial b (xs @ ys) = rem_initial b ys", "using assms"], ["proof (prove)\nusing this:\n  rem_initial b xs = []\n\ngoal (1 subgoal):\n 1. rem_initial b (xs @ ys) = rem_initial b ys", "by (induct xs) auto"], ["", "definition\n  norm_unsigned :: \"bit list => bit list\" where\n  \"norm_unsigned = rem_initial \\<zero>\""], ["", "lemma norm_unsigned_Nil [simp]: \"norm_unsigned [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned [] = []", "by (simp add: norm_unsigned_def)"], ["", "lemma norm_unsigned_Cons0 [simp]: \"norm_unsigned (\\<zero>#bs) = norm_unsigned bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (\\<zero> # bs) = norm_unsigned bs", "by (simp add: norm_unsigned_def)"], ["", "lemma norm_unsigned_Cons1 [simp]: \"norm_unsigned (\\<one>#bs) = \\<one>#bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (\\<one> # bs) = \\<one> # bs", "by (simp add: norm_unsigned_def)"], ["", "lemma norm_unsigned_idem [simp]: \"norm_unsigned (norm_unsigned w) = norm_unsigned w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (norm_unsigned w) = norm_unsigned w", "by (rule bit_list_induct [of _ w],simp_all)"], ["", "fun\n  nat_to_bv_helper :: \"nat => bit list => bit list\"\nwhere\n  \"nat_to_bv_helper n bs = (if n = 0 then bs\n                               else nat_to_bv_helper (n div 2) ((if n mod 2 = 0 then \\<zero> else \\<one>)#bs))\""], ["", "definition\n  nat_to_bv :: \"nat => bit list\" where\n  \"nat_to_bv n = nat_to_bv_helper n []\""], ["", "lemma nat_to_bv0 [simp]: \"nat_to_bv 0 = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv 0 = []", "by (simp add: nat_to_bv_def)"], ["", "lemmas [simp del] = nat_to_bv_helper.simps"], ["", "lemma n_div_2_cases:\n  assumes zero: \"(n::nat) = 0 ==> R\"\n  and     div : \"[| n div 2 < n ; 0 < n |] ==> R\"\n  shows         \"R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> R\n 2. n \\<noteq> 0 \\<Longrightarrow> R", "assume \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> R\n 2. n \\<noteq> 0 \\<Longrightarrow> R", "thus R"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. R", "by (rule zero)"], ["proof (state)\nthis:\n  R\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> R", "assume \"n ~= 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> R", "hence \"0 < n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> R", "hence \"n div 2 < n\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n div 2 < n", "by arith"], ["proof (state)\nthis:\n  n div 2 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> R", "from this and \\<open>0 < n\\<close>"], ["proof (chain)\npicking this:\n  n div 2 < n\n  0 < n", "show R"], ["proof (prove)\nusing this:\n  n div 2 < n\n  0 < n\n\ngoal (1 subgoal):\n 1. R", "by (rule div)"], ["proof (state)\nthis:\n  R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_wf_ge_induct:\n  assumes ind :  \"!!i::int. (!!j. [| k \\<le> j ; j < i |] ==> P j) ==> P i\"\n  shows          \"P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P i", "proof (rule wf_induct_rule [OF wf_int_ge_less_than])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> int_ge_less_than ?d1 \\<Longrightarrow>\n           P y) \\<Longrightarrow>\n       P x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> int_ge_less_than ?d1 \\<Longrightarrow>\n           P y) \\<Longrightarrow>\n       P x", "assume ih: \"(\\<And>y::int. (y, x) \\<in> int_ge_less_than k \\<Longrightarrow> P y)\""], ["proof (state)\nthis:\n  (?y, x) \\<in> int_ge_less_than k \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           (y, x) \\<in> int_ge_less_than ?d1 \\<Longrightarrow>\n           P y) \\<Longrightarrow>\n       P x", "thus \"P x\""], ["proof (prove)\nusing this:\n  (?y, x) \\<in> int_ge_less_than k \\<Longrightarrow> P ?y\n\ngoal (1 subgoal):\n 1. P x", "by (rule ind) (simp add: int_ge_less_than_def)"], ["proof (state)\nthis:\n  P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unfold_nat_to_bv_helper:\n  \"nat_to_bv_helper b l = nat_to_bv_helper b [] @ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l", "have \"\\<forall>l. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l", "proof (induct b rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           \\<forall>l.\n              nat_to_bv_helper y l =\n              nat_to_bv_helper y [] @ l) \\<Longrightarrow>\n       \\<forall>l. nat_to_bv_helper x l = nat_to_bv_helper x [] @ l", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           \\<forall>l.\n              nat_to_bv_helper y l =\n              nat_to_bv_helper y [] @ l) \\<Longrightarrow>\n       \\<forall>l. nat_to_bv_helper x l = nat_to_bv_helper x [] @ l", "assume ind: \"!!j. j < n \\<Longrightarrow> \\<forall> l. nat_to_bv_helper j l = nat_to_bv_helper j [] @ l\""], ["proof (state)\nthis:\n  ?j < n \\<Longrightarrow>\n  \\<forall>l. nat_to_bv_helper ?j l = nat_to_bv_helper ?j [] @ l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           \\<forall>l.\n              nat_to_bv_helper y l =\n              nat_to_bv_helper y [] @ l) \\<Longrightarrow>\n       \\<forall>l. nat_to_bv_helper x l = nat_to_bv_helper x [] @ l", "show \"\\<forall>l. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "show \"nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "proof (cases \"n < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n 2. \\<not> n < 0 \\<Longrightarrow>\n    nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "assume \"n < 0\""], ["proof (state)\nthis:\n  n < 0\n\ngoal (2 subgoals):\n 1. n < 0 \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n 2. \\<not> n < 0 \\<Longrightarrow>\n    nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "thus ?thesis"], ["proof (prove)\nusing this:\n  n < 0\n\ngoal (1 subgoal):\n 1. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "by (simp add: nat_to_bv_helper.simps)"], ["proof (state)\nthis:\n  nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "assume \"~n < 0\""], ["proof (state)\nthis:\n  \\<not> n < 0\n\ngoal (1 subgoal):\n 1. \\<not> n < 0 \\<Longrightarrow>\n    nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "proof (rule n_div_2_cases [of n])"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n 2. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "assume [simp]: \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n 2. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "apply (simp only: nat_to_bv_helper.simps [of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n = 0 then l\n     else nat_to_bv_helper (n div 2)\n           ((if n mod 2 = 0 then \\<zero> else \\<one>) # l)) =\n    (if n = 0 then []\n     else nat_to_bv_helper (n div 2)\n           [if n mod 2 = 0 then \\<zero> else \\<one>]) @\n    l", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "assume n2n: \"n div 2 < n\""], ["proof (state)\nthis:\n  n div 2 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "assume [simp]: \"0 < n\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "hence n20: \"0 \\<le> n div 2\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 0 \\<le> n div 2", "by arith"], ["proof (state)\nthis:\n  0 \\<le> n div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "from ind [of \"n div 2\"] and n2n n20"], ["proof (chain)\npicking this:\n  n div 2 < n \\<Longrightarrow>\n  \\<forall>l.\n     nat_to_bv_helper (n div 2) l = nat_to_bv_helper (n div 2) [] @ l\n  n div 2 < n\n  0 \\<le> n div 2", "have ind': \"\\<forall>l. nat_to_bv_helper (n div 2) l = nat_to_bv_helper (n div 2) [] @ l\""], ["proof (prove)\nusing this:\n  n div 2 < n \\<Longrightarrow>\n  \\<forall>l.\n     nat_to_bv_helper (n div 2) l = nat_to_bv_helper (n div 2) [] @ l\n  n div 2 < n\n  0 \\<le> n div 2\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       nat_to_bv_helper (n div 2) l = nat_to_bv_helper (n div 2) [] @ l", "by blast"], ["proof (state)\nthis:\n  \\<forall>l.\n     nat_to_bv_helper (n div 2) l = nat_to_bv_helper (n div 2) [] @ l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l", "apply (simp only: nat_to_bv_helper.simps [of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n = 0 then l\n     else nat_to_bv_helper (n div 2)\n           ((if n mod 2 = 0 then \\<zero> else \\<one>) # l)) =\n    (if n = 0 then []\n     else nat_to_bv_helper (n div 2)\n           [if n mod 2 = 0 then \\<zero> else \\<one>]) @\n    l", "apply (cases \"n=0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    (if n = 0 then l\n     else nat_to_bv_helper (n div 2)\n           ((if n mod 2 = 0 then \\<zero> else \\<one>) # l)) =\n    (if n = 0 then []\n     else nat_to_bv_helper (n div 2)\n           [if n mod 2 = 0 then \\<zero> else \\<one>]) @\n    l\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    (if n = 0 then l\n     else nat_to_bv_helper (n div 2)\n           ((if n mod 2 = 0 then \\<zero> else \\<one>) # l)) =\n    (if n = 0 then []\n     else nat_to_bv_helper (n div 2)\n           [if n mod 2 = 0 then \\<zero> else \\<one>]) @\n    l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    (if n = 0 then l\n     else nat_to_bv_helper (n div 2)\n           ((if n mod 2 = 0 then \\<zero> else \\<one>) # l)) =\n    (if n = 0 then []\n     else nat_to_bv_helper (n div 2)\n           [if n mod 2 = 0 then \\<zero> else \\<one>]) @\n    l", "apply (simp only: if_False)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv_helper (n div 2)\n     ((if n mod 2 = 0 then \\<zero> else \\<one>) # l) =\n    nat_to_bv_helper (n div 2) [if n mod 2 = 0 then \\<zero> else \\<one>] @ l", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n mod 2 = 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) (\\<zero> # l) =\n     nat_to_bv_helper (n div 2) [\\<zero>] @ l) \\<and>\n    (n mod 2 = Suc 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) (\\<one> # l) =\n     nat_to_bv_helper (n div 2) [\\<one>] @ l)", "apply (subst spec [OF ind',of \"\\<zero>#l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n mod 2 = 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<zero> # l =\n     nat_to_bv_helper (n div 2) [\\<zero>] @ l) \\<and>\n    (n mod 2 = Suc 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) (\\<one> # l) =\n     nat_to_bv_helper (n div 2) [\\<one>] @ l)", "apply (subst spec [OF ind',of \"\\<one>#l\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n mod 2 = 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<zero> # l =\n     nat_to_bv_helper (n div 2) [\\<zero>] @ l) \\<and>\n    (n mod 2 = Suc 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<one> # l =\n     nat_to_bv_helper (n div 2) [\\<one>] @ l)", "apply (subst spec [OF ind',of \"[\\<one>]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n mod 2 = 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<zero> # l =\n     nat_to_bv_helper (n div 2) [\\<zero>] @ l) \\<and>\n    (n mod 2 = Suc 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<one> # l =\n     (nat_to_bv_helper (n div 2) [] @ [\\<one>]) @ l)", "apply (subst spec [OF ind',of \"[\\<zero>]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n mod 2 = 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<zero> # l =\n     (nat_to_bv_helper (n div 2) [] @ [\\<zero>]) @ l) \\<and>\n    (n mod 2 = Suc 0 \\<longrightarrow>\n     nat_to_bv_helper (n div 2) [] @ \\<one> # l =\n     (nat_to_bv_helper (n div 2) [] @ [\\<one>]) @ l)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l. nat_to_bv_helper n l = nat_to_bv_helper n [] @ l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l\n\ngoal (1 subgoal):\n 1. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l\n\ngoal (1 subgoal):\n 1. nat_to_bv_helper b l = nat_to_bv_helper b [] @ l", ".."], ["proof (state)\nthis:\n  nat_to_bv_helper b l = nat_to_bv_helper b [] @ l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_to_bv_non0 [simp]: \"n\\<noteq>0 ==> nat_to_bv n = nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv n =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv n =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "assume n: \"n\\<noteq>0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv n =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv n =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "apply (subst nat_to_bv_def [of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper n [] =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "apply (simp only: nat_to_bv_helper.simps [of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n = 0 then []\n     else nat_to_bv_helper (n div 2)\n           [if n mod 2 = 0 then \\<zero> else \\<one>]) =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "apply (subst unfold_nat_to_bv_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n = 0 then []\n     else nat_to_bv_helper (n div 2) [] @\n          [if n mod 2 = 0 then \\<zero> else \\<one>]) =\n    nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]", "apply (simp add: n)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper (n div 2) [] = nat_to_bv (n div 2)", "apply (subst nat_to_bv_def [of \"n div 2\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv_helper (n div 2) [] = nat_to_bv_helper (n div 2) []", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_to_bv n =\n  nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat_dist_append:\n  \"bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2", "have \"\\<forall>l2. bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l2.\n       bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2", "proof (induct l1, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1.\n       \\<forall>l2.\n          bv_to_nat (l1 @ l2) =\n          bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2 \\<Longrightarrow>\n       \\<forall>l2.\n          bitval a * 2 ^ (length l1 + length l2) +\n          bv_to_nat l1 * 2 ^ length l2 =\n          (bitval a * 2 ^ length l1 + bv_to_nat l1) * 2 ^ length l2", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l1.\n       \\<forall>l2.\n          bv_to_nat (l1 @ l2) =\n          bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2 \\<Longrightarrow>\n       \\<forall>l2.\n          bitval a * 2 ^ (length l1 + length l2) +\n          bv_to_nat l1 * 2 ^ length l2 =\n          (bitval a * 2 ^ length l1 + bv_to_nat l1) * 2 ^ length l2", "assume ind: \"\\<forall>l2. bv_to_nat (xs @ l2) = bv_to_nat xs * 2 ^ length l2 + bv_to_nat l2\""], ["proof (state)\nthis:\n  \\<forall>l2.\n     bv_to_nat (xs @ l2) = bv_to_nat xs * 2 ^ length l2 + bv_to_nat l2\n\ngoal (1 subgoal):\n 1. \\<And>a l1.\n       \\<forall>l2.\n          bv_to_nat (l1 @ l2) =\n          bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2 \\<Longrightarrow>\n       \\<forall>l2.\n          bitval a * 2 ^ (length l1 + length l2) +\n          bv_to_nat l1 * 2 ^ length l2 =\n          (bitval a * 2 ^ length l1 + bv_to_nat l1) * 2 ^ length l2", "show \"\\<forall>l2::bit list. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 = (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l2.\n       bitval x * 2 ^ (length xs + length l2) +\n       bv_to_nat xs * 2 ^ length l2 =\n       (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l2.\n       bitval x * 2 ^ (length xs + length l2) +\n       bv_to_nat xs * 2 ^ length l2 =\n       (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "fix l2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l2.\n       bitval x * 2 ^ (length xs + length l2) +\n       bv_to_nat xs * 2 ^ length l2 =\n       (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "show \"bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 = (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "have \"(2::nat) ^ (length xs + length l2) = 2 ^ length xs * 2 ^ length l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length xs + length l2) = 2 ^ length xs * 2 ^ length l2", "by (induct (\"length xs\")) simp_all"], ["proof (state)\nthis:\n  2 ^ (length xs + length l2) = 2 ^ length xs * 2 ^ length l2\n\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "hence \"bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n          bitval x * 2 ^ length xs * 2 ^ length l2 + bv_to_nat xs * 2 ^ length l2\""], ["proof (prove)\nusing this:\n  2 ^ (length xs + length l2) = 2 ^ length xs * 2 ^ length l2\n\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    bitval x * 2 ^ length xs * 2 ^ length l2 + bv_to_nat xs * 2 ^ length l2", "by simp"], ["proof (state)\nthis:\n  bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n  bitval x * 2 ^ length xs * 2 ^ length l2 + bv_to_nat xs * 2 ^ length l2\n\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "also"], ["proof (state)\nthis:\n  bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n  bitval x * 2 ^ length xs * 2 ^ length l2 + bv_to_nat xs * 2 ^ length l2\n\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "have \"... = (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitval x * 2 ^ length xs * 2 ^ length l2 +\n    bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  bitval x * 2 ^ length xs * 2 ^ length l2 + bv_to_nat xs * 2 ^ length l2 =\n  (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\n\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "finally"], ["proof (chain)\npicking this:\n  bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n  (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "show ?thesis"], ["proof (prove)\nusing this:\n  bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n  (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\n\ngoal (1 subgoal):\n 1. bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n    (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2", "by simp"], ["proof (state)\nthis:\n  bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n  (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n  (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l2.\n     bitval x * 2 ^ (length xs + length l2) + bv_to_nat xs * 2 ^ length l2 =\n     (bitval x * 2 ^ length xs + bv_to_nat xs) * 2 ^ length l2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>l2.\n     bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2\n\ngoal (1 subgoal):\n 1. bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>l2.\n     bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2\n\ngoal (1 subgoal):\n 1. bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2", ".."], ["proof (state)\nthis:\n  bv_to_nat (l1 @ l2) = bv_to_nat l1 * 2 ^ length l2 + bv_to_nat l2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_nat_bv [simp]: \"bv_to_nat (nat_to_bv n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv n) = n", "proof (induct n rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           bv_to_nat (nat_to_bv y) = y) \\<Longrightarrow>\n       bv_to_nat (nat_to_bv x) = x", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           bv_to_nat (nat_to_bv y) = y) \\<Longrightarrow>\n       bv_to_nat (nat_to_bv x) = x", "assume ind: \"!!j. j < n \\<Longrightarrow> bv_to_nat (nat_to_bv j) = j\""], ["proof (state)\nthis:\n  ?j < n \\<Longrightarrow> bv_to_nat (nat_to_bv ?j) = ?j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>y.\n           y < x \\<Longrightarrow>\n           bv_to_nat (nat_to_bv y) = y) \\<Longrightarrow>\n       bv_to_nat (nat_to_bv x) = x", "show \"bv_to_nat (nat_to_bv n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv n) = n", "proof (rule n_div_2_cases [of n])"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n\n 2. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "assume \"n = 0\""], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n\n 2. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv n) = n", "by simp"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv n) = n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "assume nn: \"n div 2 < n\""], ["proof (state)\nthis:\n  n div 2 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "assume n0: \"0 < n\""], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "from ind and nn"], ["proof (chain)\npicking this:\n  ?j < n \\<Longrightarrow> bv_to_nat (nat_to_bv ?j) = ?j\n  n div 2 < n", "have ind': \"bv_to_nat (nat_to_bv (n div 2)) = n div 2\""], ["proof (prove)\nusing this:\n  ?j < n \\<Longrightarrow> bv_to_nat (nat_to_bv ?j) = ?j\n  n div 2 < n\n\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv (n div 2)) = n div 2", "by blast"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv (n div 2)) = n div 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "from n0"], ["proof (chain)\npicking this:\n  0 < n", "have n0': \"n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n div 2 < n; 0 < n\\<rbrakk>\n    \\<Longrightarrow> bv_to_nat (nat_to_bv n) = n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv n) = n", "apply (subst nat_to_bv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv_helper n []) = n", "apply (simp only: nat_to_bv_helper.simps [of n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat\n     (if n = 0 then []\n      else nat_to_bv_helper (n div 2)\n            [if n mod 2 = 0 then \\<zero> else \\<one>]) =\n    n", "apply (simp only: n0' if_False)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat\n     (nat_to_bv_helper (n div 2)\n       [if n mod 2 = 0 then \\<zero> else \\<one>]) =\n    n", "apply (subst unfold_nat_to_bv_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat\n     (nat_to_bv_helper (n div 2) [] @\n      [if n mod 2 = 0 then \\<zero> else \\<one>]) =\n    n", "apply (subst bv_to_nat_dist_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv_helper (n div 2) []) *\n    2 ^ length [if n mod 2 = 0 then \\<zero> else \\<one>] +\n    bv_to_nat [if n mod 2 = 0 then \\<zero> else \\<one>] =\n    n", "apply (fold nat_to_bv_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv (n div 2)) *\n    2 ^ length [if n mod 2 = 0 then \\<zero> else \\<one>] +\n    bv_to_nat [if n mod 2 = 0 then \\<zero> else \\<one>] =\n    n", "apply (simp add: ind' split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n div 2 * 2 + bitval (if n mod 2 = 0 then \\<zero> else \\<one>) = n", "apply (cases \"n mod 2 = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. n mod 2 = 0 \\<Longrightarrow>\n    n div 2 * 2 + bitval (if n mod 2 = 0 then \\<zero> else \\<one>) = n\n 2. n mod 2 \\<noteq> 0 \\<Longrightarrow>\n    n div 2 * 2 + bitval (if n mod 2 = 0 then \\<zero> else \\<one>) = n", "proof (simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. n mod 2 = 0 \\<Longrightarrow> n div 2 * 2 = n\n 2. n mod 2 = Suc 0 \\<Longrightarrow> Suc (n div 2 * 2) = n", "assume \"n mod 2 = 0\""], ["proof (state)\nthis:\n  n mod 2 = 0\n\ngoal (2 subgoals):\n 1. n mod 2 = 0 \\<Longrightarrow> n div 2 * 2 = n\n 2. n mod 2 = Suc 0 \\<Longrightarrow> Suc (n div 2 * 2) = n", "with div_mult_mod_eq [of n 2]"], ["proof (chain)\npicking this:\n  n div 2 * 2 + n mod 2 = n\n  n mod 2 = 0", "show \"n div 2 * 2 = n\""], ["proof (prove)\nusing this:\n  n div 2 * 2 + n mod 2 = n\n  n mod 2 = 0\n\ngoal (1 subgoal):\n 1. n div 2 * 2 = n", "by simp"], ["proof (state)\nthis:\n  n div 2 * 2 = n\n\ngoal (1 subgoal):\n 1. n mod 2 = Suc 0 \\<Longrightarrow> Suc (n div 2 * 2) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n mod 2 = Suc 0 \\<Longrightarrow> Suc (n div 2 * 2) = n", "assume \"n mod 2 = Suc 0\""], ["proof (state)\nthis:\n  n mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. n mod 2 = Suc 0 \\<Longrightarrow> Suc (n div 2 * 2) = n", "with div_mult_mod_eq [of n 2]"], ["proof (chain)\npicking this:\n  n div 2 * 2 + n mod 2 = n\n  n mod 2 = Suc 0", "show \"Suc (n div 2 * 2) = n\""], ["proof (prove)\nusing this:\n  n div 2 * 2 + n mod 2 = n\n  n mod 2 = Suc 0\n\ngoal (1 subgoal):\n 1. Suc (n div 2 * 2) = n", "by arith"], ["proof (state)\nthis:\n  Suc (n div 2 * 2) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv n) = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv n) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat_type [simp]: \"bv_to_nat (norm_unsigned w) = bv_to_nat w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (norm_unsigned w) = bv_to_nat w", "by (rule bit_list_induct) simp_all"], ["", "lemma length_norm_unsigned_le [simp]: \"length (norm_unsigned w) \\<le> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_unsigned w) \\<le> length w", "by (rule bit_list_induct) simp_all"], ["", "lemma bv_to_nat_rew_msb: \"bv_msb w = \\<one> ==> bv_to_nat w = 2 ^ (length w - 1) + bv_to_nat (tl w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_nat w = 2 ^ (length w - 1) + bv_to_nat (tl w)", "by (rule bit_list_cases [of w]) simp_all"], ["", "lemma norm_unsigned_result: \"norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>", "proof (rule length_induct [of _ xs])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          norm_unsigned ys = [] \\<or>\n          bv_msb (norm_unsigned ys) = \\<one> \\<Longrightarrow>\n       norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>", "fix xs :: \"bit list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          norm_unsigned ys = [] \\<or>\n          bv_msb (norm_unsigned ys) = \\<one> \\<Longrightarrow>\n       norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>", "assume ind: \"\\<forall>ys. length ys < length xs --> norm_unsigned ys = [] \\<or> bv_msb (norm_unsigned ys) = \\<one>\""], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     norm_unsigned ys = [] \\<or> bv_msb (norm_unsigned ys) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          norm_unsigned ys = [] \\<or>\n          bv_msb (norm_unsigned ys) = \\<one> \\<Longrightarrow>\n       norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>", "show \"norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>", "proof (rule bit_list_cases [of xs],simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>", "fix bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>", "assume [simp]: \"xs = \\<zero>#bs\""], ["proof (state)\nthis:\n  xs = \\<zero> # bs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>", "from ind"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     norm_unsigned ys = [] \\<or> bv_msb (norm_unsigned ys) = \\<one>", "have \"length bs < length xs --> norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     norm_unsigned ys = [] \\<or> bv_msb (norm_unsigned ys) = \\<one>\n\ngoal (1 subgoal):\n 1. length bs < length xs \\<longrightarrow>\n    norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>", ".."], ["proof (state)\nthis:\n  length bs < length xs \\<longrightarrow>\n  norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>", "thus \"norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>\""], ["proof (prove)\nusing this:\n  length bs < length xs \\<longrightarrow>\n  norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>\n\ngoal (1 subgoal):\n 1. norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>", "by simp"], ["proof (state)\nthis:\n  norm_unsigned bs = [] \\<or> bv_msb (norm_unsigned bs) = \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_empty_bv_to_nat_zero:\n  assumes nw: \"norm_unsigned w = []\"\n  shows       \"bv_to_nat w = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "have \"bv_to_nat w = bv_to_nat (norm_unsigned w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w = bv_to_nat (norm_unsigned w)", "by simp"], ["proof (state)\nthis:\n  bv_to_nat w = bv_to_nat (norm_unsigned w)\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "also"], ["proof (state)\nthis:\n  bv_to_nat w = bv_to_nat (norm_unsigned w)\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "have \"... = bv_to_nat []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (norm_unsigned w) = bv_to_nat []", "by (subst nw) (rule refl)"], ["proof (state)\nthis:\n  bv_to_nat (norm_unsigned w) = bv_to_nat []\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "also"], ["proof (state)\nthis:\n  bv_to_nat (norm_unsigned w) = bv_to_nat []\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "have \"... = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat [] = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_nat [] = 0\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "finally"], ["proof (chain)\npicking this:\n  bv_to_nat w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  bv_to_nat w = 0\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "."], ["proof (state)\nthis:\n  bv_to_nat w = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat_lower_limit:\n  assumes w0: \"0 < bv_to_nat w\"\n  shows \"2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w", "from w0 and norm_unsigned_result [of w]"], ["proof (chain)\npicking this:\n  0 < bv_to_nat w\n  norm_unsigned w = [] \\<or> bv_msb (norm_unsigned w) = \\<one>", "have msbw: \"bv_msb (norm_unsigned w) = \\<one>\""], ["proof (prove)\nusing this:\n  0 < bv_to_nat w\n  norm_unsigned w = [] \\<or> bv_msb (norm_unsigned w) = \\<one>\n\ngoal (1 subgoal):\n 1. bv_msb (norm_unsigned w) = \\<one>", "by (auto simp add: norm_empty_bv_to_nat_zero)"], ["proof (state)\nthis:\n  bv_msb (norm_unsigned w) = \\<one>\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w", "have \"2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat (norm_unsigned w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat (norm_unsigned w)", "by (subst bv_to_nat_rew_msb [OF msbw],simp)"], ["proof (state)\nthis:\n  2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat (norm_unsigned w)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat (norm_unsigned w)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (norm_unsigned w) - 1) \\<le> bv_to_nat w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [simp del] = nat_to_bv_non0"], ["", "lemma norm_unsigned_length [intro!]: \"length (norm_unsigned w) \\<le> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_unsigned w) \\<le> length w", "by (subst norm_unsigned_def,rule rem_initial_length)"], ["", "lemma norm_unsigned_equal:\n  \"length (norm_unsigned w) = length w ==> norm_unsigned w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_unsigned w) = length w \\<Longrightarrow>\n    norm_unsigned w = w", "by (simp add: norm_unsigned_def,rule rem_initial_equal)"], ["", "lemma bv_extend_norm_unsigned: \"bv_extend (length w) \\<zero> (norm_unsigned w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length w) \\<zero> (norm_unsigned w) = w", "by (simp add: norm_unsigned_def,rule bv_extend_rem_initial)"], ["", "lemma norm_unsigned_append1 [simp]:\n  \"norm_unsigned xs \\<noteq> [] ==> norm_unsigned (xs @ ys) = norm_unsigned xs @ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    norm_unsigned (xs @ ys) = norm_unsigned xs @ ys", "by (simp add: norm_unsigned_def,rule rem_initial_append1)"], ["", "lemma norm_unsigned_append2 [simp]:\n  \"norm_unsigned xs = [] ==> norm_unsigned (xs @ ys) = norm_unsigned ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned xs = [] \\<Longrightarrow>\n    norm_unsigned (xs @ ys) = norm_unsigned ys", "by (simp add: norm_unsigned_def,rule rem_initial_append2)"], ["", "lemma bv_to_nat_zero_imp_empty:\n  \"bv_to_nat w = 0 \\<Longrightarrow> norm_unsigned w = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w = 0 \\<Longrightarrow> norm_unsigned w = []", "by (atomize (full), induct w rule: bit_list_induct) simp_all"], ["", "lemma bv_to_nat_nzero_imp_nempty:\n  \"bv_to_nat w \\<noteq> 0 \\<Longrightarrow> norm_unsigned w \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w \\<noteq> 0 \\<Longrightarrow> norm_unsigned w \\<noteq> []", "by (induct w rule: bit_list_induct) simp_all"], ["", "lemma nat_helper1:\n  assumes ass: \"nat_to_bv (bv_to_nat w) = norm_unsigned w\"\n  shows        \"nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "assume [simp]: \"x = \\<one>\""], ["proof (state)\nthis:\n  x = \\<one>\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "have \"nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n      nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n    nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>]", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>]\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "also"], ["proof (state)\nthis:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>]\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "have \"... = nat_to_bv (bv_to_nat w) @ [\\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>] =\n    nat_to_bv (bv_to_nat w) @ [\\<one>]", "by (subst div_add1_eq) simp"], ["proof (state)\nthis:\n  nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>] =\n  nat_to_bv (bv_to_nat w) @ [\\<one>]\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "also"], ["proof (state)\nthis:\n  nat_to_bv ((1 + 2 * bv_to_nat w) div 2) @ [\\<one>] =\n  nat_to_bv (bv_to_nat w) @ [\\<one>]\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "have \"... = norm_unsigned w @ [\\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (bv_to_nat w) @ [\\<one>] = norm_unsigned w @ [\\<one>]", "by (subst ass) (rule refl)"], ["proof (state)\nthis:\n  nat_to_bv (bv_to_nat w) @ [\\<one>] = norm_unsigned w @ [\\<one>]\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "also"], ["proof (state)\nthis:\n  nat_to_bv (bv_to_nat w) @ [\\<one>] = norm_unsigned w @ [\\<one>]\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "have \"... = norm_unsigned (w @ [\\<one>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned w @ [\\<one>] = norm_unsigned (w @ [\\<one>])", "by (cases \"norm_unsigned w\") simp_all"], ["proof (state)\nthis:\n  norm_unsigned w @ [\\<one>] = norm_unsigned (w @ [\\<one>])\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "finally"], ["proof (chain)\npicking this:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  norm_unsigned (w @ [\\<one>])", "have \"nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] = norm_unsigned (w @ [\\<one>])\""], ["proof (prove)\nusing this:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  norm_unsigned (w @ [\\<one>])\n\ngoal (1 subgoal):\n 1. nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n    norm_unsigned (w @ [\\<one>])", "."], ["proof (state)\nthis:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  norm_unsigned (w @ [\\<one>])\n\ngoal (2 subgoals):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. x = \\<one> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "then"], ["proof (chain)\npicking this:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  norm_unsigned (w @ [\\<one>])", "show ?thesis"], ["proof (prove)\nusing this:\n  nat_to_bv (Suc (2 * bv_to_nat w) div 2) @ [\\<one>] =\n  norm_unsigned (w @ [\\<one>])\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "by (simp add: nat_to_bv_non0)"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n\ngoal (1 subgoal):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "assume [simp]: \"x = \\<zero>\""], ["proof (state)\nthis:\n  x = \\<zero>\n\ngoal (1 subgoal):\n 1. x = \\<zero> \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "proof (cases \"bv_to_nat w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bv_to_nat w = 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. bv_to_nat w \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "assume \"bv_to_nat w = 0\""], ["proof (state)\nthis:\n  bv_to_nat w = 0\n\ngoal (2 subgoals):\n 1. bv_to_nat w = 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n 2. bv_to_nat w \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_nat w = 0\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "by (simp add: bv_to_nat_zero_imp_empty)"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n\ngoal (1 subgoal):\n 1. bv_to_nat w \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat w \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "assume \"bv_to_nat w \\<noteq> 0\""], ["proof (state)\nthis:\n  bv_to_nat w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. bv_to_nat w \\<noteq> 0 \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_nat w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_nat w \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w) = norm_unsigned (w @ [\\<zero>])", "apply (subst nat_to_bv_non0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < bv_to_nat w \\<Longrightarrow> 2 * bv_to_nat w \\<noteq> 0\n 2. 0 < bv_to_nat w \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w div 2) @\n    [if 2 * bv_to_nat w mod 2 = 0 then \\<zero> else \\<one>] =\n    norm_unsigned (w @ [\\<zero>])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_nat w \\<Longrightarrow>\n    nat_to_bv (2 * bv_to_nat w div 2) @\n    [if 2 * bv_to_nat w mod 2 = 0 then \\<zero> else \\<one>] =\n    norm_unsigned (w @ [\\<zero>])", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_nat w \\<Longrightarrow>\n    nat_to_bv (bv_to_nat w) @ [\\<zero>] = norm_unsigned (w @ [\\<zero>])", "apply (subst ass)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_nat w \\<Longrightarrow>\n    norm_unsigned w @ [\\<zero>] = norm_unsigned (w @ [\\<zero>])", "apply (cases \"norm_unsigned w\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < bv_to_nat w; norm_unsigned w = []\\<rbrakk>\n    \\<Longrightarrow> norm_unsigned w @ [\\<zero>] =\n                      norm_unsigned (w @ [\\<zero>])\n 2. \\<And>a list.\n       \\<lbrakk>0 < bv_to_nat w; norm_unsigned w = a # list\\<rbrakk>\n       \\<Longrightarrow> norm_unsigned w @ [\\<zero>] =\n                         norm_unsigned (w @ [\\<zero>])", "apply (simp_all add: norm_empty_bv_to_nat_zero)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat w + bitval x) = norm_unsigned (w @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_helper2: \"nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs", "have \"\\<forall>xs. nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # (rev xs)\" (is \"\\<forall>xs. ?P xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs.\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "show \"?P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs", "proof (rule length_induct [of _ xs])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) =\n          \\<one> # rev ys \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "fix xs :: \"bit list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) =\n          \\<one> # rev ys \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "assume ind: \"\\<forall>ys. length ys < length xs --> ?P ys\""], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) =\n          \\<one> # rev ys \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "show \"?P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs", "by (simp add: nat_to_bv_non0)"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "fix y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "assume [simp]: \"xs = y # ys\""], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) =\n       \\<one> # rev xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + bv_to_nat (rev ys @ [y])) =\n    \\<one> # rev ys @ [y]", "apply (subst bv_to_nat_dist_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv\n     (2 * 2 ^ length ys +\n      (bv_to_nat (rev ys) * 2 ^ length [y] + bv_to_nat [y])) =\n    \\<one> # rev ys @ [y]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "have \"nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n            nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y)", "by (simp add: ac_simps ac_simps)"], ["proof (state)\nthis:\n  nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n  nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y)\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "also"], ["proof (state)\nthis:\n  nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n  nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y)\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "have \"... = nat_to_bv (2 * (bv_to_nat (\\<one>#rev ys)) + bitval y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y) =\n    nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y)", "by simp"], ["proof (state)\nthis:\n  nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y) =\n  nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y)\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "also"], ["proof (state)\nthis:\n  nat_to_bv (2 * (2 ^ length ys + bv_to_nat (rev ys)) + bitval y) =\n  nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y)\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "have \"... = norm_unsigned (\\<one>#rev ys) @ [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n    norm_unsigned (\\<one> # rev ys) @ [y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n    norm_unsigned (\\<one> # rev ys) @ [y]", "from ind"], ["proof (chain)\npicking this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys", "have \"nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys", "by auto"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n    norm_unsigned (\\<one> # rev ys) @ [y]", "hence [simp]: \"nat_to_bv (2 ^ length ys + bv_to_nat (rev ys)) = \\<one> # rev ys\""], ["proof (prove)\nusing this:\n  nat_to_bv (2 ^ length (rev ys) + bv_to_nat (rev ys)) = \\<one> # rev ys\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length ys + bv_to_nat (rev ys)) = \\<one> # rev ys", "by simp"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length ys + bv_to_nat (rev ys)) = \\<one> # rev ys\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n    norm_unsigned (\\<one> # rev ys) @ [y]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n    norm_unsigned (\\<one> # rev ys) @ [y]", "apply (subst nat_helper1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nat_to_bv (bv_to_nat (\\<one> # rev ys)) =\n    norm_unsigned (\\<one> # rev ys)\n 2. norm_unsigned ((\\<one> # rev ys) @ [y]) =\n    norm_unsigned (\\<one> # rev ys) @ [y]", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n  norm_unsigned (\\<one> # rev ys) @ [y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n  norm_unsigned (\\<one> # rev ys) @ [y]\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "also"], ["proof (state)\nthis:\n  nat_to_bv (2 * bv_to_nat (\\<one> # rev ys) + bitval y) =\n  norm_unsigned (\\<one> # rev ys) @ [y]\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "have \"... = (\\<one>#rev ys) @ [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (\\<one> # rev ys) @ [y] = (\\<one> # rev ys) @ [y]", "by simp"], ["proof (state)\nthis:\n  norm_unsigned (\\<one> # rev ys) @ [y] = (\\<one> # rev ys) @ [y]\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "also"], ["proof (state)\nthis:\n  norm_unsigned (\\<one> # rev ys) @ [y] = (\\<one> # rev ys) @ [y]\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "have \"... = \\<one> # rev ys @ [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<one> # rev ys) @ [y] = \\<one> # rev ys @ [y]", "by simp"], ["proof (state)\nthis:\n  (\\<one> # rev ys) @ [y] = \\<one> # rev ys @ [y]\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "finally"], ["proof (chain)\npicking this:\n  nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n  \\<one> # rev ys @ [y]", "show \"nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n              \\<one> # rev ys @ [y]\""], ["proof (prove)\nusing this:\n  nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n  \\<one> # rev ys @ [y]\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n    \\<one> # rev ys @ [y]", "."], ["proof (state)\nthis:\n  nat_to_bv (2 * 2 ^ length ys + (bv_to_nat (rev ys) * 2 + bitval y)) =\n  \\<one> # rev ys @ [y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>xs.\n     nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs", "hence \"nat_to_bv (2 ^ length (rev (rev xs)) + bv_to_nat (rev (rev xs))) =\n      \\<one> # rev (rev xs)\""], ["proof (prove)\nusing this:\n  \\<forall>xs.\n     nat_to_bv (2 ^ length (rev xs) + bv_to_nat (rev xs)) = \\<one> # rev xs\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length (rev (rev xs)) + bv_to_nat (rev (rev xs))) =\n    \\<one> # rev (rev xs)", ".."], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length (rev (rev xs)) + bv_to_nat (rev (rev xs))) =\n  \\<one> # rev (rev xs)\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat_to_bv (2 ^ length (rev (rev xs)) + bv_to_nat (rev (rev xs))) =\n  \\<one> # rev (rev xs)\n\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs", "by simp"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_bv_nat [simp]: \"nat_to_bv (bv_to_nat w) = norm_unsigned w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (bv_to_nat w) = norm_unsigned w", "proof (rule bit_list_induct [of _ w],simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       nat_to_bv (bv_to_nat bs) = norm_unsigned bs \\<Longrightarrow>\n       nat_to_bv (2 ^ length bs + bv_to_nat bs) = \\<one> # bs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       nat_to_bv (bv_to_nat bs) = norm_unsigned bs \\<Longrightarrow>\n       nat_to_bv (2 ^ length bs + bv_to_nat bs) = \\<one> # bs", "assume \"nat_to_bv (bv_to_nat xs) = norm_unsigned xs\""], ["proof (state)\nthis:\n  nat_to_bv (bv_to_nat xs) = norm_unsigned xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       nat_to_bv (bv_to_nat bs) = norm_unsigned bs \\<Longrightarrow>\n       nat_to_bv (2 ^ length bs + bv_to_nat bs) = \\<one> # bs", "have \"bv_to_nat xs = bv_to_nat (norm_unsigned xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat xs = bv_to_nat (norm_unsigned xs)", "by simp"], ["proof (state)\nthis:\n  bv_to_nat xs = bv_to_nat (norm_unsigned xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       nat_to_bv (bv_to_nat bs) = norm_unsigned bs \\<Longrightarrow>\n       nat_to_bv (2 ^ length bs + bv_to_nat bs) = \\<one> # bs", "have \"bv_to_nat xs < 2 ^ length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat xs < 2 ^ length xs", "by (rule bv_to_nat_upper_range)"], ["proof (state)\nthis:\n  bv_to_nat xs < 2 ^ length xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       nat_to_bv (bv_to_nat bs) = norm_unsigned bs \\<Longrightarrow>\n       nat_to_bv (2 ^ length bs + bv_to_nat bs) = \\<one> # bs", "show \"nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs", "by (rule nat_helper2)"], ["proof (state)\nthis:\n  nat_to_bv (2 ^ length xs + bv_to_nat xs) = \\<one> # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat_qinj:\n  assumes one: \"bv_to_nat xs = bv_to_nat ys\"\n  and     len: \"length xs = length ys\"\n  shows        \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys", "from one"], ["proof (chain)\npicking this:\n  bv_to_nat xs = bv_to_nat ys", "have \"nat_to_bv (bv_to_nat xs) = nat_to_bv (bv_to_nat ys)\""], ["proof (prove)\nusing this:\n  bv_to_nat xs = bv_to_nat ys\n\ngoal (1 subgoal):\n 1. nat_to_bv (bv_to_nat xs) = nat_to_bv (bv_to_nat ys)", "by simp"], ["proof (state)\nthis:\n  nat_to_bv (bv_to_nat xs) = nat_to_bv (bv_to_nat ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "hence xsys: \"norm_unsigned xs = norm_unsigned ys\""], ["proof (prove)\nusing this:\n  nat_to_bv (bv_to_nat xs) = nat_to_bv (bv_to_nat ys)\n\ngoal (1 subgoal):\n 1. norm_unsigned xs = norm_unsigned ys", "by simp"], ["proof (state)\nthis:\n  norm_unsigned xs = norm_unsigned ys\n\ngoal (1 subgoal):\n 1. xs = ys", "have \"xs = bv_extend (length xs) \\<zero> (norm_unsigned xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = bv_extend (length xs) \\<zero> (norm_unsigned xs)", "by (simp add: bv_extend_norm_unsigned)"], ["proof (state)\nthis:\n  xs = bv_extend (length xs) \\<zero> (norm_unsigned xs)\n\ngoal (1 subgoal):\n 1. xs = ys", "also"], ["proof (state)\nthis:\n  xs = bv_extend (length xs) \\<zero> (norm_unsigned xs)\n\ngoal (1 subgoal):\n 1. xs = ys", "have \"... = bv_extend (length ys) \\<zero> (norm_unsigned ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length xs) \\<zero> (norm_unsigned xs) =\n    bv_extend (length ys) \\<zero> (norm_unsigned ys)", "by (simp add: xsys len)"], ["proof (state)\nthis:\n  bv_extend (length xs) \\<zero> (norm_unsigned xs) =\n  bv_extend (length ys) \\<zero> (norm_unsigned ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "also"], ["proof (state)\nthis:\n  bv_extend (length xs) \\<zero> (norm_unsigned xs) =\n  bv_extend (length ys) \\<zero> (norm_unsigned ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "have \"... = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length ys) \\<zero> (norm_unsigned ys) = ys", "by (simp add: bv_extend_norm_unsigned)"], ["proof (state)\nthis:\n  bv_extend (length ys) \\<zero> (norm_unsigned ys) = ys\n\ngoal (1 subgoal):\n 1. xs = ys", "finally"], ["proof (chain)\npicking this:\n  xs = ys", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. xs = ys", "."], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_unsigned_nat_to_bv [simp]:\n  \"norm_unsigned (nat_to_bv n) = nat_to_bv n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) = nat_to_bv n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) = nat_to_bv n", "have \"norm_unsigned (nat_to_bv n) = nat_to_bv (bv_to_nat (norm_unsigned (nat_to_bv n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) =\n    nat_to_bv (bv_to_nat (norm_unsigned (nat_to_bv n)))", "by (subst nat_bv_nat) simp"], ["proof (state)\nthis:\n  norm_unsigned (nat_to_bv n) =\n  nat_to_bv (bv_to_nat (norm_unsigned (nat_to_bv n)))\n\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) = nat_to_bv n", "also"], ["proof (state)\nthis:\n  norm_unsigned (nat_to_bv n) =\n  nat_to_bv (bv_to_nat (norm_unsigned (nat_to_bv n)))\n\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) = nat_to_bv n", "have \"... = nat_to_bv n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_to_bv (bv_to_nat (norm_unsigned (nat_to_bv n))) = nat_to_bv n", "by simp"], ["proof (state)\nthis:\n  nat_to_bv (bv_to_nat (norm_unsigned (nat_to_bv n))) = nat_to_bv n\n\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) = nat_to_bv n", "finally"], ["proof (chain)\npicking this:\n  norm_unsigned (nat_to_bv n) = nat_to_bv n", "show ?thesis"], ["proof (prove)\nusing this:\n  norm_unsigned (nat_to_bv n) = nat_to_bv n\n\ngoal (1 subgoal):\n 1. norm_unsigned (nat_to_bv n) = nat_to_bv n", "."], ["proof (state)\nthis:\n  norm_unsigned (nat_to_bv n) = nat_to_bv n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_nat_to_bv_upper_limit:\n  assumes nk: \"n \\<le> 2 ^ k - 1\"\n  shows       \"length (nat_to_bv n) \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv n) \\<le> k", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k\n 2. n \\<noteq> 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k\n 2. n \\<noteq> 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. length (nat_to_bv n) \\<le> k", "by (simp add: nat_to_bv_def nat_to_bv_helper.simps)"], ["proof (state)\nthis:\n  length (nat_to_bv n) \\<le> k\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k", "case False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k", "hence n0: \"0 < n\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < n", "by simp"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> length (nat_to_bv n) \\<le> k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv n) \\<le> k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "assume \"~ length (nat_to_bv n) \\<le> k\""], ["proof (state)\nthis:\n  \\<not> length (nat_to_bv n) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "hence \"k < length (nat_to_bv n)\""], ["proof (prove)\nusing this:\n  \\<not> length (nat_to_bv n) \\<le> k\n\ngoal (1 subgoal):\n 1. k < length (nat_to_bv n)", "by simp"], ["proof (state)\nthis:\n  k < length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "hence \"k \\<le> length (nat_to_bv n) - 1\""], ["proof (prove)\nusing this:\n  k < length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. k \\<le> length (nat_to_bv n) - 1", "by arith"], ["proof (state)\nthis:\n  k \\<le> length (nat_to_bv n) - 1\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "hence \"(2::nat) ^ k \\<le> 2 ^ (length (nat_to_bv n) - 1)\""], ["proof (prove)\nusing this:\n  k \\<le> length (nat_to_bv n) - 1\n\ngoal (1 subgoal):\n 1. 2 ^ k \\<le> 2 ^ (length (nat_to_bv n) - 1)", "by simp"], ["proof (state)\nthis:\n  2 ^ k \\<le> 2 ^ (length (nat_to_bv n) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ k \\<le> 2 ^ (length (nat_to_bv n) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "have \"... = 2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (nat_to_bv n) - 1) =\n    2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv n) - 1) =\n  2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ (length (nat_to_bv n) - 1) =\n  2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "have \"... \\<le> bv_to_nat (nat_to_bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)\n    \\<le> bv_to_nat (nat_to_bv n)", "by (rule bv_to_nat_lower_limit) (simp add: n0)"], ["proof (state)\nthis:\n  2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)\n  \\<le> bv_to_nat (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ (length (norm_unsigned (nat_to_bv n)) - 1)\n  \\<le> bv_to_nat (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "have \"... = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv n) = n", "by simp"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv n) = n\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  2 ^ k \\<le> n", "have \"2 ^ k \\<le> n\""], ["proof (prove)\nusing this:\n  2 ^ k \\<le> n\n\ngoal (1 subgoal):\n 1. 2 ^ k \\<le> n", "."], ["proof (state)\nthis:\n  2 ^ k \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "with n0"], ["proof (chain)\npicking this:\n  0 < n\n  2 ^ k \\<le> n", "have \"2 ^ k - 1 < n\""], ["proof (prove)\nusing this:\n  0 < n\n  2 ^ k \\<le> n\n\ngoal (1 subgoal):\n 1. 2 ^ k - 1 < n", "by arith"], ["proof (state)\nthis:\n  2 ^ k - 1 < n\n\ngoal (1 subgoal):\n 1. \\<not> length (nat_to_bv n) \\<le> k \\<Longrightarrow> False", "with nk"], ["proof (chain)\npicking this:\n  n \\<le> 2 ^ k - 1\n  2 ^ k - 1 < n", "show False"], ["proof (prove)\nusing this:\n  n \\<le> 2 ^ k - 1\n  2 ^ k - 1 < n\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (nat_to_bv n) \\<le> k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_nat_to_bv_lower_limit:\n  assumes nk: \"2 ^ k \\<le> n\"\n  shows       \"k < length (nat_to_bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (nat_to_bv n)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "assume \"~ k < length (nat_to_bv n)\""], ["proof (state)\nthis:\n  \\<not> k < length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "hence lnk: \"length (nat_to_bv n) \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k < length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. length (nat_to_bv n) \\<le> k", "by simp"], ["proof (state)\nthis:\n  length (nat_to_bv n) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "have \"n = bv_to_nat (nat_to_bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = bv_to_nat (nat_to_bv n)", "by simp"], ["proof (state)\nthis:\n  n = bv_to_nat (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  n = bv_to_nat (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "have \"... < 2 ^ length (nat_to_bv n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (nat_to_bv n) < 2 ^ length (nat_to_bv n)", "by (rule bv_to_nat_upper_range)"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv n) < 2 ^ length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  bv_to_nat (nat_to_bv n) < 2 ^ length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "from lnk"], ["proof (chain)\npicking this:\n  length (nat_to_bv n) \\<le> k", "have \"... \\<le> 2 ^ k\""], ["proof (prove)\nusing this:\n  length (nat_to_bv n) \\<le> k\n\ngoal (1 subgoal):\n 1. 2 ^ length (nat_to_bv n) \\<le> 2 ^ k", "by simp"], ["proof (state)\nthis:\n  2 ^ length (nat_to_bv n) \\<le> 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  n < 2 ^ k", "have \"n < 2 ^ k\""], ["proof (prove)\nusing this:\n  n < 2 ^ k\n\ngoal (1 subgoal):\n 1. n < 2 ^ k", "."], ["proof (state)\nthis:\n  n < 2 ^ k\n\ngoal (1 subgoal):\n 1. \\<not> k < length (nat_to_bv n) \\<Longrightarrow> False", "with nk"], ["proof (chain)\npicking this:\n  2 ^ k \\<le> n\n  n < 2 ^ k", "show False"], ["proof (prove)\nusing this:\n  2 ^ k \\<le> n\n  n < 2 ^ k\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unsigned Arithmetic Operations\\<close>"], ["", "definition\n  bv_add :: \"[bit list, bit list ] => bit list\" where\n  \"bv_add w1 w2 = nat_to_bv (bv_to_nat w1 + bv_to_nat w2)\""], ["", "lemma bv_add_type1 [simp]: \"bv_add (norm_unsigned w1) w2 = bv_add w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_add (norm_unsigned w1) w2 = bv_add w1 w2", "by (simp add: bv_add_def)"], ["", "lemma bv_add_type2 [simp]: \"bv_add w1 (norm_unsigned w2) = bv_add w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_add w1 (norm_unsigned w2) = bv_add w1 w2", "by (simp add: bv_add_def)"], ["", "lemma bv_add_returntype [simp]: \"norm_unsigned (bv_add w1 w2) = bv_add w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (bv_add w1 w2) = bv_add w1 w2", "by (simp add: bv_add_def)"], ["", "lemma bv_add_length: \"length (bv_add w1 w2) \\<le> Suc (max (length w1) (length w2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_add w1 w2) \\<le> Suc (max (length w1) (length w2))", "proof (unfold bv_add_def,rule length_nat_to_bv_upper_limit)"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "from bv_to_nat_upper_range [of w1] and bv_to_nat_upper_range [of w2]"], ["proof (chain)\npicking this:\n  bv_to_nat w1 < 2 ^ length w1\n  bv_to_nat w2 < 2 ^ length w2", "have \"bv_to_nat w1 + bv_to_nat w2 \\<le> (2 ^ length w1 - 1) + (2 ^ length w2 - 1)\""], ["proof (prove)\nusing this:\n  bv_to_nat w1 < 2 ^ length w1\n  bv_to_nat w2 < 2 ^ length w2\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ length w1 - 1 + (2 ^ length w2 - 1)", "by arith"], ["proof (state)\nthis:\n  bv_to_nat w1 + bv_to_nat w2 \\<le> 2 ^ length w1 - 1 + (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "also"], ["proof (state)\nthis:\n  bv_to_nat w1 + bv_to_nat w2 \\<le> 2 ^ length w1 - 1 + (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "have \"... \\<le>\n      max (2 ^ length w1 - 1) (2 ^ length w2 - 1) + max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 + (2 ^ length w2 - 1)\n    \\<le> max (2 ^ length w1 - 1) (2 ^ length w2 - 1) +\n          max (2 ^ length w1 - 1) (2 ^ length w2 - 1)", "by (rule add_mono,safe intro!: max.cobounded1 max.cobounded2)"], ["proof (state)\nthis:\n  2 ^ length w1 - 1 + (2 ^ length w2 - 1)\n  \\<le> max (2 ^ length w1 - 1) (2 ^ length w2 - 1) +\n        max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "also"], ["proof (state)\nthis:\n  2 ^ length w1 - 1 + (2 ^ length w2 - 1)\n  \\<le> max (2 ^ length w1 - 1) (2 ^ length w2 - 1) +\n        max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "have \"... = 2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (2 ^ length w1 - 1) (2 ^ length w2 - 1) +\n    max (2 ^ length w1 - 1) (2 ^ length w2 - 1) =\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)", "by simp"], ["proof (state)\nthis:\n  max (2 ^ length w1 - 1) (2 ^ length w2 - 1) +\n  max (2 ^ length w1 - 1) (2 ^ length w2 - 1) =\n  2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "also"], ["proof (state)\nthis:\n  max (2 ^ length w1 - 1) (2 ^ length w2 - 1) +\n  max (2 ^ length w1 - 1) (2 ^ length w2 - 1) =\n  2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "have \"... \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "proof (cases \"length w1 \\<le> length w2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n 2. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "assume w1w2: \"length w1 \\<le> length w2\""], ["proof (state)\nthis:\n  length w1 \\<le> length w2\n\ngoal (2 subgoals):\n 1. length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n 2. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "hence \"(2::nat) ^ length w1 \\<le> 2 ^ length w2\""], ["proof (prove)\nusing this:\n  length w1 \\<le> length w2\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 \\<le> 2 ^ length w2", "by simp"], ["proof (state)\nthis:\n  2 ^ length w1 \\<le> 2 ^ length w2\n\ngoal (2 subgoals):\n 1. length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n 2. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "hence \"(2::nat) ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\""], ["proof (prove)\nusing this:\n  2 ^ length w1 \\<le> 2 ^ length w2\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1", "by arith"], ["proof (state)\nthis:\n  2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\n\ngoal (2 subgoals):\n 1. length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n 2. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "with w1w2"], ["proof (chain)\npicking this:\n  length w1 \\<le> length w2\n  2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  length w1 \\<le> length w2\n  2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\n\ngoal (1 subgoal):\n 1. 2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "by (simp add: diff_mult_distrib2 split: split_max)"], ["proof (state)\nthis:\n  2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n  \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n\ngoal (1 subgoal):\n 1. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "assume [simp]: \"~ (length w1 \\<le> length w2)\""], ["proof (state)\nthis:\n  \\<not> length w1 \\<le> length w2\n\ngoal (1 subgoal):\n 1. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "have \"~ ((2::nat) ^ length w1 - 1 \\<le> 2 ^ length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow> False", "assume \"(2::nat) ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\""], ["proof (state)\nthis:\n  2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow> False", "hence \"((2::nat) ^ length w1 - 1) + 1 \\<le> (2 ^ length w2 - 1) + 1\""], ["proof (prove)\nusing this:\n  2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 + 1 \\<le> 2 ^ length w2 - 1 + 1", "by (rule add_right_mono)"], ["proof (state)\nthis:\n  2 ^ length w1 - 1 + 1 \\<le> 2 ^ length w2 - 1 + 1\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow> False", "hence \"(2::nat) ^ length w1 \\<le> 2 ^ length w2\""], ["proof (prove)\nusing this:\n  2 ^ length w1 - 1 + 1 \\<le> 2 ^ length w2 - 1 + 1\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 \\<le> 2 ^ length w2", "by simp"], ["proof (state)\nthis:\n  2 ^ length w1 \\<le> 2 ^ length w2\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow> False", "hence \"length w1 \\<le> length w2\""], ["proof (prove)\nusing this:\n  2 ^ length w1 \\<le> 2 ^ length w2\n\ngoal (1 subgoal):\n 1. length w1 \\<le> length w2", "by simp"], ["proof (state)\nthis:\n  length w1 \\<le> length w2\n\ngoal (1 subgoal):\n 1. 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length w1 \\<le> length w2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\n\ngoal (1 subgoal):\n 1. \\<not> length w1 \\<le> length w2 \\<Longrightarrow>\n    2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> 2 ^ length w1 - 1 \\<le> 2 ^ length w2 - 1\n\ngoal (1 subgoal):\n 1. 2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "by (simp add: diff_mult_distrib2 split: split_max)"], ["proof (state)\nthis:\n  2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n  \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 * max (2 ^ length w1 - 1) (2 ^ length w2 - 1)\n  \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "finally"], ["proof (chain)\npicking this:\n  bv_to_nat w1 + bv_to_nat w2\n  \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2", "show \"bv_to_nat w1 + bv_to_nat w2 \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1\""], ["proof (prove)\nusing this:\n  bv_to_nat w1 + bv_to_nat w2\n  \\<le> 2 ^ Suc (max (length w1) (length w2)) - 2\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 + bv_to_nat w2\n    \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1", "by arith"], ["proof (state)\nthis:\n  bv_to_nat w1 + bv_to_nat w2\n  \\<le> 2 ^ Suc (max (length w1) (length w2)) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  bv_mult :: \"[bit list, bit list ] => bit list\" where\n  \"bv_mult w1 w2 = nat_to_bv (bv_to_nat w1 * bv_to_nat w2)\""], ["", "lemma bv_mult_type1 [simp]: \"bv_mult (norm_unsigned w1) w2 = bv_mult w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_mult (norm_unsigned w1) w2 = bv_mult w1 w2", "by (simp add: bv_mult_def)"], ["", "lemma bv_mult_type2 [simp]: \"bv_mult w1 (norm_unsigned w2) = bv_mult w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_mult w1 (norm_unsigned w2) = bv_mult w1 w2", "by (simp add: bv_mult_def)"], ["", "lemma bv_mult_returntype [simp]: \"norm_unsigned (bv_mult w1 w2) = bv_mult w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned (bv_mult w1 w2) = bv_mult w1 w2", "by (simp add: bv_mult_def)"], ["", "lemma bv_mult_length: \"length (bv_mult w1 w2) \\<le> length w1 + length w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_mult w1 w2) \\<le> length w1 + length w2", "proof (unfold bv_mult_def,rule length_nat_to_bv_upper_limit)"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "from bv_to_nat_upper_range [of w1] and bv_to_nat_upper_range [of w2]"], ["proof (chain)\npicking this:\n  bv_to_nat w1 < 2 ^ length w1\n  bv_to_nat w2 < 2 ^ length w2", "have h: \"bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and> bv_to_nat w2 \\<le> 2 ^ length w2 - 1\""], ["proof (prove)\nusing this:\n  bv_to_nat w1 < 2 ^ length w1\n  bv_to_nat w2 < 2 ^ length w2\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1", "by arith"], ["proof (state)\nthis:\n  bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n  bv_to_nat w2 \\<le> 2 ^ length w2 - 1\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "have \"bv_to_nat w1 * bv_to_nat w2 \\<le> (2 ^ length w1 - 1) * (2 ^ length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2\n    \\<le> (2 ^ length w1 - 1) * (2 ^ length w2 - 1)", "apply (cut_tac h)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow>\n    bv_to_nat w1 * bv_to_nat w2\n    \\<le> (2 ^ length w1 - 1) * (2 ^ length w2 - 1)", "apply (rule mult_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow>\n    bv_to_nat w1 \\<le> 2 ^ length w1 - 1\n 2. bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1\n 3. bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow>\n    0 \\<le> 2 ^ length w1 - 1\n 4. bv_to_nat w1 \\<le> 2 ^ length w1 - 1 \\<and>\n    bv_to_nat w2 \\<le> 2 ^ length w2 - 1 \\<Longrightarrow>\n    0 \\<le> bv_to_nat w2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_to_nat w1 * bv_to_nat w2\n  \\<le> (2 ^ length w1 - 1) * (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "also"], ["proof (state)\nthis:\n  bv_to_nat w1 * bv_to_nat w2\n  \\<le> (2 ^ length w1 - 1) * (2 ^ length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "have \"... < 2 ^ length w1 * 2 ^ length w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 ^ length w1 - 1) * (2 ^ length w2 - 1)\n    < 2 ^ length w1 * 2 ^ length w2", "by (rule mult_strict_mono,auto)"], ["proof (state)\nthis:\n  (2 ^ length w1 - 1) * (2 ^ length w2 - 1) < 2 ^ length w1 * 2 ^ length w2\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "also"], ["proof (state)\nthis:\n  (2 ^ length w1 - 1) * (2 ^ length w2 - 1) < 2 ^ length w1 * 2 ^ length w2\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "have \"... = 2 ^ (length w1 + length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length w1 * 2 ^ length w2 = 2 ^ (length w1 + length w2)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  2 ^ length w1 * 2 ^ length w2 = 2 ^ (length w1 + length w2)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "finally"], ["proof (chain)\npicking this:\n  bv_to_nat w1 * bv_to_nat w2 < 2 ^ (length w1 + length w2)", "show \"bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1\""], ["proof (prove)\nusing this:\n  bv_to_nat w1 * bv_to_nat w2 < 2 ^ (length w1 + length w2)\n\ngoal (1 subgoal):\n 1. bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1", "by arith"], ["proof (state)\nthis:\n  bv_to_nat w1 * bv_to_nat w2 \\<le> 2 ^ (length w1 + length w2) - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Signed Vectors\\<close>"], ["", "primrec norm_signed :: \"bit list => bit list\" where\n    norm_signed_Nil: \"norm_signed [] = []\"\n  | norm_signed_Cons: \"norm_signed (b#bs) =\n      (case b of\n        \\<zero> => if norm_unsigned bs = [] then [] else b#norm_unsigned bs\n      | \\<one> => b#rem_initial b bs)\""], ["", "lemma norm_signed0 [simp]: \"norm_signed [\\<zero>] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed [\\<zero>] = []", "by simp"], ["", "lemma norm_signed1 [simp]: \"norm_signed [\\<one>] = [\\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed [\\<one>] = [\\<one>]", "by simp"], ["", "lemma norm_signed01 [simp]: \"norm_signed (\\<zero>#\\<one>#xs) = \\<zero>#\\<one>#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (\\<zero> # \\<one> # xs) = \\<zero> # \\<one> # xs", "by simp"], ["", "lemma norm_signed00 [simp]: \"norm_signed (\\<zero>#\\<zero>#xs) = norm_signed (\\<zero>#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (\\<zero> # \\<zero> # xs) = norm_signed (\\<zero> # xs)", "by simp"], ["", "lemma norm_signed10 [simp]: \"norm_signed (\\<one>#\\<zero>#xs) = \\<one>#\\<zero>#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (\\<one> # \\<zero> # xs) = \\<one> # \\<zero> # xs", "by simp"], ["", "lemma norm_signed11 [simp]: \"norm_signed (\\<one>#\\<one>#xs) = norm_signed (\\<one>#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (\\<one> # \\<one> # xs) = norm_signed (\\<one> # xs)", "by simp"], ["", "lemmas [simp del] = norm_signed_Cons"], ["", "definition\n  int_to_bv :: \"int => bit list\" where\n  \"int_to_bv n = (if 0 \\<le> n\n                 then norm_signed (\\<zero>#nat_to_bv (nat n))\n                 else norm_signed (bv_not (\\<zero>#nat_to_bv (nat (-n- 1)))))\""], ["", "lemma int_to_bv_ge0 [simp]: \"0 \\<le> n ==> int_to_bv n = norm_signed (\\<zero> # nat_to_bv (nat n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> n \\<Longrightarrow>\n    int_to_bv n = norm_signed (\\<zero> # nat_to_bv (nat n))", "by (simp add: int_to_bv_def)"], ["", "lemma int_to_bv_lt0 [simp]:\n    \"n < 0 ==> int_to_bv n = norm_signed (bv_not (\\<zero>#nat_to_bv (nat (-n- 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 0 \\<Longrightarrow>\n    int_to_bv n = norm_signed (bv_not (\\<zero> # nat_to_bv (nat (- n - 1))))", "by (simp add: int_to_bv_def)"], ["", "lemma norm_signed_idem [simp]: \"norm_signed (norm_signed w) = norm_signed w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (norm_signed w) = norm_signed w", "proof (rule bit_list_induct [of _ w], simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<zero> # bs)) = norm_signed (\\<zero> # bs)\n 2. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<zero> # bs)) = norm_signed (\\<zero> # bs)\n 2. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "assume eq: \"norm_signed (norm_signed xs) = norm_signed xs\""], ["proof (state)\nthis:\n  norm_signed (norm_signed xs) = norm_signed xs\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<zero> # bs)) = norm_signed (\\<zero> # bs)\n 2. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "show \"norm_signed (norm_signed (\\<zero>#xs)) = norm_signed (\\<zero>#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (norm_signed (\\<zero> # xs)) = norm_signed (\\<zero> # xs)", "proof (rule bit_list_cases [of xs],simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<zero> # bs)) = norm_signed (\\<zero> # bs)", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<zero> # bs)) = norm_signed (\\<zero> # bs)", "assume \"xs = \\<zero>#ys\""], ["proof (state)\nthis:\n  xs = \\<zero> # ys\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<zero> # bs)) = norm_signed (\\<zero> # bs)", "from this [symmetric] and eq"], ["proof (chain)\npicking this:\n  \\<zero> # ys = xs\n  norm_signed (norm_signed xs) = norm_signed xs", "show \"norm_signed (norm_signed (\\<zero>#ys)) = norm_signed (\\<zero>#ys)\""], ["proof (prove)\nusing this:\n  \\<zero> # ys = xs\n  norm_signed (norm_signed xs) = norm_signed xs\n\ngoal (1 subgoal):\n 1. norm_signed (norm_signed (\\<zero> # ys)) = norm_signed (\\<zero> # ys)", "by simp"], ["proof (state)\nthis:\n  norm_signed (norm_signed (\\<zero> # ys)) = norm_signed (\\<zero> # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm_signed (norm_signed (\\<zero> # xs)) = norm_signed (\\<zero> # xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "assume eq: \"norm_signed (norm_signed xs) = norm_signed xs\""], ["proof (state)\nthis:\n  norm_signed (norm_signed xs) = norm_signed xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed (norm_signed bs) = norm_signed bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "show \"norm_signed (norm_signed (\\<one>#xs)) = norm_signed (\\<one>#xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (norm_signed (\\<one> # xs)) = norm_signed (\\<one> # xs)", "proof (rule bit_list_cases [of xs],simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<one> # bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<one> # bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "assume \"xs = \\<one>#ys\""], ["proof (state)\nthis:\n  xs = \\<one> # ys\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<one> # bs \\<Longrightarrow>\n       norm_signed (norm_signed (\\<one> # bs)) = norm_signed (\\<one> # bs)", "from this [symmetric] and eq"], ["proof (chain)\npicking this:\n  \\<one> # ys = xs\n  norm_signed (norm_signed xs) = norm_signed xs", "show \"norm_signed (norm_signed (\\<one>#ys)) = norm_signed (\\<one>#ys)\""], ["proof (prove)\nusing this:\n  \\<one> # ys = xs\n  norm_signed (norm_signed xs) = norm_signed xs\n\ngoal (1 subgoal):\n 1. norm_signed (norm_signed (\\<one> # ys)) = norm_signed (\\<one> # ys)", "by simp"], ["proof (state)\nthis:\n  norm_signed (norm_signed (\\<one> # ys)) = norm_signed (\\<one> # ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  norm_signed (norm_signed (\\<one> # xs)) = norm_signed (\\<one> # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  bv_to_int :: \"bit list => int\" where\n  \"bv_to_int w =\n    (case bv_msb w of \\<zero> => int (bv_to_nat w)\n    | \\<one> => - int (bv_to_nat (bv_not w) + 1))\""], ["", "lemma bv_to_int_Nil [simp]: \"bv_to_int [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int [] = 0", "by (simp add: bv_to_int_def)"], ["", "lemma bv_to_int_Cons0 [simp]: \"bv_to_int (\\<zero>#bs) = int (bv_to_nat bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (\\<zero> # bs) = int (bv_to_nat bs)", "by (simp add: bv_to_int_def)"], ["", "lemma bv_to_int_Cons1 [simp]: \"bv_to_int (\\<one>#bs) = - int (bv_to_nat (bv_not bs) + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (\\<one> # bs) = - int (bv_to_nat (bv_not bs) + 1)", "by (simp add: bv_to_int_def)"], ["", "lemma bv_to_int_type [simp]: \"bv_to_int (norm_signed w) = bv_to_int w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = bv_to_int w", "proof (rule bit_list_induct [of _ w], simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<zero> # bs)) = int (bv_to_nat bs)\n 2. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<zero> # bs)) = int (bv_to_nat bs)\n 2. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "assume ind: \"bv_to_int (norm_signed xs) = bv_to_int xs\""], ["proof (state)\nthis:\n  bv_to_int (norm_signed xs) = bv_to_int xs\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<zero> # bs)) = int (bv_to_nat bs)\n 2. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "show \"bv_to_int (norm_signed (\\<zero>#xs)) = int (bv_to_nat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed (\\<zero> # xs)) = int (bv_to_nat xs)", "proof (rule bit_list_cases [of xs], simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<zero> # bs)) = int (bv_to_nat bs)", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<zero> # bs)) = int (bv_to_nat bs)", "assume [simp]: \"xs = \\<zero>#ys\""], ["proof (state)\nthis:\n  xs = \\<zero> # ys\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<zero> # bs)) = int (bv_to_nat bs)", "from ind"], ["proof (chain)\npicking this:\n  bv_to_int (norm_signed xs) = bv_to_int xs", "show \"bv_to_int (norm_signed (\\<zero>#ys)) = int (bv_to_nat ys)\""], ["proof (prove)\nusing this:\n  bv_to_int (norm_signed xs) = bv_to_int xs\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed (\\<zero> # ys)) = int (bv_to_nat ys)", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed (\\<zero> # ys)) = int (bv_to_nat ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_int (norm_signed (\\<zero> # xs)) = int (bv_to_nat xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "assume ind: \"bv_to_int (norm_signed xs) = bv_to_int xs\""], ["proof (state)\nthis:\n  bv_to_int (norm_signed xs) = bv_to_int xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       bv_to_int (norm_signed bs) = bv_to_int bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "show \"bv_to_int (norm_signed (\\<one>#xs)) = -1 - int (bv_to_nat (bv_not xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed (\\<one> # xs)) =\n    - 1 - int (bv_to_nat (bv_not xs))", "proof (rule bit_list_cases [of xs], simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "fix ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "assume [simp]: \"xs = \\<one>#ys\""], ["proof (state)\nthis:\n  xs = \\<one> # ys\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       xs = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed (\\<one> # bs)) =\n       - 1 - int (bv_to_nat (bv_not bs))", "from ind"], ["proof (chain)\npicking this:\n  bv_to_int (norm_signed xs) = bv_to_int xs", "show \"bv_to_int (norm_signed (\\<one>#ys)) = -1 - int (bv_to_nat (bv_not ys))\""], ["proof (prove)\nusing this:\n  bv_to_int (norm_signed xs) = bv_to_int xs\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed (\\<one> # ys)) =\n    - 1 - int (bv_to_nat (bv_not ys))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed (\\<one> # ys)) = - 1 - int (bv_to_nat (bv_not ys))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_int (norm_signed (\\<one> # xs)) = - 1 - int (bv_to_nat (bv_not xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_int_upper_range: \"bv_to_int w < 2 ^ (length w - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w < 2 ^ (length w - 1)", "proof (rule bit_list_cases [of w],simp_all add: bv_to_nat_upper_range)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "fix bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "have \"-1 - int (bv_to_nat (bv_not bs)) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 - int (bv_to_nat (bv_not bs)) \\<le> 0", "by simp"], ["proof (state)\nthis:\n  - 1 - int (bv_to_nat (bv_not bs)) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "also"], ["proof (state)\nthis:\n  - 1 - int (bv_to_nat (bv_not bs)) \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "have \"... < 2 ^ length bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ length bs", "by (induct bs) simp_all"], ["proof (state)\nthis:\n  0 < 2 ^ length bs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "finally"], ["proof (chain)\npicking this:\n  - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "show \"-1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs\""], ["proof (prove)\nusing this:\n  - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs\n\ngoal (1 subgoal):\n 1. - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs", "."], ["proof (state)\nthis:\n  - 1 - int (bv_to_nat (bv_not bs)) < 2 ^ length bs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_int_lower_range: \"- (2 ^ (length w - 1)) \\<le> bv_to_int w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w - 1)) \\<le> bv_to_int w", "proof (rule bit_list_cases [of w],simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "fix bs :: \"bit list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "have \"- (2 ^ length bs) \\<le> (0::int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ length bs) \\<le> 0", "by (induct bs) simp_all"], ["proof (state)\nthis:\n  - (2 ^ length bs) \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "also"], ["proof (state)\nthis:\n  - (2 ^ length bs) \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "have \"... \\<le> int (bv_to_nat bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> int (bv_to_nat bs)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> int (bv_to_nat bs)\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ length bs) \\<le> int (bv_to_nat bs)", "show \"- (2 ^ length bs) \\<le> int (bv_to_nat bs)\""], ["proof (prove)\nusing this:\n  - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n\ngoal (1 subgoal):\n 1. - (2 ^ length bs) \\<le> int (bv_to_nat bs)", "."], ["proof (state)\nthis:\n  - (2 ^ length bs) \\<le> int (bv_to_nat bs)\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "fix bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "from bv_to_nat_upper_range [of \"bv_not bs\"]"], ["proof (chain)\npicking this:\n  bv_to_nat (bv_not bs) < 2 ^ length (bv_not bs)", "show \"- (2 ^ length bs) \\<le> -1 - int (bv_to_nat (bv_not bs))\""], ["proof (prove)\nusing this:\n  bv_to_nat (bv_not bs) < 2 ^ length (bv_not bs)\n\ngoal (1 subgoal):\n 1. - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))", "apply (simp add: algebra_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (bv_not bs) < 2 ^ length bs \\<Longrightarrow>\n    1 + int (bv_to_nat (bv_not bs)) \\<le> 2 ^ length bs", "by (metis of_nat_power add.commute not_less of_nat_numeral zle_add1_eq_le of_nat_le_iff)"], ["proof (state)\nthis:\n  - (2 ^ length bs) \\<le> - 1 - int (bv_to_nat (bv_not bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_bv_int [simp]: \"int_to_bv (bv_to_int w) = norm_signed w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int_to_bv (bv_to_int w) = norm_signed w", "proof (rule bit_list_cases [of w],simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "assume [simp]: \"w = \\<zero>#xs\""], ["proof (state)\nthis:\n  w = \\<zero> # xs\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_to_bv (bv_to_int w) = norm_signed w", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (\\<zero> # norm_unsigned xs) = norm_signed (\\<zero> # xs)", "apply (subst norm_signed_Cons [of \"\\<zero>\" \"xs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (\\<zero> # norm_unsigned xs) =\n    (case \\<zero> of\n     \\<zero> \\<Rightarrow>\n       if norm_unsigned xs = [] then [] else \\<zero> # norm_unsigned xs\n     | \\<one> \\<Rightarrow> \\<zero> # rem_initial \\<zero> xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_unsigned xs \\<noteq> [] \\<longrightarrow>\n    norm_signed (\\<zero> # norm_unsigned xs) = \\<zero> # norm_unsigned xs", "using norm_unsigned_result [of xs]"], ["proof (prove)\nusing this:\n  norm_unsigned xs = [] \\<or> bv_msb (norm_unsigned xs) = \\<one>\n\ngoal (1 subgoal):\n 1. norm_unsigned xs \\<noteq> [] \\<longrightarrow>\n    norm_signed (\\<zero> # norm_unsigned xs) = \\<zero> # norm_unsigned xs", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_unsigned xs \\<noteq> [];\n     bv_msb (norm_unsigned xs) = \\<one>\\<rbrakk>\n    \\<Longrightarrow> norm_signed (\\<zero> # norm_unsigned xs) =\n                      \\<zero> # norm_unsigned xs", "apply (rule bit_list_cases [of \"norm_unsigned xs\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>norm_unsigned xs \\<noteq> [];\n     bv_msb (norm_unsigned xs) = \\<one>; norm_unsigned xs = []\\<rbrakk>\n    \\<Longrightarrow> norm_signed (\\<zero> # norm_unsigned xs) =\n                      \\<zero> # norm_unsigned xs\n 2. \\<And>bs.\n       \\<lbrakk>norm_unsigned xs \\<noteq> [];\n        bv_msb (norm_unsigned xs) = \\<one>;\n        norm_unsigned xs = \\<zero> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # norm_unsigned xs) =\n                         \\<zero> # norm_unsigned xs\n 3. \\<And>bs.\n       \\<lbrakk>norm_unsigned xs \\<noteq> [];\n        bv_msb (norm_unsigned xs) = \\<one>;\n        norm_unsigned xs = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # norm_unsigned xs) =\n                         \\<zero> # norm_unsigned xs", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  int_to_bv (bv_to_int w) = norm_signed w\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "assume [simp]: \"w = \\<one>#xs\""], ["proof (state)\nthis:\n  w = \\<one> # xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       int_to_bv (bv_to_int w) = norm_signed w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_to_bv (bv_to_int w) = norm_signed w", "apply (simp del: int_to_bv_lt0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int_to_bv (- 1 - int (bv_to_nat (bv_not xs))) =\n    norm_signed (\\<one> # xs)", "apply (rule bit_list_induct [of _ xs], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       int_to_bv (- 1 - int (bv_to_nat (bv_not (\\<zero> # bs)))) =\n       norm_signed (\\<one> # \\<zero> # bs)\n 2. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       int_to_bv (- 1 - int (bv_to_nat (bv_not (\\<one> # bs)))) =\n       norm_signed (\\<one> # \\<one> # bs)", "apply (subst int_to_bv_lt0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       - 1 - int (bv_to_nat (bv_not (\\<zero> # bs))) < 0\n 2. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       norm_signed\n        (bv_not\n          (\\<zero> #\n           nat_to_bv\n            (nat (- (- 1 - int (bv_to_nat (bv_not (\\<zero> # bs)))) -\n                  1)))) =\n       norm_signed (\\<one> # \\<zero> # bs)\n 3. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       int_to_bv (- 1 - int (bv_to_nat (bv_not (\\<one> # bs)))) =\n       norm_signed (\\<one> # \\<one> # bs)", "apply linarith"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       norm_signed\n        (bv_not\n          (\\<zero> #\n           nat_to_bv\n            (nat (- (- 1 - int (bv_to_nat (bv_not (\\<zero> # bs)))) -\n                  1)))) =\n       norm_signed (\\<one> # \\<zero> # bs)\n 2. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       int_to_bv (- 1 - int (bv_to_nat (bv_not (\\<one> # bs)))) =\n       norm_signed (\\<one> # \\<one> # bs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed (\\<one> # bv_not (norm_unsigned (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       norm_signed\n        (\\<one> #\n         bv_not\n          (nat_to_bv (nat (2 ^ length bs + int (bv_to_nat (bv_not bs)))))) =\n       \\<one> # \\<zero> # bs\n 2. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       int_to_bv (- 1 - int (bv_to_nat (bv_not (\\<one> # bs)))) =\n       norm_signed (\\<one> # \\<one> # bs)", "apply (metis add.commute bitnot_zero bv_not_Cons bv_not_bv_not int_nat_two_exp length_bv_not nat_helper2 nat_int norm_signed10 of_nat_add)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       int_to_bv (- 1 - int (bv_to_nat (bv_not bs))) =\n       norm_signed (\\<one> # bs) \\<Longrightarrow>\n       int_to_bv (- 1 - int (bv_to_nat (bv_not (\\<one> # bs)))) =\n       norm_signed (\\<one> # \\<one> # bs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  int_to_bv (bv_to_int w) = norm_signed w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_int_bv [simp]: \"bv_to_int (int_to_bv i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (int_to_bv i) = i", "by (cases \"0 \\<le> i\") simp_all"], ["", "lemma bv_msb_norm [simp]: \"bv_msb (norm_signed w) = bv_msb w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) = bv_msb w", "by (rule bit_list_cases [of w]) (simp_all add: norm_signed_Cons)"], ["", "lemma norm_signed_length: \"length (norm_signed w) \\<le> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_signed w) \\<le> length w", "apply (cases w, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w = a # list \\<Longrightarrow>\n       length (norm_signed (a # list)) \\<le> Suc (length list)", "apply (subst norm_signed_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       w = a # list \\<Longrightarrow>\n       length\n        (case a of\n         \\<zero> \\<Rightarrow>\n           if norm_unsigned list = [] then [] else a # norm_unsigned list\n         | \\<one> \\<Rightarrow> a # rem_initial a list)\n       \\<le> Suc (length list)", "apply (case_tac a, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>w = \\<one> # list; a = \\<one>\\<rbrakk>\n       \\<Longrightarrow> length (rem_initial \\<one> list) \\<le> length list", "apply (rule rem_initial_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma norm_signed_equal: \"length (norm_signed w) = length w ==> norm_signed w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_signed w) = length w \\<Longrightarrow> norm_signed w = w", "proof (rule bit_list_cases [of w], simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<zero> # bs)) = Suc (length bs);\n        w = \\<zero> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # bs) = \\<zero> # bs\n 2. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<zero> # bs)) = Suc (length bs);\n        w = \\<zero> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # bs) = \\<zero> # bs\n 2. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "assume \"length (norm_signed (\\<zero>#xs)) = Suc (length xs)\""], ["proof (state)\nthis:\n  length (norm_signed (\\<zero> # xs)) = Suc (length xs)\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<zero> # bs)) = Suc (length bs);\n        w = \\<zero> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # bs) = \\<zero> # bs\n 2. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "thus \"norm_signed (\\<zero>#xs) = \\<zero>#xs\""], ["proof (prove)\nusing this:\n  length (norm_signed (\\<zero> # xs)) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. norm_signed (\\<zero> # xs) = \\<zero> # xs", "by (simp add: norm_signed_Cons norm_unsigned_equal [THEN eqTrueI]\n             split: if_split_asm)"], ["proof (state)\nthis:\n  norm_signed (\\<zero> # xs) = \\<zero> # xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "assume \"length (norm_signed (\\<one>#xs)) = Suc (length xs)\""], ["proof (state)\nthis:\n  length (norm_signed (\\<one> # xs)) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>length (norm_signed (\\<one> # bs)) = Suc (length bs);\n        w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<one> # bs) = \\<one> # bs", "thus \"norm_signed (\\<one>#xs) = \\<one>#xs\""], ["proof (prove)\nusing this:\n  length (norm_signed (\\<one> # xs)) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. norm_signed (\\<one> # xs) = \\<one> # xs", "apply (simp add: norm_signed_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rem_initial \\<one> xs) = length xs \\<Longrightarrow>\n    rem_initial \\<one> xs = xs", "apply (rule rem_initial_equal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (rem_initial \\<one> xs) = length xs \\<Longrightarrow>\n    length (rem_initial \\<one> xs) = length xs", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  norm_signed (\\<one> # xs) = \\<one> # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_extend_norm_signed: \"bv_msb w = b ==> bv_extend (length w) b (norm_signed w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb w = b \\<Longrightarrow>\n    bv_extend (length w) b (norm_signed w) = w", "proof (rule bit_list_cases [of w],simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>\\<zero> = b; w = \\<zero> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<zero>\n                          (norm_signed (\\<zero> # bs)) =\n                         \\<zero> # bs\n 2. \\<And>bs.\n       \\<lbrakk>\\<one> = b; w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<one>\n                          (norm_signed (\\<one> # bs)) =\n                         \\<one> # bs", "fix xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       \\<lbrakk>\\<zero> = b; w = \\<zero> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<zero>\n                          (norm_signed (\\<zero> # bs)) =\n                         \\<zero> # bs\n 2. \\<And>bs.\n       \\<lbrakk>\\<one> = b; w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<one>\n                          (norm_signed (\\<one> # bs)) =\n                         \\<one> # bs", "show \"bv_extend (Suc (length xs)) \\<zero> (norm_signed (\\<zero>#xs)) = \\<zero>#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<zero> (norm_signed (\\<zero> # xs)) =\n    \\<zero> # xs", "proof (simp add: norm_signed_def,auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm_unsigned xs = [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero> # xs\n 2. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "assume \"norm_unsigned xs = []\""], ["proof (state)\nthis:\n  norm_unsigned xs = []\n\ngoal (2 subgoals):\n 1. norm_unsigned xs = [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero> # xs\n 2. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "hence xx: \"rem_initial \\<zero> xs = []\""], ["proof (prove)\nusing this:\n  norm_unsigned xs = []\n\ngoal (1 subgoal):\n 1. rem_initial \\<zero> xs = []", "by (simp add: norm_unsigned_def)"], ["proof (state)\nthis:\n  rem_initial \\<zero> xs = []\n\ngoal (2 subgoals):\n 1. norm_unsigned xs = [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero> # xs\n 2. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "have \"bv_extend (Suc (length xs)) \\<zero> (\\<zero>#rem_initial \\<zero> xs) = \\<zero>#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<zero> (\\<zero> # rem_initial \\<zero> xs) =\n    \\<zero> # xs", "apply (simp add: bv_extend_def replicate_app_Cons_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (length xs - length (rem_initial \\<zero> xs)) \\<zero> @\n    rem_initial \\<zero> xs =\n    xs", "apply (fold bv_extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length xs) \\<zero> (rem_initial \\<zero> xs) = xs", "apply (rule bv_extend_rem_initial)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) \\<zero> (\\<zero> # rem_initial \\<zero> xs) =\n  \\<zero> # xs\n\ngoal (2 subgoals):\n 1. norm_unsigned xs = [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero> # xs\n 2. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "thus \"bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero>#xs\""], ["proof (prove)\nusing this:\n  bv_extend (Suc (length xs)) \\<zero> (\\<zero> # rem_initial \\<zero> xs) =\n  \\<zero> # xs\n\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero> # xs", "by (simp add: xx)"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) \\<zero> [\\<zero>] = \\<zero> # xs\n\ngoal (1 subgoal):\n 1. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. norm_unsigned xs \\<noteq> [] \\<Longrightarrow>\n    bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "show \"bv_extend (Suc (length xs)) \\<zero> (\\<zero>#norm_unsigned xs) = \\<zero>#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n    \\<zero> # xs", "apply (simp add: norm_unsigned_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<zero> (\\<zero> # rem_initial \\<zero> xs) =\n    \\<zero> # xs", "apply (simp add: bv_extend_def replicate_app_Cons_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (length xs - length (rem_initial \\<zero> xs)) \\<zero> @\n    rem_initial \\<zero> xs =\n    xs", "apply (fold bv_extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length xs) \\<zero> (rem_initial \\<zero> xs) = xs", "apply (rule bv_extend_rem_initial)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) \\<zero> (\\<zero> # norm_unsigned xs) =\n  \\<zero> # xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) \\<zero> (norm_signed (\\<zero> # xs)) =\n  \\<zero> # xs\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>\\<one> = b; w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<one>\n                          (norm_signed (\\<one> # bs)) =\n                         \\<one> # bs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>\\<one> = b; w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<one>\n                          (norm_signed (\\<one> # bs)) =\n                         \\<one> # bs", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>\\<one> = b; w = \\<one> # bs\\<rbrakk>\n       \\<Longrightarrow> bv_extend (Suc (length bs)) \\<one>\n                          (norm_signed (\\<one> # bs)) =\n                         \\<one> # bs", "show \"bv_extend (Suc (length xs)) \\<one> (norm_signed (\\<one>#xs)) = \\<one>#xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<one> (norm_signed (\\<one> # xs)) =\n    \\<one> # xs", "apply (simp add: norm_signed_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (Suc (length xs)) \\<one> (\\<one> # rem_initial \\<one> xs) =\n    \\<one> # xs", "apply (simp add: bv_extend_def replicate_app_Cons_same)"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate (length xs - length (rem_initial \\<one> xs)) \\<one> @\n    rem_initial \\<one> xs =\n    xs", "apply (fold bv_extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length xs) \\<one> (rem_initial \\<one> xs) = xs", "apply (rule bv_extend_rem_initial)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_extend (Suc (length xs)) \\<one> (norm_signed (\\<one> # xs)) =\n  \\<one> # xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_int_qinj:\n  assumes one: \"bv_to_int xs = bv_to_int ys\"\n  and     len: \"length xs = length ys\"\n  shows        \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = ys", "from one"], ["proof (chain)\npicking this:\n  bv_to_int xs = bv_to_int ys", "have \"int_to_bv (bv_to_int xs) = int_to_bv (bv_to_int ys)\""], ["proof (prove)\nusing this:\n  bv_to_int xs = bv_to_int ys\n\ngoal (1 subgoal):\n 1. int_to_bv (bv_to_int xs) = int_to_bv (bv_to_int ys)", "by simp"], ["proof (state)\nthis:\n  int_to_bv (bv_to_int xs) = int_to_bv (bv_to_int ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "hence xsys: \"norm_signed xs = norm_signed ys\""], ["proof (prove)\nusing this:\n  int_to_bv (bv_to_int xs) = int_to_bv (bv_to_int ys)\n\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys", "by simp"], ["proof (state)\nthis:\n  norm_signed xs = norm_signed ys\n\ngoal (1 subgoal):\n 1. xs = ys", "hence xsys': \"bv_msb xs = bv_msb ys\""], ["proof (prove)\nusing this:\n  norm_signed xs = norm_signed ys\n\ngoal (1 subgoal):\n 1. bv_msb xs = bv_msb ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys \\<Longrightarrow> bv_msb xs = bv_msb ys", "have \"bv_msb xs = bv_msb (norm_signed xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb xs = bv_msb (norm_signed xs)", "by simp"], ["proof (state)\nthis:\n  bv_msb xs = bv_msb (norm_signed xs)\n\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys \\<Longrightarrow> bv_msb xs = bv_msb ys", "also"], ["proof (state)\nthis:\n  bv_msb xs = bv_msb (norm_signed xs)\n\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys \\<Longrightarrow> bv_msb xs = bv_msb ys", "have \"... = bv_msb (norm_signed ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_signed xs) = bv_msb (norm_signed ys)", "by (simp add: xsys)"], ["proof (state)\nthis:\n  bv_msb (norm_signed xs) = bv_msb (norm_signed ys)\n\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys \\<Longrightarrow> bv_msb xs = bv_msb ys", "also"], ["proof (state)\nthis:\n  bv_msb (norm_signed xs) = bv_msb (norm_signed ys)\n\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys \\<Longrightarrow> bv_msb xs = bv_msb ys", "have \"... = bv_msb ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_signed ys) = bv_msb ys", "by simp"], ["proof (state)\nthis:\n  bv_msb (norm_signed ys) = bv_msb ys\n\ngoal (1 subgoal):\n 1. norm_signed xs = norm_signed ys \\<Longrightarrow> bv_msb xs = bv_msb ys", "finally"], ["proof (chain)\npicking this:\n  bv_msb xs = bv_msb ys", "show ?thesis"], ["proof (prove)\nusing this:\n  bv_msb xs = bv_msb ys\n\ngoal (1 subgoal):\n 1. bv_msb xs = bv_msb ys", "."], ["proof (state)\nthis:\n  bv_msb xs = bv_msb ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_msb xs = bv_msb ys\n\ngoal (1 subgoal):\n 1. xs = ys", "have \"xs = bv_extend (length xs) (bv_msb xs) (norm_signed xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = bv_extend (length xs) (bv_msb xs) (norm_signed xs)", "by (simp add: bv_extend_norm_signed)"], ["proof (state)\nthis:\n  xs = bv_extend (length xs) (bv_msb xs) (norm_signed xs)\n\ngoal (1 subgoal):\n 1. xs = ys", "also"], ["proof (state)\nthis:\n  xs = bv_extend (length xs) (bv_msb xs) (norm_signed xs)\n\ngoal (1 subgoal):\n 1. xs = ys", "have \"... = bv_extend (length ys) (bv_msb ys) (norm_signed ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length xs) (bv_msb xs) (norm_signed xs) =\n    bv_extend (length ys) (bv_msb ys) (norm_signed ys)", "by (simp add: xsys xsys' len)"], ["proof (state)\nthis:\n  bv_extend (length xs) (bv_msb xs) (norm_signed xs) =\n  bv_extend (length ys) (bv_msb ys) (norm_signed ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "also"], ["proof (state)\nthis:\n  bv_extend (length xs) (bv_msb xs) (norm_signed xs) =\n  bv_extend (length ys) (bv_msb ys) (norm_signed ys)\n\ngoal (1 subgoal):\n 1. xs = ys", "have \"... = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_extend (length ys) (bv_msb ys) (norm_signed ys) = ys", "by (simp add: bv_extend_norm_signed)"], ["proof (state)\nthis:\n  bv_extend (length ys) (bv_msb ys) (norm_signed ys) = ys\n\ngoal (1 subgoal):\n 1. xs = ys", "finally"], ["proof (chain)\npicking this:\n  xs = ys", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = ys\n\ngoal (1 subgoal):\n 1. xs = ys", "."], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_to_bv_returntype [simp]: \"norm_signed (int_to_bv w) = int_to_bv w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (int_to_bv w) = int_to_bv w", "by (simp add: int_to_bv_def)"], ["", "lemma bv_to_int_msb0: \"0 \\<le> bv_to_int w1 ==> bv_msb w1 = \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w1 \\<Longrightarrow> bv_msb w1 = \\<zero>", "by (rule bit_list_cases,simp_all)"], ["", "lemma bv_to_int_msb1: \"bv_to_int w1 < 0 ==> bv_msb w1 = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 < 0 \\<Longrightarrow> bv_msb w1 = \\<one>", "by (rule bit_list_cases,simp_all)"], ["", "lemma bv_to_int_lower_limit_gt0:\n  assumes w0: \"0 < bv_to_int w\"\n  shows       \"2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "from w0"], ["proof (chain)\npicking this:\n  0 < bv_to_int w", "have \"0 \\<le> bv_to_int w\""], ["proof (prove)\nusing this:\n  0 < bv_to_int w\n\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w", "by simp"], ["proof (state)\nthis:\n  0 \\<le> bv_to_int w\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "hence [simp]: \"bv_msb w = \\<zero>\""], ["proof (prove)\nusing this:\n  0 \\<le> bv_to_int w\n\ngoal (1 subgoal):\n 1. bv_msb w = \\<zero>", "by (rule bv_to_int_msb0)"], ["proof (state)\nthis:\n  bv_msb w = \\<zero>\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "have \"2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "proof (rule bit_list_cases [of w])"], ["proof (state)\ngoal (3 subgoals):\n 1. w = [] \\<Longrightarrow>\n    2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 2. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 3. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "assume \"w = []\""], ["proof (state)\nthis:\n  w = []\n\ngoal (3 subgoals):\n 1. w = [] \\<Longrightarrow>\n    2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 2. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 3. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "with w0"], ["proof (chain)\npicking this:\n  0 < bv_to_int w\n  w = []", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int w\n  w = []\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "fix w'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "assume weq: \"w = \\<zero> # w'\""], ["proof (state)\nthis:\n  w = \\<zero> # w'\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  w = \\<zero> # w'\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "proof (simp add: norm_signed_Cons,safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' = []\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (norm_unsigned w') - Suc 0)\n                      \\<le> bv_to_nat w'", "assume \"norm_unsigned w' = []\""], ["proof (state)\nthis:\n  norm_unsigned w' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' = []\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (norm_unsigned w') - Suc 0)\n                      \\<le> bv_to_nat w'", "with weq and w0"], ["proof (chain)\npicking this:\n  w = \\<zero> # w'\n  0 < bv_to_int w\n  norm_unsigned w' = []", "show False"], ["proof (prove)\nusing this:\n  w = \\<zero> # w'\n  0 < bv_to_int w\n  norm_unsigned w' = []\n\ngoal (1 subgoal):\n 1. False", "by (simp add: norm_empty_bv_to_nat_zero)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (norm_unsigned w') - Suc 0)\n                      \\<le> bv_to_nat w'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (norm_unsigned w') - Suc 0)\n                      \\<le> bv_to_nat w'", "assume w'0: \"norm_unsigned w' \\<noteq> []\""], ["proof (state)\nthis:\n  norm_unsigned w' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (norm_unsigned w') - Suc 0)\n                      \\<le> bv_to_nat w'", "have \"0 < bv_to_nat w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_nat w'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < bv_to_nat w' \\<Longrightarrow> False", "assume \"~ (0 < bv_to_nat w')\""], ["proof (state)\nthis:\n  \\<not> 0 < bv_to_nat w'\n\ngoal (1 subgoal):\n 1. \\<not> 0 < bv_to_nat w' \\<Longrightarrow> False", "hence \"bv_to_nat w' = 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < bv_to_nat w'\n\ngoal (1 subgoal):\n 1. bv_to_nat w' = 0", "by arith"], ["proof (state)\nthis:\n  bv_to_nat w' = 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < bv_to_nat w' \\<Longrightarrow> False", "hence \"norm_unsigned w' = []\""], ["proof (prove)\nusing this:\n  bv_to_nat w' = 0\n\ngoal (1 subgoal):\n 1. norm_unsigned w' = []", "by (simp add: bv_to_nat_zero_imp_empty)"], ["proof (state)\nthis:\n  norm_unsigned w' = []\n\ngoal (1 subgoal):\n 1. \\<not> 0 < bv_to_nat w' \\<Longrightarrow> False", "with w'0"], ["proof (chain)\npicking this:\n  norm_unsigned w' \\<noteq> []\n  norm_unsigned w' = []", "show False"], ["proof (prove)\nusing this:\n  norm_unsigned w' \\<noteq> []\n  norm_unsigned w' = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < bv_to_nat w'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w = \\<zero> # w'; norm_unsigned w' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> 2 ^ (length (norm_unsigned w') - Suc 0)\n                      \\<le> bv_to_nat w'", "with bv_to_nat_lower_limit [of w']"], ["proof (chain)\npicking this:\n  0 < bv_to_nat w' \\<Longrightarrow>\n  2 ^ (length (norm_unsigned w') - 1) \\<le> bv_to_nat w'\n  0 < bv_to_nat w'", "show \"2 ^ (length (norm_unsigned w') - Suc 0) \\<le> bv_to_nat w'\""], ["proof (prove)\nusing this:\n  0 < bv_to_nat w' \\<Longrightarrow>\n  2 ^ (length (norm_unsigned w') - 1) \\<le> bv_to_nat w'\n  0 < bv_to_nat w'\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w') - Suc 0) \\<le> bv_to_nat w'", "using One_nat_def int_nat_two_exp"], ["proof (prove)\nusing this:\n  0 < bv_to_nat w' \\<Longrightarrow>\n  2 ^ (length (norm_unsigned w') - 1) \\<le> bv_to_nat w'\n  0 < bv_to_nat w'\n  1 = Suc 0\n  2 ^ ?k = int (2 ^ ?k)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_unsigned w') - Suc 0) \\<le> bv_to_nat w'", "by presburger"], ["proof (state)\nthis:\n  2 ^ (length (norm_unsigned w') - Suc 0) \\<le> bv_to_nat w'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "fix w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "assume weq: \"w = \\<one> # w'\""], ["proof (state)\nthis:\n  w = \\<one> # w'\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "from w0"], ["proof (chain)\npicking this:\n  0 < bv_to_int w", "have \"bv_msb w = \\<zero>\""], ["proof (prove)\nusing this:\n  0 < bv_to_int w\n\ngoal (1 subgoal):\n 1. bv_msb w = \\<zero>", "by simp"], ["proof (state)\nthis:\n  bv_msb w = \\<zero>\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "with weq"], ["proof (chain)\npicking this:\n  w = \\<one> # w'\n  bv_msb w = \\<zero>", "show ?thesis"], ["proof (prove)\nusing this:\n  w = \\<one> # w'\n  bv_msb w = \\<zero>\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "also"], ["proof (state)\nthis:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int (norm_signed w)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "have \"...  = bv_to_int w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = bv_to_int w", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) = bv_to_int w\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "finally"], ["proof (chain)\npicking this:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w\n\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w", "."], ["proof (state)\nthis:\n  2 ^ (length (norm_signed w) - 2) \\<le> bv_to_int w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma norm_signed_result: \"norm_signed w = [] \\<or> norm_signed w = [\\<one>] \\<or> bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed w = [] \\<or>\n    norm_signed w = [\\<one>] \\<or>\n    bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))", "apply (rule bit_list_cases [of w],simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w = \\<zero> # bs \\<Longrightarrow>\n       norm_signed (\\<zero> # bs) = [] \\<or>\n       norm_signed (\\<zero> # bs) = [\\<one>] \\<or>\n       \\<zero> \\<noteq> bv_msb (tl (norm_signed (\\<zero> # bs)))\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       norm_signed (\\<one> # bs) = [] \\<or>\n       norm_signed (\\<one> # bs) = [\\<one>] \\<or>\n       \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # bs)))", "apply (case_tac \"bs\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs a list.\n       \\<lbrakk>w = \\<zero> # a # list; bs = a # list\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # a # list) = [] \\<or>\n                         norm_signed (\\<zero> # a # list) = [\\<one>] \\<or>\n                         \\<zero> \\<noteq>\n                         bv_msb (tl (norm_signed (\\<zero> # a # list)))\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       norm_signed (\\<one> # bs) = [] \\<or>\n       norm_signed (\\<one> # bs) = [\\<one>] \\<or>\n       \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # bs)))", "apply (case_tac \"a\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs a list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list; bs = \\<zero> # list;\n        a = \\<zero>\\<rbrakk>\n       \\<Longrightarrow> norm_signed (\\<zero> # list) = [] \\<or>\n                         norm_signed (\\<zero> # list) = [\\<one>] \\<or>\n                         \\<zero> \\<noteq>\n                         bv_msb (tl (norm_signed (\\<zero> # list)))\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       norm_signed (\\<one> # bs) = [] \\<or>\n       norm_signed (\\<one> # bs) = [\\<one>] \\<or>\n       \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # bs)))", "apply (simp add: norm_signed_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs a list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list; bs = \\<zero> # list;\n        a = \\<zero>\\<rbrakk>\n       \\<Longrightarrow> norm_unsigned list \\<noteq> [] \\<longrightarrow>\n                         \\<zero> \\<noteq> bv_msb (norm_unsigned list)\n 2. \\<And>bs.\n       w = \\<one> # bs \\<Longrightarrow>\n       norm_signed (\\<one> # bs) = [] \\<or>\n       norm_signed (\\<one> # bs) = [\\<one>] \\<or>\n       \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # bs)))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>bs a list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "assume msb: \"\\<zero> = bv_msb (norm_unsigned l)\""], ["proof (state)\nthis:\n  \\<zero> = bv_msb (norm_unsigned l)\n\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"norm_unsigned l \\<noteq> []\""], ["proof (state)\nthis:\n  norm_unsigned l \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "with norm_unsigned_result [of l]"], ["proof (chain)\npicking this:\n  norm_unsigned l = [] \\<or> bv_msb (norm_unsigned l) = \\<one>\n  norm_unsigned l \\<noteq> []", "have \"bv_msb (norm_unsigned l) = \\<one>\""], ["proof (prove)\nusing this:\n  norm_unsigned l = [] \\<or> bv_msb (norm_unsigned l) = \\<one>\n  norm_unsigned l \\<noteq> []\n\ngoal (1 subgoal):\n 1. bv_msb (norm_unsigned l) = \\<one>", "by simp"], ["proof (state)\nthis:\n  bv_msb (norm_unsigned l) = \\<one>\n\ngoal (2 subgoals):\n 1. \\<And>list.\n       \\<lbrakk>w = \\<zero> # \\<zero> # list;\n        norm_unsigned list \\<noteq> [];\n        \\<zero> = bv_msb (norm_unsigned list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "with msb"], ["proof (chain)\npicking this:\n  \\<zero> = bv_msb (norm_unsigned l)\n  bv_msb (norm_unsigned l) = \\<one>", "show False"], ["proof (prove)\nusing this:\n  \\<zero> = bv_msb (norm_unsigned l)\n  bv_msb (norm_unsigned l) = \\<one>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "assume p: \"\\<one> = bv_msb (tl (norm_signed (\\<one> # xs)))\""], ["proof (state)\nthis:\n  \\<one> = bv_msb (tl (norm_signed (\\<one> # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "have \"\\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # xs)))", "by (rule bit_list_induct [of _ xs],simp_all)"], ["proof (state)\nthis:\n  \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       \\<lbrakk>w = \\<one> # bs; norm_signed (\\<one> # bs) \\<noteq> [];\n        norm_signed (\\<one> # bs) \\<noteq> [\\<one>];\n        \\<one> = bv_msb (tl (norm_signed (\\<one> # bs)))\\<rbrakk>\n       \\<Longrightarrow> False", "with p"], ["proof (chain)\npicking this:\n  \\<one> = bv_msb (tl (norm_signed (\\<one> # xs)))\n  \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # xs)))", "show False"], ["proof (prove)\nusing this:\n  \\<one> = bv_msb (tl (norm_signed (\\<one> # xs)))\n  \\<one> \\<noteq> bv_msb (tl (norm_signed (\\<one> # xs)))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_int_upper_limit_lem1:\n  assumes w0: \"bv_to_int w < -1\"\n  shows       \"bv_to_int w < - (2 ^ (length (norm_signed w) - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "from w0"], ["proof (chain)\npicking this:\n  bv_to_int w < - 1", "have \"bv_to_int w < 0\""], ["proof (prove)\nusing this:\n  bv_to_int w < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w < 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int w < 0\n\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "hence msbw [simp]: \"bv_msb w = \\<one>\""], ["proof (prove)\nusing this:\n  bv_to_int w < 0\n\ngoal (1 subgoal):\n 1. bv_msb w = \\<one>", "by (rule bv_to_int_msb1)"], ["proof (state)\nthis:\n  bv_msb w = \\<one>\n\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "have \"bv_to_int w = bv_to_int (norm_signed w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w = bv_to_int (norm_signed w)", "by simp"], ["proof (state)\nthis:\n  bv_to_int w = bv_to_int (norm_signed w)\n\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "also"], ["proof (state)\nthis:\n  bv_to_int w = bv_to_int (norm_signed w)\n\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "from norm_signed_result [of w]"], ["proof (chain)\npicking this:\n  norm_signed w = [] \\<or>\n  norm_signed w = [\\<one>] \\<or>\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))", "have \"... < - (2 ^ (length (norm_signed w) - 2))\""], ["proof (prove)\nusing this:\n  norm_signed w = [] \\<or>\n  norm_signed w = [\\<one>] \\<or>\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume \"norm_signed w = []\""], ["proof (state)\nthis:\n  norm_signed w = []\n\ngoal (3 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "hence \"bv_to_int (norm_signed w) = 0\""], ["proof (prove)\nusing this:\n  norm_signed w = []\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) = 0\n\ngoal (3 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "with w0"], ["proof (chain)\npicking this:\n  bv_to_int w < - 1\n  bv_to_int (norm_signed w) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w < - 1\n  bv_to_int (norm_signed w) = 0\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (2 subgoals):\n 1. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume \"norm_signed w = [\\<one>]\""], ["proof (state)\nthis:\n  norm_signed w = [\\<one>]\n\ngoal (2 subgoals):\n 1. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "hence \"bv_to_int (norm_signed w) = -1\""], ["proof (prove)\nusing this:\n  norm_signed w = [\\<one>]\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = - 1", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) = - 1\n\ngoal (2 subgoals):\n 1. norm_signed w = [\\<one>] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "with w0"], ["proof (chain)\npicking this:\n  bv_to_int w < - 1\n  bv_to_int (norm_signed w) = - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w < - 1\n  bv_to_int (norm_signed w) = - 1\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume \"bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\""], ["proof (state)\nthis:\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\n\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "hence msb_tl: \"\\<one> \\<noteq> bv_msb (tl (norm_signed w))\""], ["proof (prove)\nusing this:\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\n\ngoal (1 subgoal):\n 1. \\<one> \\<noteq> bv_msb (tl (norm_signed w))", "by simp"], ["proof (state)\nthis:\n  \\<one> \\<noteq> bv_msb (tl (norm_signed w))\n\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) \\<noteq>\n    bv_msb (tl (norm_signed w)) \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "show \"bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "proof (rule bit_list_cases [of \"norm_signed w\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume \"norm_signed w = []\""], ["proof (state)\nthis:\n  norm_signed w = []\n\ngoal (3 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "hence \"bv_to_int (norm_signed w) = 0\""], ["proof (prove)\nusing this:\n  norm_signed w = []\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) = 0\n\ngoal (3 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "with w0"], ["proof (chain)\npicking this:\n  bv_to_int w < - 1\n  bv_to_int (norm_signed w) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w < - 1\n  bv_to_int (norm_signed w) = 0\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "fix w'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume nw: \"norm_signed w = \\<zero> # w'\""], ["proof (state)\nthis:\n  norm_signed w = \\<zero> # w'\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "from msbw"], ["proof (chain)\npicking this:\n  bv_msb w = \\<one>", "have \"bv_msb (norm_signed w) = \\<one>\""], ["proof (prove)\nusing this:\n  bv_msb w = \\<one>\n\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) = \\<one>", "by simp"], ["proof (state)\nthis:\n  bv_msb (norm_signed w) = \\<one>\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       norm_signed w = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "with nw"], ["proof (chain)\npicking this:\n  norm_signed w = \\<zero> # w'\n  bv_msb (norm_signed w) = \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  norm_signed w = \\<zero> # w'\n  bv_msb (norm_signed w) = \\<one>\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "fix w'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume weq: \"norm_signed w = \\<one> # w'\""], ["proof (state)\nthis:\n  norm_signed w = \\<one> # w'\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       norm_signed w = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "proof (rule bit_list_cases [of w'])"], ["proof (state)\ngoal (3 subgoals):\n 1. w' = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume w'eq: \"w' = []\""], ["proof (state)\nthis:\n  w' = []\n\ngoal (3 subgoals):\n 1. w' = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "from w0"], ["proof (chain)\npicking this:\n  bv_to_int w < - 1", "have \"bv_to_int (norm_signed w) < -1\""], ["proof (prove)\nusing this:\n  bv_to_int w < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - 1", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - 1\n\ngoal (3 subgoals):\n 1. w' = [] \\<Longrightarrow>\n    bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 3. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "with w'eq and weq"], ["proof (chain)\npicking this:\n  w' = []\n  norm_signed w = \\<one> # w'\n  bv_to_int (norm_signed w) < - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  w' = []\n  norm_signed w = \\<one> # w'\n  bv_to_int (norm_signed w) < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "fix w''"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume w'eq: \"w' = \\<zero> # w''\""], ["proof (state)\nthis:\n  w' = \\<zero> # w''\n\ngoal (2 subgoals):\n 1. \\<And>bs.\n       w' = \\<zero> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n 2. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by (simp add: weq w'eq)"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "fix w''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "assume w'eq: \"w' = \\<one> # w''\""], ["proof (state)\nthis:\n  w' = \\<one> # w''\n\ngoal (1 subgoal):\n 1. \\<And>bs.\n       w' = \\<one> # bs \\<Longrightarrow>\n       bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "with weq and msb_tl"], ["proof (chain)\npicking this:\n  norm_signed w = \\<one> # w'\n  \\<one> \\<noteq> bv_msb (tl (norm_signed w))\n  w' = \\<one> # w''", "show ?thesis"], ["proof (prove)\nusing this:\n  norm_signed w = \\<one> # w'\n  \\<one> \\<noteq> bv_msb (tl (norm_signed w))\n  w' = \\<one> # w''\n\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))", "by simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "finally"], ["proof (chain)\npicking this:\n  bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "show ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w < - (2 ^ (length (norm_signed w) - 2))\n\ngoal (1 subgoal):\n 1. bv_to_int w < - (2 ^ (length (norm_signed w) - 2))", "."], ["proof (state)\nthis:\n  bv_to_int w < - (2 ^ (length (norm_signed w) - 2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_int_to_bv_upper_limit_gt0:\n  assumes w0: \"0 < i\"\n  and     wk: \"i \\<le> 2 ^ (k - 1) - 1\"\n  shows       \"length (int_to_bv i) \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv i) \\<le> k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "from w0 wk"], ["proof (chain)\npicking this:\n  0 < i\n  i \\<le> 2 ^ (k - 1) - 1", "have k1: \"1 < k\""], ["proof (prove)\nusing this:\n  0 < i\n  i \\<le> 2 ^ (k - 1) - 1\n\ngoal (1 subgoal):\n 1. 1 < k", "by (cases \"k - 1\",simp_all)"], ["proof (state)\nthis:\n  1 < k\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "assume \"~ length (int_to_bv i) \\<le> k\""], ["proof (state)\nthis:\n  \\<not> length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence \"k < length (int_to_bv i)\""], ["proof (prove)\nusing this:\n  \\<not> length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. k < length (int_to_bv i)", "by simp"], ["proof (state)\nthis:\n  k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence \"k \\<le> length (int_to_bv i) - 1\""], ["proof (prove)\nusing this:\n  k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. k \\<le> length (int_to_bv i) - 1", "by arith"], ["proof (state)\nthis:\n  k \\<le> length (int_to_bv i) - 1\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence a: \"k - 1 \\<le> length (int_to_bv i) - 2\""], ["proof (prove)\nusing this:\n  k \\<le> length (int_to_bv i) - 1\n\ngoal (1 subgoal):\n 1. k - 1 \\<le> length (int_to_bv i) - 2", "by arith"], ["proof (state)\nthis:\n  k - 1 \\<le> length (int_to_bv i) - 2\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence \"(2::int) ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)\""], ["proof (prove)\nusing this:\n  k - 1 \\<le> length (int_to_bv i) - 2\n\ngoal (1 subgoal):\n 1. 2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)", "by simp"], ["proof (state)\nthis:\n  2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "have \"... \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 2) \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 2) \\<le> i", "have \"2 ^ (length (norm_signed (int_to_bv i)) - 2) \\<le> bv_to_int (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (norm_signed (int_to_bv i)) - 2)\n    \\<le> bv_to_int (int_to_bv i)", "proof (rule bv_to_int_lower_limit_gt0)"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < bv_to_int (int_to_bv i)", "from w0"], ["proof (chain)\npicking this:\n  0 < i", "show \"0 < bv_to_int (int_to_bv i)\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. 0 < bv_to_int (int_to_bv i)", "by simp"], ["proof (state)\nthis:\n  0 < bv_to_int (int_to_bv i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (norm_signed (int_to_bv i)) - 2) \\<le> bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 2) \\<le> i", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (length (norm_signed (int_to_bv i)) - 2) \\<le> bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 2) \\<le> i", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (int_to_bv i) - 2) \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (length (int_to_bv i) - 2) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  2 ^ (k - 1) \\<le> i", "have \"2 ^ (k - 1) \\<le> i\""], ["proof (prove)\nusing this:\n  2 ^ (k - 1) \\<le> i\n\ngoal (1 subgoal):\n 1. 2 ^ (k - 1) \\<le> i", "."], ["proof (state)\nthis:\n  2 ^ (k - 1) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "with wk"], ["proof (chain)\npicking this:\n  i \\<le> 2 ^ (k - 1) - 1\n  2 ^ (k - 1) \\<le> i", "show False"], ["proof (prove)\nusing this:\n  i \\<le> 2 ^ (k - 1) - 1\n  2 ^ (k - 1) \\<le> i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_length_pos:\n  assumes i0: \"0 < bv_to_int w\"\n  shows       \"0 < length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length w", "from norm_signed_result [of w]"], ["proof (chain)\npicking this:\n  norm_signed w = [] \\<or>\n  norm_signed w = [\\<one>] \\<or>\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))", "have \"0 < length (norm_signed w)\""], ["proof (prove)\nusing this:\n  norm_signed w = [] \\<or>\n  norm_signed w = [\\<one>] \\<or>\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\n\ngoal (1 subgoal):\n 1. 0 < length (norm_signed w)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "assume ii: \"norm_signed w = []\""], ["proof (state)\nthis:\n  norm_signed w = []\n\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"bv_to_int (norm_signed w) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = 0", "by (subst ii) simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) = 0\n\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"bv_to_int w = 0\""], ["proof (prove)\nusing this:\n  bv_to_int (norm_signed w) = 0\n\ngoal (1 subgoal):\n 1. bv_to_int w = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int w = 0\n\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "with i0"], ["proof (chain)\npicking this:\n  0 < bv_to_int w\n  bv_to_int w = 0", "show False"], ["proof (prove)\nusing this:\n  0 < bv_to_int w\n  bv_to_int w = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "assume ii: \"norm_signed w = []\""], ["proof (state)\nthis:\n  norm_signed w = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "assume jj: \"bv_msb w \\<noteq> \\<zero>\""], ["proof (state)\nthis:\n  bv_msb w \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<zero> = bv_msb (norm_signed w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero> = bv_msb (norm_signed w)", "by (subst ii) simp"], ["proof (state)\nthis:\n  \\<zero> = bv_msb (norm_signed w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<zero> = bv_msb (norm_signed w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"... \\<noteq> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) \\<noteq> \\<zero>", "by (simp add: jj)"], ["proof (state)\nthis:\n  bv_msb (norm_signed w) \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<zero> \\<noteq> \\<zero>", "show False"], ["proof (prove)\nusing this:\n  \\<zero> \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length (norm_signed w)\n\ngoal (1 subgoal):\n 1. 0 < length w", "also"], ["proof (state)\nthis:\n  0 < length (norm_signed w)\n\ngoal (1 subgoal):\n 1. 0 < length w", "have \"... \\<le> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_signed w) \\<le> length w", "by (rule norm_signed_length)"], ["proof (state)\nthis:\n  length (norm_signed w) \\<le> length w\n\ngoal (1 subgoal):\n 1. 0 < length w", "finally"], ["proof (chain)\npicking this:\n  0 < length w", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < length w\n\ngoal (1 subgoal):\n 1. 0 < length w", "."], ["proof (state)\nthis:\n  0 < length w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma neg_length_pos:\n  assumes i0: \"bv_to_int w < -1\"\n  shows       \"0 < length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < length w", "from norm_signed_result [of w]"], ["proof (chain)\npicking this:\n  norm_signed w = [] \\<or>\n  norm_signed w = [\\<one>] \\<or>\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))", "have \"0 < length (norm_signed w)\""], ["proof (prove)\nusing this:\n  norm_signed w = [] \\<or>\n  norm_signed w = [\\<one>] \\<or>\n  bv_msb (norm_signed w) \\<noteq> bv_msb (tl (norm_signed w))\n\ngoal (1 subgoal):\n 1. 0 < length (norm_signed w)", "proof (auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "assume ii: \"norm_signed w = []\""], ["proof (state)\nthis:\n  norm_signed w = []\n\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"bv_to_int (norm_signed w) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (norm_signed w) = 0", "by (subst ii) simp"], ["proof (state)\nthis:\n  bv_to_int (norm_signed w) = 0\n\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"bv_to_int w = 0\""], ["proof (prove)\nusing this:\n  bv_to_int (norm_signed w) = 0\n\ngoal (1 subgoal):\n 1. bv_to_int w = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int w = 0\n\ngoal (2 subgoals):\n 1. norm_signed w = [] \\<Longrightarrow> False\n 2. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "with i0"], ["proof (chain)\npicking this:\n  bv_to_int w < - 1\n  bv_to_int w = 0", "show False"], ["proof (prove)\nusing this:\n  bv_to_int w < - 1\n  bv_to_int w = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "assume ii: \"norm_signed w = []\""], ["proof (state)\nthis:\n  norm_signed w = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "assume jj: \"bv_msb w \\<noteq> \\<zero>\""], ["proof (state)\nthis:\n  bv_msb w \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"\\<zero> = bv_msb (norm_signed w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<zero> = bv_msb (norm_signed w)", "by (subst ii) simp"], ["proof (state)\nthis:\n  \\<zero> = bv_msb (norm_signed w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<zero> = bv_msb (norm_signed w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"... \\<noteq> \\<zero>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_signed w) \\<noteq> \\<zero>", "by (simp add: jj)"], ["proof (state)\nthis:\n  bv_msb (norm_signed w) \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>norm_signed w = []; bv_msb w \\<noteq> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<zero> \\<noteq> \\<zero>", "show False"], ["proof (prove)\nusing this:\n  \\<zero> \\<noteq> \\<zero>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < length (norm_signed w)\n\ngoal (1 subgoal):\n 1. 0 < length w", "also"], ["proof (state)\nthis:\n  0 < length (norm_signed w)\n\ngoal (1 subgoal):\n 1. 0 < length w", "have \"... \\<le> length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_signed w) \\<le> length w", "by (rule norm_signed_length)"], ["proof (state)\nthis:\n  length (norm_signed w) \\<le> length w\n\ngoal (1 subgoal):\n 1. 0 < length w", "finally"], ["proof (chain)\npicking this:\n  0 < length w", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < length w\n\ngoal (1 subgoal):\n 1. 0 < length w", "."], ["proof (state)\nthis:\n  0 < length w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_int_to_bv_lower_limit_gt0:\n  assumes wk: \"2 ^ (k - 1) \\<le> i\"\n  shows       \"k < length (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (int_to_bv i)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have \"0 < (2::int) ^ (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ (k - 1)", "by (rule zero_less_power) simp"], ["proof (state)\nthis:\n  0 < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have \"... \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k - 1) \\<le> i", "by (rule wk)"], ["proof (state)\nthis:\n  2 ^ (k - 1) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 < i", "have i0: \"0 < i\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. 0 < i", "."], ["proof (state)\nthis:\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have lii0: \"0 < length (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (int_to_bv i)", "apply (rule pos_length_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_int (int_to_bv i)", "apply (simp,rule i0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "assume \"~ k < length (int_to_bv i)\""], ["proof (state)\nthis:\n  \\<not> k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "hence \"length (int_to_bv i) \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) \\<le> k", "by simp"], ["proof (state)\nthis:\n  length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "with lii0"], ["proof (chain)\npicking this:\n  0 < length (int_to_bv i)\n  length (int_to_bv i) \\<le> k", "have a: \"length (int_to_bv i) - 1 \\<le> k - 1\""], ["proof (prove)\nusing this:\n  0 < length (int_to_bv i)\n  length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) - 1 \\<le> k - 1", "by arith"], ["proof (state)\nthis:\n  length (int_to_bv i) - 1 \\<le> k - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have \"i < 2 ^ (length (int_to_bv i) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 2 ^ (length (int_to_bv i) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < 2 ^ (length (int_to_bv i) - 1)", "have \"i = bv_to_int (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = bv_to_int (int_to_bv i)", "by simp"], ["proof (state)\nthis:\n  i = bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. i < 2 ^ (length (int_to_bv i) - 1)", "also"], ["proof (state)\nthis:\n  i = bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. i < 2 ^ (length (int_to_bv i) - 1)", "have \"... < 2 ^ (length (int_to_bv i) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (int_to_bv i) < 2 ^ (length (int_to_bv i) - 1)", "by (rule bv_to_int_upper_range)"], ["proof (state)\nthis:\n  bv_to_int (int_to_bv i) < 2 ^ (length (int_to_bv i) - 1)\n\ngoal (1 subgoal):\n 1. i < 2 ^ (length (int_to_bv i) - 1)", "finally"], ["proof (chain)\npicking this:\n  i < 2 ^ (length (int_to_bv i) - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i < 2 ^ (length (int_to_bv i) - 1)\n\ngoal (1 subgoal):\n 1. i < 2 ^ (length (int_to_bv i) - 1)", "."], ["proof (state)\nthis:\n  i < 2 ^ (length (int_to_bv i) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < 2 ^ (length (int_to_bv i) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  i < 2 ^ (length (int_to_bv i) - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have \"(2::int) ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)", "using a"], ["proof (prove)\nusing this:\n  length (int_to_bv i) - 1 \\<le> k - 1\n\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  i < 2 ^ (k - 1)", "have \"i < 2 ^ (k - 1)\""], ["proof (prove)\nusing this:\n  i < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. i < 2 ^ (k - 1)", "."], ["proof (state)\nthis:\n  i < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "with wk"], ["proof (chain)\npicking this:\n  2 ^ (k - 1) \\<le> i\n  i < 2 ^ (k - 1)", "show False"], ["proof (prove)\nusing this:\n  2 ^ (k - 1) \\<le> i\n  i < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_int_to_bv_upper_limit_lem1:\n  assumes w1: \"i < -1\"\n  and     wk: \"- (2 ^ (k - 1)) \\<le> i\"\n  shows       \"length (int_to_bv i) \\<le> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv i) \\<le> k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "from w1 wk"], ["proof (chain)\npicking this:\n  i < - 1\n  - (2 ^ (k - 1)) \\<le> i", "have k1: \"1 < k\""], ["proof (prove)\nusing this:\n  i < - 1\n  - (2 ^ (k - 1)) \\<le> i\n\ngoal (1 subgoal):\n 1. 1 < k", "by (cases \"k - 1\") simp_all"], ["proof (state)\nthis:\n  1 < k\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "assume \"~ length (int_to_bv i) \\<le> k\""], ["proof (state)\nthis:\n  \\<not> length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence \"k < length (int_to_bv i)\""], ["proof (prove)\nusing this:\n  \\<not> length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. k < length (int_to_bv i)", "by simp"], ["proof (state)\nthis:\n  k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence \"k \\<le> length (int_to_bv i) - 1\""], ["proof (prove)\nusing this:\n  k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. k \\<le> length (int_to_bv i) - 1", "by arith"], ["proof (state)\nthis:\n  k \\<le> length (int_to_bv i) - 1\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "hence a: \"k - 1 \\<le> length (int_to_bv i) - 2\""], ["proof (prove)\nusing this:\n  k \\<le> length (int_to_bv i) - 1\n\ngoal (1 subgoal):\n 1. k - 1 \\<le> length (int_to_bv i) - 2", "by arith"], ["proof (state)\nthis:\n  k - 1 \\<le> length (int_to_bv i) - 2\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "have \"i < - (2 ^ (length (int_to_bv i) - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < - (2 ^ (length (int_to_bv i) - 2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i < - (2 ^ (length (int_to_bv i) - 2))", "have \"i = bv_to_int (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = bv_to_int (int_to_bv i)", "by simp"], ["proof (state)\nthis:\n  i = bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. i < - (2 ^ (length (int_to_bv i) - 2))", "also"], ["proof (state)\nthis:\n  i = bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. i < - (2 ^ (length (int_to_bv i) - 2))", "have \"... < - (2 ^ (length (norm_signed (int_to_bv i)) - 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (int_to_bv i)\n    < - (2 ^ (length (norm_signed (int_to_bv i)) - 2))", "by (rule bv_to_int_upper_limit_lem1,simp,rule w1)"], ["proof (state)\nthis:\n  bv_to_int (int_to_bv i) < - (2 ^ (length (norm_signed (int_to_bv i)) - 2))\n\ngoal (1 subgoal):\n 1. i < - (2 ^ (length (int_to_bv i) - 2))", "finally"], ["proof (chain)\npicking this:\n  i < - (2 ^ (length (norm_signed (int_to_bv i)) - 2))", "show ?thesis"], ["proof (prove)\nusing this:\n  i < - (2 ^ (length (norm_signed (int_to_bv i)) - 2))\n\ngoal (1 subgoal):\n 1. i < - (2 ^ (length (int_to_bv i) - 2))", "by simp"], ["proof (state)\nthis:\n  i < - (2 ^ (length (int_to_bv i) - 2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < - (2 ^ (length (int_to_bv i) - 2))\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  i < - (2 ^ (length (int_to_bv i) - 2))\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "have \"... \\<le> -(2 ^ (k - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 2)) \\<le> - (2 ^ (k - 1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 2)) \\<le> - (2 ^ (k - 1))", "have \"(2::int) ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)", "using a"], ["proof (prove)\nusing this:\n  k - 1 \\<le> length (int_to_bv i) - 2\n\ngoal (1 subgoal):\n 1. 2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)", "by simp"], ["proof (state)\nthis:\n  2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 2)) \\<le> - (2 ^ (k - 1))", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (k - 1) \\<le> 2 ^ (length (int_to_bv i) - 2)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 2)) \\<le> - (2 ^ (k - 1))", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (length (int_to_bv i) - 2)) \\<le> - (2 ^ (k - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ (length (int_to_bv i) - 2)) \\<le> - (2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  i < - (2 ^ (k - 1))", "have \"i < -(2 ^ (k - 1))\""], ["proof (prove)\nusing this:\n  i < - (2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. i < - (2 ^ (k - 1))", "."], ["proof (state)\nthis:\n  i < - (2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. \\<not> length (int_to_bv i) \\<le> k \\<Longrightarrow> False", "with wk"], ["proof (chain)\npicking this:\n  - (2 ^ (k - 1)) \\<le> i\n  i < - (2 ^ (k - 1))", "show False"], ["proof (prove)\nusing this:\n  - (2 ^ (k - 1)) \\<le> i\n  i < - (2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_int_to_bv_lower_limit_lem1:\n  assumes wk: \"i < -(2 ^ (k - 1))\"\n  shows       \"k < length (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (int_to_bv i)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "from wk"], ["proof (chain)\npicking this:\n  i < - (2 ^ (k - 1))", "have \"i \\<le> -(2 ^ (k - 1)) - 1\""], ["proof (prove)\nusing this:\n  i < - (2 ^ (k - 1))\n\ngoal (1 subgoal):\n 1. i \\<le> - (2 ^ (k - 1)) - 1", "by simp"], ["proof (state)\nthis:\n  i \\<le> - (2 ^ (k - 1)) - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  i \\<le> - (2 ^ (k - 1)) - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have \"... < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) - 1 < - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) - 1 < - 1", "have \"0 < (2::int) ^ (k - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 2 ^ (k - 1)", "by (rule zero_less_power) simp"], ["proof (state)\nthis:\n  0 < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) - 1 < - 1", "hence \"-((2::int) ^ (k - 1)) < 0\""], ["proof (prove)\nusing this:\n  0 < 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) < 0", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (k - 1)) < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) - 1 < - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  - (2 ^ (k - 1)) < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) - 1 < - 1", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (k - 1)) - 1 < - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ (k - 1)) - 1 < - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  i < - 1", "have i1: \"i < -1\""], ["proof (prove)\nusing this:\n  i < - 1\n\ngoal (1 subgoal):\n 1. i < - 1", "."], ["proof (state)\nthis:\n  i < - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have lii0: \"0 < length (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (int_to_bv i)", "apply (rule neg_length_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (int_to_bv i) < - 1", "apply (simp, rule i1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "assume \"~ k < length (int_to_bv i)\""], ["proof (state)\nthis:\n  \\<not> k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "hence \"length (int_to_bv i) \\<le> k\""], ["proof (prove)\nusing this:\n  \\<not> k < length (int_to_bv i)\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) \\<le> k", "by simp"], ["proof (state)\nthis:\n  length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "with lii0"], ["proof (chain)\npicking this:\n  0 < length (int_to_bv i)\n  length (int_to_bv i) \\<le> k", "have a: \"length (int_to_bv i) - 1 \\<le> k - 1\""], ["proof (prove)\nusing this:\n  0 < length (int_to_bv i)\n  length (int_to_bv i) \\<le> k\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) - 1 \\<le> k - 1", "by arith"], ["proof (state)\nthis:\n  length (int_to_bv i) - 1 \\<le> k - 1\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "hence \"(2::int) ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)\""], ["proof (prove)\nusing this:\n  length (int_to_bv i) - 1 \\<le> k - 1\n\ngoal (1 subgoal):\n 1. 2 ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)", "by simp"], ["proof (state)\nthis:\n  2 ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "hence \"-((2::int) ^ (k - 1)) \\<le> - (2 ^ (length (int_to_bv i) - 1))\""], ["proof (prove)\nusing this:\n  2 ^ (length (int_to_bv i) - 1) \\<le> 2 ^ (k - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) \\<le> - (2 ^ (length (int_to_bv i) - 1))", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (k - 1)) \\<le> - (2 ^ (length (int_to_bv i) - 1))\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  - (2 ^ (k - 1)) \\<le> - (2 ^ (length (int_to_bv i) - 1))\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "have \"... \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "have \"- (2 ^ (length (int_to_bv i) - 1)) \\<le> bv_to_int (int_to_bv i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> bv_to_int (int_to_bv i)", "by (rule bv_to_int_lower_range)"], ["proof (state)\nthis:\n  - (2 ^ (length (int_to_bv i) - 1)) \\<le> bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "also"], ["proof (state)\nthis:\n  - (2 ^ (length (int_to_bv i) - 1)) \\<le> bv_to_int (int_to_bv i)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "have \"... = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (int_to_bv i) = i", "by simp"], ["proof (state)\nthis:\n  bv_to_int (int_to_bv i) = i\n\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "show ?thesis"], ["proof (prove)\nusing this:\n  - (2 ^ (length (int_to_bv i) - 1)) \\<le> i\n\ngoal (1 subgoal):\n 1. - (2 ^ (length (int_to_bv i) - 1)) \\<le> i", "."], ["proof (state)\nthis:\n  - (2 ^ (length (int_to_bv i) - 1)) \\<le> i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ (length (int_to_bv i) - 1)) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ (k - 1)) \\<le> i", "have \"-(2 ^ (k - 1)) \\<le> i\""], ["proof (prove)\nusing this:\n  - (2 ^ (k - 1)) \\<le> i\n\ngoal (1 subgoal):\n 1. - (2 ^ (k - 1)) \\<le> i", "."], ["proof (state)\nthis:\n  - (2 ^ (k - 1)) \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> k < length (int_to_bv i) \\<Longrightarrow> False", "with wk"], ["proof (chain)\npicking this:\n  i < - (2 ^ (k - 1))\n  - (2 ^ (k - 1)) \\<le> i", "show False"], ["proof (prove)\nusing this:\n  i < - (2 ^ (k - 1))\n  - (2 ^ (k - 1)) \\<le> i\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Signed Arithmetic Operations\\<close>"], ["", "subsubsection \\<open>Conversion from unsigned to signed\\<close>"], ["", "definition\n  utos :: \"bit list => bit list\" where\n  \"utos w = norm_signed (\\<zero> # w)\""], ["", "lemma utos_type [simp]: \"utos (norm_unsigned w) = utos w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. utos (norm_unsigned w) = utos w", "by (simp add: utos_def norm_signed_Cons)"], ["", "lemma utos_returntype [simp]: \"norm_signed (utos w) = utos w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (utos w) = utos w", "by (simp add: utos_def)"], ["", "lemma utos_length: \"length (utos w) \\<le> Suc (length w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (utos w) \\<le> Suc (length w)", "by (simp add: utos_def norm_signed_Cons)"], ["", "lemma bv_to_int_utos: \"bv_to_int (utos w) = int (bv_to_nat w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w) = int (bv_to_nat w)", "proof (simp add: utos_def norm_signed_Cons, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. norm_unsigned w = [] \\<Longrightarrow> bv_to_nat w = 0", "assume \"norm_unsigned w = []\""], ["proof (state)\nthis:\n  norm_unsigned w = []\n\ngoal (1 subgoal):\n 1. norm_unsigned w = [] \\<Longrightarrow> bv_to_nat w = 0", "hence \"bv_to_nat (norm_unsigned w) = 0\""], ["proof (prove)\nusing this:\n  norm_unsigned w = []\n\ngoal (1 subgoal):\n 1. bv_to_nat (norm_unsigned w) = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_nat (norm_unsigned w) = 0\n\ngoal (1 subgoal):\n 1. norm_unsigned w = [] \\<Longrightarrow> bv_to_nat w = 0", "thus \"bv_to_nat w = 0\""], ["proof (prove)\nusing this:\n  bv_to_nat (norm_unsigned w) = 0\n\ngoal (1 subgoal):\n 1. bv_to_nat w = 0", "by simp"], ["proof (state)\nthis:\n  bv_to_nat w = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Unary minus\\<close>"], ["", "definition\n  bv_uminus :: \"bit list => bit list\" where\n  \"bv_uminus w = int_to_bv (- bv_to_int w)\""], ["", "lemma bv_uminus_type [simp]: \"bv_uminus (norm_signed w) = bv_uminus w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_uminus (norm_signed w) = bv_uminus w", "by (simp add: bv_uminus_def)"], ["", "lemma bv_uminus_returntype [simp]: \"norm_signed (bv_uminus w) = bv_uminus w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (bv_uminus w) = bv_uminus w", "by (simp add: bv_uminus_def)"], ["", "lemma bv_uminus_length: \"length (bv_uminus w) \\<le> Suc (length w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "have \"1 < -bv_to_int w \\<or> -bv_to_int w = 1 \\<or> -bv_to_int w = 0 \\<or> -bv_to_int w = -1 \\<or> -bv_to_int w < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < - bv_to_int w \\<or>\n    - bv_to_int w = 1 \\<or>\n    - bv_to_int w = 0 \\<or> - bv_to_int w = - 1 \\<or> - bv_to_int w < - 1", "by arith"], ["proof (state)\nthis:\n  1 < - bv_to_int w \\<or>\n  - bv_to_int w = 1 \\<or>\n  - bv_to_int w = 0 \\<or> - bv_to_int w = - 1 \\<or> - bv_to_int w < - 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 < - bv_to_int w \\<or>\n  - bv_to_int w = 1 \\<or>\n  - bv_to_int w = 0 \\<or> - bv_to_int w = - 1 \\<or> - bv_to_int w < - 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "proof safe"], ["proof (state)\ngoal (5 subgoals):\n 1. 1 < - bv_to_int w \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 5. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "assume p: \"1 < - bv_to_int w\""], ["proof (state)\nthis:\n  1 < - bv_to_int w\n\ngoal (5 subgoals):\n 1. 1 < - bv_to_int w \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 5. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "have lw: \"0 < length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length w", "apply (rule neg_length_pos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w < - 1", "using p"], ["proof (prove)\nusing this:\n  1 < - bv_to_int w\n\ngoal (1 subgoal):\n 1. bv_to_int w < - 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  0 < length w\n\ngoal (5 subgoals):\n 1. 1 < - bv_to_int w \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 5. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "proof (simp add: bv_uminus_def,rule length_int_to_bv_upper_limit_gt0,simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. bv_to_int w < 0\n 2. - bv_to_int w < 2 ^ length w", "from p"], ["proof (chain)\npicking this:\n  1 < - bv_to_int w", "show \"bv_to_int w < 0\""], ["proof (prove)\nusing this:\n  1 < - bv_to_int w\n\ngoal (1 subgoal):\n 1. bv_to_int w < 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int w < 0\n\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "have \"-(2^(length w - 1)) \\<le> bv_to_int w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w - 1)) \\<le> bv_to_int w", "by (rule bv_to_int_lower_range)"], ["proof (state)\nthis:\n  - (2 ^ (length w - 1)) \\<le> bv_to_int w\n\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "hence \"- bv_to_int w \\<le> 2^(length w - 1)\""], ["proof (prove)\nusing this:\n  - (2 ^ (length w - 1)) \\<le> bv_to_int w\n\ngoal (1 subgoal):\n 1. - bv_to_int w \\<le> 2 ^ (length w - 1)", "by simp"], ["proof (state)\nthis:\n  - bv_to_int w \\<le> 2 ^ (length w - 1)\n\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "also"], ["proof (state)\nthis:\n  - bv_to_int w \\<le> 2 ^ (length w - 1)\n\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "from lw"], ["proof (chain)\npicking this:\n  0 < length w", "have \"... < 2 ^ length w\""], ["proof (prove)\nusing this:\n  0 < length w\n\ngoal (1 subgoal):\n 1. 2 ^ (length w - 1) < 2 ^ length w", "by simp"], ["proof (state)\nthis:\n  2 ^ (length w - 1) < 2 ^ length w\n\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "finally"], ["proof (chain)\npicking this:\n  - bv_to_int w < 2 ^ length w", "show \"- bv_to_int w < 2 ^ length w\""], ["proof (prove)\nusing this:\n  - bv_to_int w < 2 ^ length w\n\ngoal (1 subgoal):\n 1. - bv_to_int w < 2 ^ length w", "by simp"], ["proof (state)\nthis:\n  - bv_to_int w < 2 ^ length w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_uminus w) \\<le> Suc (length w)\n\ngoal (4 subgoals):\n 1. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "assume p: \"- bv_to_int w = 1\""], ["proof (state)\nthis:\n  - bv_to_int w = 1\n\ngoal (4 subgoals):\n 1. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "hence lw: \"0 < length w\""], ["proof (prove)\nusing this:\n  - bv_to_int w = 1\n\ngoal (1 subgoal):\n 1. 0 < length w", "by (cases w) simp_all"], ["proof (state)\nthis:\n  0 < length w\n\ngoal (4 subgoals):\n 1. - bv_to_int w = 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 4. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "from p"], ["proof (chain)\npicking this:\n  - bv_to_int w = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  - bv_to_int w = 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "apply (simp add: bv_uminus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w = - 1 \\<Longrightarrow>\n    length (norm_signed (\\<zero> # nat_to_bv (Suc 0))) \\<le> Suc (length w)", "using lw"], ["proof (prove)\nusing this:\n  0 < length w\n\ngoal (1 subgoal):\n 1. bv_to_int w = - 1 \\<Longrightarrow>\n    length (norm_signed (\\<zero> # nat_to_bv (Suc 0))) \\<le> Suc (length w)", "apply (simp (no_asm) add: nat_to_bv_non0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (bv_uminus w) \\<le> Suc (length w)\n\ngoal (3 subgoals):\n 1. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "assume \"- bv_to_int w = 0\""], ["proof (state)\nthis:\n  - bv_to_int w = 0\n\ngoal (3 subgoals):\n 1. - bv_to_int w = 0 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 3. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - bv_to_int w = 0\n\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "by (simp add: bv_uminus_def)"], ["proof (state)\nthis:\n  length (bv_uminus w) \\<le> Suc (length w)\n\ngoal (2 subgoals):\n 1. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "assume p: \"- bv_to_int w = -1\""], ["proof (state)\nthis:\n  - bv_to_int w = - 1\n\ngoal (2 subgoals):\n 1. - bv_to_int w = - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)\n 2. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - bv_to_int w = - 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "by (simp add: bv_uminus_def)"], ["proof (state)\nthis:\n  length (bv_uminus w) \\<le> Suc (length w)\n\ngoal (1 subgoal):\n 1. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "assume p: \"- bv_to_int w < -1\""], ["proof (state)\nthis:\n  - bv_to_int w < - 1\n\ngoal (1 subgoal):\n 1. - bv_to_int w < - 1 \\<Longrightarrow>\n    length (bv_uminus w) \\<le> Suc (length w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_uminus w) \\<le> Suc (length w)", "apply (simp add: bv_uminus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (- bv_to_int w)) \\<le> Suc (length w)", "apply (rule length_int_to_bv_upper_limit_lem1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - bv_to_int w < - 1\n 2. - (2 ^ (Suc (length w) - 1)) \\<le> - bv_to_int w", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (Suc (length w) - 1)) \\<le> - bv_to_int w", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w \\<le> 2 ^ length w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w \\<le> 2 ^ length w", "have \"bv_to_int w < 2 ^ (length w - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w < 2 ^ (length w - 1)", "by (rule bv_to_int_upper_range)"], ["proof (state)\nthis:\n  bv_to_int w < 2 ^ (length w - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w \\<le> 2 ^ length w", "also"], ["proof (state)\nthis:\n  bv_to_int w < 2 ^ (length w - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w \\<le> 2 ^ length w", "have \"... \\<le> 2 ^ length w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w - 1) \\<le> 2 ^ length w", "by simp"], ["proof (state)\nthis:\n  2 ^ (length w - 1) \\<le> 2 ^ length w\n\ngoal (1 subgoal):\n 1. bv_to_int w \\<le> 2 ^ length w", "finally"], ["proof (chain)\npicking this:\n  bv_to_int w < 2 ^ length w", "show \"bv_to_int w \\<le> 2 ^ length w\""], ["proof (prove)\nusing this:\n  bv_to_int w < 2 ^ length w\n\ngoal (1 subgoal):\n 1. bv_to_int w \\<le> 2 ^ length w", "by simp"], ["proof (state)\nthis:\n  bv_to_int w \\<le> 2 ^ length w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_uminus w) \\<le> Suc (length w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_uminus w) \\<le> Suc (length w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_uminus_length_utos: \"length (bv_uminus (utos w)) \\<le> Suc (length w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "have \"-bv_to_int (utos w) = 0 \\<or> -bv_to_int (utos w) = -1 \\<or> -bv_to_int (utos w) < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - bv_to_int (utos w) = 0 \\<or>\n    - bv_to_int (utos w) = - 1 \\<or> - bv_to_int (utos w) < - 1", "by (simp add: bv_to_int_utos, arith)"], ["proof (state)\nthis:\n  - bv_to_int (utos w) = 0 \\<or>\n  - bv_to_int (utos w) = - 1 \\<or> - bv_to_int (utos w) < - 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - bv_to_int (utos w) = 0 \\<or>\n  - bv_to_int (utos w) = - 1 \\<or> - bv_to_int (utos w) < - 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. - bv_to_int (utos w) = 0 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 2. - bv_to_int (utos w) = - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 3. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "assume \"-bv_to_int (utos w) = 0\""], ["proof (state)\nthis:\n  - bv_to_int (utos w) = 0\n\ngoal (3 subgoals):\n 1. - bv_to_int (utos w) = 0 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 2. - bv_to_int (utos w) = - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 3. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - bv_to_int (utos w) = 0\n\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "by (simp add: bv_uminus_def)"], ["proof (state)\nthis:\n  length (bv_uminus (utos w)) \\<le> Suc (length w)\n\ngoal (2 subgoals):\n 1. - bv_to_int (utos w) = - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 2. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. - bv_to_int (utos w) = - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 2. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "assume \"-bv_to_int (utos w) = -1\""], ["proof (state)\nthis:\n  - bv_to_int (utos w) = - 1\n\ngoal (2 subgoals):\n 1. - bv_to_int (utos w) = - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)\n 2. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "thus ?thesis"], ["proof (prove)\nusing this:\n  - bv_to_int (utos w) = - 1\n\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "by (simp add: bv_uminus_def)"], ["proof (state)\nthis:\n  length (bv_uminus (utos w)) \\<le> Suc (length w)\n\ngoal (1 subgoal):\n 1. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "assume p: \"-bv_to_int (utos w) < -1\""], ["proof (state)\nthis:\n  - bv_to_int (utos w) < - 1\n\ngoal (1 subgoal):\n 1. - bv_to_int (utos w) < - 1 \\<Longrightarrow>\n    length (bv_uminus (utos w)) \\<le> Suc (length w)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_uminus (utos w)) \\<le> Suc (length w)", "apply (simp add: bv_uminus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (- bv_to_int (utos w))) \\<le> Suc (length w)", "apply (rule length_int_to_bv_upper_limit_lem1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - bv_to_int (utos w) < - 1\n 2. - (2 ^ (Suc (length w) - 1)) \\<le> - bv_to_int (utos w)", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (Suc (length w) - 1)) \\<le> - bv_to_int (utos w)", "apply (simp add: bv_to_int_utos)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat w \\<le> 2 ^ length w", "using bv_to_nat_upper_range [of w] int_nat_two_exp"], ["proof (prove)\nusing this:\n  bv_to_nat w < 2 ^ length w\n  2 ^ ?k = int (2 ^ ?k)\n\ngoal (1 subgoal):\n 1. bv_to_nat w \\<le> 2 ^ length w", "apply presburger"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (bv_uminus (utos w)) \\<le> Suc (length w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_uminus (utos w)) \\<le> Suc (length w)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  bv_sadd :: \"[bit list, bit list ] => bit list\" where\n  \"bv_sadd w1 w2 = int_to_bv (bv_to_int w1 + bv_to_int w2)\""], ["", "lemma bv_sadd_type1 [simp]: \"bv_sadd (norm_signed w1) w2 = bv_sadd w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_sadd (norm_signed w1) w2 = bv_sadd w1 w2", "by (simp add: bv_sadd_def)"], ["", "lemma bv_sadd_type2 [simp]: \"bv_sadd w1 (norm_signed w2) = bv_sadd w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_sadd w1 (norm_signed w2) = bv_sadd w1 w2", "by (simp add: bv_sadd_def)"], ["", "lemma bv_sadd_returntype [simp]: \"norm_signed (bv_sadd w1 w2) = bv_sadd w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (bv_sadd w1 w2) = bv_sadd w1 w2", "by (simp add: bv_sadd_def)"], ["", "lemma adder_helper:\n  assumes lw: \"0 < max (length w1) (length w2)\"\n  shows   \"((2::int) ^ (length w1 - 1)) + (2 ^ (length w2 - 1)) \\<le> 2 ^ max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "have \"((2::int) ^ (length w1 - 1)) + (2 ^ (length w2 - 1)) \\<le>\n      2 ^ (max (length w1) (length w2) - 1) + 2 ^ (max (length w1) (length w2) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ (max (length w1) (length w2) - 1) +\n          2 ^ (max (length w1) (length w2) - 1)", "by (auto simp:max_def)"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (max (length w1) (length w2) - 1) +\n        2 ^ (max (length w1) (length w2) - 1)\n\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "also"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (max (length w1) (length w2) - 1) +\n        2 ^ (max (length w1) (length w2) - 1)\n\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "have \"... = 2 ^ max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (max (length w1) (length w2) - 1) +\n    2 ^ (max (length w1) (length w2) - 1) =\n    2 ^ max (length w1) (length w2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ (max (length w1) (length w2) - 1) +\n    2 ^ (max (length w1) (length w2) - 1) =\n    2 ^ max (length w1) (length w2)", "from lw"], ["proof (chain)\npicking this:\n  0 < max (length w1) (length w2)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. 2 ^ (max (length w1) (length w2) - 1) +\n    2 ^ (max (length w1) (length w2) - 1) =\n    2 ^ max (length w1) (length w2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2) \\<Longrightarrow>\n    2 * 2 ^ (max (length w1) (length w2) - Suc 0) =\n    2 ^ max (length w1) (length w2)", "apply (subst power_Suc [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2) \\<Longrightarrow>\n    2 ^ Suc (max (length w1) (length w2) - Suc 0) =\n    2 ^ max (length w1) (length w2)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (max (length w1) (length w2) - 1) +\n  2 ^ (max (length w1) (length w2) - 1) =\n  2 ^ max (length w1) (length w2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ (max (length w1) (length w2) - 1) +\n  2 ^ (max (length w1) (length w2) - 1) =\n  2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "finally"], ["proof (chain)\npicking this:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "."], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_sadd_length: \"length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "let ?Q = \"bv_to_int w1 + bv_to_int w2\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "have helper: \"?Q \\<noteq> 0 ==> 0 < max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    0 < max (length w1) (length w2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    0 < max (length w1) (length w2)", "assume p: \"?Q \\<noteq> 0\""], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    0 < max (length w1) (length w2)", "show \"0 < max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2)", "proof (simp add: less_max_iff_disj,rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. w1 = [] \\<Longrightarrow> w2 \\<noteq> []", "assume [simp]: \"w1 = []\""], ["proof (state)\nthis:\n  w1 = []\n\ngoal (1 subgoal):\n 1. w1 = [] \\<Longrightarrow> w2 \\<noteq> []", "show \"w2 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w2 \\<noteq> []", "proof (rule ccontr,simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. w2 = [] \\<Longrightarrow> False", "assume [simp]: \"w2 = []\""], ["proof (state)\nthis:\n  w2 = []\n\ngoal (1 subgoal):\n 1. w2 = [] \\<Longrightarrow> False", "from p"], ["proof (chain)\npicking this:\n  bv_to_int w1 + bv_to_int w2 \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  bv_to_int w1 + bv_to_int w2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w2 \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < max (length w1) (length w2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n  0 < max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "have \"0 < ?Q \\<or> ?Q = 0 \\<or> ?Q = -1 \\<or> ?Q < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<or>\n    bv_to_int w1 + bv_to_int w2 = 0 \\<or>\n    bv_to_int w1 + bv_to_int w2 = - 1 \\<or>\n    bv_to_int w1 + bv_to_int w2 < - 1", "by arith"], ["proof (state)\nthis:\n  0 < bv_to_int w1 + bv_to_int w2 \\<or>\n  bv_to_int w1 + bv_to_int w2 = 0 \\<or>\n  bv_to_int w1 + bv_to_int w2 = - 1 \\<or> bv_to_int w1 + bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int w1 + bv_to_int w2 \\<or>\n  bv_to_int w1 + bv_to_int w2 = 0 \\<or>\n  bv_to_int w1 + bv_to_int w2 = - 1 \\<or> bv_to_int w1 + bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "proof safe"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 + bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 4. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume \"?Q = 0\""], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 = 0\n\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 + bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 4. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w1 + bv_to_int w2 = 0\n\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "by (simp add: bv_sadd_def)"], ["proof (state)\nthis:\n  length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume \"?Q = -1\""], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 = - 1\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w1 + bv_to_int w2 = - 1\n\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "by (simp add: bv_sadd_def)"], ["proof (state)\nthis:\n  length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume p: \"0 < ?Q\""], ["proof (state)\nthis:\n  0 < bv_to_int w1 + bv_to_int w2\n\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "apply (simp add: bv_sadd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 + bv_to_int w2))\n    \\<le> Suc (max (length w1) (length w2))", "apply (rule length_int_to_bv_upper_limit_gt0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 + bv_to_int w2\n 2. bv_to_int w1 + bv_to_int w2\n    \\<le> 2 ^ (Suc (max (length w1) (length w2)) - 1) - 1", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2\n    \\<le> 2 ^ (Suc (max (length w1) (length w2)) - 1) - 1", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "from bv_to_int_upper_range [of w2]"], ["proof (chain)\npicking this:\n  bv_to_int w2 < 2 ^ (length w2 - 1)", "have \"bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\""], ["proof (prove)\nusing this:\n  bv_to_int w2 < 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<le> 2 ^ (length w2 - 1)", "by simp"], ["proof (state)\nthis:\n  bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "with bv_to_int_upper_range [of w1]"], ["proof (chain)\npicking this:\n  bv_to_int w1 < 2 ^ (length w1 - 1)\n  bv_to_int w2 \\<le> 2 ^ (length w2 - 1)", "have \"bv_to_int w1 + bv_to_int w2 < (2 ^ (length w1 - 1)) + (2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  bv_to_int w1 < 2 ^ (length w1 - 1)\n  bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)", "by (rule add_less_le_mono)"], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 < 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "also"], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 < 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "have \"... \\<le> 2 ^ max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "apply (rule adder_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2)", "apply (rule helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  0 < bv_to_int w1 + bv_to_int w2\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "finally"], ["proof (chain)\npicking this:\n  bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "show \"?Q < 2 ^ max (length w1) (length w2)\""], ["proof (prove)\nusing this:\n  bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)", "."], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 < 2 ^ max (length w1) (length w2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume p: \"?Q < -1\""], ["proof (state)\nthis:\n  bv_to_int w1 + bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))", "apply (simp add: bv_sadd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 + bv_to_int w2))\n    \\<le> Suc (max (length w1) (length w2))", "apply (rule length_int_to_bv_upper_limit_lem1,simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_int w1 + bv_to_int w2 < - 1\n 2. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "have \"(2 ^ (length w1 - 1)) + 2 ^ (length w2 - 1) \\<le> (2::int) ^ max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "apply (rule adder_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2)", "apply (rule helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  bv_to_int w1 + bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w1 + bv_to_int w2 \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "hence \"-((2::int) ^ max (length w1) (length w2)) \\<le> - (2 ^ (length w1 - 1)) + -(2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2))\n    \\<le> - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))", "by simp"], ["proof (state)\nthis:\n  - (2 ^ max (length w1) (length w2))\n  \\<le> - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "also"], ["proof (state)\nthis:\n  - (2 ^ max (length w1) (length w2))\n  \\<le> - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "have \"- (2 ^ (length w1 - 1)) + -(2 ^ (length w2 - 1)) \\<le> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n    \\<le> bv_to_int w1 + bv_to_int w2", "apply (rule add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (2 ^ (length w1 - 1)) \\<le> bv_to_int w1\n 2. - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2", "apply (rule bv_to_int_lower_range [of w1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2", "apply (rule bv_to_int_lower_range [of w2])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n  \\<le> bv_to_int w1 + bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "show \"- (2^max (length w1) (length w2)) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2", "."], ["proof (state)\nthis:\n  - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sadd w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  bv_sub :: \"[bit list, bit list] => bit list\" where\n  \"bv_sub w1 w2 = bv_sadd w1 (bv_uminus w2)\""], ["", "lemma bv_sub_type1 [simp]: \"bv_sub (norm_signed w1) w2 = bv_sub w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_sub (norm_signed w1) w2 = bv_sub w1 w2", "by (simp add: bv_sub_def)"], ["", "lemma bv_sub_type2 [simp]: \"bv_sub w1 (norm_signed w2) = bv_sub w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_sub w1 (norm_signed w2) = bv_sub w1 w2", "by (simp add: bv_sub_def)"], ["", "lemma bv_sub_returntype [simp]: \"norm_signed (bv_sub w1 w2) = bv_sub w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (bv_sub w1 w2) = bv_sub w1 w2", "by (simp add: bv_sub_def)"], ["", "lemma bv_sub_length: \"length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "proof (cases \"bv_to_int w2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume p: \"bv_to_int w2 = 0\""], ["proof (state)\nthis:\n  bv_to_int w2 = 0\n\ngoal (2 subgoals):\n 1. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "proof (simp add: bv_sub_def bv_sadd_def bv_uminus_def p)"], ["proof (state)\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "have \"length (norm_signed w1) \\<le> length w1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> length w1", "by (rule norm_signed_length)"], ["proof (state)\nthis:\n  length (norm_signed w1) \\<le> length w1\n\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "also"], ["proof (state)\nthis:\n  length (norm_signed w1) \\<le> length w1\n\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "have \"... \\<le> max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w1 \\<le> max (length w1) (length w2)", "by (rule max.cobounded1)"], ["proof (state)\nthis:\n  length w1 \\<le> max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "also"], ["proof (state)\nthis:\n  length w1 \\<le> max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "have \"... \\<le> Suc (max (length w1) (length w2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (length w1) (length w2) \\<le> Suc (max (length w1) (length w2))", "by arith"], ["proof (state)\nthis:\n  max (length w1) (length w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "finally"], ["proof (chain)\npicking this:\n  length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "show \"length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))\""], ["proof (prove)\nusing this:\n  length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))\n\ngoal (1 subgoal):\n 1. length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))", "."], ["proof (state)\nthis:\n  length (norm_signed w1) \\<le> Suc (max (length w1) (length w2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume \"bv_to_int w2 \\<noteq> 0\""], ["proof (state)\nthis:\n  bv_to_int w2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "hence \"0 < length w2\""], ["proof (prove)\nusing this:\n  bv_to_int w2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < length w2", "by (cases w2,simp_all)"], ["proof (state)\nthis:\n  0 < length w2\n\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "hence lmw: \"0 < max (length w1) (length w2)\""], ["proof (prove)\nusing this:\n  0 < length w2\n\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2)", "by arith"], ["proof (state)\nthis:\n  0 < max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "let ?Q = \"bv_to_int w1 - bv_to_int w2\""], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "have \"0 < ?Q \\<or> ?Q = 0 \\<or> ?Q = -1 \\<or> ?Q < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<or>\n    bv_to_int w1 - bv_to_int w2 = 0 \\<or>\n    bv_to_int w1 - bv_to_int w2 = - 1 \\<or>\n    bv_to_int w1 - bv_to_int w2 < - 1", "by arith"], ["proof (state)\nthis:\n  0 < bv_to_int w1 - bv_to_int w2 \\<or>\n  bv_to_int w1 - bv_to_int w2 = 0 \\<or>\n  bv_to_int w1 - bv_to_int w2 = - 1 \\<or> bv_to_int w1 - bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int w1 - bv_to_int w2 \\<or>\n  bv_to_int w1 - bv_to_int w2 = 0 \\<or>\n  bv_to_int w1 - bv_to_int w2 = - 1 \\<or> bv_to_int w1 - bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "proof safe"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 - bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 4. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume \"?Q = 0\""], ["proof (state)\nthis:\n  bv_to_int w1 - bv_to_int w2 = 0\n\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 - bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 4. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w1 - bv_to_int w2 = 0\n\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "by (simp add: bv_sub_def bv_sadd_def bv_uminus_def)"], ["proof (state)\nthis:\n  length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume \"?Q = -1\""], ["proof (state)\nthis:\n  bv_to_int w1 - bv_to_int w2 = - 1\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 3. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w1 - bv_to_int w2 = - 1\n\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "by (simp add: bv_sub_def bv_sadd_def bv_uminus_def)"], ["proof (state)\nthis:\n  length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume p: \"0 < ?Q\""], ["proof (state)\nthis:\n  0 < bv_to_int w1 - bv_to_int w2\n\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n 2. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "apply (simp add: bv_sub_def bv_sadd_def bv_uminus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 - bv_to_int w2))\n    \\<le> Suc (max (length w1) (length w2))", "apply (rule length_int_to_bv_upper_limit_gt0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 - bv_to_int w2\n 2. bv_to_int w1 - bv_to_int w2\n    \\<le> 2 ^ (Suc (max (length w1) (length w2)) - 1) - 1", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2\n    \\<le> 2 ^ (Suc (max (length w1) (length w2)) - 1) - 1", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "from bv_to_int_lower_range [of w2]"], ["proof (chain)\npicking this:\n  - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2", "have v2: \"- bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\""], ["proof (prove)\nusing this:\n  - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2\n\ngoal (1 subgoal):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)", "by simp"], ["proof (state)\nthis:\n  - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "have \"bv_to_int w1 + - bv_to_int w2 < (2 ^ (length w1 - 1)) + (2 ^ (length w2 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 + - bv_to_int w2\n    < 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)", "apply (rule add_less_le_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_int w1 < 2 ^ (length w1 - 1)\n 2. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)", "apply (rule bv_to_int_upper_range [of w1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)", "apply (rule v2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_to_int w1 + - bv_to_int w2 < 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "also"], ["proof (state)\nthis:\n  bv_to_int w1 + - bv_to_int w2 < 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "have \"... \\<le> 2 ^ max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "apply (rule adder_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2)", "apply (rule lmw)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "finally"], ["proof (chain)\npicking this:\n  bv_to_int w1 + - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "show \"?Q < 2 ^ max (length w1) (length w2)\""], ["proof (prove)\nusing this:\n  bv_to_int w1 + - bv_to_int w2 < 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)", "by simp"], ["proof (state)\nthis:\n  bv_to_int w1 - bv_to_int w2 < 2 ^ max (length w1) (length w2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "assume p: \"?Q < -1\""], ["proof (state)\nthis:\n  bv_to_int w1 - bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w1 - bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))", "apply (simp add: bv_sub_def bv_sadd_def bv_uminus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 - bv_to_int w2))\n    \\<le> Suc (max (length w1) (length w2))", "apply (rule length_int_to_bv_upper_limit_lem1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_int w1 - bv_to_int w2 < - 1\n 2. - (2 ^ (Suc (max (length w1) (length w2)) - 1))\n    \\<le> bv_to_int w1 - bv_to_int w2", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (Suc (max (length w1) (length w2)) - 1))\n    \\<le> bv_to_int w1 - bv_to_int w2", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2", "have \"(2 ^ (length w1 - 1)) + 2 ^ (length w2 - 1) \\<le> (2::int) ^ max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n    \\<le> 2 ^ max (length w1) (length w2)", "apply (rule adder_helper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < max (length w1) (length w2)", "apply (rule lmw)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2", "hence \"-((2::int) ^ max (length w1) (length w2)) \\<le> - (2 ^ (length w1 - 1)) + -(2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  2 ^ (length w1 - 1) + 2 ^ (length w2 - 1)\n  \\<le> 2 ^ max (length w1) (length w2)\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2))\n    \\<le> - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))", "by simp"], ["proof (state)\nthis:\n  - (2 ^ max (length w1) (length w2))\n  \\<le> - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2", "also"], ["proof (state)\nthis:\n  - (2 ^ max (length w1) (length w2))\n  \\<le> - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2", "have \"- (2 ^ (length w1 - 1)) + -(2 ^ (length w2 - 1)) \\<le> bv_to_int w1 + -bv_to_int w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n    \\<le> bv_to_int w1 + - bv_to_int w2", "apply (rule add_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. - (2 ^ (length w1 - 1)) \\<le> bv_to_int w1\n 2. - (2 ^ (length w2 - 1)) \\<le> - bv_to_int w2", "apply (rule bv_to_int_lower_range [of w1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w2 - 1)) \\<le> - bv_to_int w2", "using bv_to_int_upper_range [of w2]"], ["proof (prove)\nusing this:\n  bv_to_int w2 < 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w2 - 1)) \\<le> - bv_to_int w2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - (2 ^ (length w1 - 1)) + - (2 ^ (length w2 - 1))\n  \\<le> bv_to_int w1 + - bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + - bv_to_int w2", "show \"- (2^max (length w1) (length w2)) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 + - bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2", "by simp"], ["proof (state)\nthis:\n  - (2 ^ max (length w1) (length w2)) \\<le> bv_to_int w1 - bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_sub w1 w2) \\<le> Suc (max (length w1) (length w2))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  bv_smult :: \"[bit list, bit list] => bit list\" where\n  \"bv_smult w1 w2 = int_to_bv (bv_to_int w1 * bv_to_int w2)\""], ["", "lemma bv_smult_type1 [simp]: \"bv_smult (norm_signed w1) w2 = bv_smult w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_smult (norm_signed w1) w2 = bv_smult w1 w2", "by (simp add: bv_smult_def)"], ["", "lemma bv_smult_type2 [simp]: \"bv_smult w1 (norm_signed w2) = bv_smult w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_smult w1 (norm_signed w2) = bv_smult w1 w2", "by (simp add: bv_smult_def)"], ["", "lemma bv_smult_returntype [simp]: \"norm_signed (bv_smult w1 w2) = bv_smult w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm_signed (bv_smult w1 w2) = bv_smult w1 w2", "by (simp add: bv_smult_def)"], ["", "lemma bv_smult_length: \"length (bv_smult w1 w2) \\<le> length w1 + length w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "let ?Q = \"bv_to_int w1 * bv_to_int w2\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "have lmw: \"?Q \\<noteq> 0 ==> 0 < length w1 \\<and> 0 < length w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    0 < length w1 \\<and> 0 < length w2", "by auto"], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n  0 < length w1 \\<and> 0 < length w2\n\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "have \"0 < ?Q \\<or> ?Q = 0 \\<or> ?Q = -1 \\<or> ?Q < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<or>\n    bv_to_int w1 * bv_to_int w2 = 0 \\<or>\n    bv_to_int w1 * bv_to_int w2 = - 1 \\<or>\n    bv_to_int w1 * bv_to_int w2 < - 1", "by arith"], ["proof (state)\nthis:\n  0 < bv_to_int w1 * bv_to_int w2 \\<or>\n  bv_to_int w1 * bv_to_int w2 = 0 \\<or>\n  bv_to_int w1 * bv_to_int w2 = - 1 \\<or> bv_to_int w1 * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int w1 * bv_to_int w2 \\<or>\n  bv_to_int w1 * bv_to_int w2 = 0 \\<or>\n  bv_to_int w1 * bv_to_int w2 = - 1 \\<or> bv_to_int w1 * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "proof (safe dest!: iffD1 [OF mult_eq_0_iff])"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 4. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 5. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume \"bv_to_int w1 = 0\""], ["proof (state)\nthis:\n  bv_to_int w1 = 0\n\ngoal (5 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 4. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 5. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w1 = 0\n\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "by (simp add: bv_smult_def)"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 4. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 4. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume \"bv_to_int w2 = 0\""], ["proof (state)\nthis:\n  bv_to_int w2 = 0\n\ngoal (4 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 4. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w2 = 0\n\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "by (simp add: bv_smult_def)"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume p: \"?Q = -1\""], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 = - 1\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 3. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "apply (simp add: bv_smult_def p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 \\<le> length w1 + length w2", "apply (cut_tac lmw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length w1 \\<and> 0 < length w2 \\<Longrightarrow>\n    Suc 0 \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  bv_to_int w1 * bv_to_int w2 = - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume p: \"0 < ?Q\""], ["proof (state)\nthis:\n  0 < bv_to_int w1 * bv_to_int w2\n\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int w1 * bv_to_int w2\n\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "proof (simp add: zero_less_mult_iff,safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; 0 < bv_to_int w1;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume bi1: \"0 < bv_to_int w1\""], ["proof (state)\nthis:\n  0 < bv_to_int w1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; 0 < bv_to_int w1;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume bi2: \"0 < bv_to_int w2\""], ["proof (state)\nthis:\n  0 < bv_to_int w2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; 0 < bv_to_int w1;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2\n 2. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "apply (simp add: bv_smult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 * bv_to_int w2))\n    \\<le> length w1 + length w2", "apply (rule length_int_to_bv_upper_limit_gt0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2\n 2. bv_to_int w1 * bv_to_int w2 \\<le> 2 ^ (length w1 + length w2 - 1) - 1", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 \\<le> 2 ^ (length w1 + length w2 - 1) - 1", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "have \"?Q < 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)", "apply (rule mult_strict_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. bv_to_int w1 < 2 ^ (length w1 - 1)\n 2. bv_to_int w2 < 2 ^ (length w2 - 1)\n 3. 0 < 2 ^ (length w1 - 1)\n 4. 0 \\<le> bv_to_int w2", "apply (rule bv_to_int_upper_range)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bv_to_int w2 < 2 ^ (length w2 - 1)\n 2. 0 < 2 ^ (length w1 - 1)\n 3. 0 \\<le> bv_to_int w2", "apply (rule bv_to_int_upper_range)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 2 ^ (length w1 - 1)\n 2. 0 \\<le> bv_to_int w2", "apply (rule zero_less_power)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 2\n 2. 0 \\<le> bv_to_int w2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w2", "using bi2"], ["proof (prove)\nusing this:\n  0 < bv_to_int w2\n\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "also"], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "have \"... \\<le> 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply (subst power_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - Suc 0 + (length w2 - Suc 0))\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "finally"], ["proof (chain)\npicking this:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "show \"?Q < 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\nusing this:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "."], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume bi1: \"bv_to_int w1 < 0\""], ["proof (state)\nthis:\n  bv_to_int w1 < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume bi2: \"bv_to_int w2 < 0\""], ["proof (state)\nthis:\n  bv_to_int w2 < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int w1 * bv_to_int w2; bv_to_int w1 < 0;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult w1 w2) \\<le> length w1 + length w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "apply (simp add: bv_smult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 * bv_to_int w2))\n    \\<le> length w1 + length w2", "apply (rule length_int_to_bv_upper_limit_gt0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < bv_to_int w1 * bv_to_int w2\n 2. bv_to_int w1 * bv_to_int w2 \\<le> 2 ^ (length w1 + length w2 - 1) - 1", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 \\<le> 2 ^ (length w1 + length w2 - 1) - 1", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "have \"-bv_to_int w1 * -bv_to_int w2 \\<le> 2 ^ (length w1 - 1) * 2 ^(length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - bv_to_int w1 * - bv_to_int w2\n    \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)", "apply (rule mult_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. - bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 2. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> 2 ^ (length w1 - 1)\n 4. 0 \\<le> - bv_to_int w2", "using bv_to_int_lower_range [of w1]"], ["proof (prove)\nusing this:\n  - (2 ^ (length w1 - 1)) \\<le> bv_to_int w1\n\ngoal (4 subgoals):\n 1. - bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 2. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> 2 ^ (length w1 - 1)\n 4. 0 \\<le> - bv_to_int w2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. 0 \\<le> 2 ^ (length w1 - 1)\n 3. 0 \\<le> - bv_to_int w2", "using bv_to_int_lower_range [of w2]"], ["proof (prove)\nusing this:\n  - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2\n\ngoal (3 subgoals):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. 0 \\<le> 2 ^ (length w1 - 1)\n 3. 0 \\<le> - bv_to_int w2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 2 ^ (length w1 - 1)\n 2. 0 \\<le> - bv_to_int w2", "apply (rule zero_le_power,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> - bv_to_int w2", "using bi2"], ["proof (prove)\nusing this:\n  bv_to_int w2 < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> - bv_to_int w2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - bv_to_int w1 * - bv_to_int w2\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "hence \"?Q \\<le> 2 ^ (length w1 - 1) * 2 ^(length w2 - 1)\""], ["proof (prove)\nusing this:\n  - bv_to_int w1 * - bv_to_int w2\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2\n    \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)", "by simp"], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "also"], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "have \"... < 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n    < 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0)\n    < 2 ^ (length w1 + length w2 - Suc 0)", "apply (subst power_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - Suc 0 + (length w2 - Suc 0))\n    < 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. length w1 - Suc 0 + (length w2 - Suc 0) < length w1 + length w2 - Suc 0", "apply (cut_tac lmw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length w1 \\<and> 0 < length w2 \\<Longrightarrow>\n    length w1 - Suc 0 + (length w2 - Suc 0) < length w1 + length w2 - Suc 0\n 2. bv_to_int w1 * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 \\<noteq> 0", "apply (cut_tac p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_int w1 * bv_to_int w2 \\<Longrightarrow>\n    bv_to_int w1 * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n  < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "finally"], ["proof (chain)\npicking this:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "show \"?Q < 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\nusing this:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "."], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "assume p: \"?Q < -1\""], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult w1 w2) \\<le> length w1 + length w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult w1 w2) \\<le> length w1 + length w2", "apply (subst bv_smult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int w1 * bv_to_int w2))\n    \\<le> length w1 + length w2", "apply (rule length_int_to_bv_upper_limit_lem1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_int w1 * bv_to_int w2 < - 1\n 2. - (2 ^ (length w1 + length w2 - 1)) \\<le> bv_to_int w1 * bv_to_int w2", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - 1)) \\<le> bv_to_int w1 * bv_to_int w2", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "have \"(2::int) ^ (length w1 - 1) * 2 ^(length w2 - 1) \\<le> 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply (subst power_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 - Suc 0 + (length w2 - Suc 0))\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "hence \"-((2::int) ^ (length w1 + length w2 - Suc 0)) \\<le> -(2^(length w1 - 1) * 2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "also"], ["proof (state)\nthis:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "have \"... \\<le> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int w1 * bv_to_int w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int w1 * bv_to_int w2", "from p"], ["proof (chain)\npicking this:\n  bv_to_int w1 * bv_to_int w2 < - 1", "have q: \"bv_to_int w1 * bv_to_int w2 < 0\""], ["proof (prove)\nusing this:\n  bv_to_int w1 * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int w1 * bv_to_int w2 < 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int w1 * bv_to_int w2 < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int w1 * bv_to_int w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w1 * bv_to_int w2 < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int w1 * bv_to_int w2", "proof (simp add: mult_less_0_iff,safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; 0 < bv_to_int w1;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2\n 2. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "assume bi1: \"0 < bv_to_int w1\""], ["proof (state)\nthis:\n  0 < bv_to_int w1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; 0 < bv_to_int w1;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2\n 2. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "assume bi2: \"bv_to_int w2 < 0\""], ["proof (state)\nthis:\n  bv_to_int w2 < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; 0 < bv_to_int w1;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2\n 2. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "have \"-bv_to_int w2 * bv_to_int w1 \\<le> ((2::int)^(length w2 - 1)) * (2 ^ (length w1 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - bv_to_int w2 * bv_to_int w1\n    \\<le> 2 ^ (length w2 - 1) * 2 ^ (length w1 - 1)", "apply (rule mult_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 3. 0 \\<le> 2 ^ (length w2 - 1)\n 4. 0 \\<le> bv_to_int w1", "using bv_to_int_lower_range [of w2]"], ["proof (prove)\nusing this:\n  - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2\n\ngoal (4 subgoals):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 3. 0 \\<le> 2 ^ (length w2 - 1)\n 4. 0 \\<le> bv_to_int w1", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 2. 0 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> bv_to_int w1", "using bv_to_int_upper_range [of w1]"], ["proof (prove)\nusing this:\n  bv_to_int w1 < 2 ^ (length w1 - 1)\n\ngoal (3 subgoals):\n 1. bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 2. 0 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> bv_to_int w1", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 2 ^ (length w2 - 1)\n 2. 0 \\<le> bv_to_int w1", "apply (rule zero_le_power,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w1", "using bi1"], ["proof (prove)\nusing this:\n  0 < bv_to_int w1\n\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - bv_to_int w2 * bv_to_int w1\n  \\<le> 2 ^ (length w2 - 1) * 2 ^ (length w1 - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; 0 < bv_to_int w1;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2\n 2. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "hence \"-?Q \\<le> ((2::int)^(length w1 - 1)) * (2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  - bv_to_int w2 * bv_to_int w1\n  \\<le> 2 ^ (length w2 - 1) * 2 ^ (length w1 - 1)\n\ngoal (1 subgoal):\n 1. - (bv_to_int w1 * bv_to_int w2)\n    \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  - (bv_to_int w1 * bv_to_int w2)\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; 0 < bv_to_int w1;\n     bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2\n 2. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "thus \"-(((2::int)^(length w1 - Suc 0)) * (2 ^ (length w2 - Suc 0))) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (bv_to_int w1 * bv_to_int w2)\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n  \\<le> bv_to_int w1 * bv_to_int w2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "assume bi1: \"bv_to_int w1 < 0\""], ["proof (state)\nthis:\n  bv_to_int w1 < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "assume bi2: \"0 < bv_to_int w2\""], ["proof (state)\nthis:\n  0 < bv_to_int w2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "have \"-bv_to_int w1 * bv_to_int w2 \\<le> ((2::int)^(length w1 - 1)) * (2 ^ (length w2 - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - bv_to_int w1 * bv_to_int w2\n    \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)", "apply (rule mult_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. - bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 2. bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> 2 ^ (length w1 - 1)\n 4. 0 \\<le> bv_to_int w2", "using bv_to_int_lower_range [of w1]"], ["proof (prove)\nusing this:\n  - (2 ^ (length w1 - 1)) \\<le> bv_to_int w1\n\ngoal (4 subgoals):\n 1. - bv_to_int w1 \\<le> 2 ^ (length w1 - 1)\n 2. bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> 2 ^ (length w1 - 1)\n 4. 0 \\<le> bv_to_int w2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. 0 \\<le> 2 ^ (length w1 - 1)\n 3. 0 \\<le> bv_to_int w2", "using bv_to_int_upper_range [of w2]"], ["proof (prove)\nusing this:\n  bv_to_int w2 < 2 ^ (length w2 - 1)\n\ngoal (3 subgoals):\n 1. bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. 0 \\<le> 2 ^ (length w1 - 1)\n 3. 0 \\<le> bv_to_int w2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 2 ^ (length w1 - 1)\n 2. 0 \\<le> bv_to_int w2", "apply (rule zero_le_power,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w2", "using bi2"], ["proof (prove)\nusing this:\n  0 < bv_to_int w2\n\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - bv_to_int w1 * bv_to_int w2\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "hence \"-?Q \\<le> ((2::int)^(length w1 - 1)) * (2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  - bv_to_int w1 * bv_to_int w2\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. - (bv_to_int w1 * bv_to_int w2)\n    \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  - (bv_to_int w1 * bv_to_int w2)\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int w1 * bv_to_int w2 < 0; bv_to_int w1 < 0;\n     0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int w1 * bv_to_int w2", "thus \"-(((2::int)^(length w1 - Suc 0)) * (2 ^ (length w2 - Suc 0))) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (bv_to_int w1 * bv_to_int w2)\n  \\<le> 2 ^ (length w1 - 1) * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (length w1 - Suc 0) * 2 ^ (length w2 - Suc 0))\n  \\<le> bv_to_int w1 * bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n  \\<le> bv_to_int w1 * bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ (length w1 - 1) * 2 ^ (length w2 - 1))\n  \\<le> bv_to_int w1 * bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ (length w1 + length w2 - Suc 0)) \\<le> bv_to_int w1 * bv_to_int w2", "show \"-(2 ^ (length w1 + length w2 - Suc 0)) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (2 ^ (length w1 + length w2 - Suc 0)) \\<le> bv_to_int w1 * bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int w1 * bv_to_int w2", "."], ["proof (state)\nthis:\n  - (2 ^ (length w1 + length w2 - Suc 0)) \\<le> bv_to_int w1 * bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult w1 w2) \\<le> length w1 + length w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_msb_one: \"bv_msb w = \\<one> ==> bv_to_nat w \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow> bv_to_nat w \\<noteq> 0", "by (cases w) simp_all"], ["", "lemma bv_smult_length_utos: \"length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "let ?Q = \"bv_to_int (utos w1) * bv_to_int w2\""], ["proof (state)\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "have lmw: \"?Q \\<noteq> 0 ==> 0 < length (utos w1) \\<and> 0 < length w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n    0 < length (utos w1) \\<and> 0 < length w2", "by auto"], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0 \\<Longrightarrow>\n  0 < length (utos w1) \\<and> 0 < length w2\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "have \"0 < ?Q \\<or> ?Q = 0 \\<or> ?Q = -1 \\<or> ?Q < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<or>\n    bv_to_int (utos w1) * bv_to_int w2 = 0 \\<or>\n    bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<or>\n    bv_to_int (utos w1) * bv_to_int w2 < - 1", "by arith"], ["proof (state)\nthis:\n  0 < bv_to_int (utos w1) * bv_to_int w2 \\<or>\n  bv_to_int (utos w1) * bv_to_int w2 = 0 \\<or>\n  bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<or>\n  bv_to_int (utos w1) * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int (utos w1) * bv_to_int w2 \\<or>\n  bv_to_int (utos w1) * bv_to_int w2 = 0 \\<or>\n  bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<or>\n  bv_to_int (utos w1) * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "proof (safe dest!: iffD1 [OF mult_eq_0_iff])"], ["proof (state)\ngoal (5 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 4. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 5. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "assume \"bv_to_int (utos w1) = 0\""], ["proof (state)\nthis:\n  bv_to_int (utos w1) = 0\n\ngoal (5 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 4. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 5. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) = 0\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "by (simp add: bv_smult_def)"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal (4 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 4. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 4. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "assume \"bv_to_int w2 = 0\""], ["proof (state)\nthis:\n  bv_to_int w2 = 0\n\ngoal (4 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int w2 = 0 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 4. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int w2 = 0\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "by (simp add: bv_smult_def)"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "assume p: \"0 < ?Q\""], ["proof (state)\nthis:\n  0 < bv_to_int (utos w1) * bv_to_int w2\n\ngoal (3 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 3. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < bv_to_int (utos w1) * bv_to_int w2\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "proof (simp add: zero_less_mult_iff,safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     0 < bv_to_int (utos w1); 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2\n 2. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     bv_to_int (utos w1) < 0; bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2", "assume biw2: \"0 < bv_to_int w2\""], ["proof (state)\nthis:\n  0 < bv_to_int w2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     0 < bv_to_int (utos w1); 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2\n 2. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     bv_to_int (utos w1) < 0; bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "apply (simp add: bv_smult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int (utos w1) * bv_to_int w2))\n    \\<le> length w1 + length w2", "apply (rule length_int_to_bv_upper_limit_gt0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < bv_to_int (utos w1) * bv_to_int w2\n 2. bv_to_int (utos w1) * bv_to_int w2\n    \\<le> 2 ^ (length w1 + length w2 - 1) - 1", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2\n    \\<le> 2 ^ (length w1 + length w2 - 1) - 1", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "have \"?Q < 2 ^ length w1 * 2 ^ (length w2 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 2 ^ length w1 * 2 ^ (length w2 - 1)", "apply (rule mult_strict_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. bv_to_int (utos w1) < 2 ^ length w1\n 2. bv_to_int w2 < 2 ^ (length w2 - 1)\n 3. 0 < 2 ^ length w1\n 4. 0 \\<le> bv_to_int w2", "apply (simp add: bv_to_int_utos bv_to_nat_upper_range int_nat_two_exp del: of_nat_power)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bv_to_int w2 < 2 ^ (length w2 - 1)\n 2. 0 < 2 ^ length w1\n 3. 0 \\<le> bv_to_int w2", "apply (rule bv_to_int_upper_range)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 2 ^ length w1\n 2. 0 \\<le> bv_to_int w2", "apply (rule zero_less_power,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w2", "using biw2"], ["proof (prove)\nusing this:\n  0 < bv_to_int w2\n\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int w2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 < 2 ^ length w1 * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "also"], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 < 2 ^ length w1 * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "have \"... \\<le> 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length w1 * 2 ^ (length w2 - 1)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length w1 * 2 ^ (length w2 - Suc 0)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply (subst power_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 + (length w2 - Suc 0))\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. length w1 + (length w2 - Suc 0) \\<le> length w1 + length w2 - Suc 0", "apply (cut_tac lmw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length (utos w1) \\<and> 0 < length w2 \\<Longrightarrow>\n    length w1 + (length w2 - Suc 0) \\<le> length w1 + length w2 - Suc 0\n 2. bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "using p"], ["proof (prove)\nusing this:\n  0 < bv_to_int (utos w1) * bv_to_int w2\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ length w1 * 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "finally"], ["proof (chain)\npicking this:\n  bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "show \"?Q < 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)", "."], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 < 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     bv_to_int (utos w1) < 0; bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     bv_to_int (utos w1) < 0; bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2", "assume \"bv_to_int (utos w1) < 0\""], ["proof (state)\nthis:\n  bv_to_int (utos w1) < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < bv_to_int (utos w1) * bv_to_int w2;\n     bv_to_int (utos w1) < 0; bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> length (bv_smult (utos w1) w2)\n                      \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) < 0\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "by (simp add: bv_to_int_utos)"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal (2 subgoals):\n 1. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "assume p: \"?Q = -1\""], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 = - 1\n\ngoal (2 subgoals):\n 1. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) * bv_to_int w2 = - 1\n\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "apply (simp add: bv_smult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    Suc 0 \\<le> length w1 + length w2", "apply (cut_tac lmw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 = - 1;\n     0 < length (utos w1) \\<and> 0 < length w2\\<rbrakk>\n    \\<Longrightarrow> Suc 0 \\<le> length w1 + length w2\n 2. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 = - 1 \\<Longrightarrow>\n    bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "assume p: \"?Q < -1\""], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_smult (utos w1) w2) \\<le> length w1 + length w2", "apply (subst bv_smult_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv (bv_to_int (utos w1) * bv_to_int w2))\n    \\<le> length w1 + length w2", "apply (rule length_int_to_bv_upper_limit_lem1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_int (utos w1) * bv_to_int w2 < - 1\n 2. - (2 ^ (length w1 + length w2 - 1))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "apply (rule p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - 1))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "proof simp"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "have \"(2::int) ^ length w1 * 2 ^(length w2 - 1) \\<le> 2 ^ (length w1 + length w2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length w1 * 2 ^ (length w2 - 1)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ length w1 * 2 ^ (length w2 - Suc 0)\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply (subst power_add [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (length w1 + (length w2 - Suc 0))\n    \\<le> 2 ^ (length w1 + length w2 - Suc 0)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. length w1 + (length w2 - Suc 0) \\<le> length w1 + length w2 - Suc 0", "apply (cut_tac lmw)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < length (utos w1) \\<and> 0 < length w2 \\<Longrightarrow>\n    length w1 + (length w2 - Suc 0) \\<le> length w1 + length w2 - Suc 0\n 2. bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply (cut_tac p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < - 1 \\<Longrightarrow>\n    bv_to_int (utos w1) * bv_to_int w2 \\<noteq> 0", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  2 ^ length w1 * 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "hence \"-((2::int) ^ (length w1 + length w2 - Suc 0)) \\<le> -(2^ length w1 * 2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  2 ^ length w1 * 2 ^ (length w2 - 1)\n  \\<le> 2 ^ (length w1 + length w2 - Suc 0)\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> - (2 ^ length w1 * 2 ^ (length w2 - 1))", "by simp"], ["proof (state)\nthis:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> - (2 ^ length w1 * 2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "also"], ["proof (state)\nthis:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> - (2 ^ length w1 * 2 ^ (length w2 - 1))\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "have \"... \\<le> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (2 ^ length w1 * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (2 ^ length w1 * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "from p"], ["proof (chain)\npicking this:\n  bv_to_int (utos w1) * bv_to_int w2 < - 1", "have q: \"bv_to_int (utos w1) * bv_to_int w2 < 0\""], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) * bv_to_int w2 < - 1\n\ngoal (1 subgoal):\n 1. bv_to_int (utos w1) * bv_to_int w2 < 0", "by simp"], ["proof (state)\nthis:\n  bv_to_int (utos w1) * bv_to_int w2 < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ length w1 * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "thus ?thesis"], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) * bv_to_int w2 < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ length w1 * 2 ^ (length w2 - 1))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "proof (simp add: mult_less_0_iff,safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     0 < bv_to_int (utos w1); bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2\n 2. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "assume bi1: \"0 < bv_to_int (utos w1)\""], ["proof (state)\nthis:\n  0 < bv_to_int (utos w1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     0 < bv_to_int (utos w1); bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2\n 2. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "assume bi2: \"bv_to_int w2 < 0\""], ["proof (state)\nthis:\n  bv_to_int w2 < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     0 < bv_to_int (utos w1); bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2\n 2. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "have \"-bv_to_int w2 * bv_to_int (utos w1) \\<le> ((2::int)^(length w2 - 1)) * (2 ^ length w1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - bv_to_int w2 * bv_to_int (utos w1)\n    \\<le> 2 ^ (length w2 - 1) * 2 ^ length w1", "apply (rule mult_mono)"], ["proof (prove)\ngoal (4 subgoals):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. bv_to_int (utos w1) \\<le> 2 ^ length w1\n 3. 0 \\<le> 2 ^ (length w2 - 1)\n 4. 0 \\<le> bv_to_int (utos w1)", "using bv_to_int_lower_range [of w2]"], ["proof (prove)\nusing this:\n  - (2 ^ (length w2 - 1)) \\<le> bv_to_int w2\n\ngoal (4 subgoals):\n 1. - bv_to_int w2 \\<le> 2 ^ (length w2 - 1)\n 2. bv_to_int (utos w1) \\<le> 2 ^ length w1\n 3. 0 \\<le> 2 ^ (length w2 - 1)\n 4. 0 \\<le> bv_to_int (utos w1)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. bv_to_int (utos w1) \\<le> 2 ^ length w1\n 2. 0 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> bv_to_int (utos w1)", "apply (simp add: bv_to_int_utos)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bv_to_nat w1 \\<le> 2 ^ length w1\n 2. 0 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> bv_to_int (utos w1)", "using bv_to_nat_upper_range [of w1]"], ["proof (prove)\nusing this:\n  bv_to_nat w1 < 2 ^ length w1\n\ngoal (3 subgoals):\n 1. bv_to_nat w1 \\<le> 2 ^ length w1\n 2. 0 \\<le> 2 ^ (length w2 - 1)\n 3. 0 \\<le> bv_to_int (utos w1)", "apply (simp add: int_nat_two_exp del: of_nat_power)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> 2 ^ (length w2 - 1)\n 2. 0 \\<le> bv_to_int (utos w1)", "apply (rule zero_le_power,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int (utos w1)", "using bi1"], ["proof (prove)\nusing this:\n  0 < bv_to_int (utos w1)\n\ngoal (1 subgoal):\n 1. 0 \\<le> bv_to_int (utos w1)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  - bv_to_int w2 * bv_to_int (utos w1)\n  \\<le> 2 ^ (length w2 - 1) * 2 ^ length w1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     0 < bv_to_int (utos w1); bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2\n 2. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "hence \"-?Q \\<le> ((2::int)^length w1) * (2 ^ (length w2 - 1))\""], ["proof (prove)\nusing this:\n  - bv_to_int w2 * bv_to_int (utos w1)\n  \\<le> 2 ^ (length w2 - 1) * 2 ^ length w1\n\ngoal (1 subgoal):\n 1. - (bv_to_int (utos w1) * bv_to_int w2)\n    \\<le> 2 ^ length w1 * 2 ^ (length w2 - 1)", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  - (bv_to_int (utos w1) * bv_to_int w2)\n  \\<le> 2 ^ length w1 * 2 ^ (length w2 - 1)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     0 < bv_to_int (utos w1); bv_to_int w2 < 0\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2\n 2. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "thus \"-(((2::int)^length w1) * (2 ^ (length w2 - Suc 0))) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (bv_to_int (utos w1) * bv_to_int w2)\n  \\<le> 2 ^ length w1 * 2 ^ (length w2 - 1)\n\ngoal (1 subgoal):\n 1. - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "by simp"], ["proof (state)\nthis:\n  - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "assume bi1: \"bv_to_int (utos w1) < 0\""], ["proof (state)\nthis:\n  bv_to_int (utos w1) < 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_to_int (utos w1) * bv_to_int w2 < 0;\n     bv_to_int (utos w1) < 0; 0 < bv_to_int w2\\<rbrakk>\n    \\<Longrightarrow> - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n                      \\<le> bv_to_int (utos w1) * bv_to_int w2", "thus \"-(((2::int)^length w1) * (2 ^ (length w2 - Suc 0))) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  bv_to_int (utos w1) < 0\n\ngoal (1 subgoal):\n 1. - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "by (simp add: bv_to_int_utos)"], ["proof (state)\nthis:\n  - (2 ^ length w1 * 2 ^ (length w2 - Suc 0))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ length w1 * 2 ^ (length w2 - 1))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (2 ^ length w1 * 2 ^ (length w2 - 1))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "finally"], ["proof (chain)\npicking this:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2", "show \"-(2 ^ (length w1 + length w2 - Suc 0)) \\<le> ?Q\""], ["proof (prove)\nusing this:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2\n\ngoal (1 subgoal):\n 1. - (2 ^ (length w1 + length w2 - Suc 0))\n    \\<le> bv_to_int (utos w1) * bv_to_int w2", "."], ["proof (state)\nthis:\n  - (2 ^ (length w1 + length w2 - Suc 0))\n  \\<le> bv_to_int (utos w1) * bv_to_int w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (bv_smult (utos w1) w2) \\<le> length w1 + length w2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_smult_sym: \"bv_smult w1 w2 = bv_smult w2 w1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_smult w1 w2 = bv_smult w2 w1", "by (simp add: bv_smult_def ac_simps)"], ["", "subsection \\<open>Structural operations\\<close>"], ["", "definition\n  bv_select :: \"[bit list,nat] => bit\" where\n  \"bv_select w i = w ! (length w - 1 - i)\""], ["", "definition\n  bv_chop :: \"[bit list,nat] => bit list * bit list\" where\n  \"bv_chop w i = (let len = length w in (take (len - i) w,drop (len - i) w))\""], ["", "definition\n  bv_slice :: \"[bit list,nat*nat] => bit list\" where\n  \"bv_slice w = (\\<lambda>(b,e). fst (bv_chop (snd (bv_chop w (b+1))) e))\""], ["", "lemma bv_select_rev:\n  assumes notnull: \"n < length w\"\n  shows            \"bv_select w n = rev w ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_select w n = rev w ! n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_select w n = rev w ! n", "have \"\\<forall>n. n < length w --> bv_select w n = rev w ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n<length w. bv_select w n = rev w ! n", "proof (rule length_induct [of _ w],auto simp add: bv_select_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>n<length ys.\n                       ys ! (length ys - Suc n) = rev ys ! n);\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "fix xs :: \"bit list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>n<length ys.\n                       ys ! (length ys - Suc n) = rev ys ! n);\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>n<length ys.\n                       ys ! (length ys - Suc n) = rev ys ! n);\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "assume ind: \"\\<forall>ys::bit list. length ys < length xs --> (\\<forall>n. n < length ys --> ys ! (length ys - Suc n) = rev ys ! n)\""], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     (\\<forall>n<length ys. ys ! (length ys - Suc n) = rev ys ! n)\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>n<length ys.\n                       ys ! (length ys - Suc n) = rev ys ! n);\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "assume notx: \"n < length xs\""], ["proof (state)\nthis:\n  n < length xs\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   (\\<forall>n<length ys.\n                       ys ! (length ys - Suc n) = rev ys ! n);\n        n < length xs\\<rbrakk>\n       \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "show \"xs ! (length xs - Suc n) = rev xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! (length xs - Suc n) = rev xs ! n", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "assume \"xs = []\""], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "with notx"], ["proof (chain)\npicking this:\n  n < length xs\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  n < length xs\n  xs = []\n\ngoal (1 subgoal):\n 1. xs ! (length xs - Suc n) = rev xs ! n", "by simp"], ["proof (state)\nthis:\n  xs ! (length xs - Suc n) = rev xs ! n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "fix y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "assume [simp]: \"xs = y # ys\""], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow> xs ! (length xs - Suc n) = rev xs ! n", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! (length xs - Suc n) = rev xs ! n", "proof (auto simp add: nth_append)"], ["proof (state)\ngoal (2 subgoals):\n 1. n < length ys \\<Longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n 2. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "assume noty: \"n < length ys\""], ["proof (state)\nthis:\n  n < length ys\n\ngoal (2 subgoals):\n 1. n < length ys \\<Longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n 2. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "from spec [OF ind,of ys]"], ["proof (chain)\npicking this:\n  length ys < length xs \\<longrightarrow>\n  (\\<forall>n<length ys. ys ! (length ys - Suc n) = rev ys ! n)", "have \"\\<forall>n. n < length ys --> ys ! (length ys - Suc n) = rev ys ! n\""], ["proof (prove)\nusing this:\n  length ys < length xs \\<longrightarrow>\n  (\\<forall>n<length ys. ys ! (length ys - Suc n) = rev ys ! n)\n\ngoal (1 subgoal):\n 1. \\<forall>n<length ys. ys ! (length ys - Suc n) = rev ys ! n", "by simp"], ["proof (state)\nthis:\n  \\<forall>n<length ys. ys ! (length ys - Suc n) = rev ys ! n\n\ngoal (2 subgoals):\n 1. n < length ys \\<Longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n 2. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "hence \"n < length ys --> ys ! (length ys - Suc n) = rev ys ! n\""], ["proof (prove)\nusing this:\n  \\<forall>n<length ys. ys ! (length ys - Suc n) = rev ys ! n\n\ngoal (1 subgoal):\n 1. n < length ys \\<longrightarrow> ys ! (length ys - Suc n) = rev ys ! n", ".."], ["proof (state)\nthis:\n  n < length ys \\<longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n\ngoal (2 subgoals):\n 1. n < length ys \\<Longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n 2. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "from this and noty"], ["proof (chain)\npicking this:\n  n < length ys \\<longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n  n < length ys", "show \"ys ! (length ys - Suc n) = rev ys ! n\""], ["proof (prove)\nusing this:\n  n < length ys \\<longrightarrow> ys ! (length ys - Suc n) = rev ys ! n\n  n < length ys\n\ngoal (1 subgoal):\n 1. ys ! (length ys - Suc n) = rev ys ! n", ".."], ["proof (state)\nthis:\n  ys ! (length ys - Suc n) = rev ys ! n\n\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "assume \"~ n < length ys\""], ["proof (state)\nthis:\n  \\<not> n < length ys\n\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "hence x: \"length ys \\<le> n\""], ["proof (prove)\nusing this:\n  \\<not> n < length ys\n\ngoal (1 subgoal):\n 1. length ys \\<le> n", "by simp"], ["proof (state)\nthis:\n  length ys \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "from notx"], ["proof (chain)\npicking this:\n  n < length xs", "have \"n < Suc (length ys)\""], ["proof (prove)\nusing this:\n  n < length xs\n\ngoal (1 subgoal):\n 1. n < Suc (length ys)", "by simp"], ["proof (state)\nthis:\n  n < Suc (length ys)\n\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "hence \"n \\<le> length ys\""], ["proof (prove)\nusing this:\n  n < Suc (length ys)\n\ngoal (1 subgoal):\n 1. n \\<le> length ys", "by simp"], ["proof (state)\nthis:\n  n \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "with x"], ["proof (chain)\npicking this:\n  length ys \\<le> n\n  n \\<le> length ys", "have \"length ys = n\""], ["proof (prove)\nusing this:\n  length ys \\<le> n\n  n \\<le> length ys\n\ngoal (1 subgoal):\n 1. length ys = n", "by simp"], ["proof (state)\nthis:\n  length ys = n\n\ngoal (1 subgoal):\n 1. \\<not> n < length ys \\<Longrightarrow> y = [y] ! (n - length ys)", "thus \"y = [y] ! (n - length ys)\""], ["proof (prove)\nusing this:\n  length ys = n\n\ngoal (1 subgoal):\n 1. y = [y] ! (n - length ys)", "by simp"], ["proof (state)\nthis:\n  y = [y] ! (n - length ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs ! (length xs - Suc n) = rev xs ! n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs ! (length xs - Suc n) = rev xs ! n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n<length w. bv_select w n = rev w ! n\n\ngoal (1 subgoal):\n 1. bv_select w n = rev w ! n", "then"], ["proof (chain)\npicking this:\n  \\<forall>n<length w. bv_select w n = rev w ! n", "have \"n < length w --> bv_select w n = rev w ! n\""], ["proof (prove)\nusing this:\n  \\<forall>n<length w. bv_select w n = rev w ! n\n\ngoal (1 subgoal):\n 1. n < length w \\<longrightarrow> bv_select w n = rev w ! n", ".."], ["proof (state)\nthis:\n  n < length w \\<longrightarrow> bv_select w n = rev w ! n\n\ngoal (1 subgoal):\n 1. bv_select w n = rev w ! n", "from this and notnull"], ["proof (chain)\npicking this:\n  n < length w \\<longrightarrow> bv_select w n = rev w ! n\n  n < length w", "show ?thesis"], ["proof (prove)\nusing this:\n  n < length w \\<longrightarrow> bv_select w n = rev w ! n\n  n < length w\n\ngoal (1 subgoal):\n 1. bv_select w n = rev w ! n", ".."], ["proof (state)\nthis:\n  bv_select w n = rev w ! n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_chop_append: \"bv_chop (w1 @ w2) (length w2) = (w1,w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_chop (w1 @ w2) (length w2) = (w1, w2)", "by (simp add: bv_chop_def Let_def)"], ["", "lemma append_bv_chop_id: \"fst (bv_chop w l) @ snd (bv_chop w l) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (bv_chop w l) @ snd (bv_chop w l) = w", "by (simp add: bv_chop_def Let_def)"], ["", "lemma bv_chop_length_fst [simp]: \"length (fst (bv_chop w i)) = length w - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (fst (bv_chop w i)) = length w - i", "by (simp add: bv_chop_def Let_def)"], ["", "lemma bv_chop_length_snd [simp]: \"length (snd (bv_chop w i)) = min i (length w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (snd (bv_chop w i)) = min i (length w)", "by (simp add: bv_chop_def Let_def)"], ["", "lemma bv_slice_length [simp]: \"[| j \\<le> i; i < length w |] ==> length (bv_slice w (i,j)) = i - j + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < length w\\<rbrakk>\n    \\<Longrightarrow> length (bv_slice w (i, j)) = i - j + 1", "by (auto simp add: bv_slice_def)"], ["", "definition\n  length_nat :: \"nat => nat\" where\n  [code del]: \"length_nat x = (LEAST n. x < 2 ^ n)\""], ["", "lemma length_nat: \"length (nat_to_bv n) = length_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv n) = length_nat n", "apply (simp add: length_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv n) = (LEAST na. n < 2 ^ na)", "apply (rule Least_equality [symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. n < 2 ^ length (nat_to_bv n)\n 2. \\<And>y. n < 2 ^ y \\<Longrightarrow> length (nat_to_bv n) \\<le> y", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. n < 2 ^ y \\<Longrightarrow> length (nat_to_bv n) \\<le> y\n 2. n < 2 ^ length (nat_to_bv n)", "apply (rule length_nat_to_bv_upper_limit)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y. n < 2 ^ y \\<Longrightarrow> n \\<le> 2 ^ y - 1\n 2. n < 2 ^ length (nat_to_bv n)", "apply arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. n < 2 ^ length (nat_to_bv n)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> n < 2 ^ length (nat_to_bv n) \\<Longrightarrow> False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n < 2 ^ length (nat_to_bv n) \\<Longrightarrow> False", "assume \"~ n < 2 ^ length (nat_to_bv n)\""], ["proof (state)\nthis:\n  \\<not> n < 2 ^ length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> n < 2 ^ length (nat_to_bv n) \\<Longrightarrow> False", "hence \"2 ^ length (nat_to_bv n) \\<le> n\""], ["proof (prove)\nusing this:\n  \\<not> n < 2 ^ length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. 2 ^ length (nat_to_bv n) \\<le> n", "by simp"], ["proof (state)\nthis:\n  2 ^ length (nat_to_bv n) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> n < 2 ^ length (nat_to_bv n) \\<Longrightarrow> False", "hence \"length (nat_to_bv n) < length (nat_to_bv n)\""], ["proof (prove)\nusing this:\n  2 ^ length (nat_to_bv n) \\<le> n\n\ngoal (1 subgoal):\n 1. length (nat_to_bv n) < length (nat_to_bv n)", "by (rule length_nat_to_bv_lower_limit)"], ["proof (state)\nthis:\n  length (nat_to_bv n) < length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. \\<not> n < 2 ^ length (nat_to_bv n) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  length (nat_to_bv n) < length (nat_to_bv n)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_nat_0 [simp]: \"length_nat 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_nat 0 = 0", "by (simp add: length_nat_def Least_equality)"], ["", "lemma length_nat_non0:\n  assumes n0: \"n \\<noteq> 0\"\n  shows       \"length_nat n = Suc (length_nat (n div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_nat n = Suc (length_nat (n div 2))", "apply (simp add: length_nat [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nat_to_bv n) = Suc (length (nat_to_bv (n div 2)))", "apply (subst nat_to_bv_non0 [of n])"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<noteq> 0\n 2. length\n     (nat_to_bv (n div 2) @ [if n mod 2 = 0 then \\<zero> else \\<one>]) =\n    Suc (length (nat_to_bv (n div 2)))", "apply (simp_all add: n0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  length_int :: \"int => nat\" where\n  \"length_int x =\n    (if 0 < x then Suc (length_nat (nat x))\n    else if x = 0 then 0\n    else Suc (length_nat (nat (-x - 1))))\""], ["", "lemma length_int: \"length (int_to_bv i) = length_int i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "proof (cases \"0 < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "assume i0: \"0 < i\""], ["proof (state)\nthis:\n  0 < i\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "hence \"length (int_to_bv i) =\n      length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i))))\""], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) =\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i))))", "by simp"], ["proof (state)\nthis:\n  length (int_to_bv i) =\n  length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i))))\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "also"], ["proof (state)\nthis:\n  length (int_to_bv i) =\n  length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i))))\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "from norm_unsigned_result [of \"nat_to_bv (nat i)\"]"], ["proof (chain)\npicking this:\n  norm_unsigned (nat_to_bv (nat i)) = [] \\<or>\n  bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>", "have \"... = Suc (length_nat (nat i))\""], ["proof (prove)\nusing this:\n  norm_unsigned (nat_to_bv (nat i)) = [] \\<or>\n  bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>\n\ngoal (1 subgoal):\n 1. length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm_unsigned (nat_to_bv (nat i)) = [] \\<Longrightarrow>\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))\n 2. bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one> \\<Longrightarrow>\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))", "apply (simp del: norm_unsigned_nat_to_bv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm_unsigned (nat_to_bv (nat i)) = [] \\<Longrightarrow> False\n 2. bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one> \\<Longrightarrow>\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))", "apply (drule norm_empty_bv_to_nat_zero)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_nat (nat_to_bv (nat i)) = 0 \\<Longrightarrow> False\n 2. bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one> \\<Longrightarrow>\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))", "using i0"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (2 subgoals):\n 1. bv_to_nat (nat_to_bv (nat i)) = 0 \\<Longrightarrow> False\n 2. bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one> \\<Longrightarrow>\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one> \\<Longrightarrow>\n    length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n    Suc (length_nat (nat i))", "apply (cases \"norm_unsigned (nat_to_bv (nat i))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n     norm_unsigned (nat_to_bv (nat i)) = []\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                      Suc (length_nat (nat i))\n 2. \\<And>a list.\n       \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n        norm_unsigned (nat_to_bv (nat i)) = a # list\\<rbrakk>\n       \\<Longrightarrow> length\n                          (norm_signed\n                            (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                         Suc (length_nat (nat i))", "apply (drule norm_empty_bv_to_nat_zero [of \"nat_to_bv (nat i)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n     bv_to_nat (nat_to_bv (nat i)) = 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                      Suc (length_nat (nat i))\n 2. \\<And>a list.\n       \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n        norm_unsigned (nat_to_bv (nat i)) = a # list\\<rbrakk>\n       \\<Longrightarrow> length\n                          (norm_signed\n                            (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                         Suc (length_nat (nat i))", "using i0"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n     bv_to_nat (nat_to_bv (nat i)) = 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                      Suc (length_nat (nat i))\n 2. \\<And>a list.\n       \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n        norm_unsigned (nat_to_bv (nat i)) = a # list\\<rbrakk>\n       \\<Longrightarrow> length\n                          (norm_signed\n                            (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                         Suc (length_nat (nat i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat i))) = \\<one>;\n        norm_unsigned (nat_to_bv (nat i)) = a # list\\<rbrakk>\n       \\<Longrightarrow> length\n                          (norm_signed\n                            (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n                         Suc (length_nat (nat i))", "apply (simp add: i0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>a = \\<one>; nat_to_bv (nat i) = \\<one> # list\\<rbrakk>\n       \\<Longrightarrow> Suc (length list) = length_nat (nat i)", "using i0"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>a = \\<one>; nat_to_bv (nat i) = \\<one> # list\\<rbrakk>\n       \\<Longrightarrow> Suc (length list) = length_nat (nat i)", "apply (simp add: length_nat [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length (norm_signed (\\<zero> # norm_unsigned (nat_to_bv (nat i)))) =\n  Suc (length_nat (nat i))\n\ngoal (2 subgoals):\n 1. 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "finally"], ["proof (chain)\npicking this:\n  length (int_to_bv i) = Suc (length_nat (nat i))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (int_to_bv i) = Suc (length_nat (nat i))\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "using i0"], ["proof (prove)\nusing this:\n  length (int_to_bv i) = Suc (length_nat (nat i))\n  0 < i\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "by (simp add: length_int_def)"], ["proof (state)\nthis:\n  length (int_to_bv i) = length_int i\n\ngoal (1 subgoal):\n 1. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "assume \"~ 0 < i\""], ["proof (state)\nthis:\n  \\<not> 0 < i\n\ngoal (1 subgoal):\n 1. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "hence i0: \"i \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 < i\n\ngoal (1 subgoal):\n 1. i \\<le> 0", "by simp"], ["proof (state)\nthis:\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<not> 0 < i \\<Longrightarrow> length (int_to_bv i) = length_int i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "assume \"i = 0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> length (int_to_bv i) = length_int i\n 2. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "by (simp add: length_int_def)"], ["proof (state)\nthis:\n  length (int_to_bv i) = length_int i\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "assume \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "with i0"], ["proof (chain)\npicking this:\n  i \\<le> 0\n  i \\<noteq> 0", "have i0: \"i < 0\""], ["proof (prove)\nusing this:\n  i \\<le> 0\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i < 0", "by simp"], ["proof (state)\nthis:\n  i < 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "hence \"length (int_to_bv i) =\n        length (norm_signed (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1)))))\""], ["proof (prove)\nusing this:\n  i < 0\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) =\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1)))))", "by (simp add: int_to_bv_def nat_diff_distrib)"], ["proof (state)\nthis:\n  length (int_to_bv i) =\n  length\n   (norm_signed\n     (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1)))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "also"], ["proof (state)\nthis:\n  length (int_to_bv i) =\n  length\n   (norm_signed\n     (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1)))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "from norm_unsigned_result [of \"nat_to_bv (nat (- i) - 1)\"]"], ["proof (chain)\npicking this:\n  norm_unsigned (nat_to_bv (nat (- i) - 1)) = [] \\<or>\n  bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) = \\<one>", "have \"... = Suc (length_nat (nat (- i) - 1))\""], ["proof (prove)\nusing this:\n  norm_unsigned (nat_to_bv (nat (- i) - 1)) = [] \\<or>\n  bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) = \\<one>\n\ngoal (1 subgoal):\n 1. length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm_unsigned (nat_to_bv (nat (- i) - 1)) = [] \\<Longrightarrow>\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))\n 2. bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) =\n    \\<one> \\<Longrightarrow>\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))", "apply (simp del: norm_unsigned_nat_to_bv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. norm_unsigned (nat_to_bv (nat (- i) - Suc 0)) = [] \\<Longrightarrow>\n    length_nat (nat (- i) - Suc 0) = 0\n 2. bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) =\n    \\<one> \\<Longrightarrow>\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))", "apply (drule norm_empty_bv_to_nat_zero [of \"nat_to_bv (nat (-i) - Suc 0)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_nat (nat_to_bv (nat (- i) - Suc 0)) = 0 \\<Longrightarrow>\n    length_nat (nat (- i) - Suc 0) = 0\n 2. bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) =\n    \\<one> \\<Longrightarrow>\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))", "using i0"], ["proof (prove)\nusing this:\n  i < 0\n\ngoal (2 subgoals):\n 1. bv_to_nat (nat_to_bv (nat (- i) - Suc 0)) = 0 \\<Longrightarrow>\n    length_nat (nat (- i) - Suc 0) = 0\n 2. bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) =\n    \\<one> \\<Longrightarrow>\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) =\n    \\<one> \\<Longrightarrow>\n    length\n     (norm_signed\n       (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n    Suc (length_nat (nat (- i) - 1))", "apply (cases \"- i - 1 = 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) = \\<one>;\n     - i - 1 = 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<one> #\n                          bv_not\n                           (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n                      Suc (length_nat (nat (- i) - 1))\n 2. \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) = \\<one>;\n     - i - 1 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<one> #\n                          bv_not\n                           (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n                      Suc (length_nat (nat (- i) - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_msb (norm_unsigned (nat_to_bv (nat (- i) - 1))) = \\<one>;\n     - i - 1 \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<one> #\n                          bv_not\n                           (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n                      Suc (length_nat (nat (- i) - 1))", "apply (simp add: length_nat [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bv_msb (nat_to_bv (nat (- i) - Suc 0)) = \\<one>;\n     i \\<noteq> - 1\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<one> #\n                          bv_not (nat_to_bv (nat (- i) - Suc 0)))) =\n                      Suc (length (nat_to_bv (nat (- i) - Suc 0)))", "apply (cases \"norm_unsigned (nat_to_bv (nat (- i) - 1))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_msb (nat_to_bv (nat (- i) - Suc 0)) = \\<one>;\n     i \\<noteq> - 1; norm_unsigned (nat_to_bv (nat (- i) - 1)) = []\\<rbrakk>\n    \\<Longrightarrow> length\n                       (norm_signed\n                         (\\<one> #\n                          bv_not (nat_to_bv (nat (- i) - Suc 0)))) =\n                      Suc (length (nat_to_bv (nat (- i) - Suc 0)))\n 2. \\<And>a list.\n       \\<lbrakk>bv_msb (nat_to_bv (nat (- i) - Suc 0)) = \\<one>;\n        i \\<noteq> - 1;\n        norm_unsigned (nat_to_bv (nat (- i) - 1)) = a # list\\<rbrakk>\n       \\<Longrightarrow> length\n                          (norm_signed\n                            (\\<one> #\n                             bv_not (nat_to_bv (nat (- i) - Suc 0)))) =\n                         Suc (length (nat_to_bv (nat (- i) - Suc 0)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>bv_msb (nat_to_bv (nat (- i) - Suc 0)) = \\<one>;\n        i \\<noteq> - 1;\n        norm_unsigned (nat_to_bv (nat (- i) - 1)) = a # list\\<rbrakk>\n       \\<Longrightarrow> length\n                          (norm_signed\n                            (\\<one> #\n                             bv_not (nat_to_bv (nat (- i) - Suc 0)))) =\n                         Suc (length (nat_to_bv (nat (- i) - Suc 0)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length\n   (norm_signed\n     (\\<one> # bv_not (norm_unsigned (nat_to_bv (nat (- i) - 1))))) =\n  Suc (length_nat (nat (- i) - 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> length (int_to_bv i) = length_int i", "finally"], ["proof (chain)\npicking this:\n  length (int_to_bv i) = Suc (length_nat (nat (- i) - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  length (int_to_bv i) = Suc (length_nat (nat (- i) - 1))\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "using i0"], ["proof (prove)\nusing this:\n  length (int_to_bv i) = Suc (length_nat (nat (- i) - 1))\n  i < 0\n\ngoal (1 subgoal):\n 1. length (int_to_bv i) = length_int i", "by (simp add: length_int_def nat_diff_distrib del: int_to_bv_lt0)"], ["proof (state)\nthis:\n  length (int_to_bv i) = length_int i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (int_to_bv i) = length_int i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_int_0 [simp]: \"length_int 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length_int 0 = 0", "by (simp add: length_int_def)"], ["", "lemma length_int_gt0: \"0 < i ==> length_int i = Suc (length_nat (nat i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow> length_int i = Suc (length_nat (nat i))", "by (simp add: length_int_def)"], ["", "lemma length_int_lt0: \"i < 0 ==> length_int i = Suc (length_nat (nat (- i) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < 0 \\<Longrightarrow> length_int i = Suc (length_nat (nat (- i) - 1))", "by (simp add: length_int_def nat_diff_distrib)"], ["", "lemma bv_chopI: \"[| w = w1 @ w2 ; i = length w2 |] ==> bv_chop w i = (w1,w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w = w1 @ w2; i = length w2\\<rbrakk>\n    \\<Longrightarrow> bv_chop w i = (w1, w2)", "by (simp add: bv_chop_def Let_def)"], ["", "lemma bv_sliceI: \"[| j \\<le> i ; i < length w ; w = w1 @ w2 @ w3 ; Suc i = length w2 + j ; j = length w3  |] ==> bv_slice w (i,j) = w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<le> i; i < length w; w = w1 @ w2 @ w3;\n     Suc i = length w2 + j; j = length w3\\<rbrakk>\n    \\<Longrightarrow> bv_slice w (i, j) = w2", "apply (simp add: bv_slice_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> fst (bv_chop\n                            (snd (bv_chop (w1 @ w2 @ w3)\n                                   (length w2 + length w3)))\n                            (length w3)) =\n                      w2", "apply (subst bv_chopI [of \"w1 @ w2 @ w3\" w1 \"w2 @ w3\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> w1 @ w2 @ w3 = w1 @ w2 @ w3\n 2. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> length w2 + length w3 = length (w2 @ w3)\n 3. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> fst (bv_chop (snd (w1, w2 @ w3)) (length w3)) = w2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> length w2 + length w3 = length (w2 @ w3)\n 2. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> fst (bv_chop (snd (w1, w2 @ w3)) (length w3)) = w2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> fst (bv_chop (snd (w1, w2 @ w3)) (length w3)) = w2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length w3 \\<le> i; w = w1 @ w2 @ w3;\n     Suc i = length w2 + length w3; j = length w3\\<rbrakk>\n    \\<Longrightarrow> fst (bv_chop (w2 @ w3) (length w3)) = w2", "apply (subst bv_chopI [of \"w2 @ w3\" w2 w3],simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bv_slice_bv_slice:\n  assumes ki: \"k \\<le> i\"\n  and     ij: \"i \\<le> j\"\n  and     jl: \"j \\<le> l\"\n  and     lw: \"l < length w\"\n  shows       \"bv_slice w (j,i) = bv_slice (bv_slice w (l,k)) (j-k,i-k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_slice w (j, i) = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_slice w (j, i) = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "define w1 w2 w3 w4 w5\n    where w_defs:\n      \"w1 = fst (bv_chop w (Suc l))\"\n      \"w2 = fst (bv_chop (snd (bv_chop w (Suc l))) (Suc j))\"\n      \"w3 = fst (bv_chop (snd (bv_chop (snd (bv_chop w (Suc l))) (Suc j))) i)\"\n      \"w4 = fst (bv_chop (snd (bv_chop (snd (bv_chop (snd (bv_chop w (Suc l))) (Suc j))) i)) k)\"\n      \"w5 = snd (bv_chop (snd (bv_chop (snd (bv_chop (snd (bv_chop w (Suc l))) (Suc j))) i)) k)\""], ["proof (state)\nthis:\n  w1 = fst (bv_chop w (Suc l))\n  w2 = fst (bv_chop (snd (bv_chop w (Suc l))) (Suc j))\n  w3 = fst (bv_chop (snd (bv_chop (snd (bv_chop w (Suc l))) (Suc j))) i)\n  w4 =\n  fst (bv_chop\n        (snd (bv_chop (snd (bv_chop (snd (bv_chop w (Suc l))) (Suc j))) i))\n        k)\n  w5 =\n  snd (bv_chop\n        (snd (bv_chop (snd (bv_chop (snd (bv_chop w (Suc l))) (Suc j))) i))\n        k)\n\ngoal (1 subgoal):\n 1. bv_slice w (j, i) = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "have w_def: \"w = w1 @ w2 @ w3 @ w4 @ w5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = w1 @ w2 @ w3 @ w4 @ w5", "by (simp add: w_defs append_bv_chop_id)"], ["proof (state)\nthis:\n  w = w1 @ w2 @ w3 @ w4 @ w5\n\ngoal (1 subgoal):\n 1. bv_slice w (j, i) = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "from ki ij jl lw"], ["proof (chain)\npicking this:\n  k \\<le> i\n  i \\<le> j\n  j \\<le> l\n  l < length w", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> i\n  i \\<le> j\n  j \\<le> l\n  l < length w\n\ngoal (1 subgoal):\n 1. bv_slice w (j, i) = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "apply (subst bv_sliceI [where ?j = i and ?i = j and ?w = w and ?w1.0 = \"w1 @ w2\" and ?w2.0 = w3 and ?w3.0 = \"w4 @ w5\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i \\<le> j\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> j < length w\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w = (w1 @ w2) @ w3 @ w4 @ w5\n 4. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc j = length w3 + i\n 5. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i = length (w4 @ w5)\n 6. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w = w1 @ w2 @ w3 @ w4 @ w5\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc j = length w3 + i\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i = length w4 + length w5\n 4. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "apply (rule w_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc j = length w3 + i\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i = length w4 + length w5\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "apply (simp add: w_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i = length w4 + length w5\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "apply (simp add: w_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (bv_slice w (l, k)) (j - k, i - k)", "apply (subst bv_sliceI [where ?j = k and ?i = l and ?w = w and ?w1.0 = w1 and ?w2.0 = \"w2 @ w3 @ w4\" and ?w3.0 = w5])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> k \\<le> l\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> l < length w\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w = w1 @ (w2 @ w3 @ w4) @ w5\n 4. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc l = length (w2 @ w3 @ w4) + k\n 5. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> k = length w5\n 6. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (w2 @ w3 @ w4) (j - k, i - k)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w = w1 @ w2 @ w3 @ w4 @ w5\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc l = length w2 + (length w3 + length w4) + k\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> k = length w5\n 4. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (w2 @ w3 @ w4) (j - k, i - k)", "apply (rule w_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc l = length w2 + (length w3 + length w4) + k\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> k = length w5\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (w2 @ w3 @ w4) (j - k, i - k)", "apply (simp add: w_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> k = length w5\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (w2 @ w3 @ w4) (j - k, i - k)", "apply (simp add: w_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = bv_slice (w2 @ w3 @ w4) (j - k, i - k)", "apply (subst bv_sliceI [where ?j = \"i-k\" and ?i = \"j-k\" and ?w = \"w2 @ w3 @ w4\" and ?w1.0 = w2 and ?w2.0 = w3 and ?w3.0 = w4])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i - k \\<le> j - k\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> j - k < length (w2 @ w3 @ w4)\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w2 @ w3 @ w4 = w2 @ w3 @ w4\n 4. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc (j - k) = length w3 + (i - k)\n 5. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i - k = length w4\n 6. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> w3 = w3", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> j - k < length w2 + (length w3 + length w4)\n 2. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> Suc (j - k) = length w3 + i - k\n 3. \\<lbrakk>k \\<le> i; i \\<le> j; j \\<le> l; l < length w\\<rbrakk>\n    \\<Longrightarrow> i - k = length w4", "apply (simp_all add: w_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_slice w (j, i) = bv_slice (bv_slice w (l, k)) (j - k, i - k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bv_to_nat_extend [simp]: \"bv_to_nat (bv_extend n \\<zero> w) = bv_to_nat w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (bv_extend n \\<zero> w) = bv_to_nat w", "apply (simp add: bv_extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (replicate (n - length w) \\<zero> @ w) = bv_to_nat w", "apply (subst bv_to_nat_dist_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (replicate (n - length w) \\<zero>) * 2 ^ length w +\n    bv_to_nat w =\n    bv_to_nat w", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (replicate (n - length w) \\<zero>) = 0", "apply (induct (\"n - length w\"))"], ["proof (prove)\ngoal (2 subgoals):\n 1. bv_to_nat (replicate 0 \\<zero>) = 0\n 2. \\<And>n.\n       bv_to_nat (replicate n \\<zero>) = 0 \\<Longrightarrow>\n       bv_to_nat (replicate (Suc n) \\<zero>) = 0", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bv_msb_extend_same [simp]: \"bv_msb w = b ==> bv_msb (bv_extend n b w) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb w = b \\<Longrightarrow> bv_msb (bv_extend n b w) = b", "apply (simp add: bv_extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_msb w = b \\<Longrightarrow>\n    bv_msb (replicate (n - length w) b @ w) = b", "apply (cases \"n - length w\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bv_msb w = b; n - length w = 0\\<rbrakk>\n    \\<Longrightarrow> bv_msb (replicate (n - length w) b @ w) = b\n 2. \\<And>nat.\n       \\<lbrakk>bv_msb w = b; n - length w = Suc nat\\<rbrakk>\n       \\<Longrightarrow> bv_msb (replicate (n - length w) b @ w) = b", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bv_to_int_extend [simp]:\n  assumes a: \"bv_msb w = b\"\n  shows      \"bv_to_int (bv_extend n b w) = bv_to_int w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (bv_extend n b w) = bv_to_int w", "proof (cases \"bv_msb w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bv_msb w = \\<zero> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w\n 2. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "assume [simp]: \"bv_msb w = \\<zero>\""], ["proof (state)\nthis:\n  bv_msb w = \\<zero>\n\ngoal (2 subgoals):\n 1. bv_msb w = \\<zero> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w\n 2. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "with a"], ["proof (chain)\npicking this:\n  bv_msb w = b\n  bv_msb w = \\<zero>", "have [simp]: \"b = \\<zero>\""], ["proof (prove)\nusing this:\n  bv_msb w = b\n  bv_msb w = \\<zero>\n\ngoal (1 subgoal):\n 1. b = \\<zero>", "by simp"], ["proof (state)\nthis:\n  b = \\<zero>\n\ngoal (2 subgoals):\n 1. bv_msb w = \\<zero> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w\n 2. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (bv_extend n b w) = bv_to_int w", "by (simp add: bv_to_int_def)"], ["proof (state)\nthis:\n  bv_to_int (bv_extend n b w) = bv_to_int w\n\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "assume [simp]: \"bv_msb w = \\<one>\""], ["proof (state)\nthis:\n  bv_msb w = \\<one>\n\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "with a"], ["proof (chain)\npicking this:\n  bv_msb w = b\n  bv_msb w = \\<one>", "have [simp]: \"b = \\<one>\""], ["proof (prove)\nusing this:\n  bv_msb w = b\n  bv_msb w = \\<one>\n\ngoal (1 subgoal):\n 1. b = \\<one>", "by simp"], ["proof (state)\nthis:\n  b = \\<one>\n\ngoal (1 subgoal):\n 1. bv_msb w = \\<one> \\<Longrightarrow>\n    bv_to_int (bv_extend n b w) = bv_to_int w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_int (bv_extend n b w) = bv_to_int w", "apply (simp add: bv_to_int_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (bv_not (bv_extend n \\<one> w)) = bv_to_nat (bv_not w)", "apply (simp add: bv_extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (bv_not (replicate (n - length w) \\<one> @ w)) =\n    bv_to_nat (bv_not w)", "apply (induct (\"n - length w\"), simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bv_to_int (bv_extend n b w) = bv_to_int w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_nat_mono [simp]: \"x \\<le> y ==> length_nat x \\<le> length_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> length_nat x \\<le> length_nat y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "assume xy: \"x \\<le> y\""], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"~ length_nat x \\<le> length_nat y\""], ["proof (state)\nthis:\n  \\<not> length_nat x \\<le> length_nat y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "hence lxly: \"length_nat y < length_nat x\""], ["proof (prove)\nusing this:\n  \\<not> length_nat x \\<le> length_nat y\n\ngoal (1 subgoal):\n 1. length_nat y < length_nat x", "by simp"], ["proof (state)\nthis:\n  length_nat y < length_nat x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"length_nat y < (LEAST n. x < 2 ^ n)\""], ["proof (prove)\nusing this:\n  length_nat y < length_nat x\n\ngoal (1 subgoal):\n 1. length_nat y < (LEAST n. x < 2 ^ n)", "by (simp add: length_nat_def)"], ["proof (state)\nthis:\n  length_nat y < (LEAST n. x < 2 ^ n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"~ x < 2 ^ length_nat y\""], ["proof (prove)\nusing this:\n  length_nat y < (LEAST n. x < 2 ^ n)\n\ngoal (1 subgoal):\n 1. \\<not> x < 2 ^ length_nat y", "by (rule not_less_Least)"], ["proof (state)\nthis:\n  \\<not> x < 2 ^ length_nat y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "hence xx: \"2 ^ length_nat y \\<le> x\""], ["proof (prove)\nusing this:\n  \\<not> x < 2 ^ length_nat y\n\ngoal (1 subgoal):\n 1. 2 ^ length_nat y \\<le> x", "by simp"], ["proof (state)\nthis:\n  2 ^ length_nat y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "have yy: \"y < 2 ^ length_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y < 2 ^ length_nat y", "apply (simp add: length_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < 2 ^ (LEAST n. y < 2 ^ n)", "apply (rule LeastI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < 2 ^ ?k", "apply (subgoal_tac \"y < 2 ^ y\",assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. y < 2 ^ y", "apply (cases \"0 \\<le> y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> y \\<Longrightarrow> y < 2 ^ y\n 2. \\<not> 0 \\<le> y \\<Longrightarrow> y < 2 ^ y", "apply (induct y,simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  y < 2 ^ length_nat y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "with xx"], ["proof (chain)\npicking this:\n  2 ^ length_nat y \\<le> x\n  y < 2 ^ length_nat y", "have \"y < x\""], ["proof (prove)\nusing this:\n  2 ^ length_nat y \\<le> x\n  y < 2 ^ length_nat y\n\ngoal (1 subgoal):\n 1. y < x", "by simp"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; \\<not> length_nat x \\<le> length_nat y\\<rbrakk>\n    \\<Longrightarrow> False", "with xy"], ["proof (chain)\npicking this:\n  x \\<le> y\n  y < x", "show False"], ["proof (prove)\nusing this:\n  x \\<le> y\n  y < x\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_nat_mono_int: \"x \\<le> y ==> length_nat x \\<le> length_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> length_nat x \\<le> length_nat y", "by (rule length_nat_mono) arith"], ["", "lemma length_nat_pos [simp,intro!]: \"0 < x ==> 0 < length_nat x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x \\<Longrightarrow> 0 < length_nat x", "by (simp add: length_nat_non0)"], ["", "lemma length_int_mono_gt0: \"[| 0 \\<le> x ; x \\<le> y |] ==> length_int x \\<le> length_int y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> length_int x \\<le> length_int y", "by (cases \"x = 0\") (simp_all add: length_int_gt0 nat_le_eq_zle)"], ["", "lemma length_int_mono_lt0: \"[| x \\<le> y ; y \\<le> 0 |] ==> length_int y \\<le> length_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> length_int y \\<le> length_int x", "by (cases \"y = 0\") (simp_all add: length_int_lt0)"], ["", "lemmas [simp] = length_nat_non0"], ["", "primrec fast_bv_to_nat_helper :: \"[bit list, num] => num\" where\n    fast_bv_to_nat_Nil: \"fast_bv_to_nat_helper [] k = k\"\n  | fast_bv_to_nat_Cons: \"fast_bv_to_nat_helper (b#bs) k =\n      fast_bv_to_nat_helper bs ((case_bit Num.Bit0 Num.Bit1 b) k)\""], ["", "declare fast_bv_to_nat_helper.simps [code del]"], ["", "lemma fast_bv_to_nat_Cons0: \"fast_bv_to_nat_helper (\\<zero>#bs) bin =\n    fast_bv_to_nat_helper bs (Num.Bit0 bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_bv_to_nat_helper (\\<zero> # bs) bin =\n    fast_bv_to_nat_helper bs (num.Bit0 bin)", "by simp"], ["", "lemma fast_bv_to_nat_Cons1: \"fast_bv_to_nat_helper (\\<one>#bs) bin =\n    fast_bv_to_nat_helper bs (Num.Bit1 bin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fast_bv_to_nat_helper (\\<one> # bs) bin =\n    fast_bv_to_nat_helper bs (num.Bit1 bin)", "by simp"], ["", "lemma mult_Bit0_left: \"Num.Bit0 m * n = Num.Bit0 (m * n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num.Bit0 m * n = num.Bit0 (m * n)", "by (simp add: num_eq_iff nat_of_num_mult distrib_right)"], ["", "lemma fast_bv_to_nat_def:\n  \"bv_to_nat (\\<one> # bs) == numeral (fast_bv_to_nat_helper bs Num.One)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_to_nat (\\<one> # bs) \\<equiv>\n    numeral (fast_bv_to_nat_helper bs num.One)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bv_to_nat (\\<one> # bs) \\<equiv>\n    numeral (fast_bv_to_nat_helper bs num.One)", "have \"\\<And>k. foldl (\\<lambda>bn b. 2 * bn + bitval b) (numeral k) bs = numeral (fast_bv_to_nat_helper bs k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) (numeral k) bs =\n       numeral (fast_bv_to_nat_helper bs k)", "apply (induct bs, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a bs k.\n       (\\<And>k.\n           foldl (\\<lambda>bn b. 2 * bn + bitval b) (numeral k) bs =\n           numeral (fast_bv_to_nat_helper bs k)) \\<Longrightarrow>\n       foldl (\\<lambda>bn b. 2 * bn + bitval b) (numeral k) (a # bs) =\n       numeral (fast_bv_to_nat_helper (a # bs) k)", "apply (case_tac a, simp_all add: mult_Bit0_left)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) (numeral ?k) bs =\n  numeral (fast_bv_to_nat_helper bs ?k)\n\ngoal (1 subgoal):\n 1. bv_to_nat (\\<one> # bs) \\<equiv>\n    numeral (fast_bv_to_nat_helper bs num.One)", "thus \"PROP ?thesis\""], ["proof (prove)\nusing this:\n  foldl (\\<lambda>bn b. 2 * bn + bitval b) (numeral ?k) bs =\n  numeral (fast_bv_to_nat_helper bs ?k)\n\ngoal (1 subgoal):\n 1. bv_to_nat (\\<one> # bs) \\<equiv>\n    numeral (fast_bv_to_nat_helper bs num.One)", "by (simp add: bv_to_nat_def add: numeral_One [symmetric]\n      del: numeral_One One_nat_def)"], ["proof (state)\nthis:\n  bv_to_nat (\\<one> # bs) \\<equiv>\n  numeral (fast_bv_to_nat_helper bs num.One)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare fast_bv_to_nat_Cons [simp del]"], ["", "declare fast_bv_to_nat_Cons0 [simp]"], ["", "declare fast_bv_to_nat_Cons1 [simp]"], ["", "simproc_setup bv_to_nat (\"bv_to_nat (x # xs)\") = \\<open>\n  fn _ => fn ctxt => fn ct =>\n    let\n      fun is_const_bool (Const(@{const_name True},_)) = true\n        | is_const_bool (Const(@{const_name False},_)) = true\n        | is_const_bool _ = false\n      fun is_const_bit (Const(@{const_name Zero},_)) = true\n        | is_const_bit (Const(@{const_name One},_)) = true\n        | is_const_bit _ = false\n      fun vec_is_usable (Const(@{const_name Nil},_)) = true\n        | vec_is_usable (Const(@{const_name Cons},_) $ b $ bs) =\n            vec_is_usable bs andalso is_const_bit b\n        | vec_is_usable _ = false\n      fun proc (Const(@{const_name bv_to_nat},_) $\n        (Const(@{const_name Cons},_) $ Const(@{const_name One},_) $ t)) =\n            if vec_is_usable t then\n              SOME\n                (infer_instantiate ctxt\n                  [((\"bs\", 0), Thm.cterm_of ctxt t)] @{thm fast_bv_to_nat_def})\n            else NONE\n        | proc _ = NONE\n    in proc (Thm.term_of ct) end\n\\<close>"], ["", "declare bv_to_nat1 [simp del]"], ["", "declare bv_to_nat_helper [simp del]"], ["", "definition\n  bv_mapzip :: \"[bit => bit => bit,bit list, bit list] => bit list\" where\n  \"bv_mapzip f w1 w2 =\n    (let g = bv_extend (max (length w1) (length w2)) \\<zero>\n     in map (case_prod f) (zip (g w1) (g w2)))\""], ["", "lemma bv_length_bv_mapzip [simp]:\n    \"length (bv_mapzip f w1 w2) = max (length w1) (length w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (bv_mapzip f w1 w2) = max (length w1) (length w2)", "by (simp add: bv_mapzip_def Let_def split: split_max)"], ["", "lemma bv_mapzip_Nil [simp]: \"bv_mapzip f [] [] = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bv_mapzip f [] [] = []", "by (simp add: bv_mapzip_def Let_def)"], ["", "lemma bv_mapzip_Cons [simp]: \"length w1 = length w2 ==>\n    bv_mapzip f (x#w1) (y#w2) = f x y # bv_mapzip f w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length w1 = length w2 \\<Longrightarrow>\n    bv_mapzip f (x # w1) (y # w2) = f x y # bv_mapzip f w1 w2", "by (simp add: bv_mapzip_def Let_def)"], ["", "end"]]}