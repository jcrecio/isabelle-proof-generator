{"file_name": "/home/qj213/afp-2021-10-22/thys/Transformer_Semantics/Powerset_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transformer_Semantics", "problem_names": ["lemma P_func1: \"\\<P> (f \\<circ> g) = \\<P> f \\<circ> \\<P> g\"", "lemma P_func2: \"\\<P> id = id\"", "lemma eta_nt: \"\\<P> f \\<circ> \\<eta> = \\<eta> \\<circ> id f\"", "lemma mu_nt: \"\\<mu> \\<circ> (\\<P> \\<circ> \\<P>) f = (\\<P> f) \\<circ> \\<mu>\"", "lemma pow_assoc: \"(\\<mu>::'a set set \\<Rightarrow> 'a set) \\<circ> \\<P> (\\<mu>::'a set set \\<Rightarrow> 'a set) = (\\<mu> ::'a set set \\<Rightarrow> 'a set) \\<circ> (\\<mu>::'a set set set \\<Rightarrow> 'a set set)\"", "lemma pow_un1: \"(\\<mu>::'a set set \\<Rightarrow> 'a set) \\<circ> (\\<P> (\\<eta>:: 'a  \\<Rightarrow> 'a set)) = (id::'a set  \\<Rightarrow> 'a set)\"", "lemma pow_un2: \"(\\<mu>::'a set set \\<Rightarrow> 'a set) \\<circ> (\\<eta>::'a set \\<Rightarrow> 'a set set) = (id::'a set \\<Rightarrow> 'a set)\"", "lemma kcomp_prop: \"(f \\<circ>\\<^sub>K g) x = (\\<Squnion>y \\<in> f x. g y)\"", "lemma klift_prop: \"(f\\<^sup>\\<dagger>) X = (\\<Squnion>x \\<in> X. f x)\"", "lemma kcomp_klift: \"f \\<circ>\\<^sub>K g = g\\<^sup>\\<dagger> \\<circ> f\"", "lemma klift_prop1: \"(f\\<^sup>\\<dagger> \\<circ> g)\\<^sup>\\<dagger> = f\\<^sup>\\<dagger> \\<circ> g\\<^sup>\\<dagger>\"", "lemma klift_eta_inv1 [simp]: \"f\\<^sup>\\<dagger> \\<circ> \\<eta> = f\"", "lemma klift_eta_pres [simp]: \"\\<eta>\\<^sup>\\<dagger> = (id::'a set \\<Rightarrow> 'a set)\"", "lemma klift_id_pres [simp]: \"id\\<^sup>\\<dagger> = \\<mu>\"", "lemma kcomp_assoc: \"(f \\<circ>\\<^sub>K g) \\<circ>\\<^sub>K h = f \\<circ>\\<^sub>K (g \\<circ>\\<^sub>K h)\"", "lemma kcomp_idl [simp]: \"\\<eta> \\<circ>\\<^sub>K f = f\"", "lemma kcomp_idr [simp]: \"f \\<circ>\\<^sub>K \\<eta> = f\"", "lemma eta_func1: \"\\<eta> \\<circ> (f \\<circ> g) = (\\<eta> \\<circ> g) \\<circ>\\<^sub>K (\\<eta> \\<circ> f)\"", "lemma em_assoc [simp]: \"\\<sigma> \\<circ> \\<P> (\\<sigma>::'a::complete_lattice set \\<Rightarrow> 'a) = \\<sigma> \\<circ> \\<mu>\"", "lemma em_id [simp]: \"\\<sigma> \\<circ> \\<eta> = (id::'a::complete_lattice \\<Rightarrow> 'a)\"", "lemma em_mu_assoc [simp]: \"\\<mu> \\<circ> \\<P> \\<mu> = \\<mu> \\<circ> \\<mu>\"", "lemma em_mu_id [simp]: \"\\<mu> \\<circ> \\<eta> = id\"", "lemma smap_un1: \"smap {x, smap Y} = smap ({x} \\<union> Y)\"", "lemma smap_comm: \"smap {x, smap Y} = smap {smap Y, x}\"", "lemma smap_un2: \"smap {smap X, y} = smap (X \\<union> {y})\"", "lemma sleq_refl: \"sleq x x\"", "lemma sleq_trans: \"sleq x y \\<Longrightarrow> sleq y z \\<Longrightarrow> sleq x z\"", "lemma sleq_antisym: \"sleq x y \\<Longrightarrow> sleq y x \\<Longrightarrow> x = y\"", "lemma smap_ub: \"x \\<in> A \\<Longrightarrow> sleq x (smap A)\"", "lemma smap_lub: \"(\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow> sleq (smap A) z\"", "lemma r2f2r_inv1 [simp]: \"\\<R> \\<circ> \\<F> = id\"", "lemma f2r2f_inv2 [simp]: \"\\<F> \\<circ> \\<R> = id\"", "lemma r2f_f2r_galois: \"(\\<R> f = R) = (\\<F> R = f)\"", "lemma r2f_f2r_galois_var: \"(\\<R> \\<circ> f = R) = (\\<F> \\<circ> R = f)\"", "lemma r2f_f2r_galois_var2: \"(f \\<circ> \\<R> = R) = (R \\<circ> \\<F> = f)\"", "lemma r2f_inj: \"inj \\<F>\"", "lemma f2r_inj: \"inj \\<R>\"", "lemma r2f_mono: \"\\<forall>f g. \\<F> \\<circ> f = \\<F> \\<circ> g \\<longrightarrow> f = g\"", "lemma f2r_mono: \"\\<forall>f g. \\<R> \\<circ> f = \\<R> \\<circ> g \\<longrightarrow> f = g\"", "lemma r2f_mono_iff: \"(\\<F> \\<circ> f = \\<F> \\<circ> g) = (f = g)\"", "lemma f2r_mono_iff : \"(\\<R> \\<circ> f = \\<R> \\<circ> g) = (f = g)\"", "lemma r2f_inj_iff: \"(\\<R> f = \\<R> g) = (f = g)\"", "lemma f2r_inj_iff: \"(\\<F> R = \\<F> S) = (R = S)\"", "lemma r2f_surj: \"surj \\<F>\"", "lemma f2r_surj: \"surj \\<R>\"", "lemma r2f_epi: \"\\<forall>f g. f \\<circ> \\<F> = g \\<circ> \\<F> \\<longrightarrow> f = g\"", "lemma f2r_epi: \"\\<forall>f g. f \\<circ> \\<R> = g \\<circ> \\<R> \\<longrightarrow> f = g\"", "lemma r2f_epi_iff: \"(f \\<circ> \\<F> = g \\<circ> \\<F>) = (f = g)\"", "lemma f2r_epi_iff: \"(f \\<circ> \\<R> = g \\<circ> \\<R>) = (f = g)\"", "lemma r2f_bij: \"bij \\<F>\"", "lemma f2r_bij: \"bij \\<R>\"", "lemma r2f_curry: \"r2f R = Collect \\<circ> (curry \\<circ> s2p) R\"", "lemma f2r_uncurry: \"f2r f = (Collect \\<circ> case_prod) (s2p \\<circ> f)\"", "lemma r2f_comp_pres: \"\\<F> (R ; S) = \\<F> R \\<circ>\\<^sub>K \\<F> S\"", "lemma r2f_Id_pres [simp]: \"\\<F> Id = \\<eta>\"", "lemma r2f_Sup_pres: \"Sup_pres \\<F>\"", "lemma r2f_Sup_pres_var: \"\\<F> (\\<Union>R) = (\\<Squnion>r \\<in> R. \\<F> r)\"", "lemma r2f_sup_pres: \"sup_pres \\<F>\"", "lemma r2f_Inf_pres: \"Inf_pres \\<F>\"", "lemma r2f_Inf_pres_var: \"\\<F> (\\<Sqinter>R) = (\\<Sqinter>r \\<in> R. \\<F> r)\"", "lemma r2f_inf_pres: \"inf_pres \\<F>\"", "lemma r2f_bot_pres: \"bot_pres \\<F>\"", "lemma r2f_top_pres: \"top_pres \\<F>\"", "lemma r2f_leq: \"(R \\<subseteq> S) = (\\<F> R \\<le> \\<F> S)\"", "lemma f2r_kcomp_pres: \"\\<R> (f \\<circ>\\<^sub>K g) = \\<R> f ; \\<R> g\"", "lemma f2r_eta_pres [simp]: \"\\<R> \\<eta> = Id\"", "lemma f2r_Sup_pres:\"Sup_pres \\<R>\"", "lemma f2r_Sup_pres_var: \"\\<R> (\\<Squnion>F) = (\\<Squnion>f \\<in> F. \\<R> f)\"", "lemma f2r_sup_pres: \"sup_pres \\<R>\"", "lemma f2r_Inf_pres: \"Inf_pres \\<R>\"", "lemma f2r_Inf_pres_var: \"\\<R> (\\<Sqinter>F) = (\\<Inter>f \\<in> F. \\<R> f)\"", "lemma f2r_inf_pres: \"inf_pres \\<R>\"", "lemma f2r_bot_pres: \"bot_pres \\<R>\"", "lemma f2r_top_pres: \"top_pres \\<R>\"", "lemma f2r_leq: \"(f \\<le> g) = (\\<R> f \\<subseteq> \\<R> g)\"", "lemma r2f_Id_on1: \"\\<F> (Id_on X) = (\\<lambda>x. if x \\<in> X then {x} else {})\"", "lemma r2f_Id_on2: \"\\<F> (Id_on X) \\<circ>\\<^sub>K f = (\\<lambda>x. if x \\<in> X then f x else {})\"", "lemma r2f_Id_on3: \"f \\<circ>\\<^sub>K \\<F> (Id_on X) = (\\<lambda>x. X \\<inter> f x)\"", "lemma kop_contrav: \"op\\<^sub>K (f \\<circ>\\<^sub>K g) = op\\<^sub>K g \\<circ>\\<^sub>K op\\<^sub>K f\"", "lemma kop_func2 [simp]: \"op\\<^sub>K \\<eta> = \\<eta>\"", "lemma converse_idem [simp]: \"(\\<smile>) \\<circ> (\\<smile>) = id\"", "lemma converse_galois: \"((\\<smile>) \\<circ> f = g) = ((\\<smile>) \\<circ> g = f)\"", "lemma converse_galois2: \"(f \\<circ> (\\<smile>) = g) = (g \\<circ> (\\<smile>) = f)\"", "lemma converse_mono_iff: \"((\\<smile>) \\<circ> f = (\\<smile>) \\<circ> g) = (f = g)\"", "lemma converse_epi_iff: \"(f \\<circ> (\\<smile>) = g \\<circ> (\\<smile>)) = (f = g)\"", "lemma kop_idem [simp]: \"op\\<^sub>K \\<circ> op\\<^sub>K = id\"", "lemma kop_galois: \"(op\\<^sub>K f = g) = (op\\<^sub>K g = f)\"", "lemma kop_galois_var: \"(op\\<^sub>K \\<circ> f = g) = (op\\<^sub>K \\<circ> g = f)\"", "lemma kop_galois_var2: \"(f \\<circ> op\\<^sub>K = g) = (g \\<circ> op\\<^sub>K = f)\"", "lemma kop_inj: \"inj op\\<^sub>K\"", "lemma kop_inj_iff: \"(op\\<^sub>K f = op\\<^sub>K g) = (f = g)\"", "lemma kop_surj: \"surj op\\<^sub>K\"", "lemma kop_bij: \"bij op\\<^sub>K\"", "lemma kop_mono: \"(op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g) \\<Longrightarrow> (f = g)\"", "lemma kop_mono_iff: \"(op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g) = (f = g)\"", "lemma kop_epi: \"(f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K) \\<Longrightarrow> (f = g)\"", "lemma kop_epi_iff: \"(f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K) = (f = g)\"", "lemma Sup_pres_kop: \"Sup_pres op\\<^sub>K\"", "lemma Inf_pres_kop: \"Inf_pres op\\<^sub>K\""], "translations": [["", "lemma P_func1: \"\\<P> (f \\<circ> g) = \\<P> f \\<circ> \\<P> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<P> (f \\<circ> g) = \\<P> f \\<circ> \\<P> g", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. \\<P> (f \\<circ> g) x = (\\<P> f \\<circ> \\<P> g) x", "by force"], ["", "lemma P_func2: \"\\<P> id = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<P> id = id", "by simp"], ["", "text \\<open>Isabelle' type systems doesn't allow formalising arbitrary monads, but instances such as the powerset monad\ncan still be developed.\\<close>"], ["", "abbreviation eta :: \"'a \\<Rightarrow> 'a set\" (\"\\<eta>\") where\n  \"\\<eta> \\<equiv> (\\<lambda>x. {x})\""], ["", "abbreviation mu :: \"'a set set \\<Rightarrow> 'a set\" (\"\\<mu>\") where\n  \"\\<mu> \\<equiv> Union\""], ["", "text \\<open>$\\eta$ and $\\mu$ are natural transformations.\\<close>"], ["", "lemma eta_nt: \"\\<P> f \\<circ> \\<eta> = \\<eta> \\<circ> id f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<P> f \\<circ> \\<eta> = \\<eta> \\<circ> id f", "by fastforce"], ["", "lemma mu_nt: \"\\<mu> \\<circ> (\\<P> \\<circ> \\<P>) f = (\\<P> f) \\<circ> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> (\\<P> \\<circ> \\<P>) f = \\<P> f \\<circ> \\<mu>", "by fastforce"], ["", "text \\<open>They satisfy the following coherence conditions. Explicit typing clarifies that $\\eta$ and $\\mu$ have different type in these expressions.\\<close>"], ["", "lemma pow_assoc: \"(\\<mu>::'a set set \\<Rightarrow> 'a set) \\<circ> \\<P> (\\<mu>::'a set set \\<Rightarrow> 'a set) = (\\<mu> ::'a set set \\<Rightarrow> 'a set) \\<circ> (\\<mu>::'a set set set \\<Rightarrow> 'a set set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> \\<mu> = \\<mu> \\<circ> \\<mu>", "using fun_eq_iff"], ["proof (prove)\nusing this:\n  (?f = ?g) = (\\<forall>x. ?f x = ?g x)\n\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> \\<mu> = \\<mu> \\<circ> \\<mu>", "by fastforce"], ["", "lemma pow_un1: \"(\\<mu>::'a set set \\<Rightarrow> 'a set) \\<circ> (\\<P> (\\<eta>:: 'a  \\<Rightarrow> 'a set)) = (id::'a set  \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> \\<eta> = id", "using fun_eq_iff"], ["proof (prove)\nusing this:\n  (?f = ?g) = (\\<forall>x. ?f x = ?g x)\n\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> \\<eta> = id", "by fastforce"], ["", "lemma pow_un2: \"(\\<mu>::'a set set \\<Rightarrow> 'a set) \\<circ> (\\<eta>::'a set \\<Rightarrow> 'a set set) = (id::'a set \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<eta> = id", "using fun_eq_iff"], ["proof (prove)\nusing this:\n  (?f = ?g) = (\\<forall>x. ?f x = ?g x)\n\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<eta> = id", "by fastforce"], ["", "text \\<open>Thus the powerset monad is indeed a monad.\\<close>"], ["", "subsection \\<open>Kleisli Category of the Powerset Monad\\<close>"], ["", "text \\<open>Next I define the Kleisli composition and Kleisli lifting (Kleisli extension) of Kleisli arrows. \nThe Kleisli lifting turns Kleisli arrows into forward predicate transformers.\\<close>"], ["", "definition kcomp :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('b \\<Rightarrow> 'c set) \\<Rightarrow> ('a  \\<Rightarrow> 'c set)\" (infixl \"\\<circ>\\<^sub>K\" 75) where\n  \"f \\<circ>\\<^sub>K g = \\<mu> \\<circ> \\<P> g \\<circ> f\""], ["", "lemma kcomp_prop: \"(f \\<circ>\\<^sub>K g) x = (\\<Squnion>y \\<in> f x. g y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ>\\<^sub>K g) x = \\<mu> (\\<P> g (f x))", "by (simp add: kcomp_def)"], ["", "definition klift :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> 'a set \\<Rightarrow> 'b set\" (\"_\\<^sup>\\<dagger>\" [101] 100) where\n  \"f\\<^sup>\\<dagger> = \\<mu> \\<circ> \\<P> f\""], ["", "lemma klift_prop: \"(f\\<^sup>\\<dagger>) X = (\\<Squnion>x \\<in> X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^sup>\\<dagger>) X = \\<mu> (\\<P> f X)", "by (simp add: klift_def)"], ["", "lemma kcomp_klift: \"f \\<circ>\\<^sub>K g = g\\<^sup>\\<dagger> \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>\\<^sub>K g = g\\<^sup>\\<dagger> \\<circ> f", "unfolding kcomp_def klift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> g \\<circ> f = \\<mu> \\<circ> \\<P> g \\<circ> f", "by simp"], ["", "lemma klift_prop1: \"(f\\<^sup>\\<dagger> \\<circ> g)\\<^sup>\\<dagger> = f\\<^sup>\\<dagger> \\<circ> g\\<^sup>\\<dagger>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^sup>\\<dagger> \\<circ> g)\\<^sup>\\<dagger> =\n    f\\<^sup>\\<dagger> \\<circ> g\\<^sup>\\<dagger>", "unfolding fun_eq_iff klift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<mu> \\<circ> \\<P> (\\<mu> \\<circ> \\<P> f \\<circ> g)) x =\n       (\\<mu> \\<circ> \\<P> f \\<circ> (\\<mu> \\<circ> \\<P> g)) x", "by simp"], ["", "lemma klift_eta_inv1 [simp]: \"f\\<^sup>\\<dagger> \\<circ> \\<eta> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sup>\\<dagger> \\<circ> \\<eta> = f", "unfolding fun_eq_iff klift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (\\<mu> \\<circ> \\<P> f \\<circ> \\<eta>) x = f x", "by simp"], ["", "lemma klift_eta_pres [simp]: \"\\<eta>\\<^sup>\\<dagger> = (id::'a set \\<Rightarrow> 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<eta>\\<^sup>\\<dagger> = id", "unfolding fun_eq_iff klift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. (\\<mu> \\<circ> \\<P> \\<eta>) x = id x", "by simp"], ["", "lemma klift_id_pres [simp]: \"id\\<^sup>\\<dagger> = \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. id\\<^sup>\\<dagger> = \\<mu>", "unfolding klift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> id = \\<mu>", "by simp"], ["", "lemma kcomp_assoc: \"(f \\<circ>\\<^sub>K g) \\<circ>\\<^sub>K h = f \\<circ>\\<^sub>K (g \\<circ>\\<^sub>K h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>\\<^sub>K g \\<circ>\\<^sub>K h =\n    f \\<circ>\\<^sub>K (g \\<circ>\\<^sub>K h)", "unfolding kcomp_klift klift_prop1"], ["proof (prove)\ngoal (1 subgoal):\n 1. h\\<^sup>\\<dagger> \\<circ> (g\\<^sup>\\<dagger> \\<circ> f) =\n    h\\<^sup>\\<dagger> \\<circ> g\\<^sup>\\<dagger> \\<circ> f", "by force"], ["", "lemma kcomp_idl [simp]: \"\\<eta> \\<circ>\\<^sub>K f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<eta> \\<circ>\\<^sub>K f = f", "unfolding kcomp_klift"], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sup>\\<dagger> \\<circ> \\<eta> = f", "by simp"], ["", "lemma kcomp_idr [simp]: \"f \\<circ>\\<^sub>K \\<eta> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>\\<^sub>K \\<eta> = f", "unfolding kcomp_klift"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<eta>\\<^sup>\\<dagger> \\<circ> f = f", "by simp"], ["", "text \\<open>In the following interpretation statement, types are restricted.\nThis is needed for defining iteration.\\<close>"], ["", "interpretation kmon: monoid_mult \"\\<eta>\" \"(\\<circ>\\<^sub>K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_mult \\<eta> (\\<circ>\\<^sub>K)", "by unfold_locales (simp_all add: kcomp_assoc)"], ["", "text \\<open>Next I show that $\\eta$ is a (contravariant) functor from Set into the Kleisli category of the powerset monad.\nIt simply turns functions into Kleisli arrows.\\<close>"], ["", "lemma eta_func1: \"\\<eta> \\<circ> (f \\<circ> g) = (\\<eta> \\<circ> g) \\<circ>\\<^sub>K (\\<eta> \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<eta> \\<circ> (f \\<circ> g) =\n    (\\<eta> \\<circ> g) \\<circ>\\<^sub>K (\\<eta> \\<circ> f)", "unfolding fun_eq_iff kcomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<eta> \\<circ> (f \\<circ> g)) x =\n       (\\<mu> \\<circ> \\<P> (\\<eta> \\<circ> f) \\<circ> (\\<eta> \\<circ> g)) x", "by simp"], ["", "subsection \\<open>Eilenberg-Moore Algebra\\<close>"], ["", "text \\<open>It is well known that the Eilenberg-Moore algebras of the powerset monad form complete join semilattices (hence Sup-lattices).\\<close>"], ["", "text \\<open>First I verify that every complete lattice with structure map Sup satisfies the laws of Eilenberg-Moore algebras.\\<close>"], ["", "notation Sup (\"\\<sigma>\")"], ["", "lemma em_assoc [simp]: \"\\<sigma> \\<circ> \\<P> (\\<sigma>::'a::complete_lattice set \\<Rightarrow> 'a) = \\<sigma> \\<circ> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<P> \\<sigma> = \\<sigma> \\<circ> \\<mu>", "apply (standard, rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       (\\<sigma> \\<circ> \\<P> \\<sigma>) x \\<le> (\\<sigma> \\<circ> \\<mu>) x\n 2. \\<And>x.\n       (\\<sigma> \\<circ> \\<mu>) x \\<le> (\\<sigma> \\<circ> \\<P> \\<sigma>) x", "apply (simp add: SUP_least Sup_subset_mono Sup_upper)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<sigma> \\<circ> \\<mu>) x \\<le> (\\<sigma> \\<circ> \\<P> \\<sigma>) x", "by (metis (no_types, lifting) SUP_upper2 Sup_least Sup_upper UnionE comp_def)"], ["", "lemma em_id [simp]: \"\\<sigma> \\<circ> \\<eta> = (id::'a::complete_lattice \\<Rightarrow> 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<eta> = id", "by (simp add: fun_eq_iff)"], ["", "text\\<open>Hence every Sup-lattice is an Eilenberg-Moore algebra for the powerset monad. \nThe morphisms between Eilenberg-Moore algebras of the powerset monad are Sup-preserving maps. \nIn particular, powersets with structure map $\\mu$ form an Eilenberg-Moore algebra (in fact the free one):\\<close>"], ["", "lemma em_mu_assoc [simp]: \"\\<mu> \\<circ> \\<P> \\<mu> = \\<mu> \\<circ> \\<mu>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<P> \\<mu> = \\<mu> \\<circ> \\<mu>", "by simp"], ["", "lemma em_mu_id [simp]: \"\\<mu> \\<circ> \\<eta> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<mu> \\<circ> \\<eta> = id", "by simp"], ["", "text \\<open>Next I show that every Eilenberg-Moore algebras for the \npowerset functor is a Sup-lattice.\\<close>"], ["", "class eilenberg_moore_pow = \n  fixes smap :: \"'a set \\<Rightarrow> 'a\"\n  assumes smap_assoc: \"smap \\<circ> \\<P> smap = smap \\<circ> \\<mu>\"\n  and smap_id: \"smap \\<circ> \\<eta> = id\"\n\nbegin"], ["", "definition \"sleq = (\\<lambda>x y. smap {x,y} = y)\""], ["", "definition \"sle = (\\<lambda>x y. sleq x y \\<and> y \\<noteq> x)\""], ["", "lemma smap_un1: \"smap {x, smap Y} = smap ({x} \\<union> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "have \"smap {x, smap Y} = smap {smap {x}, smap Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) =\n    smap (insert (smap (\\<eta> x)) (\\<eta> (smap Y)))", "by (metis comp_apply id_apply smap_id)"], ["proof (state)\nthis:\n  smap (insert x (\\<eta> (smap Y))) =\n  smap (insert (smap (\\<eta> x)) (\\<eta> (smap Y)))\n\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "also"], ["proof (state)\nthis:\n  smap (insert x (\\<eta> (smap Y))) =\n  smap (insert (smap (\\<eta> x)) (\\<eta> (smap Y)))\n\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "have \"... = (smap \\<circ> \\<P> smap) {{x}, Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (insert (smap (\\<eta> x)) (\\<eta> (smap Y))) =\n    (smap \\<circ> \\<P> smap) (insert (\\<eta> x) (\\<eta> Y))", "by simp"], ["proof (state)\nthis:\n  smap (insert (smap (\\<eta> x)) (\\<eta> (smap Y))) =\n  (smap \\<circ> \\<P> smap) (insert (\\<eta> x) (\\<eta> Y))\n\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "finally"], ["proof (chain)\npicking this:\n  smap (insert x (\\<eta> (smap Y))) =\n  (smap \\<circ> \\<P> smap) (insert (\\<eta> x) (\\<eta> Y))", "show ?thesis"], ["proof (prove)\nusing this:\n  smap (insert x (\\<eta> (smap Y))) =\n  (smap \\<circ> \\<P> smap) (insert (\\<eta> x) (\\<eta> Y))\n\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "using local.smap_assoc"], ["proof (prove)\nusing this:\n  smap (insert x (\\<eta> (smap Y))) =\n  (smap \\<circ> \\<P> smap) (insert (\\<eta> x) (\\<eta> Y))\n  smap \\<circ> \\<P> smap = smap \\<circ> \\<mu>\n\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)", "by auto"], ["proof (state)\nthis:\n  smap (insert x (\\<eta> (smap Y))) = smap (\\<eta> x \\<union> Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma smap_comm: \"smap {x, smap Y} = smap {smap Y, x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (insert x (\\<eta> (smap Y))) = smap (insert (smap Y) (\\<eta> x))", "by (simp add: insert_commute)"], ["", "lemma smap_un2: \"smap {smap X, y} = smap (X \\<union> {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (insert (smap X) (\\<eta> y)) = smap (X \\<union> \\<eta> y)", "using smap_comm smap_un1"], ["proof (prove)\nusing this:\n  smap (insert ?x (\\<eta> (smap ?Y))) = smap (insert (smap ?Y) (\\<eta> ?x))\n  smap (insert ?x (\\<eta> (smap ?Y))) = smap (\\<eta> ?x \\<union> ?Y)\n\ngoal (1 subgoal):\n 1. smap (insert (smap X) (\\<eta> y)) = smap (X \\<union> \\<eta> y)", "by auto"], ["", "lemma sleq_refl: \"sleq x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sleq x x", "by (metis id_apply insert_absorb2 local.smap_id o_apply sleq_def)"], ["", "lemma sleq_trans: \"sleq x y \\<Longrightarrow> sleq y z \\<Longrightarrow> sleq x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sleq x y; sleq y z\\<rbrakk> \\<Longrightarrow> sleq x z", "by (metis (no_types, lifting) sleq_def smap_un1 smap_un2 sup_assoc)"], ["", "lemma sleq_antisym: \"sleq x y \\<Longrightarrow> sleq y x \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sleq x y; sleq y x\\<rbrakk> \\<Longrightarrow> x = y", "by (simp add: insert_commute sleq_def)"], ["", "lemma smap_ub: \"x \\<in> A \\<Longrightarrow> sleq x (smap A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> sleq x (smap A)", "using insert_absorb sleq_def smap_un1"], ["proof (prove)\nusing this:\n  ?a \\<in> ?A \\<Longrightarrow> insert ?a ?A = ?A\n  sleq = (\\<lambda>x y. smap (insert x (\\<eta> y)) = y)\n  smap (insert ?x (\\<eta> (smap ?Y))) = smap (\\<eta> ?x \\<union> ?Y)\n\ngoal (1 subgoal):\n 1. x \\<in> A \\<Longrightarrow> sleq x (smap A)", "by fastforce"], ["", "lemma smap_lub: \"(\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow> sleq (smap A) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "assume h: \"\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z\""], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> sleq ?x z\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"smap {smap A, z} = smap (A \\<union> {z})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (insert (smap A) (\\<eta> z)) = smap (A \\<union> \\<eta> z)", "by (simp add: smap_un2)"], ["proof (state)\nthis:\n  smap (insert (smap A) (\\<eta> z)) = smap (A \\<union> \\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap (insert (smap A) (\\<eta> z)) = smap (A \\<union> \\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap ((\\<Union>x \\<in> A. {x,z})  \\<union> {z})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap (A \\<union> \\<eta> z) =\n    smap\n     (\\<mu> (\\<P> (\\<lambda>x. insert x (\\<eta> z)) A) \\<union> \\<eta> z)", "by (rule_tac f=smap in arg_cong, auto)"], ["proof (state)\nthis:\n  smap (A \\<union> \\<eta> z) =\n  smap (\\<mu> (\\<P> (\\<lambda>x. insert x (\\<eta> z)) A) \\<union> \\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap (A \\<union> \\<eta> z) =\n  smap (\\<mu> (\\<P> (\\<lambda>x. insert x (\\<eta> z)) A) \\<union> \\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap {(smap \\<circ> \\<mu>) {{x,z} |x. x \\<in> A}, z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\n     (\\<mu> (\\<P> (\\<lambda>x. insert x (\\<eta> z)) A) \\<union> \\<eta> z) =\n    smap\n     (insert ((smap \\<circ> \\<mu>) {insert x (\\<eta> z) |x. x \\<in> A})\n       (\\<eta> z))", "by (simp add: Setcompr_eq_image smap_un2)"], ["proof (state)\nthis:\n  smap\n   (\\<mu> (\\<P> (\\<lambda>x. insert x (\\<eta> z)) A) \\<union> \\<eta> z) =\n  smap\n   (insert ((smap \\<circ> \\<mu>) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap\n   (\\<mu> (\\<P> (\\<lambda>x. insert x (\\<eta> z)) A) \\<union> \\<eta> z) =\n  smap\n   (insert ((smap \\<circ> \\<mu>) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap {(smap \\<circ> \\<P> smap) {{x,z} |x. x \\<in> A}, z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\n     (insert ((smap \\<circ> \\<mu>) {insert x (\\<eta> z) |x. x \\<in> A})\n       (\\<eta> z)) =\n    smap\n     (insert ((smap \\<circ> \\<P> smap) {insert x (\\<eta> z) |x. x \\<in> A})\n       (\\<eta> z))", "by (simp add: local.smap_assoc)"], ["proof (state)\nthis:\n  smap\n   (insert ((smap \\<circ> \\<mu>) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z)) =\n  smap\n   (insert ((smap \\<circ> \\<P> smap) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap\n   (insert ((smap \\<circ> \\<mu>) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z)) =\n  smap\n   (insert ((smap \\<circ> \\<P> smap) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap {smap {smap {x,z} |x. x \\<in> A}, z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\n     (insert ((smap \\<circ> \\<P> smap) {insert x (\\<eta> z) |x. x \\<in> A})\n       (\\<eta> z)) =\n    smap\n     (insert (smap {smap (insert x (\\<eta> z)) |x. x \\<in> A}) (\\<eta> z))", "by (simp add: Setcompr_eq_image image_image)"], ["proof (state)\nthis:\n  smap\n   (insert ((smap \\<circ> \\<P> smap) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z)) =\n  smap (insert (smap {smap (insert x (\\<eta> z)) |x. x \\<in> A}) (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap\n   (insert ((smap \\<circ> \\<P> smap) {insert x (\\<eta> z) |x. x \\<in> A})\n     (\\<eta> z)) =\n  smap (insert (smap {smap (insert x (\\<eta> z)) |x. x \\<in> A}) (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap {smap {z |x. x \\<in> A}, z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\n     (insert (smap {smap (insert x (\\<eta> z)) |x. x \\<in> A}) (\\<eta> z)) =\n    smap\n     (insert (smap {uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A}) (\\<eta> z))", "by (metis h sleq_def)"], ["proof (state)\nthis:\n  smap\n   (insert (smap {smap (insert x (\\<eta> z)) |x. x \\<in> A}) (\\<eta> z)) =\n  smap\n   (insert (smap {uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A}) (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap\n   (insert (smap {smap (insert x (\\<eta> z)) |x. x \\<in> A}) (\\<eta> z)) =\n  smap\n   (insert (smap {uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A}) (\\<eta> z))\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap ({z |x. x \\<in> A} \\<union> {z})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\n     (insert (smap {uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A})\n       (\\<eta> z)) =\n    smap ({uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A} \\<union> \\<eta> z)", "by (simp add: smap_un2)"], ["proof (state)\nthis:\n  smap\n   (insert (smap {uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A}) (\\<eta> z)) =\n  smap ({uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A} \\<union> \\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "also"], ["proof (state)\nthis:\n  smap\n   (insert (smap {uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A}) (\\<eta> z)) =\n  smap ({uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A} \\<union> \\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "have \"... = smap {z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap ({uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A} \\<union> \\<eta> z) =\n    smap (\\<eta> z)", "by (rule_tac f=smap in arg_cong, auto)"], ["proof (state)\nthis:\n  smap ({uu_. \\<exists>x. uu_ = z \\<and> x \\<in> A} \\<union> \\<eta> z) =\n  smap (\\<eta> z)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> sleq x z) \\<Longrightarrow>\n    sleq (smap A) z", "finally"], ["proof (chain)\npicking this:\n  smap (insert (smap A) (\\<eta> z)) = smap (\\<eta> z)", "show ?thesis"], ["proof (prove)\nusing this:\n  smap (insert (smap A) (\\<eta> z)) = smap (\\<eta> z)\n\ngoal (1 subgoal):\n 1. sleq (smap A) z", "using sleq_def sleq_refl"], ["proof (prove)\nusing this:\n  smap (insert (smap A) (\\<eta> z)) = smap (\\<eta> z)\n  sleq = (\\<lambda>x y. smap (insert x (\\<eta> y)) = y)\n  sleq ?x ?x\n\ngoal (1 subgoal):\n 1. sleq (smap A) z", "by auto"], ["proof (state)\nthis:\n  sleq (smap A) z\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale smap_Sup_lat: Sup_lattice smap sleq sle"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.Sup_lattice smap sleq", "by unfold_locales (simp_all add: sleq_refl sleq_antisym sleq_trans smap_ub smap_lub)"], ["", "text \\<open>Hence every complete lattice is an Eilenberg-Moore algebra of $\\mathcal{P}$.\\<close>"], ["", "no_notation Sup (\"\\<sigma>\")"], ["", "end"], ["", "subsection \\<open>Isomorphism between Kleisli Category and Rel\\<close>"], ["", "text \\<open>This is again well known---the isomorphism is essentially curry vs uncurry. Kleisli arrows are nondeterministic functions; \nthey are also known as state transformers.  Binary relations are very well developed in Isabelle; Kleisli composition of Kleisli \narrows isn't. Ideally one should therefore use the isomorphism to transport theorems from relations to Kleisli arrows automatically. \nI spell out the isomorphisms and prove that the full quantalic structure, that is, complete lattices plus compositions, \nis preserved by the isomorphisms.\\<close>"], ["", "abbreviation kzero :: \"'a \\<Rightarrow> 'b set\" (\"\\<zeta>\") where\n  \"\\<zeta> \\<equiv> (\\<lambda>x::'a. {})\""], ["", "text \\<open>First I define the morphisms. The second one is nothing but the graph of a function.\\<close>"], ["", "definition r2f :: \"('a \\<times> 'b) set \\<Rightarrow> 'a \\<Rightarrow> 'b set\" (\"\\<F>\") where\n  \"\\<F> R = Image R \\<circ> \\<eta>\""], ["", "definition f2r :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> ('a \\<times> 'b) set\" (\"\\<R>\") where\n  \"\\<R> f = {(x,y). y \\<in> f x}\""], ["", "text \\<open>The functors form a bijective pair.\\<close>"], ["", "lemma r2f2r_inv1 [simp]: \"\\<R> \\<circ> \\<F> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> \\<circ> \\<F> = id", "unfolding f2r_def r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. {(x, y). y \\<in> f x}) \\<circ>\n    (\\<lambda>R. (``) R \\<circ> \\<eta>) =\n    id", "by force"], ["", "lemma f2r2f_inv2 [simp]: \"\\<F> \\<circ> \\<R> = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> \\<circ> \\<R> = id", "unfolding f2r_def r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>R. (``) R \\<circ> \\<eta>) \\<circ>\n    (\\<lambda>f. {(x, y). y \\<in> f x}) =\n    id", "by force"], ["", "lemma r2f_f2r_galois: \"(\\<R> f = R) = (\\<F> R = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<R> f = R) = (\\<F> R = f)", "by (force simp: f2r_def r2f_def)"], ["", "lemma r2f_f2r_galois_var: \"(\\<R> \\<circ> f = R) = (\\<F> \\<circ> R = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<R> \\<circ> f = R) = (\\<F> \\<circ> R = f)", "by (force simp: f2r_def r2f_def)"], ["", "lemma r2f_f2r_galois_var2: \"(f \\<circ> \\<R> = R) = (R \\<circ> \\<F> = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> \\<R> = R) = (R \\<circ> \\<F> = f)", "by (metis (no_types, hide_lams) comp_id f2r2f_inv2 map_fun_def o_assoc r2f2r_inv1)"], ["", "lemma r2f_inj: \"inj \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<F>", "by (meson inj_on_inverseI r2f_f2r_galois)"], ["", "lemma f2r_inj: \"inj \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj \\<R>", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. \\<R> x = \\<R> y \\<longrightarrow> x = y", "using r2f_f2r_galois"], ["proof (prove)\nusing this:\n  (\\<R> ?f = ?R) = (\\<F> ?R = ?f)\n\ngoal (1 subgoal):\n 1. \\<forall>x y. \\<R> x = \\<R> y \\<longrightarrow> x = y", "by metis"], ["", "lemma r2f_mono: \"\\<forall>f g. \\<F> \\<circ> f = \\<F> \\<circ> g \\<longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f g. \\<F> \\<circ> f = \\<F> \\<circ> g \\<longrightarrow> f = g", "by (force simp: fun_eq_iff r2f_def)"], ["", "lemma f2r_mono: \"\\<forall>f g. \\<R> \\<circ> f = \\<R> \\<circ> g \\<longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f g. \\<R> \\<circ> f = \\<R> \\<circ> g \\<longrightarrow> f = g", "by (force simp: fun_eq_iff f2r_def)"], ["", "lemma r2f_mono_iff: \"(\\<F> \\<circ> f = \\<F> \\<circ> g) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<F> \\<circ> f = \\<F> \\<circ> g) = (f = g)", "using r2f_mono"], ["proof (prove)\nusing this:\n  \\<forall>f g. \\<F> \\<circ> f = \\<F> \\<circ> g \\<longrightarrow> f = g\n\ngoal (1 subgoal):\n 1. (\\<F> \\<circ> f = \\<F> \\<circ> g) = (f = g)", "by blast"], ["", "lemma f2r_mono_iff : \"(\\<R> \\<circ> f = \\<R> \\<circ> g) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<R> \\<circ> f = \\<R> \\<circ> g) = (f = g)", "using f2r_mono"], ["proof (prove)\nusing this:\n  \\<forall>f g. \\<R> \\<circ> f = \\<R> \\<circ> g \\<longrightarrow> f = g\n\ngoal (1 subgoal):\n 1. (\\<R> \\<circ> f = \\<R> \\<circ> g) = (f = g)", "by blast"], ["", "lemma r2f_inj_iff: \"(\\<R> f = \\<R> g) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<R> f = \\<R> g) = (f = g)", "by (simp add: f2r_inj inj_eq)"], ["", "lemma f2r_inj_iff: \"(\\<F> R = \\<F> S) = (R = S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<F> R = \\<F> S) = (R = S)", "by (simp add: r2f_inj inj_eq)"], ["", "lemma r2f_surj: \"surj \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres (\\<P> \\<F>)", "by (metis r2f_f2r_galois surj_def)"], ["", "lemma f2r_surj: \"surj \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres (\\<P> \\<R>)", "using r2f_f2r_galois"], ["proof (prove)\nusing this:\n  (\\<R> ?f = ?R) = (\\<F> ?R = ?f)\n\ngoal (1 subgoal):\n 1. top_pres (\\<P> \\<R>)", "by auto"], ["", "lemma r2f_epi: \"\\<forall>f g. f \\<circ> \\<F> = g \\<circ> \\<F> \\<longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f g. f \\<circ> \\<F> = g \\<circ> \\<F> \\<longrightarrow> f = g", "by (metis r2f_f2r_galois_var2)"], ["", "lemma f2r_epi: \"\\<forall>f g. f \\<circ> \\<R> = g \\<circ> \\<R> \\<longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f g. f \\<circ> \\<R> = g \\<circ> \\<R> \\<longrightarrow> f = g", "by (metis r2f_f2r_galois_var2)"], ["", "lemma r2f_epi_iff: \"(f \\<circ> \\<F> = g \\<circ> \\<F>) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> \\<F> = g \\<circ> \\<F>) = (f = g)", "using r2f_epi"], ["proof (prove)\nusing this:\n  \\<forall>f g. f \\<circ> \\<F> = g \\<circ> \\<F> \\<longrightarrow> f = g\n\ngoal (1 subgoal):\n 1. (f \\<circ> \\<F> = g \\<circ> \\<F>) = (f = g)", "by blast"], ["", "lemma f2r_epi_iff: \"(f \\<circ> \\<R> = g \\<circ> \\<R>) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> \\<R> = g \\<circ> \\<R>) = (f = g)", "using f2r_epi"], ["proof (prove)\nusing this:\n  \\<forall>f g. f \\<circ> \\<R> = g \\<circ> \\<R> \\<longrightarrow> f = g\n\ngoal (1 subgoal):\n 1. (f \\<circ> \\<R> = g \\<circ> \\<R>) = (f = g)", "by blast"], ["", "lemma r2f_bij: \"bij \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<F>", "by (simp add: bijI r2f_inj r2f_surj)"], ["", "lemma f2r_bij: \"bij \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij \\<R>", "by (simp add: bij_def f2r_inj f2r_surj)"], ["", "text \\<open>r2f is essentially curry and f2r is uncurry, yet in Isabelle the type of sets and predicates \n(boolean-valued functions) are different. Collect transforms predicates into sets and the following function\nsets into predicates:\\<close>"], ["", "abbreviation \"s2p X \\<equiv> (\\<lambda>x. x \\<in> X)\""], ["", "lemma r2f_curry: \"r2f R = Collect \\<circ> (curry \\<circ> s2p) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> R = Collect \\<circ> (curry \\<circ> s2p) R", "by (force simp: r2f_def fun_eq_iff curry_def)"], ["", "lemma f2r_uncurry: \"f2r f = (Collect \\<circ> case_prod) (s2p \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> f = (Collect \\<circ> case_prod) (s2p \\<circ> f)", "by (force simp: fun_eq_iff f2r_def)"], ["", "text \\<open>Uncurry is case-prod in Isabelle.\\<close>"], ["", "text \\<open>f2r and r2f preserve the quantalic structures of relations and Kleisli arrows. In particular they are functors.\\<close>"], ["", "lemma r2f_comp_pres: \"\\<F> (R ; S) = \\<F> R \\<circ>\\<^sub>K \\<F> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> (R ; S) = \\<F> R \\<circ>\\<^sub>K \\<F> S", "unfolding fun_eq_iff r2f_def kcomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ((``) (R ; S) \\<circ> \\<eta>) x =\n       (\\<mu> \\<circ> \\<P> ((``) S \\<circ> \\<eta>) \\<circ>\n        ((``) R \\<circ> \\<eta>))\n        x", "by force"], ["", "lemma r2f_Id_pres [simp]: \"\\<F> Id = \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> Id = \\<eta>", "unfolding fun_eq_iff r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. ((``) Id \\<circ> \\<eta>) x = \\<eta> x", "by simp"], ["", "lemma r2f_Sup_pres: \"Sup_pres \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres \\<F>", "unfolding fun_eq_iff r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       ((\\<lambda>R. (``) R \\<circ> \\<eta>) \\<circ> \\<mu>) x xa =\n       (Sup \\<circ> \\<P> (\\<lambda>R. (``) R \\<circ> \\<eta>)) x xa", "by force"], ["", "lemma r2f_Sup_pres_var: \"\\<F> (\\<Union>R) = (\\<Squnion>r \\<in> R. \\<F> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> (\\<mu> R) = \\<Squnion> \\<P> \\<F> R", "unfolding r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (``) (\\<mu> R) \\<circ> \\<eta> =\n    (\\<Squnion>r\\<in>R. (``) r \\<circ> \\<eta>)", "by force"], ["", "lemma r2f_sup_pres: \"sup_pres \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_pres \\<F>", "unfolding r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (``) (x \\<union> y) \\<circ> \\<eta> =\n       ((``) x \\<circ> \\<eta>) \\<squnion> ((``) y \\<circ> \\<eta>)", "by force"], ["", "lemma r2f_Inf_pres: \"Inf_pres \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres \\<F>", "unfolding fun_eq_iff r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       ((\\<lambda>R. (``) R \\<circ> \\<eta>) \\<circ> \\<Inter>) x xa =\n       (Inf \\<circ> \\<P> (\\<lambda>R. (``) R \\<circ> \\<eta>)) x xa", "by force"], ["", "lemma r2f_Inf_pres_var: \"\\<F> (\\<Sqinter>R) = (\\<Sqinter>r \\<in> R. \\<F> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> (\\<Inter> R) = \\<Sqinter> \\<P> \\<F> R", "unfolding r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (``) (\\<Inter> R) \\<circ> \\<eta> =\n    (\\<Sqinter>r\\<in>R. (``) r \\<circ> \\<eta>)", "by force"], ["", "lemma r2f_inf_pres: \"inf_pres \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_pres \\<F>", "unfolding r2f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       (``) (x \\<inter> y) \\<circ> \\<eta> =\n       ((``) x \\<circ> \\<eta>) \\<sqinter> ((``) y \\<circ> \\<eta>)", "by force"], ["", "lemma r2f_bot_pres: \"bot_pres \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_pres \\<F>", "by (metis SUP_empty Sup_empty r2f_Sup_pres_var)"], ["", "lemma r2f_top_pres: \"top_pres \\<F>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres \\<F>", "by (metis Sup_UNIV r2f_Sup_pres_var r2f_surj)"], ["", "lemma r2f_leq: \"(R \\<subseteq> S) = (\\<F> R \\<le> \\<F> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R \\<subseteq> S) = (\\<F> R \\<le> \\<F> S)", "by (metis le_iff_sup r2f_f2r_galois r2f_sup_pres)"], ["", "text \\<open>Dual statements for f2r hold. Can one automate this?\\<close>"], ["", "lemma f2r_kcomp_pres: \"\\<R> (f \\<circ>\\<^sub>K g) = \\<R> f ; \\<R> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> (f \\<circ>\\<^sub>K g) = \\<R> f ; \\<R> g", "by (simp add: r2f_f2r_galois r2f_comp_pres pointfree_idE)"], ["", "lemma f2r_eta_pres [simp]: \"\\<R> \\<eta> = Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> \\<eta> = Id", "by (simp add: r2f_f2r_galois)"], ["", "lemma f2r_Sup_pres:\"Sup_pres \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres \\<R>", "by (auto simp: r2f_f2r_galois_var comp_assoc[symmetric] r2f_Sup_pres image_comp)"], ["", "lemma f2r_Sup_pres_var: \"\\<R> (\\<Squnion>F) = (\\<Squnion>f \\<in> F. \\<R> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> (\\<Squnion> F) = \\<mu> (\\<P> \\<R> F)", "by (simp add: r2f_f2r_galois r2f_Sup_pres_var image_comp)"], ["", "lemma f2r_sup_pres: \"sup_pres \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_pres \\<R>", "by (simp add: r2f_f2r_galois r2f_sup_pres pointfree_idE)"], ["", "lemma f2r_Inf_pres: \"Inf_pres \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres \\<R>", "by (auto simp: r2f_f2r_galois_var comp_assoc[symmetric] r2f_Inf_pres image_comp)"], ["", "lemma f2r_Inf_pres_var: \"\\<R> (\\<Sqinter>F) = (\\<Inter>f \\<in> F. \\<R> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<R> (\\<Sqinter> F) = \\<Inter> (\\<P> \\<R> F)", "by (simp add: r2f_f2r_galois r2f_Inf_pres_var image_comp)"], ["", "lemma f2r_inf_pres: \"inf_pres \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_pres \\<R>", "by (simp add: r2f_f2r_galois r2f_inf_pres pointfree_idE)"], ["", "lemma f2r_bot_pres: \"bot_pres \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot_pres \\<R>", "by (simp add: r2f_bot_pres r2f_f2r_galois)"], ["", "lemma f2r_top_pres: \"top_pres \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres \\<R>", "by (simp add: r2f_f2r_galois r2f_top_pres)"], ["", "lemma f2r_leq: \"(f \\<le> g) = (\\<R> f \\<subseteq> \\<R> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<le> g) = (\\<R> f \\<subseteq> \\<R> g)", "by (metis r2f_f2r_galois r2f_leq)"], ["", "text \\<open>Relational subidentities are isomorphic to particular Kleisli arrows.\\<close>"], ["", "lemma r2f_Id_on1: \"\\<F> (Id_on X) = (\\<lambda>x. if x \\<in> X then {x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> (Id_on X) = (\\<lambda>x. if s2p X x then \\<eta> x else {})", "by (force simp add: fun_eq_iff r2f_def Id_on_def)"], ["", "lemma r2f_Id_on2: \"\\<F> (Id_on X) \\<circ>\\<^sub>K f = (\\<lambda>x. if x \\<in> X then f x else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<F> (Id_on X) \\<circ>\\<^sub>K f =\n    (\\<lambda>x. if s2p X x then f x else {})", "unfolding fun_eq_iff Id_on_def r2f_def kcomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<mu> \\<circ> \\<P> f \\<circ>\n        ((``) (\\<mu> (\\<P> (\\<lambda>x. \\<eta> (x, x)) X)) \\<circ> \\<eta>))\n        x =\n       (if s2p X x then f x else {})", "by auto"], ["", "lemma r2f_Id_on3: \"f \\<circ>\\<^sub>K \\<F> (Id_on X) = (\\<lambda>x. X \\<inter> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ>\\<^sub>K \\<F> (Id_on X) = (\\<lambda>x. X \\<inter> f x)", "unfolding kcomp_def r2f_def Id_on_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<mu> \\<circ>\n        \\<P>\n         ((``) (\\<mu> (\\<P> (\\<lambda>x. \\<eta> (x, x)) X)) \\<circ>\n          \\<eta>) \\<circ>\n        f)\n        x =\n       X \\<inter> f x", "by auto"], ["", "subsection \\<open>The opposite Kleisli Category\\<close>"], ["", "text \\<open>Opposition is funtamental for categories; yet hard to realise in Isabelle in general. Due to the access to relations,\nthe Kleisli category of the powerset functor is an exception.\\<close>"], ["", "notation converse (\"\\<smile>\")"], ["", "definition kop :: \"('a \\<Rightarrow> 'b set) \\<Rightarrow> 'b \\<Rightarrow> 'a set\" (\"op\\<^sub>K\") where\n  \"op\\<^sub>K = \\<F> \\<circ> (\\<smile>) \\<circ> \\<R>\""], ["", "text \\<open>Kop is a contravariant functor.\\<close>"], ["", "lemma kop_contrav: \"op\\<^sub>K (f \\<circ>\\<^sub>K g) = op\\<^sub>K g \\<circ>\\<^sub>K op\\<^sub>K f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>K (f \\<circ>\\<^sub>K g) =\n    op\\<^sub>K g \\<circ>\\<^sub>K op\\<^sub>K f", "unfolding kop_def r2f_def f2r_def converse_def kcomp_def fun_eq_iff comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {(x, y).\n        (\\<lambda>x xa.\n            s2p {(x, y). s2p (\\<mu> (\\<P> g (f x))) y}\n             (x, xa))\\<inverse>\\<inverse>\n         x y} ``\n       \\<eta> x =\n       \\<mu>\n        (\\<P>\n          (\\<lambda>x.\n              {(x, y).\n               (\\<lambda>x xa.\n                   s2p {(x, y). s2p (f x) y} (x, xa))\\<inverse>\\<inverse>\n                x y} ``\n              \\<eta> x)\n          ({(x, y).\n            (\\<lambda>x xa.\n                s2p {(x, y). s2p (g x) y} (x, xa))\\<inverse>\\<inverse>\n             x y} ``\n           \\<eta> x))", "by fastforce"], ["", "lemma kop_func2 [simp]: \"op\\<^sub>K \\<eta> = \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>K \\<eta> = \\<eta>", "unfolding kop_def r2f_def f2r_def converse_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       {(x, y).\n        (\\<lambda>x xa.\n            s2p {(x, y). s2p (\\<eta> x) y} (x, xa))\\<inverse>\\<inverse>\n         x y} ``\n       \\<eta> x =\n       \\<eta> x", "by fastforce"], ["", "lemma converse_idem [simp]: \"(\\<smile>) \\<circ> (\\<smile>) = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<smile> \\<circ> \\<smile> = id", "using comp_def"], ["proof (prove)\nusing this:\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (1 subgoal):\n 1. \\<smile> \\<circ> \\<smile> = id", "by auto"], ["", "lemma converse_galois: \"((\\<smile>) \\<circ> f = g) = ((\\<smile>) \\<circ> g = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<smile> \\<circ> f = g) = (\\<smile> \\<circ> g = f)", "by auto"], ["", "lemma converse_galois2: \"(f \\<circ> (\\<smile>) = g) = (g \\<circ> (\\<smile>) = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> \\<smile> = g) = (g \\<circ> \\<smile> = f)", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. f (\\<smile> x) = g x) = (\\<forall>x. g (\\<smile> x) = f x)", "by (metis converse_converse)"], ["", "lemma converse_mono_iff: \"((\\<smile>) \\<circ> f = (\\<smile>) \\<circ> g) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<smile> \\<circ> f = \\<smile> \\<circ> g) = (f = g)", "using converse_galois"], ["proof (prove)\nusing this:\n  (\\<smile> \\<circ> ?f = ?g) = (\\<smile> \\<circ> ?g = ?f)\n\ngoal (1 subgoal):\n 1. (\\<smile> \\<circ> f = \\<smile> \\<circ> g) = (f = g)", "by force"], ["", "lemma converse_epi_iff: \"(f \\<circ> (\\<smile>) = g \\<circ> (\\<smile>)) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> \\<smile> = g \\<circ> \\<smile>) = (f = g)", "using converse_galois2"], ["proof (prove)\nusing this:\n  (?f \\<circ> \\<smile> = ?g) = (?g \\<circ> \\<smile> = ?f)\n\ngoal (1 subgoal):\n 1. (f \\<circ> \\<smile> = g \\<circ> \\<smile>) = (f = g)", "by force"], ["", "lemma kop_idem [simp]: \"op\\<^sub>K \\<circ> op\\<^sub>K = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>K \\<circ> op\\<^sub>K = id", "unfolding kop_def comp_def fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       \\<F> (\\<smile> (\\<R> (\\<F> (\\<smile> (\\<R> x))))) xa = id x xa", "by (metis converse_converse id_apply r2f_f2r_galois)"], ["", "lemma kop_galois: \"(op\\<^sub>K f = g) = (op\\<^sub>K g = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>K f = g) = (op\\<^sub>K g = f)", "by (metis kop_idem pointfree_idE)"], ["", "lemma kop_galois_var: \"(op\\<^sub>K \\<circ> f = g) = (op\\<^sub>K \\<circ> g = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>K \\<circ> f = g) = (op\\<^sub>K \\<circ> g = f)", "by (auto simp: kop_def f2r_def r2f_def converse_def fun_eq_iff)"], ["", "lemma kop_galois_var2: \"(f \\<circ> op\\<^sub>K = g) = (g \\<circ> op\\<^sub>K = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> op\\<^sub>K = g) = (g \\<circ> op\\<^sub>K = f)", "by (metis (no_types, hide_lams) comp_assoc comp_id kop_idem)"], ["", "lemma kop_inj: \"inj op\\<^sub>K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj op\\<^sub>K", "unfolding inj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. op\\<^sub>K x = op\\<^sub>K y \\<longrightarrow> x = y", "by (simp add: f2r_inj_iff kop_def r2f_inj_iff)"], ["", "lemma kop_inj_iff: \"(op\\<^sub>K f = op\\<^sub>K g) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>K f = op\\<^sub>K g) = (f = g)", "by (simp add: inj_eq kop_inj)"], ["", "lemma kop_surj: \"surj op\\<^sub>K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_pres (\\<P> op\\<^sub>K)", "unfolding surj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>x. y = op\\<^sub>K x", "by (metis kop_galois)"], ["", "lemma kop_bij: \"bij op\\<^sub>K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij op\\<^sub>K", "by (simp add: bij_def kop_inj kop_surj)"], ["", "lemma kop_mono: \"(op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g) \\<Longrightarrow> (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g \\<Longrightarrow> f = g", "by (simp add: fun.inj_map inj_eq kop_inj)"], ["", "lemma kop_mono_iff: \"(op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g) = (f = g)", "using kop_mono"], ["proof (prove)\nusing this:\n  op\\<^sub>K \\<circ> ?f = op\\<^sub>K \\<circ> ?g \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. (op\\<^sub>K \\<circ> f = op\\<^sub>K \\<circ> g) = (f = g)", "by blast"], ["", "lemma kop_epi: \"(f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K) \\<Longrightarrow> (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K \\<Longrightarrow> f = g", "by (metis kop_galois_var2)"], ["", "lemma kop_epi_iff: \"(f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K) = (f = g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K) = (f = g)", "using kop_epi"], ["proof (prove)\nusing this:\n  ?f \\<circ> op\\<^sub>K = ?g \\<circ> op\\<^sub>K \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. (f \\<circ> op\\<^sub>K = g \\<circ> op\\<^sub>K) = (f = g)", "by blast"], ["", "lemma Sup_pres_kop: \"Sup_pres op\\<^sub>K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup_pres op\\<^sub>K", "unfolding kop_def fun_eq_iff comp_def r2f_def f2r_def converse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       {(xa, y).\n        (\\<lambda>xa xb.\n            s2p {(xa, y). s2p ((\\<Squnion> x) xa) y}\n             (xa, xb))\\<inverse>\\<inverse>\n         xa y} ``\n       \\<eta> xa =\n       (\\<Squnion>x\\<in>x.\n           (\\<lambda>xa.\n               {(xa, y).\n                (\\<lambda>xa xb.\n                    s2p {(xa, y). s2p (x xa) y}\n                     (xa, xb))\\<inverse>\\<inverse>\n                 xa y} ``\n               \\<eta> xa))\n        xa", "by auto"], ["", "lemma Inf_pres_kop: \"Inf_pres op\\<^sub>K\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf_pres op\\<^sub>K", "unfolding kop_def fun_eq_iff comp_def r2f_def f2r_def converse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa.\n       {(xa, y).\n        (\\<lambda>xa xb.\n            s2p {(xa, y). s2p ((\\<Sqinter> x) xa) y}\n             (xa, xb))\\<inverse>\\<inverse>\n         xa y} ``\n       \\<eta> xa =\n       (\\<Sqinter>x\\<in>x.\n           (\\<lambda>xa.\n               {(xa, y).\n                (\\<lambda>xa xb.\n                    s2p {(xa, y). s2p (x xa) y}\n                     (xa, xb))\\<inverse>\\<inverse>\n                 xa y} ``\n               \\<eta> xa))\n        xa", "by auto"], ["", "end"]]}