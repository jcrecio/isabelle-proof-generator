{"file_name": "/home/qj213/afp-2021-10-22/thys/Transformer_Semantics/Kleisli_Quantale.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transformer_Semantics", "problem_names": ["lemma r2f2r_inv: \"r2fnd \\<circ> f2rnd = id\"", "lemma f2r2f_inv: \"f2rnd \\<circ> r2fnd = id\"", "lemma Abs_comp_hom: \"Abs_nd_fun (f \\<circ>\\<^sub>K g) = Abs_nd_fun f \\<cdot> Abs_nd_fun g\"", "lemma Rep_comp_hom: \"Rep_nd_fun (f \\<cdot> g) = Rep_nd_fun f \\<circ>\\<^sub>K Rep_nd_fun g\"", "lemma fun_star_unfoldl_eq: \"(1::'a nd_fun) \\<squnion> f \\<cdot> qstar f = qstar f\"", "lemma fun_star_unfoldl: \"(1::'a nd_fun) \\<squnion> f \\<cdot> qstar f \\<le> qstar f\"", "lemma fun_star_unfoldr_eq: \"(1::'a nd_fun) \\<squnion> (qstar f) \\<cdot> f = qstar f\"", "lemma fun_star_unfoldr: \"(1::'a nd_fun) \\<squnion> qstar f \\<cdot> f \\<le> qstar f\"", "lemma fun_star_inductl: \"(h::'a nd_fun) \\<squnion> f \\<cdot> g \\<le> g \\<Longrightarrow> qstar f \\<cdot>  h \\<le> g\"", "lemma fun_star_inductr: \"(h::'a nd_fun) \\<squnion> g \\<cdot> f \\<le> g \\<Longrightarrow> h \\<cdot> qstar f \\<le> g\""], "translations": [["", "lemma r2f2r_inv: \"r2fnd \\<circ> f2rnd = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r2fnd \\<circ> f2rnd = id", "by transfer (simp add: fun_eq_iff pointfree_idE)"], ["", "lemma f2r2f_inv: \"f2rnd \\<circ> r2fnd = id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f2rnd \\<circ> r2fnd = id", "by transfer (simp add: fun_eq_iff r2f_def f2r_def Abs_nd_fun_inverse)"], ["", "instantiation nd_fun :: (type) monoid_mult\nbegin"], ["", "lift_definition one_nd_fun :: \"'a nd_fun\" is \"Abs_nd_fun \\<eta>\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition times_nd_fun :: \"'a::type nd_fun \\<Rightarrow> 'a::type nd_fun \\<Rightarrow> 'a::type nd_fun\" is \"\\<lambda>f g. Abs_nd_fun (Rep_nd_fun f \\<circ>\\<^sub>K Rep_nd_fun g)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nd_fun, monoid_mult_class)", "by intro_classes (transfer, simp add: Abs_nd_fun_inverse kcomp_assoc)+"], ["", "end"], ["", "instantiation nd_fun :: (type) order_lean\nbegin"], ["", "lift_definition less_eq_nd_fun :: \"'a nd_fun \\<Rightarrow> 'a nd_fun \\<Rightarrow> bool\" is \"\\<lambda>f g. Rep_nd_fun f \\<le> Rep_nd_fun g\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_nd_fun :: \"'a nd_fun \\<Rightarrow> 'a nd_fun \\<Rightarrow> bool\" is \"\\<lambda>f g. Rep_nd_fun f \\<le> Rep_nd_fun g \\<and> f \\<noteq> g\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nd_fun, order_lean_class)", "apply intro_classes"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "apply (transfer, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "apply transfer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>Rep_nd_fun x \\<le> Rep_nd_fun y;\n        Rep_nd_fun y \\<le> Rep_nd_fun z\\<rbrakk>\n       \\<Longrightarrow> Rep_nd_fun x \\<le> Rep_nd_fun z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "using order.trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (2 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>Rep_nd_fun x \\<le> Rep_nd_fun y;\n        Rep_nd_fun y \\<le> Rep_nd_fun z\\<rbrakk>\n       \\<Longrightarrow> Rep_nd_fun x \\<le> Rep_nd_fun z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y", "by (simp add: Rep_nd_fun_inject less_eq_nd_fun.abs_eq)"], ["", "end"], ["", "instantiation nd_fun :: (type) Sup_lattice\nbegin"], ["", "lift_definition Sup_nd_fun :: \"'a nd_fun set \\<Rightarrow> 'a nd_fun\" is \"Abs_nd_fun \\<circ> Sup \\<circ> \\<P> Rep_nd_fun\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nd_fun, Sup_lattice_class)", "by (intro_classes; transfer, simp_all add: Abs_nd_fun_inverse Sup_upper sup_absorb2 Sup_le_iff)"], ["", "end"], ["", "lemma Abs_comp_hom: \"Abs_nd_fun (f \\<circ>\\<^sub>K g) = Abs_nd_fun f \\<cdot> Abs_nd_fun g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_nd_fun (f \\<circ>\\<^sub>K g) = Abs_nd_fun f \\<cdot> Abs_nd_fun g", "by transfer (simp add: Abs_nd_fun_inverse)"], ["", "lemma Rep_comp_hom: \"Rep_nd_fun (f \\<cdot> g) = Rep_nd_fun f \\<circ>\\<^sub>K Rep_nd_fun g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_nd_fun (f \\<cdot> g) = Rep_nd_fun f \\<circ>\\<^sub>K Rep_nd_fun g", "by (simp add: Abs_nd_fun_inverse times_nd_fun.abs_eq)"], ["", "instance nd_fun :: (type) unital_Sup_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nd_fun, unital_Sup_quantale_class)", "by (intro_classes; transfer, simp_all) (smt Abs_comp_hom Rep_comp_hom Rep_nd_fun_inverse SUP_cong image_image kSup_distr kSup_distl)+"], ["", "text \\<open>Unfortunately, this is not it yet. To benefit from Isabelle's theorems for orderings, lattices, \nKleene algebras and quantales, Isabelle's complete lattices need to be in scope. Somewhat annoyingly, this\nrequires more work...\\<close>"], ["", "instantiation nd_fun :: (type) complete_lattice\nbegin"], ["", "lift_definition Inf_nd_fun :: \"'a nd_fun set \\<Rightarrow> 'a nd_fun\" is \"Abs_nd_fun \\<circ> Inf \\<circ> \\<P> Rep_nd_fun\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition bot_nd_fun :: \"'a::type nd_fun\" is \"Abs_nd_fun (Sup {})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition sup_nd_fun :: \"'a::type nd_fun \\<Rightarrow> 'a::type nd_fun \\<Rightarrow> 'a::type nd_fun\" is \"\\<lambda>f g. Abs_nd_fun (Rep_nd_fun f \\<squnion> Rep_nd_fun g)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition top_nd_fun :: \"'a::type nd_fun\" is \"Abs_nd_fun (Inf {})\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition inf_nd_fun :: \"'a::type nd_fun \\<Rightarrow> 'a::type nd_fun \\<Rightarrow> 'a::type nd_fun\" is \"\\<lambda>f g. Abs_nd_fun (Rep_nd_fun f \\<sqinter> Rep_nd_fun g)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nd_fun, complete_lattice_class)", "apply intro_classes"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "apply transfer"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y.\n       (Rep_nd_fun x \\<le> Rep_nd_fun y \\<and> x \\<noteq> y) =\n       (Rep_nd_fun x \\<le> Rep_nd_fun y \\<and>\n        \\<not> Rep_nd_fun y \\<le> Rep_nd_fun x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "using Rep_nd_fun_inject dual_order.antisym"], ["proof (prove)\nusing this:\n  (Rep_nd_fun ?x = Rep_nd_fun ?y) = (?x = ?y)\n  \\<lbrakk>?b \\<le> ?a; ?a \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?a = ?b\n\ngoal (16 subgoals):\n 1. \\<And>x y.\n       (Rep_nd_fun x \\<le> Rep_nd_fun y \\<and> x \\<noteq> y) =\n       (Rep_nd_fun x \\<le> Rep_nd_fun y \\<and>\n        \\<not> Rep_nd_fun y \\<le> Rep_nd_fun x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 16 subgoals...", "apply blast"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 3. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 4. \\<And>x y. x \\<sqinter> y \\<le> x\n 5. \\<And>x y. x \\<sqinter> y \\<le> y\n 6. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 7. \\<And>x y. x \\<le> x \\<squnion> y\n 8. \\<And>y x. y \\<le> x \\<squnion> y\n 9. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 10. \\<And>x A. s2p A x \\<Longrightarrow> \\<Sqinter> A \\<le> x\nA total of 15 subgoals...", "apply (transfer, simp)"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<sqinter> y \\<le> x\n 4. \\<And>x y. x \\<sqinter> y \\<le> y\n 5. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 6. \\<And>x y. x \\<le> x \\<squnion> y\n 7. \\<And>y x. y \\<le> x \\<squnion> y\n 8. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 9. \\<And>x A. s2p A x \\<Longrightarrow> \\<Sqinter> A \\<le> x\n 10. \\<And>A z.\n        (\\<And>x. s2p A x \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n        z \\<le> \\<Sqinter> A\nA total of 14 subgoals...", "apply (transfer, simp)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<sqinter> y \\<le> x\n 3. \\<And>x y. x \\<sqinter> y \\<le> y\n 4. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>x A. s2p A x \\<Longrightarrow> \\<Sqinter> A \\<le> x\n 9. \\<And>A z.\n       (\\<And>x. s2p A x \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 10. \\<And>x A. s2p A x \\<Longrightarrow> x \\<le> \\<Squnion> A\nA total of 13 subgoals...", "apply (simp add: Abs_nd_fun_inverse)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>x y. x \\<le> x \\<squnion> y\n 5. \\<And>y x. y \\<le> x \\<squnion> y\n 6. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 7. \\<And>x A. s2p A x \\<Longrightarrow> \\<Sqinter> A \\<le> x\n 8. \\<And>A z.\n       (\\<And>x. s2p A x \\<Longrightarrow> z \\<le> x) \\<Longrightarrow>\n       z \\<le> \\<Sqinter> A\n 9. \\<And>x A. s2p A x \\<Longrightarrow> x \\<le> \\<Squnion> A\n 10. \\<And>A z.\n        (\\<And>x. s2p A x \\<Longrightarrow> x \\<le> z) \\<Longrightarrow>\n        \\<Squnion> A \\<le> z\nA total of 12 subgoals...", "by (transfer; simp_all add: Abs_nd_fun_inverse Sup_le_iff SUP_upper2 le_INF_iff Inf_lower)+"], ["", "end"], ["", "instance nd_fun :: (type) unital_quantale"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a nd_fun, unital_quantale_class)", "apply intro_classes"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X y. \\<Squnion> X \\<cdot> y = (\\<Squnion>x\\<in>X. x \\<cdot> y)\n 2. \\<And>x Y. x \\<cdot> \\<Squnion> Y = \\<Squnion> \\<P> ((\\<cdot>) x) Y", "using supq.Sup_distr"], ["proof (prove)\nusing this:\n  \\<Squnion> ?X \\<cdot> ?y = (\\<Squnion>x\\<in>?X. x \\<cdot> ?y)\n\ngoal (2 subgoals):\n 1. \\<And>X y. \\<Squnion> X \\<cdot> y = (\\<Squnion>x\\<in>X. x \\<cdot> y)\n 2. \\<And>x Y. x \\<cdot> \\<Squnion> Y = \\<Squnion> \\<P> ((\\<cdot>) x) Y", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Y. x \\<cdot> \\<Squnion> Y = \\<Squnion> \\<P> ((\\<cdot>) x) Y", "by (simp add: supq.Sup_distl)"], ["", "text \\<open>Now, theorems for the Kleene star, which come from quantales, are finally in scope.\\<close>"], ["", "lemma fun_star_unfoldl_eq: \"(1::'a nd_fun) \\<squnion> f \\<cdot> qstar f = qstar f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<squnion> f \\<cdot> qstar f = qstar f", "by (simp add: qstar_comm)"], ["", "lemma fun_star_unfoldl: \"(1::'a nd_fun) \\<squnion> f \\<cdot> qstar f \\<le> qstar f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<squnion> f \\<cdot> qstar f \\<le> qstar f", "using qstar_unfoldl"], ["proof (prove)\nusing this:\n  (1::?'a) \\<squnion> ?x \\<cdot> qstar ?x \\<le> qstar ?x\n\ngoal (1 subgoal):\n 1. 1 \\<squnion> f \\<cdot> qstar f \\<le> qstar f", "by blast"], ["", "lemma fun_star_unfoldr_eq: \"(1::'a nd_fun) \\<squnion> (qstar f) \\<cdot> f = qstar f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<squnion> qstar f \\<cdot> f = qstar f", "by simp"], ["", "lemma fun_star_unfoldr: \"(1::'a nd_fun) \\<squnion> qstar f \\<cdot> f \\<le> qstar f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<squnion> qstar f \\<cdot> f \\<le> qstar f", "by (simp add: fun_star_unfoldr_eq)"], ["", "lemma fun_star_inductl: \"(h::'a nd_fun) \\<squnion> f \\<cdot> g \\<le> g \\<Longrightarrow> qstar f \\<cdot>  h \\<le> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<squnion> f \\<cdot> g \\<le> g \\<Longrightarrow>\n    qstar f \\<cdot> h \\<le> g", "using qstar_inductl"], ["proof (prove)\nusing this:\n  ?z \\<squnion> ?x \\<cdot> ?y \\<le> ?y \\<Longrightarrow>\n  qstar ?x \\<cdot> ?z \\<le> ?y\n\ngoal (1 subgoal):\n 1. h \\<squnion> f \\<cdot> g \\<le> g \\<Longrightarrow>\n    qstar f \\<cdot> h \\<le> g", "by blast"], ["", "lemma fun_star_inductr: \"(h::'a nd_fun) \\<squnion> g \\<cdot> f \\<le> g \\<Longrightarrow> h \\<cdot> qstar f \\<le> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<squnion> g \\<cdot> f \\<le> g \\<Longrightarrow>\n    h \\<cdot> qstar f \\<le> g", "by (simp add: qstar_inductr)"], ["", "end"]]}