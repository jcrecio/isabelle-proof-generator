{"file_name": "/home/qj213/afp-2021-10-22/thys/Transformer_Semantics/Isotone_Transformers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Transformer_Semantics", "problem_names": ["lemma iso_id: \"mono id\"", "lemma iso_botf: \"mono \\<bottom>\"", "lemma iso_topf: \"mono \\<top>\"", "lemma iso_fcomp: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<circ> g)\"", "lemma iso_fSup: \n  fixes F :: \"('a::order \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"(\\<forall>f \\<in> F. mono f) \\<Longrightarrow> mono (\\<Squnion>F)\"", "lemma iso_fsup: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<squnion> g)\"", "lemma iso_fInf: \n  fixes F :: \"('a::order \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"\\<forall>f \\<in> F. mono f \\<Longrightarrow> mono (\\<Sqinter>F)\"", "lemma iso_finf: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<sqinter> g)\"", "lemma fun_isol: \"mono f \\<Longrightarrow> g \\<le> h \\<Longrightarrow> (f \\<circ> g) \\<le> (f \\<circ> h)\"", "lemma fun_isor: \"mono f \\<Longrightarrow> g \\<le> h \\<Longrightarrow> (g \\<circ> f) \\<le> (h \\<circ> f)\"", "lemma H_iso_cond1: \"(x::'a::preorder) \\<le> y \\<Longrightarrow> y \\<le> f z \\<Longrightarrow> x \\<le> f z\"", "lemma H_iso_cond2: \"mono f \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> x \\<le> f z\"", "lemma H_iso_seq: \"mono f \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> y \\<le> g z \\<Longrightarrow> x \\<le> f (g z)\"", "lemma H_iso_seq_var: \"mono f \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> y \\<le> g z \\<Longrightarrow> x \\<le> (f \\<circ> g) z\"", "lemma H_iso_fInf: \n  fixes F :: \"('a \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"(\\<forall>f \\<in> F. x \\<le> f y) \\<Longrightarrow> x \\<le> (\\<Sqinter>F) y\"", "lemma H_iso_fSup: \n  fixes F :: \"('a \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"F \\<noteq> {} \\<Longrightarrow> (\\<forall>f \\<in> F. x \\<le> f y) \\<Longrightarrow> x \\<le> (\\<Squnion>F) y\"", "lemma fiter_fun_exp: \"fiter_fun f g h = f \\<sqinter> (g \\<circ> h)\"", "lemma fiter_qiter1: \"Abs_iso (fiter_fun (Rep_iso f) (Rep_iso g) (Rep_iso h)) = qiter_fun f g h\"", "lemma fiter_qiter4: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono h \\<Longrightarrow> Rep_iso (qiter_fun (Abs_iso f) (Abs_iso g) (Abs_iso h)) = fiter_fun f g h\"", "lemma iso_fiter_fun: \"mono f \\<Longrightarrow> mono (fiter_fun f)\"", "lemma iso_fiter_fun2: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (fiter_fun f g)\"", "lemma fiter_unfoldl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> f \\<sqinter> (g \\<circ> fiter f g) = fiter f g\"", "lemma fiter_inductl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> h \\<le> f \\<sqinter> (g \\<circ> h) \\<Longrightarrow> h \\<le> fiter f g\"", "lemma fiter_fusion: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes \"mono f\" \n  and \"mono g\"\nshows \"fiter f g = fiter_id g \\<circ> f\"", "lemma fpower_supdistl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f \\<circ> fstar g \\<le> (\\<Sqinter>i. f \\<circ> fpower g i)\"", "lemma fpower_distr: \"fstar f \\<circ> g = (\\<Sqinter>i. fpower f i \\<circ> g)\"", "lemma fpower_Sup_subcomm: \"mono f \\<Longrightarrow> f \\<circ> fstar f \\<le> fstar f \\<circ> f\"", "lemma fpower_inductl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> h \\<le> g \\<sqinter> (f \\<circ> h) \\<Longrightarrow> h \\<le> fpower f i \\<circ> g\"", "lemma fpower_inductr: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> h \\<le> g \\<sqinter> (h \\<circ> f) \\<Longrightarrow> h \\<le> g \\<circ> fpower f i\"", "lemma fiter_fstar: \"mono f \\<Longrightarrow> fiter_id f \\<le> fstar f\"", "lemma iso_fiter_ext: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> mono (\\<lambda>x. y \\<sqinter> f x)\"", "lemma fstar_pred_char: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)\"", "lemma H_weak_loop: \"mono f \\<Longrightarrow> x \\<le> f x \\<Longrightarrow> x \\<le> fiter_id f x\"", "lemma iso_fiter: \"mono f \\<Longrightarrow> mono (fiter_id f)\"", "lemma bqtran_iso: \"mono \\<lfloor>x\\<rfloor>\"", "lemma cond_iso: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (\\<lfloor>x\\<rfloor> \\<circ> f \\<sqinter> \\<lfloor>y\\<rfloor> \\<circ> g)\"", "lemma loop_iso: \"mono f \\<Longrightarrow> mono (fiter_id (\\<lfloor>x\\<rfloor> \\<circ> f) \\<circ> \\<lfloor>y\\<rfloor>)\"", "lemma H_iso_cond: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow>  p \\<sqinter> x \\<le> f y \\<Longrightarrow> q \\<sqinter> x \\<le> g y \\<Longrightarrow> x \\<le> (inf (\\<lfloor>p\\<rfloor> \\<circ> f) (\\<lfloor>q\\<rfloor> \\<circ> g)) y\"", "lemma H_iso_loop: \"mono f \\<Longrightarrow> p \\<sqinter> x \\<le> f x \\<Longrightarrow> x \\<le> ((fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)) \\<circ> \\<lfloor>q\\<rfloor>) (x \\<sqinter> q)\"", "lemma btran_spec: \"x \\<le> \\<lfloor>y\\<rfloor> (x \\<sqinter> y)\"", "lemma btran_neg_spec: \"x \\<le> \\<lfloor>-y\\<rfloor> (x - y)\"", "lemma Ri_least: \"mono f \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> Ri x y z \\<le> f z\"", "lemma Ri_spec: \"x \\<le> Ri x y y\"", "lemma Ri_spec_var: \"(\\<forall>z. Ri x y z \\<le> f z) \\<Longrightarrow> x \\<le> f y\"", "lemma Ri_prop: \"mono f \\<Longrightarrow> x \\<le> f y \\<longleftrightarrow> (\\<forall>z. Ri x y z \\<le> f z)\"", "lemma iso_Ri: \"mono (Ri x y)\"", "lemma Ri_weaken: \"x \\<le> x' \\<Longrightarrow>  y' \\<le> y \\<Longrightarrow> Ri x y z \\<le> Ri x' y' z\"", "lemma Ri_seq: \"Ri x y z \\<le> Ri x w (Ri w y z)\"", "lemma Ri_seq_var: \"Ri x y z \\<le> ((Ri x w) \\<circ> (Ri w y)) z\"", "lemma Ri_Inf: \" Ri (\\<Sqinter> X) y z \\<le> \\<Sqinter>{Ri x y z |x. x \\<in> X}\"", "lemma Ri_weak_iter: \"Ri x x y  \\<le> fiter_id (Ri x x) y\"", "lemma Ri_cond: \"Ri x y z \\<le> (inf (\\<lfloor>p\\<rfloor> \\<circ> (Ri (p \\<sqinter> x) y)) ((\\<lfloor>q\\<rfloor> \\<circ> (Ri (q \\<sqinter> x) y)))) z\"", "lemma Ri_loop: \"Ri x (q \\<sqinter> x) y \\<le> ((fiter_id (\\<lfloor>p\\<rfloor> \\<circ> (Ri (x \\<sqinter> p) x))) \\<circ> \\<lfloor>q\\<rfloor>) (q \\<sqinter> y)\""], "translations": [["", "lemma iso_id: \"mono id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono id", "by (simp add: monoI)"], ["", "lemma iso_botf: \"mono \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<bottom>", "by (simp add: monoI)"], ["", "lemma iso_topf: \"mono \\<top>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<top>", "by (simp add: monoI)"], ["", "text \\<open>... and that compositions, Infs and Sups preserve isotonicity.\\<close>"], ["", "lemma iso_fcomp: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono (f \\<circ> g)", "by (simp add: mono_def)"], ["", "lemma iso_fSup: \n  fixes F :: \"('a::order \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"(\\<forall>f \\<in> F. mono f) \\<Longrightarrow> mono (\\<Squnion>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. mono f \\<Longrightarrow> mono (\\<Squnion> F)", "by (simp add: mono_def SUP_subset_mono)"], ["", "lemma iso_fsup: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<squnion> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono (f \\<squnion> g)", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     \\<forall>x y. x \\<le> y \\<longrightarrow> g x \\<le> g y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x y.\n                         x \\<le> y \\<longrightarrow>\n                         (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "using sup_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<squnion> ?b \\<le> ?c \\<squnion> ?d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     \\<forall>x y. x \\<le> y \\<longrightarrow> g x \\<le> g y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x y.\n                         x \\<le> y \\<longrightarrow>\n                         (f \\<squnion> g) x \\<le> (f \\<squnion> g) y", "by fastforce"], ["", "lemma iso_fInf: \n  fixes F :: \"('a::order \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"\\<forall>f \\<in> F. mono f \\<Longrightarrow> mono (\\<Sqinter>F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. mono f \\<Longrightarrow> mono (\\<Sqinter> F)", "by (simp add: mono_def, safe, rule Inf_greatest, auto simp: INF_lower2)"], ["", "lemma iso_finf: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (f \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono (f \\<sqinter> g)", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     \\<forall>x y. x \\<le> y \\<longrightarrow> g x \\<le> g y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x y.\n                         x \\<le> y \\<longrightarrow>\n                         (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "using inf_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<le> ?c; ?b \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c \\<sqinter> ?d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x y. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     \\<forall>x y. x \\<le> y \\<longrightarrow> g x \\<le> g y\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x y.\n                         x \\<le> y \\<longrightarrow>\n                         (f \\<sqinter> g) x \\<le> (f \\<sqinter> g) y", "by fastforce"], ["", "lemma fun_isol: \"mono f \\<Longrightarrow> g \\<le> h \\<Longrightarrow> (f \\<circ> g) \\<le> (f \\<circ> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; g \\<le> h\\<rbrakk>\n    \\<Longrightarrow> f \\<circ> g \\<le> f \\<circ> h", "by (simp add: le_fun_def monoD)"], ["", "lemma fun_isor: \"mono f \\<Longrightarrow> g \\<le> h \\<Longrightarrow> (g \\<circ> f) \\<le> (h \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; g \\<le> h\\<rbrakk>\n    \\<Longrightarrow> g \\<circ> f \\<le> h \\<circ> f", "by (simp add: le_fun_def monoD)"], ["", "subsection \\<open>Pre-Quantale of Isotone Transformers\\<close>"], ["", "text \\<open>It is well known, and has been formalised within Isabelle, that functions into complete lattices form complete lattices.\nIn the following proof, this needs to be replayed because isotone functions are considered and closure conditions\nneed to be respected.\n\nFunctions must now be restricted to a single type.\\<close>"], ["", "instantiation iso :: (complete_lattice) unital_pre_quantale \nbegin"], ["", "lift_definition one_iso :: \"'a::complete_lattice iso\" is id"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono id", "by (simp add: iso_id)"], ["", "lift_definition times_iso :: \"'a::complete_lattice iso \\<Rightarrow> 'a iso \\<Rightarrow> 'a iso\" is \"(\\<circ>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fun1 fun2.\n       \\<lbrakk>mono fun1; mono fun2\\<rbrakk>\n       \\<Longrightarrow> mono (fun1 \\<circ> fun2)", "by (simp add: iso_fcomp)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a iso, unital_pre_quantale_class)", "by (intro_classes; transfer, simp_all add: comp_assoc fInf_distr_var fInf_subdistl_var)"], ["", "end"], ["", "text \\<open>I have previously worked in (pre)quantales with many types or quantaloids. Formally, these are categories  \nenriched over the category of Sup-lattices (complete lattices with Sup-preserving functions). An advantage \nof the single-typed approach is that the definition of the Kleene star for (pre)quantales is available in this setting.\\<close>"], ["", "subsection \\<open>Propositional Hoare Logic for Transformers without Star\\<close>"], ["", "text \\<open>The rules of an abstract Propositional Hoare logic are derivable.\\<close>"], ["", "lemma H_iso_cond1: \"(x::'a::preorder) \\<le> y \\<Longrightarrow> y \\<le> f z \\<Longrightarrow> x \\<le> f z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> f z\\<rbrakk> \\<Longrightarrow> x \\<le> f z", "using order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; y \\<le> f z\\<rbrakk> \\<Longrightarrow> x \\<le> f z", "by auto"], ["", "lemma H_iso_cond2: \"mono f \\<Longrightarrow> y \\<le> z \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> x \\<le> f z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; y \\<le> z; x \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> f z", "by (meson mono_def order_subst1)"], ["", "lemma H_iso_seq: \"mono f \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> y \\<le> g z \\<Longrightarrow> x \\<le> f (g z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> f y; y \\<le> g z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> f (g z)", "using H_iso_cond2"], ["proof (prove)\nusing this:\n  \\<lbrakk>mono ?f; ?y \\<le> ?z; ?x \\<le> ?f ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?f ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> f y; y \\<le> g z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> f (g z)", "by force"], ["", "lemma H_iso_seq_var: \"mono f \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> y \\<le> g z \\<Longrightarrow> x \\<le> (f \\<circ> g) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> f y; y \\<le> g z\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (f \\<circ> g) z", "by (simp add: H_iso_cond2)"], ["", "lemma H_iso_fInf: \n  fixes F :: \"('a \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"(\\<forall>f \\<in> F. x \\<le> f y) \\<Longrightarrow> x \\<le> (\\<Sqinter>F) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>F. x \\<le> f y \\<Longrightarrow> x \\<le> (\\<Sqinter> F) y", "by (simp add: le_INF_iff)"], ["", "lemma H_iso_fSup: \n  fixes F :: \"('a \\<Rightarrow> 'b::complete_lattice) set\"\n  shows \"F \\<noteq> {} \\<Longrightarrow> (\\<forall>f \\<in> F. x \\<le> f y) \\<Longrightarrow> x \\<le> (\\<Squnion>F) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<noteq> {}; \\<forall>f\\<in>F. x \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (\\<Squnion> F) y", "using SUP_upper2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<in> ?A; ?u \\<le> ?f ?i\\<rbrakk>\n  \\<Longrightarrow> ?u \\<le> \\<Squnion> (?f ` ?A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<noteq> {}; \\<forall>f\\<in>F. x \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (\\<Squnion> F) y", "by fastforce"], ["", "text \\<open>These rules are suitable for weakest liberal preconditions. Order-dual ones, in which the order relation is swapped,\nare consistent with other kinds of transformers. In the context of dynamic logic, the first set corresponds to box modalities \nwhereas the second one would correspond to diamonds.\\<close>"], ["", "subsection \\<open>Kleene Star of Isotone Transformers\\<close>"], ["", "text \\<open>The Hoare rule for loops requires some preparation. On the way I verify some Kleene-algebra-style axioms for iteration.\\<close>"], ["", "text \\<open>First I show that functions form monoids.\\<close>"], ["", "interpretation fun_mon: monoid_mult \"id::'a \\<Rightarrow> 'a\" \"(\\<circ>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_mult id (\\<circ>)", "by unfold_locales auto"], ["", "definition fiter_fun :: \"('a \\<Rightarrow> 'c::semilattice_inf) \\<Rightarrow> ('b \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'c\" where \n  \"fiter_fun f g = (\\<sqinter>) f \\<circ> (\\<circ>) g\""], ["", "definition fiter :: \"('a \\<Rightarrow> 'b::complete_lattice) \\<Rightarrow> ('b \\<Rightarrow> 'b) \\<Rightarrow> 'a \\<Rightarrow> 'b\" where \n  \"fiter f g = gfp (fiter_fun f g)\""], ["", "definition fiter_id :: \"('a::complete_lattice \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a\" where \n  \"fiter_id = fiter id\""], ["", "abbreviation \"fpower \\<equiv> fun_mon.power\""], ["", "definition fstar :: \"('a::complete_lattice \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n  \"fstar f = (\\<Sqinter>i. fpower f i)\""], ["", "text \\<open>The types in the following statements are often more general than those in the prequantale setting. I develop them generally, \ninstead of inheriting (most of them) with more restrictive types from the quantale components.\\<close>"], ["", "lemma fiter_fun_exp: \"fiter_fun f g h = f \\<sqinter> (g \\<circ> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fiter_fun f g h = f \\<sqinter> (g \\<circ> h)", "unfolding fiter_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sqinter>) f \\<circ> (\\<circ>) g) h = f \\<sqinter> (g \\<circ> h)", "by simp"], ["", "text \\<open>The two lemmas that follow set up the relationship between the star for transformers and those in quantales.\\<close>"], ["", "lemma fiter_qiter1: \"Abs_iso (fiter_fun (Rep_iso f) (Rep_iso g) (Rep_iso h)) = qiter_fun f g h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_iso (fiter_fun (Rep_iso f) (Rep_iso g) (Rep_iso h)) =\n    qiter_fun f g h", "unfolding fiter_fun_def qiter_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_iso\n     (((\\<sqinter>) (Rep_iso f) \\<circ> (\\<circ>) (Rep_iso g))\n       (Rep_iso h)) =\n    ((\\<squnion>) f \\<circ> (\\<cdot>) g) h", "by (metis Rep_iso_inverse comp_def sup_iso.rep_eq times_iso.rep_eq)"], ["", "lemma fiter_qiter4: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono h \\<Longrightarrow> Rep_iso (qiter_fun (Abs_iso f) (Abs_iso g) (Abs_iso h)) = fiter_fun f g h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g; mono h\\<rbrakk>\n    \\<Longrightarrow> Rep_iso\n                       (qiter_fun (Abs_iso f) (Abs_iso g) (Abs_iso h)) =\n                      fiter_fun f g h", "by (metis Abs_iso_inverse fiter_fun_exp fiter_qiter1 iso_fcomp iso_finf mem_Collect_eq)"], ["", "text \\<open>The type coercions are needed to deal with isotone (monotone) functions, which had to be redefined to one single type above,\nin order to cooperate with the type classes for quantales. Having to deal with these coercions would be another drawback of using the \nquantale-based setting for the development.\\<close>"], ["", "lemma iso_fiter_fun: \"mono f \\<Longrightarrow> mono (fiter_fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (fiter_fun f)", "by (simp add: fiter_fun_exp le_fun_def mono_def inf.coboundedI2)"], ["", "lemma iso_fiter_fun2: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (fiter_fun f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk> \\<Longrightarrow> mono (fiter_fun f g)", "by (simp add: fiter_fun_exp le_fun_def mono_def inf.coboundedI2)"], ["", "lemma fiter_unfoldl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> f \\<sqinter> (g \\<circ> fiter f g) = fiter f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk>\n    \\<Longrightarrow> f \\<sqinter> (g \\<circ> fiter f g) = fiter f g", "by (metis fiter_def fiter_fun_exp gfp_unfold iso_fiter_fun2)"], ["", "lemma fiter_inductl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> h \\<le> f \\<sqinter> (g \\<circ> h) \\<Longrightarrow> h \\<le> fiter f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g; h \\<le> f \\<sqinter> (g \\<circ> h)\\<rbrakk>\n    \\<Longrightarrow> h \\<le> fiter f g", "by (simp add: fiter_def fiter_fun_def gfp_upperbound)"], ["", "lemma fiter_fusion: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  assumes \"mono f\" \n  and \"mono g\"\nshows \"fiter f g = fiter_id g \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "have h1: \"mono (fiter_fun id g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (fiter_fun id g)", "by (simp add: assms(2) iso_fiter_fun2 iso_id)"], ["proof (state)\nthis:\n  mono (fiter_fun id g)\n\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "have h2: \"mono (fiter_fun f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (fiter_fun f g)", "by (simp add: assms(1) assms(2) iso_fiter_fun2)"], ["proof (state)\nthis:\n  mono (fiter_fun f g)\n\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "have h3: \"Inf \\<circ> image (\\<lambda>x. x \\<circ> f) = (\\<lambda>x. x \\<circ> f) \\<circ> Inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inf \\<circ> (`) (\\<lambda>x. x \\<circ> f) =\n    (\\<lambda>x. x \\<circ> f) \\<circ> Inf", "by (simp add: fun_eq_iff image_comp)"], ["proof (state)\nthis:\n  Inf \\<circ> (`) (\\<lambda>x. x \\<circ> f) =\n  (\\<lambda>x. x \\<circ> f) \\<circ> Inf\n\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "have \"(\\<lambda>x. x \\<circ> f) \\<circ> (fiter_fun id g) = (fiter_fun f g) \\<circ> (\\<lambda>x. x \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x \\<circ> f) \\<circ> fiter_fun id g =\n    fiter_fun f g \\<circ> (\\<lambda>x. x \\<circ> f)", "by (simp add: fun_eq_iff fiter_fun_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. x \\<circ> f) \\<circ> fiter_fun id g =\n  fiter_fun f g \\<circ> (\\<lambda>x. x \\<circ> f)\n\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x \\<circ> f) \\<circ> fiter_fun id g =\n  fiter_fun f g \\<circ> (\\<lambda>x. x \\<circ> f)\n\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "using gfp_fusion_inf_pres"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x \\<circ> f) \\<circ> fiter_fun id g =\n  fiter_fun f g \\<circ> (\\<lambda>x. x \\<circ> f)\n  \\<lbrakk>Inf_pres ?h; mono ?f; mono ?g;\n   ?h \\<circ> ?f = ?g \\<circ> ?h\\<rbrakk>\n  \\<Longrightarrow> ?h (gfp ?f) = gfp ?g\n\ngoal (1 subgoal):\n 1. fiter f g = fiter_id g \\<circ> f", "by (metis fiter_def fiter_id_def h1 h2 h3)"], ["proof (state)\nthis:\n  fiter f g = fiter_id g \\<circ> f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fpower_supdistl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> f \\<circ> fstar g \\<le> (\\<Sqinter>i. f \\<circ> fpower g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    f \\<circ> fstar g \\<le> (\\<Sqinter>i. f \\<circ> fpower g i)", "by (simp add: Isotone_Transformers.fun_isol fstar_def mono_INF mono_def)"], ["", "lemma fpower_distr: \"fstar f \\<circ> g = (\\<Sqinter>i. fpower f i \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fstar f \\<circ> g = (\\<Sqinter>i. fpower f i \\<circ> g)", "by (auto simp: fstar_def image_comp)"], ["", "lemma fpower_Sup_subcomm: \"mono f \\<Longrightarrow> f \\<circ> fstar f \\<le> fstar f \\<circ> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> f \\<circ> fstar f \\<le> fstar f \\<circ> f", "by (metis (mono_tags, lifting) fun_mon.power_commutes le_INF_iff fpower_distr fpower_supdistl)"], ["", "lemma fpower_inductl: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> h \\<le> g \\<sqinter> (f \\<circ> h) \\<Longrightarrow> h \\<le> fpower f i \\<circ> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g; h \\<le> g \\<sqinter> (f \\<circ> h)\\<rbrakk>\n    \\<Longrightarrow> h \\<le> fpower f i \\<circ> g", "apply (induct i, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>h \\<le> fpower f i \\<circ> g; mono f; mono g;\n        h \\<le> g \\<and> h \\<le> f \\<circ> h\\<rbrakk>\n       \\<Longrightarrow> h \\<le> f \\<circ> fpower f i \\<circ> g", "by (metis (no_types, hide_lams) fun.map_comp fun_isol order_trans)"], ["", "lemma fpower_inductr: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> h \\<le> g \\<sqinter> (h \\<circ> f) \\<Longrightarrow> h \\<le> g \\<circ> fpower f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g; h \\<le> g \\<sqinter> (h \\<circ> f)\\<rbrakk>\n    \\<Longrightarrow> h \\<le> g \\<circ> fpower f i", "by (induct i, simp_all add: le_fun_def, metis comp_eq_elim fun_mon.power_commutes order_trans)"], ["", "lemma fiter_fstar: \"mono f \\<Longrightarrow> fiter_id f \\<le> fstar f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> fiter_id f \\<le> fstar f", "by (metis (no_types, lifting) fiter_id_def fiter_unfoldl fpower_inductl fstar_def iso_id le_INF_iff o_id order_refl)"], ["", "lemma iso_fiter_ext: \n  fixes f :: \"'a::order \\<Rightarrow> 'b::complete_lattice\"\n  shows \"mono f \\<Longrightarrow> mono (\\<lambda>x. y \\<sqinter> f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (\\<lambda>x. y \\<sqinter> f x)", "by (simp add: le_infI2 mono_def)"], ["", "lemma fstar_pred_char: \n  fixes f :: \"'a::complete_lattice \\<Rightarrow> 'a\"\n  shows \"mono f \\<Longrightarrow> fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)", "assume hyp: \"mono f\""], ["proof (state)\nthis:\n  mono f\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)", "have \"\\<forall>g. (id \\<sqinter> (f \\<circ> g)) x = x \\<sqinter> f (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g. (id \\<sqinter> (f \\<circ> g)) x = x \\<sqinter> f (g x)", "by simp"], ["proof (state)\nthis:\n  \\<forall>g. (id \\<sqinter> (f \\<circ> g)) x = x \\<sqinter> f (g x)\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)", "hence \"\\<forall>g. fiter_fun id f g x = (\\<lambda>y. x \\<sqinter> f y) (g x)\""], ["proof (prove)\nusing this:\n  \\<forall>g. (id \\<sqinter> (f \\<circ> g)) x = x \\<sqinter> f (g x)\n\ngoal (1 subgoal):\n 1. \\<forall>g. fiter_fun id f g x = x \\<sqinter> f (g x)", "unfolding fiter_fun_def"], ["proof (prove)\nusing this:\n  \\<forall>g. (id \\<sqinter> (f \\<circ> g)) x = x \\<sqinter> f (g x)\n\ngoal (1 subgoal):\n 1. \\<forall>g.\n       ((\\<sqinter>) id \\<circ> (\\<circ>) f) g x = x \\<sqinter> f (g x)", "by simp"], ["proof (state)\nthis:\n  \\<forall>g. fiter_fun id f g x = x \\<sqinter> f (g x)\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>g. fiter_fun id f g x = x \\<sqinter> f (g x)\n\ngoal (1 subgoal):\n 1. fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)", "by (simp add: fiter_id_def fiter_def gfp_fusion_var hyp iso_fiter_fun2 iso_id iso_fiter_ext)"], ["proof (state)\nthis:\n  fiter_id f x = gfp (\\<lambda>y. x \\<sqinter> f y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Propositional Hoare Logic Completed\\<close>"], ["", "lemma H_weak_loop: \"mono f \\<Longrightarrow> x \\<le> f x \\<Longrightarrow> x \\<le> fiter_id f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> fiter_id f x", "by (force simp: fstar_pred_char gfp_def intro: Sup_upper)"], ["", "lemma iso_fiter: \"mono f \\<Longrightarrow> mono (fiter_id f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow> mono (fiter_id f)", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<le> y \\<longrightarrow> f x \\<le> f y \\<Longrightarrow>\n    \\<forall>x y.\n       x \\<le> y \\<longrightarrow> fiter_id f x \\<le> fiter_id f y", "by (subst fstar_pred_char, simp add: mono_def)+ (auto intro: gfp_mono inf_mono)"], ["", "text \\<open>As already mentioned, a dual Hoare logic can be built for the dual lattice. In this case, weak iteration is defined with respect to Sup.\\<close>"], ["", "text \\<open>The following standard construction lifts elements of (meet semi)lattices to transformers.\nI allow a more general type.\\<close>"], ["", "definition fqtran :: \"'a::inf \\<Rightarrow> 'a \\<Rightarrow> 'a\" where\n  \"fqtran x \\<equiv> \\<lambda>y. x \\<sqinter> y\""], ["", "text \\<open>The following standard construction lifts elements of boolean algebras to transformers.\\<close>"], ["", "definition bqtran :: \"'a::boolean_algebra \\<Rightarrow> 'a \\<Rightarrow> 'a\" (\"\\<lfloor>_\\<rfloor>\") where\n  \"\\<lfloor>x\\<rfloor> y = -x \\<squnion> y\""], ["", "text \\<open>The conditional and while rule of Hoare logic are now derivable.\\<close>"], ["", "lemma bqtran_iso: \"mono \\<lfloor>x\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono \\<lfloor>x\\<rfloor>", "by (metis bqtran_def monoI order_refl sup.mono)"], ["", "lemma cond_iso: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow> mono (\\<lfloor>x\\<rfloor> \\<circ> f \\<sqinter> \\<lfloor>y\\<rfloor> \\<circ> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g\\<rbrakk>\n    \\<Longrightarrow> mono\n                       (\\<lfloor>x\\<rfloor> \\<circ>\n                        f \\<sqinter> \\<lfloor>y\\<rfloor> \\<circ>\n                        g)", "by (simp add: bqtran_iso iso_fcomp iso_finf)"], ["", "lemma loop_iso: \"mono f \\<Longrightarrow> mono (fiter_id (\\<lfloor>x\\<rfloor> \\<circ> f) \\<circ> \\<lfloor>y\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    mono\n     (fiter_id (\\<lfloor>x\\<rfloor> \\<circ> f) \\<circ> \\<lfloor>y\\<rfloor>)", "by (simp add: bqtran_iso iso_fcomp iso_fiter)"], ["", "lemma H_iso_cond: \"mono f \\<Longrightarrow> mono g \\<Longrightarrow>  p \\<sqinter> x \\<le> f y \\<Longrightarrow> q \\<sqinter> x \\<le> g y \\<Longrightarrow> x \\<le> (inf (\\<lfloor>p\\<rfloor> \\<circ> f) (\\<lfloor>q\\<rfloor> \\<circ> g)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; mono g; p \\<sqinter> x \\<le> f y;\n     q \\<sqinter> x \\<le> g y\\<rbrakk>\n    \\<Longrightarrow> x \\<le> ((\\<lfloor>p\\<rfloor> \\<circ> f) \\<sqinter>\n                               (\\<lfloor>q\\<rfloor> \\<circ> g))\n                               y", "by (metis (full_types) bqtran_def comp_apply inf_apply inf_commute le_inf_iff shunt1)"], ["", "lemma H_iso_loop: \"mono f \\<Longrightarrow> p \\<sqinter> x \\<le> f x \\<Longrightarrow> x \\<le> ((fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)) \\<circ> \\<lfloor>q\\<rfloor>) (x \\<sqinter> q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "assume a: \"mono f\"\nand \"p \\<sqinter> x \\<le> f x\""], ["proof (state)\nthis:\n  mono f\n  p \\<sqinter> x \\<le> f x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "hence \"x \\<le> (\\<lfloor>p\\<rfloor> \\<circ> f) x\""], ["proof (prove)\nusing this:\n  mono f\n  p \\<sqinter> x \\<le> f x\n\ngoal (1 subgoal):\n 1. x \\<le> (\\<lfloor>p\\<rfloor> \\<circ> f) x", "using H_iso_cond"], ["proof (prove)\nusing this:\n  mono f\n  p \\<sqinter> x \\<le> f x\n  \\<lbrakk>mono ?f; mono ?g; ?p \\<sqinter> ?x \\<le> ?f ?y;\n   ?q \\<sqinter> ?x \\<le> ?g ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ((\\<lfloor>?p\\<rfloor> \\<circ> ?f) \\<sqinter>\n                              (\\<lfloor>?q\\<rfloor> \\<circ> ?g))\n                              ?y\n\ngoal (1 subgoal):\n 1. x \\<le> (\\<lfloor>p\\<rfloor> \\<circ> f) x", "by fastforce"], ["proof (state)\nthis:\n  x \\<le> (\\<lfloor>p\\<rfloor> \\<circ> f) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "hence \"x \\<le> (fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)) x\""], ["proof (prove)\nusing this:\n  x \\<le> (\\<lfloor>p\\<rfloor> \\<circ> f) x\n\ngoal (1 subgoal):\n 1. x \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) x", "by (simp add: H_weak_loop a bqtran_iso iso_fcomp)"], ["proof (state)\nthis:\n  x \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "also"], ["proof (state)\nthis:\n  x \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "have \"... \\<le> (fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)) (-q \\<squnion> (x \\<sqinter> q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) x\n    \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)\n           (- q \\<squnion> x \\<sqinter> q)", "by (meson a bqtran_iso dual_order.refl iso_fcomp iso_fiter monoD shunt1)"], ["proof (state)\nthis:\n  fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) x\n  \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)\n         (- q \\<squnion> x \\<sqinter> q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; p \\<sqinter> x \\<le> f x\\<rbrakk>\n    \\<Longrightarrow> x \\<le> (fiter_id\n                                (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n                               \\<lfloor>q\\<rfloor>)\n                               (x \\<sqinter> q)", "finally"], ["proof (chain)\npicking this:\n  x \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)\n           (- q \\<squnion> x \\<sqinter> q)", "show \"x \\<le> ((fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)) \\<circ> \\<lfloor>q\\<rfloor>) (x \\<sqinter> q)\""], ["proof (prove)\nusing this:\n  x \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f)\n           (- q \\<squnion> x \\<sqinter> q)\n\ngoal (1 subgoal):\n 1. x \\<le> (fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n             \\<lfloor>q\\<rfloor>)\n             (x \\<sqinter> q)", "by (simp add: bqtran_def)"], ["proof (state)\nthis:\n  x \\<le> (fiter_id (\\<lfloor>p\\<rfloor> \\<circ> f) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (x \\<sqinter> q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma btran_spec: \"x \\<le> \\<lfloor>y\\<rfloor> (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<lfloor>y\\<rfloor> (x \\<sqinter> y)", "by (simp add: bqtran_def sup_inf_distrib1)"], ["", "lemma btran_neg_spec: \"x \\<le> \\<lfloor>-y\\<rfloor> (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<lfloor>- y\\<rfloor> (x - y)", "by (simp add: btran_spec diff_eq)"], ["", "subsection \\<open>A Propositional Refinement Calculus\\<close>"], ["", "text \\<open>Next I derive the laws of an abstract Propositional Refinement Calculus, Morgan-style. \nThese are given without the co-called frames, which capture information about local and global variables in variants of this calculus.\\<close>"], ["", "definition \"Ri x y z = \\<Sqinter>{f z |f. x \\<le> f y \\<and> mono (f::'a::order \\<Rightarrow> 'b::complete_lattice)}\""], ["", "lemma Ri_least: \"mono f \\<Longrightarrow> x \\<le> f y \\<Longrightarrow> Ri x y z \\<le> f z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> Ri x y z \\<le> f z", "unfolding Ri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mono f; x \\<le> f y\\<rbrakk>\n    \\<Longrightarrow> \\<Sqinter> {f z |f. x \\<le> f y \\<and> mono f}\n                      \\<le> f z", "by (metis (mono_tags, lifting) Inf_lower mem_Collect_eq)"], ["", "lemma Ri_spec: \"x \\<le> Ri x y y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> Ri x y y", "unfolding Ri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> \\<Sqinter> {f y |f. x \\<le> f y \\<and> mono f}", "by (rule Inf_greatest, safe)"], ["", "lemma Ri_spec_var: \"(\\<forall>z. Ri x y z \\<le> f z) \\<Longrightarrow> x \\<le> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z. Ri x y z \\<le> f z \\<Longrightarrow> x \\<le> f y", "using Ri_spec dual_order.trans"], ["proof (prove)\nusing this:\n  ?x \\<le> Ri ?x ?y ?y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<forall>z. Ri x y z \\<le> f z \\<Longrightarrow> x \\<le> f y", "by blast"], ["", "lemma Ri_prop: \"mono f \\<Longrightarrow> x \\<le> f y \\<longleftrightarrow> (\\<forall>z. Ri x y z \\<le> f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    (x \\<le> f y) = (\\<forall>z. Ri x y z \\<le> f z)", "using Ri_least Ri_spec_var"], ["proof (prove)\nusing this:\n  \\<lbrakk>mono ?f; ?x \\<le> ?f ?y\\<rbrakk>\n  \\<Longrightarrow> Ri ?x ?y ?z \\<le> ?f ?z\n  \\<forall>z. Ri ?x ?y z \\<le> ?f z \\<Longrightarrow> ?x \\<le> ?f ?y\n\ngoal (1 subgoal):\n 1. mono f \\<Longrightarrow>\n    (x \\<le> f y) = (\\<forall>z. Ri x y z \\<le> f z)", "by blast"], ["", "lemma iso_Ri: \"mono (Ri x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (Ri x y)", "unfolding mono_def Ri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa ya.\n       xa \\<le> ya \\<longrightarrow>\n       \\<Sqinter> {f xa |f.\n                   x \\<le> f y \\<and>\n                   (\\<forall>x y.\n                       x \\<le> y \\<longrightarrow> f x \\<le> f y)}\n       \\<le> \\<Sqinter> {f ya |f.\n                         x \\<le> f y \\<and>\n                         (\\<forall>x y.\n                             x \\<le> y \\<longrightarrow> f x \\<le> f y)}", "by (auto intro!: Inf_mono)"], ["", "lemma Ri_weaken: \"x \\<le> x' \\<Longrightarrow>  y' \\<le> y \\<Longrightarrow> Ri x y z \\<le> Ri x' y' z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> x'; y' \\<le> y\\<rbrakk>\n    \\<Longrightarrow> Ri x y z \\<le> Ri x' y' z", "by (meson H_iso_cond2 Ri_least Ri_spec iso_Ri order.trans)"], ["", "lemma Ri_seq: \"Ri x y z \\<le> Ri x w (Ri w y z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ri x y z \\<le> Ri x w (Ri w y z)", "by (metis (no_types, hide_lams) H_iso_cond2 Ri_prop Ri_spec iso_Ri iso_fcomp o_apply)"], ["", "lemma Ri_seq_var: \"Ri x y z \\<le> ((Ri x w) \\<circ> (Ri w y)) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ri x y z \\<le> (Ri x w \\<circ> Ri w y) z", "by (simp add: Ri_seq)"], ["", "lemma Ri_Inf: \" Ri (\\<Sqinter> X) y z \\<le> \\<Sqinter>{Ri x y z |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ri (\\<Sqinter> X) y z \\<le> \\<Sqinter> {Ri x y z |x. x \\<in> X}", "by (safe intro!: Inf_greatest, simp add: Ri_weaken Inf_lower)"], ["", "lemma Ri_weak_iter: \"Ri x x y  \\<le> fiter_id (Ri x x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ri x x y \\<le> fiter_id (Ri x x) y", "by (simp add: H_weak_loop Ri_least Ri_spec iso_Ri iso_fiter)"], ["", "lemma Ri_cond: \"Ri x y z \\<le> (inf (\\<lfloor>p\\<rfloor> \\<circ> (Ri (p \\<sqinter> x) y)) ((\\<lfloor>q\\<rfloor> \\<circ> (Ri (q \\<sqinter> x) y)))) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ri x y z\n    \\<le> ((\\<lfloor>p\\<rfloor> \\<circ> Ri (p \\<sqinter> x) y) \\<sqinter>\n           (\\<lfloor>q\\<rfloor> \\<circ> Ri (q \\<sqinter> x) y))\n           z", "by (meson H_iso_cond Ri_least Ri_spec bqtran_iso iso_Ri iso_fcomp iso_finf)"], ["", "lemma Ri_loop: \"Ri x (q \\<sqinter> x) y \\<le> ((fiter_id (\\<lfloor>p\\<rfloor> \\<circ> (Ri (x \\<sqinter> p) x))) \\<circ> \\<lfloor>q\\<rfloor>) (q \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ri x (q \\<sqinter> x) y\n    \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Ri x (q \\<sqinter> x) y\n    \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> y)", "have \"(p \\<sqinter> x) \\<le> Ri (p \\<sqinter> x) x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<sqinter> x \\<le> Ri (p \\<sqinter> x) x x", "by (simp add: Ri_spec)"], ["proof (state)\nthis:\n  p \\<sqinter> x \\<le> Ri (p \\<sqinter> x) x x\n\ngoal (1 subgoal):\n 1. Ri x (q \\<sqinter> x) y\n    \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> y)", "hence \"x \\<le> ((fiter_id (\\<lfloor>p\\<rfloor> \\<circ> (Ri (x \\<sqinter> p) x))) \\<circ> \\<lfloor>q\\<rfloor>) (q \\<sqinter> x)\""], ["proof (prove)\nusing this:\n  p \\<sqinter> x \\<le> Ri (p \\<sqinter> x) x x\n\ngoal (1 subgoal):\n 1. x \\<le> (fiter_id\n              (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n             \\<lfloor>q\\<rfloor>)\n             (q \\<sqinter> x)", "by (metis H_iso_loop inf_commute iso_Ri)"], ["proof (state)\nthis:\n  x \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> x)\n\ngoal (1 subgoal):\n 1. Ri x (q \\<sqinter> x) y\n    \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> x)\n\ngoal (1 subgoal):\n 1. Ri x (q \\<sqinter> x) y\n    \\<le> (fiter_id\n            (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n           \\<lfloor>q\\<rfloor>)\n           (q \\<sqinter> y)", "apply (subst Ri_least, safe, simp_all add: mono_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x)\n             (\\<lfloor>q\\<rfloor> (q \\<sqinter> x)) \\<Longrightarrow>\n    \\<forall>xa y.\n       xa \\<le> y \\<longrightarrow>\n       fiter_id (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x)\n        (\\<lfloor>q\\<rfloor> (q \\<sqinter> xa))\n       \\<le> fiter_id (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x)\n              (\\<lfloor>q\\<rfloor> (q \\<sqinter> y))", "by (metis bqtran_iso inf_mono iso_Ri iso_fcomp iso_fiter mono_def order_refl)"], ["proof (state)\nthis:\n  Ri x (q \\<sqinter> x) y\n  \\<le> (fiter_id\n          (\\<lfloor>p\\<rfloor> \\<circ> Ri (x \\<sqinter> p) x) \\<circ>\n         \\<lfloor>q\\<rfloor>)\n         (q \\<sqinter> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}