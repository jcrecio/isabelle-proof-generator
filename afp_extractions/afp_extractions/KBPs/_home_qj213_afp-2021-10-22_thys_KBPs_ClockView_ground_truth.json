{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/ClockView.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma clock_jview_tInit:\n  \"clock_jview a (tInit s) = (0, envObs a s)\"", "lemma clock_jview_tStep:\n  \"clock_jview a (t \\<leadsto> s) = (Suc (tLength t), envObs a s)\"", "lemma clock_jview_tStepI[intro]:\n  \"\\<lbrakk> tLength t = Suc n; envObs a (tLast t) = obs \\<rbrakk>\n     \\<Longrightarrow> clock_jview a t = (Suc n, obs)\"", "lemma clock_jview_inv:\n  \"clock_jview a t = (n, obs) \\<Longrightarrow> envObs a (tLast t) = obs\"", "lemmas clock_jview_simps =\n  clock_jview_tInit\n  clock_jview_tStep\n  clock_jview_inv", "lemma clock_jview_eq_inv[iff]:\n  \"clock_jview a t' = clock_jview a t\n    \\<longleftrightarrow> tLength t' = tLength t \\<and> envObs a (tLast t') = envObs a (tLast t)\"", "lemma clock_simVal_def2[iff]: \"clock_simVal (clock_sim t) = envVal (tLast t)\"", "lemma clock_sim_range:\n  \"sim_range Clock.MC clock_simMC clock_sim\"", "lemma clock_simVal:\n  \"sim_val Clock.MC clock_simMC clock_sim\"", "lemma clock_sim_f:\n  \"sim_f Clock.MC clock_simMC clock_sim\"", "lemma clock_sim_r:\n  \"sim_r Clock.MC clock_simMC clock_sim\"", "lemma clock_sim:\n  \"sim Clock.MC clock_simMC clock_sim\"", "lemma aec_refl[intro, simp]:\n  \"t \\<in> Clock.jkbpC \\<Longrightarrow> tLast t \\<in> agent_abs a t\"", "lemma aec_cec_subset:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n  shows \"x \\<in> ODList.toSet aec \\<Longrightarrow> x \\<in> ODList.toSet cec\"", "lemma clock_simAbs_refl:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"clock_sim t \\<in> clock_simAbs ec\"", "lemma common_abs:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (fst ec) = common_abs t\"", "lemma agent_abs:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (snd ec) = agent_abs a t\"", "lemma clock_simAbs_inj_on:\n  \"inj_on clock_simAbs { x . clock_simAbs x \\<in> Clock.jkbpSEC }\"", "lemma clock_repMC_kripke[intro, simp]: \"kripke (clock_repMC X)\"", "lemma clock_repMC_S5n[intro, simp]: \"S5n (clock_repMC X)\"", "lemma jkbpCSt_jkbpCS_subset:\n  \"clock_jkbpCSt t \\<subseteq> clock_sim ` Clock.jkbpC\"", "lemma jkbpCSt_refl[iff]:\n  \"t \\<in> Clock.jkbpC \\<Longrightarrow> clock_sim t \\<in> clock_jkbpCSt t\"", "lemma fst_clock_sim[iff]:\n  \"t \\<in> Clock.jkbpC \\<Longrightarrow> fst (clock_sim t) = tLast ` Clock.jkbpCn (tLength t)\"", "lemma clock_repSim_simps[simp]:\n  \"clock_repSim ` clock_sim ` T = tLast ` T\"\n  \"clock_repSim (clock_sim t) = tLast t\"", "lemma clock_repSim:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  shows \"sim (clock_simMCt t)\n             ((clock_repMC \\<circ> fst) (clock_sim t))\n             clock_repSim\"\n(*<*) (is \"sim ?M ?M' ?f\")", "lemma clock_simInit:\n  assumes \"iobs \\<in> envObs a ` set envInit\"\n  shows \"clock_simAbs (clock_simInit a iobs)\n       = clock_sim ` { t' \\<in> Clock.jkbpC.\n                       clock_jview a t' = clock_jviewInit a iobs }\"", "lemma clock_simObs:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"clock_simObs a ec = envObs a (tLast t)\"", "lemma clock_coEC_relation_image:\n  \"s \\<in> ODList.toSet Y\n    \\<Longrightarrow> ODList.toSet (clock_knowledge envObs Y a s) = relations (clock_repMC (ODList.toSet Y)) a `` {s}\"", "lemma clock_commonKnowledge_relation_image_aux:\n  \"(\\<Union>x\\<in>set as. \\<Union>a\\<in>ODList.toSet Y. \\<Union>aa\\<in>ODList.toSet Y \\<inter> {s''. envObs x a = envObs x s''}. {(a, aa)})\n = ((\\<Union>a\\<in>set as. {(s, s'). envObs a s = envObs a s'}) \\<inter> ODList.toSet Y \\<times> ODList.toSet Y)\"", "lemma clock_commonKnowledge_relation_image:\n  \"s \\<in> ODList.toSet Y\n    \\<Longrightarrow> ODList.toSet (clock_commonKnowledge envObs Y as s) = (\\<Union>a \\<in> set as. relations (clock_repMC (ODList.toSet Y)) a)\\<^sup>+ `` {s}\"", "lemma eval_rec_models:\n  assumes XY: \"ODList.toSet X \\<subseteq> ODList.toSet Y\"\n      and s: \"s \\<in> ODList.toSet X\"\n  shows \"s \\<in> ODList.toSet (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y) (clock_commonKnowledge envObs Y) X \\<phi>)\n     \\<longleftrightarrow> clock_repMC (ODList.toSet Y), s \\<Turnstile> \\<phi>\"", "lemma trc_aux:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n  shows \"ODList.toSet (big_union (clock_commonKnowledge envObs cec as) (toList aec)) \\<subseteq> ODList.toSet cec\"", "lemma clock_repMC_aec:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and x: \"x \\<in> ODList.toSet aec\"\n      and xy: \"(x, y) \\<in> relations (clock_repMC (ODList.toSet cec)) a\"\n  shows \"y \\<in> ODList.toSet aec\"", "lemma clock_repMC_cec:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and x: \"x \\<in> ODList.toSet aec\"\n      and y: \"y \\<in> ODList.toSet aec\"\n  shows \"(x, y) \\<in> relations (clock_repMC (ODList.toSet cec)) a\"", "lemma evalS_models:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and subj_phi: \"subjective a \\<phi>\"\n      and s: \"s \\<in> ODList.toSet aec\"\n  shows \"evalS (clock_evalProp envVal) (clock_knowledge envObs cec) (clock_commonKnowledge envObs cec) aec \\<phi>\n     \\<longleftrightarrow> clock_repMC (ODList.toSet cec), s \\<Turnstile> \\<phi>\" (is \"?lhs \\<phi> = ?rhs \\<phi>\")", "lemma eval_models:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and subj_phi: \"subjective a \\<phi>\"\n      and s: \"s \\<in> ODList.toSet aec\"\n  shows \"eval envVal envObs (cec, aec) \\<phi>\n     \\<longleftrightarrow> clock_repMC (ODList.toSet cec), s \\<Turnstile> \\<phi>\"", "lemma clock_simAction_jAction:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n  shows \"set (clock_simAction a (cec, aec))\n       = set (jAction (clock_repMC (ODList.toSet cec)) (tLast t) a)\"", "lemma clock_submodel_aux:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and s: \"s \\<in> worlds (clock_simMCt t)\"\n  shows \"gen_model Clock.MCS s = gen_model (clock_simMCt t) s\"", "lemma clock_simAction':\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes aec: \"ODList.toSet aec = agent_abs a t\"\n  assumes cec: \"ODList.toSet cec = common_abs t\"\n  shows \"set (clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)\"\n(*<*) (is \"?lhs = ?rhs\")", "lemma clock_simAction:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"set (clock_simAction a ec) = set (jAction Clock.MC t a)\"", "lemma clock_trans_aux:\n  assumes t'C: \"t' \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a' t'\"\n      and tC: \"t \\<in> Clock.jkbpCn (tLength t')\"\n      and eact: \"eact \\<in> set (envAction (tLast t))\"\n  shows \"(aact \\<in> set (listToFuns (\\<lambda>a. clock_simAction a (fst ec, clock_knowledge envObs (fst ec) a (tLast t)))\n                            (toList agents)))\n     \\<longleftrightarrow> (\\<forall>a. aact a \\<in> set (jAction (Clock.MCn (tLength t')) t a))\"", "lemma clock_trans_common:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (clock_trans (fst ec) (fst ec))\n       = { s |t' s. t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t }\"\n(*<*) (is \"?lhs = ?rhs\")", "lemma clock_trans_agent:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (clock_trans (fst ec) (snd ec))\n       = { s |t' s. t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t }\"\n(*<*) (is \"?lhs = ?rhs\")", "lemma clock_simTrans:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"clock_simAbs ` set (clock_simTrans a ec)\n      = { Clock.sim_equiv_class a (t' \\<leadsto> s)\n          |t' s. t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t }\"\n(*<*) (is \"?lhs = ?rhs\")", "lemma (in FiniteLinorderEnvironment) trans_MapOps:\n  \"MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k)) (Clock.jkbpSEC \\<times> UNIV) trans_MapOps\"", "lemma (in FiniteLinorderEnvironment) acts_MapOps:\n  \"MapOps clock_simAbs Clock.jkbpSEC acts_MapOps\"", "lemma (in FiniteLinorderEnvironment) mkClockAuto_implements:\n  \"Clock.implements\n    (mkClockAuto agents jkbp envInit envAction envTrans envVal envObs)\"", "lemma (in FiniteLinorderEnvironment)\n  \"mkClockAuto agents jkbp envInit envAction envTrans envVal envObs\n = (\\<lambda>a. alg_mk_auto acts_MapOps trans_MapOps (clock_simInit a) (ClockAutoDFS agents jkbp envInit envAction envTrans envVal envObs a))\""], "translations": [["", "lemma clock_jview_tInit:\n  \"clock_jview a (tInit s) = (0, envObs a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_jview a (tInit s) = (0, envObs a s)", "unfolding clock_jview_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tLength (tInit s), envObs a (tLast (tInit s))) = (0, envObs a s)", "by simp"], ["", "lemma clock_jview_tStep:\n  \"clock_jview a (t \\<leadsto> s) = (Suc (tLength t), envObs a s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_jview a (t \\<leadsto> s) = (Suc (tLength t), envObs a s)", "unfolding clock_jview_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tLength (t \\<leadsto> s), envObs a (tLast (t \\<leadsto> s))) =\n    (Suc (tLength t), envObs a s)", "by simp"], ["", "lemma clock_jview_tStepI[intro]:\n  \"\\<lbrakk> tLength t = Suc n; envObs a (tLast t) = obs \\<rbrakk>\n     \\<Longrightarrow> clock_jview a t = (Suc n, obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tLength t = Suc n; envObs a (tLast t) = obs\\<rbrakk>\n    \\<Longrightarrow> clock_jview a t = (Suc n, obs)", "unfolding clock_jview_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tLength t = Suc n; envObs a (tLast t) = obs\\<rbrakk>\n    \\<Longrightarrow> (tLength t, envObs a (tLast t)) = (Suc n, obs)", "by (cases t) simp_all"], ["", "lemma clock_jview_inv:\n  \"clock_jview a t = (n, obs) \\<Longrightarrow> envObs a (tLast t) = obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_jview a t = (n, obs) \\<Longrightarrow> envObs a (tLast t) = obs", "unfolding clock_jview_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tLength t, envObs a (tLast t)) = (n, obs) \\<Longrightarrow>\n    envObs a (tLast t) = obs", "by (cases t) simp_all"], ["", "lemmas clock_jview_simps =\n  clock_jview_tInit\n  clock_jview_tStep\n  clock_jview_inv"], ["", "lemma clock_jview_eq_inv[iff]:\n  \"clock_jview a t' = clock_jview a t\n    \\<longleftrightarrow> tLength t' = tLength t \\<and> envObs a (tLast t') = envObs a (tLast t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (clock_jview a t' = clock_jview a t) =\n    (tLength t' = tLength t \\<and> envObs a (tLast t') = envObs a (tLast t))", "by (fastforce simp: clock_jview_def)"], ["", "end"], ["", "(*>*)"], ["", "text\\<open>\n\nThis is the least-information synchronous view, given the requirements\nof \\S\\ref{sec:kbps-views}. We show that finite-state implementations\nexist for all environments with respect to this view as per\n\\citet{Ron:1996}.\n\nThe corresponding incremental view simply increments the counter\nrecords the new observation.\n\n\\<close>"], ["", "definition (in Environment)\n  clock_jviewInit :: \"'a \\<Rightarrow> 'obs \\<Rightarrow> nat \\<times> 'obs\"\nwhere\n  \"clock_jviewInit \\<equiv> \\<lambda>a obs. (0, obs)\""], ["", "definition (in Environment)\n  clock_jviewIncr :: \"'a \\<Rightarrow> 'obs \\<Rightarrow> nat \\<times> 'obs \\<Rightarrow> nat \\<times> 'obs\"\nwhere\n  \"clock_jviewIncr \\<equiv> \\<lambda>a obs' (l, obs). (l + 1, obs')\""], ["", "text\\<open>\n\nIt is straightforward to demonstrate the assumptions of the\nincremental environment locale (\\S\\ref{sec:kbps-environments}) with\nrespect to an arbitrary environment.\n\n\\<close>"], ["", "sublocale Environment\n        < Clock: IncrEnvironment jkbp envInit envAction envTrans envVal\n                        clock_jview envObs clock_jviewInit clock_jviewIncr"], ["proof (prove)\ngoal (1 subgoal):\n 1. IncrEnvironment jkbp clock_jview envObs clock_jviewInit clock_jviewIncr", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. IncrEnvironment jkbp clock_jview envObs clock_jviewInit clock_jviewIncr", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>a t t'.\n       clock_jview a t = clock_jview a t' \\<longrightarrow>\n       tLength t = tLength t'\n 2. \\<forall>a s. clock_jviewInit a (envObs a s) = clock_jview a (tInit s)\n 3. \\<forall>a t s.\n       clock_jview a (t \\<leadsto> s) =\n       clock_jviewIncr a (envObs a s) (clock_jview a t)", "apply (simp_all add: clock_jviewInit_def clock_jviewIncr_def clock_jview_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nAs we later show, satisfaction of a formula at a trace \\<open>t \\<in>\nClock.jkbpC\\<^bsub>n\\<^esub>\\<close> is determined by the set of final states of traces in\n\\<open>Clock.jkbpCn\\<close>:\n\n\\<close>"], ["", "context Environment\nbegin"], ["", "abbreviation clock_commonAbs :: \"'s Trace \\<Rightarrow> 's set\" where\n  \"clock_commonAbs t \\<equiv> tLast ` Clock.jkbpCn (tLength t)\""], ["", "text\\<open>\n\nIntuitively this set contains the states that the agents commonly\nconsider possible at time @{term \"n\"}, which is sufficient for\ndetermining knowledge as the clock view ignores paths. Therefore we\ncan simulate trace @{term \"t\"} by pairing this abstraction of @{term\n\"t\"} with its final state:\n\n\\<close>"], ["", "type_synonym (in -) 's clock_simWorlds = \"'s set \\<times> 's\""], ["", "definition clock_sim :: \"'s Trace \\<Rightarrow> 's clock_simWorlds\" where\n  \"clock_sim \\<equiv> \\<lambda>t. (clock_commonAbs t, tLast t)\""], ["", "text\\<open>\n\nIn the Kripke structure for our simulation, we relate worlds for\n@{term \"a\"} if the sets of commonly-held states coincide, and the\nobservation of the final states of the traces is the\nsame. Propositions are evaluated at the final state.\n\n\\<close>"], ["", "definition clock_simRels :: \"'a \\<Rightarrow> 's clock_simWorlds Relation\" where\n  \"clock_simRels \\<equiv> \\<lambda>a. { ((X, s), (X', s')) |X X' s s'.\n                          X = X' \\<and> {s, s'} \\<subseteq> X \\<and> envObs a s = envObs a s' }\""], ["", "definition clock_simVal :: \"'s clock_simWorlds \\<Rightarrow> 'p \\<Rightarrow> bool\" where\n  \"clock_simVal \\<equiv> envVal \\<circ> snd\""], ["", "abbreviation clock_simMC :: \"('a, 'p, 's clock_simWorlds) KripkeStructure\" where\n  \"clock_simMC \\<equiv> mkKripke (clock_sim ` Clock.jkbpC) clock_simRels clock_simVal\""], ["", "(*<*)"], ["", "lemma clock_simVal_def2[iff]: \"clock_simVal (clock_sim t) = envVal (tLast t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_simVal (clock_sim t) = envVal (tLast t)", "unfolding clock_sim_def clock_simVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (envVal \\<circ> snd) (clock_commonAbs t, tLast t) = envVal (tLast t)", "by simp"], ["", "lemma clock_sim_range:\n  \"sim_range Clock.MC clock_simMC clock_sim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_range Clock.MC clock_simMC clock_sim", "by (rule sim_rangeI) (simp_all add: clock_sim_def)"], ["", "lemma clock_simVal:\n  \"sim_val Clock.MC clock_simMC clock_sim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_val Clock.MC clock_simMC clock_sim", "by (rule sim_valI) (simp add: clock_simVal_def clock_sim_def)"], ["", "lemma clock_sim_f:\n  \"sim_f Clock.MC clock_simMC clock_sim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_f Clock.MC clock_simMC clock_sim", "apply (rule sim_fI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       (clock_sim u, clock_sim v) \\<in> relations clock_simMC a", "apply (simp add: clock_simRels_def clock_sim_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       tLast u \\<in> clock_commonAbs u \\<and>\n       tLast v \\<in> clock_commonAbs u \\<and>\n       envObs a (tLast u) = envObs a (tLast v) \\<and>\n       (clock_commonAbs u, tLast v)\n       \\<in> (\\<lambda>x. (clock_commonAbs x, tLast x)) ` Clock.jkbpC", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       tLast u \\<in> clock_commonAbs u\n 2. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       tLast v \\<in> clock_commonAbs u\n 3. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       envObs a (tLast u) = envObs a (tLast v)\n 4. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       (clock_commonAbs u, tLast v)\n       \\<in> (\\<lambda>x. (clock_commonAbs x, tLast x)) ` Clock.jkbpC", "apply (fastforce intro!: imageI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       tLast v \\<in> clock_commonAbs u\n 2. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       envObs a (tLast u) = envObs a (tLast v)\n 3. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       (clock_commonAbs u, tLast v)\n       \\<in> (\\<lambda>x. (clock_commonAbs x, tLast x)) ` Clock.jkbpC", "apply (fastforce intro!: imageI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       envObs a (tLast u) = envObs a (tLast v)\n 2. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       (clock_commonAbs u, tLast v)\n       \\<in> (\\<lambda>x. (clock_commonAbs x, tLast x)) ` Clock.jkbpC", "apply (fastforce dest: Clock.mkM_simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       (clock_commonAbs u, tLast v)\n       \\<in> (\\<lambda>x. (clock_commonAbs x, tLast x)) ` Clock.jkbpC", "apply (rule_tac x=v in image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       (clock_commonAbs u, tLast v) = (clock_commonAbs v, tLast v)\n 2. \\<And>a u v.\n       (u, v) \\<in> relations Clock.MC a \\<Longrightarrow>\n       v \\<in> Clock.jkbpC", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma clock_sim_r:\n  \"sim_r Clock.MC clock_simMC clock_sim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_r Clock.MC clock_simMC clock_sim", "apply (rule sim_rI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v'.\n       \\<lbrakk>u \\<in> worlds Clock.MC;\n        (clock_sim u, v') \\<in> relations clock_simMC a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            (u, v) \\<in> relations Clock.MC a \\<and>\n                            clock_sim v = v'", "apply (clarsimp simp: clock_simRels_def clock_sim_def cong del: image_cong_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u t x xa.\n       \\<lbrakk>u \\<in> Clock.jkbpC; t \\<in> Clock.jkbpC; tLast u = tLast x;\n        x \\<in> Clock.jkbpCn (tLength u);\n        clock_commonAbs t = clock_commonAbs u;\n        envObs a (tLast x) = envObs a (tLast xa); tLast t = tLast xa;\n        xa \\<in> Clock.jkbpCn (tLength u)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            (u, v) \\<in> relations Clock.MC a \\<and>\n                            clock_commonAbs v = clock_commonAbs u \\<and>\n                            tLast v = tLast xa", "apply (rule_tac x=xa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u t x xa.\n       \\<lbrakk>u \\<in> Clock.jkbpC; t \\<in> Clock.jkbpC; tLast u = tLast x;\n        x \\<in> Clock.jkbpCn (tLength u);\n        clock_commonAbs t = clock_commonAbs u;\n        envObs a (tLast x) = envObs a (tLast xa); tLast t = tLast xa;\n        xa \\<in> Clock.jkbpCn (tLength u)\\<rbrakk>\n       \\<Longrightarrow> (u, xa) \\<in> relations Clock.MC a \\<and>\n                         clock_commonAbs xa = clock_commonAbs u \\<and>\n                         tLast xa = tLast xa", "unfolding Clock.mkM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u t x xa.\n       \\<lbrakk>u \\<in> Clock.jkbpC; t \\<in> Clock.jkbpC; tLast u = tLast x;\n        x \\<in> Clock.jkbpCn (tLength u);\n        clock_commonAbs t = clock_commonAbs u;\n        envObs a (tLast x) = envObs a (tLast xa); tLast t = tLast xa;\n        xa \\<in> Clock.jkbpCn (tLength u)\\<rbrakk>\n       \\<Longrightarrow> (u, xa)\n                         \\<in> relations\n                                \\<lparr>worlds = Clock.jkbpC,\n                                   relations =\n                                     \\<lambda>a.\n  rel_ext\n   (\\<lambda>(t, t').\n       {t, t'} \\<subseteq> Clock.jkbpC \\<and>\n       clock_jview a t = clock_jview a t'),\n                                   valuation = envVal \\<circ> tLast\\<rparr>\n                                a \\<and>\n                         clock_commonAbs xa = clock_commonAbs u \\<and>\n                         tLast xa = tLast xa", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nThat this is in fact a simulation\n(\\S\\ref{sec:kripke-theory-simulations}) is entirely straightforward.\n\n\\<close>"], ["", "lemma clock_sim:\n  \"sim Clock.MC clock_simMC clock_sim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim Clock.MC clock_simMC clock_sim", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sim Clock.MC clock_simMC clock_sim", "using clock_sim_range clock_simVal clock_sim_f clock_sim_r"], ["proof (prove)\nusing this:\n  sim_range Clock.MC clock_simMC clock_sim\n  sim_val Clock.MC clock_simMC clock_sim\n  sim_f Clock.MC clock_simMC clock_sim\n  sim_r Clock.MC clock_simMC clock_sim\n\ngoal (1 subgoal):\n 1. sim Clock.MC clock_simMC clock_sim", "unfolding sim_def"], ["proof (prove)\nusing this:\n  sim_range Clock.MC clock_simMC clock_sim\n  sim_val Clock.MC clock_simMC clock_sim\n  sim_f Clock.MC clock_simMC clock_sim\n  sim_r Clock.MC clock_simMC clock_sim\n\ngoal (1 subgoal):\n 1. sim_range Clock.MC clock_simMC clock_sim \\<and>\n    sim_val Clock.MC clock_simMC clock_sim \\<and>\n    sim_f Clock.MC clock_simMC clock_sim \\<and>\n    sim_r Clock.MC clock_simMC clock_sim", "by blast"], ["", "(*>*)"], ["", "end"], ["", "(* context Environment *)"], ["", "text\\<open>\n\nThe \\<open>SimIncrEnvironment\\<close> of\n\\S\\ref{sec:kbps-theory-automata-env-sims} only requires that we\nprovide it an @{term \"Environment\"} and a simulation.\n\n\\<close>"], ["", "sublocale Environment\n        < Clock: SimIncrEnvironment jkbp envInit envAction envTrans envVal\n                  clock_jview envObs clock_jviewInit clock_jviewIncr\n                  clock_sim clock_simRels clock_simVal"], ["proof (prove)\ngoal (1 subgoal):\n 1. SimIncrEnvironment jkbp envInit envAction envTrans envVal clock_jview\n     envObs clock_jviewInit clock_jviewIncr clock_sim clock_simRels\n     clock_simVal", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. SimIncrEnvironment jkbp envInit envAction envTrans envVal clock_jview\n     envObs clock_jviewInit clock_jviewIncr clock_sim clock_simRels\n     clock_simVal", "by (unfold_locales, simp_all add: clock_sim)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe next consider algorithmic issues.\n\n\\<close>"], ["", "(* **************************************** *)"], ["", "subsubsection\\<open>Representations\\<close>"], ["", "text\\<open>\n\n\\label{sec:kbps-theory-clock-view-rep}\n\nWe now turn to the issue of how to represent equivalence classes of\nstates. As these are used as map keys, it is easiest to represent them\ncanonically. A simple approach is to use \\emph{ordered distinct lists}\nof type @{typ \"'a odlist\"} for the sets and \\emph{tries} for the\nmaps. Therefore we ask that environment states @{typ \"'s\"} belong to\nthe class \\<open>linorder\\<close> of linearly-ordered types, and moreover\nthat the set \\<open>agents\\<close> be effectively presented. We introduce a\nnew locale capturing these requirements:\n\n\\<close>"], ["", "locale FiniteLinorderEnvironment =\n  Environment jkbp envInit envAction envTrans envVal envObs\n    for jkbp :: \"('a::{finite, linorder}, 'p, 'aAct) JKBP\"\n    and envInit :: \"('s::{finite, linorder}) list\"\n    and envAction :: \"'s \\<Rightarrow> 'eAct list\"\n    and envTrans :: \"'eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's\"\n    and envVal :: \"'s \\<Rightarrow> 'p \\<Rightarrow> bool\"\n    and envObs :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'obs\"\n+ fixes agents :: \"'a odlist\"\n  assumes agents: \"ODList.toSet agents = UNIV\""], ["", "context FiniteLinorderEnvironment\nbegin"], ["", "text\\<open>\n\n\\label{sec:kbps-theory-clock-view-algops}\n\nFor a fixed agent @{term \"a\"}, we can reduce the number of worlds in\n@{term \"clock_simMC\"} by taking its quotient with respect to the\nequivalence relation for @{term \"a\"}. In other words, we represent a\nsimulated equivalence class by a pair of the set of all states\nreachable at a particular time, and the subset of these that @{term\n\"a\"} considers possible. The worlds in our representational Kripke\nstructure are therefore a pair of ordered, distinct lists:\n\n\\<close>"], ["", "type_synonym (in -) 's clock_simWorldsRep = \"'s odlist \\<times> 's odlist\""], ["", "text\\<open>\n\nWe can readily abstract a representation to a set of simulated\nequivalence classes:\n\n\\<close>"], ["", "definition (in -)\n  clock_simAbs :: \"'s::linorder clock_simWorldsRep \\<Rightarrow> 's clock_simWorlds set\"\nwhere\n  \"clock_simAbs X \\<equiv> { (ODList.toSet (fst X), s) |s. s \\<in> ODList.toSet (snd X) }\""], ["", "text\\<open>\n\nAssuming @{term \"X\"} represents a simulated equivalence class for\n@{term \"t \\<in> jkbpC\"}, @{term \"clock_simAbs X\"} decomposes into these\ntwo functions:\n\n\\<close>"], ["", "definition\n  agent_abs :: \"'a \\<Rightarrow> 's Trace \\<Rightarrow> 's set\"\nwhere\n  \"agent_abs a t \\<equiv>\n     { tLast t' |t'. t' \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t}\""], ["", "definition\n  common_abs :: \"'s Trace \\<Rightarrow> 's set\"\nwhere\n  \"common_abs t \\<equiv> tLast ` Clock.jkbpCn (tLength t)\""], ["", "(*<*)"], ["", "lemma aec_refl[intro, simp]:\n  \"t \\<in> Clock.jkbpC \\<Longrightarrow> tLast t \\<in> agent_abs a t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> Clock.jkbpC \\<Longrightarrow> tLast t \\<in> agent_abs a t", "unfolding agent_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> Clock.jkbpC \\<Longrightarrow>\n    tLast t\n    \\<in> rel_ext\n           (\\<lambda>uu_.\n               \\<exists>t'.\n                  uu_ = tLast t' \\<and>\n                  t' \\<in> Clock.jkbpC \\<and>\n                  clock_jview a t' = clock_jview a t)", "by auto"], ["", "lemma aec_cec_subset:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n  shows \"x \\<in> ODList.toSet aec \\<Longrightarrow> x \\<in> ODList.toSet cec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> toSet aec \\<Longrightarrow> x \\<in> toSet cec", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. x \\<in> toSet aec \\<Longrightarrow> x \\<in> toSet cec", "unfolding agent_abs_def common_abs_def"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t'.\n          uu_ = tLast t' \\<and>\n          t' \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t)\n  toSet cec = clock_commonAbs t\n\ngoal (1 subgoal):\n 1. x \\<in> toSet aec \\<Longrightarrow> x \\<in> toSet cec", "by fastforce"], ["", "lemma clock_simAbs_refl:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"clock_sim t \\<in> clock_simAbs ec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_sim t \\<in> clock_simAbs ec", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  clock_simAbs ec = Clock.sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. clock_sim t \\<in> clock_simAbs ec", "by simp"], ["", "lemma common_abs:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (fst ec) = common_abs t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (fst ec) = common_abs t", "using tC clock_simAbs_refl[OF tC ec]"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  clock_sim t \\<in> clock_simAbs ec\n\ngoal (1 subgoal):\n 1. toSet (fst ec) = common_abs t", "unfolding clock_sim_def clock_simAbs_def common_abs_def"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  (clock_commonAbs t, tLast t)\n  \\<in> rel_ext\n         (\\<lambda>uu_.\n             \\<exists>s.\n                uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec))\n\ngoal (1 subgoal):\n 1. toSet (fst ec) = clock_commonAbs t", "by (auto simp: ODList.toSet_def[symmetric])"], ["", "lemma agent_abs:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (snd ec) = agent_abs a t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (snd ec) = agent_abs a t", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  clock_simAbs ec = Clock.sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. toSet (snd ec) = agent_abs a t", "unfolding clock_sim_def clock_simAbs_def agent_abs_def"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>s.\n          uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec)) =\n  (\\<lambda>t. (clock_commonAbs t, tLast t)) `\n  rel_ext\n   (\\<lambda>t'.\n       t' \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t)\n\ngoal (1 subgoal):\n 1. toSet (snd ec) =\n    rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t'.\n            uu_ = tLast t' \\<and>\n            t' \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>t \\<in> Clock.jkbpC;\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>s.\n                uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec)) =\n        (\\<lambda>x. (clock_commonAbs t, tLast x)) `\n        rel_ext\n         (\\<lambda>t'.\n             t' \\<in> Clock.jkbpC \\<and>\n             tLength t' = tLength t \\<and>\n             envObs a (tLast t') = envObs a (tLast t));\n        x \\<in> toSet (snd ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            x = tLast t' \\<and>\n                            t' \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t \\<and>\n                            envObs a (tLast t') = envObs a (tLast t)", "apply (subgoal_tac \"(ODList.toSet (fst ec), x) \\<in> {(ODList.toSet (fst ec), s) |s. s \\<in> ODList.toSet (snd ec)}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t \\<in> Clock.jkbpC;\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>s.\n                uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec)) =\n        (\\<lambda>x. (clock_commonAbs t, tLast x)) `\n        rel_ext\n         (\\<lambda>t'.\n             t' \\<in> Clock.jkbpC \\<and>\n             tLength t' = tLength t \\<and>\n             envObs a (tLast t') = envObs a (tLast t));\n        x \\<in> toSet (snd ec);\n        (toSet (fst ec), x)\n        \\<in> rel_ext\n               (\\<lambda>uu_.\n                   \\<exists>s.\n                      uu_ = (toSet (fst ec), s) \\<and>\n                      s \\<in> toSet (snd ec))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            x = tLast t' \\<and>\n                            t' \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t \\<and>\n                            envObs a (tLast t') = envObs a (tLast t)\n 2. \\<And>x.\n       \\<lbrakk>t \\<in> Clock.jkbpC;\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>s.\n                uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec)) =\n        (\\<lambda>x. (clock_commonAbs t, tLast x)) `\n        rel_ext\n         (\\<lambda>t'.\n             t' \\<in> Clock.jkbpC \\<and>\n             tLength t' = tLength t \\<and>\n             envObs a (tLast t') = envObs a (tLast t));\n        x \\<in> toSet (snd ec)\\<rbrakk>\n       \\<Longrightarrow> (toSet (fst ec), x)\n                         \\<in> rel_ext\n                                (\\<lambda>uu_.\n                                    \\<exists>s.\n uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "(* FIXME filthy *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nThis representation is canonical on the domain of interest (though not\nin general):\n\n\\<close>"], ["", "lemma clock_simAbs_inj_on:\n  \"inj_on clock_simAbs { x . clock_simAbs x \\<in> Clock.jkbpSEC }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on clock_simAbs\n     (rel_ext\n       (\\<lambda>x.\n           clock_simAbs x\n           \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)))", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on clock_simAbs\n     (rel_ext\n       (\\<lambda>x.\n           clock_simAbs x\n           \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)))", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x: \"x \\<in> { x . clock_simAbs x \\<in> Clock.jkbpSEC }\"\n     and y: \"y \\<in> { x . clock_simAbs x \\<in> Clock.jkbpSEC }\"\n     and xy: \"clock_simAbs x = clock_simAbs y\""], ["proof (state)\nthis:\n  x \\<in> rel_ext\n           (\\<lambda>x.\n               clock_simAbs x\n               \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC))\n  y \\<in> rel_ext\n           (\\<lambda>x.\n               clock_simAbs x\n               \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC))\n  clock_simAbs x = clock_simAbs y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from x"], ["proof (chain)\npicking this:\n  x \\<in> rel_ext\n           (\\<lambda>x.\n               clock_simAbs x\n               \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC))", "obtain a t\n    where tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs x = Clock.sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  x \\<in> rel_ext\n           (\\<lambda>x.\n               clock_simAbs x\n               \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC))\n\ngoal (1 subgoal):\n 1. (\\<And>t a.\n        \\<lbrakk>t \\<in> Clock.jkbpC;\n         clock_simAbs x = Clock.sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> Clock.jkbpC\n  clock_simAbs x = Clock.sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from common_abs[OF tC ec] common_abs[OF tC trans[OF xy[symmetric] ec], symmetric]"], ["proof (chain)\npicking this:\n  toSet (fst x) = common_abs t\n  common_abs t = toSet (fst y)", "have \"fst x = fst y\""], ["proof (prove)\nusing this:\n  toSet (fst x) = common_abs t\n  common_abs t = toSet (fst y)\n\ngoal (1 subgoal):\n 1. fst x = fst y", "by (blast intro: injD[OF toSet_inj])"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  fst x = fst y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from agent_abs[OF tC ec] agent_abs[OF tC trans[OF xy[symmetric] ec], symmetric]"], ["proof (chain)\npicking this:\n  toSet (snd x) = agent_abs a t\n  agent_abs a t = toSet (snd y)", "have \"snd x = snd y\""], ["proof (prove)\nusing this:\n  toSet (snd x) = agent_abs a t\n  agent_abs a t = toSet (snd y)\n\ngoal (1 subgoal):\n 1. snd x = snd y", "by (blast intro: injD[OF toSet_inj])"], ["proof (state)\nthis:\n  snd x = snd y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> rel_ext\n                         (\\<lambda>x.\n                             clock_simAbs x\n                             \\<in> (\\<Union>a.\n Clock.sim_equiv_class a ` Clock.jkbpC));\n        y \\<in> rel_ext\n                 (\\<lambda>x.\n                     clock_simAbs x\n                     \\<in> (\\<Union>a.\n                               Clock.sim_equiv_class a ` Clock.jkbpC));\n        clock_simAbs x = clock_simAbs y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  fst x = fst y\n  snd x = snd y", "show \"x = y\""], ["proof (prove)\nusing this:\n  fst x = fst y\n  snd x = snd y\n\ngoal (1 subgoal):\n 1. x = y", "by (simp add: prod_eqI)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nWe could further compress this representation by labelling each\nelement of the set of states reachable at time $n$ with a bit to\nindicate whether the agent considers that state possible.  Note,\nhowever, that the representation would be non-canonical: if \\<open>(s, True)\\<close> is in the representation, indicating that the agent\nconsiders \\<open>s\\<close> possible, then \\<open>(s, False)\\<close> may or may\nnot be. The associated abstraction function is not injective and hence\nwould obfuscate the following. Repairing this would entail introducing\na new type, which would again complicate this development.\n\n\n\nThe following lemmas make use of this Kripke structure, constructed\nfrom the set of final states of a temporal slice @{term \"X\"}:\n\n\\<close>"], ["", "definition\n  clock_repRels :: \"'a \\<Rightarrow> ('s \\<times> 's) set\"\nwhere\n  \"clock_repRels \\<equiv> \\<lambda>a. { (s, s'). envObs a s = envObs a s' }\""], ["", "abbreviation\n  clock_repMC :: \"'s set \\<Rightarrow> ('a, 'p, 's) KripkeStructure\"\nwhere\n  \"clock_repMC \\<equiv> \\<lambda>X. mkKripke X clock_repRels envVal\""], ["", "(*<*)"], ["", "lemma clock_repMC_kripke[intro, simp]: \"kripke (clock_repMC X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kripke (clock_repMC X)", "by (rule kripkeI) simp"], ["", "lemma clock_repMC_S5n[intro, simp]: \"S5n (clock_repMC X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S5n (clock_repMC X)", "unfolding clock_repRels_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S5n (mkKripke X\n          (\\<lambda>a. rel_ext (\\<lambda>(s, s'). envObs a s = envObs a s'))\n          envVal)", "by (intro S5nI equivI refl_onI symI transI) auto"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can show that this Kripke structure retains sufficient information\nfrom @{term \"Clock.MCS\"} by showing simulation. This is eased by\nintroducing an intermediary structure that focusses on a particular\ntrace:\n\n\\<close>"], ["", "abbreviation\n  clock_jkbpCSt :: \"'b Trace \\<Rightarrow> 's clock_simWorlds set\"\nwhere\n  \"clock_jkbpCSt t \\<equiv> clock_sim ` Clock.jkbpCn (tLength t)\""], ["", "abbreviation\n  clock_simMCt :: \"'b Trace \\<Rightarrow> ('a, 'p, 's clock_simWorlds) KripkeStructure\"\nwhere\n  \"clock_simMCt t \\<equiv> mkKripke (clock_jkbpCSt t) clock_simRels clock_simVal\""], ["", "definition clock_repSim :: \"'s clock_simWorlds \\<Rightarrow> 's\" where\n  \"clock_repSim \\<equiv> snd\""], ["", "(*<*)"], ["", "lemma jkbpCSt_jkbpCS_subset:\n  \"clock_jkbpCSt t \\<subseteq> clock_sim ` Clock.jkbpC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_jkbpCSt t \\<subseteq> Clock.jkbpCS", "by auto"], ["", "lemma jkbpCSt_refl[iff]:\n  \"t \\<in> Clock.jkbpC \\<Longrightarrow> clock_sim t \\<in> clock_jkbpCSt t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> Clock.jkbpC \\<Longrightarrow> clock_sim t \\<in> clock_jkbpCSt t", "by blast"], ["", "lemma fst_clock_sim[iff]:\n  \"t \\<in> Clock.jkbpC \\<Longrightarrow> fst (clock_sim t) = tLast ` Clock.jkbpCn (tLength t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> Clock.jkbpC \\<Longrightarrow>\n    fst (clock_sim t) = clock_commonAbs t", "by (simp add: clock_sim_def)"], ["", "lemma clock_repSim_simps[simp]:\n  \"clock_repSim ` clock_sim ` T = tLast ` T\"\n  \"clock_repSim (clock_sim t) = tLast t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_repSim ` clock_sim ` T = tLast ` T &&&\n    clock_repSim (clock_sim t) = tLast t", "unfolding clock_repSim_def clock_sim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` (\\<lambda>t. (clock_commonAbs t, tLast t)) ` T = tLast ` T &&&\n    snd (clock_commonAbs t, tLast t) = tLast t", "by (auto intro!: image_eqI)"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma clock_repSim:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  shows \"sim (clock_simMCt t)\n             ((clock_repMC \\<circ> fst) (clock_sim t))\n             clock_repSim\"\n(*<*) (is \"sim ?M ?M' ?f\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sim (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. sim_range (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 2. sim_val (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 3. sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 4. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "show \"sim_range ?M ?M' ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_range (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. worlds ((clock_repMC \\<circ> fst) (clock_sim t)) =\n    clock_repSim ` worlds (clock_simMCt t)\n 2. \\<And>a.\n       relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\n       \\<subseteq> worlds ((clock_repMC \\<circ> fst) (clock_sim t)) \\<times>\n                   worlds ((clock_repMC \\<circ> fst) (clock_sim t))", "show \"worlds ?M' = ?f ` worlds ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worlds ((clock_repMC \\<circ> fst) (clock_sim t)) =\n    clock_repSim ` worlds (clock_simMCt t)", "unfolding clock_sim_def clock_repSim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. worlds ((clock_repMC \\<circ> fst) (clock_commonAbs t, tLast t)) =\n    snd `\n    worlds\n     (mkKripke\n       ((\\<lambda>t. (clock_commonAbs t, tLast t)) `\n        Clock.jkbpCn (tLength t))\n       clock_simRels clock_simVal)", "by force"], ["proof (state)\nthis:\n  worlds ((clock_repMC \\<circ> fst) (clock_sim t)) =\n  clock_repSim ` worlds (clock_simMCt t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\n       \\<subseteq> worlds ((clock_repMC \\<circ> fst) (clock_sim t)) \\<times>\n                   worlds ((clock_repMC \\<circ> fst) (clock_sim t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\n       \\<subseteq> worlds ((clock_repMC \\<circ> fst) (clock_sim t)) \\<times>\n                   worlds ((clock_repMC \\<circ> fst) (clock_sim t))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\n       \\<subseteq> worlds ((clock_repMC \\<circ> fst) (clock_sim t)) \\<times>\n                   worlds ((clock_repMC \\<circ> fst) (clock_sim t))", "show \"relations ?M' a \\<subseteq> worlds ?M' \\<times> worlds ?M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\n    \\<subseteq> worlds ((clock_repMC \\<circ> fst) (clock_sim t)) \\<times>\n                worlds ((clock_repMC \\<circ> fst) (clock_sim t))", "by (simp add: clock_sim_def clock_repSim_def)"], ["proof (state)\nthis:\n  relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\n  \\<subseteq> worlds ((clock_repMC \\<circ> fst) (clock_sim t)) \\<times>\n              worlds ((clock_repMC \\<circ> fst) (clock_sim t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sim_range (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n   clock_repSim\n\ngoal (3 subgoals):\n 1. sim_val (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 2. sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 3. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sim_val (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 2. sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 3. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "show \"sim_val ?M ?M' ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_val (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "by (rule, simp add: clock_sim_def clock_simVal_def clock_repSim_def split: prod.split)"], ["proof (state)\nthis:\n  sim_val (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n   clock_repSim\n\ngoal (2 subgoals):\n 1. sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 2. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim\n 2. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "show \"sim_f ?M ?M' ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v.\n       (u, v) \\<in> relations (clock_simMCt t) a \\<Longrightarrow>\n       (clock_repSim u, clock_repSim v)\n       \\<in> relations ((clock_repMC \\<circ> fst) (clock_sim t)) a", "unfolding clock_repRels_def clock_repSim_def clock_simRels_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v.\n       (u, v)\n       \\<in> relations\n              (mkKripke (clock_jkbpCSt t)\n                (\\<lambda>a.\n                    rel_ext\n                     (\\<lambda>uu_.\n                         \\<exists>X X' s s'.\n                            uu_ = ((X, s), X', s') \\<and>\n                            X = X' \\<and>\n                            {s, s'} \\<subseteq> X \\<and>\n                            envObs a s = envObs a s'))\n                clock_simVal)\n              a \\<Longrightarrow>\n       (snd u, snd v)\n       \\<in> relations\n              (((\\<lambda>X.\n                    mkKripke X\n                     (\\<lambda>a.\n                         rel_ext\n                          (\\<lambda>(s, s'). envObs a s = envObs a s'))\n                     envVal) \\<circ>\n                fst)\n                (clock_sim t))\n              a", "apply (auto iff: clock_sim_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sim_f (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n   clock_repSim\n\ngoal (1 subgoal):\n 1. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "show \"sim_r ?M ?M' ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n     clock_repSim", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v'.\n       \\<lbrakk>u \\<in> worlds (clock_simMCt t);\n        (clock_repSim u, v')\n        \\<in> relations ((clock_repMC \\<circ> fst) (clock_sim t)) a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            (u, v) \\<in> relations (clock_simMCt t) a \\<and>\n                            clock_repSim v = v'", "unfolding clock_repRels_def clock_repSim_def clock_simRels_def clock_sim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a u v'.\n       \\<lbrakk>u \\<in> worlds\n                         (mkKripke\n                           ((\\<lambda>t. (clock_commonAbs t, tLast t)) `\n                            Clock.jkbpCn (tLength t))\n                           (\\<lambda>a.\n                               rel_ext\n                                (\\<lambda>uu_.\n                                    \\<exists>X X' s s'.\n uu_ = ((X, s), X', s') \\<and>\n X = X' \\<and> {s, s'} \\<subseteq> X \\<and> envObs a s = envObs a s'))\n                           clock_simVal);\n        (snd u, v')\n        \\<in> relations\n               (((\\<lambda>X.\n                     mkKripke X\n                      (\\<lambda>a.\n                          rel_ext\n                           (\\<lambda>(s, s'). envObs a s = envObs a s'))\n                      envVal) \\<circ>\n                 fst)\n                 (clock_commonAbs t, tLast t))\n               a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v.\n                            (u, v)\n                            \\<in> relations\n                                   (mkKripke\n                                     ((\\<lambda>t.\n    (clock_commonAbs t, tLast t)) `\nClock.jkbpCn (tLength t))\n                                     (\\<lambda>a.\n   rel_ext\n    (\\<lambda>uu_.\n        \\<exists>X X' s s'.\n           uu_ = ((X, s), X', s') \\<and>\n           X = X' \\<and>\n           {s, s'} \\<subseteq> X \\<and> envObs a s = envObs a s'))\n                                     clock_simVal)\n                                   a \\<and>\n                            snd v = v'", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sim_r (clock_simMCt t) ((clock_repMC \\<circ> fst) (clock_sim t))\n   clock_repSim\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nThe following sections show how we satisfy the remaining requirements\nof the \\<open>Algorithm\\<close> locale of\nFigure~\\ref{fig:kbps-alg-alg-locale}. Where the proof is routine, we\nsimply present the lemma without proof or comment.\n\nDue to a limitation in the code generator in the present version of\nIsabelle (2011), we need to define the equations we wish to execute\noutside of a locale; the syntax \\<open>(in -)\\<close> achieves this by\nmaking definitons at the theory top-level. We then define (but elide)\nlocale-local abbreviations that supply the locale-bound variables to\nthese definitions.\n\n\\<close>"], ["", "(* **************************************** *)"], ["", "subsubsection\\<open>Initial states\\<close>"], ["", "text\\<open>\n\nThe initial states of the automaton for an agent is simply @{term\n\"envInit\"} paired with the partition of @{term \"envInit\"} under the\nagent's observation.\n\n\\<close>"], ["", "definition (in -)\n  clock_simInit :: \"('s::linorder) list \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> 'obs)\n                \\<Rightarrow> 'a \\<Rightarrow> 'obs \\<Rightarrow> 's clock_simWorldsRep\"\nwhere\n  \"clock_simInit envInit envObs \\<equiv> \\<lambda>a iobs.\n    let cec = ODList.fromList envInit\n     in (cec, ODList.filter (\\<lambda>s. envObs a s = iobs) cec)\""], ["", "(*<*)"], ["", "abbreviation\n  clock_simInit :: \"'a \\<Rightarrow> 'obs \\<Rightarrow> 's clock_simWorldsRep\"\nwhere\n  \"clock_simInit \\<equiv> ClockView.clock_simInit envInit envObs\""], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma clock_simInit:\n  assumes \"iobs \\<in> envObs a ` set envInit\"\n  shows \"clock_simAbs (clock_simInit a iobs)\n       = clock_sim ` { t' \\<in> Clock.jkbpC.\n                       clock_jview a t' = clock_jviewInit a iobs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_simAbs (local.clock_simInit a iobs) =\n    clock_sim `\n    rel_ext\n     (\\<lambda>t'.\n         t' \\<in> Clock.jkbpC \\<and>\n         clock_jview a t' = clock_jviewInit a iobs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_simAbs (local.clock_simInit a iobs) =\n    clock_sim `\n    rel_ext\n     (\\<lambda>t'.\n         t' \\<in> Clock.jkbpC \\<and>\n         clock_jview a t' = clock_jviewInit a iobs)", "using assms"], ["proof (prove)\nusing this:\n  iobs \\<in> envObs a ` set envInit\n\ngoal (1 subgoal):\n 1. clock_simAbs (local.clock_simInit a iobs) =\n    clock_sim `\n    rel_ext\n     (\\<lambda>t'.\n         t' \\<in> Clock.jkbpC \\<and>\n         clock_jview a t' = clock_jviewInit a iobs)", "unfolding clock_simInit_def clock_simAbs_def clock_sim_def [abs_def] Let_def"], ["proof (prove)\nusing this:\n  iobs \\<in> envObs a ` set envInit\n\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>s.\n            uu_ =\n            (toSet\n              (fst (fromList envInit,\n                    ODList.filter (\\<lambda>s. envObs a s = iobs)\n                     (fromList envInit))),\n             s) \\<and>\n            s \\<in> toSet\n                     (snd (fromList envInit,\n                           ODList.filter (\\<lambda>s. envObs a s = iobs)\n                            (fromList envInit)))) =\n    (\\<lambda>t. (clock_commonAbs t, tLast t)) `\n    rel_ext\n     (\\<lambda>t'.\n         t' \\<in> Clock.jkbpC \\<and>\n         clock_jview a t' = clock_jviewInit a iobs)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ = (set envInit, s) \\<and>\n                                 s \\<in> set envInit \\<and>\n                                 envObs a s = envObs a x) =\n                         (\\<lambda>x. (clock_commonAbs x, tLast x)) `\n                         rel_ext\n                          (\\<lambda>t'.\n                              t' \\<in> Clock.jkbpC \\<and>\n                              clock_jview a t' =\n                              clock_jviewInit a (envObs a x))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ = (set envInit, s) \\<and>\n                                 s \\<in> set envInit \\<and>\n                                 envObs a s = envObs a x)\n                         \\<subseteq> (\\<lambda>x.\n   (clock_commonAbs x, tLast x)) `\n                                     rel_ext\n(\\<lambda>t'.\n    t' \\<in> Clock.jkbpC \\<and>\n    clock_jview a t' = clock_jviewInit a (envObs a x))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (clock_commonAbs x, tLast x)) `\n                         rel_ext\n                          (\\<lambda>t'.\n                              t' \\<in> Clock.jkbpC \\<and>\n                              clock_jview a t' =\n                              clock_jviewInit a (envObs a x))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>s.\n       uu_ = (set envInit, s) \\<and>\n       s \\<in> set envInit \\<and> envObs a s = envObs a x)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x; s \\<in> set envInit;\n        envObs a s = envObs a x\\<rbrakk>\n       \\<Longrightarrow> (set envInit, s)\n                         \\<in> (\\<lambda>x. (clock_commonAbs x, tLast x)) `\n                               rel_ext\n                                (\\<lambda>t'.\n                                    t' \\<in> Clock.jkbpC \\<and>\n                                    clock_jview a t' =\n                                    clock_jviewInit a (envObs a x))\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (clock_commonAbs x, tLast x)) `\n                         rel_ext\n                          (\\<lambda>t'.\n                              t' \\<in> Clock.jkbpC \\<and>\n                              clock_jview a t' =\n                              clock_jviewInit a (envObs a x))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>s.\n       uu_ = (set envInit, s) \\<and>\n       s \\<in> set envInit \\<and> envObs a s = envObs a x)", "apply (rule_tac x=\"tInit s\" in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x s.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x; s \\<in> set envInit;\n        envObs a s = envObs a x\\<rbrakk>\n       \\<Longrightarrow> (set envInit, s) =\n                         (clock_commonAbs (tInit s), tLast (tInit s))\n 2. \\<And>x s.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x; s \\<in> set envInit;\n        envObs a s = envObs a x\\<rbrakk>\n       \\<Longrightarrow> tInit s\n                         \\<in> rel_ext\n                                (\\<lambda>t'.\n                                    t' \\<in> Clock.jkbpC \\<and>\n                                    clock_jview a t' =\n                                    clock_jviewInit a (envObs a x))\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (clock_commonAbs x, tLast x)) `\n                         rel_ext\n                          (\\<lambda>t'.\n                              t' \\<in> Clock.jkbpC \\<and>\n                              clock_jview a t' =\n                              clock_jviewInit a (envObs a x))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>s.\n       uu_ = (set envInit, s) \\<and>\n       s \\<in> set envInit \\<and> envObs a s = envObs a x)", "apply (auto simp: Set.image_def Clock.jviewInit)[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. (clock_commonAbs x, tLast x)) `\n                         rel_ext\n                          (\\<lambda>t'.\n                              t' \\<in> Clock.jkbpC \\<and>\n                              clock_jview a t' =\n                              clock_jviewInit a (envObs a x))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>s.\n       uu_ = (set envInit, s) \\<and>\n       s \\<in> set envInit \\<and> envObs a s = envObs a x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply (case_tac xa)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = tInit x1\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x\n 2. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ = tInit s \\<and> s \\<in> set envInit) =\n                         set envInit \\<and>\n                         envObs a x1 = envObs a x\n 2. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ = tInit s \\<and> s \\<in> set envInit) =\n                         set envInit\n 2. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> envObs a x1 = envObs a x\n 3. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ = tInit s \\<and> s \\<in> set envInit)\n                         \\<subseteq> set envInit\n 2. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> set envInit\n                         \\<subseteq> tLast `\n                                     rel_ext\n(\\<lambda>uu_. \\<exists>s. uu_ = tInit s \\<and> s \\<in> set envInit)\n 3. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> envObs a x1 = envObs a x\n 4. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> set envInit\n                         \\<subseteq> tLast `\n                                     rel_ext\n(\\<lambda>uu_. \\<exists>s. uu_ = tInit s \\<and> s \\<in> set envInit)\n 2. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> envObs a x1 = envObs a x\n 3. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x1 xa.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x);\n        xa \\<in> set envInit\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> tLast `\n                                  rel_ext\n                                   (\\<lambda>uu_.\n \\<exists>s. uu_ = tInit s \\<and> s \\<in> set envInit)\n 2. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> envObs a x1 = envObs a x\n 3. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply (rule_tac x=\"tInit xa\" in image_eqI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x1 xa.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x);\n        xa \\<in> set envInit\\<rbrakk>\n       \\<Longrightarrow> xa = tLast (tInit xa)\n 2. \\<And>x x1 xa.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x);\n        xa \\<in> set envInit\\<rbrakk>\n       \\<Longrightarrow> tInit xa\n                         \\<in> rel_ext\n                                (\\<lambda>uu_.\n                                    \\<exists>s.\n uu_ = tInit s \\<and> s \\<in> set envInit)\n 3. \\<And>x x1.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        x1 \\<in> set envInit;\n        clock_jview a (tInit x1) = clock_jviewInit a (envObs a x)\\<rbrakk>\n       \\<Longrightarrow> envObs a x1 = envObs a x\n 4. \\<And>x xa x21 x22.\n       \\<lbrakk>x \\<in> set envInit; iobs = envObs a x;\n        xa \\<in> Clock.jkbpC;\n        clock_jview a xa = clock_jviewInit a (envObs a x);\n        xa = x21 \\<leadsto> x22\\<rbrakk>\n       \\<Longrightarrow> clock_commonAbs xa = set envInit \\<and>\n                         tLast xa \\<in> set envInit \\<and>\n                         envObs a (tLast xa) = envObs a x", "apply (auto intro!: image_eqI simp: Clock.jviewInit)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* **************************************** *)"], ["", "subsubsection\\<open>Simulated observations\\<close>"], ["", "text\\<open>\n\nAgent @{term \"a\"} will make the same observation at any of the worlds\nthat it considers possible, so we choose the first one in the list:\n\n\\<close>"], ["", "definition (in -)\n  clock_simObs :: \"('a \\<Rightarrow> ('s :: linorder) \\<Rightarrow> 'obs)\n                \\<Rightarrow> 'a \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> 'obs\"\nwhere\n  \"clock_simObs envObs \\<equiv> \\<lambda>a. envObs a \\<circ> ODList.hd \\<circ> snd\""], ["", "(*<*)"], ["", "abbreviation\n  clock_simObs :: \"'a \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> 'obs\"\nwhere\n  \"clock_simObs \\<equiv> ClockView.clock_simObs envObs\""], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma clock_simObs:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"clock_simObs a ec = envObs a (tLast t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.clock_simObs a ec = envObs a (tLast t)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.clock_simObs a ec = envObs a (tLast t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.clock_simObs a ec = envObs a (tLast t)", "have A: \"\\<forall>s \\<in> set (toList (snd ec)). envObs a s = envObs a (tLast t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set (toList (snd ec)). envObs a s = envObs a (tLast t)", "using agent_abs[OF tC ec]"], ["proof (prove)\nusing this:\n  toSet (snd ec) = agent_abs a t\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set (toList (snd ec)). envObs a s = envObs a (tLast t)", "by (clarsimp simp: agent_abs_def toSet_def)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set (toList (snd ec)). envObs a s = envObs a (tLast t)\n\ngoal (1 subgoal):\n 1. local.clock_simObs a ec = envObs a (tLast t)", "have B: \"tLast t \\<in> set (toList (snd ec))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tLast t \\<in> set (toList (snd ec))", "using clock_simAbs_refl[OF assms]"], ["proof (prove)\nusing this:\n  clock_sim t \\<in> clock_simAbs ec\n\ngoal (1 subgoal):\n 1. tLast t \\<in> set (toList (snd ec))", "unfolding clock_simAbs_def clock_sim_def"], ["proof (prove)\nusing this:\n  (clock_commonAbs t, tLast t)\n  \\<in> rel_ext\n         (\\<lambda>uu_.\n             \\<exists>s.\n                uu_ = (toSet (fst ec), s) \\<and> s \\<in> toSet (snd ec))\n\ngoal (1 subgoal):\n 1. tLast t \\<in> set (toList (snd ec))", "by (simp add: toSet_def snd_def)"], ["proof (state)\nthis:\n  tLast t \\<in> set (toList (snd ec))\n\ngoal (1 subgoal):\n 1. local.clock_simObs a ec = envObs a (tLast t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.clock_simObs a ec = envObs a (tLast t)", "unfolding clock_simObs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (envObs a \\<circ> ODList.hd \\<circ> snd) ec = envObs a (tLast t)", "by (simp add: list_choose_hd[OF A B] ODList.hd_def)"], ["proof (state)\nthis:\n  local.clock_simObs a ec = envObs a (tLast t)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n\n(* **************************************** *)"], ["", "subsubsection\\<open>Evaluation\\<close>"], ["", "text\\<open>\n\n\\label{sec:kbps-theory-clock-view-eval}\n\nWe define our \\<open>eval\\<close> function in terms of @{term \"evalS\"},\nwhich implements boolean logic over @{typ \"'s odlist\"} in the usual\nway -- see \\S\\ref{sec:kbps-spr-single-agent-eval} for the relevant\nclauses. It requires three functions specific to the representation:\none each for propositions, knowledge and common knowledge.\n\nPropositions define subsets of the worlds considered possible:\n\n\\<close>"], ["", "abbreviation (in -)\n  clock_evalProp :: \"(('s::linorder) \\<Rightarrow> 'p \\<Rightarrow> bool)\n                  \\<Rightarrow> 's odlist \\<Rightarrow> 'p \\<Rightarrow> 's odlist\"\nwhere\n  \"clock_evalProp envVal \\<equiv> \\<lambda>X p. ODList.filter (\\<lambda>s. envVal s p) X\""], ["", "text\\<open>\n\nThe knowledge relation computes the subset of the\ncommonly-held-possible worlds \\<open>cec\\<close> that agent @{term \"a\"}\nconsiders possible at world @{term \"s\"}:\n\n\\<close>"], ["", "definition (in -)\n  clock_knowledge :: \"('a \\<Rightarrow> ('s :: linorder) \\<Rightarrow> 'obs) \\<Rightarrow> 's odlist\n                  \\<Rightarrow> 'a \\<Rightarrow> 's \\<Rightarrow> 's odlist\"\nwhere\n  \"clock_knowledge envObs cec \\<equiv> \\<lambda>a s.\n     ODList.filter (\\<lambda>s'. envObs a s = envObs a s') cec\""], ["", "text\\<open>\n\n\nSimilarly the common knowledge operation computes the transitive\nclosure of the union of the knowledge relations for the agents \\<open>as\\<close>:\n\n\\<close>"], ["", "definition (in -)\n  clock_commonKnowledge :: \"('a \\<Rightarrow> ('s :: linorder) \\<Rightarrow> 'obs) \\<Rightarrow> 's odlist\n           \\<Rightarrow> 'a list \\<Rightarrow> 's \\<Rightarrow> 's odlist\"\nwhere\n  \"clock_commonKnowledge envObs cec \\<equiv> \\<lambda>as s.\n     let r = \\<lambda>a. ODList.fromList [ (s', s'') . s' \\<leftarrow> toList cec, s'' \\<leftarrow> toList cec,\n                                   envObs a s' = envObs a s'' ];\n         R = toList (ODList.big_union r as)\n      in ODList.fromList (memo_list_trancl R s)\""], ["", "text\\<open>\n\nThe function \\<open>memo_list_trancl\\<close> comes from the executable\ntransitive closure theory of \\citep{AFP:TRANCL}.\n\nThe evaluation function evaluates a subjective knowledge formula on\nthe representation of an equivalence class:\n\n\\<close>"], ["", "definition (in -)\n  eval :: \"(('s :: linorder) \\<Rightarrow> 'p \\<Rightarrow> bool)\n        \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> 'obs)\n        \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> ('a, 'p) Kform \\<Rightarrow> bool\"\nwhere\n  \"eval envVal envObs \\<equiv> \\<lambda>(cec, aec). evalS (clock_evalProp envVal)\n                                      (clock_knowledge envObs cec)\n                                      (clock_commonKnowledge envObs cec)\n                                      aec\""], ["", "text\\<open>\n\nThis function corresponds with the standard semantics:\n\n\\<close>"], ["", "(*<*)"], ["", "lemma clock_coEC_relation_image:\n  \"s \\<in> ODList.toSet Y\n    \\<Longrightarrow> ODList.toSet (clock_knowledge envObs Y a s) = relations (clock_repMC (ODList.toSet Y)) a `` {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> toSet Y \\<Longrightarrow>\n    toSet (clock_knowledge envObs Y a s) =\n    relations (clock_repMC (toSet Y)) a `` {s}", "unfolding clock_knowledge_def clock_repRels_def Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> toSet Y \\<Longrightarrow>\n    toSet (ODList.filter (\\<lambda>s'. envObs a s = envObs a s') Y) =\n    rel_ext\n     (\\<lambda>y.\n         \\<exists>x\\<in>{s}.\n            (x, y)\n            \\<in> relations\n                   (mkKripke (toSet Y)\n                     (\\<lambda>a.\n                         rel_ext\n                          (\\<lambda>(s, s'). envObs a s = envObs a s'))\n                     envVal)\n                   a)", "by auto"], ["", "lemma clock_commonKnowledge_relation_image_aux:\n  \"(\\<Union>x\\<in>set as. \\<Union>a\\<in>ODList.toSet Y. \\<Union>aa\\<in>ODList.toSet Y \\<inter> {s''. envObs x a = envObs x s''}. {(a, aa)})\n = ((\\<Union>a\\<in>set as. {(s, s'). envObs a s = envObs a s'}) \\<inter> ODList.toSet Y \\<times> ODList.toSet Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set as.\n        \\<Union>a\\<in>toSet Y.\n           \\<Union>aa\\<in>toSet Y \\<inter>\n                          rel_ext (\\<lambda>s''. envObs x a = envObs x s'').\n              {(a, aa)}) =\n    Restr\n     (\\<Union>a\\<in>set as.\n         rel_ext (\\<lambda>(s, s'). envObs a s = envObs a s'))\n     (toSet Y)", "by auto"], ["", "lemma clock_commonKnowledge_relation_image:\n  \"s \\<in> ODList.toSet Y\n    \\<Longrightarrow> ODList.toSet (clock_commonKnowledge envObs Y as s) = (\\<Union>a \\<in> set as. relations (clock_repMC (ODList.toSet Y)) a)\\<^sup>+ `` {s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> toSet Y \\<Longrightarrow>\n    toSet (clock_commonKnowledge envObs Y as s) =\n    (\\<Union> (relations (clock_repMC (toSet Y)) ` set as))\\<^sup>+ `` {s}", "unfolding clock_commonKnowledge_def clock_repRels_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> toSet Y \\<Longrightarrow>\n    toSet\n     (fromList\n       (memo_list_trancl\n         (toList\n           (big_union\n             (\\<lambda>a.\n                 fromList\n                  (concat\n                    (map (\\<lambda>s'.\n                             concat\n                              (map (\\<lambda>s''.\n if envObs a s' = envObs a s'' then [(s', s'')] else [])\n                                (toList Y)))\n                      (toList Y))))\n             as))\n         s)) =\n    (\\<Union>\n      (relations\n        (mkKripke (toSet Y)\n          (\\<lambda>a. rel_ext (\\<lambda>(s, s'). envObs a s = envObs a s'))\n          envVal) `\n       set as))\\<^sup>+ ``\n    {s}", "apply (simp add: memo_list_trancl toSet_def[symmetric] Image_def clock_commonKnowledge_relation_image_aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma eval_rec_models:\n  assumes XY: \"ODList.toSet X \\<subseteq> ODList.toSet Y\"\n      and s: \"s \\<in> ODList.toSet X\"\n  shows \"s \\<in> ODList.toSet (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y) (clock_commonKnowledge envObs Y) X \\<phi>)\n     \\<longleftrightarrow> clock_repMC (ODList.toSet Y), s \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<phi>", "using XY s"], ["proof (prove)\nusing this:\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (1 subgoal):\n 1. (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<phi>", "proof(induct \\<phi> arbitrary: X s)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x X s.\n       \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kprop x))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Kprop x\n 2. \\<And>\\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Knot \\<phi>))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Knot \\<phi>\n 3. \\<And>\\<phi>1 \\<phi>2 X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>1)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>1;\n        \\<And>X s.\n           \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n           \\<Longrightarrow> (s \\<in> toSet\n (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n   (clock_commonKnowledge envObs Y) X \\<phi>2)) =\n                             clock_repMC (toSet Y), s \\<Turnstile> \\<phi>2;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kand \\<phi>1 \\<phi>2))) =\n                         clock_repMC\n                          (toSet Y), s \\<Turnstile> Kand \\<phi>1 \\<phi>2\n 4. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>K\\<^sub>x1a \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>K\\<^sub>x1a \\<phi>\n 5. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>", "case (Kknows a' \\<phi> X s)"], ["proof (state)\nthis:\n  \\<lbrakk>toSet ?X3 \\<subseteq> toSet Y; ?s3 \\<in> toSet ?X3\\<rbrakk>\n  \\<Longrightarrow> (?s3\n                     \\<in> toSet\n                            (eval_rec (clock_evalProp envVal)\n                              (clock_knowledge envObs Y)\n                              (clock_commonKnowledge envObs Y) ?X3\n                              \\<phi>)) =\n                    clock_repMC (toSet Y), ?s3 \\<Turnstile> \\<phi>\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (5 subgoals):\n 1. \\<And>x X s.\n       \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kprop x))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Kprop x\n 2. \\<And>\\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Knot \\<phi>))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Knot \\<phi>\n 3. \\<And>\\<phi>1 \\<phi>2 X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>1)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>1;\n        \\<And>X s.\n           \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n           \\<Longrightarrow> (s \\<in> toSet\n (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n   (clock_commonKnowledge envObs Y) X \\<phi>2)) =\n                             clock_repMC (toSet Y), s \\<Turnstile> \\<phi>2;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kand \\<phi>1 \\<phi>2))) =\n                         clock_repMC\n                          (toSet Y), s \\<Turnstile> Kand \\<phi>1 \\<phi>2\n 4. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>K\\<^sub>x1a \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>K\\<^sub>x1a \\<phi>\n 5. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>", "from \\<open>s \\<in> ODList.toSet X\\<close> clock_coEC_relation_image[OF subsetD[OF Kknows(2) Kknows(3)], where a=a']"], ["proof (chain)\npicking this:\n  s \\<in> toSet X\n  toSet (clock_knowledge envObs Y a' s) =\n  relations (clock_repMC (toSet Y)) a' `` {s}", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> toSet X\n  toSet (clock_knowledge envObs Y a' s) =\n  relations (clock_repMC (toSet Y)) a' `` {s}\n\ngoal (1 subgoal):\n 1. (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>K\\<^sub>a' \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>K\\<^sub>a' \\<phi>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s}\\<rbrakk>\n    \\<Longrightarrow> (ODList.difference (clock_knowledge envObs Y a' s)\n                        (eval_rec (clock_evalProp envVal)\n                          (clock_knowledge envObs Y)\n                          (clock_commonKnowledge envObs Y)\n                          (clock_knowledge envObs Y a' s) \\<phi>) =\n                       ODList.empty) =\n                      (\\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) ``\n {s}.\n                          clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     ODList.difference (clock_knowledge envObs Y a' s)\n      (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n        (clock_commonKnowledge envObs Y) (clock_knowledge envObs Y a' s)\n        \\<phi>) =\n     ODList.empty\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) ``\n{s}.\n                         clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference (clock_knowledge envObs Y a' s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_knowledge envObs Y a' s) \\<phi>) =\n                      ODList.empty", "apply (drule arg_cong[where f=\"ODList.toSet\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     toSet\n      (ODList.difference (clock_knowledge envObs Y a' s)\n        (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n          (clock_commonKnowledge envObs Y) (clock_knowledge envObs Y a' s)\n          \\<phi>)) =\n     toSet ODList.empty\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) ``\n{s}.\n                         clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference (clock_knowledge envObs Y a' s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_knowledge envObs Y a' s) \\<phi>) =\n                      ODList.empty", "apply (clarsimp simp: odlist_all_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y;\n        w' \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference (clock_knowledge envObs Y a' s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_knowledge envObs Y a' s) \\<phi>) =\n                      ODList.empty", "apply (cut_tac s3=\"w'\" and X3=\"clock_knowledge envObs Y a' s\" in Kknows.hyps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y;\n        w' \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_knowledge envObs Y a' s)\n                         \\<subseteq> toSet Y\n 2. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y;\n        w' \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet (clock_knowledge envObs Y a' s)\n 3. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y; w' \\<in> toSet Y;\n        (w' \\<in> toSet\n                   (eval_rec (clock_evalProp envVal)\n                     (clock_knowledge envObs Y)\n                     (clock_commonKnowledge envObs Y)\n                     (clock_knowledge envObs Y a' s) \\<phi>)) =\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 4. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference (clock_knowledge envObs Y a' s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_knowledge envObs Y a' s) \\<phi>) =\n                      ODList.empty", "using Kknows(2) Kknows(3)"], ["proof (prove)\nusing this:\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (4 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y;\n        w' \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_knowledge envObs Y a' s)\n                         \\<subseteq> toSet Y\n 2. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y;\n        w' \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet (clock_knowledge envObs Y a' s)\n 3. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        Restr (clock_repRels a') (toSet Y) `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_knowledge envObs Y a' s) \\<phi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet Y; w' \\<in> toSet Y;\n        (w' \\<in> toSet\n                   (eval_rec (clock_evalProp envVal)\n                     (clock_knowledge envObs Y)\n                     (clock_commonKnowledge envObs Y)\n                     (clock_knowledge envObs Y a' s) \\<phi>)) =\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 4. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference (clock_knowledge envObs Y a' s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_knowledge envObs Y a' s) \\<phi>) =\n                      ODList.empty", "apply (auto simp add: S5n_rels_closed[OF clock_repMC_S5n])[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_knowledge envObs Y a' s) =\n     Restr (clock_repRels a') (toSet Y) `` {s};\n     \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference (clock_knowledge envObs Y a' s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_knowledge envObs Y a' s) \\<phi>) =\n                      ODList.empty", "apply (clarsimp simp: toSet_eq_iff odlist_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet\n                                  (eval_rec (clock_evalProp envVal)\n                                    (clock_knowledge envObs Y)\n                                    (clock_commonKnowledge envObs Y)\n                                    (clock_knowledge envObs Y a' s) \\<phi>)", "apply (subst Kknows.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_knowledge envObs Y a' s)\n                         \\<subseteq> toSet Y\n 2. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet (clock_knowledge envObs Y a' s)\n 3. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), x \\<Turnstile> \\<phi>", "using Kknows(2) Kknows(3)"], ["proof (prove)\nusing this:\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_knowledge envObs Y a' s)\n                         \\<subseteq> toSet Y\n 2. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet (clock_knowledge envObs Y a' s)\n 3. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_knowledge envObs Y a' s) =\n        Restr (clock_repRels a') (toSet Y) `` {s};\n        \\<forall>w'\\<in>Restr (clock_repRels a') (toSet Y) `` {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x) \\<in> clock_repRels a'; s \\<in> toSet Y;\n        x \\<in> toSet Y\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), x \\<Turnstile> \\<phi>", "apply (auto simp add: S5n_rels_closed[OF clock_repMC_S5n])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (s \\<in> toSet\n            (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n              (clock_commonKnowledge envObs Y) X\n              \\<^bold>K\\<^sub>a' \\<phi>)) =\n  clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>K\\<^sub>a' \\<phi>\n\ngoal (4 subgoals):\n 1. \\<And>x X s.\n       \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kprop x))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Kprop x\n 2. \\<And>\\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Knot \\<phi>))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Knot \\<phi>\n 3. \\<And>\\<phi>1 \\<phi>2 X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>1)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>1;\n        \\<And>X s.\n           \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n           \\<Longrightarrow> (s \\<in> toSet\n (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n   (clock_commonKnowledge envObs Y) X \\<phi>2)) =\n                             clock_repMC (toSet Y), s \\<Turnstile> \\<phi>2;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kand \\<phi>1 \\<phi>2))) =\n                         clock_repMC\n                          (toSet Y), s \\<Turnstile> Kand \\<phi>1 \\<phi>2\n 4. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x X s.\n       \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kprop x))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Kprop x\n 2. \\<And>\\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Knot \\<phi>))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Knot \\<phi>\n 3. \\<And>\\<phi>1 \\<phi>2 X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>1)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>1;\n        \\<And>X s.\n           \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n           \\<Longrightarrow> (s \\<in> toSet\n (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n   (clock_commonKnowledge envObs Y) X \\<phi>2)) =\n                             clock_repMC (toSet Y), s \\<Turnstile> \\<phi>2;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kand \\<phi>1 \\<phi>2))) =\n                         clock_repMC\n                          (toSet Y), s \\<Turnstile> Kand \\<phi>1 \\<phi>2\n 4. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>", "case (Kcknows as \\<phi> X s)"], ["proof (state)\nthis:\n  \\<lbrakk>toSet ?X3 \\<subseteq> toSet Y; ?s3 \\<in> toSet ?X3\\<rbrakk>\n  \\<Longrightarrow> (?s3\n                     \\<in> toSet\n                            (eval_rec (clock_evalProp envVal)\n                              (clock_knowledge envObs Y)\n                              (clock_commonKnowledge envObs Y) ?X3\n                              \\<phi>)) =\n                    clock_repMC (toSet Y), ?s3 \\<Turnstile> \\<phi>\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (4 subgoals):\n 1. \\<And>x X s.\n       \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kprop x))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Kprop x\n 2. \\<And>\\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Knot \\<phi>))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Knot \\<phi>\n 3. \\<And>\\<phi>1 \\<phi>2 X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>1)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>1;\n        \\<And>X s.\n           \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n           \\<Longrightarrow> (s \\<in> toSet\n (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n   (clock_commonKnowledge envObs Y) X \\<phi>2)) =\n                             clock_repMC (toSet Y), s \\<Turnstile> \\<phi>2;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kand \\<phi>1 \\<phi>2))) =\n                         clock_repMC\n                          (toSet Y), s \\<Turnstile> Kand \\<phi>1 \\<phi>2\n 4. \\<And>x1a \\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>)) =\n                         clock_repMC\n                          (toSet\n                            Y), s \\<Turnstile> \\<^bold>C\\<^bsub>x1a\\<^esub> \\<phi>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "proof(cases \"as = Nil\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n 2. as \\<noteq> [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "case True"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n 2. as \\<noteq> [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "with \\<open>s \\<in> ODList.toSet X\\<close>"], ["proof (chain)\npicking this:\n  s \\<in> toSet X\n  as = []", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> toSet X\n  as = []\n\ngoal (1 subgoal):\n 1. (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "by clarsimp"], ["proof (state)\nthis:\n  (s \\<in> toSet\n            (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n              (clock_commonKnowledge envObs Y) X\n              \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n  clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "case False"], ["proof (state)\nthis:\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. as \\<noteq> [] \\<Longrightarrow>\n    (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "with \\<open>s \\<in> ODList.toSet X\\<close> clock_commonKnowledge_relation_image[OF subsetD[OF Kcknows(2) Kcknows(3)], where as=as]"], ["proof (chain)\npicking this:\n  s \\<in> toSet X\n  toSet (clock_commonKnowledge envObs Y as s) =\n  (\\<Union> (relations (clock_repMC (toSet Y)) ` set as))\\<^sup>+ `` {s}\n  as \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> toSet X\n  toSet (clock_commonKnowledge envObs Y as s) =\n  (\\<Union> (relations (clock_repMC (toSet Y)) ` set as))\\<^sup>+ `` {s}\n  as \\<noteq> []\n\ngoal (1 subgoal):\n 1. (s \\<in> toSet\n              (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n                (clock_commonKnowledge envObs Y) X\n                \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n    clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> (ODList.difference\n                        (clock_commonKnowledge envObs Y as s)\n                        (eval_rec (clock_evalProp envVal)\n                          (clock_knowledge envObs Y)\n                          (clock_commonKnowledge envObs Y)\n                          (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                       ODList.empty) =\n                      (\\<forall>w'\\<in>(Restr\n   (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n {s}.\n                          clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     ODList.difference (clock_commonKnowledge envObs Y as s)\n      (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n        (clock_commonKnowledge envObs Y)\n        (clock_commonKnowledge envObs Y as s) \\<phi>) =\n     ODList.empty\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w'\\<in>(Restr\n  (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n{s}.\n                         clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply (drule arg_cong[where f=\"ODList.toSet\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     toSet\n      (ODList.difference (clock_commonKnowledge envObs Y as s)\n        (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n          (clock_commonKnowledge envObs Y)\n          (clock_commonKnowledge envObs Y as s) \\<phi>)) =\n     toSet ODList.empty\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w'\\<in>(Restr\n  (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n{s}.\n                         clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply (clarsimp simp: odlist_all_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply (cut_tac s3=\"w'\" and X3=\"clock_commonKnowledge envObs Y as s\" in Kcknows.hyps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_commonKnowledge envObs Y as s)\n                         \\<subseteq> toSet Y\n 2. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet\n                                   (clock_commonKnowledge envObs Y as s)\n 3. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        (w' \\<in> toSet\n                   (eval_rec (clock_evalProp envVal)\n                     (clock_knowledge envObs Y)\n                     (clock_commonKnowledge envObs Y)\n                     (clock_commonKnowledge envObs Y as s) \\<phi>)) =\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 4. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "using Kcknows(2) Kcknows(3)"], ["proof (prove)\nusing this:\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (4 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_commonKnowledge envObs Y as s)\n                         \\<subseteq> toSet Y\n 2. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet\n                                   (clock_commonKnowledge envObs Y as s)\n 3. \\<And>w'.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        (w' \\<in> toSet\n                   (eval_rec (clock_evalProp envVal)\n                     (clock_knowledge envObs Y)\n                     (clock_commonKnowledge envObs Y)\n                     (clock_commonKnowledge envObs Y as s) \\<phi>)) =\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\n 4. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply (auto simp add: S5n_rels_closed[OF clock_repMC_S5n])[3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w' x.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet Y\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply (subst (asm) trancl_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w' x.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y) \\<union>\n                 (Restr (\\<Union> (clock_repRels ` set as))\n                   (toSet Y))\\<^sup>+ O\n                 Restr (\\<Union> (clock_repRels ` set as)) (toSet Y)) ``\n                {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet Y\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w' x.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y) \\<union>\n         (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ O\n         Restr (\\<Union> (clock_repRels ` set as)) (toSet Y)) ``\n        {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet Y\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w' x.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, w')\n        \\<in> Restr (\\<Union> (clock_repRels ` set as)) (toSet Y) \\<union>\n              (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+ O\n              Restr (\\<Union> (clock_repRels ` set as)) (toSet Y);\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet Y\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w' x.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s}\n        \\<subseteq> toSet\n                     (eval_rec (clock_evalProp envVal)\n                       (clock_knowledge envObs Y)\n                       (clock_commonKnowledge envObs Y)\n                       (clock_commonKnowledge envObs Y as s) \\<phi>);\n        (s, x)\n        \\<in> Restr (\\<Union> (clock_repRels ` set as)) (toSet Y) \\<union>\n              (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+ O\n              Restr (\\<Union> (clock_repRels ` set as)) (toSet Y);\n        (s, w')\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet Y\n 2. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "(* FIXME disgusting *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> toSet X;\n     toSet (clock_commonKnowledge envObs Y as s) =\n     (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ `` {s};\n     as \\<noteq> [];\n     \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                       (toSet Y))\\<^sup>+ ``\n                     {s}.\n        clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> ODList.difference\n                       (clock_commonKnowledge envObs Y as s)\n                       (eval_rec (clock_evalProp envVal)\n                         (clock_knowledge envObs Y)\n                         (clock_commonKnowledge envObs Y)\n                         (clock_commonKnowledge envObs Y as s) \\<phi>) =\n                      ODList.empty", "apply (clarsimp simp: toSet_eq_iff odlist_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet\n                                  (eval_rec (clock_evalProp envVal)\n                                    (clock_knowledge envObs Y)\n                                    (clock_commonKnowledge envObs Y)\n                                    (clock_commonKnowledge envObs Y as s)\n                                    \\<phi>)", "apply (subst Kcknows.hyps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_commonKnowledge envObs Y as s)\n                         \\<subseteq> toSet Y\n 2. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet (clock_commonKnowledge envObs Y as s)\n 3. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), x \\<Turnstile> \\<phi>", "using Kcknows(2) Kcknows(3)"], ["proof (prove)\nusing this:\n  toSet X \\<subseteq> toSet Y\n  s \\<in> toSet X\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> toSet (clock_commonKnowledge envObs Y as s)\n                         \\<subseteq> toSet Y\n 2. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet (clock_commonKnowledge envObs Y as s)\n 3. \\<And>x.\n       \\<lbrakk>s \\<in> toSet X;\n        toSet (clock_commonKnowledge envObs Y as s) =\n        (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+ ``\n        {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet Y), x \\<Turnstile> \\<phi>", "apply (auto simp add: S5n_rels_closed[OF clock_repMC_S5n])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, xa)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> toSet Y", "apply (subst (asm) trancl_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y) \\<union>\n                 (Restr (\\<Union> (clock_repRels ` set as))\n                   (toSet Y))\\<^sup>+ O\n                 Restr (\\<Union> (clock_repRels ` set as)) (toSet Y)) ``\n                {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, xa)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> toSet Y", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y) \\<union>\n                         (Restr (\\<Union> (clock_repRels ` set as))\n                           (toSet Y))\\<^sup>+ O\n                         Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y)) ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, xa)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> toSet Y", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, x)\n        \\<in> Restr (\\<Union> (clock_repRels ` set as)) (toSet Y) \\<union>\n              (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+ O\n              Restr (\\<Union> (clock_repRels ` set as)) (toSet Y);\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X;\n        (s, xa)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> toSet Y", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>toSet (clock_commonKnowledge envObs Y as s) =\n                (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet Y))\\<^sup>+ ``\n                {s};\n        as \\<noteq> [];\n        \\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet Y))\\<^sup>+ ``\n                        {s}.\n           clock_repMC (toSet Y), w' \\<Turnstile> \\<phi>;\n        (s, xa)\n        \\<in> Restr (\\<Union> (clock_repRels ` set as)) (toSet Y) \\<union>\n              (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet Y))\\<^sup>+ O\n              Restr (\\<Union> (clock_repRels ` set as)) (toSet Y);\n        (s, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as)) (toSet Y))\\<^sup>+;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> toSet Y", "apply auto[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "(* FIXME disgusting *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (s \\<in> toSet\n            (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n              (clock_commonKnowledge envObs Y) X\n              \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n  clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<in> toSet\n            (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n              (clock_commonKnowledge envObs Y) X\n              \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>)) =\n  clock_repMC (toSet Y), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n\ngoal (3 subgoals):\n 1. \\<And>x X s.\n       \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kprop x))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Kprop x\n 2. \\<And>\\<phi> X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Knot \\<phi>))) =\n                         clock_repMC (toSet Y), s \\<Turnstile> Knot \\<phi>\n 3. \\<And>\\<phi>1 \\<phi>2 X s.\n       \\<lbrakk>\\<And>X s.\n                   \\<lbrakk>toSet X \\<subseteq> toSet Y;\n                    s \\<in> toSet X\\<rbrakk>\n                   \\<Longrightarrow> (s\n\\<in> toSet\n       (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n         (clock_commonKnowledge envObs Y) X \\<phi>1)) =\n                                     clock_repMC\n(toSet Y), s \\<Turnstile> \\<phi>1;\n        \\<And>X s.\n           \\<lbrakk>toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n           \\<Longrightarrow> (s \\<in> toSet\n (eval_rec (clock_evalProp envVal) (clock_knowledge envObs Y)\n   (clock_commonKnowledge envObs Y) X \\<phi>2)) =\n                             clock_repMC (toSet Y), s \\<Turnstile> \\<phi>2;\n        toSet X \\<subseteq> toSet Y; s \\<in> toSet X\\<rbrakk>\n       \\<Longrightarrow> (s \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs Y)\n                                     (clock_commonKnowledge envObs Y) X\n                                     (Kand \\<phi>1 \\<phi>2))) =\n                         clock_repMC\n                          (toSet Y), s \\<Turnstile> Kand \\<phi>1 \\<phi>2", "qed simp_all"], ["", "lemma trc_aux:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n  shows \"ODList.toSet (big_union (clock_commonKnowledge envObs cec as) (toList aec)) \\<subseteq> ODList.toSet cec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (big_union (clock_commonKnowledge envObs cec as) (toList aec))\n    \\<subseteq> toSet cec", "apply (clarsimp simp: toSet_def[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> toSet aec;\n        x \\<in> toSet (clock_commonKnowledge envObs cec as xa)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet cec", "apply (subst (asm) clock_commonKnowledge_relation_image)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa. xa \\<in> toSet aec \\<Longrightarrow> xa \\<in> toSet cec\n 2. \\<And>x xa.\n       \\<lbrakk>xa \\<in> toSet aec;\n        x \\<in> (\\<Union>\n                  (relations (clock_repMC (toSet cec)) ` set as))\\<^sup>+ ``\n                {xa}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet cec", "apply (erule aec_cec_subset[OF tC aec cec])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> toSet aec;\n        x \\<in> (\\<Union>\n                  (relations (clock_repMC (toSet cec)) ` set as))\\<^sup>+ ``\n                {xa}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet cec", "apply (subst (asm) trancl_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> toSet aec;\n        x \\<in> (\\<Union>\n                  (relations (clock_repMC (toSet cec)) ` set as) \\<union>\n                 (\\<Union>\n                   (relations (clock_repMC (toSet cec)) ` set as))\\<^sup>+ O\n                 \\<Union> (relations (clock_repMC (toSet cec)) ` set as)) ``\n                {xa}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet cec", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>xa \\<in> toSet aec;\n        x \\<in> (\\<Union>\n                  (relations (clock_repMC (toSet cec)) ` set as) \\<union>\n                 (\\<Union>\n                   (relations (clock_repMC (toSet cec)) ` set as))\\<^sup>+ O\n                 \\<Union> (relations (clock_repMC (toSet cec)) ` set as)) ``\n                {xa}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet cec", "apply (auto simp: agent_abs_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma clock_repMC_aec:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and x: \"x \\<in> ODList.toSet aec\"\n      and xy: \"(x, y) \\<in> relations (clock_repMC (ODList.toSet cec)) a\"\n  shows \"y \\<in> ODList.toSet aec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> toSet aec", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n  x \\<in> toSet aec\n  (x, y) \\<in> relations (clock_repMC (toSet cec)) a\n\ngoal (1 subgoal):\n 1. y \\<in> toSet aec", "unfolding clock_repRels_def agent_abs_def common_abs_def"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t'.\n          uu_ = tLast t' \\<and>\n          t' \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t)\n  toSet cec = clock_commonAbs t\n  x \\<in> toSet aec\n  (x, y)\n  \\<in> relations\n         (mkKripke (toSet cec)\n           (\\<lambda>a.\n               rel_ext (\\<lambda>(s, s'). envObs a s = envObs a s'))\n           envVal)\n         a\n\ngoal (1 subgoal):\n 1. y \\<in> toSet aec", "by auto"], ["", "lemma clock_repMC_cec:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and x: \"x \\<in> ODList.toSet aec\"\n      and y: \"y \\<in> ODList.toSet aec\"\n  shows \"(x, y) \\<in> relations (clock_repMC (ODList.toSet cec)) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> relations (clock_repMC (toSet cec)) a", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n  x \\<in> toSet aec\n  y \\<in> toSet aec\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> relations (clock_repMC (toSet cec)) a", "unfolding clock_repRels_def agent_abs_def common_abs_def"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t'.\n          uu_ = tLast t' \\<and>\n          t' \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t)\n  toSet cec = clock_commonAbs t\n  x \\<in> toSet aec\n  y \\<in> toSet aec\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> relations\n           (mkKripke (toSet cec)\n             (\\<lambda>a.\n                 rel_ext (\\<lambda>(s, s'). envObs a s = envObs a s'))\n             envVal)\n           a", "by auto"], ["", "lemma evalS_models:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and subj_phi: \"subjective a \\<phi>\"\n      and s: \"s \\<in> ODList.toSet aec\"\n  shows \"evalS (clock_evalProp envVal) (clock_knowledge envObs cec) (clock_commonKnowledge envObs cec) aec \\<phi>\n     \\<longleftrightarrow> clock_repMC (ODList.toSet cec), s \\<Turnstile> \\<phi>\" (is \"?lhs \\<phi> = ?rhs \\<phi>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec \\<phi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<phi>", "using subj_phi s aec cec"], ["proof (prove)\nusing this:\n  subjective a \\<phi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec \\<phi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<phi>", "proof(induct \\<phi> rule: subjective.induct[case_names Kprop Knot Kand Kknows Kcknows])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a a' f.\n       \\<lbrakk>subjective a \\<^bold>K\\<^sub>a' f; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>K\\<^sub>a' f =\n                         clock_repMC\n                          (toSet cec), s \\<Turnstile> \\<^bold>K\\<^sub>a' f\n 5. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "case (Kknows a a' \\<psi>)"], ["proof (state)\nthis:\n  subjective a \\<^bold>K\\<^sub>a' \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (5 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a a' f.\n       \\<lbrakk>subjective a \\<^bold>K\\<^sub>a' f; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>K\\<^sub>a' f =\n                         clock_repMC\n                          (toSet cec), s \\<Turnstile> \\<^bold>K\\<^sub>a' f\n 5. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec \\<^bold>K\\<^sub>a' \\<psi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<^bold>K\\<^sub>a' \\<psi>", "apply (clarsimp simp: toSet_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (toSet aec\n     \\<subseteq> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec) aec \\<psi>)) =\n    (\\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n        clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec\n                   \\<psi>) \\<Longrightarrow>\n    \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>\n 2. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>\n 2. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply (subgoal_tac \"w' \\<in> ODList.toSet aec\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec; w' \\<in> toSet aec\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>\n 2. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet aec\n 3. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply (drule_tac c=\"w'\" in subsetD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>(s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec; w' \\<in> toSet aec\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet aec\n 2. \\<And>w'.\n       \\<lbrakk>(s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec; w' \\<in> toSet aec;\n        w' \\<in> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec) aec \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>\n 3. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet aec\n 4. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>(s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec; w' \\<in> toSet aec;\n        w' \\<in> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec) aec \\<psi>)\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>\n 2. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet aec\n 3. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply (simp add: eval_rec_models[OF subsetI[OF aec_cec_subset[OF tC aec cec]]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> w' \\<in> toSet aec\n 2. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply (rule clock_repMC_aec[OF tC Kknows(3) Kknows(4), rotated, where x=s])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> (s, w') \\<in> relations (clock_repMC (toSet cec)) a\n 2. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> s \\<in> toSet aec\n 3. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "using Kknows"], ["proof (prove)\nusing this:\n  subjective a \\<^bold>K\\<^sub>a' \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (3 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> (s, w') \\<in> relations (clock_repMC (toSet cec)) a\n 2. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> s \\<in> toSet aec\n 3. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> s \\<in> toSet aec\n 2. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "using Kknows"], ["proof (prove)\nusing this:\n  subjective a \\<^bold>K\\<^sub>a' \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (2 subgoals):\n 1. \\<And>w'.\n       \\<lbrakk>toSet aec\n                \\<subseteq> toSet\n                             (eval_rec (clock_evalProp envVal)\n                               (clock_knowledge envObs cec)\n                               (clock_commonKnowledge envObs cec) aec\n                               \\<psi>);\n        (s, w') \\<in> clock_repRels a'; s \\<in> toSet cec;\n        w' \\<in> toSet cec\\<rbrakk>\n       \\<Longrightarrow> s \\<in> toSet aec\n 2. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n       clock_repMC (toSet cec), w' \\<Turnstile> \\<psi> \\<Longrightarrow>\n    toSet aec\n    \\<subseteq> toSet\n                 (eval_rec (clock_evalProp envVal)\n                   (clock_knowledge envObs cec)\n                   (clock_commonKnowledge envObs cec) aec \\<psi>)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n                   clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>;\n        x \\<in> toSet aec\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet\n                                  (eval_rec (clock_evalProp envVal)\n                                    (clock_knowledge envObs cec)\n                                    (clock_commonKnowledge envObs cec) aec\n                                    \\<psi>)", "apply (simp add: eval_rec_models[OF subsetI[OF aec_cec_subset[OF tC aec cec]]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n                   clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>;\n        x \\<in> toSet aec\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet cec), x \\<Turnstile> \\<psi>", "using tC Kknows"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  subjective a \\<^bold>K\\<^sub>a' \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>w'\\<in>Restr (clock_repRels a') (toSet cec) `` {s}.\n                   clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>;\n        x \\<in> toSet aec\\<rbrakk>\n       \\<Longrightarrow> clock_repMC (toSet cec), x \\<Turnstile> \\<psi>", "apply (clarsimp simp: agent_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t' t'a.\n       \\<lbrakk>\\<forall>w'\\<in>Restr (clock_repRels a') (common_abs t) ``\n                                {tLast t'a}.\n                   clock_repMC (common_abs t), w' \\<Turnstile> \\<psi>;\n        t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t)\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (common_abs t), tLast t' \\<Turnstile> \\<psi>", "apply (erule (1) ballE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr (clock_repRels a') (common_abs t) ``\n                 {tLast t'a}\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (common_abs t), tLast t' \\<Turnstile> \\<psi>", "using Kknows"], ["proof (prove)\nusing this:\n  subjective a \\<^bold>K\\<^sub>a' \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr (clock_repRels a') (common_abs t) ``\n                 {tLast t'a}\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (common_abs t), tLast t' \\<Turnstile> \\<psi>", "apply (cut_tac x=\"tLast t'\" and y=\"tLast t'a\" in clock_repMC_cec[OF tC Kknows(3) Kknows(4)])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr (clock_repRels a') (common_abs t) `` {tLast t'a};\n        subjective a \\<^bold>K\\<^sub>a' \\<psi>; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> tLast t' \\<in> toSet aec\n 2. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr (clock_repRels a') (common_abs t) `` {tLast t'a};\n        subjective a \\<^bold>K\\<^sub>a' \\<psi>; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> tLast t'a \\<in> toSet aec\n 3. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr (clock_repRels a') (common_abs t) `` {tLast t'a};\n        subjective a \\<^bold>K\\<^sub>a' \\<psi>; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t;\n        (tLast t', tLast t'a)\n        \\<in> relations (clock_repMC (toSet cec)) a\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (common_abs t), tLast t' \\<Turnstile> \\<psi>", "unfolding clock_repRels_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr\n                  (rel_ext (\\<lambda>(s, s'). envObs a' s = envObs a' s'))\n                  (common_abs t) ``\n                 {tLast t'a};\n        subjective a \\<^bold>K\\<^sub>a' \\<psi>; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> tLast t' \\<in> toSet aec\n 2. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr\n                  (rel_ext (\\<lambda>(s, s'). envObs a' s = envObs a' s'))\n                  (common_abs t) ``\n                 {tLast t'a};\n        subjective a \\<^bold>K\\<^sub>a' \\<psi>; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> tLast t'a \\<in> toSet aec\n 3. \\<And>t' t'a.\n       \\<lbrakk>t \\<in> Clock.jkbpC; a = a';\n        toSet aec =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                uu_ = tLast t' \\<and>\n                t' \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a' (tLast t') = envObs a' (tLast t));\n        toSet cec = common_abs t; s = tLast t'a; t' \\<in> Clock.jkbpC;\n        t'a \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a' (tLast t') = envObs a' (tLast t); tLength t'a = tLength t;\n        envObs a' (tLast t'a) = envObs a' (tLast t);\n        tLast t'\n        \\<notin> Restr\n                  (rel_ext (\\<lambda>(s, s'). envObs a' s = envObs a' s'))\n                  (common_abs t) ``\n                 {tLast t'a};\n        subjective a \\<^bold>K\\<^sub>a' \\<psi>; s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t;\n        (tLast t', tLast t'a)\n        \\<in> relations\n               (mkKripke (toSet cec)\n                 (\\<lambda>a.\n                     rel_ext (\\<lambda>(s, s'). envObs a s = envObs a s'))\n                 envVal)\n               a\\<rbrakk>\n       \\<Longrightarrow> mkKripke (common_abs t)\n                          (\\<lambda>a.\n                              rel_ext\n                               (\\<lambda>(s, s'). envObs a s = envObs a s'))\n                          envVal, tLast t' \\<Turnstile> \\<psi>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec \\<^bold>K\\<^sub>a' \\<psi> =\n  clock_repMC (toSet cec), s \\<Turnstile> \\<^bold>K\\<^sub>a' \\<psi>\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "case (Kcknows a as \\<psi>)"], ["proof (state)\nthis:\n  subjective a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "have \"?lhs (Kcknows as \\<psi>)\n      = (\\<forall>y\\<in>ODList.toSet aec.\n           \\<forall>x\\<in>(\\<Union>a\\<in>set as. relations (clock_repMC (ODList.toSet cec)) a)\\<^sup>+ `` {y}.\n              x \\<in> ODList.toSet (eval_rec (clock_evalProp envVal) (clock_knowledge envObs cec) (clock_commonKnowledge envObs cec)\n                       (big_union (clock_commonKnowledge envObs cec as) (toList aec)) \\<psi>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec\n     \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n    (\\<forall>y\\<in>toSet aec.\n        \\<forall>x\\<in>(\\<Union>\n                         (relations (clock_repMC (toSet cec)) `\n                          set as))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>))", "(* FIXME dreaming of a cong rule here. *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec\n     \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n    (\\<forall>y\\<in>toSet aec.\n        \\<forall>x\\<in>(\\<Union>\n                         (relations (clock_repMC (toSet cec)) `\n                          set as))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>))", "using toSet_def[symmetric]"], ["proof (prove)\nusing this:\n  set (toList ?X) = toSet ?X\n\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec\n     \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n    (\\<forall>y\\<in>toSet aec.\n        \\<forall>x\\<in>(\\<Union>\n                         (relations (clock_repMC (toSet cec)) `\n                          set as))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>))", "apply (clarsimp simp: toSet_eq_iff toSet_def[symmetric] subset_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>toSet aec.\n        \\<forall>x\\<in>toSet (clock_commonKnowledge envObs cec as y).\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>)) =\n    (\\<forall>y\\<in>toSet aec.\n        \\<forall>x\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                         (toSet cec))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>))", "apply (rule ball_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> toSet aec \\<Longrightarrow>\n       (\\<forall>x\\<in>toSet (clock_commonKnowledge envObs cec as y).\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>)) =\n       (\\<forall>x\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                         (toSet cec))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>))", "apply (rule ball_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       y \\<in> toSet aec \\<Longrightarrow>\n       toSet (clock_commonKnowledge envObs cec as y) =\n       (Restr (\\<Union> (clock_repRels ` set as)) (toSet cec))\\<^sup>+ ``\n       {y}\n 2. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>))", "apply (subst clock_commonKnowledge_relation_image[OF aec_cec_subset[OF tC Kcknows(3) Kcknows(4)]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y. y \\<in> toSet aec \\<Longrightarrow> y \\<in> toSet aec\n 2. \\<And>y.\n       y \\<in> toSet aec \\<Longrightarrow>\n       (\\<Union> (relations (clock_repMC (toSet cec)) ` set as))\\<^sup>+ ``\n       {y} =\n       (Restr (\\<Union> (clock_repRels ` set as)) (toSet cec))\\<^sup>+ ``\n       {y}\n 3. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec\n   \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n  (\\<forall>y\\<in>toSet aec.\n      \\<forall>x\\<in>(\\<Union>\n                       (relations (clock_repMC (toSet cec)) `\n                        set as))\\<^sup>+ ``\n                     {y}.\n         x \\<in> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec)\n                    (big_union (clock_commonKnowledge envObs cec as)\n                      (toList aec))\n                    \\<psi>))\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "also"], ["proof (state)\nthis:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec\n   \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n  (\\<forall>y\\<in>toSet aec.\n      \\<forall>x\\<in>(\\<Union>\n                       (relations (clock_repMC (toSet cec)) `\n                        set as))\\<^sup>+ ``\n                     {y}.\n         x \\<in> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec)\n                    (big_union (clock_commonKnowledge envObs cec as)\n                      (toList aec))\n                    \\<psi>))\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "have \"... = (\\<forall>s\\<in>ODList.toSet aec. clock_repMC (ODList.toSet cec), s \\<Turnstile> Kcknows as \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<in>toSet aec.\n        \\<forall>x\\<in>(\\<Union>\n                         (relations (clock_repMC (toSet cec)) `\n                          set as))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>)) =\n    (\\<forall>s\\<in>toSet aec.\n        clock_repMC\n         (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>)", "apply (rule ball_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> toSet aec \\<Longrightarrow>\n       (\\<forall>x\\<in>(\\<Union>\n                         (relations (clock_repMC (toSet cec)) `\n                          set as))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>)) =\n       clock_repMC\n        (toSet cec), y \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> toSet aec \\<Longrightarrow>\n       (\\<forall>x\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                         (toSet cec))\\<^sup>+ ``\n                       {y}.\n           x \\<in> toSet\n                    (eval_rec (clock_evalProp envVal)\n                      (clock_knowledge envObs cec)\n                      (clock_commonKnowledge envObs cec)\n                      (big_union (clock_commonKnowledge envObs cec as)\n                        (toList aec))\n                      \\<psi>)) =\n       (\\<forall>w'\\<in>(Restr (\\<Union> (clock_repRels ` set as))\n                          (toSet cec))\\<^sup>+ ``\n                        {y}.\n           clock_repMC (toSet cec), w' \\<Turnstile> \\<psi>)", "apply (rule ball_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         clock_repMC (toSet cec), x \\<Turnstile> \\<psi>", "apply (subst eval_rec_models[OF trc_aux[OF tC Kcknows(3) Kcknows(4), where as=as], symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet\n                                  (big_union\n                                    (clock_commonKnowledge envObs cec as)\n                                    (toList aec))\n 2. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>))", "apply (simp add: toSet_def[symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        (y, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet cec))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>toSet aec.\n                            x \\<in> toSet\n                                     (clock_commonKnowledge envObs cec as\n xa)\n 2. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>))", "apply (rule_tac x=y in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        (y, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet cec))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> toSet\n                                  (clock_commonKnowledge envObs cec as y)\n 2. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        (y, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet cec))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> y \\<in> toSet aec\n 3. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>))", "apply (subst clock_commonKnowledge_relation_image[OF aec_cec_subset[OF tC Kcknows(3) Kcknows(4)]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        (y, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet cec))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> y \\<in> toSet aec\n 2. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        (y, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet cec))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> x \\<in> (\\<Union>\n                                   (relations (clock_repMC (toSet cec)) `\n                                    set as))\\<^sup>+ ``\n                                 {y}\n 3. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        (y, x)\n        \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                (toSet cec))\\<^sup>+\\<rbrakk>\n       \\<Longrightarrow> y \\<in> toSet aec\n 4. \\<And>y x.\n       \\<lbrakk>y \\<in> toSet aec;\n        x \\<in> (Restr (\\<Union> (clock_repRels ` set as))\n                  (toSet cec))\\<^sup>+ ``\n                {y}\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>)) =\n                         (x \\<in> toSet\n                                   (eval_rec (clock_evalProp envVal)\n                                     (clock_knowledge envObs cec)\n                                     (clock_commonKnowledge envObs cec)\n                                     (big_union\n (clock_commonKnowledge envObs cec as) (toList aec))\n                                     \\<psi>))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>y\\<in>toSet aec.\n      \\<forall>x\\<in>(\\<Union>\n                       (relations (clock_repMC (toSet cec)) `\n                        set as))\\<^sup>+ ``\n                     {y}.\n         x \\<in> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec)\n                    (big_union (clock_commonKnowledge envObs cec as)\n                      (toList aec))\n                    \\<psi>)) =\n  (\\<forall>s\\<in>toSet aec.\n      clock_repMC\n       (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>)\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "also"], ["proof (state)\nthis:\n  (\\<forall>y\\<in>toSet aec.\n      \\<forall>x\\<in>(\\<Union>\n                       (relations (clock_repMC (toSet cec)) `\n                        set as))\\<^sup>+ ``\n                     {y}.\n         x \\<in> toSet\n                  (eval_rec (clock_evalProp envVal)\n                    (clock_knowledge envObs cec)\n                    (clock_commonKnowledge envObs cec)\n                    (big_union (clock_commonKnowledge envObs cec as)\n                      (toList aec))\n                    \\<psi>)) =\n  (\\<forall>s\\<in>toSet aec.\n      clock_repMC\n       (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>)\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "have \"... = clock_repMC (ODList.toSet cec), s \\<Turnstile> Kknows a (Kcknows as \\<psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>toSet aec.\n        clock_repMC\n         (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>) =\n    clock_repMC\n     (toSet\n       cec), s \\<Turnstile> \\<^bold>K\\<^sub>a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>", "using clock_repMC_aec[OF tC Kcknows(3) Kcknows(4) Kcknows(2)]\n          clock_repMC_cec[OF tC Kcknows(3) Kcknows(4) Kcknows(2)]"], ["proof (prove)\nusing this:\n  (s, ?y) \\<in> relations (clock_repMC (toSet cec)) a \\<Longrightarrow>\n  ?y \\<in> toSet aec\n  ?y \\<in> toSet aec \\<Longrightarrow>\n  (s, ?y) \\<in> relations (clock_repMC (toSet cec)) a\n\ngoal (1 subgoal):\n 1. (\\<forall>s\\<in>toSet aec.\n        clock_repMC\n         (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>) =\n    clock_repMC\n     (toSet\n       cec), s \\<Turnstile> \\<^bold>K\\<^sub>a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>", "by (auto cong: ball_cong)"], ["proof (state)\nthis:\n  (\\<forall>s\\<in>toSet aec.\n      clock_repMC\n       (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>) =\n  clock_repMC\n   (toSet\n     cec), s \\<Turnstile> \\<^bold>K\\<^sub>a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "also"], ["proof (state)\nthis:\n  (\\<forall>s\\<in>toSet aec.\n      clock_repMC\n       (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>) =\n  clock_repMC\n   (toSet\n     cec), s \\<Turnstile> \\<^bold>K\\<^sub>a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "have \"... = clock_repMC (ODList.toSet cec), s \\<Turnstile> Kcknows as \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_repMC\n     (toSet\n       cec), s \\<Turnstile> \\<^bold>K\\<^sub>a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n    clock_repMC\n     (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>", "apply (rule S5n_common_knowledge_fixed_point_simpler[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. S5n (clock_repMC (toSet cec))\n 2. s \\<in> worlds (clock_repMC (toSet cec))\n 3. a \\<in> set as", "using Kcknows"], ["proof (prove)\nusing this:\n  subjective a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n  s \\<in> toSet aec\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (3 subgoals):\n 1. S5n (clock_repMC (toSet cec))\n 2. s \\<in> worlds (clock_repMC (toSet cec))\n 3. a \\<in> set as", "apply (auto intro: aec_cec_subset[OF tC Kcknows(3) Kcknows(4) Kcknows(2)])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock_repMC\n   (toSet\n     cec), s \\<Turnstile> \\<^bold>K\\<^sub>a \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n  clock_repMC (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g\n 4. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         clock_repMC\n                          (toSet\n                            cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "finally"], ["proof (chain)\npicking this:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec\n   \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n  clock_repMC (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>", "show ?case"], ["proof (prove)\nusing this:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec\n   \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n  clock_repMC (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n\ngoal (1 subgoal):\n 1. evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n     (clock_commonKnowledge envObs cec) aec\n     \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n    clock_repMC\n     (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>", "."], ["proof (state)\nthis:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec\n   \\<^bold>C\\<^bsub>as\\<^esub> \\<psi> =\n  clock_repMC (toSet cec), s \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<psi>\n\ngoal (3 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Kprop p) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        subjective a (Knot f); s \\<in> toSet aec; toSet aec = agent_abs a t;\n        toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec (Knot f) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f; s \\<in> toSet aec;\n                 toSet aec = agent_abs a t;\n                 toSet cec = common_abs t\\<rbrakk>\n                \\<Longrightarrow> evalS (clock_evalProp envVal)\n                                   (clock_knowledge envObs cec)\n                                   (clock_commonKnowledge envObs cec) aec\n                                   f =\n                                  clock_repMC (toSet cec), s \\<Turnstile> f;\n        \\<lbrakk>subjective a g; s \\<in> toSet aec;\n         toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n        \\<Longrightarrow> evalS (clock_evalProp envVal)\n                           (clock_knowledge envObs cec)\n                           (clock_commonKnowledge envObs cec) aec g =\n                          clock_repMC (toSet cec), s \\<Turnstile> g;\n        subjective a (Kand f g); s \\<in> toSet aec;\n        toSet aec = agent_abs a t; toSet cec = common_abs t\\<rbrakk>\n       \\<Longrightarrow> evalS (clock_evalProp envVal)\n                          (clock_knowledge envObs cec)\n                          (clock_commonKnowledge envObs cec) aec\n                          (Kand f g) =\n                         clock_repMC (toSet cec), s \\<Turnstile> Kand f g", "qed simp_all"], ["", "(*>*)"], ["", "lemma eval_models:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n      and subj_phi: \"subjective a \\<phi>\"\n      and s: \"s \\<in> ODList.toSet aec\"\n  shows \"eval envVal envObs (cec, aec) \\<phi>\n     \\<longleftrightarrow> clock_repMC (ODList.toSet cec), s \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval envVal envObs (cec, aec) \\<phi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval envVal envObs (cec, aec) \\<phi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<phi>", "unfolding eval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (cec, aec) of\n     (cec, aec) \\<Rightarrow>\n       evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n        (clock_commonKnowledge envObs cec) aec)\n     \\<phi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<phi>", "using evalS_models[OF tC aec cec subj_phi s]"], ["proof (prove)\nusing this:\n  evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n   (clock_commonKnowledge envObs cec) aec \\<phi> =\n  clock_repMC (toSet cec), s \\<Turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. (case (cec, aec) of\n     (cec, aec) \\<Rightarrow>\n       evalS (clock_evalProp envVal) (clock_knowledge envObs cec)\n        (clock_commonKnowledge envObs cec) aec)\n     \\<phi> =\n    clock_repMC (toSet cec), s \\<Turnstile> \\<phi>", "apply (simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* **************************************** *)"], ["", "subsubsection\\<open>Simulated actions\\<close>"], ["", "text\\<open>\n\nFrom a common equivalence class and a subjective equivalence class for\nagent @{term \"a\"}, we can compute the actions enabled for @{term \"a\"}:\n\n\\<close>"], ["", "definition (in -)\n  clock_simAction :: \"('a, 'p, 'aAct) JKBP \\<Rightarrow> (('s :: linorder) \\<Rightarrow> 'p \\<Rightarrow> bool)\n                  \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> 'obs)\n                  \\<Rightarrow> 'a \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> 'aAct list\"\nwhere\n  \"clock_simAction jkbp envVal envObs \\<equiv> \\<lambda>a (Y, X).\n     [ action gc. gc \\<leftarrow> jkbp a, eval envVal envObs (Y, X) (guard gc) ]\""], ["", "(*<*)"], ["", "abbreviation\n  clock_simAction :: \"'a \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> 'aAct list\"\nwhere\n  \"clock_simAction \\<equiv> ClockView.clock_simAction jkbp envVal envObs\""], ["", "(*>*)"], ["", "text\\<open>\n\nUsing the above result about evaluation, we can relate \\<open>clock_simAction\\<close> to @{term \"jAction\"}. Firstly, \\<open>clock_simAction\\<close> behaves the same as @{term \"jAction\"} using the\n@{term \"clock_repMC\"} structure:\n\n\\<close>"], ["", "lemma clock_simAction_jAction:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and aec: \"ODList.toSet aec = agent_abs a t\"\n      and cec: \"ODList.toSet cec = common_abs t\"\n  shows \"set (clock_simAction a (cec, aec))\n       = set (jAction (clock_repMC (ODList.toSet cec)) (tLast t) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) =\n    set (jAction (clock_repMC (toSet cec)) (tLast t) a)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) =\n    set (jAction (clock_repMC (toSet cec)) (tLast t) a)", "unfolding clock_simAction_def jAction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (case (cec, aec) of\n         (Y, X) \\<Rightarrow>\n           concat\n            (map (\\<lambda>gc.\n                     if eval envVal envObs (Y, X) (guard gc)\n                     then [action gc] else [])\n              (jkbp a))) =\n    set (concat\n          (map (\\<lambda>gc.\n                   if clock_repMC (toSet cec), tLast t \\<Turnstile> guard gc\n                   then [action gc] else [])\n            (jkbp a)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc. eval envVal envObs (cec, aec) (guard gc)).\n        {action x}) =\n    (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc. eval envVal envObs (cec, aec) (guard gc)).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    clock_repMC\n                                     (toSet\n cec), tLast t \\<Turnstile> guard gc).\n                    {action x})\n 2. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (jkbp a) \\<inter>\n  rel_ext\n   (\\<lambda>gc. clock_repMC (toSet cec), tLast t \\<Turnstile> guard gc).\n                            action xa = action x\n 2. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "apply (rule_tac x=xa in bexI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> action xa = action xa\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set (jkbp a) \\<inter>\n                                  rel_ext\n                                   (\\<lambda>gc.\n clock_repMC (toSet cec), tLast t \\<Turnstile> guard gc)\n 3. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set (jkbp a) \\<inter>\n                                  rel_ext\n                                   (\\<lambda>gc.\n clock_repMC (toSet cec), tLast t \\<Turnstile> guard gc)\n 2. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (toSet cec), tLast t \\<Turnstile> guard xa\n 2. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "apply (subst eval_models[OF tC aec cec, symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> subjective a (guard xa)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> tLast t \\<in> toSet aec\n 3. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> eval envVal envObs (cec, aec) (guard xa)\n 4. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "using tC aec cec subj"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n  \\<forall>a gc.\n     gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc)\n\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> subjective a (guard xa)\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> tLast t \\<in> toSet aec\n 3. \\<And>xa.\n       \\<lbrakk>xa \\<in> set (jkbp a);\n        eval envVal envObs (cec, aec) (guard xa)\\<rbrakk>\n       \\<Longrightarrow> eval envVal envObs (cec, aec) (guard xa)\n 4. (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                   rel_ext\n                    (\\<lambda>gc.\n                        clock_repMC\n                         (toSet cec), tLast t \\<Turnstile> guard gc).\n        {action x})\n    \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                               rel_ext\n                                (\\<lambda>gc.\n                                    eval envVal envObs (cec, aec)\n                                     (guard gc)).\n                    {action x})", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n     toSet cec = common_abs t;\n     \\<forall>a gc.\n        gc \\<in> set (jkbp a) \\<longrightarrow>\n        subjective a (guard gc)\\<rbrakk>\n    \\<Longrightarrow> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n                                     rel_ext\n(\\<lambda>gc. clock_repMC (common_abs t), tLast t \\<Turnstile> guard gc).\n                          {action x})\n                      \\<subseteq> (\\<Union>x\\<in>set (jkbp a) \\<inter>\n           rel_ext (\\<lambda>gc. eval envVal envObs (cec, aec) (guard gc)).\n{action x})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set (jkbp a) \\<inter>\n  rel_ext (\\<lambda>gc. eval envVal envObs (cec, aec) (guard gc)).\n                            action xa = action x", "apply (rule_tac x=xa in bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> action xa = action xa\n 2. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set (jkbp a) \\<inter>\n                                  rel_ext\n                                   (\\<lambda>gc.\n eval envVal envObs (cec, aec) (guard gc))", "apply (rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set (jkbp a) \\<inter>\n                                  rel_ext\n                                   (\\<lambda>gc.\n eval envVal envObs (cec, aec) (guard gc))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> eval envVal envObs (cec, aec) (guard xa)", "apply (subst eval_models[OF tC aec cec])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> subjective a (guard xa)\n 2. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> ?s58 xa \\<in> toSet aec\n 3. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (toSet cec), ?s58 xa \\<Turnstile> guard xa", "using tC aec cec subj"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n  \\<forall>a gc.\n     gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc)\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> subjective a (guard xa)\n 2. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> ?s58 xa \\<in> toSet aec\n 3. \\<And>xa.\n       \\<lbrakk>t \\<in> Clock.jkbpC; toSet aec = agent_abs a t;\n        toSet cec = common_abs t;\n        \\<forall>a gc.\n           gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc);\n        xa \\<in> set (jkbp a);\n        clock_repMC (common_abs t), tLast t \\<Turnstile> guard xa\\<rbrakk>\n       \\<Longrightarrow> clock_repMC\n                          (toSet cec), ?s58 xa \\<Turnstile> guard xa", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma clock_submodel_aux:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and s: \"s \\<in> worlds (clock_simMCt t)\"\n  shows \"gen_model Clock.MCS s = gen_model (clock_simMCt t) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_model clock_simMC s = gen_model (clock_simMCt t) s", "proof(rule gen_model_subset[where T=\"clock_jkbpCSt t\"])"], ["proof (state)\ngoal (8 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. \\<And>a.\n       Restr (relations clock_simMC a) (clock_jkbpCSt t) =\n       Restr (relations (clock_simMCt t) a) (clock_jkbpCSt t)\n 4. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 5. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 6. s \\<in> worlds clock_simMC\n 7. s \\<in> worlds (clock_simMCt t)\n 8. valuation clock_simMC = valuation (clock_simMCt t)", "fix a"], ["proof (state)\ngoal (8 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. \\<And>a.\n       Restr (relations clock_simMC a) (clock_jkbpCSt t) =\n       Restr (relations (clock_simMCt t) a) (clock_jkbpCSt t)\n 4. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 5. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 6. s \\<in> worlds clock_simMC\n 7. s \\<in> worlds (clock_simMCt t)\n 8. valuation clock_simMC = valuation (clock_simMCt t)", "let ?X = \"clock_sim ` Clock.jkbpCn (tLength t)\""], ["proof (state)\ngoal (8 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. \\<And>a.\n       Restr (relations clock_simMC a) (clock_jkbpCSt t) =\n       Restr (relations (clock_simMCt t) a) (clock_jkbpCSt t)\n 4. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 5. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 6. s \\<in> worlds clock_simMC\n 7. s \\<in> worlds (clock_simMCt t)\n 8. valuation clock_simMC = valuation (clock_simMCt t)", "show \"relations Clock.MCS a \\<inter> ?X \\<times> ?X\n      = relations (clock_simMCt t) a \\<inter> ?X \\<times> ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr (relations clock_simMC a) (clock_jkbpCSt t) =\n    Restr (relations (clock_simMCt t) a) (clock_jkbpCSt t)", "by (simp add: Int_ac Int_absorb1\n                  relation_mono[OF jkbpCSt_jkbpCS_subset jkbpCSt_jkbpCS_subset])"], ["proof (state)\nthis:\n  Restr (relations clock_simMC a) (clock_jkbpCSt t) =\n  Restr (relations (clock_simMCt t) a) (clock_jkbpCSt t)\n\ngoal (7 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 5. s \\<in> worlds clock_simMC\n 6. s \\<in> worlds (clock_simMCt t)\n 7. valuation clock_simMC = valuation (clock_simMCt t)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 5. s \\<in> worlds clock_simMC\n 6. s \\<in> worlds (clock_simMCt t)\n 7. valuation clock_simMC = valuation (clock_simMCt t)", "let ?X = \"clock_sim ` Clock.jkbpCn (tLength t)\""], ["proof (state)\ngoal (7 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 5. s \\<in> worlds clock_simMC\n 6. s \\<in> worlds (clock_simMCt t)\n 7. valuation clock_simMC = valuation (clock_simMCt t)", "from s"], ["proof (chain)\npicking this:\n  s \\<in> worlds (clock_simMCt t)", "show \"(\\<Union>a. relations (clock_simMCt t) a)\\<^sup>* `` {s} \\<subseteq> ?X\""], ["proof (prove)\nusing this:\n  s \\<in> worlds (clock_simMCt t)\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t", "apply (clarsimp simp del: mkKripke_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> worlds (clock_simMCt t);\n        ((aa, ba), a, b)\n        \\<in> (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>*;\n        s = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> clock_jkbpCSt t", "apply (erule kripke_rels_trc_worlds)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> worlds (clock_simMCt t);\n        s = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> worlds (clock_simMCt t)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> worlds (clock_simMCt t);\n        s = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> kripke (clock_simMCt t)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>(aa, ba) \\<in> worlds (clock_simMCt t);\n        s = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> clock_jkbpCSt t = worlds (clock_simMCt t)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Union> (range (relations (clock_simMCt t))))\\<^sup>* `` {s}\n  \\<subseteq> clock_jkbpCSt t\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "let ?Y = \"Clock.jkbpCn (tLength t)\""], ["proof (state)\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "let ?X = \"clock_sim ` ?Y\""], ["proof (state)\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "from s"], ["proof (chain)\npicking this:\n  s \\<in> worlds (clock_simMCt t)", "obtain t'\n    where st': \"s = clock_sim t'\"\n      and t'C: \"t' \\<in> Clock.jkbpC\"\n      and t'O: \"tLength t = tLength t'\""], ["proof (prove)\nusing this:\n  s \\<in> worlds (clock_simMCt t)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>s = clock_sim t'; t' \\<in> Clock.jkbpC;\n         tLength t = tLength t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  s = clock_sim t'\n  t' \\<in> Clock.jkbpC\n  tLength t = tLength t'\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "{"], ["proof (state)\nthis:\n  s = clock_sim t'\n  t' \\<in> Clock.jkbpC\n  tLength t = tLength t'\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "fix t''"], ["proof (state)\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "assume tt': \"(t', t'') \\<in> (\\<Union>a. relations Clock.MC a)\\<^sup>*\""], ["proof (state)\nthis:\n  (t', t'') \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>*\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "from t'C tt'"], ["proof (chain)\npicking this:\n  t' \\<in> Clock.jkbpC\n  (t', t'') \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>*", "have t''C: \"t'' \\<in> Clock.jkbpC\""], ["proof (prove)\nusing this:\n  t' \\<in> Clock.jkbpC\n  (t', t'') \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. t'' \\<in> Clock.jkbpC", "by - (erule kripke_rels_trc_worlds, simp_all)"], ["proof (state)\nthis:\n  t'' \\<in> Clock.jkbpC\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "from t'O tt'"], ["proof (chain)\npicking this:\n  tLength t = tLength t'\n  (t', t'') \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>*", "have t''O: \"tLength t = tLength t''\""], ["proof (prove)\nusing this:\n  tLength t = tLength t'\n  (t', t'') \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. tLength t = tLength t''", "by (simp add: Clock.sync_tLength_eq_trc)"], ["proof (state)\nthis:\n  tLength t = tLength t''\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "from t''C t''O"], ["proof (chain)\npicking this:\n  t'' \\<in> Clock.jkbpC\n  tLength t = tLength t''", "have \"t'' \\<in> ?Y\""], ["proof (prove)\nusing this:\n  t'' \\<in> Clock.jkbpC\n  tLength t = tLength t''\n\ngoal (1 subgoal):\n 1. t'' \\<in> Clock.jkbpCn (tLength t)", "by fastforce"], ["proof (state)\nthis:\n  t'' \\<in> Clock.jkbpCn (tLength t)\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "}"], ["proof (state)\nthis:\n  (t', ?t''5)\n  \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>* \\<Longrightarrow>\n  ?t''5 \\<in> Clock.jkbpCn (tLength t)\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "hence \"(\\<Union>a. relations Clock.MC a)\\<^sup>* `` {t'} \\<subseteq> ?Y\""], ["proof (prove)\nusing this:\n  (t', ?t''5)\n  \\<in> (\\<Union> (range (relations Clock.MC)))\\<^sup>* \\<Longrightarrow>\n  ?t''5 \\<in> Clock.jkbpCn (tLength t)\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n    \\<subseteq> Clock.jkbpCn (tLength t)", "by clarsimp"], ["proof (state)\nthis:\n  (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n  \\<subseteq> Clock.jkbpCn (tLength t)\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "hence \"clock_sim ` ((\\<Union>a. relations Clock.MC a)\\<^sup>* `` {t'}) \\<subseteq> ?X\""], ["proof (prove)\nusing this:\n  (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n  \\<subseteq> Clock.jkbpCn (tLength t)\n\ngoal (1 subgoal):\n 1. clock_sim ` (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n    \\<subseteq> clock_jkbpCSt t", "by (rule image_mono)"], ["proof (state)\nthis:\n  clock_sim ` (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n  \\<subseteq> clock_jkbpCSt t\n\ngoal (6 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t\n 4. s \\<in> worlds clock_simMC\n 5. s \\<in> worlds (clock_simMCt t)\n 6. valuation clock_simMC = valuation (clock_simMCt t)", "with st' t'C"], ["proof (chain)\npicking this:\n  s = clock_sim t'\n  t' \\<in> Clock.jkbpC\n  clock_sim ` (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n  \\<subseteq> clock_jkbpCSt t", "show \"(\\<Union>a. relations Clock.MCS a)\\<^sup>* `` {s} \\<subseteq> ?X\""], ["proof (prove)\nusing this:\n  s = clock_sim t'\n  t' \\<in> Clock.jkbpC\n  clock_sim ` (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n  \\<subseteq> clock_jkbpCSt t\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t", "using sim_trc_commute[OF Clock.mkM_kripke clock_sim, where t=t']"], ["proof (prove)\nusing this:\n  s = clock_sim t'\n  t' \\<in> Clock.jkbpC\n  clock_sim ` (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'}\n  \\<subseteq> clock_jkbpCSt t\n  t' \\<in> worlds Clock.MC \\<Longrightarrow>\n  clock_sim ` (\\<Union> (range (relations Clock.MC)))\\<^sup>* `` {t'} =\n  (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {clock_sim t'}\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n    \\<subseteq> clock_jkbpCSt t", "by simp"], ["proof (state)\nthis:\n  (\\<Union> (range (relations clock_simMC)))\\<^sup>* `` {s}\n  \\<subseteq> clock_jkbpCSt t\n\ngoal (5 subgoals):\n 1. kripke clock_simMC\n 2. kripke (clock_simMCt t)\n 3. s \\<in> worlds clock_simMC\n 4. s \\<in> worlds (clock_simMCt t)\n 5. valuation clock_simMC = valuation (clock_simMCt t)", "qed (insert s, auto)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can connect the agent's choice of actions on the \\<open>clock_repMC\\<close> structure to those on the \\<open>Clock.MC\\<close>\nstructure using our earlier results about actions being preserved by\ngenerated models and simulations.\n\n\\<close>"], ["", "lemma clock_simAction':\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes aec: \"ODList.toSet aec = agent_abs a t\"\n  assumes cec: \"ODList.toSet cec = common_abs t\"\n  shows \"set (clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)\"\n(*<*) (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "from tC aec cec"], ["proof (chain)\npicking this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t", "have \"?lhs = set (jAction (clock_repMC (ODList.toSet cec)) (tLast t) a)\""], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) =\n    set (jAction (clock_repMC (toSet cec)) (tLast t) a)", "by (rule clock_simAction_jAction)"], ["proof (state)\nthis:\n  set (local.clock_simAction a (cec, aec)) =\n  set (jAction (clock_repMC (toSet cec)) (tLast t) a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "also"], ["proof (state)\nthis:\n  set (local.clock_simAction a (cec, aec)) =\n  set (jAction (clock_repMC (toSet cec)) (tLast t) a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "from tC aec cec"], ["proof (chain)\npicking this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t", "have \"... = set (jAction (clock_simMCt t) (clock_sim t) a)\""], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  toSet aec = agent_abs a t\n  toSet cec = common_abs t\n\ngoal (1 subgoal):\n 1. set (jAction (clock_repMC (toSet cec)) (tLast t) a) =\n    set (jAction (clock_simMCt t) (clock_sim t) a)", "by (simp add: simulation_jAction_eq[OF _ clock_repSim] common_abs_def)"], ["proof (state)\nthis:\n  set (jAction (clock_repMC (toSet cec)) (tLast t) a) =\n  set (jAction (clock_simMCt t) (clock_sim t) a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "also"], ["proof (state)\nthis:\n  set (jAction (clock_repMC (toSet cec)) (tLast t) a) =\n  set (jAction (clock_simMCt t) (clock_sim t) a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "from tC"], ["proof (chain)\npicking this:\n  t \\<in> Clock.jkbpC", "have \"... = set (jAction Clock.MCS (clock_sim t) a)\""], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n\ngoal (1 subgoal):\n 1. set (jAction (clock_simMCt t) (clock_sim t) a) =\n    set (jAction clock_simMC (clock_sim t) a)", "using gen_model_jAction_eq[OF clock_submodel_aux[OF tC, where s=\"clock_sim t\"], where w'=\"clock_sim t\"]\n          gen_model_world_refl[where w=\"clock_sim t\" and M=\"clock_simMCt t\"]"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  \\<lbrakk>clock_sim t \\<in> worlds (clock_simMCt t);\n   clock_sim t \\<in> worlds (gen_model (clock_simMCt t) (clock_sim t));\n   kripke clock_simMC; kripke (clock_simMCt t)\\<rbrakk>\n  \\<Longrightarrow> jAction clock_simMC (clock_sim t) =\n                    jAction (clock_simMCt t) (clock_sim t)\n  clock_sim t \\<in> worlds (clock_simMCt t) \\<Longrightarrow>\n  clock_sim t \\<in> worlds (gen_model (clock_simMCt t) (clock_sim t))\n\ngoal (1 subgoal):\n 1. set (jAction (clock_simMCt t) (clock_sim t) a) =\n    set (jAction clock_simMC (clock_sim t) a)", "by simp"], ["proof (state)\nthis:\n  set (jAction (clock_simMCt t) (clock_sim t) a) =\n  set (jAction clock_simMC (clock_sim t) a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "also"], ["proof (state)\nthis:\n  set (jAction (clock_simMCt t) (clock_sim t) a) =\n  set (jAction clock_simMC (clock_sim t) a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "from tC"], ["proof (chain)\npicking this:\n  t \\<in> Clock.jkbpC", "have \"... = set (jAction Clock.MC t a)\""], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n\ngoal (1 subgoal):\n 1. set (jAction clock_simMC (clock_sim t) a) = set (jAction Clock.MC t a)", "by (simp add: simulation_jAction_eq[OF _ clock_sim])"], ["proof (state)\nthis:\n  set (jAction clock_simMC (clock_sim t) a) = set (jAction Clock.MC t a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "finally"], ["proof (chain)\npicking this:\n  set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)", "."], ["proof (state)\nthis:\n  set (local.clock_simAction a (cec, aec)) = set (jAction Clock.MC t a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nThe @{term \"Algorithm\"} locale requires a specialisation of this\nlemma:\n\n\\<close>"], ["", "lemma clock_simAction:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"set (clock_simAction a ec) = set (jAction Clock.MC t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.clock_simAction a ec) = set (jAction Clock.MC t a)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (local.clock_simAction a ec) = set (jAction Clock.MC t a)", "using assms clock_simAction'[OF tC, where cec=\"fst ec\" and aec=\"snd ec\"]"], ["proof (prove)\nusing this:\n  t \\<in> Clock.jkbpC\n  clock_simAbs ec = Clock.sim_equiv_class a t\n  \\<lbrakk>toSet (snd ec) = agent_abs ?a t;\n   toSet (fst ec) = common_abs t\\<rbrakk>\n  \\<Longrightarrow> set (local.clock_simAction ?a (fst ec, snd ec)) =\n                    set (jAction Clock.MC t ?a)\n\ngoal (1 subgoal):\n 1. set (local.clock_simAction a ec) = set (jAction Clock.MC t a)", "apply (simp add: common_abs agent_abs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)\n\n(* **************************************** *)"], ["", "subsubsection\\<open>Simulated transitions\\<close>"], ["", "text\\<open>\n\nWe need to determine the image of the set of commonly-held-possible\nstates under the transition function, and also for the agent's\nsubjective equivalence class. We do this with the \\<open>clock_trans\\<close> function:\n\n\\<close>"], ["", "definition (in -)\n  clock_trans :: \"('a :: linorder) odlist \\<Rightarrow> ('a, 'p, 'aAct) JKBP\n              \\<Rightarrow> (('s :: linorder) \\<Rightarrow> 'eAct list)\n              \\<Rightarrow> ('eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's)\n              \\<Rightarrow> ('s \\<Rightarrow> 'p \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> 'obs)\n              \\<Rightarrow> 's odlist \\<Rightarrow> 's odlist \\<Rightarrow> 's odlist\"\nwhere\n  \"clock_trans agents jkbp envAction envTrans envVal envObs \\<equiv> \\<lambda>cec X.\n     ODList.fromList (concat\n       [ [ envTrans eact aact s .\n                     eact \\<leftarrow> envAction s,\n                     aact \\<leftarrow> listToFuns (\\<lambda>a. clock_simAction jkbp envVal envObs a\n                                        (cec, clock_knowledge envObs cec a s))\n                                        (toList agents) ] .\n                   s \\<leftarrow> toList X ])\""], ["", "(*<*)"], ["", "abbreviation\n  clock_trans :: \"'s odlist \\<Rightarrow> 's odlist \\<Rightarrow> 's odlist\"\nwhere\n  \"clock_trans \\<equiv> ClockView.clock_trans agents jkbp envAction envTrans envVal envObs\""], ["", "lemma clock_trans_aux:\n  assumes t'C: \"t' \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a' t'\"\n      and tC: \"t \\<in> Clock.jkbpCn (tLength t')\"\n      and eact: \"eact \\<in> set (envAction (tLast t))\"\n  shows \"(aact \\<in> set (listToFuns (\\<lambda>a. clock_simAction a (fst ec, clock_knowledge envObs (fst ec) a (tLast t)))\n                            (toList agents)))\n     \\<longleftrightarrow> (\\<forall>a. aact a \\<in> set (jAction (Clock.MCn (tLength t')) t a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (aact\n     \\<in> set (listToFuns\n                 (\\<lambda>a.\n                     local.clock_simAction a\n                      (fst ec, clock_knowledge envObs (fst ec) a (tLast t)))\n                 (toList agents))) =\n    (\\<forall>a. aact a \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "using assms"], ["proof (prove)\nusing this:\n  t' \\<in> Clock.jkbpC\n  clock_simAbs ec = Clock.sim_equiv_class a' t'\n  t \\<in> Clock.jkbpCn (tLength t')\n  eact \\<in> set (envAction (tLast t))\n\ngoal (1 subgoal):\n 1. (aact\n     \\<in> set (listToFuns\n                 (\\<lambda>a.\n                     local.clock_simAction a\n                      (fst ec, clock_knowledge envObs (fst ec) a (tLast t)))\n                 (toList agents))) =\n    (\\<forall>a. aact a \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec = Clock.sim_equiv_class a' t';\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t))\\<rbrakk>\n    \\<Longrightarrow> (aact\n                       \\<in> set (listToFuns\n                                   (\\<lambda>a.\n local.clock_simAction a\n  (fst ec, clock_knowledge envObs (fst ec) a (tLast t)))\n                                   (toList agents))) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (frule Clock.jkbpCn_jkbpC_inc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec = Clock.sim_equiv_class a' t';\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (aact\n                       \\<in> set (listToFuns\n                                   (\\<lambda>a.\n local.clock_simAction a\n  (fst ec, clock_knowledge envObs (fst ec) a (tLast t)))\n                                   (toList agents))) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (clarsimp simp: listToFuns_ext[OF agents[unfolded toSet_def]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x\n                          \\<in> set (local.clock_simAction x\n(fst ec, clock_knowledge envObs (fst ec) x (tLast t)))) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (subst clock_simAction')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> ?t6 \\<in> Clock.jkbpC\n 2. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet\n                          (clock_knowledge envObs (fst ec) x (tLast t)) =\n                         agent_abs x ?t6\n 3. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet (fst ec) = common_abs ?t6\n 4. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x \\<in> set (jAction Clock.MC ?t6 x)) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (erule Clock.jkbpCn_jkbpC_inc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet\n                          (clock_knowledge envObs (fst ec) x (tLast t)) =\n                         agent_abs x t\n 2. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet (fst ec) = common_abs t\n 3. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x \\<in> set (jAction Clock.MC t x)) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (subst clock_coEC_relation_image)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> tLast t \\<in> toSet (fst ec)\n 2. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> relations (clock_repMC (toSet (fst ec))) x ``\n                         {tLast t} =\n                         agent_abs x t\n 3. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet (fst ec) = common_abs t\n 4. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x \\<in> set (jAction Clock.MC t x)) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (simp add: common_abs common_abs_def toSet_def[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> relations (clock_repMC (toSet (fst ec))) x ``\n                         {tLast t} =\n                         agent_abs x t\n 2. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet (fst ec) = common_abs t\n 3. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x \\<in> set (jAction Clock.MC t x)) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (fastforce simp: common_abs agent_abs_def common_abs_def clock_repRels_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>t' \\<in> Clock.jkbpC;\n        clock_simAbs ec =\n        clock_sim `\n        rel_ext\n         (\\<lambda>t'a.\n             t'a \\<in> Clock.jkbpC \\<and>\n             tLength t'a = tLength t' \\<and>\n             envObs a' (tLast t'a) = envObs a' (tLast t'));\n        t \\<in> Clock.jkbpCn (tLength t');\n        eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n       \\<Longrightarrow> toSet (fst ec) = common_abs t\n 2. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x \\<in> set (jAction Clock.MC t x)) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (simp add: common_abs common_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t' \\<in> Clock.jkbpC;\n     clock_simAbs ec =\n     clock_sim `\n     rel_ext\n      (\\<lambda>t'a.\n          t'a \\<in> Clock.jkbpC \\<and>\n          tLength t'a = tLength t' \\<and>\n          envObs a' (tLast t'a) = envObs a' (tLast t'));\n     t \\<in> Clock.jkbpCn (tLength t');\n     eact \\<in> set (envAction (tLast t)); t \\<in> Clock.jkbpC\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x.\n                          aact x \\<in> set (jAction Clock.MC t x)) =\n                      (\\<forall>a.\n                          aact a\n                          \\<in> set (jAction (Clock.MCn (tLength t')) t a))", "apply (simp add: Clock.jkbpC_jkbpCn_jAction_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nThe function @{term \"listToFuns\"} exhibits the isomorphism between @{typ\n\"('a \\<times> 'b list) list\"} and @{typ \"('a \\<Rightarrow> 'b) list\"} for finite types\n@{typ \"'a\"}.\n\nWe can show that the transition function works for both the\ncommonly-held set of states and the agent subjective one. The proofs\nare  straightforward.\n\n\\<close>"], ["", "lemma clock_trans_common:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (clock_trans (fst ec) (fst ec))\n       = { s |t' s. t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t }\"\n(*<*) (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (local.clock_trans (fst ec) (fst ec)) =\n    rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. toSet (local.clock_trans (fst ec) (fst ec))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ = s \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t)\n 2. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (fst ec))", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (local.clock_trans (fst ec) (fst ec))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ = s \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t)", "unfolding clock_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet\n     (fromList\n       (concat\n         (map (\\<lambda>s.\n                  concat\n                   (map (\\<lambda>eact.\n                            map (\\<lambda>aact. envTrans eact aact s)\n                             (listToFuns\n                               (\\<lambda>a.\n                                   local.clock_simAction a\n                                    (fst ec,\n                                     clock_knowledge envObs (fst ec) a s))\n                               (toList agents)))\n                     (envAction s)))\n           (toList (fst ec)))))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ = s \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t)", "apply (clarsimp simp: toSet_def[symmetric] common_abs[OF assms] common_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb aact.\n       \\<lbrakk>xa \\<in> Clock.jkbpCn (tLength t);\n        xb \\<in> set (envAction (tLast xa));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast xa)))\n                    (toList agents))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> envTrans xb aact (tLast xa)\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (rule_tac x=xa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb aact.\n       \\<lbrakk>xa \\<in> Clock.jkbpCn (tLength t);\n        xb \\<in> set (envAction (tLast xa));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast xa)))\n                    (toList agents))\\<rbrakk>\n       \\<Longrightarrow> xa \\<leadsto> envTrans xb aact (tLast xa)\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength xa = tLength t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb aact.\n       \\<lbrakk>xa \\<in> Clock.jkbpCn (tLength t);\n        xb \\<in> set (envAction (tLast xa));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast xa)))\n                    (toList agents))\\<rbrakk>\n       \\<Longrightarrow> xa \\<leadsto> envTrans xb aact (tLast xa)\n                         \\<in> Clock.jkbpC", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb aact.\n       \\<lbrakk>xa \\<in> Clock.jkbpCn (tLength t);\n        xb \\<in> set (envAction (tLast xa));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast xa)))\n                    (toList agents))\\<rbrakk>\n       \\<Longrightarrow> xa \\<leadsto> envTrans xb aact (tLast xa)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))", "apply (auto simp: Let_def iff: clock_trans_aux[OF tC ec])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  toSet (local.clock_trans (fst ec) (fst ec))\n  \\<subseteq> rel_ext\n               (\\<lambda>uu_.\n                   \\<exists>t' s.\n                      uu_ = s \\<and>\n                      t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                      tLength t' = tLength t)\n\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (fst ec))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (fst ec))", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (fst ec))", "unfolding clock_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n    \\<subseteq> toSet\n                 (fromList\n                   (concat\n                     (map (\\<lambda>s.\n                              concat\n                               (map (\\<lambda>eact.\n  map (\\<lambda>aact. envTrans eact aact s)\n   (listToFuns\n     (\\<lambda>a.\n         local.clock_simAction a\n          (fst ec, clock_knowledge envObs (fst ec) a s))\n     (toList agents)))\n                                 (envAction s)))\n                       (toList (fst ec)))))", "apply (clarsimp simp: toSet_def[symmetric] common_abs[OF assms] common_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t'.\n       \\<lbrakk>t' \\<leadsto> x \\<in> Clock.jkbpC;\n        tLength t' = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>Clock.jkbpCn (tLength t).\n                            \\<exists>xb\\<in>set (envAction (tLast xa)).\n                               x \\<in> (\\<lambda>aact.\n     envTrans xb aact (tLast xa)) `\n set (listToFuns\n       (\\<lambda>a.\n           local.clock_simAction a\n            (fst ec, clock_knowledge envObs (fst ec) a (tLast xa)))\n       (toList agents))", "apply (drule Clock.jkbpC_tLength_inv[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t'.\n       tLength t' = tLength t \\<Longrightarrow>\n       tLength (t' \\<leadsto> x) = Suc (tLength t)\n 2. \\<And>x t'.\n       \\<lbrakk>tLength t' = tLength t;\n        t' \\<leadsto> x \\<in> Clock.jkbpCn (Suc (tLength t))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>Clock.jkbpCn (tLength t).\n                            \\<exists>xb\\<in>set (envAction (tLast xa)).\n                               x \\<in> (\\<lambda>aact.\n     envTrans xb aact (tLast xa)) `\n set (listToFuns\n       (\\<lambda>a.\n           local.clock_simAction a\n            (fst ec, clock_knowledge envObs (fst ec) a (tLast xa)))\n       (toList agents))", "apply (auto simp: Let_def iff: clock_trans_aux[OF tC ec])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = s \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n  \\<subseteq> toSet (local.clock_trans (fst ec) (fst ec))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma clock_trans_agent:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n  assumes ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"ODList.toSet (clock_trans (fst ec) (snd ec))\n       = { s |t' s. t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t }\"\n(*<*) (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (local.clock_trans (fst ec) (snd ec)) =\n    rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. toSet (local.clock_trans (fst ec) (snd ec))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ = s \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)\n 2. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (snd ec))", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (local.clock_trans (fst ec) (snd ec))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ = s \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)", "unfolding clock_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet\n     (fromList\n       (concat\n         (map (\\<lambda>s.\n                  concat\n                   (map (\\<lambda>eact.\n                            map (\\<lambda>aact. envTrans eact aact s)\n                             (listToFuns\n                               (\\<lambda>a.\n                                   local.clock_simAction a\n                                    (fst ec,\n                                     clock_knowledge envObs (fst ec) a s))\n                               (toList agents)))\n                     (envAction s)))\n           (toList (snd ec)))))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ = s \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)", "apply (clarsimp simp: toSet_def[symmetric] common_abs[OF assms] agent_abs[OF assms] common_abs_def agent_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb aact t'.\n       \\<lbrakk>xb \\<in> set (envAction (tLast t'));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast t')))\n                    (toList agents));\n        t' \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'a.\n                            t'a \\<leadsto> envTrans xb aact (tLast t')\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t'a = tLength t \\<and>\n                            envObs a (tLast t'a) = envObs a (tLast t)", "apply (rule_tac x=t' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb aact t'.\n       \\<lbrakk>xb \\<in> set (envAction (tLast t'));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast t')))\n                    (toList agents));\n        t' \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> t' \\<leadsto> envTrans xb aact (tLast t')\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength t' = tLength t \\<and>\n                         envObs a (tLast t') = envObs a (tLast t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb aact t'.\n       \\<lbrakk>xb \\<in> set (envAction (tLast t'));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast t')))\n                    (toList agents));\n        t' \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> t' \\<leadsto> envTrans xb aact (tLast t')\n                         \\<in> Clock.jkbpC", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb aact t'.\n       \\<lbrakk>xb \\<in> set (envAction (tLast t'));\n        aact\n        \\<in> set (listToFuns\n                    (\\<lambda>a.\n                        local.clock_simAction a\n                         (fst ec,\n                          clock_knowledge envObs (fst ec) a (tLast t')))\n                    (toList agents));\n        t' \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> t' \\<leadsto> envTrans xb aact (tLast t')\n                         \\<in> Clock.jkbpCn (Suc (tLength t))", "apply (auto simp: Let_def iff: clock_trans_aux[OF tC ec])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  toSet (local.clock_trans (fst ec) (snd ec))\n  \\<subseteq> rel_ext\n               (\\<lambda>uu_.\n                   \\<exists>t' s.\n                      uu_ = s \\<and>\n                      t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                      clock_jview a t' = clock_jview a t)\n\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (snd ec))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (snd ec))", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> toSet (local.clock_trans (fst ec) (snd ec))", "unfolding clock_trans_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = s \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> toSet\n                 (fromList\n                   (concat\n                     (map (\\<lambda>s.\n                              concat\n                               (map (\\<lambda>eact.\n  map (\\<lambda>aact. envTrans eact aact s)\n   (listToFuns\n     (\\<lambda>a.\n         local.clock_simAction a\n          (fst ec, clock_knowledge envObs (fst ec) a s))\n     (toList agents)))\n                                 (envAction s)))\n                       (toList (snd ec)))))", "apply (clarsimp simp: toSet_def[symmetric] common_abs[OF assms] agent_abs[OF assms] common_abs_def agent_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x t'.\n       \\<lbrakk>t' \\<leadsto> x \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>t'.\n                                xa = tLast t' \\<and>\n                                t' \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t \\<and>\n                                envObs a (tLast t') =\n                                envObs a (tLast t)) \\<and>\n                            (\\<exists>xb\\<in>set (envAction xa).\n                                x \\<in> (\\<lambda>aact.\n      envTrans xb aact xa) `\n  set (listToFuns\n        (\\<lambda>a.\n            local.clock_simAction a\n             (fst ec, clock_knowledge envObs (fst ec) a xa))\n        (toList agents)))", "apply (drule Clock.jkbpC_tLength_inv[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x t'.\n       \\<lbrakk>tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> tLength (t' \\<leadsto> x) = Suc (tLength t)\n 2. \\<And>x t'.\n       \\<lbrakk>tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        t' \\<leadsto> x \\<in> Clock.jkbpCn (Suc (tLength t))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>t'.\n                                xa = tLast t' \\<and>\n                                t' \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t \\<and>\n                                envObs a (tLast t') =\n                                envObs a (tLast t)) \\<and>\n                            (\\<exists>xb\\<in>set (envAction xa).\n                                x \\<in> (\\<lambda>aact.\n      envTrans xb aact xa) `\n  set (listToFuns\n        (\\<lambda>a.\n            local.clock_simAction a\n             (fst ec, clock_knowledge envObs (fst ec) a xa))\n        (toList agents)))", "apply (auto simp: Let_def iff: clock_trans_aux[OF tC ec])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = s \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n          clock_jview a t' = clock_jview a t)\n  \\<subseteq> toSet (local.clock_trans (fst ec) (snd ec))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nNote that the clock semantics disregards paths, so we simply compute\nthe successors of the temporal slice and partition that. Similarly the\nsuccessors of the agent's subjective equivalence class tell us what\nthe set of possible observations are:\n\n\\<close>"], ["", "definition (in -)\n  clock_mkSuccs :: \"('s :: linorder \\<Rightarrow> 'obs) \\<Rightarrow> 'obs \\<Rightarrow> 's odlist\n                \\<Rightarrow> 's clock_simWorldsRep\"\nwhere\n  \"clock_mkSuccs envObs obs Y' \\<equiv> (Y', ODList.filter (\\<lambda>s. envObs s = obs) Y')\""], ["", "text\\<open>\n\nFinally we can define our transition function on simulated states:\n\n\\<close>"], ["", "definition (in -)\n  clock_simTrans :: \"('a :: linorder) odlist \\<Rightarrow> ('a, 'p, 'aAct) JKBP\n              \\<Rightarrow> (('s :: linorder) \\<Rightarrow> 'eAct list)\n              \\<Rightarrow> ('eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's)\n              \\<Rightarrow> ('s \\<Rightarrow> 'p \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 's \\<Rightarrow> 'obs)\n              \\<Rightarrow> 'a \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> 's clock_simWorldsRep list\"\nwhere\n  \"clock_simTrans agents jkbp envAction envTrans envVal envObs \\<equiv> \\<lambda>a (Y, X).\n     let X' = clock_trans agents jkbp envAction envTrans envVal envObs Y X;\n        Y' = clock_trans agents jkbp envAction envTrans envVal envObs Y Y\n      in [ clock_mkSuccs (envObs a) obs Y' .\n             obs \\<leftarrow> map (envObs a) (toList X') ]\""], ["", "(*<*)"], ["", "abbreviation\n  clock_simTrans :: \"'a \\<Rightarrow> 's clock_simWorldsRep \\<Rightarrow> 's clock_simWorldsRep list\"\nwhere\n  \"clock_simTrans \\<equiv> ClockView.clock_simTrans agents jkbp envAction envTrans envVal envObs\""], ["", "(*>*)"], ["", "text\\<open>\n\nShowing that this respects the property asked of it by the @{term\n\"Algorithm\"} locale is straightforward:\n\n\\<close>"], ["", "lemma clock_simTrans:\n  assumes tC: \"t \\<in> Clock.jkbpC\"\n      and ec: \"clock_simAbs ec = Clock.sim_equiv_class a t\"\n  shows \"clock_simAbs ` set (clock_simTrans a ec)\n      = { Clock.sim_equiv_class a (t' \\<leadsto> s)\n          |t' s. t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> clock_jview a t' = clock_jview a t }\"\n(*<*) (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_simAbs ` set (local.clock_simTrans a ec) =\n    rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. clock_simAbs ` set (local.clock_simTrans a ec)\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ =\n                        Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)\n 2. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> clock_simAbs ` set (local.clock_simTrans a ec)", "note image_cong_simp [cong del]"], ["proof (state)\nthis:\n  \\<lbrakk>?M = ?N; \\<And>x. x \\<in> ?N =simp=> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (2 subgoals):\n 1. clock_simAbs ` set (local.clock_simTrans a ec)\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ =\n                        Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)\n 2. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> clock_simAbs ` set (local.clock_simTrans a ec)", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_simAbs ` set (local.clock_simTrans a ec)\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ =\n                        Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)", "unfolding clock_simTrans_def clock_mkSuccs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. clock_simAbs `\n    set (case ec of\n         (Y, X) \\<Rightarrow>\n           let X' = local.clock_trans Y X; Y' = local.clock_trans Y Y\n           in map (\\<lambda>obs.\n                      (Y', ODList.filter (\\<lambda>s. envObs a s = obs) Y'))\n               (map (envObs a) (toList X')))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ =\n                        Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)", "using clock_trans_common[OF tC ec] clock_trans_agent[OF tC ec]"], ["proof (prove)\nusing this:\n  toSet (local.clock_trans (fst ec) (fst ec)) =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = s \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n  toSet (local.clock_trans (fst ec) (snd ec)) =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = s \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n          clock_jview a t' = clock_jview a t)\n\ngoal (1 subgoal):\n 1. clock_simAbs `\n    set (case ec of\n         (Y, X) \\<Rightarrow>\n           let X' = local.clock_trans Y X; Y' = local.clock_trans Y Y\n           in map (\\<lambda>obs.\n                      (Y', ODList.filter (\\<lambda>s. envObs a s = obs) Y'))\n               (map (envObs a) (toList X')))\n    \\<subseteq> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t' s.\n                        uu_ =\n                        Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n                        t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                        clock_jview a t' = clock_jview a t)", "apply (clarsimp simp: toSet_def[symmetric] clock_simAbs_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t'.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t' s.\n                            rel_ext\n                             (\\<lambda>uu_.\n                                 \\<exists>s.\n                                    uu_ =\n                                    (rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t),\n                                     s) \\<and>\n                                    (\\<exists>t'.\n  t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t) \\<and>\n                                    envObs a s = envObs a xa) =\n                            clock_sim `\n                            rel_ext\n                             (\\<lambda>t'a.\n                                 t'a \\<in> Clock.jkbpC \\<and>\n                                 tLength t'a = Suc (tLength t') \\<and>\n                                 envObs a (tLast t'a) = envObs a s) \\<and>\n                            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t \\<and>\n                            envObs a (tLast t') = envObs a (tLast t)", "apply (rule_tac x=t' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t'.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            rel_ext\n                             (\\<lambda>uu_.\n                                 \\<exists>s.\n                                    uu_ =\n                                    (rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t),\n                                     s) \\<and>\n                                    (\\<exists>t'.\n  t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t) \\<and>\n                                    envObs a s = envObs a xa) =\n                            clock_sim `\n                            rel_ext\n                             (\\<lambda>t'a.\n                                 t'a \\<in> Clock.jkbpC \\<and>\n                                 tLength t'a = Suc (tLength t') \\<and>\n                                 envObs a (tLast t'a) = envObs a s) \\<and>\n                            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t \\<and>\n                            envObs a (tLast t') = envObs a (tLast t)", "apply (rule_tac x=xa in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t'.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ =\n                                 (rel_ext\n                                   (\\<lambda>uu_.\n \\<exists>t'.\n    t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t),\n                                  s) \\<and>\n                                 (\\<exists>t'.\n                                     t' \\<leadsto> s\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t) \\<and>\n                                 envObs a s = envObs a xa) =\n                         clock_sim `\n                         rel_ext\n                          (\\<lambda>t'a.\n                              t'a \\<in> Clock.jkbpC \\<and>\n                              tLength t'a = Suc (tLength t') \\<and>\n                              envObs a (tLast t'a) = envObs a xa) \\<and>\n                         t' \\<leadsto> xa \\<in> Clock.jkbpC \\<and>\n                         tLength t' = tLength t \\<and>\n                         envObs a (tLast t') = envObs a (tLast t)", "apply (clarsimp simp: clock_sim_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t'.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>s.\n                                 uu_ =\n                                 (rel_ext\n                                   (\\<lambda>uu_.\n \\<exists>t'.\n    t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t),\n                                  s) \\<and>\n                                 (\\<exists>t'.\n                                     t' \\<leadsto> s\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t) \\<and>\n                                 envObs a s = envObs a xa) =\n                         (\\<lambda>t. (clock_commonAbs t, tLast t)) `\n                         rel_ext\n                          (\\<lambda>t'.\n                              t' \\<in> Clock.jkbpC \\<and>\n                              tLength t' = Suc (tLength t) \\<and>\n                              envObs a (tLast t') = envObs a xa)", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa t' aa b s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          s)\n                         \\<in> (\\<lambda>t. (clock_commonAbs t, tLast t)) `\n                               rel_ext\n                                (\\<lambda>t'.\n                                    t' \\<in> Clock.jkbpC \\<and>\n                                    tLength t' = Suc (tLength t) \\<and>\n                                    envObs a (tLast t') = envObs a xa)\n 2. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          s)\n                         \\<in> (\\<lambda>t. (clock_commonAbs t, tLast t)) `\n                               rel_ext\n                                (\\<lambda>t'.\n                                    t' \\<in> Clock.jkbpC \\<and>\n                                    tLength t' = Suc (tLength t) \\<and>\n                                    envObs a (tLast t') = envObs a xa)\n 2. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (rule_tac x=\"t'a \\<leadsto> s\" in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          s) =\n                         (clock_commonAbs (t'a \\<leadsto> s),\n                          tLast (t'a \\<leadsto> s))\n 2. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> t'a \\<leadsto> s\n                         \\<in> rel_ext\n                                (\\<lambda>t'.\n                                    t' \\<in> Clock.jkbpC \\<and>\n                                    tLength t' = Suc (tLength t) \\<and>\n                                    envObs a (tLast t') = envObs a xa)\n 3. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (clarsimp simp: Let_def Set.image_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t) =\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x.\n                                 (\\<exists>ta eact aact.\n                                     x =\n                                     ta \\<leadsto>\n                                     envTrans eact aact (tLast ta) \\<and>\n                                     ta \\<in> Clock.jkbpCn\n         (tLength t) \\<and>\n                                     eact\n                                     \\<in> set (envAction (tLast ta)) \\<and>\n                                     (\\<forall>a.\n   aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                                 y = tLast x)\n 2. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> t'a \\<leadsto> s\n                         \\<in> rel_ext\n                                (\\<lambda>t'.\n                                    t' \\<in> Clock.jkbpC \\<and>\n                                    tLength t' = Suc (tLength t) \\<and>\n                                    envObs a (tLast t') = envObs a xa)\n 3. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a x t'b.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; t'b \\<leadsto> x \\<in> Clock.jkbpC;\n        tLength t'b = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 2. \\<And>uu_ uua_ xa t' s t'a x xb ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (ta \\<leadsto> envTrans eact aact (tLast ta))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 4. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 5. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (rule_tac x=\"t'b \\<leadsto> x\" in exI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a x t'b.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; t'b \\<leadsto> x \\<in> Clock.jkbpC;\n        tLength t'b = tLength t\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ta eact aact.\n                             t'b \\<leadsto> x =\n                             ta \\<leadsto>\n                             envTrans eact aact (tLast ta) \\<and>\n                             ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                             eact \\<in> set (envAction (tLast ta)) \\<and>\n                             (\\<forall>a.\n                                 aact a\n                                 \\<in> set\n  (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                         x = tLast (t'b \\<leadsto> x)\n 2. \\<And>uu_ uua_ xa t' s t'a x xb ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (ta \\<leadsto> envTrans eact aact (tLast ta))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 4. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 5. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (clarsimp simp: Let_def Set.image_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a x t'b.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; t'b \\<leadsto> x \\<in> Clock.jkbpC;\n        tLength t'b = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eact aact.\n                            x = envTrans eact aact (tLast t'b) \\<and>\n                            t'b \\<in> Clock.jkbpCn (tLength t) \\<and>\n                            eact \\<in> set (envAction (tLast t'b)) \\<and>\n                            (\\<forall>a.\n                                aact a\n                                \\<in> set\n (jAction (Clock.MCn (tLength t)) t'b a))\n 2. \\<And>uu_ uua_ xa t' s t'a x xb ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (ta \\<leadsto> envTrans eact aact (tLast ta))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 4. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 5. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (drule_tac t=\"t'b \\<leadsto> x\" in Clock.jkbpC_tLength_inv[OF _ refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a x t'b.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; tLength t'b = tLength t;\n        t'b \\<leadsto> x\n        \\<in> Clock.jkbpCn (tLength (t'b \\<leadsto> x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eact aact.\n                            x = envTrans eact aact (tLast t'b) \\<and>\n                            t'b \\<in> Clock.jkbpCn (tLength t) \\<and>\n                            eact \\<in> set (envAction (tLast t'b)) \\<and>\n                            (\\<forall>a.\n                                aact a\n                                \\<in> set\n (jAction (Clock.MCn (tLength t)) t'b a))\n 2. \\<And>uu_ uua_ xa t' s t'a x xb ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (ta \\<leadsto> envTrans eact aact (tLast ta))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 4. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 5. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (auto simp: Let_def)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a x xb ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (ta \\<leadsto> envTrans eact aact (tLast ta))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 4. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (rule_tac x=\"ta\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a x xb ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto>\n                         tLast (ta \\<leadsto> envTrans eact aact (tLast ta))\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength ta = tLength t\n 2. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 4. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC\n 2. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 4. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>uu_ uua_ xa t' s t'a ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t; ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))\n 2. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLength (t'a \\<leadsto> s) = Suc (tLength t)\n 3. \\<And>uu_ uua_ xa t' s t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a s = envObs a xa; t'a \\<leadsto> s \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> envObs a (tLast (t'a \\<leadsto> s)) = envObs a xa\n 4. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (auto simp: Let_def)[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s.\n                            (clock_commonAbs ta, tLast ta) =\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             s) \\<and>\n                            (\\<exists>t'.\n                                t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t) \\<and>\n                            envObs a s = envObs a xa", "apply (rule_tac x=\"tLast ta\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' aa b ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> (clock_commonAbs ta, tLast ta) =\n                         (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          tLast ta) \\<and>\n                         (\\<exists>t'.\n                             t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                             tLength t' = tLength t) \\<and>\n                         envObs a (tLast ta) = envObs a xa", "apply (clarsimp simp: Let_def Set.image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x.\n                                 (\\<exists>ta eact aact.\n                                     x =\n                                     ta \\<leadsto>\n                                     envTrans eact aact (tLast ta) \\<and>\n                                     ta \\<in> Clock.jkbpCn\n         (tLength t) \\<and>\n                                     eact\n                                     \\<in> set (envAction (tLast ta)) \\<and>\n                                     (\\<forall>a.\n   aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                                 y = tLast x) =\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t) \\<and>\n                         (\\<exists>t'.\n                             t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                             tLength t' = tLength t)", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta x xb taa eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        taa \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast taa));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) taa a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (taa \\<leadsto> envTrans eact aact (tLast taa))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        t'a \\<leadsto> x \\<in> Clock.jkbpC; tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 3. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (rule_tac x=\"taa\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta x xb taa eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        taa \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast taa));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) taa a)\\<rbrakk>\n       \\<Longrightarrow> taa \\<leadsto>\n                         tLast\n                          (taa \\<leadsto> envTrans eact aact (tLast taa))\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength taa = tLength t\n 2. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        t'a \\<leadsto> x \\<in> Clock.jkbpC; tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 3. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta taa eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        taa \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast taa));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) taa a)\\<rbrakk>\n       \\<Longrightarrow> taa \\<leadsto> envTrans eact aact (tLast taa)\n                         \\<in> Clock.jkbpC\n 2. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        t'a \\<leadsto> x \\<in> Clock.jkbpC; tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 3. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta taa eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        taa \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast taa));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) taa a)\\<rbrakk>\n       \\<Longrightarrow> taa \\<leadsto> envTrans eact aact (tLast taa)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))\n 2. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        t'a \\<leadsto> x \\<in> Clock.jkbpC; tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 3. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (auto simp: Let_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa;\n        t'a \\<leadsto> x \\<in> Clock.jkbpC; tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 2. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (drule_tac t=\"t'a \\<leadsto> x\" in Clock.jkbpC_tLength_inv[OF _ refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa; tLength t'a = tLength t;\n        t'a \\<leadsto> x\n        \\<in> Clock.jkbpCn (tLength (t'a \\<leadsto> x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 2. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (rule_tac x=\"t'a \\<leadsto> x\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta x t'a.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa; tLength t'a = tLength t;\n        t'a \\<leadsto> x\n        \\<in> Clock.jkbpCn (tLength (t'a \\<leadsto> x))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ta eact aact.\n                             t'a \\<leadsto> x =\n                             ta \\<leadsto>\n                             envTrans eact aact (tLast ta) \\<and>\n                             ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                             eact \\<in> set (envAction (tLast ta)) \\<and>\n                             (\\<forall>a.\n                                 aact a\n                                 \\<in> set\n  (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                         x = tLast (t'a \\<leadsto> x)\n 2. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (auto simp: Let_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        ta \\<in> Clock.jkbpC; tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (drule_tac t=\"ta\" in Clock.jkbpC_tLength_inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        tLength ta = Suc (tLength t);\n        envObs a (tLast ta) = envObs a xa\\<rbrakk>\n       \\<Longrightarrow> tLength ta = ?n189 uu_ uua_ xa t' ta\n 2. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        tLength ta = Suc (tLength t); envObs a (tLast ta) = envObs a xa;\n        ta \\<in> Clock.jkbpCn (?n189 uu_ uua_ xa t' ta)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        tLength ta = Suc (tLength t); envObs a (tLast ta) = envObs a xa;\n        ta \\<in> Clock.jkbpCn (Suc (tLength t))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast ta \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (clarsimp simp: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a (envTrans eact aact (tLast ta)) = envObs a xa;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> envTrans eact aact (tLast ta)\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (rule_tac x=\"ta\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a (envTrans eact aact (tLast ta)) = envObs a xa;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength ta = tLength t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a (envTrans eact aact (tLast ta)) = envObs a xa;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ uua_ xa t' ta eact aact.\n       \\<lbrakk>toSet (local.clock_trans uua_ uua_) =\n                rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>t'.\n                        t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                        tLength t' = tLength t);\n        toSet (local.clock_trans uua_ uu_) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        ec = (uua_, uu_); t' \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t' = tLength t; envObs a (tLast t') = envObs a (tLast t);\n        envObs a (envTrans eact aact (tLast ta)) = envObs a xa;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))", "apply (auto simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  clock_simAbs ` set (local.clock_simTrans a ec)\n  \\<subseteq> rel_ext\n               (\\<lambda>uu_.\n                   \\<exists>t' s.\n                      uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n                      t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                      clock_jview a t' = clock_jview a t)\n\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> clock_simAbs ` set (local.clock_simTrans a ec)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> clock_simAbs ` set (local.clock_simTrans a ec)", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> clock_simAbs ` set (local.clock_simTrans a ec)", "unfolding clock_simTrans_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext\n     (\\<lambda>uu_.\n         \\<exists>t' s.\n            uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n            t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jview a t)\n    \\<subseteq> clock_simAbs `\n                set (case ec of\n                     (Y, X) \\<Rightarrow>\n                       map (\\<lambda>obs.\n                               clock_mkSuccs (envObs a) obs\n                                (local.clock_trans Y Y))\n                        (map (envObs a) (toList (local.clock_trans Y X))))", "apply (cases ec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       ec = (aa, b) \\<Longrightarrow>\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n       \\<subseteq> clock_simAbs `\n                   set (case ec of\n                        (Y, X) \\<Rightarrow>\n                          map (\\<lambda>obs.\n                                  clock_mkSuccs (envObs a) obs\n                                   (local.clock_trans Y Y))\n                           (map (envObs a)\n                             (toList (local.clock_trans Y X))))", "using clock_trans_common[OF tC ec] clock_trans_agent[OF tC ec]"], ["proof (prove)\nusing this:\n  toSet (local.clock_trans (fst ec) (fst ec)) =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = s \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n  toSet (local.clock_trans (fst ec) (snd ec)) =\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = s \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n          clock_jview a t' = clock_jview a t)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       ec = (aa, b) \\<Longrightarrow>\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n       \\<subseteq> clock_simAbs `\n                   set (case ec of\n                        (Y, X) \\<Rightarrow>\n                          map (\\<lambda>obs.\n                                  clock_mkSuccs (envObs a) obs\n                                   (local.clock_trans Y Y))\n                           (map (envObs a)\n                             (toList (local.clock_trans Y X))))", "apply (clarsimp simp: toSet_def[symmetric] Set.image_def clock_simAbs_def\n                simp del: split_paired_Ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>xa.\n                                (\\<exists>t'.\n                                    t' \\<leadsto> xa\n                                    \\<in> Clock.jkbpC \\<and>\n                                    tLength t' = tLength t \\<and>\n                                    envObs a (tLast t') =\n                                    envObs a (tLast t)) \\<and>\n                                x =\n                                clock_mkSuccs (envObs a) (envObs a xa)\n                                 (local.clock_trans aa aa)) \\<and>\n                            rel_ext\n                             (\\<lambda>y.\n                                 \\<exists>x.\n                                    x \\<in> Clock.jkbpC \\<and>\n                                    tLength x = Suc (tLength t) \\<and>\n                                    envObs a (tLast x) = envObs a s \\<and>\n                                    y = clock_sim x) =\n                            rel_ext\n                             (\\<lambda>uu_.\n                                 \\<exists>s.\n                                    uu_ = (toSet (fst x), s) \\<and>\n                                    s \\<in> toSet (snd x))", "apply (rule_tac x=\"clock_mkSuccs (envObs a) (envObs a s) (clock_trans aa aa)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>x.\n                             (\\<exists>t'.\n                                 t' \\<leadsto> x \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t \\<and>\n                                 envObs a (tLast t') =\n                                 envObs a (tLast t)) \\<and>\n                             clock_mkSuccs (envObs a) (envObs a s)\n                              (local.clock_trans aa aa) =\n                             clock_mkSuccs (envObs a) (envObs a x)\n                              (local.clock_trans aa aa)) \\<and>\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x.\n                                 x \\<in> Clock.jkbpC \\<and>\n                                 tLength x = Suc (tLength t) \\<and>\n                                 envObs a (tLast x) = envObs a s \\<and>\n                                 y = clock_sim x) =\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>sa.\n                                 uu_ =\n                                 (toSet\n                                   (fst (clock_mkSuccs (envObs a)\n    (envObs a s) (local.clock_trans aa aa))),\n                                  sa) \\<and>\n                                 sa \\<in> toSet\n     (snd (clock_mkSuccs (envObs a) (envObs a s)\n            (local.clock_trans aa aa))))", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>t'.\n                                t' \\<leadsto> x \\<in> Clock.jkbpC \\<and>\n                                tLength t' = tLength t \\<and>\n                                envObs a (tLast t') =\n                                envObs a (tLast t)) \\<and>\n                            clock_mkSuccs (envObs a) (envObs a s)\n                             (local.clock_trans aa aa) =\n                            clock_mkSuccs (envObs a) (envObs a x)\n                             (local.clock_trans aa aa)\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa.\n                            (aaa, ba) =\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) \\<and>\n                            sa \\<in> toSet\n(snd (clock_mkSuccs (envObs a) (envObs a s) (local.clock_trans aa aa)))\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sa.\n                            (aaa, ba) =\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) \\<and>\n                            sa \\<in> toSet\n(snd (clock_mkSuccs (envObs a) (envObs a s) (local.clock_trans aa aa)))\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=\"tLast x\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> (aaa, ba) =\n                         (toSet\n                           (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                  (local.clock_trans aa aa))),\n                          tLast x) \\<and>\n                         tLast x\n                         \\<in> toSet\n                                (snd (clock_mkSuccs (envObs a) (envObs a s)\n (local.clock_trans aa aa)))\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (clarsimp simp: clock_trans_common[OF tC ec] clock_mkSuccs_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> clock_sim x =\n                         (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          tLast x) \\<and>\n                         (\\<exists>t'.\n                             t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                             tLength t' = tLength t)\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> clock_sim x =\n                         (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          tLast x)\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (clarsimp simp: clock_sim_def simp del: Clock.jkbpCn.simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> tLast ` Clock.jkbpCn (Suc (tLength t)) =\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> tLast ` Clock.jkbpCn (Suc (tLength t))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (clarsimp simp: Let_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> envTrans eact aact (tLast ta)\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=\"ta\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength ta = tLength t\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (clarsimp simp: Let_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast ta) =\n                            envTrans eacta aacta (tLast ta) \\<and>\n                            eacta \\<in> set (envAction (tLast ta)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set\n (jAction (Clock.MCn (tLength t)) ta a))\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=eact in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aacta.\n                            envTrans eact aact (tLast ta) =\n                            envTrans eact aacta (tLast ta) \\<and>\n                            eact \\<in> set (envAction (tLast ta)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set\n (jAction (Clock.MCn (tLength t)) ta a))\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=aact in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b t' s x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> envTrans eact aact (tLast ta) =\n                         envTrans eact aact (tLast ta) \\<and>\n                         eact \\<in> set (envAction (tLast ta)) \\<and>\n                         (\\<forall>a.\n                             aact a\n                             \\<in> set (jAction (Clock.MCn (tLength t)) ta\n   a))\n 2. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 3. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 4. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t);\n        envObs a (tLast x) = envObs a s\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast ` Clock.jkbpCn (Suc (tLength t))\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (clarsimp simp: Let_def Set.image_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s x xa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        t'a \\<leadsto> xa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>ta eact aact.\n                                x =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            xa = tLast x\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (drule_tac t=\"t'a \\<leadsto> xa\" in Clock.jkbpC_tLength_inv[OF _ refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s x xa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        tLength t'a = tLength t;\n        t'a \\<leadsto> xa\n        \\<in> Clock.jkbpCn (tLength (t'a \\<leadsto> xa))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            (\\<exists>ta eact aact.\n                                x =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            xa = tLast x\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=\"t'a \\<leadsto> xa\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b t' s x xa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        tLength t'a = tLength t;\n        t'a \\<leadsto> xa\n        \\<in> Clock.jkbpCn (tLength (t'a \\<leadsto> xa))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ta eact aact.\n                             t'a \\<leadsto> xa =\n                             ta \\<leadsto>\n                             envTrans eact aact (tLast ta) \\<and>\n                             ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                             eact \\<in> set (envAction (tLast ta)) \\<and>\n                             (\\<forall>a.\n                                 aact a\n                                 \\<in> set\n  (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                         xa = tLast (t'a \\<leadsto> xa)\n 2. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 3. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (auto simp: Let_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); x \\<in> Clock.jkbpC;\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (drule_tac t=\"x\" in Clock.jkbpC_tLength_inv[OF _ refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x; x \\<in> Clock.jkbpCn (tLength x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (simp only: Let_def Clock.jkbpCn.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        tLength x = Suc (tLength t); envObs a (tLast x) = envObs a s;\n        (aaa, ba) = clock_sim x;\n        x \\<in> rel_ext\n                 (\\<lambda>uu_.\n                     \\<exists>ta eact aact.\n                        uu_ =\n                        ta \\<leadsto> envTrans eact aact (tLast ta) \\<and>\n                        ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                        eact \\<in> set (envAction (tLast ta)) \\<and>\n                        (\\<forall>a.\n                            aact a\n                            \\<in> set (jAction (Clock.MCn (tLength t)) ta\n  a)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> tLast x \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        tLength (ta \\<leadsto> envTrans eact aact (tLast ta)) =\n        Suc (tLength t);\n        envObs a (tLast (ta \\<leadsto> envTrans eact aact (tLast ta))) =\n        envObs a s;\n        (aaa, ba) = clock_sim (ta \\<leadsto> envTrans eact aact (tLast ta));\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto>\n                            tLast\n                             (ta \\<leadsto> envTrans eact aact (tLast ta))\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=\"ta\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba x ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        tLength (ta \\<leadsto> envTrans eact aact (tLast ta)) =\n        Suc (tLength t);\n        envObs a (tLast (ta \\<leadsto> envTrans eact aact (tLast ta))) =\n        envObs a s;\n        (aaa, ba) = clock_sim (ta \\<leadsto> envTrans eact aact (tLast ta));\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto>\n                         tLast (ta \\<leadsto> envTrans eact aact (tLast ta))\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength ta = tLength t\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        envObs a (envTrans eact aact (tLast ta)) = envObs a s;\n        (aaa, ba) = clock_sim (ta \\<leadsto> envTrans eact aact (tLast ta));\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s aaa ba ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        envObs a (envTrans eact aact (tLast ta)) = envObs a s;\n        (aaa, ba) = clock_sim (ta \\<leadsto> envTrans eact aact (tLast ta));\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))\n 2. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (auto simp: Let_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s aaa ba sa.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t);\n        sa \\<in> toSet\n                  (snd (clock_mkSuccs (envObs a) (envObs a s)\n                         (local.clock_trans aa aa)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (toSet\n                              (fst (clock_mkSuccs (envObs a) (envObs a s)\n                                     (local.clock_trans aa aa))),\n                             sa) =\n                            clock_sim x", "apply (clarsimp simp: clock_trans_common[OF tC ec] clock_mkSuccs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            x \\<in> Clock.jkbpC \\<and>\n                            tLength x = Suc (tLength t) \\<and>\n                            envObs a (tLast x) = envObs a s \\<and>\n                            (rel_ext\n                              (\\<lambda>uu_.\n                                  \\<exists>t'.\n                                     t' \\<leadsto> uu_\n                                     \\<in> Clock.jkbpC \\<and>\n                                     tLength t' = tLength t),\n                             sa) =\n                            clock_sim x", "apply (rule_tac x=\"t'a \\<leadsto> sa\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> t'a \\<leadsto> sa \\<in> Clock.jkbpC \\<and>\n                         tLength (t'a \\<leadsto> sa) =\n                         Suc (tLength t) \\<and>\n                         envObs a (tLast (t'a \\<leadsto> sa)) =\n                         envObs a s \\<and>\n                         (rel_ext\n                           (\\<lambda>uu_.\n                               \\<exists>t'.\n                                  t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                  tLength t' = tLength t),\n                          sa) =\n                         clock_sim (t'a \\<leadsto> sa)", "apply (clarsimp simp: clock_sim_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t) =\n                         tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))", "(* FIXME similar to above *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t) =\n                         tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t'.\n                                 t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                                 tLength t' = tLength t)\n                         \\<subseteq> tLast `\n                                     rel_ext\n(\\<lambda>uu_.\n    \\<exists>ta eact aact.\n       uu_ = ta \\<leadsto> envTrans eact aact (tLast ta) \\<and>\n       ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n       eact \\<in> set (envAction (tLast ta)) \\<and>\n       (\\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)))\n 2. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)", "apply (clarsimp simp: Set.image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s sa t'a x t'b.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        t'b \\<leadsto> x \\<in> Clock.jkbpC; tLength t'b = tLength t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>ta eact aact.\n                                xa =\n                                ta \\<leadsto>\n                                envTrans eact aact (tLast ta) \\<and>\n                                ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                eact \\<in> set (envAction (tLast ta)) \\<and>\n                                (\\<forall>a.\n                                    aact a\n                                    \\<in> set\n     (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                            x = tLast xa\n 2. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)", "apply (rule_tac x=\"t'b \\<leadsto> x\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s sa t'a x t'b.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        t'b \\<leadsto> x \\<in> Clock.jkbpC; tLength t'b = tLength t\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ta eact aact.\n                             t'b \\<leadsto> x =\n                             ta \\<leadsto>\n                             envTrans eact aact (tLast ta) \\<and>\n                             ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                             eact \\<in> set (envAction (tLast ta)) \\<and>\n                             (\\<forall>a.\n                                 aact a\n                                 \\<in> set\n  (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                         x = tLast (t'b \\<leadsto> x)\n 2. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)", "apply (drule_tac t=\"t'b \\<leadsto> x\" in Clock.jkbpC_tLength_inv[OF _ refl])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b t' s sa t'a x t'b.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        tLength t'b = tLength t;\n        t'b \\<leadsto> x\n        \\<in> Clock.jkbpCn (tLength (t'b \\<leadsto> x))\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ta eact aact.\n                             t'b \\<leadsto> x =\n                             ta \\<leadsto>\n                             envTrans eact aact (tLast ta) \\<and>\n                             ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                             eact \\<in> set (envAction (tLast ta)) \\<and>\n                             (\\<forall>a.\n                                 aact a\n                                 \\<in> set\n  (jAction (Clock.MCn (tLength t)) ta a))) \\<and>\n                         x = tLast (t'b \\<leadsto> x)\n 2. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)", "apply (auto simp: Let_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC;\n        tLength t'a = tLength t\\<rbrakk>\n       \\<Longrightarrow> tLast `\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>ta eact aact.\n                                 uu_ =\n                                 ta \\<leadsto>\n                                 envTrans eact aact (tLast ta) \\<and>\n                                 ta \\<in> Clock.jkbpCn (tLength t) \\<and>\n                                 eact\n                                 \\<in> set (envAction (tLast ta)) \\<and>\n                                 (\\<forall>a.\n                                     aact a\n                                     \\<in> set\n      (jAction (Clock.MCn (tLength t)) ta a)))\n                         \\<subseteq> rel_ext\n(\\<lambda>uu_.\n    \\<exists>t'.\n       t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and> tLength t' = tLength t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t'.\n                            t' \\<leadsto> envTrans eact aact (tLast ta)\n                            \\<in> Clock.jkbpC \\<and>\n                            tLength t' = tLength t", "apply (rule_tac x=\"ta\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC \\<and>\n                         tLength ta = tLength t", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpC", "apply (rule Clock.jkbpCn_jkbpC_inc[where n=\"Suc (tLength t)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b t' s sa t'a ta eact aact.\n       \\<lbrakk>ec = (aa, b);\n        toSet (local.clock_trans aa aa) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t);\n        toSet (local.clock_trans aa b) =\n        rel_ext\n         (\\<lambda>uu_.\n             \\<exists>t'.\n                t' \\<leadsto> uu_ \\<in> Clock.jkbpC \\<and>\n                tLength t' = tLength t \\<and>\n                envObs a (tLast t') = envObs a (tLast t));\n        t' \\<leadsto> s \\<in> Clock.jkbpC; tLength t' = tLength t;\n        envObs a (tLast t') = envObs a (tLast t); envObs a sa = envObs a s;\n        t'a \\<leadsto> sa \\<in> Clock.jkbpC; tLength t'a = tLength t;\n        ta \\<in> Clock.jkbpCn (tLength t);\n        eact \\<in> set (envAction (tLast ta));\n        \\<forall>a.\n           aact a \\<in> set (jAction (Clock.MCn (tLength t)) ta a)\\<rbrakk>\n       \\<Longrightarrow> ta \\<leadsto> envTrans eact aact (tLast ta)\n                         \\<in> Clock.jkbpCn (Suc (tLength t))", "apply (auto simp: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_ext\n   (\\<lambda>uu_.\n       \\<exists>t' s.\n          uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n          t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n          clock_jview a t' = clock_jview a t)\n  \\<subseteq> clock_simAbs ` set (local.clock_simTrans a ec)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "(* context FiniteLinorderEnvironment *)\n\n(* **************************************** *)"], ["", "subsubsection\\<open>Maps\\<close>"], ["", "text\\<open>\n\n\\label{sec:kbps-theory-clock-view-maps}\n\nAs mentioned above, the canonicity of our ordered, distinct list\nrepresentation of automaton states allows us to use them as keys in a\ndigital trie; a value of type @{typ \"('key, 'val) trie\"} maps keys of\ntype @{typ \"'key list\"} to values of type @{typ \"'val\"}.\n\nIn this specific case we track automaton transitions using a two-level\nstructure mapping sets of states to an association list mapping\nobservations to sets of states, and for actions automaton states map\ndirectly to agent actions.\n\n\\<close>"], ["", "type_synonym ('s, 'obs) clock_trans_trie\n  = \"('s, ('s, ('obs, 's clock_simWorldsRep) mapping) trie) trie\""], ["", "type_synonym ('s, 'aAct) clock_acts_trie = \"('s, ('s, 'aAct) trie) trie\""], ["", "(*<*)"], ["", "definition\n  trans_MapOps_lookup :: \"('s :: linorder, 'obs) clock_trans_trie\n                        \\<Rightarrow> 's clock_simWorldsRep \\<times> 'obs\n                        \\<rightharpoonup> 's clock_simWorldsRep\"\nwhere\n  \"trans_MapOps_lookup \\<equiv> \\<lambda>m k.\n     Option.bind (trie_odlist_lookup m (fst (fst k))) (\\<lambda>m.\n       (Option.bind (trie_odlist_lookup m (snd (fst k))) (\\<lambda>m.\n         Mapping.lookup m (snd k))))\""], ["", "definition\n  trans_MapOps_update :: \"('s :: linorder) clock_simWorldsRep \\<times> 'obs \\<Rightarrow> 's clock_simWorldsRep\n                        \\<Rightarrow> ('s :: linorder, 'obs) clock_trans_trie\n                        \\<Rightarrow> ('s :: linorder, 'obs) clock_trans_trie\"\nwhere\n  \"trans_MapOps_update \\<equiv> \\<lambda>k v m.\n     trie_odlist_update_with (fst (fst k)) m empty_trie (\\<lambda>m.\n       trie_odlist_update_with (snd (fst k)) m Mapping.empty (\\<lambda>m.\n          Mapping.update (snd k) v m))\""], ["", "definition\n  trans_MapOps :: \"(('s :: linorder, 'obs) clock_trans_trie,\n                    's clock_simWorldsRep \\<times> 'obs, 's clock_simWorldsRep) MapOps\"\nwhere\n  \"trans_MapOps \\<equiv>\n     \\<lparr> MapOps.empty = empty_trie,\n       lookup = trans_MapOps_lookup,\n       update = trans_MapOps_update \\<rparr>\""], ["", "lemma (in FiniteLinorderEnvironment) trans_MapOps:\n  \"MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k)) (Clock.jkbpSEC \\<times> UNIV) trans_MapOps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       (clock_simAbs (fst k), snd k)\n       \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n             UNIV \\<Longrightarrow>\n       MapOps.lookup trans_MapOps (MapOps.empty trans_MapOps) k = None\n 2. \\<And>e k k' M.\n       \\<lbrakk>(clock_simAbs (fst k), snd k)\n                \\<in> (\\<Union>a.\n                          Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n                      UNIV;\n        (clock_simAbs (fst k'), snd k')\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n              UNIV\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trans_MapOps\n                          (update trans_MapOps k e M) k' =\n                         (if (clock_simAbs (fst k'), snd k') =\n                             (clock_simAbs (fst k), snd k)\n                          then Some e else MapOps.lookup trans_MapOps M k')", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       (clock_simAbs (fst k), snd k)\n       \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n             UNIV \\<Longrightarrow>\n       MapOps.lookup trans_MapOps (MapOps.empty trans_MapOps) k = None\n 2. \\<And>e k k' M.\n       \\<lbrakk>(clock_simAbs (fst k), snd k)\n                \\<in> (\\<Union>a.\n                          Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n                      UNIV;\n        (clock_simAbs (fst k'), snd k')\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n              UNIV\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trans_MapOps\n                          (update trans_MapOps k e M) k' =\n                         (if (clock_simAbs (fst k'), snd k') =\n                             (clock_simAbs (fst k), snd k)\n                          then Some e else MapOps.lookup trans_MapOps M k')", "show \"MapOps.lookup trans_MapOps (MapOps.empty trans_MapOps) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps.lookup trans_MapOps (MapOps.empty trans_MapOps) k = None", "unfolding trans_MapOps_def trans_MapOps_lookup_def trie_odlist_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps.lookup\n     \\<lparr>MapOps.empty = empty_trie,\n        lookup =\n          \\<lambda>m k.\n             Option.bind ((lookup_trie m \\<circ> toList) (fst (fst k)))\n              (\\<lambda>m.\n                  Option.bind ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                   (\\<lambda>m. Mapping.lookup m (snd k))),\n        update = trans_MapOps_update\\<rparr>\n     (MapOps.empty\n       \\<lparr>MapOps.empty = empty_trie,\n          lookup =\n            \\<lambda>m k.\n               Option.bind ((lookup_trie m \\<circ> toList) (fst (fst k)))\n                (\\<lambda>m.\n                    Option.bind\n                     ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                     (\\<lambda>m. Mapping.lookup m (snd k))),\n          update = trans_MapOps_update\\<rparr>)\n     k =\n    None", "by (auto split: prod.split)"], ["proof (state)\nthis:\n  MapOps.lookup trans_MapOps (MapOps.empty trans_MapOps) k = None\n\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>(clock_simAbs (fst k), snd k)\n                \\<in> (\\<Union>a.\n                          Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n                      UNIV;\n        (clock_simAbs (fst k'), snd k')\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n              UNIV\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trans_MapOps\n                          (update trans_MapOps k e M) k' =\n                         (if (clock_simAbs (fst k'), snd k') =\n                             (clock_simAbs (fst k), snd k)\n                          then Some e else MapOps.lookup trans_MapOps M k')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>(clock_simAbs (fst k), snd k)\n                \\<in> (\\<Union>a.\n                          Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n                      UNIV;\n        (clock_simAbs (fst k'), snd k')\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n              UNIV\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trans_MapOps\n                          (update trans_MapOps k e M) k' =\n                         (if (clock_simAbs (fst k'), snd k') =\n                             (clock_simAbs (fst k), snd k)\n                          then Some e else MapOps.lookup trans_MapOps M k')", "fix e k k' M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>(clock_simAbs (fst k), snd k)\n                \\<in> (\\<Union>a.\n                          Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n                      UNIV;\n        (clock_simAbs (fst k'), snd k')\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n              UNIV\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trans_MapOps\n                          (update trans_MapOps k e M) k' =\n                         (if (clock_simAbs (fst k'), snd k') =\n                             (clock_simAbs (fst k), snd k)\n                          then Some e else MapOps.lookup trans_MapOps M k')", "assume k: \"(clock_simAbs (fst k), snd k) \\<in> Clock.jkbpSEC \\<times> (UNIV :: 'z set)\"\n     and k': \"(clock_simAbs (fst k'), snd k') \\<in> Clock.jkbpSEC \\<times> (UNIV :: 'z set)\""], ["proof (state)\nthis:\n  (clock_simAbs (fst k), snd k)\n  \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV\n  (clock_simAbs (fst k'), snd k')\n  \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>(clock_simAbs (fst k), snd k)\n                \\<in> (\\<Union>a.\n                          Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n                      UNIV;\n        (clock_simAbs (fst k'), snd k')\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times>\n              UNIV\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trans_MapOps\n                          (update trans_MapOps k e M) k' =\n                         (if (clock_simAbs (fst k'), snd k') =\n                             (clock_simAbs (fst k), snd k)\n                          then Some e else MapOps.lookup trans_MapOps M k')", "show \"MapOps.lookup trans_MapOps (MapOps.update trans_MapOps k e M) k'\n         = (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n             then Some e else MapOps.lookup trans_MapOps M k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "proof(cases \"(clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (clock_simAbs (fst k'), snd k') =\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')\n 2. (clock_simAbs (fst k'), snd k') \\<noteq>\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "case True"], ["proof (state)\nthis:\n  (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n\ngoal (2 subgoals):\n 1. (clock_simAbs (fst k'), snd k') =\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')\n 2. (clock_simAbs (fst k'), snd k') \\<noteq>\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "hence \"k = k'\""], ["proof (prove)\nusing this:\n  (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n\ngoal (1 subgoal):\n 1. k = k'", "using inj_onD[OF clock_simAbs_inj_on] k k'"], ["proof (prove)\nusing this:\n  (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n  \\<lbrakk>clock_simAbs ?x = clock_simAbs ?y;\n   ?x \\<in> rel_ext\n             (\\<lambda>x.\n                 clock_simAbs x\n                 \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC));\n   ?y \\<in> rel_ext\n             (\\<lambda>x.\n                 clock_simAbs x\n                 \\<in> (\\<Union>a.\n                           Clock.sim_equiv_class a ` Clock.jkbpC))\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  (clock_simAbs (fst k), snd k)\n  \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV\n  (clock_simAbs (fst k'), snd k')\n  \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. k = k'", "by (auto iff: prod_eqI)"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. (clock_simAbs (fst k'), snd k') =\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')\n 2. (clock_simAbs (fst k'), snd k') \\<noteq>\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "unfolding trans_MapOps_def trans_MapOps_lookup_def trans_MapOps_update_def trie_odlist_lookup_def trie_odlist_update_with_def"], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. MapOps.lookup\n     \\<lparr>MapOps.empty = empty_trie,\n        lookup =\n          \\<lambda>m k.\n             Option.bind ((lookup_trie m \\<circ> toList) (fst (fst k)))\n              (\\<lambda>m.\n                  Option.bind ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                   (\\<lambda>m. Mapping.lookup m (snd k))),\n        update =\n          \\<lambda>k v m.\n             trie_update_with' (toList (fst (fst k))) m empty_trie\n              (trie_update_with (toList (snd (fst k))) Mapping.empty\n                (Mapping.update (snd k) v))\\<rparr>\n     (update\n       \\<lparr>MapOps.empty = empty_trie,\n          lookup =\n            \\<lambda>m k.\n               Option.bind ((lookup_trie m \\<circ> toList) (fst (fst k)))\n                (\\<lambda>m.\n                    Option.bind\n                     ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                     (\\<lambda>m. Mapping.lookup m (snd k))),\n          update =\n            \\<lambda>k v m.\n               trie_update_with' (toList (fst (fst k))) m empty_trie\n                (trie_update_with (toList (snd (fst k))) Mapping.empty\n                  (Mapping.update (snd k) v))\\<rparr>\n       k e M)\n     k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e\n     else MapOps.lookup\n           \\<lparr>MapOps.empty = empty_trie,\n              lookup =\n                \\<lambda>m k.\n                   Option.bind\n                    ((lookup_trie m \\<circ> toList) (fst (fst k)))\n                    (\\<lambda>m.\n                        Option.bind\n                         ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                         (\\<lambda>m. Mapping.lookup m (snd k))),\n              update =\n                \\<lambda>k v m.\n                   trie_update_with' (toList (fst (fst k))) m empty_trie\n                    (trie_update_with (toList (snd (fst k))) Mapping.empty\n                      (Mapping.update (snd k) v))\\<rparr>\n           M k')", "by (simp add: lookup_trie_update_with lookup_update split: option.split prod.split)"], ["proof (state)\nthis:\n  MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n  (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n   then Some e else MapOps.lookup trans_MapOps M k')\n\ngoal (1 subgoal):\n 1. (clock_simAbs (fst k'), snd k') \\<noteq>\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (clock_simAbs (fst k'), snd k') \\<noteq>\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "case False"], ["proof (state)\nthis:\n  (clock_simAbs (fst k'), snd k') \\<noteq> (clock_simAbs (fst k), snd k)\n\ngoal (1 subgoal):\n 1. (clock_simAbs (fst k'), snd k') \\<noteq>\n    (clock_simAbs (fst k), snd k) \\<Longrightarrow>\n    MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "thus ?thesis"], ["proof (prove)\nusing this:\n  (clock_simAbs (fst k'), snd k') \\<noteq> (clock_simAbs (fst k), snd k)\n\ngoal (1 subgoal):\n 1. MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e else MapOps.lookup trans_MapOps M k')", "unfolding trans_MapOps_def trans_MapOps_lookup_def trans_MapOps_update_def trie_odlist_lookup_def trie_odlist_update_with_def"], ["proof (prove)\nusing this:\n  (clock_simAbs (fst k'), snd k') \\<noteq> (clock_simAbs (fst k), snd k)\n\ngoal (1 subgoal):\n 1. MapOps.lookup\n     \\<lparr>MapOps.empty = empty_trie,\n        lookup =\n          \\<lambda>m k.\n             Option.bind ((lookup_trie m \\<circ> toList) (fst (fst k)))\n              (\\<lambda>m.\n                  Option.bind ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                   (\\<lambda>m. Mapping.lookup m (snd k))),\n        update =\n          \\<lambda>k v m.\n             trie_update_with' (toList (fst (fst k))) m empty_trie\n              (trie_update_with (toList (snd (fst k))) Mapping.empty\n                (Mapping.update (snd k) v))\\<rparr>\n     (update\n       \\<lparr>MapOps.empty = empty_trie,\n          lookup =\n            \\<lambda>m k.\n               Option.bind ((lookup_trie m \\<circ> toList) (fst (fst k)))\n                (\\<lambda>m.\n                    Option.bind\n                     ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                     (\\<lambda>m. Mapping.lookup m (snd k))),\n          update =\n            \\<lambda>k v m.\n               trie_update_with' (toList (fst (fst k))) m empty_trie\n                (trie_update_with (toList (snd (fst k))) Mapping.empty\n                  (Mapping.update (snd k) v))\\<rparr>\n       k e M)\n     k' =\n    (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n     then Some e\n     else MapOps.lookup\n           \\<lparr>MapOps.empty = empty_trie,\n              lookup =\n                \\<lambda>m k.\n                   Option.bind\n                    ((lookup_trie m \\<circ> toList) (fst (fst k)))\n                    (\\<lambda>m.\n                        Option.bind\n                         ((lookup_trie m \\<circ> toList) (snd (fst k)))\n                         (\\<lambda>m. Mapping.lookup m (snd k))),\n              update =\n                \\<lambda>k v m.\n                   trie_update_with' (toList (fst (fst k))) m empty_trie\n                    (trie_update_with (toList (snd (fst k))) Mapping.empty\n                      (Mapping.update (snd k) v))\\<rparr>\n           M k')", "by (cases \"fst k = fst k'\")\n       (auto simp add: lookup_empty lookup_update_neq prod_eq_iff lookup_trie_update_with split: option.split prod.split)"], ["proof (state)\nthis:\n  MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n  (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n   then Some e else MapOps.lookup trans_MapOps M k')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MapOps.lookup trans_MapOps (update trans_MapOps k e M) k' =\n  (if (clock_simAbs (fst k'), snd k') = (clock_simAbs (fst k), snd k)\n   then Some e else MapOps.lookup trans_MapOps M k')\n\ngoal:\nNo subgoals!", "qed"], ["", "(* A map for the agent actions. *)"], ["", "definition\n  acts_MapOps_lookup :: \"('s :: linorder, 'aAct) clock_acts_trie\n                      \\<Rightarrow> 's clock_simWorldsRep\n                      \\<rightharpoonup> 'aAct\"\nwhere\n  \"acts_MapOps_lookup \\<equiv> \\<lambda>m k.\n     Option.bind (trie_odlist_lookup m (fst k)) (\\<lambda>m.\n       (trie_odlist_lookup m (snd k)))\""], ["", "definition\n  acts_MapOps_update :: \"('s :: linorder) clock_simWorldsRep \\<Rightarrow> 'aAct\n                      \\<Rightarrow> ('s :: linorder, 'aAct) clock_acts_trie\n                      \\<Rightarrow> ('s :: linorder, 'aAct) clock_acts_trie\"\nwhere\n  \"acts_MapOps_update \\<equiv> \\<lambda>k v m.\n     trie_odlist_update_with (fst k) m empty_trie (\\<lambda>m.\n       trie_odlist_update (snd k) v m)\""], ["", "definition\n  acts_MapOps :: \"(('s :: linorder, 'aAct) clock_acts_trie, 's clock_simWorldsRep, 'aAct) MapOps\"\nwhere\n  \"acts_MapOps \\<equiv>\n     \\<lparr> MapOps.empty = empty_trie,\n       lookup = acts_MapOps_lookup,\n       update = acts_MapOps_update \\<rparr>\""], ["", "lemma (in FiniteLinorderEnvironment) acts_MapOps:\n  \"MapOps clock_simAbs Clock.jkbpSEC acts_MapOps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       clock_simAbs k\n       \\<in> (\\<Union>a.\n                 Clock.sim_equiv_class a ` Clock.jkbpC) \\<Longrightarrow>\n       MapOps.lookup acts_MapOps (MapOps.empty acts_MapOps) k = None\n 2. \\<And>e k k' M.\n       \\<lbrakk>clock_simAbs k\n                \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC);\n        clock_simAbs k'\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup acts_MapOps\n                          (update acts_MapOps k e M) k' =\n                         (if clock_simAbs k' = clock_simAbs k then Some e\n                          else MapOps.lookup acts_MapOps M k')", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       clock_simAbs k\n       \\<in> (\\<Union>a.\n                 Clock.sim_equiv_class a ` Clock.jkbpC) \\<Longrightarrow>\n       MapOps.lookup acts_MapOps (MapOps.empty acts_MapOps) k = None\n 2. \\<And>e k k' M.\n       \\<lbrakk>clock_simAbs k\n                \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC);\n        clock_simAbs k'\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup acts_MapOps\n                          (update acts_MapOps k e M) k' =\n                         (if clock_simAbs k' = clock_simAbs k then Some e\n                          else MapOps.lookup acts_MapOps M k')", "show \"MapOps.lookup acts_MapOps (MapOps.empty acts_MapOps) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps.lookup acts_MapOps (MapOps.empty acts_MapOps) k = None", "unfolding acts_MapOps_def acts_MapOps_lookup_def trie_odlist_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps.lookup\n     \\<lparr>MapOps.empty = empty_trie,\n        lookup =\n          \\<lambda>m k.\n             Option.bind ((lookup_trie m \\<circ> toList) (fst k))\n              (\\<lambda>m. (lookup_trie m \\<circ> toList) (snd k)),\n        update = acts_MapOps_update\\<rparr>\n     (MapOps.empty\n       \\<lparr>MapOps.empty = empty_trie,\n          lookup =\n            \\<lambda>m k.\n               Option.bind ((lookup_trie m \\<circ> toList) (fst k))\n                (\\<lambda>m. (lookup_trie m \\<circ> toList) (snd k)),\n          update = acts_MapOps_update\\<rparr>)\n     k =\n    None", "by auto"], ["proof (state)\nthis:\n  MapOps.lookup acts_MapOps (MapOps.empty acts_MapOps) k = None\n\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>clock_simAbs k\n                \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC);\n        clock_simAbs k'\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup acts_MapOps\n                          (update acts_MapOps k e M) k' =\n                         (if clock_simAbs k' = clock_simAbs k then Some e\n                          else MapOps.lookup acts_MapOps M k')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>clock_simAbs k\n                \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC);\n        clock_simAbs k'\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup acts_MapOps\n                          (update acts_MapOps k e M) k' =\n                         (if clock_simAbs k' = clock_simAbs k then Some e\n                          else MapOps.lookup acts_MapOps M k')", "fix e k k' M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>clock_simAbs k\n                \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC);\n        clock_simAbs k'\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup acts_MapOps\n                          (update acts_MapOps k e M) k' =\n                         (if clock_simAbs k' = clock_simAbs k then Some e\n                          else MapOps.lookup acts_MapOps M k')", "assume k: \"clock_simAbs k \\<in> Clock.jkbpSEC\"\n     and k': \"clock_simAbs k' \\<in> Clock.jkbpSEC\""], ["proof (state)\nthis:\n  clock_simAbs k \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n  clock_simAbs k' \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n\ngoal (1 subgoal):\n 1. \\<And>e k k' M.\n       \\<lbrakk>clock_simAbs k\n                \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC);\n        clock_simAbs k'\n        \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup acts_MapOps\n                          (update acts_MapOps k e M) k' =\n                         (if clock_simAbs k' = clock_simAbs k then Some e\n                          else MapOps.lookup acts_MapOps M k')", "show \"MapOps.lookup acts_MapOps (MapOps.update acts_MapOps k e M) k'\n         = (if clock_simAbs k' = clock_simAbs k\n             then Some e else MapOps.lookup acts_MapOps M k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "proof(cases \"clock_simAbs k' = clock_simAbs k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. clock_simAbs k' = clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')\n 2. clock_simAbs k' \\<noteq> clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "case True"], ["proof (state)\nthis:\n  clock_simAbs k' = clock_simAbs k\n\ngoal (2 subgoals):\n 1. clock_simAbs k' = clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')\n 2. clock_simAbs k' \\<noteq> clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "hence \"k = k'\""], ["proof (prove)\nusing this:\n  clock_simAbs k' = clock_simAbs k\n\ngoal (1 subgoal):\n 1. k = k'", "using inj_onD[OF clock_simAbs_inj_on] k k'"], ["proof (prove)\nusing this:\n  clock_simAbs k' = clock_simAbs k\n  \\<lbrakk>clock_simAbs ?x = clock_simAbs ?y;\n   ?x \\<in> rel_ext\n             (\\<lambda>x.\n                 clock_simAbs x\n                 \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC));\n   ?y \\<in> rel_ext\n             (\\<lambda>x.\n                 clock_simAbs x\n                 \\<in> (\\<Union>a.\n                           Clock.sim_equiv_class a ` Clock.jkbpC))\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  clock_simAbs k \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n  clock_simAbs k' \\<in> (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n\ngoal (1 subgoal):\n 1. k = k'", "by (auto iff: prod_eqI)"], ["proof (state)\nthis:\n  k = k'\n\ngoal (2 subgoals):\n 1. clock_simAbs k' = clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')\n 2. clock_simAbs k' \\<noteq> clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "unfolding acts_MapOps_def acts_MapOps_lookup_def acts_MapOps_update_def"], ["proof (prove)\nusing this:\n  k = k'\n\ngoal (1 subgoal):\n 1. MapOps.lookup\n     \\<lparr>MapOps.empty = empty_trie,\n        lookup =\n          \\<lambda>m k.\n             Option.bind (trie_odlist_lookup m (fst k))\n              (\\<lambda>m. trie_odlist_lookup m (snd k)),\n        update =\n          \\<lambda>k v m.\n             trie_odlist_update_with (fst k) m empty_trie\n              (trie_odlist_update (snd k) v)\\<rparr>\n     (update\n       \\<lparr>MapOps.empty = empty_trie,\n          lookup =\n            \\<lambda>m k.\n               Option.bind (trie_odlist_lookup m (fst k))\n                (\\<lambda>m. trie_odlist_lookup m (snd k)),\n          update =\n            \\<lambda>k v m.\n               trie_odlist_update_with (fst k) m empty_trie\n                (trie_odlist_update (snd k) v)\\<rparr>\n       k e M)\n     k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup\n           \\<lparr>MapOps.empty = empty_trie,\n              lookup =\n                \\<lambda>m k.\n                   Option.bind (trie_odlist_lookup m (fst k))\n                    (\\<lambda>m. trie_odlist_lookup m (snd k)),\n              update =\n                \\<lambda>k v m.\n                   trie_odlist_update_with (fst k) m empty_trie\n                    (trie_odlist_update (snd k) v)\\<rparr>\n           M k')", "by (auto simp: lookup_trie_update lookup_trie_update_with\n                     trie_odlist_update_with_def trie_odlist_update_def trie_odlist_lookup_def)"], ["proof (state)\nthis:\n  MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n  (if clock_simAbs k' = clock_simAbs k then Some e\n   else MapOps.lookup acts_MapOps M k')\n\ngoal (1 subgoal):\n 1. clock_simAbs k' \\<noteq> clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. clock_simAbs k' \\<noteq> clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "case False"], ["proof (state)\nthis:\n  clock_simAbs k' \\<noteq> clock_simAbs k\n\ngoal (1 subgoal):\n 1. clock_simAbs k' \\<noteq> clock_simAbs k \\<Longrightarrow>\n    MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "thus ?thesis"], ["proof (prove)\nusing this:\n  clock_simAbs k' \\<noteq> clock_simAbs k\n\ngoal (1 subgoal):\n 1. MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup acts_MapOps M k')", "unfolding acts_MapOps_def acts_MapOps_lookup_def acts_MapOps_update_def"], ["proof (prove)\nusing this:\n  clock_simAbs k' \\<noteq> clock_simAbs k\n\ngoal (1 subgoal):\n 1. MapOps.lookup\n     \\<lparr>MapOps.empty = empty_trie,\n        lookup =\n          \\<lambda>m k.\n             Option.bind (trie_odlist_lookup m (fst k))\n              (\\<lambda>m. trie_odlist_lookup m (snd k)),\n        update =\n          \\<lambda>k v m.\n             trie_odlist_update_with (fst k) m empty_trie\n              (trie_odlist_update (snd k) v)\\<rparr>\n     (update\n       \\<lparr>MapOps.empty = empty_trie,\n          lookup =\n            \\<lambda>m k.\n               Option.bind (trie_odlist_lookup m (fst k))\n                (\\<lambda>m. trie_odlist_lookup m (snd k)),\n          update =\n            \\<lambda>k v m.\n               trie_odlist_update_with (fst k) m empty_trie\n                (trie_odlist_update (snd k) v)\\<rparr>\n       k e M)\n     k' =\n    (if clock_simAbs k' = clock_simAbs k then Some e\n     else MapOps.lookup\n           \\<lparr>MapOps.empty = empty_trie,\n              lookup =\n                \\<lambda>m k.\n                   Option.bind (trie_odlist_lookup m (fst k))\n                    (\\<lambda>m. trie_odlist_lookup m (snd k)),\n              update =\n                \\<lambda>k v m.\n                   trie_odlist_update_with (fst k) m empty_trie\n                    (trie_odlist_update (snd k) v)\\<rparr>\n           M k')", "by (auto simp: lookup_trie_update lookup_trie_update_with\n                     trie_odlist_update_with_def trie_odlist_update_def trie_odlist_lookup_def\n               dest: prod_eqI\n              split: option.split)"], ["proof (state)\nthis:\n  MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n  (if clock_simAbs k' = clock_simAbs k then Some e\n   else MapOps.lookup acts_MapOps M k')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MapOps.lookup acts_MapOps (update acts_MapOps k e M) k' =\n  (if clock_simAbs k' = clock_simAbs k then Some e\n   else MapOps.lookup acts_MapOps M k')\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nWe define two records @{term \"acts_MapOps\"} and @{term \"trans_MapOps\"}\nsatisfying the @{term \"MapOps\"} predicate\n(\\S\\ref{sec:kbps-theory-map-ops}). Discharging the obligations in the\n@{term \"Algorithm\"} locale is routine, leaning on the work of\n\\citet{DBLP:conf/itp/LammichL10}.\n\n\\<close>"], ["", "subsubsection\\<open>Locale instantiation\\<close>"], ["", "text\\<open>\n\nFinally we assemble the algorithm and discharge the proof obligations.\n\n\\<close>"], ["", "sublocale FiniteLinorderEnvironment\n        < Clock: Algorithm\n            jkbp envInit envAction envTrans envVal\n            clock_jview envObs clock_jviewInit clock_jviewIncr\n            clock_sim clock_simRels clock_simVal\n            clock_simAbs clock_simObs clock_simInit clock_simTrans clock_simAction\n            acts_MapOps trans_MapOps"], ["proof (prove)\ngoal (1 subgoal):\n 1. Algorithm jkbp envInit envAction envTrans envVal clock_jview envObs\n     clock_jviewInit clock_jviewIncr clock_sim clock_simRels clock_simVal\n     clock_simAbs local.clock_simObs local.clock_simInit\n     local.clock_simTrans local.clock_simAction acts_MapOps trans_MapOps", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Algorithm jkbp envInit envAction envTrans envVal clock_jview envObs\n     clock_jviewInit clock_jviewIncr clock_sim clock_simRels clock_simVal\n     clock_simAbs local.clock_simObs local.clock_simInit\n     local.clock_simTrans local.clock_simAction acts_MapOps trans_MapOps", "apply (unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<forall>a iobs.\n       iobs \\<in> envObs a ` set envInit \\<longrightarrow>\n       clock_simAbs (local.clock_simInit a iobs) =\n       clock_sim `\n       rel_ext\n        (\\<lambda>t'.\n            t' \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jviewInit a iobs)\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       local.clock_simObs a ec = envObs a (tLast t)\n 3. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       set (local.clock_simAction a ec) = set (jAction Clock.MC t a)\n 4. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 5. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 6. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply clarify"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a iobs x.\n       x \\<in> set envInit \\<Longrightarrow>\n       clock_simAbs (local.clock_simInit a (envObs a x)) =\n       clock_sim `\n       rel_ext\n        (\\<lambda>t'.\n            t' \\<in> Clock.jkbpC \\<and>\n            clock_jview a t' = clock_jviewInit a (envObs a x))\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       local.clock_simObs a ec = envObs a (tLast t)\n 3. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       set (local.clock_simAction a ec) = set (jAction Clock.MC t a)\n 4. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 5. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 6. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply (rule clock_simInit)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a iobs x.\n       x \\<in> set envInit \\<Longrightarrow>\n       envObs a x \\<in> envObs a ` set envInit\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       local.clock_simObs a ec = envObs a (tLast t)\n 3. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       set (local.clock_simAction a ec) = set (jAction Clock.MC t a)\n 4. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 5. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 6. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       local.clock_simObs a ec = envObs a (tLast t)\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       set (local.clock_simAction a ec) = set (jAction Clock.MC t a)\n 3. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 4. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 5. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply clarify"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a aa b t.\n       \\<lbrakk>t \\<in> Clock.jkbpC;\n        clock_simAbs (aa, b) = Clock.sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> local.clock_simObs a (aa, b) = envObs a (tLast t)\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       set (local.clock_simAction a ec) = set (jAction Clock.MC t a)\n 3. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 4. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 5. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply (erule (1) clock_simObs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       set (local.clock_simAction a ec) = set (jAction Clock.MC t a)\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 3. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 4. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a aa b t.\n       \\<lbrakk>t \\<in> Clock.jkbpC;\n        clock_simAbs (aa, b) = Clock.sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> set (local.clock_simAction a (aa, b)) =\n                         set (jAction Clock.MC t a)\n 2. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 3. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 4. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply (erule (1) clock_simAction)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>a ec t.\n       t \\<in> Clock.jkbpC \\<and>\n       clock_simAbs ec = Clock.sim_equiv_class a t \\<longrightarrow>\n       clock_simAbs ` set (local.clock_simTrans a ec) =\n       rel_ext\n        (\\<lambda>uu_.\n            \\<exists>t' s.\n               uu_ = Clock.sim_equiv_class a (t' \\<leadsto> s) \\<and>\n               t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n               clock_jview a t' = clock_jview a t)\n 2. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 3. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa b t.\n       \\<lbrakk>t \\<in> Clock.jkbpC;\n        clock_simAbs (aa, b) = Clock.sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> clock_simAbs `\n                         set (local.clock_simTrans a (aa, b)) =\n                         rel_ext\n                          (\\<lambda>uu_.\n                              \\<exists>t' s.\n                                 uu_ =\n                                 Clock.sim_equiv_class a\n                                  (t' \\<leadsto> s) \\<and>\n                                 t' \\<leadsto> s \\<in> Clock.jkbpC \\<and>\n                                 clock_jview a t' = clock_jview a t)\n 2. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 3. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply (erule (1) clock_simTrans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. MapOps clock_simAbs (\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC)\n     acts_MapOps\n 2. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply (rule acts_MapOps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. MapOps (\\<lambda>k. (clock_simAbs (fst k), snd k))\n     ((\\<Union>a. Clock.sim_equiv_class a ` Clock.jkbpC) \\<times> UNIV)\n     trans_MapOps", "apply (rule trans_MapOps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nExplicitly, the algorithm for this case is:\n\n\\<close>"], ["", "definition\n  \"mkClockAuto \\<equiv> \\<lambda>agents jkbp envInit envAction envTrans envVal envObs.\n    mkAlgAuto acts_MapOps\n              trans_MapOps\n              (clock_simObs envObs)\n              (clock_simInit envInit envObs)\n              (clock_simTrans agents jkbp envAction envTrans envVal envObs)\n              (clock_simAction jkbp envVal envObs)\n              (\\<lambda>a. map (clock_simInit envInit envObs a \\<circ> envObs a) envInit)\""], ["", "lemma (in FiniteLinorderEnvironment) mkClockAuto_implements:\n  \"Clock.implements\n    (mkClockAuto agents jkbp envInit envAction envTrans envVal envObs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Clock.implements\n     (mkClockAuto agents jkbp envInit envAction envTrans envVal envObs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Clock.implements\n     (mkClockAuto agents jkbp envInit envAction envTrans envVal envObs)", "using Clock.k_mkAlgAuto_implements"], ["proof (prove)\nusing this:\n  Clock.implements Clock.k_mkAlgAuto\n\ngoal (1 subgoal):\n 1. Clock.implements\n     (mkClockAuto agents jkbp envInit envAction envTrans envVal envObs)", "unfolding mkClockAuto_def mkAlgAuto_def Clock.k_frontier_def"], ["proof (prove)\nusing this:\n  Clock.implements\n   (\\<lambda>a.\n       let auto =\n             alg_dfs acts_MapOps trans_MapOps (local.clock_simObs a)\n              (local.clock_simTrans a) (local.clock_simAction a)\n              (map (local.clock_simInit a \\<circ> envObs a) envInit)\n       in \\<lparr>pInit = local.clock_simInit a,\n             pTrans =\n               \\<lambda>obs ec.\n                  the (MapOps.lookup trans_MapOps (aTrans auto) (ec, obs)),\n             pAct =\n               \\<lambda>ec.\n                  the (MapOps.lookup acts_MapOps (aActs auto) ec)\\<rparr>)\n\ngoal (1 subgoal):\n 1. Clock.implements\n     (\\<lambda>a.\n         let auto =\n               alg_dfs acts_MapOps trans_MapOps (local.clock_simObs a)\n                (local.clock_simTrans a) (local.clock_simAction a)\n                (map (local.clock_simInit a \\<circ> envObs a) envInit)\n         in \\<lparr>pInit = local.clock_simInit a,\n               pTrans =\n                 \\<lambda>obs ec.\n                    the (MapOps.lookup trans_MapOps (aTrans auto)\n                          (ec, obs)),\n               pAct =\n                 \\<lambda>ec.\n                    the (MapOps.lookup acts_MapOps (aActs auto) ec)\\<rparr>)", "by simp"], ["", "(*\n\nWe actually run this unfolding of the algorithm. The lemma is keeping\nus honest.\n\n*)"], ["", "definition\n  \"ClockAutoDFS \\<equiv> \\<lambda>agents jkbp envInit envAction envTrans envVal envObs. \\<lambda>a.\n    alg_dfs acts_MapOps\n            trans_MapOps\n            (clock_simObs envObs a)\n            (clock_simTrans agents jkbp envAction envTrans envVal envObs a)\n            (clock_simAction jkbp envVal envObs a)\n            (map (clock_simInit envInit envObs a \\<circ> envObs a) envInit)\""], ["", "lemma (in FiniteLinorderEnvironment)\n  \"mkClockAuto agents jkbp envInit envAction envTrans envVal envObs\n = (\\<lambda>a. alg_mk_auto acts_MapOps trans_MapOps (clock_simInit a) (ClockAutoDFS agents jkbp envInit envAction envTrans envVal envObs a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkClockAuto agents jkbp envInit envAction envTrans envVal envObs =\n    (\\<lambda>a.\n        alg_mk_auto acts_MapOps trans_MapOps (local.clock_simInit a)\n         (ClockAutoDFS agents jkbp envInit envAction envTrans envVal envObs\n           a))", "unfolding mkClockAuto_def ClockAutoDFS_def mkAlgAuto_def alg_mk_auto_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        let auto =\n              alg_dfs acts_MapOps trans_MapOps (local.clock_simObs a)\n               (local.clock_simTrans a) (local.clock_simAction a)\n               (map (local.clock_simInit a \\<circ> envObs a) envInit)\n        in \\<lparr>pInit = local.clock_simInit a,\n              pTrans =\n                \\<lambda>obs ec.\n                   the (MapOps.lookup trans_MapOps (aTrans auto) (ec, obs)),\n              pAct =\n                \\<lambda>ec.\n                   the (MapOps.lookup acts_MapOps (aActs auto)\n                         ec)\\<rparr>) =\n    (\\<lambda>a.\n        \\<lparr>pInit = local.clock_simInit a,\n           pTrans =\n             \\<lambda>obs ec.\n                the (MapOps.lookup trans_MapOps\n                      (aTrans\n                        (alg_dfs acts_MapOps trans_MapOps\n                          (local.clock_simObs a) (local.clock_simTrans a)\n                          (local.clock_simAction a)\n                          (map (local.clock_simInit a \\<circ> envObs a)\n                            envInit)))\n                      (ec, obs)),\n           pAct =\n             \\<lambda>ec.\n                the (MapOps.lookup acts_MapOps\n                      (aActs\n                        (alg_dfs acts_MapOps trans_MapOps\n                          (local.clock_simObs a) (local.clock_simTrans a)\n                          (local.clock_simAction a)\n                          (map (local.clock_simInit a \\<circ> envObs a)\n                            envInit)))\n                      ec)\\<rparr>)", "by (simp add: Let_def)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe discuss the clock semantics further in \\S\\ref{sec:kbps-alg-clock}.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}