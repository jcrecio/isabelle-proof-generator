{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/Extra.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma relation_mono:\n  \"\\<lbrakk> A \\<subseteq> C; B \\<subseteq> D \\<rbrakk> \\<Longrightarrow> A \\<times> B \\<subseteq> C \\<times> D\"", "lemma quotientI2:\n  \"\\<lbrakk> x \\<in> A; X = r `` {x} \\<rbrakk> \\<Longrightarrow> X \\<in> A // r\"", "lemma listToFun_futz:\n  \"\\<lbrakk> M \\<in> set (listToFun xs); x \\<in> fst ` set xs \\<rbrakk>\n     \\<Longrightarrow> M x \\<in> { y |y ys. (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\"", "lemma distinct_map_fst:\n  \"\\<lbrakk> x \\<notin> fst ` set xs; distinct (map fst xs) \\<rbrakk> \\<Longrightarrow> (x, y) \\<notin> set xs\"", "lemma listToFun_futz_rev:\n  \"\\<lbrakk> \\<And>x. M x \\<in> (if x \\<in> fst ` set xs then { y |y ys. (x, ys) \\<in> set xs \\<and> y \\<in> set ys} else {undefined}); distinct (map fst xs) \\<rbrakk>\n      \\<Longrightarrow> M \\<in> set (listToFun xs)\"", "lemma map_id_clunky:\n  \"set xs = UNIV \\<Longrightarrow> x \\<in> fst ` set (map (\\<lambda>x. (x, f x)) xs)\"", "lemma listToFuns_ext:\n  assumes xs: \"set xs = UNIV\"\n  assumes d: \"distinct xs\"\n  shows \"g \\<in> set (listToFuns f xs) \\<longleftrightarrow> (\\<forall>x. g x \\<in> set (f x))\"", "lemma listToFun_splice:\n  assumes xs: \"set xs = UNIV\"\n  assumes d: \"distinct xs\"\n  assumes g: \"g \\<in> set (listToFuns f xs)\"\n  assumes h: \"h \\<in> set (listToFuns f xs)\"\n  shows \"g(x := h x) \\<in> set (listToFuns f xs)\""], "translations": [["", "lemma relation_mono:\n  \"\\<lbrakk> A \\<subseteq> C; B \\<subseteq> D \\<rbrakk> \\<Longrightarrow> A \\<times> B \\<subseteq> C \\<times> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> C; B \\<subseteq> D\\<rbrakk>\n    \\<Longrightarrow> A \\<times> B \\<subseteq> C \\<times> D", "by bestsimp"], ["", "lemma quotientI2:\n  \"\\<lbrakk> x \\<in> A; X = r `` {x} \\<rbrakk> \\<Longrightarrow> X \\<in> A // r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> A; X = r `` {x}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> A // r", "by (simp add: quotientI)"], ["", "(*\n\nConcretely enumerate all the agent action functions. Can't be too\nabstract here as we want extensionality.\n\nIntroduced in the clock view.\n\n*)"], ["", "definition\n  listToFun :: \"('a \\<times> 'b list) list \\<Rightarrow> ('a \\<Rightarrow> 'b) list\"\nwhere\n  \"listToFun xs \\<equiv> foldr (\\<lambda>(a, acts) M. [ m(a := act) . m \\<leftarrow> M, act \\<leftarrow> acts ])\n                     xs\n                     [(\\<lambda>_. undefined)]\""], ["", "lemma listToFun_futz:\n  \"\\<lbrakk> M \\<in> set (listToFun xs); x \\<in> fst ` set xs \\<rbrakk>\n     \\<Longrightarrow> M x \\<in> { y |y ys. (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<in> set (listToFun xs); x \\<in> fst ` set xs\\<rbrakk>\n    \\<Longrightarrow> M x\n                      \\<in> {uu_.\n                             \\<exists>y ys.\n                                uu_ = y \\<and>\n                                (x, ys) \\<in> set xs \\<and> y \\<in> set ys}", "unfolding listToFun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>M \\<in> set (foldr\n                           (\\<lambda>(a, acts) M.\n                               concat\n                                (map (\\<lambda>m. map (fun_upd m a) acts)\n                                  M))\n                           xs [\\<lambda>_. undefined]);\n     x \\<in> fst ` set xs\\<rbrakk>\n    \\<Longrightarrow> M x\n                      \\<in> {uu_.\n                             \\<exists>y ys.\n                                uu_ = y \\<and>\n                                (x, ys) \\<in> set xs \\<and> y \\<in> set ys}", "apply (induct xs arbitrary: M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>M \\<in> set (foldr\n                              (\\<lambda>(a, acts) M.\n                                  concat\n                                   (map (\\<lambda>m. map (fun_upd m a) acts)\n                                     M))\n                              [] [\\<lambda>_. undefined]);\n        x \\<in> fst ` set []\\<rbrakk>\n       \\<Longrightarrow> M x\n                         \\<in> {uu_.\n                                \\<exists>y ys.\n                                   uu_ = y \\<and>\n                                   (x, ys) \\<in> set [] \\<and>\n                                   y \\<in> set ys}\n 2. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>M \\<in> set (foldr\n    (\\<lambda>(a, acts) M.\n        concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n    xs [\\<lambda>_. undefined]);\n                    x \\<in> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> M x\n                                     \\<in> {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys};\n        M \\<in> set (foldr\n                      (\\<lambda>(a, acts) M.\n                          concat\n                           (map (\\<lambda>m. map (fun_upd m a) acts) M))\n                      (a # xs) [\\<lambda>_. undefined]);\n        x \\<in> fst ` set (a # xs)\\<rbrakk>\n       \\<Longrightarrow> M x\n                         \\<in> {uu_.\n                                \\<exists>y ys.\n                                   uu_ = y \\<and>\n                                   (x, ys) \\<in> set (a # xs) \\<and>\n                                   y \\<in> set ys}", "apply (simp_all add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>M \\<in> set (foldr\n    (\\<lambda>p M.\n        concat (map (\\<lambda>m. map (fun_upd m (fst p)) (snd p)) M))\n    xs [\\<lambda>_. undefined]);\n                    x \\<in> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ys.\n  (x, ys) \\<in> set xs \\<and> M x \\<in> set ys;\n        \\<exists>x\\<in>set (foldr\n                             (\\<lambda>p M.\n                                 concat\n                                  (map (\\<lambda>m.\n     map (fun_upd m (fst p)) (snd p))\n                                    M))\n                             xs [\\<lambda>_. undefined]).\n           M \\<in> fun_upd x (fst a) ` set (snd a);\n        x = fst a \\<or> x \\<in> fst ` set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ((x, ys) = a \\<or> (x, ys) \\<in> set xs) \\<and>\n                            M x \\<in> set ys", "apply (case_tac a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs M aa b.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>M \\<in> set (foldr\n    (\\<lambda>p M.\n        concat (map (\\<lambda>m. map (fun_upd m (fst p)) (snd p)) M))\n    xs [\\<lambda>_. undefined]);\n                    x \\<in> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ys.\n  (x, ys) \\<in> set xs \\<and> M x \\<in> set ys;\n        \\<exists>x\\<in>set (foldr\n                             (\\<lambda>p M.\n                                 concat\n                                  (map (\\<lambda>m.\n     map (fun_upd m (fst p)) (snd p))\n                                    M))\n                             xs [\\<lambda>_. undefined]).\n           M \\<in> fun_upd x (fst a) ` set (snd a);\n        x = fst a \\<or> x \\<in> fst ` set xs; a = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            ((x, ys) = a \\<or> (x, ys) \\<in> set xs) \\<and>\n                            M x \\<in> set ys", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs aa ba xa xaa.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>M \\<in> set (foldr\n    (\\<lambda>p M.\n        concat (map (\\<lambda>m. map (fun_upd m (fst p)) (snd p)) M))\n    xs [\\<lambda>_. undefined]);\n                    x \\<in> fst ` set xs\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>ys.\n  (x, ys) \\<in> set xs \\<and> M x \\<in> set ys;\n        x = aa \\<or> x \\<in> fst ` set xs;\n        xa \\<in> set (foldr\n                       (\\<lambda>p M.\n                           concat\n                            (map (\\<lambda>m.\n                                     map (fun_upd m (fst p)) (snd p))\n                              M))\n                       xs [\\<lambda>_. undefined]);\n        xaa \\<in> set ba\\<rbrakk>\n       \\<Longrightarrow> (x = aa \\<longrightarrow>\n                          (\\<exists>ys.\n                              (ys = ba \\<or> (aa, ys) \\<in> set xs) \\<and>\n                              xaa \\<in> set ys)) \\<and>\n                         (x \\<noteq> aa \\<longrightarrow>\n                          (\\<exists>ys.\n                              (x, ys) \\<in> set xs \\<and>\n                              xa x \\<in> set ys))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma distinct_map_fst:\n  \"\\<lbrakk> x \\<notin> fst ` set xs; distinct (map fst xs) \\<rbrakk> \\<Longrightarrow> (x, y) \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> fst ` set xs; distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> (x, y) \\<notin> set xs", "by (induct xs) auto"], ["", "lemma listToFun_futz_rev:\n  \"\\<lbrakk> \\<And>x. M x \\<in> (if x \\<in> fst ` set xs then { y |y ys. (x, ys) \\<in> set xs \\<and> y \\<in> set ys} else {undefined}); distinct (map fst xs) \\<rbrakk>\n      \\<Longrightarrow> M \\<in> set (listToFun xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                M x\n                \\<in> (if x \\<in> fst ` set xs\n                       then {uu_.\n                             \\<exists>y ys.\n                                uu_ = y \\<and>\n                                (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                       else {undefined});\n     distinct (map fst xs)\\<rbrakk>\n    \\<Longrightarrow> M \\<in> set (listToFun xs)", "proof(induct xs arbitrary: M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>\\<And>x.\n                   M x\n                   \\<in> (if x \\<in> fst ` set []\n                          then {uu_.\n                                \\<exists>y ys.\n                                   uu_ = y \\<and>\n                                   (x, ys) \\<in> set [] \\<and>\n                                   y \\<in> set ys}\n                          else {undefined});\n        distinct (map fst [])\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun [])\n 2. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "case Nil"], ["proof (state)\nthis:\n  M ?x\n  \\<in> (if ?x \\<in> fst ` set []\n         then {uu_.\n               \\<exists>y ys.\n                  uu_ = y \\<and>\n                  (?x, ys) \\<in> set [] \\<and> y \\<in> set ys}\n         else {undefined})\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>\\<And>x.\n                   M x\n                   \\<in> (if x \\<in> fst ` set []\n                          then {uu_.\n                                \\<exists>y ys.\n                                   uu_ = y \\<and>\n                                   (x, ys) \\<in> set [] \\<and>\n                                   y \\<in> set ys}\n                          else {undefined});\n        distinct (map fst [])\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun [])\n 2. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  M ?x\n  \\<in> (if ?x \\<in> fst ` set []\n         then {uu_.\n               \\<exists>y ys.\n                  uu_ = y \\<and>\n                  (?x, ys) \\<in> set [] \\<and> y \\<in> set ys}\n         else {undefined})\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. M \\<in> set (listToFun [])", "unfolding listToFun_def"], ["proof (prove)\nusing this:\n  M ?x\n  \\<in> (if ?x \\<in> fst ` set []\n         then {uu_.\n               \\<exists>y ys.\n                  uu_ = y \\<and>\n                  (?x, ys) \\<in> set [] \\<and> y \\<in> set ys}\n         else {undefined})\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. M \\<in> set (foldr\n                  (\\<lambda>(a, acts) M.\n                      concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n                  [] [\\<lambda>_. undefined])", "by simp"], ["proof (state)\nthis:\n  M \\<in> set (listToFun [])\n\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x.\n              ?M x\n              \\<in> (if x \\<in> fst ` set xs\n                     then {uu_.\n                           \\<exists>y ys.\n                              uu_ = y \\<and>\n                              (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                     else {undefined});\n   distinct (map fst xs)\\<rbrakk>\n  \\<Longrightarrow> ?M \\<in> set (listToFun xs)\n  M ?x\n  \\<in> (if ?x \\<in> fst ` set (x # xs)\n         then {uu_.\n               \\<exists>y ys.\n                  uu_ = y \\<and>\n                  (?x, ys) \\<in> set (x # xs) \\<and> y \\<in> set ys}\n         else {undefined})\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "let ?M' = \"M(fst x := undefined)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "have M': \"?M' \\<in> set (listToFun xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M(fst x := undefined) \\<in> set (listToFun xs)", "apply (rule Cons.hyps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})\n 2. distinct (map fst xs)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct (map fst xs)\n 2. \\<And>xa.\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})", "using Cons(3)"], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (2 subgoals):\n 1. distinct (map fst xs)\n 2. \\<And>xa.\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})", "apply (case_tac \"xa = fst x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa = fst x \\<Longrightarrow>\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})\n 2. \\<And>xa.\n       xa \\<noteq> fst x \\<Longrightarrow>\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})", "using Cons(3)"], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa = fst x \\<Longrightarrow>\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})\n 2. \\<And>xa.\n       xa \\<noteq> fst x \\<Longrightarrow>\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<noteq> fst x \\<Longrightarrow>\n       (M(fst x := undefined)) xa\n       \\<in> (if xa \\<in> fst ` set xs\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n              else {undefined})", "apply (case_tac \"xa \\<in> fst ` set xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<in> fst ` set xs\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<notin> fst ` set xs\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})", "apply (cut_tac x=xa in Cons(2))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<in> fst ` set xs;\n        M xa\n        \\<in> (if xa \\<in> fst ` set (x # xs)\n               then {uu_.\n                     \\<exists>y ys.\n                        uu_ = y \\<and>\n                        (xa, ys) \\<in> set (x # xs) \\<and> y \\<in> set ys}\n               else {undefined})\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<notin> fst ` set xs\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<in> fst ` set xs;\n        M xa\n        \\<in> (if xa \\<in> fst ` set (x # xs)\n               then {uu_.\n                     \\<exists>y ys.\n                        uu_ = y \\<and>\n                        (xa, ys) \\<in> set (x # xs) \\<and> y \\<in> set ys}\n               else {undefined});\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})\n 2. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<notin> fst ` set xs\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<notin> fst ` set xs\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})", "apply (cut_tac x=xa in Cons(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<noteq> fst x; xa \\<notin> fst ` set xs;\n        M xa\n        \\<in> (if xa \\<in> fst ` set (x # xs)\n               then {uu_.\n                     \\<exists>y ys.\n                        uu_ = y \\<and>\n                        (xa, ys) \\<in> set (x # xs) \\<and> y \\<in> set ys}\n               else {undefined})\\<rbrakk>\n       \\<Longrightarrow> (M(fst x := undefined)) xa\n                         \\<in> (if xa \\<in> fst ` set xs\n                                then {uu_.\n\\<exists>y ys. uu_ = y \\<and> (xa, ys) \\<in> set xs \\<and> y \\<in> set ys}\n                                else {undefined})", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  M(fst x := undefined) \\<in> set (listToFun xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>\\<And>x.\n                               M x\n                               \\<in> (if x \\<in> fst ` set xs\nthen {uu_.\n      \\<exists>y ys.\n         uu_ = y \\<and> (x, ys) \\<in> set xs \\<and> y \\<in> set ys}\nelse {undefined});\n                    distinct (map fst xs)\\<rbrakk>\n                   \\<Longrightarrow> M \\<in> set (listToFun xs);\n        \\<And>x.\n           M x\n           \\<in> (if x \\<in> fst ` set (a # xs)\n                  then {uu_.\n                        \\<exists>y ys.\n                           uu_ = y \\<and>\n                           (x, ys) \\<in> set (a # xs) \\<and> y \\<in> set ys}\n                  else {undefined});\n        distinct (map fst (a # xs))\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (listToFun (a # xs))", "then"], ["proof (chain)\npicking this:\n  M(fst x := undefined) \\<in> set (listToFun xs)", "show ?case"], ["proof (prove)\nusing this:\n  M(fst x := undefined) \\<in> set (listToFun xs)\n\ngoal (1 subgoal):\n 1. M \\<in> set (listToFun (x # xs))", "unfolding listToFun_def"], ["proof (prove)\nusing this:\n  M(fst x := undefined)\n  \\<in> set (foldr\n              (\\<lambda>(a, acts) M.\n                  concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n              xs [\\<lambda>_. undefined])\n\ngoal (1 subgoal):\n 1. M \\<in> set (foldr\n                  (\\<lambda>(a, acts) M.\n                      concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n                  (x # xs) [\\<lambda>_. undefined])", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>M(fst x := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M \\<in> set (foldr\n (\\<lambda>(a, acts) M. concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n (x # xs) [\\<lambda>_. undefined])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x\\<in>set\n   (foldr\n     (\\<lambda>(a, acts) M.\n         concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n     xs [\\<lambda>_. undefined]).\n                            M \\<in> fun_upd x a ` set b", "apply (rule bexI[where x=\"?M'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M \\<in> fun_upd (M(fst x := undefined)) a ` set b\n 2. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M(fst x := undefined)\n                         \\<in> set (foldr\n                                     (\\<lambda>(a, acts) M.\n   concat (map (\\<lambda>m. map (fun_upd m a) acts) M))\n                                     xs [\\<lambda>_. undefined])", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M \\<in> fun_upd M a ` set b", "apply (rule_tac x=\"M a\" in image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M = M(a := M a)\n 2. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "apply (cut_tac x=a in Cons(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b);\n        M a\n        \\<in> (if a \\<in> fst ` set (x # xs)\n               then {uu_.\n                     \\<exists>y ys.\n                        uu_ = y \\<and>\n                        (a, ys) \\<in> set (x # xs) \\<and> y \\<in> set ys}\n               else {undefined})\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "using Cons(3)"], ["proof (prove)\nusing this:\n  distinct (map fst (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b);\n        M a\n        \\<in> (if a \\<in> fst ` set (x # xs)\n               then {uu_.\n                     \\<exists>y ys.\n                        uu_ = y \\<and>\n                        (a, ys) \\<in> set (x # xs) \\<and> y \\<in> set ys}\n               else {undefined})\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ys.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b); a \\<notin> fst ` set xs; distinct (map fst xs);\n        ys = b \\<or> (a, ys) \\<in> set xs; M a \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ys.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b); a \\<notin> fst ` set xs; distinct (map fst xs);\n        M a \\<in> set ys; ys = b\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b\n 2. \\<And>a b ys.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b); a \\<notin> fst ` set xs; distinct (map fst xs);\n        M a \\<in> set ys; (a, ys) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ys.\n       \\<lbrakk>M(a := undefined)\n                \\<in> set (foldr\n                            (\\<lambda>(a, acts) M.\n                                concat\n                                 (map (\\<lambda>m. map (fun_upd m a) acts)\n                                   M))\n                            xs [\\<lambda>_. undefined]);\n        x = (a, b); a \\<notin> fst ` set xs; distinct (map fst xs);\n        M a \\<in> set ys; (a, ys) \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> M a \\<in> set b", "apply (auto dest: distinct_map_fst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  M \\<in> set (listToFun (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  listToFuns :: \"('a \\<Rightarrow> 'b list) \\<Rightarrow> 'a list \\<Rightarrow> ('a \\<Rightarrow> 'b) list\"\nwhere\n  \"listToFuns f \\<equiv> listToFun \\<circ> map (\\<lambda>x. (x, f x))\""], ["", "lemma map_id_clunky:\n  \"set xs = UNIV \\<Longrightarrow> x \\<in> fst ` set (map (\\<lambda>x. (x, f x)) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = UNIV \\<Longrightarrow>\n    x \\<in> fst ` set (map (\\<lambda>x. (x, f x)) xs)", "apply (simp only: set_map[symmetric] map_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = UNIV \\<Longrightarrow>\n    x \\<in> set (map (fst \\<circ> (\\<lambda>x. (x, f x))) xs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\n\nThe main result is that we can freely move between representations.\n\n*)"], ["", "lemma listToFuns_ext:\n  assumes xs: \"set xs = UNIV\"\n  assumes d: \"distinct xs\"\n  shows \"g \\<in> set (listToFuns f xs) \\<longleftrightarrow> (\\<forall>x. g x \\<in> set (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<in> set (listToFuns f xs)) = (\\<forall>x. g x \\<in> set (f x))", "unfolding listToFuns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<in> set ((listToFun \\<circ> map (\\<lambda>x. (x, f x))) xs)) =\n    (\\<forall>x. g x \\<in> set (f x))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs))) =\n    (\\<forall>x. g x \\<in> set (f x))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. g \\<in> set (listToFun\n                  (map (\\<lambda>x. (x, f x)) xs)) \\<Longrightarrow>\n    \\<forall>x. g x \\<in> set (f x)\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       g \\<in> set (listToFun\n                     (map (\\<lambda>x. (x, f x)) xs)) \\<Longrightarrow>\n       g x \\<in> set (f x)\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs))", "apply (cut_tac x=x in listToFun_futz[where M=g, OF _ map_id_clunky[OF xs]])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       g \\<in> set (listToFun\n                     (map (\\<lambda>x. (x, f x)) xs)) \\<Longrightarrow>\n       g \\<in> set (listToFun (map (\\<lambda>xa. (xa, ?f7 x xa)) xs))\n 2. \\<And>x.\n       \\<lbrakk>g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs));\n        g x\n        \\<in> {uu_.\n               \\<exists>y ys.\n                  uu_ = y \\<and>\n                  (x, ys)\n                  \\<in> set (map (\\<lambda>xa. (xa, ?f7 x xa)) xs) \\<and>\n                  y \\<in> set ys}\\<rbrakk>\n       \\<Longrightarrow> g x \\<in> set (f x)\n 3. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs));\n        g x\n        \\<in> {uu_.\n               \\<exists>y ys.\n                  uu_ = y \\<and>\n                  (x, ys) \\<in> set (map (\\<lambda>x. (x, f x)) xs) \\<and>\n                  y \\<in> set ys}\\<rbrakk>\n       \\<Longrightarrow> g x \\<in> set (f x)\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    g \\<in> set (listToFun (map (\\<lambda>x. (x, f x)) xs))", "apply (rule listToFun_futz_rev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n       g x\n       \\<in> (if x \\<in> fst ` set (map (\\<lambda>x. (x, f x)) xs)\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (x, ys)\n                       \\<in> set (map (\\<lambda>x. (x, f x)) xs) \\<and>\n                       y \\<in> set ys}\n              else {undefined})\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map fst (map (\\<lambda>x. (x, f x)) xs))", "using map_id_clunky[OF xs]"], ["proof (prove)\nusing this:\n  ?x \\<in> fst ` set (map (\\<lambda>x. (x, ?f x)) xs)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n       g x\n       \\<in> (if x \\<in> fst ` set (map (\\<lambda>x. (x, f x)) xs)\n              then {uu_.\n                    \\<exists>y ys.\n                       uu_ = y \\<and>\n                       (x, ys)\n                       \\<in> set (map (\\<lambda>x. (x, f x)) xs) \\<and>\n                       y \\<in> set ys}\n              else {undefined})\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map fst (map (\\<lambda>x. (x, f x)) xs))", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x. g x \\<in> set (f x);\n        \\<And>x f. x \\<in> fst ` (\\<lambda>x. (x, f x)) ` set xs;\n        xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            (xa, ys)\n                            \\<in> (\\<lambda>x. (x, f x)) ` set xs \\<and>\n                            g xa \\<in> set ys\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map fst (map (\\<lambda>x. (x, f x)) xs))", "apply (rule_tac x=\"f xa\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>\\<forall>x. g x \\<in> set (f x);\n        \\<And>x f. x \\<in> fst ` (\\<lambda>x. (x, f x)) ` set xs;\n        xa \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> (xa, f xa)\n                         \\<in> (\\<lambda>x. (x, f x)) ` set xs \\<and>\n                         g xa \\<in> set (f xa)\n 2. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map fst (map (\\<lambda>x. (x, f x)) xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map fst (map (\\<lambda>x. (x, f x)) xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map (fst \\<circ> (\\<lambda>x. (x, f x))) xs)", "using d"], ["proof (prove)\nusing this:\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<forall>x. g x \\<in> set (f x) \\<Longrightarrow>\n    distinct (map (fst \\<circ> (\\<lambda>x. (x, f x))) xs)", "apply (simp add: distinct_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x. g x \\<in> set (f x); distinct xs\\<rbrakk>\n    \\<Longrightarrow> inj_on (fst \\<circ> (\\<lambda>x. (x, f x))) (set xs)", "apply (auto intro: inj_onI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma listToFun_splice:\n  assumes xs: \"set xs = UNIV\"\n  assumes d: \"distinct xs\"\n  assumes g: \"g \\<in> set (listToFuns f xs)\"\n  assumes h: \"h \\<in> set (listToFuns f xs)\"\n  shows \"g(x := h x) \\<in> set (listToFuns f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g(x := h x) \\<in> set (listToFuns f xs)", "using g h"], ["proof (prove)\nusing this:\n  g \\<in> set (listToFuns f xs)\n  h \\<in> set (listToFuns f xs)\n\ngoal (1 subgoal):\n 1. g(x := h x) \\<in> set (listToFuns f xs)", "by (auto iff: listToFuns_ext[OF xs d])"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}