{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma gen_dfs_simps[code, simp]:\n  \"gen_dfs succs ins memb S [] = S\"\n  \"gen_dfs succs ins memb S (x # xs) =\n    (if memb x S then gen_dfs succs ins memb S xs\n     else gen_dfs succs ins memb (ins x S) (succs x @ xs))\"", "lemma nodeAbs_subset_grot:\n  \"\\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not>memb x S\\<rbrakk>\n     \\<Longrightarrow> nodeAbs ` {n . isNode n \\<and> \\<not> memb n (ins x S)}\n       \\<subset> nodeAbs ` {n . isNode n \\<and> \\<not> memb n S}\"", "lemma psubsetI2: \"\\<lbrakk> A \\<subseteq> B; x \\<in> A; x \\<notin> B\\<rbrakk> \\<Longrightarrow> A \\<subset> B\"", "lemma dfs_induct[consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n  and xs: \"list_all isNode xs\"\n  and I1: \"\\<And>S. invariant S \\<Longrightarrow> P S []\"\n  and I2: \"\\<And>S x xs. invariant S \\<Longrightarrow> isNode x \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n    (memb x S \\<Longrightarrow> P S xs) \\<Longrightarrow> (\\<not> memb x S \\<Longrightarrow> P (ins x S) (succs x @ xs)) \\<Longrightarrow> P S (x # xs)\"\n  shows \"P S xs\"", "lemma visit_subset_dfs: \"invariant S \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n  isNode y \\<Longrightarrow> memb y S \\<Longrightarrow> memb y (dfs S xs)\"", "lemma next_subset_dfs: \"invariant S \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n  x \\<in> set xs \\<Longrightarrow> memb x (dfs S xs)\"", "lemma succss_closed_dfs':\n  \"invariant ys \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n   nodeAbs ` succss (set_of ys) \\<subseteq> nodeAbs ` (set xs \\<union> set_of ys) \\<Longrightarrow> nodeAbs ` succss (set_of (dfs ys xs)) \\<subseteq> nodeAbs ` set_of (dfs ys xs)\"", "lemma succss_closed_dfs: \"list_all isNode xs \\<Longrightarrow>\n  nodeAbs ` succss (set_of (dfs empt xs)) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\"", "theorem succsr_isNode:\n  assumes xy: \"(x, y) \\<in> succsr\\<^sup>*\"\n  shows \"isNode x \\<Longrightarrow> isNode y\"", "lemma succss_closed:\n  assumes inc: \"nodeAbs ` succss X \\<subseteq> nodeAbs ` X\"\n      and X: \"X \\<subseteq> { x . isNode x }\"\n  shows \"nodeAbs ` reachable X = nodeAbs ` X\"", "lemma dfs_isNode:\n  assumes S: \"invariant S\"\n      and xs: \"list_all isNode xs\"\n  shows \"set_of (dfs S xs) \\<subseteq> {x . isNode x}\"", "lemma reachable_closed_dfs:\n  assumes xs: \"list_all isNode xs\"\n  shows \"nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\"", "lemma reachable_succs: \"reachable (set (succs x)) \\<subseteq> reachable {x}\"", "lemma dfs_subset_reachable_visit_nodes:\n  \"invariant ys \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n   nodeAbs ` set_of (dfs ys xs) \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of ys)\"", "theorem dfs_imp_reachable:\n  assumes y: \"isNode y\"\n      and xs: \"list_all isNode xs\"\n      and m: \"memb y (dfs empt xs)\"\n  shows \"\\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)\"", "theorem (in DFS) reachable_imp_dfs:\n  assumes y: \"isNode y\"\n      and xs: \"list_all isNode xs\"\n      and m: \"y \\<in> reachable (set xs)\"\n  shows \"\\<exists>y'. nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)\"", "theorem dfs_invariant' [consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n  and xs: \"list_all isNode xs\"\n  and H: \"I S\"\n  and I: \"\\<And>S x. \\<not> memb x S \\<Longrightarrow> isNode x \\<Longrightarrow> invariant S \\<Longrightarrow> I S \\<Longrightarrow> I (ins x S)\"\n  shows \"I (dfs S xs)\"", "theorem (in DFS) dfs_invariant:\n  assumes \"invariant S\"\n  assumes \"list_all isNode xs\"\n  shows \"invariant (dfs S xs)\""], "translations": [["", "lemma gen_dfs_simps[code, simp]:\n  \"gen_dfs succs ins memb S [] = S\"\n  \"gen_dfs succs ins memb S (x # xs) =\n    (if memb x S then gen_dfs succs ins memb S xs\n     else gen_dfs succs ins memb (ins x S) (succs x @ xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_dfs succs ins memb S [] = S &&&\n    gen_dfs succs ins memb S (x # xs) =\n    (if memb x S then gen_dfs succs ins memb S xs\n     else gen_dfs succs ins memb (ins x S) (succs x @ xs))", "by (simp_all add: gen_dfs.simps)"], ["", "(*>*)"], ["", "text_raw\\<open>\n\\begin{figure}\n\\begin{isabellebody}%\n\\<close>"], ["", "locale DFS =\n  fixes succs :: \"'a \\<Rightarrow> 'a list\"\n  and isNode :: \"'a \\<Rightarrow> bool\"\n  and invariant :: \"'b \\<Rightarrow> bool\"\n  and ins :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  and memb :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\"\n  and empt :: 'b\n  and nodeAbs :: \"'a \\<Rightarrow> 'c\"\n  assumes ins_eq: \"\\<And>x y S. \\<lbrakk> isNode x; isNode y; invariant S; \\<not> memb y S \\<rbrakk>\n                       \\<Longrightarrow> memb x (ins y S)\n                       \\<longleftrightarrow> ((nodeAbs x = nodeAbs y) \\<or> memb x S)\"\n  and succs: \"\\<And>x y. \\<lbrakk> isNode x; isNode y; nodeAbs x = nodeAbs y \\<rbrakk>\n                       \\<Longrightarrow> nodeAbs ` set (succs x) = nodeAbs ` set (succs y)\"\n  and empt: \"\\<And>x. isNode x \\<Longrightarrow> \\<not> memb x empt\"\n  and succs_isNode: \"\\<And>x. isNode x \\<Longrightarrow> list_all isNode (succs x)\"\n  and empt_invariant: \"invariant empt\"\n  and ins_invariant: \"\\<And>x S. \\<lbrakk> isNode x; invariant S; \\<not> memb x S \\<rbrakk>\n                        \\<Longrightarrow> invariant (ins x S)\"\n  and graph_finite: \"finite (nodeAbs ` { x . isNode x})\""], ["", "text_raw\\<open>\n\\end{isabellebody}%\n\\begin{isamarkuptext}%\n\\caption{The \\<open>DFS\\<close> locale.}\n\\label{fig:kbps-theory-dfs-locale}\n\\end{isamarkuptext}%\n\\end{figure}\n\\<close>"], ["", "text\\<open>\n\nThe proofs are carried out in the locale of\nFigure~\\ref{fig:kbps-theory-dfs-locale}, which details our\nrequirements on the parameters for the DFS to behave as one would\nexpect. Intuitively we are traversing a graph defined by @{term\n\"succs\"} from some initial work list @{term \"wl\"}, constructing an\nobject of type @{typ \"'b\"} as we go. The function @{term \"ins\"}\nintegrates the current node into this construction. The predicate\n@{term \"isNode\"} is invariant over the set of states reachable from\nthe initial work list, and is respected by @{term \"empt\"} and @{term\n\"ins\"}. We can also supply an invariant for the constructed object\n(@{term \"invariant\"}). Inside the locale, @{term \"dfs\"} abbreviates\n@{term \"gen_dfs\"} partially applied to the fixed parameters.\n\nTo support our data refinement\n(\\S\\ref{sec:kbps-automata-synthesis-alg}) we also require that the\nrepresentation of nodes be adequate via the abstraction function\n@{term \"nodeAbs\"}, which the transition relation @{term \"succs\"} and\nvisited predicate @{term \"memb\"} must respect. To ensure termination\nit must be the case that there are only a finite number of states,\nthough there might be an infinity of representations.\n\nWe characterise the DFS traversal using the reflexive\ntransitive closure operator:\n\n\\<close>"], ["", "definition (in DFS) reachable :: \"'a set \\<Rightarrow> 'a set\" where\n  \"reachable xs \\<equiv> {(x, y). y \\<in> set (succs x)}\\<^sup>* `` xs\""], ["", "(*<*)"], ["", "context DFS\nbegin"], ["", "definition\n  \"succss xs \\<equiv> \\<Union>x\\<in>xs. set (succs x)\""], ["", "definition\n  \"set_of S \\<equiv> {x. isNode x \\<and> memb x S}\""], ["", "abbreviation\n  \"dfs \\<equiv> gen_dfs succs ins memb\""], ["", "definition rel where\n  \"rel = inv_image finite_psubset (\\<lambda>S. nodeAbs ` {n.  isNode n \\<and> \\<not> memb n S})\""], ["", "(* Yuck, something to do with Skolems broke. *)"], ["", "lemma nodeAbs_subset_grot:\n  \"\\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not>memb x S\\<rbrakk>\n     \\<Longrightarrow> nodeAbs ` {n . isNode n \\<and> \\<not> memb n (ins x S)}\n       \\<subset> nodeAbs ` {n . isNode n \\<and> \\<not> memb n S}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n     \\<not> memb x S\\<rbrakk>\n    \\<Longrightarrow> nodeAbs ` {n. isNode n \\<and> \\<not> memb n (ins x S)}\n                      \\<subset> nodeAbs `\n                                {n. isNode n \\<and> \\<not> memb n S}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n     \\<not> memb x S\\<rbrakk>\n    \\<Longrightarrow> nodeAbs ` {n. isNode n \\<and> \\<not> memb n (ins x S)}\n                      \\<subseteq> nodeAbs `\n                                  {n. isNode n \\<and> \\<not> memb n S}\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n     \\<not> memb x S\\<rbrakk>\n    \\<Longrightarrow> nodeAbs `\n                      {n. isNode n \\<and> \\<not> memb n (ins x S)} \\<noteq>\n                      nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply (auto simp add: ins_eq cong: conj_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subgoal_tac \"nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply (subgoal_tac \"nodeAbs x \\<notin> nodeAbs ` {n. isNode n \\<and> nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x\n     \\<notin> nodeAbs `\n              {n. isNode n \\<and>\n                  nodeAbs n \\<noteq> nodeAbs x \\<and>\n                  \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<notin> nodeAbs `\n                               {n. isNode n \\<and>\n                                   nodeAbs n \\<noteq> nodeAbs x \\<and>\n                                   \\<not> memb n S}\n 3. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<notin> nodeAbs `\n                               {n. isNode n \\<and>\n                                   nodeAbs n \\<noteq> nodeAbs x \\<and>\n                                   \\<not> memb n S}\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n     nodeAbs x\n     \\<in> nodeAbs `\n           {n. isNode n \\<and>\n               nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply (erule imageE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n        nodeAbs `\n        {n. isNode n \\<and>\n            nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n        nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n        nodeAbs x\n        \\<in> nodeAbs `\n              {n. isNode n \\<and>\n                  nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S};\n        nodeAbs x = nodeAbs xa;\n        xa \\<in> {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n        nodeAbs `\n        {n. isNode n \\<and>\n            nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n        nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n        nodeAbs x \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S};\n        nodeAbs x = nodeAbs xa;\n        xa \\<in> {n. isNode n \\<and>\n                     nodeAbs n \\<noteq> nodeAbs x \\<and>\n                     \\<not> memb n S}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; isNode x; list_all isNode xs; \\<not> memb x S;\n     nodeAbs `\n     {n. isNode n \\<and>\n         nodeAbs n \\<noteq> nodeAbs x \\<and> \\<not> memb n S} =\n     nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}\\<rbrakk>\n    \\<Longrightarrow> nodeAbs x\n                      \\<in> nodeAbs ` {n. isNode n \\<and> \\<not> memb n S}", "apply auto[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma psubsetI2: \"\\<lbrakk> A \\<subseteq> B; x \\<in> A; x \\<notin> B\\<rbrakk> \\<Longrightarrow> A \\<subset> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<subseteq> B; x \\<in> A; x \\<notin> B\\<rbrakk>\n    \\<Longrightarrow> A \\<subset> B", "by (unfold less_le) blast"], ["", "lemma dfs_induct[consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n  and xs: \"list_all isNode xs\"\n  and I1: \"\\<And>S. invariant S \\<Longrightarrow> P S []\"\n  and I2: \"\\<And>S x xs. invariant S \\<Longrightarrow> isNode x \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n    (memb x S \\<Longrightarrow> P S xs) \\<Longrightarrow> (\\<not> memb x S \\<Longrightarrow> P (ins x S) (succs x @ xs)) \\<Longrightarrow> P S (x # xs)\"\n  shows \"P S xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P S xs", "using I1 I2 S xs"], ["proof (prove)\nusing this:\n  invariant ?S \\<Longrightarrow> P ?S []\n  \\<lbrakk>invariant ?S; isNode ?x; list_all isNode ?xs;\n   memb ?x ?S \\<Longrightarrow> P ?S ?xs;\n   \\<not> memb ?x ?S \\<Longrightarrow>\n   P (ins ?x ?S) (succs ?x @ ?xs)\\<rbrakk>\n  \\<Longrightarrow> P ?S (?x # ?xs)\n  invariant S\n  list_all isNode xs\n\ngoal (1 subgoal):\n 1. P S xs", "apply induction_schema"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>P S xs.\n       \\<lbrakk>invariant S; list_all isNode xs;\n        \\<And>Sa__.\n           \\<lbrakk>invariant Sa__; S = Sa__; xs = []\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>Sa__ x__ xsa__.\n           \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n            S = Sa__; xs = x__ # xsa__\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>thesis__ Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__;\n        \\<lbrakk>invariant (ins x__ Sa__);\n         list_all isNode (succs x__ @ xsa__)\\<rbrakk>\n        \\<Longrightarrow> thesis__\\<rbrakk>\n       \\<Longrightarrow> thesis__\n 3. wf ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 5. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply atomize_elim"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>S xs.\n       \\<lbrakk>invariant S; list_all isNode xs\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>Sa__.\n                             invariant Sa__ \\<and>\n                             S = Sa__ \\<and> xs = []) \\<or>\n                         (\\<exists>Sa__ x__ xsa__.\n                             invariant Sa__ \\<and>\n                             isNode x__ \\<and>\n                             list_all isNode xsa__ \\<and>\n                             S = Sa__ \\<and> xs = x__ # xsa__)\n 2. \\<And>thesis__ Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__;\n        \\<lbrakk>invariant (ins x__ Sa__);\n         list_all isNode (succs x__ @ xsa__)\\<rbrakk>\n        \\<Longrightarrow> thesis__\\<rbrakk>\n       \\<Longrightarrow> thesis__\n 3. wf ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 5. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (case_tac xs, simp+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>thesis__ Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__;\n        \\<lbrakk>invariant (ins x__ Sa__);\n         list_all isNode (succs x__)\\<rbrakk>\n        \\<Longrightarrow> thesis__\\<rbrakk>\n       \\<Longrightarrow> thesis__\n 2. wf ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply atomize_elim"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> invariant (ins x__ Sa__) \\<and>\n                         list_all isNode (succs x__)\n 2. wf ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (rule conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> invariant (ins x__ Sa__)\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> list_all isNode (succs x__)\n 3. wf ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 5. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (rule ins_invariant, assumption+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> list_all isNode (succs x__)\n 2. wf ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 4. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (rule succs_isNode, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf ?R2\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__) \\<in> ?R2\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> ?R2", "apply (relation \"rel <*lex*> measure length\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (rel <*lex*> measure length)\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__)\n                         \\<in> rel <*lex*> measure length\n 3. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> rel <*lex*> measure length", "apply (simp add: wf_lex_prod rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((Sa__, xsa__), Sa__, x__ # xsa__)\n                         \\<in> rel <*lex*> measure length\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> rel <*lex*> measure length", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> ((ins x__ Sa__, succs x__ @ xsa__), Sa__,\n                          x__ # xsa__)\n                         \\<in> rel <*lex*> measure length", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> (ins x__ Sa__, Sa__) \\<in> rel \\<or>\n                         ins x__ Sa__ = Sa__ \\<and> succs x__ = []", "apply (rule disjI1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> (ins x__ Sa__, Sa__) \\<in> rel", "apply (simp add: rel_def finite_psubset_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> nodeAbs `\n                         {n. isNode n \\<and> \\<not> memb n (ins x__ Sa__)}\n                         \\<subset> nodeAbs `\n                                   {n. isNode n \\<and>\n \\<not> memb n Sa__} \\<and>\n                         finite\n                          (nodeAbs `\n                           {n. isNode n \\<and> \\<not> memb n Sa__})", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> nodeAbs `\n                         {n. isNode n \\<and> \\<not> memb n (ins x__ Sa__)}\n                         \\<subset> nodeAbs `\n                                   {n. isNode n \\<and> \\<not> memb n Sa__}\n 2. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (nodeAbs `\n                           {n. isNode n \\<and> \\<not> memb n Sa__})", "apply (erule (3) nodeAbs_subset_grot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (nodeAbs `\n                           {n. isNode n \\<and> \\<not> memb n Sa__})", "apply (rule finite_subset[OF _ graph_finite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Sa__ x__ xsa__.\n       \\<lbrakk>invariant Sa__; isNode x__; list_all isNode xsa__;\n        \\<not> memb x__ Sa__\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` {n. isNode n \\<and> \\<not> memb n Sa__}\n                         \\<subseteq> nodeAbs ` {x. isNode x}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma visit_subset_dfs: \"invariant S \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n  isNode y \\<Longrightarrow> memb y S \\<Longrightarrow> memb y (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; list_all isNode xs; isNode y; memb y S\\<rbrakk>\n    \\<Longrightarrow> memb y (dfs S xs)", "by (induct S xs rule: dfs_induct) (simp_all add: ins_eq)"], ["", "lemma next_subset_dfs: \"invariant S \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n  x \\<in> set xs \\<Longrightarrow> memb x (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant S; list_all isNode xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> memb x (dfs S xs)", "proof (induct S xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S [])\n 2. \\<And>S xa xs.\n       \\<lbrakk>invariant S; isNode xa; list_all isNode xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "case (step S y xs)"], ["proof (state)\nthis:\n  invariant S\n  isNode y\n  list_all isNode xs\n  \\<lbrakk>memb y S; x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs S xs)\n  \\<lbrakk>\\<not> memb y S; x \\<in> set (succs y @ xs)\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs (ins y S) (succs y @ xs))\n  x \\<in> set (y # xs)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S [])\n 2. \\<And>S xa xs.\n       \\<lbrakk>invariant S; isNode xa; list_all isNode xs;\n        \\<lbrakk>memb xa S; x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs S xs);\n        \\<lbrakk>\\<not> memb xa S; x \\<in> set (succs xa @ xs)\\<rbrakk>\n        \\<Longrightarrow> memb x (dfs (ins xa S) (succs xa @ xs));\n        x \\<in> set (xa # xs)\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S (xa # xs))", "then"], ["proof (chain)\npicking this:\n  invariant S\n  isNode y\n  list_all isNode xs\n  \\<lbrakk>memb y S; x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs S xs)\n  \\<lbrakk>\\<not> memb y S; x \\<in> set (succs y @ xs)\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs (ins y S) (succs y @ xs))\n  x \\<in> set (y # xs)", "show ?case"], ["proof (prove)\nusing this:\n  invariant S\n  isNode y\n  list_all isNode xs\n  \\<lbrakk>memb y S; x \\<in> set xs\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs S xs)\n  \\<lbrakk>\\<not> memb y S; x \\<in> set (succs y @ xs)\\<rbrakk>\n  \\<Longrightarrow> memb x (dfs (ins y S) (succs y @ xs))\n  x \\<in> set (y # xs)\n\ngoal (1 subgoal):\n 1. memb x (dfs S (y # xs))", "by (auto simp add: visit_subset_dfs ins_eq ins_invariant succs_isNode)"], ["proof (state)\nthis:\n  memb x (dfs S (y # xs))\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; x \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> memb x (dfs S [])", "qed simp"], ["", "lemma succss_closed_dfs':\n  \"invariant ys \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n   nodeAbs ` succss (set_of ys) \\<subseteq> nodeAbs ` (set xs \\<union> set_of ys) \\<Longrightarrow> nodeAbs ` succss (set_of (dfs ys xs)) \\<subseteq> nodeAbs ` set_of (dfs ys xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant ys; list_all isNode xs;\n     nodeAbs ` succss (set_of ys)\n     \\<subseteq> nodeAbs ` (set xs \\<union> set_of ys)\\<rbrakk>\n    \\<Longrightarrow> nodeAbs ` succss (set_of (dfs ys xs))\n                      \\<subseteq> nodeAbs ` set_of (dfs ys xs)", "proof(induct ys xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S;\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set [] \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S []))\n                         \\<subseteq> nodeAbs ` set_of (dfs S [])\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S;\n         nodeAbs ` succss (set_of S)\n         \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n        \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                          \\<subseteq> nodeAbs ` set_of (dfs S xs);\n        \\<lbrakk>\\<not> memb x S;\n         nodeAbs ` succss (set_of (ins x S))\n         \\<subseteq> nodeAbs `\n                     (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n        \\<Longrightarrow> nodeAbs `\n                          succss (set_of (dfs (ins x S) (succs x @ xs)))\n                          \\<subseteq> nodeAbs `\nset_of (dfs (ins x S) (succs x @ xs));\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S (x # xs)))\n                         \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))", "case (base S)"], ["proof (state)\nthis:\n  invariant S\n  nodeAbs ` succss (set_of S)\n  \\<subseteq> nodeAbs ` (set [] \\<union> set_of S)\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S;\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set [] \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S []))\n                         \\<subseteq> nodeAbs ` set_of (dfs S [])\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S;\n         nodeAbs ` succss (set_of S)\n         \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n        \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                          \\<subseteq> nodeAbs ` set_of (dfs S xs);\n        \\<lbrakk>\\<not> memb x S;\n         nodeAbs ` succss (set_of (ins x S))\n         \\<subseteq> nodeAbs `\n                     (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n        \\<Longrightarrow> nodeAbs `\n                          succss (set_of (dfs (ins x S) (succs x @ xs)))\n                          \\<subseteq> nodeAbs `\nset_of (dfs (ins x S) (succs x @ xs));\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S (x # xs)))\n                         \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  invariant S\n  nodeAbs ` succss (set_of S)\n  \\<subseteq> nodeAbs ` (set [] \\<union> set_of S)\n\ngoal (1 subgoal):\n 1. nodeAbs ` succss (set_of (dfs S []))\n    \\<subseteq> nodeAbs ` set_of (dfs S [])", "by simp"], ["proof (state)\nthis:\n  nodeAbs ` succss (set_of (dfs S []))\n  \\<subseteq> nodeAbs ` set_of (dfs S [])\n\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S;\n         nodeAbs ` succss (set_of S)\n         \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n        \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                          \\<subseteq> nodeAbs ` set_of (dfs S xs);\n        \\<lbrakk>\\<not> memb x S;\n         nodeAbs ` succss (set_of (ins x S))\n         \\<subseteq> nodeAbs `\n                     (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n        \\<Longrightarrow> nodeAbs `\n                          succss (set_of (dfs (ins x S) (succs x @ xs)))\n                          \\<subseteq> nodeAbs `\nset_of (dfs (ins x S) (succs x @ xs));\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S (x # xs)))\n                         \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S;\n         nodeAbs ` succss (set_of S)\n         \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n        \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                          \\<subseteq> nodeAbs ` set_of (dfs S xs);\n        \\<lbrakk>\\<not> memb x S;\n         nodeAbs ` succss (set_of (ins x S))\n         \\<subseteq> nodeAbs `\n                     (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n        \\<Longrightarrow> nodeAbs `\n                          succss (set_of (dfs (ins x S) (succs x @ xs)))\n                          \\<subseteq> nodeAbs `\nset_of (dfs (ins x S) (succs x @ xs));\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S (x # xs)))\n                         \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))", "case (step S x xs)"], ["proof (state)\nthis:\n  invariant S\n  isNode x\n  list_all isNode xs\n  \\<lbrakk>memb x S;\n   nodeAbs ` succss (set_of S)\n   \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n  \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                    \\<subseteq> nodeAbs ` set_of (dfs S xs)\n  \\<lbrakk>\\<not> memb x S;\n   nodeAbs ` succss (set_of (ins x S))\n   \\<subseteq> nodeAbs `\n               (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n  \\<Longrightarrow> nodeAbs ` succss (set_of (dfs (ins x S) (succs x @ xs)))\n                    \\<subseteq> nodeAbs `\n                                set_of (dfs (ins x S) (succs x @ xs))\n  nodeAbs ` succss (set_of S)\n  \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\n\ngoal (1 subgoal):\n 1. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S;\n         nodeAbs ` succss (set_of S)\n         \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n        \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                          \\<subseteq> nodeAbs ` set_of (dfs S xs);\n        \\<lbrakk>\\<not> memb x S;\n         nodeAbs ` succss (set_of (ins x S))\n         \\<subseteq> nodeAbs `\n                     (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n        \\<Longrightarrow> nodeAbs `\n                          succss (set_of (dfs (ins x S) (succs x @ xs)))\n                          \\<subseteq> nodeAbs `\nset_of (dfs (ins x S) (succs x @ xs));\n        nodeAbs ` succss (set_of S)\n        \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S (x # xs)))\n                         \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  invariant S\n  isNode x\n  list_all isNode xs\n  \\<lbrakk>memb x S;\n   nodeAbs ` succss (set_of S)\n   \\<subseteq> nodeAbs ` (set xs \\<union> set_of S)\\<rbrakk>\n  \\<Longrightarrow> nodeAbs ` succss (set_of (dfs S xs))\n                    \\<subseteq> nodeAbs ` set_of (dfs S xs)\n  \\<lbrakk>\\<not> memb x S;\n   nodeAbs ` succss (set_of (ins x S))\n   \\<subseteq> nodeAbs `\n               (set (succs x @ xs) \\<union> set_of (ins x S))\\<rbrakk>\n  \\<Longrightarrow> nodeAbs ` succss (set_of (dfs (ins x S) (succs x @ xs)))\n                    \\<subseteq> nodeAbs `\n                                set_of (dfs (ins x S) (succs x @ xs))\n  nodeAbs ` succss (set_of S)\n  \\<subseteq> nodeAbs ` (set (x # xs) \\<union> set_of S)\n\ngoal (1 subgoal):\n 1. nodeAbs ` succss (set_of (dfs S (x # xs)))\n    \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))", "apply (auto simp add: succss_def set_of_def cong: conj_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x (dfs S xs)}.\n            set (succs x))\n        \\<subseteq> nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set xs \\<union> {x. isNode x \\<and> memb x S});\n        memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs S xs)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {x. isNode x \\<and> memb x (dfs S xs)}\n 2. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {xa.\n                                isNode xa \\<and>\n                                memb xa (dfs (ins x S) (succs x @ xs))}", "apply (subgoal_tac \"nodeAbs xa \\<in> nodeAbs ` (\\<Union>x\\<in>{x. isNode x \\<and> memb x (dfs S xs)}. set (succs x))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x (dfs S xs)}.\n            set (succs x))\n        \\<subseteq> nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set xs \\<union> {x. isNode x \\<and> memb x S});\n        memb x S; xa \\<in> set (succs xb); isNode xb; memb xb (dfs S xs);\n        nodeAbs xa\n        \\<in> nodeAbs `\n              (\\<Union>x\\<in>{x. isNode x \\<and> memb x (dfs S xs)}.\n                  set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {x. isNode x \\<and> memb x (dfs S xs)}\n 2. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x (dfs S xs)}.\n            set (succs x))\n        \\<subseteq> nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set xs \\<union> {x. isNode x \\<and> memb x S});\n        memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs S xs)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               (\\<Union>x\\<in>{x.\n         isNode x \\<and> memb x (dfs S xs)}.\n                                   set (succs x))\n 3. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {xa.\n                                isNode xa \\<and>\n                                memb xa (dfs (ins x S) (succs x @ xs))}", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x (dfs S xs)}.\n            set (succs x))\n        \\<subseteq> nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set xs \\<union> {x. isNode x \\<and> memb x S});\n        memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs S xs)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               (\\<Union>x\\<in>{x.\n         isNode x \\<and> memb x (dfs S xs)}.\n                                   set (succs x))\n 2. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {xa.\n                                isNode xa \\<and>\n                                memb xa (dfs (ins x S) (succs x @ xs))}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {xa.\n                                isNode xa \\<and>\n                                memb xa (dfs (ins x S) (succs x @ xs))}", "apply (subgoal_tac \"nodeAbs ` (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}. set (succs x)) \\<subseteq> nodeAbs ` (set (succs x) \\<union> set xs \\<union> {xa. isNode xa \\<and> memb xa (ins x S)})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs));\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)})\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               {xa.\n                                isNode xa \\<and>\n                                memb xa (dfs (ins x S) (succs x @ xs))}\n 2. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs `\n                         (\\<Union>x\\<in>{xa.\n   isNode xa \\<and> memb xa (ins x S)}.\n                             set (succs x))\n                         \\<subseteq> nodeAbs `\n                                     (set (succs x) \\<union> set xs \\<union>\n{xa. isNode xa \\<and> memb xa (ins x S)})", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa. isNode xa \\<and> memb xa (ins x S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and> memb xa (ins x S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs `\n                         (\\<Union>x\\<in>{xa.\n   isNode xa \\<and> memb xa (ins x S)}.\n                             set (succs x))\n                         \\<subseteq> nodeAbs `\n                                     (set (succs x) \\<union> set xs \\<union>\n{xa. isNode xa \\<and> memb xa (ins x S)})", "apply (auto simp add: ins_eq succss_def set_of_def cong: conj_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (subgoal_tac \"\\<exists>xc'. xc' \\<in> set (succs x) \\<and> nodeAbs xc' = nodeAbs xc\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x;\n        \\<exists>xc'.\n           xc' \\<in> set (succs x) \\<and> nodeAbs xc' = nodeAbs xc\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 3. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xb xc xd xc'.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x; xc' \\<in> set (succs x);\n        nodeAbs xc' = nodeAbs xc\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 3. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (rule_tac x=xc' in image_eqI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa xb xc xd xc'.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x; xc' \\<in> set (succs x);\n        nodeAbs xc' = nodeAbs xc\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc = nodeAbs xc'\n 2. \\<And>xa xb xc xd xc'.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x; xc' \\<in> set (succs x);\n        nodeAbs xc' = nodeAbs xc\\<rbrakk>\n       \\<Longrightarrow> xc'\n                         \\<in> set (succs x) \\<union> set xs \\<union>\n                               {xa.\n                                isNode xa \\<and>\n                                (nodeAbs xa = nodeAbs x \\<or> memb xa S)}\n 3. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 4. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xb xc xd xc'.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x; xc' \\<in> set (succs x);\n        nodeAbs xc' = nodeAbs xc\\<rbrakk>\n       \\<Longrightarrow> xc'\n                         \\<in> set (succs x) \\<union> set xs \\<union>\n                               {xa.\n                                isNode xa \\<and>\n                                (nodeAbs xa = nodeAbs x \\<or> memb xa S)}\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 3. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (cut_tac x=xd and y=x in succs)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> isNode xd\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> isNode x\n 3. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xd = nodeAbs x\n 4. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x;\n        nodeAbs ` set (succs xd) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 5. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x;\n        nodeAbs ` set (succs xd) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (subgoal_tac \"nodeAbs xc \\<in> nodeAbs ` set (succs x)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x;\n        nodeAbs ` set (succs xd) = nodeAbs ` set (succs x);\n        nodeAbs xc \\<in> nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xc'.\n                            xc' \\<in> set (succs x) \\<and>\n                            nodeAbs xc' = nodeAbs xc\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x;\n        nodeAbs ` set (succs xd) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc \\<in> nodeAbs ` set (succs x)\n 3. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; nodeAbs xd = nodeAbs x;\n        nodeAbs ` set (succs xd) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc \\<in> nodeAbs ` set (succs x)\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (subgoal_tac \"nodeAbs ` set (succs xd) \\<subseteq> nodeAbs ` (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` set (succs xd)\n                         \\<subseteq> nodeAbs `\n                                     (\\<Union>x\\<in>{x.\n               isNode x \\<and> memb x S}.\n   set (succs x))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` set (succs xd)\n                         \\<subseteq> nodeAbs `\n                                     (\\<Union>x\\<in>{x.\n               isNode x \\<and> memb x S}.\n   set (succs x))\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (subgoal_tac \"nodeAbs xc \\<in> nodeAbs ` set (succs xd)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc \\<in> nodeAbs ` set (succs xd)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc \\<in> nodeAbs ` set (succs xd)\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (subgoal_tac \"nodeAbs xc \\<in> insert (nodeAbs x) (nodeAbs ` (set xs \\<union> {x. isNode x \\<and> memb x S}))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd);\n        nodeAbs xc\n        \\<in> insert (nodeAbs x)\n               (nodeAbs `\n                (set xs \\<union> {x. isNode x \\<and> memb x S}))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> insert (nodeAbs x)\n                                (nodeAbs `\n                                 (set xs \\<union>\n                                  {x. isNode x \\<and> memb x S}))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> insert (nodeAbs x)\n                                (nodeAbs `\n                                 (set xs \\<union>\n                                  {x. isNode x \\<and> memb x S}))\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd);\n        nodeAbs xc\n        \\<in> insert (nodeAbs x)\n               (nodeAbs `\n                (set xs \\<union> {x. isNode x \\<and> memb x S}))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (erule rev_subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` set (succs xd)\n                         \\<subseteq> insert (nodeAbs x)\n(nodeAbs ` (set xs \\<union> {x. isNode x \\<and> memb x S}))\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd);\n        nodeAbs xc\n        \\<in> insert (nodeAbs x)\n               (nodeAbs `\n                (set xs \\<union> {x. isNode x \\<and> memb x S}))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply (erule subset_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S\\<rbrakk>\n       \\<Longrightarrow> nodeAbs `\n                         (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                             set (succs x))\n                         \\<subseteq> insert (nodeAbs x)\n(nodeAbs ` (set xs \\<union> {x. isNode x \\<and> memb x S}))\n 2. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd);\n        nodeAbs xc\n        \\<in> insert (nodeAbs x)\n               (nodeAbs `\n                (set xs \\<union> {x. isNode x \\<and> memb x S}))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xc xd.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        (nodeAbs xa = nodeAbs x \\<or> memb xa S)}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    (set (succs x) \\<union> set xs \\<union>\n                     {xa.\n                      isNode xa \\<and>\n                      (nodeAbs xa = nodeAbs x \\<or>\n                       memb xa S)}) \\<Longrightarrow>\n        nodeAbs `\n        (\\<Union>x\\<in>{xa.\n                        isNode xa \\<and>\n                        memb xa (dfs (ins x S) (succs x @ xs))}.\n            set (succs x))\n        \\<subseteq> nodeAbs `\n                    {xa.\n                     isNode xa \\<and>\n                     memb xa (dfs (ins x S) (succs x @ xs))};\n        nodeAbs `\n        (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}. set (succs x))\n        \\<subseteq> insert (nodeAbs x)\n                     (nodeAbs `\n                      (set xs \\<union> {x. isNode x \\<and> memb x S}));\n        \\<not> memb x S; xa \\<in> set (succs xb); isNode xb;\n        memb xb (dfs (ins x S) (succs x @ xs)); xc \\<in> set (succs xd);\n        isNode xd; memb xd S;\n        nodeAbs ` set (succs xd)\n        \\<subseteq> nodeAbs `\n                    (\\<Union>x\\<in>{x. isNode x \\<and> memb x S}.\n                        set (succs x));\n        nodeAbs xc \\<in> nodeAbs ` set (succs xd);\n        nodeAbs xc\n        \\<in> insert (nodeAbs x)\n               (nodeAbs `\n                (set xs \\<union> {x. isNode x \\<and> memb x S}))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xc\n                         \\<in> nodeAbs `\n                               (set (succs x) \\<union> set xs \\<union>\n                                {xa.\n                                 isNode xa \\<and>\n                                 (nodeAbs xa = nodeAbs x \\<or> memb xa S)})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nodeAbs ` succss (set_of (dfs S (x # xs)))\n  \\<subseteq> nodeAbs ` set_of (dfs S (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma succss_closed_dfs: \"list_all isNode xs \\<Longrightarrow>\n  nodeAbs ` succss (set_of (dfs empt xs)) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all isNode xs \\<Longrightarrow>\n    nodeAbs ` succss (set_of (dfs empt xs))\n    \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "apply (rule succss_closed_dfs')"], ["proof (prove)\ngoal (3 subgoals):\n 1. list_all isNode xs \\<Longrightarrow> invariant empt\n 2. list_all isNode xs \\<Longrightarrow> list_all isNode xs\n 3. list_all isNode xs \\<Longrightarrow>\n    nodeAbs ` succss (set_of empt)\n    \\<subseteq> nodeAbs ` (set xs \\<union> set_of empt)", "apply (rule empt_invariant)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all isNode xs \\<Longrightarrow> list_all isNode xs\n 2. list_all isNode xs \\<Longrightarrow>\n    nodeAbs ` succss (set_of empt)\n    \\<subseteq> nodeAbs ` (set xs \\<union> set_of empt)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all isNode xs \\<Longrightarrow>\n    nodeAbs ` succss (set_of empt)\n    \\<subseteq> nodeAbs ` (set xs \\<union> set_of empt)", "apply (simp add: succss_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all isNode xs \\<Longrightarrow>\n    nodeAbs ` (\\<Union>x\\<in>set_of empt. set (succs x))\n    \\<subseteq> nodeAbs ` (set xs \\<union> set_of empt)", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>list_all isNode xs;\n        x \\<in> nodeAbs `\n                (\\<Union>x\\<in>set_of empt. set (succs x))\\<rbrakk>\n       \\<Longrightarrow> x \\<in> nodeAbs ` (set xs \\<union> set_of empt)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>list_all isNode xs; xb \\<in> set_of empt;\n        xa \\<in> set (succs xb)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs ` (set xs \\<union> set_of empt)", "unfolding set_of_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>list_all isNode xs;\n        xb \\<in> {x. isNode x \\<and> memb x empt};\n        xa \\<in> set (succs xb)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               (set xs \\<union>\n                                {x. isNode x \\<and> memb x empt})", "using empt"], ["proof (prove)\nusing this:\n  isNode ?x \\<Longrightarrow> \\<not> memb ?x empt\n\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>list_all isNode xs;\n        xb \\<in> {x. isNode x \\<and> memb x empt};\n        xa \\<in> set (succs xb)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               (set xs \\<union>\n                                {x. isNode x \\<and> memb x empt})", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  \"succsr \\<equiv> {(x, y). y \\<in> set (succs x)}\""], ["", "theorem succsr_isNode:\n  assumes xy: \"(x, y) \\<in> succsr\\<^sup>*\"\n  shows \"isNode x \\<Longrightarrow> isNode y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isNode x \\<Longrightarrow> isNode y", "using xy"], ["proof (prove)\nusing this:\n  (x, y) \\<in> succsr\\<^sup>*\n\ngoal (1 subgoal):\n 1. isNode x \\<Longrightarrow> isNode y", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. isNode x \\<Longrightarrow> isNode x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> succsr\\<^sup>*; (y, z) \\<in> succsr;\n        isNode x \\<Longrightarrow> isNode y; isNode x\\<rbrakk>\n       \\<Longrightarrow> isNode z", "case (step y z)"], ["proof (state)\nthis:\n  (x, y) \\<in> succsr\\<^sup>*\n  (y, z) \\<in> succsr\n  isNode x \\<Longrightarrow> isNode y\n  isNode x\n\ngoal (2 subgoals):\n 1. isNode x \\<Longrightarrow> isNode x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> succsr\\<^sup>*; (y, z) \\<in> succsr;\n        isNode x \\<Longrightarrow> isNode y; isNode x\\<rbrakk>\n       \\<Longrightarrow> isNode z", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> succsr\\<^sup>*\n  (y, z) \\<in> succsr\n  isNode x \\<Longrightarrow> isNode y\n  isNode x", "have \"isNode y\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> succsr\\<^sup>*\n  (y, z) \\<in> succsr\n  isNode x \\<Longrightarrow> isNode y\n  isNode x\n\ngoal (1 subgoal):\n 1. isNode y", "by simp"], ["proof (state)\nthis:\n  isNode y\n\ngoal (2 subgoals):\n 1. isNode x \\<Longrightarrow> isNode x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> succsr\\<^sup>*; (y, z) \\<in> succsr;\n        isNode x \\<Longrightarrow> isNode y; isNode x\\<rbrakk>\n       \\<Longrightarrow> isNode z", "then"], ["proof (chain)\npicking this:\n  isNode y", "have \"list_all isNode (succs y)\""], ["proof (prove)\nusing this:\n  isNode y\n\ngoal (1 subgoal):\n 1. list_all isNode (succs y)", "by (rule succs_isNode)"], ["proof (state)\nthis:\n  list_all isNode (succs y)\n\ngoal (2 subgoals):\n 1. isNode x \\<Longrightarrow> isNode x\n 2. \\<And>y z.\n       \\<lbrakk>(x, y) \\<in> succsr\\<^sup>*; (y, z) \\<in> succsr;\n        isNode x \\<Longrightarrow> isNode y; isNode x\\<rbrakk>\n       \\<Longrightarrow> isNode z", "with step"], ["proof (chain)\npicking this:\n  (x, y) \\<in> succsr\\<^sup>*\n  (y, z) \\<in> succsr\n  isNode x \\<Longrightarrow> isNode y\n  isNode x\n  list_all isNode (succs y)", "show ?case"], ["proof (prove)\nusing this:\n  (x, y) \\<in> succsr\\<^sup>*\n  (y, z) \\<in> succsr\n  isNode x \\<Longrightarrow> isNode y\n  isNode x\n  list_all isNode (succs y)\n\ngoal (1 subgoal):\n 1. isNode z", "by (simp add: succsr_def list_all_iff)"], ["proof (state)\nthis:\n  isNode z\n\ngoal (1 subgoal):\n 1. isNode x \\<Longrightarrow> isNode x", "qed"], ["", "lemma succss_closed:\n  assumes inc: \"nodeAbs ` succss X \\<subseteq> nodeAbs ` X\"\n      and X: \"X \\<subseteq> { x . isNode x }\"\n  shows \"nodeAbs ` reachable X = nodeAbs ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeAbs ` reachable X = nodeAbs ` X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. nodeAbs ` reachable X \\<subseteq> nodeAbs ` X\n 2. nodeAbs ` X \\<subseteq> nodeAbs ` reachable X", "show \"nodeAbs ` X \\<subseteq> nodeAbs ` reachable X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeAbs ` X \\<subseteq> nodeAbs ` reachable X", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeAbs ` X\n    \\<subseteq> nodeAbs ` {(x, y). y \\<in> set (succs x)}\\<^sup>* `` X", "by auto"], ["proof (state)\nthis:\n  nodeAbs ` X \\<subseteq> nodeAbs ` reachable X\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable X \\<subseteq> nodeAbs ` X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nodeAbs ` reachable X \\<subseteq> nodeAbs ` X", "show \"nodeAbs ` reachable X \\<subseteq> nodeAbs ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeAbs ` reachable X \\<subseteq> nodeAbs ` X", "proof(unfold reachable_def, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>(xb, xa) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa \\<in> nodeAbs ` X", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>(xb, xa) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa \\<in> nodeAbs ` X", "assume y: \"y \\<in> X\""], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>(xb, xa) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa \\<in> nodeAbs ` X", "assume \"(y, x) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\""], ["proof (state)\nthis:\n  (y, x) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>(xb, xa) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xb \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa \\<in> nodeAbs ` X", "thus \"nodeAbs x \\<in> nodeAbs ` X\""], ["proof (prove)\nusing this:\n  (y, x) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n\ngoal (1 subgoal):\n 1. nodeAbs x \\<in> nodeAbs ` X", "using y"], ["proof (prove)\nusing this:\n  (y, x) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. nodeAbs x \\<in> nodeAbs ` X", "proof induct"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> X \\<Longrightarrow> nodeAbs y \\<in> nodeAbs ` X\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        (ya, z) \\<in> {(x, y). y \\<in> set (succs x)};\n        y \\<in> X \\<Longrightarrow> nodeAbs ya \\<in> nodeAbs ` X;\n        y \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs z \\<in> nodeAbs ` X", "case base"], ["proof (state)\nthis:\n  y \\<in> X\n\ngoal (2 subgoals):\n 1. y \\<in> X \\<Longrightarrow> nodeAbs y \\<in> nodeAbs ` X\n 2. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        (ya, z) \\<in> {(x, y). y \\<in> set (succs x)};\n        y \\<in> X \\<Longrightarrow> nodeAbs ya \\<in> nodeAbs ` X;\n        y \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs z \\<in> nodeAbs ` X", "thus ?case"], ["proof (prove)\nusing this:\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. nodeAbs y \\<in> nodeAbs ` X", "by simp"], ["proof (state)\nthis:\n  nodeAbs y \\<in> nodeAbs ` X\n\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        (ya, z) \\<in> {(x, y). y \\<in> set (succs x)};\n        y \\<in> X \\<Longrightarrow> nodeAbs ya \\<in> nodeAbs ` X;\n        y \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs z \\<in> nodeAbs ` X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        (ya, z) \\<in> {(x, y). y \\<in> set (succs x)};\n        y \\<in> X \\<Longrightarrow> nodeAbs ya \\<in> nodeAbs ` X;\n        y \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs z \\<in> nodeAbs ` X", "case (step r s)"], ["proof (state)\nthis:\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        (ya, z) \\<in> {(x, y). y \\<in> set (succs x)};\n        y \\<in> X \\<Longrightarrow> nodeAbs ya \\<in> nodeAbs ` X;\n        y \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs z \\<in> nodeAbs ` X", "from X step"], ["proof (chain)\npicking this:\n  X \\<subseteq> {x. isNode x}\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X", "have \"isNode r\""], ["proof (prove)\nusing this:\n  X \\<subseteq> {x. isNode x}\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X\n\ngoal (1 subgoal):\n 1. isNode r", "using succsr_isNode[where x=y and y=r]"], ["proof (prove)\nusing this:\n  X \\<subseteq> {x. isNode x}\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X\n  \\<lbrakk>(y, r) \\<in> succsr\\<^sup>*; isNode y\\<rbrakk>\n  \\<Longrightarrow> isNode r\n\ngoal (1 subgoal):\n 1. isNode r", "unfolding succsr_def"], ["proof (prove)\nusing this:\n  X \\<subseteq> {x. isNode x}\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X\n  \\<lbrakk>(y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n   isNode y\\<rbrakk>\n  \\<Longrightarrow> isNode r\n\ngoal (1 subgoal):\n 1. isNode r", "by fastforce"], ["proof (state)\nthis:\n  isNode r\n\ngoal (1 subgoal):\n 1. \\<And>ya z.\n       \\<lbrakk>(y, ya) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        (ya, z) \\<in> {(x, y). y \\<in> set (succs x)};\n        y \\<in> X \\<Longrightarrow> nodeAbs ya \\<in> nodeAbs ` X;\n        y \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs z \\<in> nodeAbs ` X", "with inc step"], ["proof (chain)\npicking this:\n  nodeAbs ` succss X \\<subseteq> nodeAbs ` X\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X\n  isNode r", "show ?case"], ["proof (prove)\nusing this:\n  nodeAbs ` succss X \\<subseteq> nodeAbs ` X\n  (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n  (r, s) \\<in> {(x, y). y \\<in> set (succs x)}\n  y \\<in> X \\<Longrightarrow> nodeAbs r \\<in> nodeAbs ` X\n  y \\<in> X\n  isNode r\n\ngoal (1 subgoal):\n 1. nodeAbs s \\<in> nodeAbs ` X", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` X", "apply (subgoal_tac \"isNode x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` X\n 2. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> isNode x", "apply (cut_tac x=r and y=x in succs)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x\\<rbrakk>\n       \\<Longrightarrow> isNode r\n 2. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x\\<rbrakk>\n       \\<Longrightarrow> isNode x\n 3. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x\\<rbrakk>\n       \\<Longrightarrow> nodeAbs r = nodeAbs x\n 4. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x;\n        nodeAbs ` set (succs r) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` X\n 5. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> isNode x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x;\n        nodeAbs ` set (succs r) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` X\n 2. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> isNode x", "apply (subgoal_tac \"nodeAbs s \\<in> nodeAbs ` set (succs x)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x;\n        nodeAbs ` set (succs r) = nodeAbs ` set (succs x);\n        nodeAbs s \\<in> nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` X\n 2. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x;\n        nodeAbs ` set (succs r) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` set (succs x)\n 3. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> isNode x", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> {x. isNode x}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x;\n        nodeAbs ` set (succs r) = nodeAbs ` set (succs x);\n        nodeAbs s \\<in> nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` X\n 2. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X; isNode x;\n        nodeAbs ` set (succs r) = nodeAbs ` set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs s \\<in> nodeAbs ` set (succs x)\n 3. \\<And>x.\n       \\<lbrakk>nodeAbs ` succss X \\<subseteq> nodeAbs ` X;\n        (y, r) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        s \\<in> set (succs r); y \\<in> X; isNode r; nodeAbs r = nodeAbs x;\n        x \\<in> X\\<rbrakk>\n       \\<Longrightarrow> isNode x", "apply (auto simp: succss_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nodeAbs s \\<in> nodeAbs ` X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodeAbs x \\<in> nodeAbs ` X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodeAbs ` reachable X \\<subseteq> nodeAbs ` X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dfs_isNode:\n  assumes S: \"invariant S\"\n      and xs: \"list_all isNode xs\"\n  shows \"set_of (dfs S xs) \\<subseteq> {x . isNode x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (dfs S xs) \\<subseteq> {x. isNode x}", "using assms"], ["proof (prove)\nusing this:\n  invariant S\n  list_all isNode xs\n\ngoal (1 subgoal):\n 1. set_of (dfs S xs) \\<subseteq> {x. isNode x}", "by (induct S xs rule: dfs_induct) (auto simp: set_of_def)"], ["", "lemma reachable_closed_dfs:\n  assumes xs: \"list_all isNode xs\"\n  shows \"nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "from xs"], ["proof (chain)\npicking this:\n  list_all isNode xs", "have \"reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))\""], ["proof (prove)\nusing this:\n  list_all isNode xs\n\ngoal (1 subgoal):\n 1. reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))", "apply (unfold reachable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all isNode xs \\<Longrightarrow>\n    {(x, y). y \\<in> set (succs x)}\\<^sup>* `` set xs\n    \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                set_of (dfs empt xs)", "apply (rule Image_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all isNode xs \\<Longrightarrow>\n    {(x, y). y \\<in> set (succs x)}\\<^sup>*\n    \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>*\n 2. list_all isNode xs \\<Longrightarrow>\n    set xs \\<subseteq> set_of (dfs empt xs)", "apply (auto simp add: set_of_def next_subset_dfs empt_invariant list_all_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "hence \"nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` reachable (set_of (dfs empt xs))\""], ["proof (prove)\nusing this:\n  reachable (set xs) \\<subseteq> reachable (set_of (dfs empt xs))\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs)\n    \\<subseteq> nodeAbs ` reachable (set_of (dfs empt xs))", "by auto"], ["proof (state)\nthis:\n  nodeAbs ` reachable (set xs)\n  \\<subseteq> nodeAbs ` reachable (set_of (dfs empt xs))\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "also"], ["proof (state)\nthis:\n  nodeAbs ` reachable (set xs)\n  \\<subseteq> nodeAbs ` reachable (set_of (dfs empt xs))\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "from succss_closed_dfs[OF xs]"], ["proof (chain)\npicking this:\n  nodeAbs ` succss (set_of (dfs empt xs))\n  \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "have \"\\<dots> = nodeAbs ` set_of (dfs empt xs)\""], ["proof (prove)\nusing this:\n  nodeAbs ` succss (set_of (dfs empt xs))\n  \\<subseteq> nodeAbs ` set_of (dfs empt xs)\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set_of (dfs empt xs)) =\n    nodeAbs ` set_of (dfs empt xs)", "apply (rule succss_closed)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_of (dfs empt xs) \\<subseteq> {x. isNode x}", "apply (rule dfs_isNode[OF empt_invariant xs])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nodeAbs ` reachable (set_of (dfs empt xs)) =\n  nodeAbs ` set_of (dfs empt xs)\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "finally"], ["proof (chain)\npicking this:\n  nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\n\ngoal (1 subgoal):\n 1. nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)", "."], ["proof (state)\nthis:\n  nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_succs: \"reachable (set (succs x)) \\<subseteq> reachable {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (set (succs x)) \\<subseteq> reachable {x}", "by (auto simp add: reachable_def intro: converse_rtrancl_into_rtrancl)"], ["", "lemma dfs_subset_reachable_visit_nodes:\n  \"invariant ys \\<Longrightarrow> list_all isNode xs \\<Longrightarrow>\n   nodeAbs ` set_of (dfs ys xs) \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invariant ys; list_all isNode xs\\<rbrakk>\n    \\<Longrightarrow> nodeAbs ` set_of (dfs ys xs)\n                      \\<subseteq> nodeAbs `\n                                  (reachable (set xs) \\<union> set_of ys)", "proof(induct ys xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       invariant S \\<Longrightarrow>\n       nodeAbs ` set_of (dfs S [])\n       \\<subseteq> nodeAbs ` (reachable (set []) \\<union> set_of S)\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        memb x S \\<Longrightarrow>\n        nodeAbs ` set_of (dfs S xs)\n        \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of S);\n        \\<not> memb x S \\<Longrightarrow>\n        nodeAbs ` set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> nodeAbs `\n                    (reachable (set (succs x @ xs)) \\<union>\n                     set_of (ins x S))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` set_of (dfs S (x # xs))\n                         \\<subseteq> nodeAbs `\n                                     (reachable (set (x # xs)) \\<union>\nset_of S)", "case (step S x xs)"], ["proof (state)\nthis:\n  invariant S\n  isNode x\n  list_all isNode xs\n  memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs S xs)\n  \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of S)\n  \\<not> memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> nodeAbs `\n              (reachable (set (succs x @ xs)) \\<union> set_of (ins x S))\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       invariant S \\<Longrightarrow>\n       nodeAbs ` set_of (dfs S [])\n       \\<subseteq> nodeAbs ` (reachable (set []) \\<union> set_of S)\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        memb x S \\<Longrightarrow>\n        nodeAbs ` set_of (dfs S xs)\n        \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of S);\n        \\<not> memb x S \\<Longrightarrow>\n        nodeAbs ` set_of (dfs (ins x S) (succs x @ xs))\n        \\<subseteq> nodeAbs `\n                    (reachable (set (succs x @ xs)) \\<union>\n                     set_of (ins x S))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs ` set_of (dfs S (x # xs))\n                         \\<subseteq> nodeAbs `\n                                     (reachable (set (x # xs)) \\<union>\nset_of S)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "proof (cases \"memb x S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)\n 2. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "case True"], ["proof (state)\nthis:\n  memb x S\n\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)\n 2. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "with step"], ["proof (chain)\npicking this:\n  invariant S\n  isNode x\n  list_all isNode xs\n  memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs S xs)\n  \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of S)\n  \\<not> memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> nodeAbs `\n              (reachable (set (succs x @ xs)) \\<union> set_of (ins x S))\n  memb x S", "show ?thesis"], ["proof (prove)\nusing this:\n  invariant S\n  isNode x\n  list_all isNode xs\n  memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs S xs)\n  \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of S)\n  \\<not> memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> nodeAbs `\n              (reachable (set (succs x @ xs)) \\<union> set_of (ins x S))\n  memb x S\n\ngoal (1 subgoal):\n 1. nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "by (auto simp add: reachable_def)"], ["proof (state)\nthis:\n  nodeAbs ` set_of (dfs S (x # xs))\n  \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "case False"], ["proof (state)\nthis:\n  \\<not> memb x S\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "have \"reachable (set (succs x)) \\<subseteq> reachable {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable (set (succs x)) \\<subseteq> reachable {x}", "by (rule reachable_succs)"], ["proof (state)\nthis:\n  reachable (set (succs x)) \\<subseteq> reachable {x}\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "then"], ["proof (chain)\npicking this:\n  reachable (set (succs x)) \\<subseteq> reachable {x}", "have \"reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\""], ["proof (prove)\nusing this:\n  reachable (set (succs x)) \\<subseteq> reachable {x}\n\ngoal (1 subgoal):\n 1. reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))", "by (auto simp add: reachable_def)"], ["proof (state)\nthis:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "then"], ["proof (chain)\npicking this:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\n\ngoal (1 subgoal):\n 1. nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "using step"], ["proof (prove)\nusing this:\n  reachable (set (succs x @ xs)) \\<subseteq> reachable (set (x # xs))\n  invariant S\n  isNode x\n  list_all isNode xs\n  memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs S xs)\n  \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of S)\n  \\<not> memb x S \\<Longrightarrow>\n  nodeAbs ` set_of (dfs (ins x S) (succs x @ xs))\n  \\<subseteq> nodeAbs `\n              (reachable (set (succs x @ xs)) \\<union> set_of (ins x S))\n\ngoal (1 subgoal):\n 1. nodeAbs ` set_of (dfs S (x # xs))\n    \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)", "apply (auto simp add: reachable_def set_of_def cong: conj_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     set xs \\<union>\n                     {x. isNode x \\<and> memb x S});\n        memb x S; isNode xa; memb xa (dfs S xs)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})\n 2. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa;\n        memb xa (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply (subgoal_tac \"nodeAbs xa \\<in> nodeAbs `\n            ({(x, y). y \\<in> set (succs x)}\\<^sup>* `` set xs \\<union>\n             {x. isNode x \\<and> memb x S})\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     set xs \\<union>\n                     {x. isNode x \\<and> memb x S});\n        memb x S; isNode xa; memb xa (dfs S xs);\n        nodeAbs xa\n        \\<in> nodeAbs `\n              ({(x, y). y \\<in> set (succs x)}\\<^sup>* `` set xs \\<union>\n               {x. isNode x \\<and> memb x S})\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})\n 2. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     set xs \\<union>\n                     {x. isNode x \\<and> memb x S});\n        memb x S; isNode xa; memb xa (dfs S xs)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                set xs \\<union>\n                                {x. isNode x \\<and> memb x S})\n 3. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa;\n        memb xa (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs ` {x. isNode x \\<and> memb x (dfs S xs)}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     set xs \\<union>\n                     {x. isNode x \\<and> memb x S});\n        memb x S; isNode xa; memb xa (dfs S xs)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                set xs \\<union>\n                                {x. isNode x \\<and> memb x S})\n 2. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa;\n        memb xa (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa;\n        memb xa (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply (subgoal_tac \"nodeAbs xa \\<in> nodeAbs `\n            ({(x, y). y \\<in> set (succs x)}\\<^sup>* `` (set (succs x) \\<union> set xs) \\<union>\n             {xa. isNode xa \\<and> memb xa (ins x S)})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa\n        \\<in> nodeAbs `\n              ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n               (set (succs x) \\<union> set xs) \\<union>\n               {xa. isNode xa \\<and> memb xa (ins x S)})\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})\n 2. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa;\n        memb xa (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                (set (succs x) \\<union> set xs) \\<union>\n                                {xa. isNode xa \\<and> memb xa (ins x S)})", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa;\n        memb xa (dfs (ins x S) (succs x @ xs))\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                (set (succs x) \\<union> set xs) \\<union>\n                                {xa. isNode xa \\<and> memb xa (ins x S)})\n 2. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa\n        \\<in> nodeAbs `\n              ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n               (set (succs x) \\<union> set xs) \\<union>\n               {xa. isNode xa \\<and> memb xa (ins x S)})\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa\n        \\<in> nodeAbs `\n              ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n               (set (succs x) \\<union> set xs) \\<union>\n               {xa. isNode xa \\<and> memb xa (ins x S)})\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xa\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xba.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb;\n        (xba, xb) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xba \\<in> set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xb\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})\n 2. \\<And>xa xb.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb; isNode xb; memb xb (ins x S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xb\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply (rule_tac x=xb in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa xb xba.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb;\n        (xba, xb) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xba \\<in> set (succs x)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xb = nodeAbs xb\n 2. \\<And>xa xb xba.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb;\n        (xba, xb) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xba \\<in> set (succs x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                  insert x (set xs) \\<union>\n                                  {x. isNode x \\<and> memb x S}\n 3. \\<And>xa xb.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb; isNode xb; memb xb (ins x S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xb\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xb xba.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb;\n        (xba, xb) \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>*;\n        xba \\<in> set (succs x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                  insert x (set xs) \\<union>\n                                  {x. isNode x \\<and> memb x S}\n 2. \\<And>xa xb.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb; isNode xb; memb xb (ins x S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xb\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb.\n       \\<lbrakk>{(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                (set (succs x) \\<union> set xs)\n                \\<subseteq> {(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                            insert x (set xs);\n        invariant S; isNode x; list_all isNode xs;\n        nodeAbs `\n        {xa. isNode xa \\<and> memb xa (dfs (ins x S) (succs x @ xs))}\n        \\<subseteq> nodeAbs `\n                    ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                     (set (succs x) \\<union> set xs) \\<union>\n                     {xa. isNode xa \\<and> memb xa (ins x S)});\n        \\<not> memb x S; isNode xa; memb xa (dfs (ins x S) (succs x @ xs));\n        nodeAbs xa = nodeAbs xb; isNode xb; memb xb (ins x S)\\<rbrakk>\n       \\<Longrightarrow> nodeAbs xb\n                         \\<in> nodeAbs `\n                               ({(x, y). y \\<in> set (succs x)}\\<^sup>* ``\n                                insert x (set xs) \\<union>\n                                {x. isNode x \\<and> memb x S})", "apply (auto iff: ins_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nodeAbs ` set_of (dfs S (x # xs))\n  \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)\n\ngoal:\nNo subgoals!", "(* by (auto simp add: reachable_def ins_eq set_of_def cong: conj_cong) *)"], ["proof (state)\nthis:\n  nodeAbs ` set_of (dfs S (x # xs))\n  \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nodeAbs ` set_of (dfs S (x # xs))\n  \\<subseteq> nodeAbs ` (reachable (set (x # xs)) \\<union> set_of S)\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       invariant S \\<Longrightarrow>\n       nodeAbs ` set_of (dfs S [])\n       \\<subseteq> nodeAbs ` (reachable (set []) \\<union> set_of S)", "qed (simp add: reachable_def)"], ["", "theorem dfs_imp_reachable:\n  assumes y: \"isNode y\"\n      and xs: \"list_all isNode xs\"\n      and m: \"memb y (dfs empt xs)\"\n  shows \"\\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)", "from m dfs_subset_reachable_visit_nodes [OF empt_invariant xs] y"], ["proof (chain)\npicking this:\n  memb y (dfs empt xs)\n  nodeAbs ` set_of (dfs empt xs)\n  \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of empt)\n  isNode y", "obtain y'\n    where \"nodeAbs y' = nodeAbs y\"\n      and \"y' \\<in> reachable (set xs)\""], ["proof (prove)\nusing this:\n  memb y (dfs empt xs)\n  nodeAbs ` set_of (dfs empt xs)\n  \\<subseteq> nodeAbs ` (reachable (set xs) \\<union> set_of empt)\n  isNode y\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        \\<lbrakk>nodeAbs y' = nodeAbs y;\n         y' \\<in> reachable (set xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: empt set_of_def)"], ["proof (state)\nthis:\n  nodeAbs y' = nodeAbs y\n  y' \\<in> reachable (set xs)\n\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  nodeAbs y' = nodeAbs y\n  y' \\<in> reachable (set xs)\n\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)", "by blast"], ["proof (state)\nthis:\n  \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> y' \\<in> reachable (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nWe make use of two results about the traversal. Firstly, that some\nrepresentation of each reachable node has been incorporated into the\nfinal construction:\n\n\\<close>"], ["", "theorem (in DFS) reachable_imp_dfs:\n  assumes y: \"isNode y\"\n      and xs: \"list_all isNode xs\"\n      and m: \"y \\<in> reachable (set xs)\"\n  shows \"\\<exists>y'. nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)", "using y m reachable_closed_dfs[OF xs]"], ["proof (prove)\nusing this:\n  isNode y\n  y \\<in> reachable (set xs)\n  nodeAbs ` reachable (set xs) \\<subseteq> nodeAbs ` set_of (dfs empt xs)\n\ngoal (1 subgoal):\n 1. \\<exists>y'. nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)", "apply (auto simp add: set_of_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isNode y; y \\<in> reachable (set xs);\n     nodeAbs ` reachable (set xs)\n     \\<subseteq> nodeAbs `\n                 {x. isNode x \\<and> memb x (dfs empt xs)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'.\n                         nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)", "apply (drule subsetD[where c=\"nodeAbs y\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>isNode y; y \\<in> reachable (set xs)\\<rbrakk>\n    \\<Longrightarrow> nodeAbs y \\<in> nodeAbs ` reachable (set xs)\n 2. \\<lbrakk>isNode y; y \\<in> reachable (set xs);\n     nodeAbs y\n     \\<in> nodeAbs ` {x. isNode x \\<and> memb x (dfs empt xs)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'.\n                         nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isNode y; y \\<in> reachable (set xs);\n     nodeAbs y\n     \\<in> nodeAbs ` {x. isNode x \\<and> memb x (dfs empt xs)}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y'.\n                         nodeAbs y' = nodeAbs y \\<and> memb y' (dfs empt xs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem dfs_invariant' [consumes 2, case_names base step]:\n  assumes S: \"invariant S\"\n  and xs: \"list_all isNode xs\"\n  and H: \"I S\"\n  and I: \"\\<And>S x. \\<not> memb x S \\<Longrightarrow> isNode x \\<Longrightarrow> invariant S \\<Longrightarrow> I S \\<Longrightarrow> I (ins x S)\"\n  shows \"I (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (dfs S xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I (dfs S xs)", "from S xs H"], ["proof (chain)\npicking this:\n  invariant S\n  list_all isNode xs\n  I S", "have \"I (dfs S xs) \\<and> invariant (dfs S xs)\""], ["proof (prove)\nusing this:\n  invariant S\n  list_all isNode xs\n  I S\n\ngoal (1 subgoal):\n 1. I (dfs S xs) \\<and> invariant (dfs S xs)", "proof (induct S xs rule: dfs_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S []) \\<and> invariant (dfs S [])\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "case (step S x xs)"], ["proof (state)\nthis:\n  invariant S\n  isNode x\n  list_all isNode xs\n  \\<lbrakk>memb x S; I S\\<rbrakk>\n  \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs)\n  \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n  \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                    invariant (dfs (ins x S) (succs x @ xs))\n  I S\n\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S []) \\<and> invariant (dfs S [])\n 2. \\<And>S x xs.\n       \\<lbrakk>invariant S; isNode x; list_all isNode xs;\n        \\<lbrakk>memb x S; I S\\<rbrakk>\n        \\<Longrightarrow> I (dfs S xs) \\<and> invariant (dfs S xs);\n        \\<lbrakk>\\<not> memb x S; I (ins x S)\\<rbrakk>\n        \\<Longrightarrow> I (dfs (ins x S) (succs x @ xs)) \\<and>\n                          invariant (dfs (ins x S) (succs x @ xs));\n        I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S (x # xs)) \\<and>\n                         invariant (dfs S (x # xs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "proof (cases \"memb x S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n 2. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "case False"], ["proof (state)\nthis:\n  \\<not> memb x S\n\ngoal (2 subgoals):\n 1. memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n 2. \\<not> memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "then"], ["proof (chain)\npicking this:\n  \\<not> memb x S", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> memb x S\n\ngoal (1 subgoal):\n 1. I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow>\n    I (dfs (ins x S) (succs x @ xs)) \\<and>\n    invariant (dfs (ins x S) (succs x @ xs))", "apply (rule step)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> memb x S \\<Longrightarrow> \\<not> memb x S\n 2. \\<not> memb x S \\<Longrightarrow> I (ins x S)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> memb x S \\<Longrightarrow> I (ins x S)", "apply (rule I)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<not> memb x S \\<Longrightarrow> \\<not> memb x S\n 2. \\<not> memb x S \\<Longrightarrow> isNode x\n 3. \\<not> memb x S \\<Longrightarrow> invariant S\n 4. \\<not> memb x S \\<Longrightarrow> I S", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<not> memb x S \\<Longrightarrow> isNode x\n 2. \\<not> memb x S \\<Longrightarrow> invariant S\n 3. \\<not> memb x S \\<Longrightarrow> I S", "apply (rule step)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n\ngoal (1 subgoal):\n 1. memb x S \\<Longrightarrow>\n    I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))", "qed (simp add: step)"], ["proof (state)\nthis:\n  I (dfs S (x # xs)) \\<and> invariant (dfs S (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>invariant S; I S\\<rbrakk>\n       \\<Longrightarrow> I (dfs S []) \\<and> invariant (dfs S [])", "qed simp"], ["proof (state)\nthis:\n  I (dfs S xs) \\<and> invariant (dfs S xs)\n\ngoal (1 subgoal):\n 1. I (dfs S xs)", "then"], ["proof (chain)\npicking this:\n  I (dfs S xs) \\<and> invariant (dfs S xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  I (dfs S xs) \\<and> invariant (dfs S xs)\n\ngoal (1 subgoal):\n 1. I (dfs S xs)", ".."], ["proof (state)\nthis:\n  I (dfs S xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context DFS *)\n(*>*)"], ["", "text\\<open>\n\nSecondly, that if an invariant holds on the initial object then it\nholds on the final one:\n\n\\<close>"], ["", "theorem (in DFS) dfs_invariant:\n  assumes \"invariant S\"\n  assumes \"list_all isNode xs\"\n  shows \"invariant (dfs S xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (dfs S xs)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invariant (dfs S xs)", "using assms"], ["proof (prove)\nusing this:\n  invariant S\n  list_all isNode xs\n\ngoal (1 subgoal):\n 1. invariant (dfs S xs)", "by (induct S xs rule: dfs_induct) auto"], ["", "(*>*)"], ["", "text\\<open>\n\n\\FloatBarrier\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}