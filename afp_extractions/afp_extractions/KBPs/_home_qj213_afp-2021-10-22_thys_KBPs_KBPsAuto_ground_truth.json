{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/KBPsAuto.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma jpTraces_init_inv[dest]:\n  \"tInit s \\<in> jpTraces jp \\<Longrightarrow> s \\<in> set envInit\"", "lemma jpTraces_step_inv[dest]:\n  \"t \\<leadsto> s \\<in> jpTraces jp\n    \\<Longrightarrow> t \\<in> jpTraces jp\n     \\<and> (\\<exists>eact \\<in> set (envAction (tLast t)).\n        (\\<exists>aact. (\\<forall>a. aact a \\<in> set (actJP jp t a))\n          \\<and> s = envTrans eact aact (tLast t)))\"", "lemma jpTraces_init_length_inv:\n  \"t \\<in> jpTraces jp \\<Longrightarrow> (tLength t = 0) \\<longleftrightarrow> (\\<exists>s. s \\<in> set envInit \\<and> t = tInit s)\"", "lemma jpTraces_step_length_inv_aux:\n  \"t \\<in> { t \\<in> jpTraces jp . tLength t = Suc n }\n    \\<Longrightarrow> \\<exists>t' s. t = t' \\<leadsto> s\n            \\<and> t' \\<in> jpTraces jp\n            \\<and> tLength t' = n\n            \\<and> (\\<exists>eact \\<in> set (envAction (tLast t')).\n               (\\<exists>aact. (\\<forall>a. aact a \\<in> set (actJP jp t' a))\n                 \\<and> s = envTrans eact aact (tLast t')))\"", "lemma jpTraces_step_length_inv:\n  \"{ t \\<in> jpTraces jp . tLength t = Suc n }\n = { t \\<leadsto> s |eact aact t s. t \\<in> { t \\<in> jpTraces jp . tLength t = n }\n              \\<and> eact \\<in> set (envAction (tLast t))\n              \\<and> (\\<forall>a. aact a \\<in> set (actJP jp t a))\n              \\<and> s = envTrans eact aact (tLast t) }\"", "lemma implementsI[intro]:\n  \"(\\<And>t. t \\<in> jkbpC \\<Longrightarrow> set \\<circ> actJP jp t = set \\<circ> jAction MC t)\n  \\<Longrightarrow> implements jp\"", "lemma implementsE[elim]:\n  assumes impl: \"implements jp\"\n      and tC: \"t \\<in> jkbpC\"\n     shows \"set \\<circ> actJP jp t = set \\<circ> jAction MC t\"", "lemma implements_actJP_jAction:\n   assumes impl: \"implements jp\"\n       and tCn: \"t \\<in> jkbpCn n\"\n  shows \"set (actJP jp t a) = set (jAction (MCn n) t a)\" (is \"?lhs = ?rhs\")", "lemma implements_represents:\n  assumes impl: \"implements jp\"\n  shows \"represents (jpTraces jp)\"", "lemma implements_ind_jkbpC:\n  assumes acts: \"\\<And>a n t.\n                  \\<lbrakk> {t \\<in> jpTraces jp. tLength t = n} = jkbpCn n; t \\<in> jkbpCn n \\<rbrakk>\n                  \\<Longrightarrow> actJP jp t a = jAction MC t a\"\n  shows \"implements jp\"", "lemma behaviourally_equivI[intro]:\n  \"(\\<And>t. t \\<in> jkbpC \\<Longrightarrow> set \\<circ> actJP jp t = set \\<circ> actJP jp' t)\n    \\<Longrightarrow> behaviourally_equiv jp jp'\"", "lemma behaviourally_equiv_implements:\n  assumes \"behaviourally_equiv jp jp'\"\n  shows \"implements jp \\<longleftrightarrow> implements jp'\"", "lemma mkAutoEC_ec:\n  assumes \"t \\<in> jkbpC\"\n  shows \"runJP mkAutoEC t a = { t' \\<in> jkbpC . jview a t' = jview a t }\"", "lemma mkAutoEC_implements: \"implements mkAutoEC\"", "lemma jkbpCSn_jkbpCS_subset:\n  \"jkbpCSn n \\<subseteq> jkbpCS\"", "lemma sim_submodel_aux:\n  assumes s: \"s \\<in> worlds (MCSn n)\"\n  shows \"gen_model MCS s = gen_model (MCSn n) s\"", "lemma jkbpC_jkbpCSn_jAction_eq:\n  assumes tCn: \"t \\<in> jkbpCn n\"\n  shows \"jAction MC t = jAction (MCSn n) (simf t)\"\n(*<*) (is \"?lhs = ?rhs\")", "lemma jAction_simAbs_cong:\n  assumes tC: \"t \\<in> jkbpC\"\n      and ec: \"simAbs ec = sim_equiv_class a t\"\n      and ec': \"simAbs ec = simAbs ec'\"\n  shows \"set (simAction a ec) = set (simAction a ec')\"", "lemma simTrans_simAbs_cong:\n  assumes tC: \"t \\<in> jkbpC\"\n      and ec: \"simAbs ec = sim_equiv_class a t\"\n      and ec': \"simAbs ec = simAbs ec'\"\n  shows \"simAbs ` set (simTrans a ec) = simAbs ` set (simTrans a ec')\"", "lemma mkAutoSim_simps[simp]:\n  \"pInit (mkAutoSim a) = simInit a\"\n  \"pTrans (mkAutoSim a) = (\\<lambda>obs ec. (SOME ec'. ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs))\"\n  \"pAct (mkAutoSim a) = simAction a\"", "lemma (in AlgSimIncrEnvironment) mkAutoSim_ec:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\"", "theorem (in AlgSimIncrEnvironment) mkAutoSim_implements:\n  \"implements mkAutoSim\""], "translations": [["", "lemma jpTraces_init_inv[dest]:\n  \"tInit s \\<in> jpTraces jp \\<Longrightarrow> s \\<in> set envInit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tInit s \\<in> jpTraces jp \\<Longrightarrow> s \\<in> set envInit", "by (cases rule: jpTraces.cases) auto"], ["", "lemma jpTraces_step_inv[dest]:\n  \"t \\<leadsto> s \\<in> jpTraces jp\n    \\<Longrightarrow> t \\<in> jpTraces jp\n     \\<and> (\\<exists>eact \\<in> set (envAction (tLast t)).\n        (\\<exists>aact. (\\<forall>a. aact a \\<in> set (actJP jp t a))\n          \\<and> s = envTrans eact aact (tLast t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<leadsto> s \\<in> jpTraces jp \\<Longrightarrow>\n    t \\<in> jpTraces jp \\<and>\n    (\\<exists>eact\\<in>set (envAction (tLast t)).\n        \\<exists>aact.\n           (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n           s = envTrans eact aact (tLast t))", "by (cases rule: jpTraces.cases) auto"], ["", "lemma jpTraces_init_length_inv:\n  \"t \\<in> jpTraces jp \\<Longrightarrow> (tLength t = 0) \\<longleftrightarrow> (\\<exists>s. s \\<in> set envInit \\<and> t = tInit s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jpTraces jp \\<Longrightarrow>\n    (tLength t = 0) = (\\<exists>s. s \\<in> set envInit \\<and> t = tInit s)", "by (induct t) (auto elim: jpTraces.cases)"], ["", "lemma jpTraces_step_length_inv_aux:\n  \"t \\<in> { t \\<in> jpTraces jp . tLength t = Suc n }\n    \\<Longrightarrow> \\<exists>t' s. t = t' \\<leadsto> s\n            \\<and> t' \\<in> jpTraces jp\n            \\<and> tLength t' = n\n            \\<and> (\\<exists>eact \\<in> set (envAction (tLast t')).\n               (\\<exists>aact. (\\<forall>a. aact a \\<in> set (actJP jp t' a))\n                 \\<and> s = envTrans eact aact (tLast t')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> {t \\<in> jpTraces jp. tLength t = Suc n} \\<Longrightarrow>\n    \\<exists>t' s.\n       t = t' \\<leadsto> s \\<and>\n       t' \\<in> jpTraces jp \\<and>\n       tLength t' = n \\<and>\n       (\\<exists>eact\\<in>set (envAction (tLast t')).\n           \\<exists>aact.\n              (\\<forall>a. aact a \\<in> set (actJP jp t' a)) \\<and>\n              s = envTrans eact aact (tLast t'))", "by (induct t arbitrary: n) auto"], ["", "lemma jpTraces_step_length_inv:\n  \"{ t \\<in> jpTraces jp . tLength t = Suc n }\n = { t \\<leadsto> s |eact aact t s. t \\<in> { t \\<in> jpTraces jp . tLength t = n }\n              \\<and> eact \\<in> set (envAction (tLast t))\n              \\<and> (\\<forall>a. aact a \\<in> set (actJP jp t a))\n              \\<and> s = envTrans eact aact (tLast t) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> {t \\<in> jpTraces jp. tLength t = n} \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)}", "apply (rule set_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {t \\<in> jpTraces jp. tLength t = Suc n}) =\n       (x \\<in> {uu_.\n                 \\<exists>eact aact t s.\n                    uu_ = t \\<leadsto> s \\<and>\n                    t \\<in> {t \\<in> jpTraces jp. tLength t = n} \\<and>\n                    eact \\<in> set (envAction (tLast t)) \\<and>\n                    (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n                    s = envTrans eact aact (tLast t)})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {t \\<in> jpTraces jp. tLength t = Suc n} \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>eact aact t s.\n                   uu_ = t \\<leadsto> s \\<and>\n                   t \\<in> {t \\<in> jpTraces jp. tLength t = n} \\<and>\n                   eact \\<in> set (envAction (tLast t)) \\<and>\n                   (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n                   s = envTrans eact aact (tLast t)}\n 2. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>eact aact t s.\n                   uu_ = t \\<leadsto> s \\<and>\n                   t \\<in> {t \\<in> jpTraces jp. tLength t = n} \\<and>\n                   eact \\<in> set (envAction (tLast t)) \\<and>\n                   (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n                   s = envTrans eact aact (tLast t)} \\<Longrightarrow>\n       x \\<in> {t \\<in> jpTraces jp. tLength t = Suc n}", "apply (drule jpTraces_step_length_inv_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>t' s.\n          x = t' \\<leadsto> s \\<and>\n          t' \\<in> jpTraces jp \\<and>\n          tLength t' = n \\<and>\n          (\\<exists>eact\\<in>set (envAction (tLast t')).\n              \\<exists>aact.\n                 (\\<forall>a. aact a \\<in> set (actJP jp t' a)) \\<and>\n                 s = envTrans eact aact (tLast t')) \\<Longrightarrow>\n       x \\<in> {uu_.\n                \\<exists>eact aact t s.\n                   uu_ = t \\<leadsto> s \\<and>\n                   t \\<in> {t \\<in> jpTraces jp. tLength t = n} \\<and>\n                   eact \\<in> set (envAction (tLast t)) \\<and>\n                   (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n                   s = envTrans eact aact (tLast t)}\n 2. \\<And>x.\n       x \\<in> {uu_.\n                \\<exists>eact aact t s.\n                   uu_ = t \\<leadsto> s \\<and>\n                   t \\<in> {t \\<in> jpTraces jp. tLength t = n} \\<and>\n                   eact \\<in> set (envAction (tLast t)) \\<and>\n                   (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n                   s = envTrans eact aact (tLast t)} \\<Longrightarrow>\n       x \\<in> {t \\<in> jpTraces jp. tLength t = Suc n}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "end"], ["", "(* context IncrEnvironment *)"], ["", "subsection\\<open>The Implementation Relation\\<close>"], ["", "text\\<open>\n\n\\label{sec:kbps-implementation}\n\nWith this machinery in hand, we now relate automata with JKBPs. We say\na joint protocol @{term \"jp\"} \\emph{implements} a JKBP when they\nperform the same actions on the canonical of traces. Note that the\nbehaviour of @{term \"jp\"} on other traces is arbitrary.\n\n\\<close>"], ["", "context IncrEnvironment\nbegin"], ["", "definition\n  implements :: \"('a, 'obs, 'aAct, 'ps) JointProtocol \\<Rightarrow> bool\"\nwhere\n  \"implements jp \\<equiv> (\\<forall>t \\<in> jkbpC. set \\<circ> actJP jp t = set \\<circ> jAction MC t)\""], ["", "text\\<open>\n\nClearly there are environments where the canonical trace set @{term\n\"jkbpC\"} can be generated by actions that differ from those prescribed\nby the JKBP. We can show that the \\emph{implements} relation is a\nstronger requirement than the mere trace-inclusion required by the\n\\emph{represents} relation of \\S\\ref{sec:kbps-canonical-kripke}.\n\n\\<close>"], ["", "(*<*)"], ["", "lemma implementsI[intro]:\n  \"(\\<And>t. t \\<in> jkbpC \\<Longrightarrow> set \\<circ> actJP jp t = set \\<circ> jAction MC t)\n  \\<Longrightarrow> implements jp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> jkbpC \\<Longrightarrow>\n        set \\<circ> actJP jp t = set \\<circ> jAction MC t) \\<Longrightarrow>\n    implements jp", "unfolding implements_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> jkbpC \\<Longrightarrow>\n        set \\<circ> actJP jp t = set \\<circ> jAction MC t) \\<Longrightarrow>\n    \\<forall>t\\<in>jkbpC. set \\<circ> actJP jp t = set \\<circ> jAction MC t", "by simp"], ["", "lemma implementsE[elim]:\n  assumes impl: \"implements jp\"\n      and tC: \"t \\<in> jkbpC\"\n     shows \"set \\<circ> actJP jp t = set \\<circ> jAction MC t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<circ> actJP jp t = set \\<circ> jAction MC t", "using assms"], ["proof (prove)\nusing this:\n  implements jp\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. set \\<circ> actJP jp t = set \\<circ> jAction MC t", "unfolding implements_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>jkbpC. set \\<circ> actJP jp t = set \\<circ> jAction MC t\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. set \\<circ> actJP jp t = set \\<circ> jAction MC t", "by simp"], ["", "lemma implements_actJP_jAction:\n   assumes impl: \"implements jp\"\n       and tCn: \"t \\<in> jkbpCn n\"\n  shows \"set (actJP jp t a) = set (jAction (MCn n) t a)\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "from tCn"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>", "have tC: \"t \\<in> jkbpC\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. t \\<in> jkbpC", "by blast"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "hence \"?lhs = (set \\<circ> jAction MC t) a\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = (set \\<circ> jAction MC t) a", "using implementsE[OF impl, symmetric]"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  ?t \\<in> jkbpC \\<Longrightarrow>\n  set \\<circ> jAction MC ?t = set \\<circ> actJP jp ?t\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = (set \\<circ> jAction MC t) a", "by auto"], ["proof (state)\nthis:\n  set (actJP jp t a) = (set \\<circ> jAction MC t) a\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "also"], ["proof (state)\nthis:\n  set (actJP jp t a) = (set \\<circ> jAction MC t) a\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "have \"... = set (jAction (MCn n) t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (set \\<circ> jAction MC t) a = set (jAction MC\\<^bsub>n\\<^esub> t a)", "by (simp add: jkbpC_jkbpCn_jAction_eq[OF tCn])"], ["proof (state)\nthis:\n  (set \\<circ> jAction MC t) a = set (jAction MC\\<^bsub>n\\<^esub> t a)\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "finally"], ["proof (chain)\npicking this:\n  set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "show ?thesis"], ["proof (prove)\nusing this:\n  set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)\n\ngoal (1 subgoal):\n 1. set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)", "."], ["proof (state)\nthis:\n  set (actJP jp t a) = set (jAction MC\\<^bsub>n\\<^esub> t a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "lemma implements_represents:\n  assumes impl: \"implements jp\"\n  shows \"represents (jpTraces jp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "have \"{ t \\<in> jpTraces jp . tLength t = n }\n        = { t \\<in> jkbpC . tLength t = n }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}", "by (auto dest: jpTraces_init_length_inv iff: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "case (Suc n)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "hence indhyp: \"{t \\<in> jpTraces jp . tLength t = n} = jkbpCn n\""], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>", "by (simp add: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "have \"{t \\<in> jpTraces jp. tLength t = Suc n}\n          = {t \\<leadsto> s |eact aact t s. t \\<in> jkbpCn n\n                      \\<and> eact \\<in> set (envAction (tLast t))\n                      \\<and> (\\<forall>a. aact a \\<in> set (actJP jp t a))\n                      \\<and> s = envTrans eact aact (tLast t) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)}", "using indhyp"], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)}", "by (simp add: jpTraces_step_length_inv)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = Suc n} =\n  {uu_.\n   \\<exists>eact aact t s.\n      uu_ = t \\<leadsto> s \\<and>\n      t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n      eact \\<in> set (envAction (tLast t)) \\<and>\n      (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n      s = envTrans eact aact (tLast t)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "also"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = Suc n} =\n  {uu_.\n   \\<exists>eact aact t s.\n      uu_ = t \\<leadsto> s \\<and>\n      t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n      eact \\<in> set (envAction (tLast t)) \\<and>\n      (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n      s = envTrans eact aact (tLast t)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "have \"... = jkbpCn (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)} =\n    jkbpC\\<^bsub>Suc n\\<^esub>", "apply (auto iff: Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>eact aact t.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a. aact a \\<in> set (actJP jp t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a))\n 2. \\<And>t eact aact.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a.\n           aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a. aacta a \\<in> set (actJP jp t a))", "apply (auto iff: implements_actJP_jAction[OF impl, symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>eact aact t s.\n      uu_ = t \\<leadsto> s \\<and>\n      t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n      eact \\<in> set (envAction (tLast t)) \\<and>\n      (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n      s = envTrans eact aact (tLast t)} =\n  jkbpC\\<^bsub>Suc n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "finally"], ["proof (chain)\npicking this:\n  {t \\<in> jpTraces jp. tLength t = Suc n} = jkbpC\\<^bsub>Suc n\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = Suc n} = jkbpC\\<^bsub>Suc n\\<^esub>\n\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {t \\<in> jkbpC. tLength t = Suc n}", "by (auto iff: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = Suc n} =\n  {t \\<in> jkbpC. tLength t = Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "}"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = ?n12} =\n  {t \\<in> jkbpC. tLength t = ?n12}\n\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "hence R: \"jpTraces jp = jkbpC\""], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = ?n12} =\n  {t \\<in> jkbpC. tLength t = ?n12}\n\ngoal (1 subgoal):\n 1. jpTraces jp = jkbpC", "by auto"], ["proof (state)\nthis:\n  jpTraces jp = jkbpC\n\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "from R jkbpC_represents"], ["proof (chain)\npicking this:\n  jpTraces jp = jkbpC\n  represents jkbpC", "show \"represents (jpTraces jp)\""], ["proof (prove)\nusing this:\n  jpTraces jp = jkbpC\n  represents jkbpC\n\ngoal (1 subgoal):\n 1. represents (jpTraces jp)", "by simp"], ["proof (state)\nthis:\n  represents (jpTraces jp)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma implements_ind_jkbpC:\n  assumes acts: \"\\<And>a n t.\n                  \\<lbrakk> {t \\<in> jpTraces jp. tLength t = n} = jkbpCn n; t \\<in> jkbpCn n \\<rbrakk>\n                  \\<Longrightarrow> actJP jp t a = jAction MC t a\"\n  shows \"implements jp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements jp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. implements jp", "let ?T = \"jpTraces jp\""], ["proof (state)\ngoal (1 subgoal):\n 1. implements jp", "from acts"], ["proof (chain)\npicking this:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 ?a10 = jAction MC ?t10 ?a10", "have acts':\n      \"\\<And>n t. \\<lbrakk> {t \\<in> jpTraces jp. tLength t = n} = jkbpCn n; t \\<in> jkbpCn n \\<rbrakk>\n          \\<Longrightarrow> actJP jp t = jAction (MCn n) t\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 ?a10 = jAction MC ?t10 ?a10\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> actJP jp t = jAction MC\\<^bsub>n\\<^esub> t", "by (simp only: jkbpC_jkbpCn_jAction_eq)"], ["proof (state)\nthis:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 = jAction MC\\<^bsub>?n10\\<^esub> ?t10\n\ngoal (1 subgoal):\n 1. implements jp", "from acts"], ["proof (chain)\npicking this:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 ?a10 = jAction MC ?t10 ?a10", "have acts':\n      \"\\<And>n t. \\<lbrakk> {t \\<in> jpTraces jp. tLength t = n} = jkbpCn n; t \\<in> jkbpCn n \\<rbrakk>\n          \\<Longrightarrow> actJP jp t = jAction (MCn n) t\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 ?a10 = jAction MC ?t10 ?a10\n\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> actJP jp t = jAction MC\\<^bsub>n\\<^esub> t", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        \\<And>n t a.\n           \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                    jkbpC\\<^bsub>n\\<^esub>;\n            t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> actJP jp t a = jAction MC t a\\<rbrakk>\n       \\<Longrightarrow> actJP jp t = jAction MC\\<^bsub>n\\<^esub> t", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n t a.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        \\<And>n t a.\n           \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                    jkbpC\\<^bsub>n\\<^esub>;\n            t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> actJP jp t a = jAction MC t a\\<rbrakk>\n       \\<Longrightarrow> actJP jp t a = jAction MC\\<^bsub>n\\<^esub> t a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n t a.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        \\<And>n t a.\n           \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                    jkbpC\\<^bsub>n\\<^esub>;\n            t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> actJP jp t a = jAction MC t a\\<rbrakk>\n       \\<Longrightarrow> jAction MC t a = jAction MC\\<^bsub>n\\<^esub> t a", "using jkbpC_jkbpCn_jAction_eq"], ["proof (prove)\nusing this:\n  ?t \\<in> jkbpC\\<^bsub>?n\\<^esub> \\<Longrightarrow>\n  jAction MC ?t = jAction MC\\<^bsub>?n\\<^esub> ?t\n\ngoal (1 subgoal):\n 1. \\<And>n t a.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        \\<And>n t a.\n           \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                    jkbpC\\<^bsub>n\\<^esub>;\n            t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n           \\<Longrightarrow> actJP jp t a = jAction MC t a\\<rbrakk>\n       \\<Longrightarrow> jAction MC t a = jAction MC\\<^bsub>n\\<^esub> t a", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 = jAction MC\\<^bsub>?n10\\<^esub> ?t10\n\ngoal (1 subgoal):\n 1. implements jp", "{"], ["proof (state)\nthis:\n  \\<lbrakk>{t \\<in> jpTraces jp. tLength t = ?n10} =\n           jkbpC\\<^bsub>?n10\\<^esub>;\n   ?t10 \\<in> jkbpC\\<^bsub>?n10\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> actJP jp ?t10 = jAction MC\\<^bsub>?n10\\<^esub> ?t10\n\ngoal (1 subgoal):\n 1. implements jp", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. implements jp", "have \"{ t \\<in> ?T . tLength t = n } = { t \\<in> jkbpC . tLength t = n }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}", "by (auto dest: jpTraces_init_length_inv iff: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "case (Suc n)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "hence indhyp: \"{t \\<in> ?T. tLength t = n} = jkbpCn n\""], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>", "by (simp add: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "have \"{t \\<in> jpTraces jp. tLength t = Suc n}\n          = {t \\<leadsto> s |eact aact t s. t \\<in> jkbpCn n\n                      \\<and> eact \\<in> set (envAction (tLast t))\n                      \\<and> (\\<forall>a. aact a \\<in> set (actJP jp t a))\n                      \\<and> s = envTrans eact aact (tLast t) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)}", "using indhyp"], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)}", "by (simp add: jpTraces_step_length_inv)"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = Suc n} =\n  {uu_.\n   \\<exists>eact aact t s.\n      uu_ = t \\<leadsto> s \\<and>\n      t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n      eact \\<in> set (envAction (tLast t)) \\<and>\n      (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n      s = envTrans eact aact (tLast t)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "also"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = Suc n} =\n  {uu_.\n   \\<exists>eact aact t s.\n      uu_ = t \\<leadsto> s \\<and>\n      t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n      eact \\<in> set (envAction (tLast t)) \\<and>\n      (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n      s = envTrans eact aact (tLast t)}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "have \"... = jkbpCn (Suc n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>eact aact t s.\n        uu_ = t \\<leadsto> s \\<and>\n        t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n        eact \\<in> set (envAction (tLast t)) \\<and>\n        (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n        s = envTrans eact aact (tLast t)} =\n    jkbpC\\<^bsub>Suc n\\<^esub>", "apply (auto iff: Let_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>eact aact t.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a. aact a \\<in> set (actJP jp t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a))\n 2. \\<And>t eact aact.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a.\n           aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a. aacta a \\<in> set (actJP jp t a))", "apply (drule acts'[OF indhyp, symmetric])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>eact aact t.\n       \\<lbrakk>eact \\<in> set (envAction (tLast t));\n        \\<forall>a. aact a \\<in> set (actJP jp t a);\n        jAction MC\\<^bsub>n\\<^esub> t = actJP jp t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a))\n 2. \\<And>t eact aact.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a.\n           aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a. aacta a \\<in> set (actJP jp t a))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t eact aact.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a.\n           aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a. aacta a \\<in> set (actJP jp t a))", "apply (drule acts'[OF indhyp, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t eact aact.\n       \\<lbrakk>eact \\<in> set (envAction (tLast t));\n        \\<forall>a. aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a);\n        jAction MC\\<^bsub>n\\<^esub> t = actJP jp t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a. aacta a \\<in> set (actJP jp t a))", "apply auto[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>eact aact t s.\n      uu_ = t \\<leadsto> s \\<and>\n      t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and>\n      eact \\<in> set (envAction (tLast t)) \\<and>\n      (\\<forall>a. aact a \\<in> set (actJP jp t a)) \\<and>\n      s = envTrans eact aact (tLast t)} =\n  jkbpC\\<^bsub>Suc n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> jpTraces jp. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> jpTraces jp. tLength t = Suc n} =\n       {t \\<in> jkbpC. tLength t = Suc n}", "finally"], ["proof (chain)\npicking this:\n  {t \\<in> jpTraces jp. tLength t = Suc n} = jkbpC\\<^bsub>Suc n\\<^esub>", "show ?case"], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = Suc n} = jkbpC\\<^bsub>Suc n\\<^esub>\n\ngoal (1 subgoal):\n 1. {t \\<in> jpTraces jp. tLength t = Suc n} =\n    {t \\<in> jkbpC. tLength t = Suc n}", "apply (auto iff: jkbpC_traces_of_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = Suc n} =\n  {t \\<in> jkbpC. tLength t = Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. implements jp", "hence \"\\<forall>t\\<in>jkbpCn n. actJP jp t = jAction (MCn n) t\""], ["proof (prove)\nusing this:\n  {t \\<in> jpTraces jp. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>jkbpC\\<^bsub>n\\<^esub>.\n       actJP jp t = jAction MC\\<^bsub>n\\<^esub> t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                {t \\<in> jkbpC. tLength t = n};\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> actJP jp t = jAction MC\\<^bsub>n\\<^esub> t", "apply (rule acts')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                {t \\<in> jkbpC. tLength t = n};\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> {t \\<in> jpTraces jp. tLength t = n} =\n                         jkbpC\\<^bsub>n\\<^esub>\n 2. \\<And>t.\n       \\<lbrakk>{t \\<in> jpTraces jp. tLength t = n} =\n                {t \\<in> jkbpC. tLength t = n};\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC\\<^bsub>n\\<^esub>", "apply (auto iff: jkbpC_traces_of_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>t\\<in>jkbpC\\<^bsub>n\\<^esub>.\n     actJP jp t = jAction MC\\<^bsub>n\\<^esub> t\n\ngoal (1 subgoal):\n 1. implements jp", "hence \"\\<forall>t\\<in>jkbpCn n. actJP jp t = jAction MC t\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>jkbpC\\<^bsub>n\\<^esub>.\n     actJP jp t = jAction MC\\<^bsub>n\\<^esub> t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>jkbpC\\<^bsub>n\\<^esub>. actJP jp t = jAction MC t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>t\\<in>jkbpC\\<^bsub>n\\<^esub>.\n                   actJP jp t = jAction MC\\<^bsub>n\\<^esub> t;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> jAction MC\\<^bsub>n\\<^esub> t = jAction MC t", "by ( rule sync_jview_jAction_eq[where n=\"n\"]\n         , auto iff: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>jkbpC\\<^bsub>n\\<^esub>. actJP jp t = jAction MC t\n\ngoal (1 subgoal):\n 1. implements jp", "}"], ["proof (state)\nthis:\n  \\<forall>t\\<in>jkbpC\\<^bsub>?n12\\<^esub>. actJP jp t = jAction MC t\n\ngoal (1 subgoal):\n 1. implements jp", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>jkbpC\\<^bsub>?n12\\<^esub>. actJP jp t = jAction MC t\n\ngoal (1 subgoal):\n 1. implements jp", "unfolding implements_def jkbpC_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>jkbpC\\<^bsub>?n12\\<^esub>.\n     actJP jp t = jAction (mkM (\\<Union> (range jkbpCn))) t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>\\<Union> (range jkbpCn).\n       set \\<circ> actJP jp t =\n       set \\<circ> jAction (mkM (\\<Union> (range jkbpCn))) t", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  implements jp\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nThe proof is by a straightfoward induction over the lengths of traces\ngenerated by the joint protocol.\n\nOur final piece of technical machinery allows us to refine automata\ndefinitions: we say that two joint protocols are \\emph{behaviourally\nequivalent} if the actions they propose coincide for each canonical\ntrace. The implementation relation is preserved by this relation.\n\n\\<close>"], ["", "definition\n  behaviourally_equiv :: \"('a, 'obs, 'aAct, 'ps) JointProtocol\n                        \\<Rightarrow> ('a, 'obs, 'aAct, 'ps') JointProtocol\n                        \\<Rightarrow> bool\"\nwhere\n  \"behaviourally_equiv jp jp' \\<equiv> \\<forall>t \\<in> jkbpC. set \\<circ> actJP jp t = set \\<circ> actJP jp' t\""], ["", "(*<*)"], ["", "lemma behaviourally_equivI[intro]:\n  \"(\\<And>t. t \\<in> jkbpC \\<Longrightarrow> set \\<circ> actJP jp t = set \\<circ> actJP jp' t)\n    \\<Longrightarrow> behaviourally_equiv jp jp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> jkbpC \\<Longrightarrow>\n        set \\<circ> actJP jp t = set \\<circ> actJP jp' t) \\<Longrightarrow>\n    behaviourally_equiv jp jp'", "unfolding behaviourally_equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        t \\<in> jkbpC \\<Longrightarrow>\n        set \\<circ> actJP jp t = set \\<circ> actJP jp' t) \\<Longrightarrow>\n    \\<forall>t\\<in>jkbpC. set \\<circ> actJP jp t = set \\<circ> actJP jp' t", "by simp"], ["", "(*>*)"], ["", "lemma behaviourally_equiv_implements:\n  assumes \"behaviourally_equiv jp jp'\"\n  shows \"implements jp \\<longleftrightarrow> implements jp'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements jp = implements jp'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. implements jp = implements jp'", "using assms"], ["proof (prove)\nusing this:\n  behaviourally_equiv jp jp'\n\ngoal (1 subgoal):\n 1. implements jp = implements jp'", "unfolding behaviourally_equiv_def implements_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>jkbpC. set \\<circ> actJP jp t = set \\<circ> actJP jp' t\n\ngoal (1 subgoal):\n 1. (\\<forall>t\\<in>jkbpC.\n        set \\<circ> actJP jp t = set \\<circ> jAction MC t) =\n    (\\<forall>t\\<in>jkbpC.\n        set \\<circ> actJP jp' t = set \\<circ> jAction MC t)", "by simp"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "end"], ["", "(* context IncrEnvironment *)\n\n(* **************************************** *)"], ["", "subsection\\<open>Automata using Equivalence Classes\\<close>"], ["", "text\\<open>\n\nWe now show that there is an implementation of every JKBP with respect\nto every incremental synchronous view. Intuitively the states of the\nautomaton for agent @{term \"a\"} represent the equivalence classes of\ntraces that @{term \"a\"} considers possible, and the transitions update\nthese sets according to her KBP.\n\n\\<close>"], ["", "context IncrEnvironment\nbegin"], ["", "definition\n  mkAutoEC :: \"('a, 'obs, 'aAct, 's Trace set) JointProtocol\"\nwhere\n  \"mkAutoEC \\<equiv> \\<lambda>a.\n     \\<lparr> pInit = \\<lambda>obs. { t \\<in> jkbpC . jviewInit a obs = jview a t },\n       pTrans = \\<lambda>obs ps. { t |t t'. t \\<in> jkbpC \\<and> t' \\<in> ps\n                                 \\<and> jview a t = jviewIncr a obs (jview a t') },\n       pAct = \\<lambda>ps. jAction MC (SOME t. t \\<in> ps) a \\<rparr>\""], ["", "text\\<open>\n\nThe function \\<open>SOME\\<close> is Hilbert's indefinite description\noperator @{term \"\\<epsilon>\"}, used here to choose an arbitrary trace from the\nprotocol state.\n\nThat this automaton maintains the correct equivalence class on a trace\n@{term \"t\"} follows from an easy induction over @{term \"t\"}.\n\n\\<close>"], ["", "lemma mkAutoEC_ec:\n  assumes \"t \\<in> jkbpC\"\n  shows \"runJP mkAutoEC t a = { t' \\<in> jkbpC . jview a t' = jview a t }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runJP mkAutoEC t a = {t' \\<in> jkbpC. jview a t' = jview a t}", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. runJP mkAutoEC t a = {t' \\<in> jkbpC. jview a t' = jview a t}", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. runJP mkAutoEC t a = {t' \\<in> jkbpC. jview a t' = jview a t}", "apply (induct t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       tInit x \\<in> jkbpC \\<Longrightarrow>\n       runJP mkAutoEC (tInit x) a =\n       {t' \\<in> jkbpC. jview a t' = jview a (tInit x)}\n 2. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                runJP mkAutoEC t a =\n                {t' \\<in> jkbpC. jview a t' = jview a t};\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> runJP mkAutoEC (t \\<leadsto> x2) a =\n                         {t' \\<in> jkbpC.\n                          jview a t' = jview a (t \\<leadsto> x2)}", "apply (auto simp add: mkAutoEC_def jviewInit)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                runJP mkAutoEC t a =\n                {t' \\<in> jkbpC. jview a t' = jview a t};\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> runJP mkAutoEC (t \\<leadsto> x2) a =\n                         {t' \\<in> jkbpC.\n                          jview a t' = jview a (t \\<leadsto> x2)}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                runJP mkAutoEC t a =\n                {t' \\<in> jkbpC. jview a t' = jview a t};\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> pTrans (mkAutoEC a) (envObs a x2)\n                          (runJP mkAutoEC t a) =\n                         {t' \\<in> jkbpC.\n                          jview a t' = jview a (t \\<leadsto> x2)}", "apply (subst mkAutoEC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                runJP mkAutoEC t a =\n                {t' \\<in> jkbpC. jview a t' = jview a t};\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> pTrans\n                          \\<lparr>pInit =\n                                    \\<lambda>obs.\n {t \\<in> jkbpC. jviewInit a obs = jview a t},\n                             pTrans =\n                               \\<lambda>obs ps.\n                                  {uu_.\n                                   \\<exists>t t'.\nuu_ = t \\<and>\nt \\<in> jkbpC \\<and>\nt' \\<in> ps \\<and> jview a t = jviewIncr a obs (jview a t')},\n                             pAct =\n                               \\<lambda>ps.\n                                  jAction MC (SOME t. t \\<in> ps) a\\<rparr>\n                          (envObs a x2) (runJP mkAutoEC t a) =\n                         {t' \\<in> jkbpC.\n                          jview a t' = jview a (t \\<leadsto> x2)}", "apply (auto iff: Let_def jviewIncr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can show that the construction yields an implementation by\nappealing to the previous lemma and showing that the @{term \"pAct\"}\nfunctions coincide.\n\n\\<close>"], ["", "lemma mkAutoEC_implements: \"implements mkAutoEC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements mkAutoEC", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. implements mkAutoEC", "apply (rule implements_ind_jkbpC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> actJP mkAutoEC t a = jAction MC t a", "apply (subst mkAutoEC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> pAct\n                          \\<lparr>pInit =\n                                    \\<lambda>obs.\n {t \\<in> jkbpC. jviewInit a obs = jview a t},\n                             pTrans =\n                               \\<lambda>obs ps.\n                                  {uu_.\n                                   \\<exists>t t'.\nuu_ = t \\<and>\nt \\<in> jkbpC \\<and>\nt' \\<in> ps \\<and> jview a t = jviewIncr a obs (jview a t')},\n                             pAct =\n                               \\<lambda>ps.\n                                  jAction MC (SOME t. t \\<in> ps) a\\<rparr>\n                          (runJP mkAutoEC t a) =\n                         jAction MC t a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> jAction MC (SOME ta. ta \\<in> runJP mkAutoEC t a)\n                          a =\n                         jAction MC t a", "apply (subgoal_tac \"t \\<in> jkbpC\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> jAction MC (SOME ta. ta \\<in> runJP mkAutoEC t a)\n                          a =\n                         jAction MC t a\n 2. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "using mkAutoEC_ec"], ["proof (prove)\nusing this:\n  ?t \\<in> jkbpC \\<Longrightarrow>\n  runJP mkAutoEC ?t ?a = {t' \\<in> jkbpC. jview ?a t' = jview ?a ?t}\n\ngoal (2 subgoals):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> jAction MC (SOME ta. ta \\<in> runJP mkAutoEC t a)\n                          a =\n                         jAction MC t a\n 2. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a =\n           {t' \\<in> jkbpC. jview a t' = jview a t}\\<rbrakk>\n       \\<Longrightarrow> jAction MC\n                          (SOME ta.\n                              ta \\<in> jkbpC \\<and> jview a ta = jview a t)\n                          a =\n                         jAction MC t a\n 2. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "apply (rule S5n_jAction_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a =\n           {t' \\<in> jkbpC. jview a t' = jview a t}\\<rbrakk>\n       \\<Longrightarrow> S5n MC\n 2. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a =\n           {t' \\<in> jkbpC. jview a t' = jview a t}\\<rbrakk>\n       \\<Longrightarrow> (SOME ta.\n                             ta \\<in> jkbpC \\<and> jview a ta = jview a t,\n                          t)\n                         \\<in> relations MC a\n 3. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a =\n           {t' \\<in> jkbpC. jview a t' = jview a t}\\<rbrakk>\n       \\<Longrightarrow> (SOME ta.\n                             ta \\<in> jkbpC \\<and> jview a ta = jview a t,\n                          t)\n                         \\<in> relations MC a\n 2. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "apply (rule_tac a=t in someI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a =\n           {t' \\<in> jkbpC. jview a t' = jview a t}\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC \\<and> jview a t = jview a t\n 2. \\<And>a n t x.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a = {t' \\<in> jkbpC. jview a t' = jview a t};\n        x \\<in> jkbpC \\<and> jview a x = jview a t\\<rbrakk>\n       \\<Longrightarrow> (x, t) \\<in> relations MC a\n 3. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a n t x.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a = {t' \\<in> jkbpC. jview a t' = jview a t};\n        x \\<in> jkbpC \\<and> jview a x = jview a t\\<rbrakk>\n       \\<Longrightarrow> (x, t) \\<in> relations MC a\n 2. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "unfolding mkM_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a n t x.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>; t \\<in> jkbpC;\n        \\<And>t a.\n           t \\<in> jkbpC \\<Longrightarrow>\n           runJP mkAutoEC t a = {t' \\<in> jkbpC. jview a t' = jview a t};\n        x \\<in> jkbpC \\<and> jview a x = jview a t\\<rbrakk>\n       \\<Longrightarrow> (x, t)\n                         \\<in> relations\n                                \\<lparr>worlds = jkbpC,\n                                   relations =\n                                     \\<lambda>a.\n  {(t, t'). {t, t'} \\<subseteq> jkbpC \\<and> jview a t = jview a t'},\n                                   valuation = envVal \\<circ> tLast\\<rparr>\n                                a\n 2. \\<And>n t.\n       \\<lbrakk>{t \\<in> jpTraces mkAutoEC. tLength t = n} =\n                jkbpC\\<^bsub>n\\<^esub>;\n        t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> t \\<in> jkbpC", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nThis definition leans on the canonical trace set jkbpC, and is indeed\neffective: we can enumerate all canonical traces and are sure to find\none that has the view we expect. Then it is sufficient to consider\nother traces of the same length due to synchrony.  We would need to do\nthis computation dynamically, as the automaton will (in general) have\nan infinite state space.\n\n\\<close>"], ["", "end"], ["", "(* context IncrEnvironment *)\n\n(* **************************************** *)"], ["", "subsection\\<open>Simulations\\<close>"], ["", "text\\<open>\n\\label{sec:kbps-theory-automata-env-sims}\n\nOur goal now is to reduce the space required by the automaton\nconstructed by @{term \"mkAutoEC\"} by \\emph{simulating} the equivalence\nclasses (\\S\\ref{sec:kripke-theory-simulations}).\n\nThe following locale captures the framework of \\citet{Ron:1996}:\n\n\\<close>"], ["", "locale SimIncrEnvironment =\n  IncrEnvironment jkbp envInit envAction envTrans envVal jview envObs\n                  jviewInit jviewIncr\n    for jkbp :: \"('a, 'p, 'aAct) JKBP\"\n\n    and envInit :: \"'s list\"\n    and envAction :: \"'s \\<Rightarrow> 'eAct list\"\n    and envTrans :: \"'eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's\"\n    and envVal :: \"'s \\<Rightarrow> 'p \\<Rightarrow> bool\"\n    and jview :: \"('a, 's, 'tv) JointView\"\n    and envObs :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'obs\"\n    and jviewInit :: \"('a, 'obs, 'tv) InitialIncrJointView\"\n    and jviewIncr :: \"('a, 'obs, 'tv) IncrJointView\"\n+ fixes simf :: \"'s Trace \\<Rightarrow> 'ss\"\n  fixes simRels :: \"'a \\<Rightarrow> 'ss Relation\"\n  fixes simVal :: \"'ss \\<Rightarrow> 'p \\<Rightarrow> bool\"\n  assumes simf: \"sim MC (mkKripke (simf ` jkbpC) simRels simVal) simf\""], ["", "context SimIncrEnvironment\nbegin"], ["", "text\\<open>\n\nNote that the back tick \\<open>`\\<close> is Isabelle/HOL's relational image\noperator. In context it says that @{term \"simf\"} must be a simulation\nfrom @{term \"jkbpC\"} to its image under @{term \"simf\"}.\n\nFirstly we lift our familiar canonical trace sets and Kripke\nstructures through the simulation.\n\n\\<close>"], ["", "abbreviation jkbpCSn :: \"nat \\<Rightarrow> 'ss set\"(*<*)(\"jkbpCS\\<^bsub>_\\<^esub>\")(*>*) where\n  \"jkbpCS\\<^bsub>n\\<^esub> \\<equiv> simf ` jkbpC\\<^bsub>n\\<^esub>\""], ["", "abbreviation jkbpCS :: \"'ss set\" where\n  \"jkbpCS \\<equiv> simf ` jkbpC\""], ["", "abbreviation MCSn :: \"nat \\<Rightarrow> ('a, 'p, 'ss) KripkeStructure\"(*<*)(\"MCS\\<^bsub>_\\<^esub>\")(*>*) where\n  \"MCS\\<^bsub>n\\<^esub> \\<equiv> mkKripke jkbpCS\\<^bsub>n\\<^esub> simRels simVal\""], ["", "abbreviation MCS :: \"('a, 'p, 'ss) KripkeStructure\" where\n  \"MCS \\<equiv> mkKripke jkbpCS simRels simVal\""], ["", "(*<*)"], ["", "lemma jkbpCSn_jkbpCS_subset:\n  \"jkbpCSn n \\<subseteq> jkbpCS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpCS\\<^bsub>n\\<^esub> \\<subseteq> jkbpCS", "by (rule image_mono[OF jkbpCn_jkbpC_subset])"], ["", "(*>*)"], ["", "text\\<open>\n\nWe will be often be concerned with the equivalence class of traces\ngenerated by agent @{term \"a\"}'s view:\n\n\\<close>"], ["", "abbreviation sim_equiv_class :: \"'a \\<Rightarrow> 's Trace \\<Rightarrow> 'ss set\" where\n  \"sim_equiv_class a t \\<equiv> simf ` { t' \\<in> jkbpC . jview a t' = jview a t }\""], ["", "abbreviation jkbpSEC :: \"'ss set set\" where\n  \"jkbpSEC \\<equiv> \\<Union>a. sim_equiv_class a ` jkbpC\""], ["", "text\\<open>\n\nWith some effort we can show that the temporal slice of the simulated\nstructure is adequate for determining the actions of the JKBP. The\nproof is tedious and routine, exploiting the sub-model property\n(\\S\\ref{sec:generated_models}).\n\n\\<close>"], ["", "(*<*)"], ["", "lemma sim_submodel_aux:\n  assumes s: \"s \\<in> worlds (MCSn n)\"\n  shows \"gen_model MCS s = gen_model (MCSn n) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_model MCS s = gen_model MCS\\<^bsub>n\\<^esub> s", "proof(rule gen_model_subset[where T=\"jkbpCSn n\"])"], ["proof (state)\ngoal (8 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. \\<And>a.\n       Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n       Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 6. s \\<in> worlds MCS\n 7. s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n 8. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from s"], ["proof (chain)\npicking this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>", "show \"s \\<in> worlds MCS\""], ["proof (prove)\nusing this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. s \\<in> worlds MCS", "by (simp add: subsetD[OF jkbpCSn_jkbpCS_subset])"], ["proof (state)\nthis:\n  s \\<in> worlds MCS\n\ngoal (7 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. \\<And>a.\n       Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n       Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 6. s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n 7. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from s"], ["proof (chain)\npicking this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>", "show \"s \\<in> worlds (MCSn n)\""], ["proof (prove)\nusing this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. s \\<in> worlds MCS\\<^bsub>n\\<^esub>", "by assumption"], ["proof (state)\nthis:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n\ngoal (6 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. \\<And>a.\n       Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n       Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 6. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. \\<And>a.\n       Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n       Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 6. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "fix a"], ["proof (state)\ngoal (6 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. \\<And>a.\n       Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n       Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 6. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "show \"relations MCS a \\<inter> jkbpCSn n \\<times> jkbpCSn n\n      = relations (MCSn n) a \\<inter> jkbpCSn n \\<times> jkbpCSn n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n    Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>", "by (simp add: Int_ac Int_absorb1\n                  relation_mono[OF jkbpCSn_jkbpCS_subset jkbpCSn_jkbpCS_subset])"], ["proof (state)\nthis:\n  Restr (relations MCS a) jkbpCS\\<^bsub>n\\<^esub> =\n  Restr (relations MCS\\<^bsub>n\\<^esub> a) jkbpCS\\<^bsub>n\\<^esub>\n\ngoal (5 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 5. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from s"], ["proof (chain)\npicking this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>", "show \"(\\<Union>a. relations (MCSn n) a)\\<^sup>* `` {s} \\<subseteq> jkbpCSn n\""], ["proof (prove)\nusing this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>", "apply (clarsimp simp del: mkKripke_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> worlds MCS\\<^bsub>n\\<^esub>;\n        (s, x)\n        \\<in> (\\<Union>\n                (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> jkbpCS\\<^bsub>n\\<^esub>", "apply (erule kripke_rels_trc_worlds)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       s \\<in> worlds MCS\\<^bsub>n\\<^esub> \\<Longrightarrow>\n       s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n 2. \\<And>x.\n       s \\<in> worlds MCS\\<^bsub>n\\<^esub> \\<Longrightarrow>\n       kripke MCS\\<^bsub>n\\<^esub>\n 3. \\<And>x.\n       s \\<in> worlds MCS\\<^bsub>n\\<^esub> \\<Longrightarrow>\n       jkbpCS\\<^bsub>n\\<^esub> = worlds MCS\\<^bsub>n\\<^esub>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<Union> (range (relations MCS\\<^bsub>n\\<^esub>)))\\<^sup>* `` {s}\n  \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from s"], ["proof (chain)\npicking this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>", "obtain t\n    where st: \"s = simf t\"\n      and tCn: \"t \\<in> jkbpCn n\""], ["proof (prove)\nusing this:\n  s \\<in> worlds MCS\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>s = simf t; t \\<in> jkbpC\\<^bsub>n\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  s = simf t\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from tCn"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>", "have tC: \"t \\<in> jkbpC\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. t \\<in> jkbpC", "by blast"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "{"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "fix t'"], ["proof (state)\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "assume tt': \"(t, t') \\<in> (\\<Union>a. relations MC a)\\<^sup>*\""], ["proof (state)\nthis:\n  (t, t') \\<in> (\\<Union> (range (relations MC)))\\<^sup>*\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from tC tt'"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC\n  (t, t') \\<in> (\\<Union> (range (relations MC)))\\<^sup>*", "have t'C: \"t' \\<in> jkbpC\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  (t, t') \\<in> (\\<Union> (range (relations MC)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. t' \\<in> jkbpC", "by - (erule kripke_rels_trc_worlds, simp_all)"], ["proof (state)\nthis:\n  t' \\<in> jkbpC\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from tCn tt'"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n  (t, t') \\<in> (\\<Union> (range (relations MC)))\\<^sup>*", "have t'Len: \"tLength t' = n\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n  (t, t') \\<in> (\\<Union> (range (relations MC)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. tLength t' = n", "by (auto dest: sync_tLength_eq_trc[where as=UNIV])"], ["proof (state)\nthis:\n  tLength t' = n\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "from t'C t'Len"], ["proof (chain)\npicking this:\n  t' \\<in> jkbpC\n  tLength t' = n", "have \"t' \\<in> jkbpCn n\""], ["proof (prove)\nusing this:\n  t' \\<in> jkbpC\n  tLength t' = n\n\ngoal (1 subgoal):\n 1. t' \\<in> jkbpC\\<^bsub>n\\<^esub>", "by - (erule jkbpC_tLength_inv)"], ["proof (state)\nthis:\n  t' \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "}"], ["proof (state)\nthis:\n  (t, ?t'13)\n  \\<in> (\\<Union> (range (relations MC)))\\<^sup>* \\<Longrightarrow>\n  ?t'13 \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "hence \"(\\<Union>a. relations MC a)\\<^sup>* `` {t} \\<subseteq> jkbpCn n\""], ["proof (prove)\nusing this:\n  (t, ?t'13)\n  \\<in> (\\<Union> (range (relations MC)))\\<^sup>* \\<Longrightarrow>\n  ?t'13 \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n    \\<subseteq> jkbpC\\<^bsub>n\\<^esub>", "by clarsimp"], ["proof (state)\nthis:\n  (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n  \\<subseteq> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "hence \"simf ` ((\\<Union>a. relations MC a)\\<^sup>* `` {t}) \\<subseteq> jkbpCSn n\""], ["proof (prove)\nusing this:\n  (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n  \\<subseteq> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. simf ` (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>", "by (rule image_mono)"], ["proof (state)\nthis:\n  simf ` (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n  \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n\ngoal (4 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n 4. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "with st tC"], ["proof (chain)\npicking this:\n  s = simf t\n  t \\<in> jkbpC\n  simf ` (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n  \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>", "show \"(\\<Union>a. relations MCS a)\\<^sup>* `` {s} \\<subseteq> jkbpCSn n\""], ["proof (prove)\nusing this:\n  s = simf t\n  t \\<in> jkbpC\n  simf ` (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n  \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>", "using sim_trc_commute[OF _ simf, where t=t]"], ["proof (prove)\nusing this:\n  s = simf t\n  t \\<in> jkbpC\n  simf ` (\\<Union> (range (relations MC)))\\<^sup>* `` {t}\n  \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n  \\<lbrakk>kripke MC; t \\<in> worlds MC\\<rbrakk>\n  \\<Longrightarrow> simf `\n                    (\\<Union> (range (relations MC)))\\<^sup>* `` {t} =\n                    (\\<Union> (range (relations MCS)))\\<^sup>* `` {simf t}\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n    \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>", "by simp"], ["proof (state)\nthis:\n  (\\<Union> (range (relations MCS)))\\<^sup>* `` {s}\n  \\<subseteq> jkbpCS\\<^bsub>n\\<^esub>\n\ngoal (3 subgoals):\n 1. kripke MCS\n 2. kripke MCS\\<^bsub>n\\<^esub>\n 3. valuation MCS = valuation MCS\\<^bsub>n\\<^esub>", "qed simp_all"], ["", "(*>*)"], ["", "lemma jkbpC_jkbpCSn_jAction_eq:\n  assumes tCn: \"t \\<in> jkbpCn n\"\n  shows \"jAction MC t = jAction (MCSn n) (simf t)\"\n(*<*) (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "have \"?lhs = jAction MCS (simf t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS (simf t)", "by (simp add: simulation_jAction_eq simf jkbpCn_jkbpC_inc[OF tCn])"], ["proof (state)\nthis:\n  jAction MC t = jAction MCS (simf t)\n\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "also"], ["proof (state)\nthis:\n  jAction MC t = jAction MCS (simf t)\n\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "have \"... = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction MCS (simf t) = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "using tCn"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. jAction MCS (simf t) = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "by - ( rule gen_model_jAction_eq[OF sim_submodel_aux, where w=\"simf t\"]\n         , auto intro: gen_model_world_refl )"], ["proof (state)\nthis:\n  jAction MCS (simf t) = jAction MCS\\<^bsub>n\\<^esub> (simf t)\n\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "finally"], ["proof (chain)\npicking this:\n  jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "show ?thesis"], ["proof (prove)\nusing this:\n  jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)\n\ngoal (1 subgoal):\n 1. jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)", "."], ["proof (state)\nthis:\n  jAction MC t = jAction MCS\\<^bsub>n\\<^esub> (simf t)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "(* context SimIncrEnvironment *)"], ["", "text\\<open>\n\nIt can be shown that a suitable simulation into a finite structure is\nadequate to establish the existence of finite-state implementations\n\\citep[Theorem~2]{Ron:1996}: essentially we apply the simulation to\nthe states of @{term \"mkAutoEC\"}. However this result does not make it\nclear how the transition function can be incrementally\nconstructed. One approach is to maintain @{term \"jkbpC\"} while\nextending the automaton, which is quite space inefficient.\n\nIntuitively we would like to compute the possible @{term\n\"sim_equiv_class\"} successors of a given @{term \"sim_equiv_class\"}\nwithout reference to @{term \"jkbpC\"}, and this should be possible as\nthe reachable simulated worlds must contain enough information to\ndifferentiate themselves from every other simulated world (reachable\nor not) that represents a trace that is observationally distinct to\ntheir own.\n\nThis leads us to asking for some extra functionality of our\nsimulation, which we do in the following section.\n\n\\<close>"], ["", "subsection\\<open>Automata using simulations\\<close>"], ["", "text_raw\\<open>\n\\label{sec:kbps-automata-synthesis-alg}\n\n\\begin{figure}[hp]\n\\begin{isabellebody}%\n\\<close>"], ["", "locale AlgSimIncrEnvironment =\n  SimIncrEnvironment jkbp envInit envAction envTrans envVal\n                     jview envObs jviewInit jviewIncr simf simRels simVal\n    for jkbp :: \"('a, 'p, 'aAct) JKBP\"\n    and envInit :: \"'s list\"\n    and envAction :: \"'s \\<Rightarrow> 'eAct list\"\n    and envTrans :: \"'eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's\"\n    and envVal :: \"'s \\<Rightarrow> 'p \\<Rightarrow> bool\"\n\n    and jview :: \"('a, 's, 'tv) JointView\"\n    and envObs :: \"'a \\<Rightarrow> 's \\<Rightarrow> 'obs\"\n    and jviewInit :: \"('a, 'obs, 'tv) InitialIncrJointView\"\n    and jviewIncr :: \"('a, 'obs, 'tv) IncrJointView\"\n\n    and simf :: \"'s Trace \\<Rightarrow> 'ss\"\n    and simRels :: \"'a \\<Rightarrow> 'ss Relation\"\n    and simVal :: \"'ss \\<Rightarrow> 'p \\<Rightarrow> bool\"\n\n+ fixes simAbs :: \"'rep \\<Rightarrow> 'ss set\"\n\n    and simObs :: \"'a \\<Rightarrow> 'rep \\<Rightarrow> 'obs\"\n    and simInit :: \"'a \\<Rightarrow> 'obs \\<Rightarrow> 'rep\"\n    and simTrans :: \"'a \\<Rightarrow> 'rep \\<Rightarrow> 'rep list\"\n    and simAction :: \"'a \\<Rightarrow> 'rep \\<Rightarrow> 'aAct list\"\n\n  assumes simInit:\n            \"\\<forall>a iobs. iobs \\<in> envObs a ` set envInit\n                   \\<longrightarrow> simAbs (simInit a iobs)\n                     = simf ` { t' \\<in> jkbpC. jview a t' = jviewInit a iobs }\"\n      and simObs:\n            \"\\<forall>a ec t. t \\<in> jkbpC \\<and> simAbs ec = sim_equiv_class a t\n                   \\<longrightarrow> simObs a ec = envObs a (tLast t)\"\n      and simAction:\n            \"\\<forall>a ec t. t \\<in> jkbpC \\<and> simAbs ec = sim_equiv_class a t\n                   \\<longrightarrow> set (simAction a ec) = set (jAction MC t a)\"\n      and simTrans:\n            \"\\<forall>a ec t. t \\<in> jkbpC \\<and> simAbs ec = sim_equiv_class a t\n                   \\<longrightarrow> simAbs ` set (simTrans a ec)\n                     = { sim_equiv_class a (t' \\<leadsto> s)\n                         |t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t }\""], ["", "text_raw\\<open>\n\\end{isabellebody}%\n\\begin{isamarkuptext}%\n\\caption{The \\<open>SimEnvironment\\<close> locale extends the @{term\n\"Environment\"} locale with simulation and algorithmic operations. The\nbacktick \\<open>`\\<close> is Isabelle/HOL's image-of-a-set-under-a-function\noperator.}\n\\label{fig:kbps-theory-auto-SimEnvironment}\n\\end{isamarkuptext}%\n\\end{figure}\n\\<close>"], ["", "text\\<open>\n\nThe locale in Figure~\\ref{fig:kbps-theory-auto-SimEnvironment} captures\nour extra requirements of a simulation.\n\nFirstly we relate the concrete representation @{typ \"'rep\"} of\nequivalence classes under simulation to differ from the abstract\nrepresentation @{typ \"'ss set\"} using the abstraction function @{term\n\"simAbs\"} \\citep{EdR:cup98}; there is no one-size-fits-all concrete\nrepresentation, as we will see.\n\nSecondly we ask for a function @{term \"simInit a iobs\"} that\nfaithfully generates a representation of the equivalence class of\nsimulated initial states that are possible for agent @{term \"a\"} given\nthe valid initial observation @{term \"iobs\"}.\n\nThirdly the @{term \"simObs\"} function allows us to partition the\nresults of @{term \"simTrans\"} according to the recurrent observation\nthat agent @{term \"a\"} makes of the equivalence class.\n\nFourthly, the function @{term \"simAction\"} computes a list of actions\nenabled by the JKBP on a state that concretely represents a canonical\nequivalence class.\n\nFinally we expect to compute the list of represented @{term\n\"sim_equiv_class\"} successors of a given @{term \"sim_equiv_class\"}\nusing @{term \"simTrans\"}.\n\nNote that these definitions are stated relative to the environment and\nthe JKBP, allowing us to treat specialised cases such as broadcast\n(\\S\\ref{sec:kbps-theory-spr-deterministic-protocols} and\n\\S\\ref{sec:kbps-theory-spr-non-deterministic-protocols}).\n\nWith these functions in hand, we can define our desired automaton:\n\n\\<close>"], ["", "definition (in AlgSimIncrEnvironment)\n  mkAutoSim :: \"('a, 'obs, 'aAct, 'rep) JointProtocol\"\nwhere\n  \"mkAutoSim \\<equiv> \\<lambda>a.\n     \\<lparr> pInit = simInit a,\n       pTrans = \\<lambda>obs ec. (SOME ec'. ec' \\<in> set (simTrans a ec)\n                                  \\<and> simObs a ec' = obs),\n       pAct = simAction a \\<rparr>\""], ["", "(*<*)"], ["", "context AlgSimIncrEnvironment\nbegin"], ["", "lemma jAction_simAbs_cong:\n  assumes tC: \"t \\<in> jkbpC\"\n      and ec: \"simAbs ec = sim_equiv_class a t\"\n      and ec': \"simAbs ec = simAbs ec'\"\n  shows \"set (simAction a ec) = set (simAction a ec')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (simAction a ec) = set (simAction a ec')", "using assms simAction[rule_format, where a=a and t=t] tC"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  simAbs ec = sim_equiv_class a t\n  simAbs ec = simAbs ec'\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  set (simAction a ?ec) = set (jAction MC t a)\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. set (simAction a ec) = set (simAction a ec')", "by simp"], ["", "lemma simTrans_simAbs_cong:\n  assumes tC: \"t \\<in> jkbpC\"\n      and ec: \"simAbs ec = sim_equiv_class a t\"\n      and ec': \"simAbs ec = simAbs ec'\"\n  shows \"simAbs ` set (simTrans a ec) = simAbs ` set (simTrans a ec')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs ` set (simTrans a ec) = simAbs ` set (simTrans a ec')", "using assms simTrans[rule_format, where a=a and t=t] tC"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  simAbs ec = sim_equiv_class a t\n  simAbs ec = simAbs ec'\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (simTrans a ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs ` set (simTrans a ec) = simAbs ` set (simTrans a ec')", "by simp"], ["", "lemma mkAutoSim_simps[simp]:\n  \"pInit (mkAutoSim a) = simInit a\"\n  \"pTrans (mkAutoSim a) = (\\<lambda>obs ec. (SOME ec'. ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs))\"\n  \"pAct (mkAutoSim a) = simAction a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pInit (mkAutoSim a) = simInit a &&&\n    pTrans (mkAutoSim a) =\n    (\\<lambda>obs ec.\n        SOME ec'.\n           ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs) &&&\n    pAct (mkAutoSim a) = simAction a", "unfolding mkAutoSim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pInit\n     \\<lparr>pInit = simInit a,\n        pTrans =\n          \\<lambda>obs ec.\n             SOME ec'.\n                ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs,\n        pAct = simAction a\\<rparr> =\n    simInit a &&&\n    pTrans\n     \\<lparr>pInit = simInit a,\n        pTrans =\n          \\<lambda>obs ec.\n             SOME ec'.\n                ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs,\n        pAct = simAction a\\<rparr> =\n    (\\<lambda>obs ec.\n        SOME ec'.\n           ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs) &&&\n    pAct\n     \\<lparr>pInit = simInit a,\n        pTrans =\n          \\<lambda>obs ec.\n             SOME ec'.\n                ec' \\<in> set (simTrans a ec) \\<and> simObs a ec' = obs,\n        pAct = simAction a\\<rparr> =\n    simAction a", "by simp_all"], ["", "end"], ["", "(* context AlgSimIncrEnvironment *)\n\n(*>*)"], ["", "text\\<open>\n\nThe automaton faithfully constructs the simulated equivalence class of\nthe given trace:\n\n\\<close>"], ["", "lemma (in AlgSimIncrEnvironment) mkAutoSim_ec:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP mkAutoSim t a) = sim_equiv_class a t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP mkAutoSim t a) = sim_equiv_class a t", "using tC"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP mkAutoSim t a) = sim_equiv_class a t", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       tInit x \\<in> jkbpC \\<Longrightarrow>\n       simAbs (runJP mkAutoSim (tInit x) a) = sim_equiv_class a (tInit x)\n 2. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "case (tInit s)"], ["proof (state)\nthis:\n  tInit s \\<in> jkbpC\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       tInit x \\<in> jkbpC \\<Longrightarrow>\n       simAbs (runJP mkAutoSim (tInit x) a) = sim_equiv_class a (tInit x)\n 2. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "thus ?case"], ["proof (prove)\nusing this:\n  tInit s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP mkAutoSim (tInit s) a) = sim_equiv_class a (tInit s)", "by (simp add: jviewInit[rule_format, symmetric] simInit)"], ["proof (state)\nthis:\n  simAbs (runJP mkAutoSim (tInit s) a) = sim_equiv_class a (tInit s)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "case (tStep t s)"], ["proof (state)\nthis:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "hence tC: \"t \\<in> jkbpC\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. t \\<in> jkbpC", "by blast"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "from tC tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC", "have F: \"simAbs ` set (simTrans a (runJP mkAutoSim t a))\n             = { sim_equiv_class a (t' \\<leadsto> s)\n                 |t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs ` set (simTrans a (runJP mkAutoSim t a)) =\n    {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n     t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "using simTrans[rule_format, where a=a and t=t and ec=\"runJP mkAutoSim t a\"]"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC \\<and>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (simTrans a (runJP mkAutoSim t a)) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. simAbs ` set (simTrans a (runJP mkAutoSim t a)) =\n    {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n     t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simAbs ` set (simTrans a (runJP mkAutoSim t a)) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "from tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC", "have G: \"sim_equiv_class a (t \\<leadsto> s)\n             \\<in> { sim_equiv_class a (t' \\<leadsto> s)\n                |t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. sim_equiv_class a (t \\<leadsto> s)\n    \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n           t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "by auto"], ["proof (state)\nthis:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "from F G"], ["proof (chain)\npicking this:\n  simAbs ` set (simTrans a (runJP mkAutoSim t a)) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "have H: \"sim_equiv_class a (t \\<leadsto> s) \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\""], ["proof (prove)\nusing this:\n  simAbs ` set (simTrans a (runJP mkAutoSim t a)) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. sim_equiv_class a (t \\<leadsto> s)\n    \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))", "by simp"], ["proof (state)\nthis:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "then"], ["proof (chain)\npicking this:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))", "obtain r\n        where R: \"r \\<in> set (simTrans a (runJP mkAutoSim t a))\"\n        and S: \"simAbs r = sim_equiv_class a (t \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>r \\<in> set (simTrans a (runJP mkAutoSim t a));\n         simAbs r = sim_equiv_class a (t \\<leadsto> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r \\<in> set (simTrans a (runJP mkAutoSim t a))\n  simAbs r = sim_equiv_class a (t \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP mkAutoSim t a) = sim_equiv_class a t;\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP mkAutoSim (t \\<leadsto> x2) a) =\n                         sim_equiv_class a (t \\<leadsto> x2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP mkAutoSim (t \\<leadsto> s) a) =\n    sim_equiv_class a (t \\<leadsto> s)", "proof(simp, rule someI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?a \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n    simObs a ?a = envObs a s\n 2. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "from R S tStep tC"], ["proof (chain)\npicking this:\n  r \\<in> set (simTrans a (runJP mkAutoSim t a))\n  simAbs r = sim_equiv_class a (t \\<leadsto> s)\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC", "show \"r \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and> simObs a r = envObs a s\""], ["proof (prove)\nusing this:\n  r \\<in> set (simTrans a (runJP mkAutoSim t a))\n  simAbs r = sim_equiv_class a (t \\<leadsto> s)\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. r \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n    simObs a r = envObs a s", "using simObs[rule_format, where t=\"t\\<leadsto>s\" and a=a]"], ["proof (prove)\nusing this:\n  r \\<in> set (simTrans a (runJP mkAutoSim t a))\n  simAbs r = sim_equiv_class a (t \\<leadsto> s)\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC\n  t \\<leadsto> s \\<in> jkbpC \\<and>\n  simAbs ?ec = sim_equiv_class a (t \\<leadsto> s) \\<Longrightarrow>\n  simObs a ?ec = envObs a (tLast (t \\<leadsto> s))\n\ngoal (1 subgoal):\n 1. r \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n    simObs a r = envObs a s", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n  simObs a r = envObs a s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "assume x: \"x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and> simObs a x = envObs a s\""], ["proof (state)\nthis:\n  x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n  simObs a x = envObs a s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n  simObs a x = envObs a s", "have A: \"simObs a x = envObs a s\""], ["proof (prove)\nusing this:\n  x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n  simObs a x = envObs a s\n\ngoal (1 subgoal):\n 1. simObs a x = envObs a s", "by simp"], ["proof (state)\nthis:\n  simObs a x = envObs a s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "from x"], ["proof (chain)\npicking this:\n  x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n  simObs a x = envObs a s", "have \"simAbs x \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\""], ["proof (prove)\nusing this:\n  x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n  simObs a x = envObs a s\n\ngoal (1 subgoal):\n 1. simAbs x \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))", "by simp"], ["proof (state)\nthis:\n  simAbs x \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "with tStep tC"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC\n  simAbs x \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))", "have \"simAbs x \\<in> { sim_equiv_class a (t' \\<leadsto> s)\n                         |t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC\n  simAbs x \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\n\ngoal (1 subgoal):\n 1. simAbs x\n    \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n           t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "using simTrans[rule_format, where a=a and t=t]"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP mkAutoSim t a) = sim_equiv_class a t\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC\n  simAbs x \\<in> simAbs ` set (simTrans a (runJP mkAutoSim t a))\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (simTrans a ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. simAbs x\n    \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n           t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "by simp"], ["proof (state)\nthis:\n  simAbs x\n  \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "then"], ["proof (chain)\npicking this:\n  simAbs x\n  \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}", "obtain t' s'\n      where X: \"simAbs x = sim_equiv_class a (t' \\<leadsto> s')\"\n          and Y: \"t' \\<leadsto> s' \\<in> jkbpC\"\n          and Z: \"jview a t' = jview a t\""], ["proof (prove)\nusing this:\n  simAbs x\n  \\<in> {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n\ngoal (1 subgoal):\n 1. (\\<And>t' s'.\n        \\<lbrakk>simAbs x = sim_equiv_class a (t' \\<leadsto> s');\n         t' \\<leadsto> s' \\<in> jkbpC; jview a t' = jview a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  simAbs x = sim_equiv_class a (t' \\<leadsto> s')\n  t' \\<leadsto> s' \\<in> jkbpC\n  jview a t' = jview a t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (simTrans a (runJP mkAutoSim t a)) \\<and>\n       simObs a x = envObs a s \\<Longrightarrow>\n       simAbs x = sim_equiv_class a (t \\<leadsto> s)", "from A X Y Z"], ["proof (chain)\npicking this:\n  simObs a x = envObs a s\n  simAbs x = sim_equiv_class a (t' \\<leadsto> s')\n  t' \\<leadsto> s' \\<in> jkbpC\n  jview a t' = jview a t", "show \"simAbs x = sim_equiv_class a (t \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  simObs a x = envObs a s\n  simAbs x = sim_equiv_class a (t' \\<leadsto> s')\n  t' \\<leadsto> s' \\<in> jkbpC\n  jview a t' = jview a t\n\ngoal (1 subgoal):\n 1. simAbs x = sim_equiv_class a (t \\<leadsto> s)", "using simObs[rule_format, where a=a and t=\"t'\\<leadsto>s'\", symmetric]"], ["proof (prove)\nusing this:\n  simObs a x = envObs a s\n  simAbs x = sim_equiv_class a (t' \\<leadsto> s')\n  t' \\<leadsto> s' \\<in> jkbpC\n  jview a t' = jview a t\n  t' \\<leadsto> s' \\<in> jkbpC \\<and>\n  simAbs ?ec = sim_equiv_class a (t' \\<leadsto> s') \\<Longrightarrow>\n  envObs a (tLast (t' \\<leadsto> s')) = simObs a ?ec\n\ngoal (1 subgoal):\n 1. simAbs x = sim_equiv_class a (t \\<leadsto> s)", "by (simp add: jviewIncr)"], ["proof (state)\nthis:\n  simAbs x = sim_equiv_class a (t \\<leadsto> s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  simAbs (runJP mkAutoSim (t \\<leadsto> s) a) =\n  sim_equiv_class a (t \\<leadsto> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nThis follows from a simple induction on @{term \"t\"}.\n\nThe following is a version of the Theorem 2 of \\citet{Ron:1996}.\n\n\\<close>"], ["", "theorem (in AlgSimIncrEnvironment) mkAutoSim_implements:\n  \"implements mkAutoSim\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements mkAutoSim", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. implements mkAutoSim", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> jkbpC \\<Longrightarrow>\n       set \\<circ> actJP mkAutoSim t = set \\<circ> jAction MC t", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t x.\n       t \\<in> jkbpC \\<Longrightarrow>\n       (set \\<circ> actJP mkAutoSim t) x = (set \\<circ> jAction MC t) x", "apply (auto dest: jkbpCn_jkbpC_inc iff: mkAutoSim_ec simAction)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nThe reader may care to contrast these structures with the\n\\emph{progression structures} of \\citet{Ron:1997}, where states\ncontain entire Kripke structures, and expanding the automaton is\nalternated with bisimulation reduction to ensure termination when a\nfinite-state implementation exists (see \\S\\ref{sec:kbps-alg-auto-min})\nWe also use simulations in Appendix~\\ref{ch:complexity} to show the\ncomplexity of some related model checking problems.\n\nWe now review a simple \\emph{depth-first search} (DFS) theory, and an\nabstraction of finite maps, before presenting the algorithm for KBP\nsynthesis.\n\n\\FloatBarrier\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}