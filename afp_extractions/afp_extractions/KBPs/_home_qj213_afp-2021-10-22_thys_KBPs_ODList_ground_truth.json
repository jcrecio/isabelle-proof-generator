{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/ODList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma set_merge[simp]:\n  \"set (merge xs ys) = set (xs @ ys)\"", "lemma distinct_sorted_merge[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> distinct (merge xs ys) \\<and> sorted (merge xs ys)\"", "lemma mset_merge [simp]:\n  \"\\<lbrakk> distinct (xs @ ys) \\<rbrakk> \\<Longrightarrow> mset (merge xs ys) = mset xs + mset ys\"", "lemma msort_distinct_sorted[simp]:\n  \"distinct (msort xs) \\<and> sorted (msort xs)\"", "lemma msort_set[simp]:\n  \"set (msort xs) = set xs\"", "lemma msort_remdups[simp]:\n  \"remdups (msort xs) = msort xs\"", "lemma msort_idle[simp]:\n  \"\\<lbrakk> distinct xs; sorted xs \\<rbrakk> \\<Longrightarrow> msort xs = xs\"", "lemma mset_msort[simp]:\n  \"distinct xs \\<Longrightarrow> mset (msort xs) = mset xs\"", "lemma msort_sort[simp]:\n  \"distinct xs \\<Longrightarrow> sort xs = msort xs\"", "lemma distinct_toList[simp]: \"distinct (toList xs)\"", "lemma sorted_toList[simp]: \"sorted (toList xs)\"", "lemma toList_ODList:\n  \"toList (ODList xs) = msort xs\"", "lemma ODList_toList[simp, code abstype]:\n  \"ODList (toList xs) = xs\"", "lemma toList_fromList[code abstract]:\n  \"toList (fromList xs) = msort xs\"", "lemma toList_empty[simp, code abstract]:\n  \"toList empty = []\"", "lemma toSet_empty[simp]:\n  \"toSet empty = {}\"", "lemma toSet_ODList[simp]:\n  \"\\<lbrakk> distinct xs; sorted xs \\<rbrakk> \\<Longrightarrow> toSet (ODList xs) = set xs\"", "lemma toSet_fromList_set[simp]:\n  \"toSet (fromList xs) = set xs\"", "lemma toSet_inj[intro, simp]: \"inj toSet\"", "lemma toSet_eq_iff:\n  \"X = Y \\<longleftrightarrow> toSet X = toSet Y\"", "lemma hd_toList: \"toList xs = y # ys \\<Longrightarrow> ODList.hd xs = y\"", "lemma member_toSet[iff]:\n  \"member xs x \\<longleftrightarrow>x \\<in> toSet xs\"", "lemma toList_filter[simp, code abstract]:\n  \"toList (filter P xs) = List.filter P (toList xs)\"", "lemma toSet_filter[simp]:\n  \"toSet (filter P xs) = { x \\<in> toSet xs . P x }\"", "lemma odlist_all_iff:\n  \"odlist_all P xs \\<longleftrightarrow> (\\<forall>x \\<in> toSet xs. P x)\"", "lemma odlist_all_cong [fundef_cong]:\n  \"xs = ys \\<Longrightarrow> (\\<And>x. x \\<in> toSet ys \\<Longrightarrow> f x = g x) \\<Longrightarrow> odlist_all f xs = odlist_all g ys\"", "lemma toList_difference[simp, code abstract]:\n  \"toList (difference xs ys) = List_local.difference (toList xs) (toList ys)\"", "lemma toSet_difference[simp]:\n  \"toSet (difference xs ys) = toSet xs - toSet ys\"", "lemma toList_intersect[simp, code abstract]:\n  \"toList (intersect xs ys) = List_local.intersection (toList xs) (toList ys)\"", "lemma toSet_intersect[simp]:\n  \"toSet (intersect xs ys) = toSet xs \\<inter> toSet ys\"", "lemma toList_union[simp, code abstract]:\n  \"toList (union xs ys) = merge (toList xs) (toList ys)\"", "lemma toSet_union[simp]:\n  \"toSet (union xs ys) = toSet xs \\<union> toSet ys\"", "lemma toSet_big_union[simp]:\n  \"toSet (big_union f X) = (\\<Union>x \\<in> set X. toSet (f x))\"", "lemma distinct_sorted_induct [consumes 2, case_names Nil insert]:\n  assumes \"distinct xs\"\n  assumes \"sorted xs\"\n  assumes base: \"P []\"\n  assumes step: \"\\<And>x xs. \\<lbrakk> distinct (x # xs); sorted (x # xs); P xs \\<rbrakk> \\<Longrightarrow> P (x # xs)\"\n  shows \"P xs\"", "lemma odlist_induct [case_names empty insert, cases type: odlist]:\n  assumes empty: \"\\<And>dxs. dxs = empty \\<Longrightarrow> P dxs\"\n  assumes insrt: \"\\<And>dxs x xs. \\<lbrakk> dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs); P (fromList xs) \\<rbrakk>\n                            \\<Longrightarrow> P dxs\"\n  shows \"P dxs\"", "lemma odlist_cases [case_names empty insert, cases type: odlist]:\n  assumes empty: \"dxs = empty \\<Longrightarrow> P\"\n  assumes insert: \"\\<And>x xs. \\<lbrakk> dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs) \\<rbrakk>\n                            \\<Longrightarrow> P\"\n  shows P", "lemma toList_image[simp, code abstract]:\n  \"toList (image R xs) = msort (List_local.image (toList R) (toList xs))\"", "lemma toSet_image[simp]:\n  \"toSet (image R xs) = toSet R `` toSet xs\"", "lemma less_eq_list_nil_inv:\n  fixes xs :: \"'a list\"\n  shows \"less_eq_list xs [] \\<Longrightarrow> xs = []\"", "lemma less_eq_list_cons_inv:\n  fixes x :: 'a\n  shows \"less_eq_list (x # xs) yys \\<Longrightarrow> \\<exists>y ys. yys = y # ys \\<and> (x < y \\<or> (x = y \\<and> less_eq_list xs ys))\"", "lemma less_eq_list_refl:\n  fixes xs :: \"'a list\"\n  shows \"less_eq_list xs xs\"", "lemma less_eq_list_trans:\n  fixes xs ys zs :: \"'a list\"\n  shows \"\\<lbrakk> less_eq_list xs ys; less_eq_list ys zs \\<rbrakk> \\<Longrightarrow> less_eq_list xs zs\"", "lemma less_eq_list_antisym:\n  fixes xs ys :: \"'a list\"\n  shows \"\\<lbrakk> less_eq_list xs ys; less_eq_list ys xs \\<rbrakk> \\<Longrightarrow> xs = ys\"", "lemma less_eq_list_linear:\n  fixes xs ys :: \"'a list\"\n  shows \"less_eq_list xs ys \\<or> less_eq_list ys xs\"", "lemma less_eq_list_not_le:\n  fixes xs ys :: \"'a list\"\n  shows \"(less_list xs ys) = (less_eq_list xs ys \\<and> \\<not> less_eq_list ys xs)\"", "lemma (in order) mono_onI [intro?]:\n  fixes f :: \"'a \\<Rightarrow> 'b::order\"\n  shows \"(\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow> mono_on f X\"", "lemma (in order) mono_onD [dest?]:\n  fixes f :: \"'a \\<Rightarrow> 'b::order\"\n  shows \"mono_on f X \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y\"", "lemma (in order) mono_on_subset:\n  fixes f :: \"'a \\<Rightarrow> 'b::order\"\n  shows \"mono_on f X \\<Longrightarrow> Y \\<subseteq> X \\<Longrightarrow> mono_on f Y\"", "lemma sorted_mono_map:\n  \"\\<lbrakk> sorted xs; mono_on f (set xs) \\<rbrakk> \\<Longrightarrow> sorted (List.map f xs)\"", "lemma msort_map:\n  \"\\<lbrakk> distinct xs; sorted xs; inj_on f (set xs); mono_on f (set xs) \\<rbrakk> \\<Longrightarrow> msort (List.map f xs) = List.map f xs\"", "lemma tabulate_toList[simp, code abstract]:\n  \"toList (tabulate ks f) = List.map (\\<lambda>k. (k, f k)) (toList ks)\"", "lemma lookup_tabulate[simp]:\n  \"lookup (tabulate ks f) = (Some o f) |` toSet ks\""], "translations": [["", "lemma set_merge[simp]:\n  \"set (merge xs ys) = set (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge xs ys) = set (xs @ ys)", "by (induct xs ys rule: merge.induct) auto"], ["", "lemma distinct_sorted_merge[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> distinct (merge xs ys) \\<and> sorted (merge xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; distinct ys; sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> distinct (merge xs ys) \\<and> sorted (merge xs ys)", "by (induct xs ys rule: merge.induct) (auto)"], ["", "lemma mset_merge [simp]:\n  \"\\<lbrakk> distinct (xs @ ys) \\<rbrakk> \\<Longrightarrow> mset (merge xs ys) = mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (xs @ ys) \\<Longrightarrow>\n    mset (merge xs ys) = mset xs + mset ys", "by (induct xs ys rule: merge.induct) (simp_all add: ac_simps)"], ["", "(*>*)"], ["", "text\\<open>The \"absorbing\" sort itself.\\<close>"], ["", "fun msort :: \"'a list \\<Rightarrow> 'a list\"\nwhere\n  \"msort [] = []\"\n| \"msort [x] = [x]\"\n| \"msort xs = merge (msort (take (size xs div 2) xs))\n                    (msort (drop (size xs div 2) xs))\""], ["", "(*<*)"], ["", "lemma msort_distinct_sorted[simp]:\n  \"distinct (msort xs) \\<and> sorted (msort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (msort xs) \\<and> sorted (msort xs)", "by (induct xs rule: msort.induct) simp_all"], ["", "lemma msort_set[simp]:\n  \"set (msort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (msort xs) = set xs", "by (induct xs rule: msort.induct)\n     (simp_all, metis List.set_simps(2) append_take_drop_id set_append)"], ["", "(* thankyou sledgehammer! *)"], ["", "lemma msort_remdups[simp]:\n  \"remdups (msort xs) = msort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups (msort xs) = msort xs", "by simp"], ["", "lemma msort_idle[simp]:\n  \"\\<lbrakk> distinct xs; sorted xs \\<rbrakk> \\<Longrightarrow> msort xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted xs\\<rbrakk> \\<Longrightarrow> msort xs = xs", "by (rule map_sorted_distinct_set_unique[where f=id]) (auto simp: map.id)"], ["", "lemma mset_msort[simp]:\n  \"distinct xs \\<Longrightarrow> mset (msort xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> mset (msort xs) = mset xs", "by (rule iffD1[OF set_eq_iff_mset_eq_distinct]) simp_all"], ["", "lemma msort_sort[simp]:\n  \"distinct xs \\<Longrightarrow> sort xs = msort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> sort xs = msort xs", "by (simp add: properties_for_sort)"], ["", "(*>*)"], ["", "end"], ["", "(* context linorder *)"], ["", "section \\<open>The @{term \"odlist\"} type\\<close>"], ["", "typedef (overloaded) ('a :: linorder) odlist = \"{ x::'a list . sorted x \\<and> distinct x }\"\n  morphisms toList odlist_Abs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)", "by (auto iff: sorted.simps(1))"], ["", "lemma distinct_toList[simp]: \"distinct (toList xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (toList xs)", "using toList"], ["proof (prove)\nusing this:\n  toList ?x \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\n\ngoal (1 subgoal):\n 1. distinct (toList xs)", "by auto"], ["", "lemma sorted_toList[simp]: \"sorted (toList xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (toList xs)", "using toList"], ["proof (prove)\nusing this:\n  toList ?x \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\n\ngoal (1 subgoal):\n 1. sorted (toList xs)", "by auto"], ["", "text\\<open>\n\nCode generator voodoo: this is the constructor for the abstract type.\n\n\\<close>"], ["", "definition\n  ODList :: \"('a :: linorder) list \\<Rightarrow> 'a odlist\"\nwhere\n  \"ODList \\<equiv> odlist_Abs \\<circ> msort\""], ["", "lemma toList_ODList:\n  \"toList (ODList xs) = msort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList xs) = msort xs", "unfolding ODList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList ((odlist_Abs \\<circ> msort) xs) = msort xs", "by (simp add: odlist_Abs_inverse)"], ["", "lemma ODList_toList[simp, code abstype]:\n  \"ODList (toList xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ODList (toList xs) = xs", "unfolding ODList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (odlist_Abs \\<circ> msort) (toList xs) = xs", "by (cases xs) (simp add: odlist_Abs_inverse)"], ["", "text\\<open>\n\nRuntime cast from @{typ \"'a list\"} into @{typ \"'a odlist\"}. This is\njust a renaming of @{term \"ODList\"} -- names are significant to the\ncode generator's abstract type machinery.\n\n\\<close>"], ["", "definition\n  fromList :: \"('a :: linorder) list \\<Rightarrow> 'a odlist\"\nwhere\n  \"fromList \\<equiv> ODList\""], ["", "lemma toList_fromList[code abstract]:\n  \"toList (fromList xs) = msort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (fromList xs) = msort xs", "unfolding fromList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList xs) = msort xs", "by (simp add: toList_ODList)"], ["", "subsection\\<open>Basic properties: equality, finiteness\\<close>"], ["", "(*<*)"], ["", "declare toList_inject[iff]"], ["", "(*>*)"], ["", "instantiation odlist :: (linorder) equal\n(*<*)\nbegin"], ["", "definition [code]:\n  \"HOL.equal A B \\<longleftrightarrow> odlist_equal (toList A) (toList B)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a odlist, equal_class)", "by standard (simp add: equal_odlist_def)"], ["", "end"], ["", "(*>*)"], ["", "instance odlist :: (\"{finite, linorder}\") finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a odlist, finite_class)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a odlist, finite_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "let ?ol = \"UNIV :: 'a odlist set\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "let ?s = \"UNIV :: 'a set set\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "have \"finite ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "by simp"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV", "moreover"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal (1 subgoal):\n 1. finite UNIV", "have \"?ol \\<subseteq> range (odlist_Abs \\<circ> sorted_list_of_set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<subseteq> range (odlist_Abs \\<circ> sorted_list_of_set)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       x \\<in> range (odlist_Abs \\<circ> sorted_list_of_set)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UNIV \\<Longrightarrow>\n       x \\<in> range (odlist_Abs \\<circ> sorted_list_of_set)", "show \"x \\<in> range (odlist_Abs \\<circ> sorted_list_of_set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> range (odlist_Abs \\<circ> sorted_list_of_set)", "apply (cases x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> range\n                                  (odlist_Abs \\<circ> sorted_list_of_set)", "apply (rule range_eqI[where x=\"set (toList x)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>x = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (odlist_Abs \\<circ> sorted_list_of_set)\n                          (set (toList x))", "apply (clarsimp simp: odlist_Abs_inject sorted_list_of_set_sort_remdups odlist_Abs_inverse distinct_remdups_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  x \\<in> range (odlist_Abs \\<circ> sorted_list_of_set)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UNIV \\<subseteq> range (odlist_Abs \\<circ> sorted_list_of_set)\n\ngoal (1 subgoal):\n 1. finite UNIV", "ultimately"], ["proof (chain)\npicking this:\n  finite UNIV\n  UNIV \\<subseteq> range (odlist_Abs \\<circ> sorted_list_of_set)", "show \"finite ?ol\""], ["proof (prove)\nusing this:\n  finite UNIV\n  UNIV \\<subseteq> range (odlist_Abs \\<circ> sorted_list_of_set)\n\ngoal (1 subgoal):\n 1. finite UNIV", "by (blast intro: finite_surj)"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "subsection\\<open>Constants\\<close>"], ["", "definition\n  empty :: \"('a :: linorder) odlist\"\nwhere\n  \"empty \\<equiv> ODList []\""], ["", "lemma toList_empty[simp, code abstract]:\n  \"toList empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList ODList.empty = []", "unfolding empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList []) = []", "by (simp add: toList_ODList)"], ["", "subsection\\<open>Operations\\<close>"], ["", "subsubsection\\<open>toSet\\<close>"], ["", "definition\n  toSet :: \"('a :: linorder) odlist \\<Rightarrow> 'a set\"\nwhere\n  \"toSet X = set (toList X)\""], ["", "lemma toSet_empty[simp]:\n  \"toSet empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet ODList.empty = {}", "unfolding toSet_def empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (toList (ODList [])) = {}", "by (simp add: toList_ODList)"], ["", "lemma toSet_ODList[simp]:\n  \"\\<lbrakk> distinct xs; sorted xs \\<rbrakk> \\<Longrightarrow> toSet (ODList xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n    \\<Longrightarrow> toSet (ODList xs) = set xs", "unfolding toSet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n    \\<Longrightarrow> set (toList (ODList xs)) = set xs", "by (simp add: toList_ODList)"], ["", "lemma toSet_fromList_set[simp]:\n  \"toSet (fromList xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (fromList xs) = set xs", "unfolding toSet_def fromList_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (toList (ODList xs)) = set xs", "by (simp add: toList_ODList)"], ["", "lemma toSet_inj[intro, simp]: \"inj toSet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj toSet", "apply (rule injI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. toSet x = toSet y \\<Longrightarrow> x = y", "unfolding toSet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. set (toList x) = set (toList y) \\<Longrightarrow> x = y", "apply (case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>set (toList x) = set (toList y); x = odlist_Abs ya;\n        ya \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (case_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya yb.\n       \\<lbrakk>set (toList x) = set (toList y); x = odlist_Abs ya;\n        ya \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x);\n        y = odlist_Abs yb;\n        yb \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (auto iff: odlist_Abs_inject odlist_Abs_inverse sorted_distinct_set_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma toSet_eq_iff:\n  \"X = Y \\<longleftrightarrow> toSet X = toSet Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X = Y) = (toSet X = toSet Y)", "by (blast dest: injD[OF toSet_inj])"], ["", "subsubsection\\<open>head\\<close>"], ["", "definition\n  hd :: \"('a :: linorder) odlist \\<Rightarrow> 'a\"\nwhere\n  [code]: \"hd \\<equiv> List.hd \\<circ> toList\""], ["", "lemma hd_toList: \"toList xs = y # ys \\<Longrightarrow> ODList.hd xs = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList xs = y # ys \\<Longrightarrow> ODList.hd xs = y", "unfolding hd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList xs = y # ys \\<Longrightarrow> (list.hd \\<circ> toList) xs = y", "by simp"], ["", "subsubsection\\<open>member\\<close>"], ["", "definition\n  member :: \"('a :: linorder) odlist \\<Rightarrow> 'a \\<Rightarrow> bool\"\nwhere\n  [code]: \"member xs x \\<equiv> List.member (toList xs) x\""], ["", "lemma member_toSet[iff]:\n  \"member xs x \\<longleftrightarrow>x \\<in> toSet xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. member xs x = (x \\<in> toSet xs)", "unfolding member_def toSet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.member (toList xs) x = (x \\<in> set (toList xs))", "by (simp add: in_set_member)"], ["", "subsubsection\\<open>Filter\\<close>"], ["", "definition\n  filter :: \"(('a :: linorder) \\<Rightarrow> bool) \\<Rightarrow> 'a odlist \\<Rightarrow> 'a odlist\"\nwhere\n  \"filter P xs \\<equiv> ODList (List.filter P (toList xs))\""], ["", "lemma toList_filter[simp, code abstract]:\n  \"toList (filter P xs) = List.filter P (toList xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList.filter P xs) = List.filter P (toList xs)", "unfolding filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList (List.filter P (toList xs))) = List.filter P (toList xs)", "by (simp add: toList_ODList)"], ["", "lemma toSet_filter[simp]:\n  \"toSet (filter P xs) = { x \\<in> toSet xs . P x }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList.filter P xs) =\n    rel_ext (\\<lambda>x. x \\<in> toSet xs \\<and> P x)", "unfolding filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList (List.filter P (toList xs))) =\n    rel_ext (\\<lambda>x. x \\<in> toSet xs \\<and> P x)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext (\\<lambda>x. x \\<in> set (toList xs) \\<and> P x) =\n    rel_ext (\\<lambda>x. x \\<in> toSet xs \\<and> P x)", "apply (simp add: toSet_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>All\\<close>"], ["", "definition\n  odlist_all :: \"('a :: linorder \\<Rightarrow> bool) \\<Rightarrow> 'a odlist \\<Rightarrow> bool\"\nwhere\n  [code]: \"odlist_all P xs \\<equiv> list_all P (toList xs)\""], ["", "lemma odlist_all_iff:\n  \"odlist_all P xs \\<longleftrightarrow> (\\<forall>x \\<in> toSet xs. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. odlist_all P xs = (\\<forall>x\\<in>toSet xs. P x)", "unfolding odlist_all_def toSet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all P (toList xs) = (\\<forall>x\\<in>set (toList xs). P x)", "by (simp only: list_all_iff)"], ["", "lemma odlist_all_cong [fundef_cong]:\n  \"xs = ys \\<Longrightarrow> (\\<And>x. x \\<in> toSet ys \\<Longrightarrow> f x = g x) \\<Longrightarrow> odlist_all f xs = odlist_all g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys;\n     \\<And>x. x \\<in> toSet ys \\<Longrightarrow> f x = g x\\<rbrakk>\n    \\<Longrightarrow> odlist_all f xs = odlist_all g ys", "by (simp add: odlist_all_iff)"], ["", "subsubsection\\<open>Difference\\<close>"], ["", "definition\n  difference :: \"('a :: linorder) odlist \\<Rightarrow> 'a odlist \\<Rightarrow> 'a odlist\"\nwhere\n  \"difference xs ys = ODList (List_local.difference (toList xs) (toList ys))\""], ["", "lemma toList_difference[simp, code abstract]:\n  \"toList (difference xs ys) = List_local.difference (toList xs) (toList ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList.difference xs ys) =\n    List_local.difference (toList xs) (toList ys)", "unfolding difference_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList (List_local.difference (toList xs) (toList ys))) =\n    List_local.difference (toList xs) (toList ys)", "by (simp add: toList_ODList)"], ["", "lemma toSet_difference[simp]:\n  \"toSet (difference xs ys) = toSet xs - toSet ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList.difference xs ys) = toSet xs - toSet ys", "unfolding difference_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList (List_local.difference (toList xs) (toList ys))) =\n    toSet xs - toSet ys", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (toList xs) - set (toList ys) = toSet xs - toSet ys", "apply (simp add: toSet_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Intersection\\<close>"], ["", "definition\n  intersect :: \"('a :: linorder) odlist \\<Rightarrow> 'a odlist \\<Rightarrow> 'a odlist\"\nwhere\n  \"intersect xs ys = ODList (List_local.intersection (toList xs) (toList ys))\""], ["", "lemma toList_intersect[simp, code abstract]:\n  \"toList (intersect xs ys) = List_local.intersection (toList xs) (toList ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (intersect xs ys) = intersection (toList xs) (toList ys)", "unfolding intersect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList (intersection (toList xs) (toList ys))) =\n    intersection (toList xs) (toList ys)", "by (simp add: toList_ODList)"], ["", "lemma toSet_intersect[simp]:\n  \"toSet (intersect xs ys) = toSet xs \\<inter> toSet ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (intersect xs ys) = toSet xs \\<inter> toSet ys", "unfolding intersect_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList (intersection (toList xs) (toList ys))) =\n    toSet xs \\<inter> toSet ys", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (toList xs) \\<inter> set (toList ys) = toSet xs \\<inter> toSet ys", "apply (simp add: toSet_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Union\\<close>"], ["", "definition\n  union :: \"('a :: linorder) odlist \\<Rightarrow> 'a odlist \\<Rightarrow> 'a odlist\"\nwhere\n  \"union xs ys = ODList (merge (toList xs) (toList ys))\""], ["", "lemma toList_union[simp, code abstract]:\n  \"toList (union xs ys) = merge (toList xs) (toList ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList.union xs ys) = merge (toList xs) (toList ys)", "unfolding union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList (merge (toList xs) (toList ys))) =\n    merge (toList xs) (toList ys)", "by (simp add: toList_ODList)"], ["", "lemma toSet_union[simp]:\n  \"toSet (union xs ys) = toSet xs \\<union> toSet ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList.union xs ys) = toSet xs \\<union> toSet ys", "unfolding union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList (merge (toList xs) (toList ys))) =\n    toSet xs \\<union> toSet ys", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (toList xs) \\<union> set (toList ys) = toSet xs \\<union> toSet ys", "apply (simp add: toSet_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  big_union :: \"('b \\<Rightarrow> ('a :: linorder) odlist) \\<Rightarrow> 'b list \\<Rightarrow> 'a odlist\"\nwhere\n  [code]: \"big_union f X \\<equiv> foldr (\\<lambda>a A. ODList.union (f a) A) X ODList.empty\""], ["", "lemma toSet_big_union[simp]:\n  \"toSet (big_union f X) = (\\<Union>x \\<in> set X. toSet (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "fix X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "have \"toSet (foldr (\\<lambda>x A. ODList.union (f x) A) X Y) = toSet Y \\<union> (\\<Union>x \\<in> set X. toSet (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (foldr (\\<lambda>x. ODList.union (f x)) X Y) =\n    toSet Y \\<union> (\\<Union>x\\<in>set X. toSet (f x))", "by (induct X arbitrary: Y) auto"], ["proof (state)\nthis:\n  toSet (foldr (\\<lambda>x. ODList.union (f x)) X Y) =\n  toSet Y \\<union> (\\<Union>x\\<in>set X. toSet (f x))\n\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "}"], ["proof (state)\nthis:\n  toSet (foldr (\\<lambda>x. ODList.union (f x)) ?Xa2 ?Y2) =\n  toSet ?Y2 \\<union> (\\<Union>x\\<in>set ?Xa2. toSet (f x))\n\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  toSet (foldr (\\<lambda>x. ODList.union (f x)) ?Xa2 ?Y2) =\n  toSet ?Y2 \\<union> (\\<Union>x\\<in>set ?Xa2. toSet (f x))\n\ngoal (1 subgoal):\n 1. toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))", "unfolding big_union_def"], ["proof (prove)\nusing this:\n  toSet (foldr (\\<lambda>x. ODList.union (f x)) ?Xa2 ?Y2) =\n  toSet ?Y2 \\<union> (\\<Union>x\\<in>set ?Xa2. toSet (f x))\n\ngoal (1 subgoal):\n 1. toSet (foldr (\\<lambda>a. ODList.union (f a)) X ODList.empty) =\n    (\\<Union>x\\<in>set X. toSet (f x))", "by simp"], ["proof (state)\nthis:\n  toSet (big_union f X) = (\\<Union>x\\<in>set X. toSet (f x))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Case distinctions\\<close>"], ["", "text\\<open>\n\nWe construct ODLists out of lists, so talk in terms of those, not a\none-step constructor we don't use.\n\n\\<close>"], ["", "lemma distinct_sorted_induct [consumes 2, case_names Nil insert]:\n  assumes \"distinct xs\"\n  assumes \"sorted xs\"\n  assumes base: \"P []\"\n  assumes step: \"\\<And>x xs. \\<lbrakk> distinct (x # xs); sorted (x # xs); P xs \\<rbrakk> \\<Longrightarrow> P (x # xs)\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "using \\<open>distinct xs\\<close> \\<open>sorted xs\\<close>"], ["proof (prove)\nusing this:\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. P xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted []\\<rbrakk> \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        distinct (a # xs); sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  sorted []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted []\\<rbrakk> \\<Longrightarrow> P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        distinct (a # xs); sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "from \\<open>P []\\<close>"], ["proof (chain)\npicking this:\n  P []", "show ?case"], ["proof (prove)\nusing this:\n  P []\n\ngoal (1 subgoal):\n 1. P []", "."], ["proof (state)\nthis:\n  P []\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        distinct (a # xs); sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        distinct (a # xs); sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs; sorted xs\\<rbrakk> \\<Longrightarrow> P xs\n  distinct (x # xs)\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        distinct (a # xs); sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct xs; sorted xs\\<rbrakk> \\<Longrightarrow> P xs\n  distinct (x # xs)\n  sorted (x # xs)", "have \"distinct (x # xs)\" and \"sorted (x # xs)\" and \"P xs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs; sorted xs\\<rbrakk> \\<Longrightarrow> P xs\n  distinct (x # xs)\n  sorted (x # xs)\n\ngoal (1 subgoal):\n 1. distinct (x # xs) &&& sorted (x # xs) &&& P xs", "by (simp_all)"], ["proof (state)\nthis:\n  distinct (x # xs)\n  sorted (x # xs)\n  P xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs; sorted xs\\<rbrakk>\n                \\<Longrightarrow> P xs;\n        distinct (a # xs); sorted (a # xs)\\<rbrakk>\n       \\<Longrightarrow> P (a # xs)", "with step"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct (?x # ?xs); sorted (?x # ?xs); P ?xs\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  P xs", "show \"P (x # xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (?x # ?xs); sorted (?x # ?xs); P ?xs\\<rbrakk>\n  \\<Longrightarrow> P (?x # ?xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  P xs\n\ngoal (1 subgoal):\n 1. P (x # xs)", "."], ["proof (state)\nthis:\n  P (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odlist_induct [case_names empty insert, cases type: odlist]:\n  assumes empty: \"\\<And>dxs. dxs = empty \\<Longrightarrow> P dxs\"\n  assumes insrt: \"\\<And>dxs x xs. \\<lbrakk> dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs); P (fromList xs) \\<rbrakk>\n                            \\<Longrightarrow> P dxs\"\n  shows \"P dxs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P dxs", "proof (cases dxs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P dxs", "case (odlist_Abs xs)"], ["proof (state)\nthis:\n  dxs = odlist_Abs xs\n  xs \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P dxs", "then"], ["proof (chain)\npicking this:\n  dxs = odlist_Abs xs\n  xs \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)", "have dxs: \"dxs = ODList xs\" and distinct: \"distinct xs\" and sorted: \"sorted xs\""], ["proof (prove)\nusing this:\n  dxs = odlist_Abs xs\n  xs \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\n\ngoal (1 subgoal):\n 1. dxs = ODList xs &&& distinct xs &&& sorted xs", "by (simp_all add: ODList_def)"], ["proof (state)\nthis:\n  dxs = ODList xs\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P dxs", "from \\<open>distinct xs\\<close> and \\<open>sorted xs\\<close>"], ["proof (chain)\npicking this:\n  distinct xs\n  sorted xs", "have \"P (ODList xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. P (ODList xs)", "proof (induct xs rule: distinct_sorted_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. P (ODList [])\n 2. \\<And>x xs.\n       \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n       \\<Longrightarrow> P (ODList (x # xs))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. P (ODList [])\n 2. \\<And>x xs.\n       \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n       \\<Longrightarrow> P (ODList (x # xs))", "from empty"], ["proof (chain)\npicking this:\n  ?dxs = ODList.empty \\<Longrightarrow> P ?dxs", "show ?case"], ["proof (prove)\nusing this:\n  ?dxs = ODList.empty \\<Longrightarrow> P ?dxs\n\ngoal (1 subgoal):\n 1. P (ODList [])", "by (simp add: empty_def)"], ["proof (state)\nthis:\n  P (ODList [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n       \\<Longrightarrow> P (ODList (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n       \\<Longrightarrow> P (ODList (x # xs))", "case (insert x xs)"], ["proof (state)\nthis:\n  distinct (x # xs)\n  sorted (x # xs)\n  P (ODList xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n       \\<Longrightarrow> P (ODList (x # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (x # xs)\n  sorted (x # xs)\n  P (ODList xs)\n\ngoal (1 subgoal):\n 1. P (ODList (x # xs))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n    \\<Longrightarrow> P (ODList (x # xs))", "apply (rule insrt)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n    \\<Longrightarrow> ODList (x # xs) = fromList (?x3 # ?xs3)\n 2. \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n    \\<Longrightarrow> distinct (?x3 # ?xs3)\n 3. \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n    \\<Longrightarrow> sorted (?x3 # ?xs3)\n 4. \\<lbrakk>distinct (x # xs); sorted (x # xs); P (ODList xs)\\<rbrakk>\n    \\<Longrightarrow> P (fromList ?xs3)", "apply (auto simp: fromList_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (ODList (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (ODList xs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P dxs", "with dxs"], ["proof (chain)\npicking this:\n  dxs = ODList xs\n  P (ODList xs)", "show \"P dxs\""], ["proof (prove)\nusing this:\n  dxs = ODList xs\n  P (ODList xs)\n\ngoal (1 subgoal):\n 1. P dxs", "by simp"], ["proof (state)\nthis:\n  P dxs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma odlist_cases [case_names empty insert, cases type: odlist]:\n  assumes empty: \"dxs = empty \\<Longrightarrow> P\"\n  assumes insert: \"\\<And>x xs. \\<lbrakk> dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs) \\<rbrakk>\n                            \\<Longrightarrow> P\"\n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases dxs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P", "case (odlist_Abs xs)"], ["proof (state)\nthis:\n  dxs = odlist_Abs xs\n  xs \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  dxs = odlist_Abs xs\n  xs \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)", "have dxs: \"dxs = ODList xs\" and distinct: \"distinct xs\" and sorted: \"sorted xs\""], ["proof (prove)\nusing this:\n  dxs = odlist_Abs xs\n  xs \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\n\ngoal (1 subgoal):\n 1. dxs = ODList xs &&& distinct xs &&& sorted xs", "by (simp_all add: ODList_def)"], ["proof (state)\nthis:\n  dxs = ODList xs\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>dxs = odlist_Abs y;\n        y \\<in> rel_ext (\\<lambda>x. sorted x \\<and> distinct x)\\<rbrakk>\n       \\<Longrightarrow> P", "show P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "with dxs"], ["proof (chain)\npicking this:\n  dxs = ODList xs\n  xs = []", "have \"dxs = empty\""], ["proof (prove)\nusing this:\n  dxs = ODList xs\n  xs = []\n\ngoal (1 subgoal):\n 1. dxs = ODList.empty", "by (simp add: empty_def)"], ["proof (state)\nthis:\n  dxs = ODList.empty\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> P\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> P", "with empty"], ["proof (chain)\npicking this:\n  dxs = ODList.empty \\<Longrightarrow> P\n  dxs = ODList.empty", "show P"], ["proof (prove)\nusing this:\n  dxs = ODList.empty \\<Longrightarrow> P\n  dxs = ODList.empty\n\ngoal (1 subgoal):\n 1. P", "."], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> P", "with dxs distinct sorted insert"], ["proof (chain)\npicking this:\n  dxs = ODList xs\n  distinct xs\n  sorted xs\n  \\<lbrakk>dxs = fromList (?x # ?xs); distinct (?x # ?xs);\n   sorted (?x # ?xs)\\<rbrakk>\n  \\<Longrightarrow> P\n  xs = y # ys", "show P"], ["proof (prove)\nusing this:\n  dxs = ODList xs\n  distinct xs\n  sorted xs\n  \\<lbrakk>dxs = fromList (?x # ?xs); distinct (?x # ?xs);\n   sorted (?x # ?xs)\\<rbrakk>\n  \\<Longrightarrow> P\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. P", "by (simp add: fromList_def)"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Relations\\<close>"], ["", "text\\<open>\n\nRelations, represented as a list of pairs.\n\n\\<close>"], ["", "type_synonym 'a odrelation = \"('a \\<times> 'a) odlist\""], ["", "subsubsection\\<open>Image\\<close>"], ["", "text\\<open>\n\nThe output of @{term \"List_local.image\"} is not guaranteed to be\nordered or distinct. Also the relation need not be monomorphic.\n\n\\<close>"], ["", "definition\n  image :: \"('a :: linorder \\<times> 'b :: linorder) odlist \\<Rightarrow> 'a odlist \\<Rightarrow> 'b odlist\"\nwhere\n  \"image R xs = ODList (List_local.image (toList R) (toList xs))\""], ["", "lemma toList_image[simp, code abstract]:\n  \"toList (image R xs) = msort (List_local.image (toList R) (toList xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList.image R xs) =\n    msort (List_local.image (toList R) (toList xs))", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList (List_local.image (toList R) (toList xs))) =\n    msort (List_local.image (toList R) (toList xs))", "by (simp add: toList_ODList)"], ["", "lemma toSet_image[simp]:\n  \"toSet (image R xs) = toSet R `` toSet xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList.image R xs) = toSet R `` toSet xs", "unfolding image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet (ODList (List_local.image (toList R) (toList xs))) =\n    toSet R `` toSet xs", "by (simp add: toSet_def toList_ODList)"], ["", "subsubsection\\<open>Linear order\\<close>"], ["", "text\\<open>\n\nLexicographic ordering on lists. Executable, unlike in List.thy.\n\n\\<close>"], ["", "instantiation odlist :: (linorder) linorder\nbegin"], ["", "print_context"], ["", "fun\n  less_eq_list :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nwhere\n  \"less_eq_list [] ys = True\"\n| \"less_eq_list xs [] = False\"\n| \"less_eq_list (x # xs) (y # ys) = (x < y \\<or> (x = y \\<and> less_eq_list xs ys))\""], ["", "lemma less_eq_list_nil_inv:\n  fixes xs :: \"'a list\"\n  shows \"less_eq_list xs [] \\<Longrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.less_eq_list xs [] \\<Longrightarrow> xs = []", "by (cases xs) simp_all"], ["", "lemma less_eq_list_cons_inv:\n  fixes x :: 'a\n  shows \"less_eq_list (x # xs) yys \\<Longrightarrow> \\<exists>y ys. yys = y # ys \\<and> (x < y \\<or> (x = y \\<and> less_eq_list xs ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.less_eq_list (x # xs) yys \\<Longrightarrow>\n    \\<exists>y ys.\n       yys = y # ys \\<and>\n       (x < y \\<or> x = y \\<and> local.less_eq_list xs ys)", "by (cases yys) auto"], ["", "lemma less_eq_list_refl:\n  fixes xs :: \"'a list\"\n  shows \"less_eq_list xs xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.less_eq_list xs xs", "by (induct xs) simp_all"], ["", "lemma less_eq_list_trans:\n  fixes xs ys zs :: \"'a list\"\n  shows \"\\<lbrakk> less_eq_list xs ys; less_eq_list ys zs \\<rbrakk> \\<Longrightarrow> less_eq_list xs zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.less_eq_list xs ys; local.less_eq_list ys zs\\<rbrakk>\n    \\<Longrightarrow> local.less_eq_list xs zs", "apply (induct xs ys arbitrary: zs rule: less_eq_list.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>local.less_eq_list [] ys; local.less_eq_list ys zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list [] zs\n 2. \\<And>v va zs.\n       \\<lbrakk>local.less_eq_list (v # va) [];\n        local.less_eq_list [] zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (v # va) zs\n 3. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (x # xs) (y # ys);\n        local.less_eq_list (y # ys) zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va zs.\n       \\<lbrakk>local.less_eq_list (v # va) [];\n        local.less_eq_list [] zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (v # va) zs\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (x # xs) (y # ys);\n        local.less_eq_list (y # ys) zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (x # xs) (y # ys);\n        local.less_eq_list (y # ys) zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        x < y \\<or> x = y \\<and> local.less_eq_list xs ys;\n        local.less_eq_list (y # ys) zs\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs; x < y\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs;\n        x = y \\<and> local.less_eq_list xs ys\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply (drule less_eq_list_cons_inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        x < y;\n        \\<exists>ya ysa.\n           zs = ya # ysa \\<and>\n           (y < ya \\<or> y = ya \\<and> local.less_eq_list ys ysa)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs;\n        x = y \\<and> local.less_eq_list xs ys\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys ya ysa.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        x < y; y < ya \\<or> y = ya \\<and> local.less_eq_list ys ysa;\n        x = ya \\<longrightarrow> \\<not> local.less_eq_list xs ysa\\<rbrakk>\n       \\<Longrightarrow> x < ya\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs;\n        x = y \\<and> local.less_eq_list xs ys\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply (erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs y ys ya ysa.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        x < y; x = ya \\<longrightarrow> \\<not> local.less_eq_list xs ysa;\n        y < ya\\<rbrakk>\n       \\<Longrightarrow> x < ya\n 2. \\<And>x xs y ys ya ysa.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        x < y; x = ya \\<longrightarrow> \\<not> local.less_eq_list xs ysa;\n        y = ya \\<and> local.less_eq_list ys ysa\\<rbrakk>\n       \\<Longrightarrow> x < ya\n 3. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs;\n        x = y \\<and> local.less_eq_list xs ys\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs y ys ya ysa.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        x < y; x = ya \\<longrightarrow> \\<not> local.less_eq_list xs ysa;\n        y = ya \\<and> local.less_eq_list ys ysa\\<rbrakk>\n       \\<Longrightarrow> x < ya\n 2. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs;\n        x = y \\<and> local.less_eq_list xs ys\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys zs.\n       \\<lbrakk>\\<And>zs.\n                   \\<lbrakk>local.less_eq_list xs ys;\n                    local.less_eq_list ys zs\\<rbrakk>\n                   \\<Longrightarrow> local.less_eq_list xs zs;\n        local.less_eq_list (y # ys) zs;\n        x = y \\<and> local.less_eq_list xs ys\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (x # xs) zs", "apply (auto dest: less_eq_list_cons_inv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma less_eq_list_antisym:\n  fixes xs ys :: \"'a list\"\n  shows \"\\<lbrakk> less_eq_list xs ys; less_eq_list ys xs \\<rbrakk> \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.less_eq_list xs ys; local.less_eq_list ys xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys", "by (induct xs ys rule: less_eq_list.induct) (auto dest: less_eq_list_nil_inv)"], ["", "lemma less_eq_list_linear:\n  fixes xs ys :: \"'a list\"\n  shows \"less_eq_list xs ys \\<or> less_eq_list ys xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.less_eq_list xs ys \\<or> local.less_eq_list ys xs", "by (induct xs ys rule: less_eq_list.induct) auto"], ["", "definition\n  less_eq_odlist :: \"'a odlist \\<Rightarrow> 'a odlist \\<Rightarrow> bool\"\nwhere\n  \"xs \\<le> ys \\<equiv> less_eq_list (toList xs) (toList ys)\""], ["", "fun\n  less_list :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nwhere\n  \"less_list [] [] = False\"\n| \"less_list [] ys = True\"\n| \"less_list xs [] = False\"\n| \"less_list (x # xs) (y # ys) = (x < y \\<or> (x = y \\<and> less_list xs ys))\""], ["", "definition\n  less_odlist :: \"'a odlist \\<Rightarrow> 'a odlist \\<Rightarrow> bool\"\nwhere\n  \"xs < ys \\<equiv> less_list (toList xs) (toList ys)\""], ["", "lemma less_eq_list_not_le:\n  fixes xs ys :: \"'a list\"\n  shows \"(less_list xs ys) = (less_eq_list xs ys \\<and> \\<not> less_eq_list ys xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.less_list xs ys =\n    (local.less_eq_list xs ys \\<and> \\<not> local.less_eq_list ys xs)", "by (induct xs ys rule: less_list.induct) auto"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a odlist, linorder_class)", "apply intro_classes"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "unfolding less_eq_odlist_def less_odlist_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       local.less_list (toList x) (toList y) =\n       (local.less_eq_list (toList x) (toList y) \\<and>\n        \\<not> local.less_eq_list (toList y) (toList x))\n 2. \\<And>x. local.less_eq_list (toList x) (toList x)\n 3. \\<And>x y z.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList z)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (toList x) (toList z)\n 4. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "using less_eq_list_not_le less_eq_list_refl less_eq_list_trans less_eq_list_antisym"], ["proof (prove)\nusing this:\n  local.less_list ?xs ?ys =\n  (local.less_eq_list ?xs ?ys \\<and> \\<not> local.less_eq_list ?ys ?xs)\n  local.less_eq_list ?xs ?xs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> local.less_eq_list ?xs ?zs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (5 subgoals):\n 1. \\<And>x y.\n       local.less_list (toList x) (toList y) =\n       (local.less_eq_list (toList x) (toList y) \\<and>\n        \\<not> local.less_eq_list (toList y) (toList x))\n 2. \\<And>x. local.less_eq_list (toList x) (toList x)\n 3. \\<And>x y z.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList z)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (toList x) (toList z)\n 4. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x. local.less_eq_list (toList x) (toList x)\n 2. \\<And>x y z.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList z)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (toList x) (toList z)\n 3. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "using less_eq_list_not_le less_eq_list_refl less_eq_list_trans less_eq_list_antisym"], ["proof (prove)\nusing this:\n  local.less_list ?xs ?ys =\n  (local.less_eq_list ?xs ?ys \\<and> \\<not> local.less_eq_list ?ys ?xs)\n  local.less_eq_list ?xs ?xs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> local.less_eq_list ?xs ?zs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (4 subgoals):\n 1. \\<And>x. local.less_eq_list (toList x) (toList x)\n 2. \\<And>x y z.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList z)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (toList x) (toList z)\n 3. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList z)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (toList x) (toList z)\n 2. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "using less_eq_list_not_le less_eq_list_refl less_eq_list_trans less_eq_list_antisym"], ["proof (prove)\nusing this:\n  local.less_list ?xs ?ys =\n  (local.less_eq_list ?xs ?ys \\<and> \\<not> local.less_eq_list ?ys ?xs)\n  local.less_eq_list ?xs ?xs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> local.less_eq_list ?xs ?zs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList z)\\<rbrakk>\n       \\<Longrightarrow> local.less_eq_list (toList x) (toList z)\n 2. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "using less_eq_list_not_le less_eq_list_refl less_eq_list_trans less_eq_list_antisym"], ["proof (prove)\nusing this:\n  local.less_list ?xs ?ys =\n  (local.less_eq_list ?xs ?ys \\<and> \\<not> local.less_eq_list ?ys ?xs)\n  local.less_eq_list ?xs ?xs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?zs\\<rbrakk>\n  \\<Longrightarrow> local.less_eq_list ?xs ?zs\n  \\<lbrakk>local.less_eq_list ?xs ?ys; local.less_eq_list ?ys ?xs\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>local.less_eq_list (toList x) (toList y);\n        local.less_eq_list (toList y) (toList x)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       local.less_eq_list (toList x) (toList y) \\<or>\n       local.less_eq_list (toList y) (toList x)", "apply (rule less_eq_list_linear)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection\\<open>Finite maps\\<close>"], ["", "text\\<open>\n\nA few operations on finite maps.\n\nUnlike the AssocList theory, ODLists give us canonical\nrepresentations, so we can order them. Our tabulate has the wrong type\n(we want to take an odlist, not a list) so we can't use that\npart of the framework.\n\n\\<close>"], ["", "definition\n  lookup :: \"('a :: linorder \\<times> 'b :: linorder) odlist \\<Rightarrow> ('a \\<rightharpoonup> 'b)\"\nwhere\n  [code]: \"lookup = map_of \\<circ> toList\""], ["", "text\\<open>Specific to ODLists.\\<close>"], ["", "definition\n  tabulate :: \"('a :: linorder) odlist \\<Rightarrow> ('a \\<Rightarrow> 'b :: linorder) \\<Rightarrow> ('a \\<times> 'b) odlist\"\nwhere\n  \"tabulate ks f = ODList (List.map (\\<lambda>k. (k, f k)) (toList ks))\""], ["", "definition (in order) mono_on :: \"('a \\<Rightarrow> 'b::order) \\<Rightarrow> 'a set \\<Rightarrow> bool\" where\n  \"mono_on f X \\<longleftrightarrow> (\\<forall>x\\<in>X. \\<forall>y\\<in>X. x \\<le> y \\<longrightarrow> f x \\<le> f y)\""], ["", "lemma (in order) mono_onI [intro?]:\n  fixes f :: \"'a \\<Rightarrow> 'b::order\"\n  shows \"(\\<And>x y. x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow> mono_on f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> X; y \\<in> X; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow>\n    order_class.mono_on f X", "unfolding mono_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> X; y \\<in> X; x \\<le> y\\<rbrakk>\n        \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow>\n    \\<forall>x\\<in>X.\n       \\<forall>y\\<in>X. x \\<le> y \\<longrightarrow> f x \\<le> f y", "by simp"], ["", "lemma (in order) mono_onD [dest?]:\n  fixes f :: \"'a \\<Rightarrow> 'b::order\"\n  shows \"mono_on f X \\<Longrightarrow> x \\<in> X \\<Longrightarrow> y \\<in> X \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order_class.mono_on f X; x \\<in> X; y \\<in> X;\n     x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f x \\<le> f y", "unfolding mono_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>y\\<in>X. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     x \\<in> X; y \\<in> X; x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> f x \\<le> f y", "by simp"], ["", "lemma (in order) mono_on_subset:\n  fixes f :: \"'a \\<Rightarrow> 'b::order\"\n  shows \"mono_on f X \\<Longrightarrow> Y \\<subseteq> X \\<Longrightarrow> mono_on f Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order_class.mono_on f X; Y \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> order_class.mono_on f Y", "unfolding mono_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>X.\n                \\<forall>y\\<in>X. x \\<le> y \\<longrightarrow> f x \\<le> f y;\n     Y \\<subseteq> X\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>Y.\n                         \\<forall>y\\<in>Y.\n                            x \\<le> y \\<longrightarrow> f x \\<le> f y", "by auto"], ["", "lemma sorted_mono_map:\n  \"\\<lbrakk> sorted xs; mono_on f (set xs) \\<rbrakk> \\<Longrightarrow> sorted (List.map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; order_class.mono_on f (set xs)\\<rbrakk>\n    \\<Longrightarrow> sorted (map f xs)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted []; order_class.mono_on f (set [])\\<rbrakk>\n    \\<Longrightarrow> sorted (map f [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs; order_class.mono_on f (set xs)\\<rbrakk>\n                \\<Longrightarrow> sorted (map f xs);\n        sorted (a # xs); order_class.mono_on f (set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (a # xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>sorted xs; order_class.mono_on f (set xs)\\<rbrakk>\n                \\<Longrightarrow> sorted (map f xs);\n        sorted (a # xs); order_class.mono_on f (set (a # xs))\\<rbrakk>\n       \\<Longrightarrow> sorted (map f (a # xs))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>order_class.mono_on f (set xs) \\<Longrightarrow>\n                sorted (map f xs);\n        (\\<forall>x\\<in>set xs. a \\<le> x) \\<and> sorted xs;\n        order_class.mono_on f (insert a (set xs))\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set xs. f a \\<le> f x) \\<and>\n                         sorted (map f xs)", "apply (cut_tac X=\"insert a (set xs)\" and Y=\"set xs\" in mono_on_subset)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>order_class.mono_on f (set xs) \\<Longrightarrow>\n                sorted (map f xs);\n        (\\<forall>x\\<in>set xs. a \\<le> x) \\<and> sorted xs;\n        order_class.mono_on f (insert a (set xs))\\<rbrakk>\n       \\<Longrightarrow> order_class.mono_on (?f8 a xs) (insert a (set xs))\n 2. \\<And>a xs.\n       \\<lbrakk>order_class.mono_on f (set xs) \\<Longrightarrow>\n                sorted (map f xs);\n        (\\<forall>x\\<in>set xs. a \\<le> x) \\<and> sorted xs;\n        order_class.mono_on f (insert a (set xs))\\<rbrakk>\n       \\<Longrightarrow> set xs \\<subseteq> insert a (set xs)\n 3. \\<And>a xs.\n       \\<lbrakk>order_class.mono_on f (set xs) \\<Longrightarrow>\n                sorted (map f xs);\n        (\\<forall>x\\<in>set xs. a \\<le> x) \\<and> sorted xs;\n        order_class.mono_on f (insert a (set xs));\n        order_class.mono_on (?f8 a xs) (set xs)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set xs. f a \\<le> f x) \\<and>\n                         sorted (map f xs)", "apply (auto dest: mono_onD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma msort_map:\n  \"\\<lbrakk> distinct xs; sorted xs; inj_on f (set xs); mono_on f (set xs) \\<rbrakk> \\<Longrightarrow> msort (List.map f xs) = List.map f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted xs; inj_on f (set xs);\n     order_class.mono_on f (set xs)\\<rbrakk>\n    \\<Longrightarrow> msort (map f xs) = map f xs", "apply (rule msort_idle)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct xs; sorted xs; inj_on f (set xs);\n     order_class.mono_on f (set xs)\\<rbrakk>\n    \\<Longrightarrow> distinct (map f xs)\n 2. \\<lbrakk>distinct xs; sorted xs; inj_on f (set xs);\n     order_class.mono_on f (set xs)\\<rbrakk>\n    \\<Longrightarrow> sorted (map f xs)", "apply (simp add: distinct_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted xs; inj_on f (set xs);\n     order_class.mono_on f (set xs)\\<rbrakk>\n    \\<Longrightarrow> sorted (map f xs)", "apply (simp add: sorted_mono_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tabulate_toList[simp, code abstract]:\n  \"toList (tabulate ks f) = List.map (\\<lambda>k. (k, f k)) (toList ks)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (tabulate ks f) = map (\\<lambda>k. (k, f k)) (toList ks)", "unfolding tabulate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. toList (ODList (map (\\<lambda>k. (k, f k)) (toList ks))) =\n    map (\\<lambda>k. (k, f k)) (toList ks)", "apply (simp add: toList_ODList)"], ["proof (prove)\ngoal (1 subgoal):\n 1. msort (map (\\<lambda>k. (k, f k)) (toList ks)) =\n    map (\\<lambda>k. (k, f k)) (toList ks)", "apply (subst msort_map)"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct (toList ks)\n 2. sorted (toList ks)\n 3. inj_on (\\<lambda>k. (k, f k)) (set (toList ks))\n 4. order_class.mono_on (\\<lambda>k. (k, f k)) (set (toList ks))\n 5. map (\\<lambda>k. (k, f k)) (toList ks) =\n    map (\\<lambda>k. (k, f k)) (toList ks)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>k. (k, f k)) (set (toList ks))\n 2. order_class.mono_on (\\<lambda>k. (k, f k)) (set (toList ks))", "apply (rule inj_onI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (toList ks); y \\<in> set (toList ks);\n        (x, f x) = (y, f y)\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. order_class.mono_on (\\<lambda>k. (k, f k)) (set (toList ks))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_class.mono_on (\\<lambda>k. (k, f k)) (set (toList ks))", "apply (rule mono_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set (toList ks); y \\<in> set (toList ks);\n        x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (x, f x) \\<le> (y, f y)", "apply (simp add: less_eq_prod_def less_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lookup_tabulate[simp]:\n  \"lookup (tabulate ks f) = (Some o f) |` toSet ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (tabulate ks f) = (Some \\<circ> f) |` toSet ks", "proof(induct ks rule: odlist_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>dxs.\n       dxs = ODList.empty \\<Longrightarrow>\n       lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs\n 2. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "case (empty dxs)"], ["proof (state)\nthis:\n  dxs = ODList.empty\n\ngoal (2 subgoals):\n 1. \\<And>dxs.\n       dxs = ODList.empty \\<Longrightarrow>\n       lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs\n 2. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "thus ?case"], ["proof (prove)\nusing this:\n  dxs = ODList.empty\n\ngoal (1 subgoal):\n 1. lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs", "unfolding tabulate_def lookup_def"], ["proof (prove)\nusing this:\n  dxs = ODList.empty\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> toList)\n     (ODList (map (\\<lambda>k. (k, f k)) (toList dxs))) =\n    (Some \\<circ> f) |` toSet dxs", "by (simp add: toList_ODList)"], ["proof (state)\nthis:\n  lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "case (insert dxs x xs)"], ["proof (state)\nthis:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "from insert"], ["proof (chain)\npicking this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)", "have \"map_of (List.map (\\<lambda>k. (k, f k)) xs) = map_of (msort (List.map (\\<lambda>k. (k, f k)) xs))\""], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>k. (k, f k)) xs) =\n    map_of (msort (map (\\<lambda>k. (k, f k)) xs))", "apply (subst msort_map)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> distinct xs\n 2. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> sorted xs\n 3. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>k. (k, f k)) (set xs)\n 4. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> order_class.mono_on (\\<lambda>k. (k, f k)) (set xs)\n 5. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> map_of (map (\\<lambda>k. (k, f k)) xs) =\n                      map_of (map (\\<lambda>k. (k, f k)) xs)", "apply (auto intro: inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dxs = fromList (x # xs);\n     lookup (tabulate (fromList xs) f) = (\\<lambda>a. Some (f a)) |` set xs;\n     x \\<notin> set xs; distinct xs; \\<forall>xa\\<in>set xs. x \\<le> xa;\n     sorted xs\\<rbrakk>\n    \\<Longrightarrow> order_class.mono_on (\\<lambda>k. (k, f k)) (set xs)", "apply (rule mono_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>dxs = fromList (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (\\<lambda>a. Some (f a)) |` set xs;\n        x \\<notin> set xs; distinct xs; \\<forall>xa\\<in>set xs. x \\<le> xa;\n        sorted xs; xa \\<in> set xs; y \\<in> set xs; xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (xa, f xa) \\<le> (y, f y)", "apply (simp add: less_eq_prod_def less_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  map_of (msort (map (\\<lambda>k. (k, f k)) xs))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "also"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  map_of (msort (map (\\<lambda>k. (k, f k)) xs))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "from insert"], ["proof (chain)\npicking this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)", "have \"... = lookup (tabulate (fromList xs) f)\""], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. map_of (msort (map (\\<lambda>k. (k, f k)) xs)) =\n    lookup (tabulate (fromList xs) f)", "unfolding tabulate_def lookup_def"], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  (map_of \\<circ> toList)\n   (ODList (map (\\<lambda>k. (k, f k)) (toList (fromList xs)))) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. map_of (msort (map (\\<lambda>k. (k, f k)) xs)) =\n    (map_of \\<circ> toList)\n     (ODList (map (\\<lambda>k. (k, f k)) (toList (fromList xs))))", "by (simp add: toList_ODList toList_fromList)"], ["proof (state)\nthis:\n  map_of (msort (map (\\<lambda>k. (k, f k)) xs)) =\n  lookup (tabulate (fromList xs) f)\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "also"], ["proof (state)\nthis:\n  map_of (msort (map (\\<lambda>k. (k, f k)) xs)) =\n  lookup (tabulate (fromList xs) f)\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "from insert"], ["proof (chain)\npicking this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)", "have \"... = (Some \\<circ> f) |` toSet (fromList xs)\""], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. lookup (tabulate (fromList xs) f) =\n    (Some \\<circ> f) |` toSet (fromList xs)", "by (simp only: toSet_fromList_set)"], ["proof (state)\nthis:\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "finally"], ["proof (chain)\npicking this:\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  (Some \\<circ> f) |` toSet (fromList xs)", "have IH: \"map_of (List.map (\\<lambda>k. (k, f k)) xs) = (Some \\<circ> f) |` toSet (fromList xs)\""], ["proof (prove)\nusing this:\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>k. (k, f k)) xs) =\n    (Some \\<circ> f) |` toSet (fromList xs)", "."], ["proof (state)\nthis:\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "from insert"], ["proof (chain)\npicking this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)", "have \"lookup (tabulate dxs f) = map_of (toList (ODList (List.map (\\<lambda>k. (k, f k)) (x # xs))))\""], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. lookup (tabulate dxs f) =\n    map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs))))", "unfolding tabulate_def lookup_def"], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  (map_of \\<circ> toList)\n   (ODList (map (\\<lambda>k. (k, f k)) (toList (fromList xs)))) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. (map_of \\<circ> toList)\n     (ODList (map (\\<lambda>k. (k, f k)) (toList dxs))) =\n    map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs))))", "by (simp add: toList_fromList)"], ["proof (state)\nthis:\n  lookup (tabulate dxs f) =\n  map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs))))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "also"], ["proof (state)\nthis:\n  lookup (tabulate dxs f) =\n  map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs))))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "have \"... = map_of (msort (List.map (\\<lambda>k. (k, f k)) (x # xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs)))) =\n    map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs)))", "by (simp only: toList_ODList)"], ["proof (state)\nthis:\n  map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs)))) =\n  map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "also"], ["proof (state)\nthis:\n  map_of (toList (ODList (map (\\<lambda>k. (k, f k)) (x # xs)))) =\n  map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "from insert"], ["proof (chain)\npicking this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)", "have \"... = map_of (List.map (\\<lambda>k. (k, f k)) (x # xs))\""], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n\ngoal (1 subgoal):\n 1. map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs))) =\n    map_of (map (\\<lambda>k. (k, f k)) (x # xs))", "apply (subst msort_map)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> distinct (x # xs)\n 2. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> sorted (x # xs)\n 3. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> inj_on (\\<lambda>k. (k, f k)) (set (x # xs))\n 4. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> order_class.mono_on (\\<lambda>k. (k, f k))\n                       (set (x # xs))\n 5. \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n     lookup (tabulate (fromList xs) f) =\n     (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n    \\<Longrightarrow> map_of (map (\\<lambda>k. (k, f k)) (x # xs)) =\n                      map_of (map (\\<lambda>k. (k, f k)) (x # xs))", "apply (auto intro: inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dxs = fromList (x # xs);\n     lookup (tabulate (fromList xs) f) = (\\<lambda>a. Some (f a)) |` set xs;\n     x \\<notin> set xs; distinct xs; \\<forall>xa\\<in>set xs. x \\<le> xa;\n     sorted xs\\<rbrakk>\n    \\<Longrightarrow> order_class.mono_on (\\<lambda>k. (k, f k))\n                       (insert x (set xs))", "apply (rule mono_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>dxs = fromList (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (\\<lambda>a. Some (f a)) |` set xs;\n        x \\<notin> set xs; distinct xs; \\<forall>xa\\<in>set xs. x \\<le> xa;\n        sorted xs; xa \\<in> insert x (set xs); y \\<in> insert x (set xs);\n        xa \\<le> y\\<rbrakk>\n       \\<Longrightarrow> (xa, f xa) \\<le> (y, f y)", "apply (simp add: less_eq_prod_def less_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs))) =\n  map_of (map (\\<lambda>k. (k, f k)) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "also"], ["proof (state)\nthis:\n  map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs))) =\n  map_of (map (\\<lambda>k. (k, f k)) (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "with insert IH"], ["proof (chain)\npicking this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n  map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs))) =\n  map_of (map (\\<lambda>k. (k, f k)) (x # xs))", "have \"... = (Some \\<circ> f) |` toSet dxs\""], ["proof (prove)\nusing this:\n  dxs = fromList (x # xs)\n  distinct (x # xs)\n  sorted (x # xs)\n  lookup (tabulate (fromList xs) f) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n  map_of (map (\\<lambda>k. (k, f k)) xs) =\n  (Some \\<circ> f) |` toSet (fromList xs)\n  map_of (msort (map (\\<lambda>k. (k, f k)) (x # xs))) =\n  map_of (map (\\<lambda>k. (k, f k)) (x # xs))\n\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>k. (k, f k)) (x # xs)) =\n    (Some \\<circ> f) |` toSet dxs", "by (auto simp add: restrict_map_def fun_eq_iff)"], ["proof (state)\nthis:\n  map_of (map (\\<lambda>k. (k, f k)) (x # xs)) =\n  (Some \\<circ> f) |` toSet dxs\n\ngoal (1 subgoal):\n 1. \\<And>dxs x xs.\n       \\<lbrakk>dxs = fromList (x # xs); distinct (x # xs); sorted (x # xs);\n        lookup (tabulate (fromList xs) f) =\n        (Some \\<circ> f) |` toSet (fromList xs)\\<rbrakk>\n       \\<Longrightarrow> lookup (tabulate dxs f) =\n                         (Some \\<circ> f) |` toSet dxs", "finally"], ["proof (chain)\npicking this:\n  lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs", "show ?case"], ["proof (prove)\nusing this:\n  lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs\n\ngoal (1 subgoal):\n 1. lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs", "."], ["proof (state)\nthis:\n  lookup (tabulate dxs f) = (Some \\<circ> f) |` toSet dxs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}