{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/List_local.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma partition_split:\n  shows \"set (fst (partition_split r x xs)) = set xs - (rel_ext r `` {x})\"\n    and \"set (snd (partition_split r x xs)) = set xs \\<inter> (rel_ext r `` {x})\"", "lemma partition_split':\n  assumes \"partition_split r x xs = (xxs', xec)\"\n  shows \"set xxs' = set xs - (rel_ext r `` {x})\"\n    and \"set xec = set xs \\<inter> (rel_ext r `` {x})\"", "lemma equiv_subseteq_in_sym:\n  \"\\<lbrakk> r `` X \\<subseteq> X;  (x, y) \\<in> r; y \\<in> X; equiv Y r; X \\<subseteq> Y \\<rbrakk> \\<Longrightarrow> x \\<in> X\"", "lemma FIXME_refl_on_insert_absorb[simp]:\n  \"\\<lbrakk> refl_on A r; x \\<in> A \\<rbrakk> \\<Longrightarrow> insert x (r `` {x}) = r `` {x}\"", "lemma equiv_subset[intro]:\n  \"\\<lbrakk> equiv A r; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> equiv B (r \\<inter> B \\<times> B)\"", "lemma FIXME_fiddle1: \"\\<lbrakk> x \\<in> Y; X \\<subseteq> Y; refl_on Y r \\<rbrakk> \\<Longrightarrow> insert x (X \\<inter> r `` {x}) = (insert x X) \\<inter> r `` {x}\"", "lemma FIXME_second_fiddle:\n  \"\\<lbrakk> (r \\<inter> Y \\<times> Y) `` X \\<subseteq> X; refl_on Z r; x \\<in> X; X \\<subseteq> Y; Y \\<subseteq> Z \\<rbrakk>\n     \\<Longrightarrow> (r \\<inter> (Y - (X - r `` {x})) \\<times> (Y - (X - r `` {x}))) `` {x}\n       = (r \\<inter> X \\<times> X) `` {x}\"", "lemma FIXME_third_fiddle:\n  \"\\<lbrakk> (r \\<inter> Y \\<times> Y) `` X \\<subseteq> X; X \\<subseteq> Y; x \\<in> X; y \\<in> Y - X    ;    r `` {y} \\<inter> X = {} \\<rbrakk>\n     \\<Longrightarrow> (r \\<inter> (Y - (X - r `` {x})) \\<times> (Y - (X - r `` {x}))) `` {y}\n       = (r \\<inter> (Y - X) \\<times> (Y - X)) `` {y}\"", "lemma partition_aux:\n  assumes equiv: \"equiv X (rel_ext r)\"\n      and XZ: \"set xs \\<subseteq> X\"\n  shows \"fst (partition_aux r xs) = []\n       \\<and> set ` set (snd (partition_aux r xs))\n       = (set xs // (rel_ext r \\<inter> set xs \\<times> set xs))\"", "lemma partition:\n  assumes equiv: \"equiv X (rel_ext r)\"\n      and xs: \"set xs \\<subseteq> X\"\n  shows \"set ` set (partition r xs) = set xs // ((rel_ext r) \\<inter> set xs \\<times> set xs)\"", "lemma equal_odlist_equal[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> odlist_equal xs ys \\<longleftrightarrow> (xs = ys)\"", "lemma set_difference[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> set (difference xs ys) = set xs - set ys\"", "lemma distinct_sorted_difference[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> distinct (difference xs ys) \\<and> sorted (difference xs ys)\"", "lemma set_intersection[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> set (intersection xs ys) = set xs \\<inter> set ys\"", "lemma distinct_sorted_intersection[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> distinct (intersection xs ys) \\<and> sorted (intersection xs ys)\"", "lemma set_image[simp]:\n  \"\\<lbrakk> distinct R; distinct xs; sorted R; sorted xs \\<rbrakk>\n     \\<Longrightarrow> set (image R xs) = set R `` set xs\"", "lemma sorted_filter[simp]:\n  \"sorted xs \\<Longrightarrow> sorted (filter P xs)\"", "lemma map_prod_eq:\n  assumes f: \"map fst xs = map fst ys\"\n      and s: \"map snd xs = map snd ys\"\n  shows \"xs = ys\"", "lemma list_choose_hd:\n  assumes \"\\<forall>x \\<in> set xs. P x\"\n      and \"x \\<in> set xs\"\n  shows \"P (List.hd xs)\""], "translations": [["", "lemma partition_split:\n  shows \"set (fst (partition_split r x xs)) = set xs - (rel_ext r `` {x})\"\n    and \"set (snd (partition_split r x xs)) = set xs \\<inter> (rel_ext r `` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x} &&&\n    set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}", "proof(induct xs)"], ["proof (state)\ngoal (4 subgoals):\n 1. set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n 2. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 4. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n 2. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 4. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "{"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n 2. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 4. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n 2. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 4. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "with Nil"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}", "unfolding partition_split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (fst (foldr (partition_split_body r x) [] ([], []))) =\n    set [] - rel_ext r `` {x}", "by simp"], ["proof (state)\nthis:\n  set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n\ngoal (3 subgoals):\n 1. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "}"], ["proof (state)\nthis:\n  set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n\ngoal (3 subgoals):\n 1. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "{"], ["proof (state)\nthis:\n  set (fst (partition_split r x [])) = set [] - rel_ext r `` {x}\n\ngoal (3 subgoals):\n 1. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 3. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "with Nil"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}", "unfolding partition_split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (snd (foldr (partition_split_body r x) [] ([], []))) =\n    set [] \\<inter> rel_ext r `` {x}", "by simp"], ["proof (state)\nthis:\n  set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "}"], ["proof (state)\nthis:\n  set (snd (partition_split r x [])) = set [] \\<inter> rel_ext r `` {x}\n\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "case (Cons x xs)"], ["proof (state)\nthis:\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}\n\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "{"], ["proof (state)\nthis:\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}\n\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_split r x (a # xs))) =\n                         set (a # xs) - rel_ext r `` {x}\n 2. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "with Cons"], ["proof (chain)\npicking this:\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}", "show ?case"], ["proof (prove)\nusing this:\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. set (fst (partition_split r x (x # xs))) =\n    set (x # xs) - rel_ext r `` {x}", "unfolding partition_split_def"], ["proof (prove)\nusing this:\n  set (fst (foldr (partition_split_body r x) xs ([], []))) =\n  set xs - rel_ext r `` {x}\n  set (snd (foldr (partition_split_body r x) xs ([], []))) =\n  set xs \\<inter> rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. set (fst (foldr (partition_split_body r x) (x # xs) ([], []))) =\n    set (x # xs) - rel_ext r `` {x}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n             set xs - rel_ext r `` {x};\n     set (snd (foldr (partition_split_body r x) xs ([], []))) =\n     set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n    \\<Longrightarrow> set (fst (partition_split_body r x x\n                                 (foldr (partition_split_body r x) xs\n                                   ([], [])))) =\n                      insert x (set xs) - rel_ext r `` {x}", "apply (subst partition_split_body_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n             set xs - rel_ext r `` {x};\n     set (snd (foldr (partition_split_body r x) xs ([], []))) =\n     set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n    \\<Longrightarrow> set (fst (case foldr (partition_split_body r x) xs\n([], []) of\n                                (X', xc) \\<Rightarrow>\n                                  if r (x, x) then (X', List.insert x xc)\n                                  else (List.insert x X', xc))) =\n                      insert x (set xs) - rel_ext r `` {x}", "apply (split prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n             set xs - rel_ext r `` {x};\n     set (snd (foldr (partition_split_body r x) xs ([], []))) =\n     set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x1 x2.\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         set (fst (if r (x, x) then (x1, List.insert x x2)\n                                   else (List.insert x x1, x2))) =\n                         insert x (set xs) - rel_ext r `` {x}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> (r (x, x) \\<longrightarrow>\n                          foldr (partition_split_body r x) xs ([], []) =\n                          (x1, x2) \\<longrightarrow>\n                          set x1 = set xs - rel_ext r `` {x}) \\<and>\n                         (\\<not> r (x, x) \\<longrightarrow>\n                          foldr (partition_split_body r x) xs ([], []) =\n                          (x1, x2) \\<longrightarrow>\n                          insert x (set x1) =\n                          insert x (set xs) - rel_ext r `` {x})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> r (x, x) \\<longrightarrow>\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         set x1 = set xs - rel_ext r `` {x}\n 2. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> r (x, x) \\<longrightarrow>\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         insert x (set x1) =\n                         insert x (set xs) - rel_ext r `` {x}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> r (x, x) \\<longrightarrow>\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         insert x (set x1) =\n                         insert x (set xs) - rel_ext r `` {x}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set x1 = set xs - rel_ext r `` {x};\n        set x2 = set xs \\<inter> rel_ext r `` {x}; \\<not> r (x, x);\n        foldr (partition_split_body r x) xs ([], []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> insert x (set xs - rel_ext r `` {x}) =\n                         insert x (set xs) - rel_ext r `` {x}", "unfolding Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set x1 =\n                set xs -\n                rel_ext\n                 (\\<lambda>y. \\<exists>x\\<in>{x}. (x, y) \\<in> rel_ext r);\n        set x2 =\n        set xs \\<inter>\n        rel_ext (\\<lambda>y. \\<exists>x\\<in>{x}. (x, y) \\<in> rel_ext r);\n        \\<not> r (x, x);\n        foldr (partition_split_body r x) xs ([], []) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> insert x\n                          (set xs -\n                           rel_ext\n                            (\\<lambda>y.\n                                \\<exists>x\\<in>{x}.\n                                   (x, y) \\<in> rel_ext r)) =\n                         insert x (set xs) -\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{x}. (x, y) \\<in> rel_ext r)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (fst (partition_split r x (x # xs))) = set (x # xs) - rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "}"], ["proof (state)\nthis:\n  set (fst (partition_split r x (x # xs))) = set (x # xs) - rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "{"], ["proof (state)\nthis:\n  set (fst (partition_split r x (x # xs))) = set (x # xs) - rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>set (fst (partition_split r x xs)) =\n                set xs - rel_ext r `` {x};\n        set (snd (partition_split r x xs)) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> set (snd (partition_split r x (a # xs))) =\n                         set (a # xs) \\<inter> rel_ext r `` {x}", "with Cons"], ["proof (chain)\npicking this:\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}", "show ?case"], ["proof (prove)\nusing this:\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. set (snd (partition_split r x (x # xs))) =\n    set (x # xs) \\<inter> rel_ext r `` {x}", "unfolding partition_split_def"], ["proof (prove)\nusing this:\n  set (fst (foldr (partition_split_body r x) xs ([], []))) =\n  set xs - rel_ext r `` {x}\n  set (snd (foldr (partition_split_body r x) xs ([], []))) =\n  set xs \\<inter> rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. set (snd (foldr (partition_split_body r x) (x # xs) ([], []))) =\n    set (x # xs) \\<inter> rel_ext r `` {x}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n             set xs - rel_ext r `` {x};\n     set (snd (foldr (partition_split_body r x) xs ([], []))) =\n     set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n    \\<Longrightarrow> set (snd (partition_split_body r x x\n                                 (foldr (partition_split_body r x) xs\n                                   ([], [])))) =\n                      insert x (set xs) \\<inter> rel_ext r `` {x}", "apply (subst partition_split_body_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n             set xs - rel_ext r `` {x};\n     set (snd (foldr (partition_split_body r x) xs ([], []))) =\n     set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n    \\<Longrightarrow> set (snd (case foldr (partition_split_body r x) xs\n([], []) of\n                                (X', xc) \\<Rightarrow>\n                                  if r (x, x) then (X', List.insert x xc)\n                                  else (List.insert x X', xc))) =\n                      insert x (set xs) \\<inter> rel_ext r `` {x}", "apply (split prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n             set xs - rel_ext r `` {x};\n     set (snd (foldr (partition_split_body r x) xs ([], []))) =\n     set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x1 x2.\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         set (snd (if r (x, x) then (x1, List.insert x x2)\n                                   else (List.insert x x1, x2))) =\n                         insert x (set xs) \\<inter> rel_ext r `` {x}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> (r (x, x) \\<longrightarrow>\n                          foldr (partition_split_body r x) xs ([], []) =\n                          (x1, x2) \\<longrightarrow>\n                          insert x (set x2) =\n                          insert x\n                           (set xs \\<inter> rel_ext r `` {x})) \\<and>\n                         (\\<not> r (x, x) \\<longrightarrow>\n                          foldr (partition_split_body r x) xs ([], []) =\n                          (x1, x2) \\<longrightarrow>\n                          set x2 = set xs \\<inter> rel_ext r `` {x})", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> r (x, x) \\<longrightarrow>\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         insert x (set x2) =\n                         insert x (set xs \\<inter> rel_ext r `` {x})\n 2. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> r (x, x) \\<longrightarrow>\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         set x2 = set xs \\<inter> rel_ext r `` {x}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>set (fst (foldr (partition_split_body r x) xs ([], []))) =\n                set xs - rel_ext r `` {x};\n        set (snd (foldr (partition_split_body r x) xs ([], []))) =\n        set xs \\<inter> rel_ext r `` {x}\\<rbrakk>\n       \\<Longrightarrow> \\<not> r (x, x) \\<longrightarrow>\n                         foldr (partition_split_body r x) xs ([], []) =\n                         (x1, x2) \\<longrightarrow>\n                         set x2 = set xs \\<inter> rel_ext r `` {x}", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (snd (partition_split r x (x # xs))) =\n  set (x # xs) \\<inter> rel_ext r `` {x}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  set (snd (partition_split r x (x # xs))) =\n  set (x # xs) \\<inter> rel_ext r `` {x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partition_split':\n  assumes \"partition_split r x xs = (xxs', xec)\"\n  shows \"set xxs' = set xs - (rel_ext r `` {x})\"\n    and \"set xec = set xs \\<inter> (rel_ext r `` {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xxs' = set xs - rel_ext r `` {x} &&&\n    set xec = set xs \\<inter> rel_ext r `` {x}", "using assms partition_split[where r=r and x=x and xs=xs]"], ["proof (prove)\nusing this:\n  partition_split r x xs = (xxs', xec)\n  set (fst (partition_split r x xs)) = set xs - rel_ext r `` {x}\n  set (snd (partition_split r x xs)) = set xs \\<inter> rel_ext r `` {x}\n\ngoal (1 subgoal):\n 1. set xxs' = set xs - rel_ext r `` {x} &&&\n    set xec = set xs \\<inter> rel_ext r `` {x}", "by simp_all"], ["", "text\\<open>Next, split an list on each of its members. For this to be\nunambiguous @{term \"r\"} must be an equivalence relation.\\<close>"], ["", "definition\n  partition_aux_body :: \"('a \\<times> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<times> 'a list list \\<Rightarrow> 'a list \\<times> 'a list list\"\nwhere\n  \"partition_aux_body \\<equiv> \\<lambda>r (xxs, ecs). case xxs of [] \\<Rightarrow> ([], []) | x # xs \\<Rightarrow>\n                           let (xxs', xec) = partition_split r x xs\n                            in (xxs', (x # xec) # ecs)\""], ["", "definition\n  partition_aux :: \"('a \\<times> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<times> 'a list list\"\nwhere\n  [code]: \"partition_aux r xs \\<equiv>\n             while (Not \\<circ> List.null \\<circ> fst) (partition_aux_body r) (xs, [])\""], ["", "(* FIXME move these. *)"], ["", "lemma equiv_subseteq_in_sym:\n  \"\\<lbrakk> r `` X \\<subseteq> X;  (x, y) \\<in> r; y \\<in> X; equiv Y r; X \\<subseteq> Y \\<rbrakk> \\<Longrightarrow> x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r `` X \\<subseteq> X; (x, y) \\<in> r; y \\<in> X; equiv Y r;\n     X \\<subseteq> Y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> X", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r `` X \\<subseteq> X; (x, y) \\<in> r; y \\<in> X;\n     refl_on Y r \\<and> sym r \\<and> trans r; X \\<subseteq> Y\\<rbrakk>\n    \\<Longrightarrow> x \\<in> X", "by (auto dest: symD)"], ["", "lemma FIXME_refl_on_insert_absorb[simp]:\n  \"\\<lbrakk> refl_on A r; x \\<in> A \\<rbrakk> \\<Longrightarrow> insert x (r `` {x}) = r `` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refl_on A r; x \\<in> A\\<rbrakk>\n    \\<Longrightarrow> insert x (r `` {x}) = r `` {x}", "by (auto dest: refl_onD)"], ["", "lemma equiv_subset[intro]:\n  \"\\<lbrakk> equiv A r; B \\<subseteq> A \\<rbrakk> \\<Longrightarrow> equiv B (r \\<inter> B \\<times> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv A r; B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> equiv B (Restr r B)", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refl_on A r \\<and> sym r \\<and> trans r;\n     B \\<subseteq> A\\<rbrakk>\n    \\<Longrightarrow> refl_on B (Restr r B) \\<and>\n                      sym (Restr r B) \\<and> trans (Restr r B)", "by (auto intro: refl_onI symI transI dest: refl_onD symD transD)"], ["", "lemma FIXME_fiddle1: \"\\<lbrakk> x \\<in> Y; X \\<subseteq> Y; refl_on Y r \\<rbrakk> \\<Longrightarrow> insert x (X \\<inter> r `` {x}) = (insert x X) \\<inter> r `` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Y; X \\<subseteq> Y; refl_on Y r\\<rbrakk>\n    \\<Longrightarrow> insert x (X \\<inter> r `` {x}) =\n                      insert x X \\<inter> r `` {x}", "by (auto dest: refl_onD)"], ["", "lemma FIXME_second_fiddle:\n  \"\\<lbrakk> (r \\<inter> Y \\<times> Y) `` X \\<subseteq> X; refl_on Z r; x \\<in> X; X \\<subseteq> Y; Y \\<subseteq> Z \\<rbrakk>\n     \\<Longrightarrow> (r \\<inter> (Y - (X - r `` {x})) \\<times> (Y - (X - r `` {x}))) `` {x}\n       = (r \\<inter> X \\<times> X) `` {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Restr r Y `` X \\<subseteq> X; refl_on Z r; x \\<in> X;\n     X \\<subseteq> Y; Y \\<subseteq> Z\\<rbrakk>\n    \\<Longrightarrow> Restr r (Y - (X - r `` {x})) `` {x} = Restr r X `` {x}", "by (blast dest: refl_onD)"], ["", "lemma FIXME_third_fiddle:\n  \"\\<lbrakk> (r \\<inter> Y \\<times> Y) `` X \\<subseteq> X; X \\<subseteq> Y; x \\<in> X; y \\<in> Y - X    ;    r `` {y} \\<inter> X = {} \\<rbrakk>\n     \\<Longrightarrow> (r \\<inter> (Y - (X - r `` {x})) \\<times> (Y - (X - r `` {x}))) `` {y}\n       = (r \\<inter> (Y - X) \\<times> (Y - X)) `` {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Restr r Y `` X \\<subseteq> X; X \\<subseteq> Y; x \\<in> X;\n     y \\<in> Y - X; r `` {y} \\<inter> X = {}\\<rbrakk>\n    \\<Longrightarrow> Restr r (Y - (X - r `` {x})) `` {y} =\n                      Restr r (Y - X) `` {y}", "by auto"], ["", "lemma partition_aux:\n  assumes equiv: \"equiv X (rel_ext r)\"\n      and XZ: \"set xs \\<subseteq> X\"\n  shows \"fst (partition_aux r xs) = []\n       \\<and> set ` set (snd (partition_aux r xs))\n       = (set xs // (rel_ext r \\<inter> set xs \\<times> set xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?b = \"Not \\<circ> List.null \\<circ> fst\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?c = \"partition_aux_body r\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?r' = \"\\<lambda>A. rel_ext r \\<inter> A \\<times> A\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?P1 = \"\\<lambda>(A, B). set A \\<subseteq> set xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?P2 = \"\\<lambda>(A, B). ?r' (set xs) `` set A \\<subseteq> set A\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?P3 = \"\\<lambda>(A, B). set ` set B = ((set xs - set A) // ?r' (set xs - set A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?P = \"\\<lambda>AB. ?P1 AB \\<and> ?P2 AB \\<and> ?P3 AB\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "let ?wfr = \"inv_image finite_psubset (set \\<circ> fst)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (partition_aux r xs) = [] \\<and>\n    set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "unfolding partition_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (while (Not \\<circ> List.null \\<circ> fst) (partition_aux_body r)\n          (xs, [])) =\n    [] \\<and>\n    set `\n    set (snd (while (Not \\<circ> List.null \\<circ> fst)\n               (partition_aux_body r) (xs, []))) =\n    set xs // Restr (rel_ext r) (set xs)", "proof(rule while_rule[where P=\"?P\" and r=\"?wfr\"])"], ["proof (state)\ngoal (5 subgoals):\n 1. (case (xs, []) of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n    (case (xs, []) of\n     (A, B) \\<Rightarrow>\n       Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n    (case (xs, []) of\n     (A, B) \\<Rightarrow>\n       set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 4. wf (inv_image finite_psubset (set \\<circ> fst))\n 5. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from equiv XZ"], ["proof (chain)\npicking this:\n  equiv X (rel_ext r)\n  set xs \\<subseteq> X", "show \"?P (xs, [])\""], ["proof (prove)\nusing this:\n  equiv X (rel_ext r)\n  set xs \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (case (xs, []) of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n    (case (xs, []) of\n     (A, B) \\<Rightarrow>\n       Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n    (case (xs, []) of\n     (A, B) \\<Rightarrow>\n       set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))", "by auto"], ["proof (state)\nthis:\n  (case (xs, []) of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case (xs, []) of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case (xs, []) of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "fix s"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "assume P: \"?P s\" and b: \"?b s\""], ["proof (state)\nthis:\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "obtain A B where s: \"s = (A, B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A B. s = (A, B) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s) blast"], ["proof (state)\nthis:\n  s = (A, B)\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "moreover"], ["proof (state)\nthis:\n  s = (A, B)\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from XZ P s"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  s = (A, B)", "have \"?P1 (?c (A, B))\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  s = (A, B)\n\ngoal (1 subgoal):\n 1. case partition_aux_body r (A, B) of\n    (A, B) \\<Rightarrow> set A \\<subseteq> set xs", "unfolding partition_aux_body_def"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  s = (A, B)\n\ngoal (1 subgoal):\n 1. case case (A, B) of ([], ecs) \\<Rightarrow> ([], [])\n         | (x # xs, ecs) \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # ecs) of\n    (A, B) \\<Rightarrow> set A \\<subseteq> set xs", "by (auto simp add: partition_split' split: list.split prod.split)"], ["proof (state)\nthis:\n  case partition_aux_body r (A, B) of\n  (A, B) \\<Rightarrow> set A \\<subseteq> set xs\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "moreover"], ["proof (state)\nthis:\n  case partition_aux_body r (A, B) of\n  (A, B) \\<Rightarrow> set A \\<subseteq> set xs\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from equiv XZ P s"], ["proof (chain)\npicking this:\n  equiv X (rel_ext r)\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  s = (A, B)", "have \"?P2 (?c s)\""], ["proof (prove)\nusing this:\n  equiv X (rel_ext r)\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  s = (A, B)\n\ngoal (1 subgoal):\n 1. case partition_aux_body r s of\n    (A, B) \\<Rightarrow>\n      Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A", "apply (cases A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n     (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n     (case s of\n      (A, B) \\<Rightarrow>\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n     (case s of\n      (A, B) \\<Rightarrow>\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n     s = (A, B); A = []\\<rbrakk>\n    \\<Longrightarrow> case partition_aux_body r s of\n                      (A, B) \\<Rightarrow>\n                        Restr (rel_ext r) (set xs) `` set A\n                        \\<subseteq> set A\n 2. \\<And>a list.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           set ` set B =\n           (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        s = (A, B); A = a # list\\<rbrakk>\n       \\<Longrightarrow> case partition_aux_body r s of\n                         (A, B) \\<Rightarrow>\n                           Restr (rel_ext r) (set xs) `` set A\n                           \\<subseteq> set A", "unfolding partition_aux_body_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n     (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n     (case s of\n      (A, B) \\<Rightarrow>\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n     (case s of\n      (A, B) \\<Rightarrow>\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n     s = (A, B); A = []\\<rbrakk>\n    \\<Longrightarrow> case case s of ([], ecs) \\<Rightarrow> ([], [])\n                           | (x # xs, ecs) \\<Rightarrow>\n                               let (xxs', xec) = partition_split r x xs\n                               in (xxs', (x # xec) # ecs) of\n                      (A, B) \\<Rightarrow>\n                        Restr (rel_ext r) (set xs) `` set A\n                        \\<subseteq> set A\n 2. \\<And>a list.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           set ` set B =\n           (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        s = (A, B); A = a # list\\<rbrakk>\n       \\<Longrightarrow> case case s of ([], ecs) \\<Rightarrow> ([], [])\n                              | (x # xs, ecs) \\<Rightarrow>\n                                  let (xxs', xec) = partition_split r x xs\n                                  in (xxs', (x # xec) # ecs) of\n                         (A, B) \\<Rightarrow>\n                           Restr (rel_ext r) (set xs) `` set A\n                           \\<subseteq> set A", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        a \\<in> set xs \\<and>\n        set list \\<subseteq> set xs \\<and>\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list) \\<and>\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        s = (a # list, B); A = a # list\\<rbrakk>\n       \\<Longrightarrow> case case partition_split r a list of\n                              (xxs', xec) \\<Rightarrow>\n                                (xxs', (a # xec) # B) of\n                         (A, B) \\<Rightarrow>\n                           Restr (rel_ext r) (set xs) `` set A\n                           \\<subseteq> set A", "subgoal for a as"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n     a \\<in> set xs \\<and>\n     set as \\<subseteq> set xs \\<and>\n     Restr (rel_ext r) (set xs) `` insert a (set as)\n     \\<subseteq> insert a (set as) \\<and>\n     set ` set B =\n     (set xs - insert a (set as)) //\n     Restr (rel_ext r) (set xs - insert a (set as));\n     s = (a # as, B); A = a # as\\<rbrakk>\n    \\<Longrightarrow> case case partition_split r a as of\n                           (xxs', xec) \\<Rightarrow>\n                             (xxs', (a # xec) # B) of\n                      (A, B) \\<Rightarrow>\n                        Restr (rel_ext r) (set xs) `` set A\n                        \\<subseteq> set A", "apply (cases \"partition_split r a as\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        a \\<in> set xs \\<and>\n        set as \\<subseteq> set xs \\<and>\n        Restr (rel_ext r) (set xs) `` insert a (set as)\n        \\<subseteq> insert a (set as) \\<and>\n        set ` set B =\n        (set xs - insert a (set as)) //\n        Restr (rel_ext r) (set xs - insert a (set as));\n        s = (a # as, B); A = a # as;\n        partition_split r a as = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> case case partition_split r a as of\n                              (xxs', xec) \\<Rightarrow>\n                                (xxs', (a # xec) # B) of\n                         (A, B) \\<Rightarrow>\n                           Restr (rel_ext r) (set xs) `` set A\n                           \\<subseteq> set A", "apply (simp add: partition_split')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        a \\<in> set xs \\<and>\n        set as \\<subseteq> set xs \\<and>\n        Restr (rel_ext r) (set xs) `` insert a (set as)\n        \\<subseteq> insert a (set as) \\<and>\n        set ` set B =\n        (set xs - insert a (set as)) //\n        Restr (rel_ext r) (set xs - insert a (set as));\n        s = (a # as, B); A = a # as;\n        partition_split r a as = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs) ``\n                         (set as - rel_ext r `` {a})\n                         \\<subseteq> set as - rel_ext r `` {a}", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>refl_on X (rel_ext r) \\<and>\n                sym (rel_ext r) \\<and> trans (rel_ext r);\n        set xs \\<subseteq> X;\n        a \\<in> set xs \\<and>\n        set as \\<subseteq> set xs \\<and>\n        Restr (rel_ext r) (set xs) `` insert a (set as)\n        \\<subseteq> insert a (set as) \\<and>\n        set ` set B =\n        (set xs - insert a (set as)) //\n        Restr (rel_ext r) (set xs - insert a (set as));\n        s = (a # as, B); A = a # as;\n        partition_split r a as = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs) ``\n                         (set as - rel_ext r `` {a})\n                         \\<subseteq> set as - rel_ext r `` {a}", "apply (auto dest: symD transD elim: quotientE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow> Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "moreover"], ["proof (state)\nthis:\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow> Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "have \"?P3 (?c s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case partition_aux_body r s of\n    (A, B) \\<Rightarrow>\n      set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. case partition_aux_body r s of\n    (A, B) \\<Rightarrow>\n      set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)", "from b s"], ["proof (chain)\npicking this:\n  (Not \\<circ> List.null \\<circ> fst) s\n  s = (A, B)", "obtain x where x: \"x \\<in> set A\""], ["proof (prove)\nusing this:\n  (Not \\<circ> List.null \\<circ> fst) s\n  s = (A, B)\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> set A \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases A) (auto iff: null_def)"], ["proof (state)\nthis:\n  x \\<in> set A\n\ngoal (1 subgoal):\n 1. case partition_aux_body r s of\n    (A, B) \\<Rightarrow>\n      set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)", "with XZ equiv P b s x"], ["proof (chain)\npicking this:\n  set xs \\<subseteq> X\n  equiv X (rel_ext r)\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s\n  s = (A, B)\n  x \\<in> set A\n  x \\<in> set A", "show ?thesis"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X\n  equiv X (rel_ext r)\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s\n  s = (A, B)\n  x \\<in> set A\n  x \\<in> set A\n\ngoal (1 subgoal):\n 1. case partition_aux_body r s of\n    (A, B) \\<Rightarrow>\n      set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)", "unfolding partition_aux_body_def"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X\n  equiv X (rel_ext r)\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s\n  s = (A, B)\n  x \\<in> set A\n  x \\<in> set A\n\ngoal (1 subgoal):\n 1. case case s of ([], ecs) \\<Rightarrow> ([], [])\n         | (x # xs, ecs) \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # ecs) of\n    (A, B) \\<Rightarrow>\n      set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba.\n       \\<lbrakk>set xs \\<subseteq> X; equiv X (rel_ext r);\n        \\<not> List.null A; s = (A, B); x \\<in> set A;\n        (case A of [] \\<Rightarrow> ([], [])\n         | x # xs \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # B)) =\n        (Aa, Ba);\n        set A \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A;\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A)\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply (erule equivE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null A; s = (A, B);\n        x \\<in> set A;\n        (case A of [] \\<Rightarrow> ([], [])\n         | x # xs \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # B)) =\n        (Aa, Ba);\n        set A \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A;\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A);\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r)\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply (cases A)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa Ba.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null A; s = (A, B);\n        x \\<in> set A;\n        (case A of [] \\<Rightarrow> ([], [])\n         | x # xs \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # B)) =\n        (Aa, Ba);\n        set A \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A;\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A);\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = []\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)\n 2. \\<And>Aa Ba a list.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null A; s = (A, B);\n        x \\<in> set A;\n        (case A of [] \\<Rightarrow> ([], [])\n         | x # xs \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # B)) =\n        (Aa, Ba);\n        set A \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A;\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A);\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba a list.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null A; s = (A, B);\n        x \\<in> set A;\n        (case A of [] \\<Rightarrow> ([], [])\n         | x # xs \\<Rightarrow>\n             let (xxs', xec) = partition_split r x xs\n             in (xxs', (x # xec) # B)) =\n        (Aa, Ba);\n        set A \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A;\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A);\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba a list.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        (case partition_split r a list of\n         (xxs', xec) \\<Rightarrow> (xxs', (a # xec) # B)) =\n        (Aa, Ba);\n        a \\<in> set xs \\<and> set list \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply (case_tac \"partition_split r a list\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa Ba a list aa b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        (case partition_split r a list of\n         (xxs', xec) \\<Rightarrow> (xxs', (a # xec) # B)) =\n        (Aa, Ba);\n        a \\<in> set xs \\<and> set list \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> set ` set Ba =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert (insert a (set b))\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r)\n                            (set xs - insert a (set list))) =\n                         (set xs - set Aa) //\n                         Restr (rel_ext r) (set xs - set Aa)", "apply (simp add: partition_split')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (insert a (set list \\<inter> rel_ext r `` {a}))\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r)\n                            (set xs - insert a (set list))) =\n                         (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))", "apply (subst FIXME_fiddle1[where Y=X])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> a \\<in> X\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> set list \\<subseteq> X\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> refl_on X (rel_ext r)\n 4. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (insert a (set list) \\<inter> rel_ext r `` {a})\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r)\n                            (set xs - insert a (set list))) =\n                         (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> set list \\<subseteq> X\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> refl_on X (rel_ext r)\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (insert a (set list) \\<inter> rel_ext r `` {a})\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r)\n                            (set xs - insert a (set list))) =\n                         (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> refl_on X (rel_ext r)\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (insert a (set list) \\<inter> rel_ext r `` {a})\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r)\n                            (set xs - insert a (set list))) =\n                         (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (insert a (set list) \\<inter> rel_ext r `` {a})\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r)\n                            (set xs - insert a (set list))) =\n                         (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (insert a (set list) \\<inter> rel_ext r `` {a})\n                          ((set xs - insert a (set list)) //\n                           Restr (rel_ext r) (set xs - insert a (set list)))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a}\n                         \\<in> (set xs - (set list - rel_ext r `` {a})) //\n                               Restr (rel_ext r)\n                                (set xs -\n                                 (set list - rel_ext r `` {a})) \\<and>\n                         (set xs - insert a (set list)) //\n                         Restr (rel_ext r) (set xs - insert a (set list))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a}\n                         \\<in> (set xs - (set list - rel_ext r `` {a})) //\n                               Restr (rel_ext r)\n                                (set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - insert a (set list)) //\n                         Restr (rel_ext r) (set xs - insert a (set list))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (rule_tac x=a in quotientI2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set xs - (set list - rel_ext r `` {a})\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a} =\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {a}\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - insert a (set list)) //\n                         Restr (rel_ext r) (set xs - insert a (set list))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 4. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (blast dest: refl_onD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a} =\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {a}\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - insert a (set list)) //\n                         Restr (rel_ext r) (set xs - insert a (set list))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "using XZ"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> X\n\ngoal (3 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a} =\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {a}\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - insert a (set list)) //\n                         Restr (rel_ext r) (set xs - insert a (set list))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (auto dest: refl_onD)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - insert a (set list)) //\n                         Restr (rel_ext r) (set xs - insert a (set list))\n                         \\<subseteq> (set xs -\n(set list - rel_ext r `` {a})) //\n                                     Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa \\<in> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (set xs -\n                                   (set list - rel_ext r `` {a})) //\n                                  Restr (rel_ext r)\n                                   (set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (erule quotientE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xaa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa = Restr (rel_ext r) (set xs - insert a (set list)) `` {xaa};\n        xaa \\<in> set xs - insert a (set list)\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> (set xs -\n                                   (set list - rel_ext r `` {a})) //\n                                  Restr (rel_ext r)\n                                   (set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs - insert a (set list)) ``\n                         {xa}\n                         \\<in> (set xs - (set list - rel_ext r `` {a})) //\n                               Restr (rel_ext r)\n                                (set xs - (set list - rel_ext r `` {a}))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (rule_tac x=xa in quotientI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> set xs - (set list - rel_ext r `` {a})\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs - insert a (set list)) ``\n                         {xa} =\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa}\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (blast dest: refl_onD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs - insert a (set list)) ``\n                         {xa} =\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa}\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs - insert a (set list)) ``\n                         {xa}\n                         \\<subseteq> Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a})) ``\n                                     {xa}\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa}\n                         \\<subseteq> Restr (rel_ext r)\n(set xs - insert a (set list)) ``\n                                     {xa}\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<in> set xs; xa \\<noteq> a;\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa}\n                         \\<subseteq> Restr (rel_ext r)\n(set xs - insert a (set list)) ``\n                                     {xa}\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<noteq> a \\<and> xb \\<notin> set list\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<noteq> a\n 2. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb); xb = a\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (cut_tac X=\"insert a (set list)\" and Y=\"set xs\" and x=xa and y=a and r=\"rel_ext r \\<inter> set xs \\<times> set xs\" in equiv_subseteq_in_sym)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs) `` insert a (set list)\n                         \\<subseteq> insert a (set list)\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> (xa, a) \\<in> Restr (rel_ext r) (set xs)\n 3. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> insert a (set list)\n 4. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> equiv (set xs) (Restr (rel_ext r) (set xs))\n 5. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<subseteq> set xs\n 6. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a);\n        xa \\<in> insert a (set list)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 8. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> equiv (set xs) (Restr (rel_ext r) (set xs))\n 2. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "using equiv"], ["proof (prove)\nusing this:\n  equiv X (rel_ext r)\n\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, a); xa \\<in> set xs;\n        a \\<in> set list \\<longrightarrow> r (a, a)\\<rbrakk>\n       \\<Longrightarrow> equiv (set xs) (Restr (rel_ext r) (set xs))\n 2. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 3. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs;\n        xb \\<in> set list \\<longrightarrow> r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<notin> set list\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (cut_tac X=\"insert a (set list)\" and Y=\"set xs\" and x=xa and y=xb and r=\"rel_ext r \\<inter> set xs \\<times> set xs\" in equiv_subseteq_in_sym)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r) (set xs) `` insert a (set list)\n                         \\<subseteq> insert a (set list)\n 2. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> (xa, xb) \\<in> Restr (rel_ext r) (set xs)\n 3. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> insert a (set list)\n 4. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> equiv (set xs) (Restr (rel_ext r) (set xs))\n 5. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<subseteq> set xs\n 6. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb); xa \\<in> insert a (set list)\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> equiv (set xs) (Restr (rel_ext r) (set xs))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "using equiv"], ["proof (prove)\nusing this:\n  equiv X (rel_ext r)\n\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xb.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<notin> set list;\n        r (xa, xb); xa \\<in> set xs; xb \\<in> set xs; xb \\<in> set list;\n        r (a, xb)\\<rbrakk>\n       \\<Longrightarrow> equiv (set xs) (Restr (rel_ext r) (set xs))\n 2. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs\\<rbrakk>\n       \\<Longrightarrow> (set xs - (set list - rel_ext r `` {a})) //\n                         Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a}))\n                         \\<subseteq> insert\n(insert a (set list) \\<inter> rel_ext r `` {a})\n((set xs - insert a (set list)) //\n Restr (rel_ext r) (set xs - insert a (set list)))", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa \\<in> (set xs - (set list - rel_ext r `` {a})) //\n                 Restr (rel_ext r)\n                  (set xs - (set list - rel_ext r `` {a}))\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> insert\n                                   (insert a (set list) \\<inter>\n                                    rel_ext r `` {a})\n                                   ((set xs - insert a (set list)) //\n                                    Restr (rel_ext r)\n                                     (set xs - insert a (set list)))", "apply (erule quotientE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa xaa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa =\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xaa};\n        xaa \\<in> set xs - (set list - rel_ext r `` {a})\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> insert\n                                   (insert a (set list) \\<inter>\n                                    rel_ext r `` {a})\n                                   ((set xs - insert a (set list)) //\n                                    Restr (rel_ext r)\n                                     (set xs - insert a (set list)))", "apply (case_tac \"xaa = a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa xaa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa =\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xaa};\n        xaa \\<in> set xs - (set list - rel_ext r `` {a}); xaa = a\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> insert\n                                   (insert a (set list) \\<inter>\n                                    rel_ext r `` {a})\n                                   ((set xs - insert a (set list)) //\n                                    Restr (rel_ext r)\n                                     (set xs - insert a (set list)))\n 2. \\<And>Aa a list b xa xaa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa =\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xaa};\n        xaa \\<in> set xs - (set list - rel_ext r `` {a});\n        xaa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> insert\n                                   (insert a (set list) \\<inter>\n                                    rel_ext r `` {a})\n                                   ((set xs - insert a (set list)) //\n                                    Restr (rel_ext r)\n                                     (set xs - insert a (set list)))", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa xaa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs;\n        xa =\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xaa};\n        xaa \\<in> set xs - (set list - rel_ext r `` {a});\n        xaa \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> insert\n                                   (insert a (set list) \\<inter>\n                                    rel_ext r `` {a})\n                                   ((set xs - insert a (set list)) //\n                                    Restr (rel_ext r)\n                                     (set xs - insert a (set list)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list))\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply (case_tac \"xa \\<in> set list\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa}\n                         \\<subseteq> insert a (set list) \\<inter>\n                                     rel_ext r `` {a}\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a}\n                         \\<subseteq> Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a})) ``\n                                     {xa}\n 3. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply (auto dest: transD)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> insert a (set list) \\<inter> rel_ext r `` {a}\n                         \\<subseteq> Restr (rel_ext r)\n(set xs - (set list - rel_ext r `` {a})) ``\n                                     {xa}\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply (auto dest: symD transD)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (set xs - insert a (set list)) //\n        Restr (rel_ext r) (set xs - insert a (set list));\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (set xs - insert a (set list)) //\n                 Restr (rel_ext r) (set xs - insert a (set list));\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "unfolding quotient_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {Restr (rel_ext r) (set xs - insert a (set list)) `` {x}});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<in> set list \\<longrightarrow> r (a, xa);\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) `` {xa}\n        \\<notin> (\\<Union>x\\<in>set xs - insert a (set list).\n                     {Restr (rel_ext r) (set xs - insert a (set list)) ``\n                      {x}});\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {Restr (rel_ext r) (set xs - insert a (set list)) `` {x}});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        \\<forall>x\\<in>set xs - insert a (set list).\n           Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) ``\n           {xa} \\<noteq>\n           Restr (rel_ext r) (set xs - insert a (set list)) `` {x};\n        xa \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "apply (erule_tac x=xa in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {Restr (rel_ext r) (set xs - insert a (set list)) `` {x}});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<notin> set list;\n        Restr (rel_ext r) (set xs - (set list - rel_ext r `` {a})) ``\n        {xa} \\<noteq>\n        Restr (rel_ext r) (set xs - insert a (set list)) `` {xa}\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        Restr (rel_ext r) (set xs) `` insert a (set list)\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {Restr (rel_ext r) (set xs - insert a (set list)) `` {x}});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<notin> set list;\n        xa \\<notin> set xs - insert a (set list)\\<rbrakk>\n       \\<Longrightarrow> Restr (rel_ext r)\n                          (set xs - (set list - rel_ext r `` {a})) ``\n                         {xa} =\n                         insert a (set list) \\<inter> rel_ext r `` {a}", "unfolding Image_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        rel_ext\n         (\\<lambda>y.\n             \\<exists>x\\<in>insert a (set list).\n                (x, y) \\<in> Restr (rel_ext r) (set xs))\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {rel_ext\n              (\\<lambda>y.\n                  \\<exists>x\\<in>{x}.\n                     (x, y)\n                     \\<in> Restr (rel_ext r)\n                            (set xs - insert a (set list)))});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<notin> set list;\n        rel_ext\n         (\\<lambda>y.\n             \\<exists>x\\<in>{xa}.\n                (x, y)\n                \\<in> Restr (rel_ext r)\n                       (set xs -\n                        (set list -\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{a}.\n                                 (x, y) \\<in> rel_ext r)))) \\<noteq>\n        rel_ext\n         (\\<lambda>y.\n             \\<exists>x\\<in>{xa}.\n                (x, y)\n                \\<in> Restr (rel_ext r)\n                       (set xs - insert a (set list)))\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{xa}.\n                                 (x, y)\n                                 \\<in> Restr (rel_ext r)\n  (set xs -\n   (set list -\n    rel_ext (\\<lambda>y. \\<exists>x\\<in>{a}. (x, y) \\<in> rel_ext r)))) =\n                         insert a (set list) \\<inter>\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{a}. (x, y) \\<in> rel_ext r)\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        rel_ext\n         (\\<lambda>y.\n             \\<exists>x\\<in>insert a (set list).\n                (x, y) \\<in> Restr (rel_ext r) (set xs))\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {rel_ext\n              (\\<lambda>y.\n                  \\<exists>x\\<in>{x}.\n                     (x, y)\n                     \\<in> Restr (rel_ext r)\n                            (set xs - insert a (set list)))});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<notin> set list;\n        xa \\<notin> set xs - insert a (set list)\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{xa}.\n                                 (x, y)\n                                 \\<in> Restr (rel_ext r)\n  (set xs -\n   (set list -\n    rel_ext (\\<lambda>y. \\<exists>x\\<in>{a}. (x, y) \\<in> rel_ext r)))) =\n                         insert a (set list) \\<inter>\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{a}. (x, y) \\<in> rel_ext r)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        rel_ext\n         (\\<lambda>y.\n             r (a, y) \\<and> y \\<in> set xs \\<or>\n             (\\<exists>x\\<in>set list.\n                 r (x, y) \\<and> x \\<in> set xs \\<and> y \\<in> set xs))\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {rel_ext\n              (\\<lambda>y.\n                  r (x, y) \\<and>\n                  y \\<in> set xs \\<and>\n                  y \\<noteq> a \\<and> y \\<notin> set list)});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<notin> set list;\n        rel_ext\n         (\\<lambda>y.\n             r (xa, y) \\<and>\n             y \\<in> set xs \\<and>\n             (y \\<in> set list \\<longrightarrow> r (a, y))) \\<noteq>\n        rel_ext\n         (\\<lambda>y.\n             r (xa, y) \\<and>\n             y \\<in> set xs \\<and>\n             y \\<noteq> a \\<and> y \\<notin> set list)\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>y.\n                              r (xa, y) \\<and>\n                              y \\<in> set xs \\<and>\n                              (y \\<in> set list \\<longrightarrow>\n                               r (a, y))) =\n                         insert a (set list) \\<inter>\n                         rel_ext (\\<lambda>y. r (a, y))\n 2. \\<And>Aa a list b xa.\n       \\<lbrakk>set xs \\<subseteq> X; \\<not> List.null (a # list);\n        s = (a # list, B); x = a \\<or> x \\<in> set list;\n        rel_ext\n         (\\<lambda>y.\n             \\<exists>x\\<in>insert a (set list).\n                (x, y) \\<in> Restr (rel_ext r) (set xs))\n        \\<subseteq> insert a (set list);\n        set ` set B =\n        (\\<Union>x\\<in>set xs - insert a (set list).\n            {rel_ext\n              (\\<lambda>y.\n                  \\<exists>x\\<in>{x}.\n                     (x, y)\n                     \\<in> Restr (rel_ext r)\n                            (set xs - insert a (set list)))});\n        refl_on X (rel_ext r); sym (rel_ext r); trans (rel_ext r);\n        A = a # list; partition_split r a list = (Aa, b); a \\<in> set xs;\n        set list \\<subseteq> set xs; xa \\<noteq> a; xa \\<in> set xs;\n        xa \\<notin> set list;\n        xa \\<notin> set xs - insert a (set list)\\<rbrakk>\n       \\<Longrightarrow> rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{xa}.\n                                 (x, y)\n                                 \\<in> Restr (rel_ext r)\n  (set xs -\n   (set list -\n    rel_ext (\\<lambda>y. \\<exists>x\\<in>{a}. (x, y) \\<in> rel_ext r)))) =\n                         insert a (set list) \\<inter>\n                         rel_ext\n                          (\\<lambda>y.\n                              \\<exists>x\\<in>{a}. (x, y) \\<in> rel_ext r)", "apply (auto dest: symD transD)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* SLOW *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow>\n    set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow>\n    set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)\n\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set A \\<subseteq> set xs) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            Restr (rel_ext r) (set xs) `` set A\n                            \\<subseteq> set A) \\<and>\n                         (case partition_aux_body r s of\n                          (A, B) \\<Rightarrow>\n                            set ` set B =\n                            (set xs - set A) //\n                            Restr (rel_ext r) (set xs - set A))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 3. wf (inv_image finite_psubset (set \\<circ> fst))\n 4. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "ultimately"], ["proof (chain)\npicking this:\n  s = (A, B)\n  case partition_aux_body r (A, B) of\n  (A, B) \\<Rightarrow> set A \\<subseteq> set xs\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow> Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow>\n    set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)", "show \"?P (?c s)\""], ["proof (prove)\nusing this:\n  s = (A, B)\n  case partition_aux_body r (A, B) of\n  (A, B) \\<Rightarrow> set A \\<subseteq> set xs\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow> Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A\n  case partition_aux_body r s of\n  (A, B) \\<Rightarrow>\n    set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A)\n\ngoal (1 subgoal):\n 1. (case partition_aux_body r s of\n     (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n    (case partition_aux_body r s of\n     (A, B) \\<Rightarrow>\n       Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n    (case partition_aux_body r s of\n     (A, B) \\<Rightarrow>\n       set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))", "by auto"], ["proof (state)\nthis:\n  (case partition_aux_body r s of\n   (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case partition_aux_body r s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case partition_aux_body r s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 2. wf (inv_image finite_psubset (set \\<circ> fst))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 2. wf (inv_image finite_psubset (set \\<circ> fst))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 2. wf (inv_image finite_psubset (set \\<circ> fst))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "assume P: \"?P s\" and b: \"\\<not> (?b s)\""], ["proof (state)\nthis:\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  \\<not> (Not \\<circ> List.null \\<circ> fst) s\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 2. wf (inv_image finite_psubset (set \\<circ> fst))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from b"], ["proof (chain)\npicking this:\n  \\<not> (Not \\<circ> List.null \\<circ> fst) s", "have F: \"fst s = []\""], ["proof (prove)\nusing this:\n  \\<not> (Not \\<circ> List.null \\<circ> fst) s\n\ngoal (1 subgoal):\n 1. fst s = []", "apply (cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<not> (Not \\<circ> List.null \\<circ> fst) s;\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fst s = []", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>List.null a; s = (a, b)\\<rbrakk> \\<Longrightarrow> a = []", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>List.null a; s = (a, b); a = []\\<rbrakk>\n       \\<Longrightarrow> a = []\n 2. \\<And>a b aa list.\n       \\<lbrakk>List.null a; s = (a, b); a = aa # list\\<rbrakk>\n       \\<Longrightarrow> a = []", "apply (simp_all add: List.null_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fst s = []\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 2. wf (inv_image finite_psubset (set \\<circ> fst))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from equiv P F"], ["proof (chain)\npicking this:\n  equiv X (rel_ext r)\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  fst s = []", "have S: \"set ` set (snd s) = (set xs // ?r' (set xs))\""], ["proof (prove)\nusing this:\n  equiv X (rel_ext r)\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  fst s = []\n\ngoal (1 subgoal):\n 1. set ` set (snd s) = set xs // Restr (rel_ext r) (set xs)", "apply (cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r);\n        (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           set ` set B =\n           (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        fst s = []; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)", "unfolding Image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r);\n        (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           rel_ext\n            (\\<lambda>y.\n                \\<exists>x\\<in>set A.\n                   (x, y) \\<in> Restr (rel_ext r) (set xs))\n           \\<subseteq> set A) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           set ` set B =\n           (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        fst s = []; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set ` set (snd s) = set xs // Restr (rel_ext r) (set xs)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        \\<not> (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> fst s = [] \\<and>\n                         set ` set (snd s) =\n                         set xs // Restr (rel_ext r) (set xs)\n 2. wf (inv_image finite_psubset (set \\<circ> fst))\n 3. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from F S"], ["proof (chain)\npicking this:\n  fst s = []\n  set ` set (snd s) = set xs // Restr (rel_ext r) (set xs)", "show \"fst s = [] \\<and> set ` set (snd s) = (set xs // ?r' (set xs))\""], ["proof (prove)\nusing this:\n  fst s = []\n  set ` set (snd s) = set xs // Restr (rel_ext r) (set xs)\n\ngoal (1 subgoal):\n 1. fst s = [] \\<and>\n    set ` set (snd s) = set xs // Restr (rel_ext r) (set xs)", "by (simp add: prod_eqI)"], ["proof (state)\nthis:\n  fst s = [] \\<and> set ` set (snd s) = set xs // Restr (rel_ext r) (set xs)\n\ngoal (2 subgoals):\n 1. wf (inv_image finite_psubset (set \\<circ> fst))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (inv_image finite_psubset (set \\<circ> fst))\n 2. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "show \"wf ?wfr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image finite_psubset (set \\<circ> fst))", "by (blast intro: wf_finite_psubset Int_lower2 [THEN [2] wf_subset])"], ["proof (state)\nthis:\n  wf (inv_image finite_psubset (set \\<circ> fst))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "assume P: \"?P s\" and b: \"?b s\""], ["proof (state)\nthis:\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "from equiv XZ P b"], ["proof (chain)\npicking this:\n  equiv X (rel_ext r)\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s", "have \"set (fst (?c s)) \\<subset> set (fst s)\""], ["proof (prove)\nusing this:\n  equiv X (rel_ext r)\n  set xs \\<subseteq> X\n  (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n  (case s of\n   (A, B) \\<Rightarrow>\n     set ` set B = (set xs - set A) // Restr (rel_ext r) (set xs - set A))\n  (Not \\<circ> List.null \\<circ> fst) s\n\ngoal (1 subgoal):\n 1. set (fst (partition_aux_body r s)) \\<subset> set (fst s)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n     (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n     (case s of\n      (A, B) \\<Rightarrow>\n        Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n     (case s of\n      (A, B) \\<Rightarrow>\n        set ` set B =\n        (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n     (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n    \\<Longrightarrow> set (fst (partition_aux_body r s))\n                      \\<subset> set (fst s)", "apply (cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        (case s of (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           Restr (rel_ext r) (set xs) `` set A \\<subseteq> set A) \\<and>\n        (case s of\n         (A, B) \\<Rightarrow>\n           set ` set B =\n           (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_aux_body r s))\n                         \\<subset> set (fst s)", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        set a \\<subseteq> set xs \\<and>\n        Restr (rel_ext r) (set xs) `` set a \\<subseteq> set a \\<and>\n        set ` set b =\n        (set xs - set a) // Restr (rel_ext r) (set xs - set a);\n        \\<not> List.null a; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> set (fst (partition_aux_body r (a, b)))\n                         \\<subset> set a", "unfolding partition_aux_body_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        set a \\<subseteq> set xs \\<and>\n        Restr (rel_ext r) (set xs) `` set a \\<subseteq> set a \\<and>\n        set ` set b =\n        (set xs - set a) // Restr (rel_ext r) (set xs - set a);\n        \\<not> List.null a; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> set (fst (case (a, b) of\n                                   ([], ecs) \\<Rightarrow> ([], [])\n                                   | (x # xs, ecs) \\<Rightarrow>\n let (xxs', xec) = partition_split r x xs in (xxs', (x # xec) # ecs)))\n                         \\<subset> set a", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null a; s = (a, b); set a \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set a \\<subseteq> set a;\n        set ` set b =\n        (set xs - set a) // Restr (rel_ext r) (set xs - set a)\\<rbrakk>\n       \\<Longrightarrow> set (fst (case a of [] \\<Rightarrow> ([], [])\n                                   | x # xs \\<Rightarrow>\n let (xxs', xec) = partition_split r x xs in (xxs', (x # xec) # b)))\n                         \\<subset> set a", "apply (case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null a; s = (a, b); set a \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set a \\<subseteq> set a;\n        set ` set b =\n        (set xs - set a) // Restr (rel_ext r) (set xs - set a);\n        a = []\\<rbrakk>\n       \\<Longrightarrow> set (fst (case a of [] \\<Rightarrow> ([], [])\n                                   | x # xs \\<Rightarrow>\n let (xxs', xec) = partition_split r x xs in (xxs', (x # xec) # b)))\n                         \\<subset> set a\n 2. \\<And>a b aa list.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null a; s = (a, b); set a \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set a \\<subseteq> set a;\n        set ` set b =\n        (set xs - set a) // Restr (rel_ext r) (set xs - set a);\n        a = aa # list\\<rbrakk>\n       \\<Longrightarrow> set (fst (case a of [] \\<Rightarrow> ([], [])\n                                   | x # xs \\<Rightarrow>\n let (xxs', xec) = partition_split r x xs in (xxs', (x # xec) # b)))\n                         \\<subset> set a", "apply (simp add: List.null_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null a; s = (a, b); set a \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` set a \\<subseteq> set a;\n        set ` set b =\n        (set xs - set a) // Restr (rel_ext r) (set xs - set a);\n        a = aa # list\\<rbrakk>\n       \\<Longrightarrow> set (fst (case a of [] \\<Rightarrow> ([], [])\n                                   | x # xs \\<Rightarrow>\n let (xxs', xec) = partition_split r x xs in (xxs', (x # xec) # b)))\n                         \\<subset> set a", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null (aa # list); s = (aa # list, b);\n        aa \\<in> set xs \\<and> set list \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` insert aa (set list)\n        \\<subseteq> insert aa (set list);\n        set ` set b =\n        (set xs - insert aa (set list)) //\n        Restr (rel_ext r) (set xs - insert aa (set list));\n        a = aa # list\\<rbrakk>\n       \\<Longrightarrow> set (fst (case partition_split r aa list of\n                                   (xxs', xec) \\<Rightarrow>\n                                     (xxs', (aa # xec) # b)))\n                         \\<subset> insert aa (set list)", "apply (case_tac \"partition_split r aa list\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list ab ba.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null (aa # list); s = (aa # list, b);\n        aa \\<in> set xs \\<and> set list \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` insert aa (set list)\n        \\<subseteq> insert aa (set list);\n        set ` set b =\n        (set xs - insert aa (set list)) //\n        Restr (rel_ext r) (set xs - insert aa (set list));\n        a = aa # list; partition_split r aa list = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> set (fst (case partition_split r aa list of\n                                   (xxs', xec) \\<Rightarrow>\n                                     (xxs', (aa # xec) # b)))\n                         \\<subset> insert aa (set list)", "apply (simp add: partition_split')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list ab ba.\n       \\<lbrakk>equiv X (rel_ext r); set xs \\<subseteq> X;\n        \\<not> List.null (aa # list); s = (aa # list, b);\n        aa \\<in> set xs \\<and> set list \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` insert aa (set list)\n        \\<subseteq> insert aa (set list);\n        set ` set b =\n        (set xs - insert aa (set list)) //\n        Restr (rel_ext r) (set xs - insert aa (set list));\n        a = aa # list; partition_split r aa list = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> set list - rel_ext r `` {aa}\n                         \\<subset> insert aa (set list)", "unfolding equiv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa list ab ba.\n       \\<lbrakk>refl_on X (rel_ext r) \\<and>\n                sym (rel_ext r) \\<and> trans (rel_ext r);\n        set xs \\<subseteq> X; \\<not> List.null (aa # list);\n        s = (aa # list, b);\n        aa \\<in> set xs \\<and> set list \\<subseteq> set xs;\n        Restr (rel_ext r) (set xs) `` insert aa (set list)\n        \\<subseteq> insert aa (set list);\n        set ` set b =\n        (set xs - insert aa (set list)) //\n        Restr (rel_ext r) (set xs - insert aa (set list));\n        a = aa # list; partition_split r aa list = (ab, ba)\\<rbrakk>\n       \\<Longrightarrow> set list - rel_ext r `` {aa}\n                         \\<subset> insert aa (set list)", "apply (auto dest: refl_onD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set (fst (partition_aux_body r s)) \\<subset> set (fst s)\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>(case s of\n                 (A, B) \\<Rightarrow> set A \\<subseteq> set xs) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   Restr (rel_ext r) (set xs) `` set A\n                   \\<subseteq> set A) \\<and>\n                (case s of\n                 (A, B) \\<Rightarrow>\n                   set ` set B =\n                   (set xs - set A) // Restr (rel_ext r) (set xs - set A));\n        (Not \\<circ> List.null \\<circ> fst) s\\<rbrakk>\n       \\<Longrightarrow> (partition_aux_body r s, s)\n                         \\<in> inv_image finite_psubset (set \\<circ> fst)", "thus \"(?c s, s) \\<in> ?wfr\""], ["proof (prove)\nusing this:\n  set (fst (partition_aux_body r s)) \\<subset> set (fst s)\n\ngoal (1 subgoal):\n 1. (partition_aux_body r s, s)\n    \\<in> inv_image finite_psubset (set \\<circ> fst)", "by auto"], ["proof (state)\nthis:\n  (partition_aux_body r s, s)\n  \\<in> inv_image finite_psubset (set \\<circ> fst)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (partition_aux r xs) = [] \\<and>\n  set ` set (snd (partition_aux r xs)) =\n  set xs // Restr (rel_ext r) (set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  partition :: \"('a \\<times> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list list\"\nwhere\n  [code]: \"partition r xs \\<equiv> snd (partition_aux r xs)\""], ["", "lemma partition:\n  assumes equiv: \"equiv X (rel_ext r)\"\n      and xs: \"set xs \\<subseteq> X\"\n  shows \"set ` set (partition r xs) = set xs // ((rel_ext r) \\<inter> set xs \\<times> set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ` set (List_local.partition r xs) =\n    set xs // Restr (rel_ext r) (set xs)", "unfolding partition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "using partition_aux[OF equiv xs]"], ["proof (prove)\nusing this:\n  fst (partition_aux r xs) = [] \\<and>\n  set ` set (snd (partition_aux r xs)) =\n  set xs // Restr (rel_ext r) (set xs)\n\ngoal (1 subgoal):\n 1. set ` set (snd (partition_aux r xs)) =\n    set xs // Restr (rel_ext r) (set xs)", "by simp"], ["", "(* **************************************** *)"], ["", "fun\n  odlist_equal :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nwhere\n  \"odlist_equal [] [] = True\"\n| \"odlist_equal [] ys = False\"\n| \"odlist_equal xs [] = False\"\n| \"odlist_equal (x # xs) (y # ys) = (x = y \\<and> odlist_equal xs ys)\""], ["", "declare odlist_equal.simps [code]"], ["", "lemma equal_odlist_equal[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> odlist_equal xs ys \\<longleftrightarrow> (xs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; distinct ys; sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> odlist_equal xs ys = (xs = ys)", "by (induct xs ys rule: odlist_equal.induct) (auto)"], ["", "fun\n  difference :: \"('a :: linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"difference [] ys = []\"\n| \"difference xs [] = xs\"\n| \"difference (x # xs) (y # ys) =\n     (if x = y then difference xs ys\n               else if x < y then x # difference xs (y # ys)\n                             else difference (x # xs) ys)\""], ["", "declare difference.simps [code]"], ["", "lemma set_difference[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> set (difference xs ys) = set xs - set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; distinct ys; sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> set (difference xs ys) = set xs - set ys", "by (induct xs ys rule: difference.induct) (auto)"], ["", "lemma distinct_sorted_difference[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> distinct (difference xs ys) \\<and> sorted (difference xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; distinct ys; sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> distinct (difference xs ys) \\<and>\n                      sorted (difference xs ys)", "by (induct xs ys rule: difference.induct) (auto)"], ["", "fun\n  intersection :: \"('a :: linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"intersection [] ys = []\"\n| \"intersection xs [] = []\"\n| \"intersection (x # xs) (y # ys) =\n     (if x = y then x # intersection xs ys\n               else if x < y then intersection xs (y # ys)\n                             else intersection (x # xs) ys)\""], ["", "declare intersection.simps [code]"], ["", "lemma set_intersection[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> set (intersection xs ys) = set xs \\<inter> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; distinct ys; sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> set (intersection xs ys) = set xs \\<inter> set ys", "by (induct xs ys rule: intersection.induct) (auto)"], ["", "lemma distinct_sorted_intersection[simp]:\n  \"\\<lbrakk> distinct xs; distinct ys; sorted xs; sorted ys \\<rbrakk>\n     \\<Longrightarrow> distinct (intersection xs ys) \\<and> sorted (intersection xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; distinct ys; sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> distinct (intersection xs ys) \\<and>\n                      sorted (intersection xs ys)", "by (induct xs ys rule: intersection.induct) (auto)"], ["", "(* This is a variant of zipWith *)"], ["", "fun\n  image :: \"('a :: linorder \\<times> 'b :: linorder) list \\<Rightarrow> 'a list \\<Rightarrow> 'b list\"\nwhere\n  \"image [] xs = []\"\n| \"image R []  = []\"\n| \"image ((x, y) # rs) (z # zs) =\n     (if x = z then y # image rs (z # zs)\n               else if x < z then image rs (z # zs)\n                             else image ((x, y) # rs) zs)\""], ["", "declare image.simps [code]"], ["", "lemma set_image[simp]:\n  \"\\<lbrakk> distinct R; distinct xs; sorted R; sorted xs \\<rbrakk>\n     \\<Longrightarrow> set (image R xs) = set R `` set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct R; distinct xs; sorted R; sorted xs\\<rbrakk>\n    \\<Longrightarrow> set (List_local.image R xs) = set R `` set xs", "by (induct R xs rule: image.induct) (auto iff: less_eq_prod_def)"], ["", "(* Extra lemmas that really belong in List.thy *)"], ["", "lemma sorted_filter[simp]:\n  \"sorted xs \\<Longrightarrow> sorted (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted xs \\<Longrightarrow> sorted (filter P xs)", "by (induct xs) (auto)"], ["", "lemma map_prod_eq:\n  assumes f: \"map fst xs = map fst ys\"\n      and s: \"map snd xs = map snd ys\"\n  shows \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "using assms"], ["proof (prove)\nusing this:\n  map fst xs = map fst ys\n  map snd xs = map snd ys\n\ngoal (1 subgoal):\n 1. xs = ys", "by (fact pair_list_eqI)"], ["", "lemma list_choose_hd:\n  assumes \"\\<forall>x \\<in> set xs. P x\"\n      and \"x \\<in> set xs\"\n  shows \"P (List.hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (hd xs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. P x\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. P (hd xs)", "by (induct xs arbitrary: x) auto"], ["", "end"]]}