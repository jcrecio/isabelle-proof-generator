{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/KBPsAlg.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma k_isNode_cong:\n  \"simAbs ec' = simAbs ec \\<Longrightarrow> k_isNode ec' \\<longleftrightarrow> k_isNode ec\"", "lemma alg_MapOps_empty[simp]:\n  \"k_isNode ec \\<Longrightarrow> lookup aOps (empty aOps) ec = None\"\n  \"k_isNode (fst k) \\<Longrightarrow> lookup tOps (empty tOps) k = None\"", "lemma alg_aOps_lookup_update[simp]:\n  \"\\<lbrakk> k_isNode ec; k_isNode ec' \\<rbrakk> \\<Longrightarrow> lookup aOps (update aOps ec e M) ec' = (if simAbs ec' = simAbs ec then Some e else lookup aOps M ec')\"", "lemma alg_tOps_lookup_update[simp]:\n  \"\\<lbrakk> k_isNode (fst k); k_isNode (fst k') \\<rbrakk> \\<Longrightarrow> lookup tOps (update tOps k e M) k' = (if (simAbs (fst k'), snd k') = (simAbs (fst k), snd k) then Some e else lookup tOps M k')\"", "lemma k_succs_is_node[intro, simp]:\n  assumes x: \"k_isNode x\"\n  shows \"list_all k_isNode (k_succs x)\"", "lemma k_memb_empt[simp]:\n  \"k_isNode x \\<Longrightarrow> \\<not>k_memb x k_empt\"", "lemma k_invariantI[intro]:\n  \"\\<lbrakk> \\<And>ec ec'. \\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec \\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec';\n     \\<And>ec ec' obs. \\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec \\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) = lookup tOps (aTrans A) (ec', obs);\n     \\<And>ec. \\<lbrakk> k_isNode ec; k_memb ec A \\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts. lookup aOps (aActs A) ec = Some acts \\<and> set acts = set (simAction a ec);\n     \\<And>ec obs ecs'. \\<lbrakk> k_isNode ec; k_memb ec A; obs \\<in> simObs a ` set (simTrans a ec) \\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'. lookup tOps (aTrans A) (ec, obs) = Some ec'\n               \\<and> simAbs ec' \\<in> simAbs ` set (simTrans a ec)\n               \\<and> simObs a ec' = obs \\<rbrakk>\n  \\<Longrightarrow> k_invariant A\"", "lemma k_invariantAOD:\n  \"\\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec; k_invariant A \\<rbrakk>\n     \\<Longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec'\"", "lemma k_invariantTOD:\n  \"\\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec; k_invariant A \\<rbrakk>\n     \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) = lookup tOps (aTrans A) (ec', obs)\"", "lemma k_invariantAD:\n  \"\\<lbrakk> k_isNode ec; k_memb ec A; k_invariant A \\<rbrakk>\n     \\<Longrightarrow> \\<exists>acts. lookup aOps (aActs A) ec = Some acts \\<and> set acts = set (simAction a ec)\"", "lemma k_invariantTD:\n  \"\\<lbrakk> k_isNode ec; k_memb ec A; obs \\<in> simObs a ` set (simTrans a ec); k_invariant A \\<rbrakk>\n     \\<Longrightarrow> \\<exists>ec'. lookup tOps (aTrans A) (ec, obs) = Some ec'\n             \\<and> simAbs ec' \\<in> simAbs ` set (simTrans a ec)\n             \\<and> simObs a ec' = obs\"", "lemma k_invariant_empt[simp]:\n  \"k_invariant k_empt\"", "lemma k_invariant_step_new_aux:\n  assumes X: \"set X \\<subseteq> set (k_succs x)\"\n      and x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and ec': \"simAbs ec' \\<in> simAbs ` set X\"\n      and S: \"simAbs ec = simAbs x\"\n  shows \"\\<exists>r. lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r\n           \\<and> simAbs r \\<in> simAbs ` set (k_succs ec)\n           \\<and> simObs a r = simObs a ec'\"", "lemma k_invariant_step_new:\n  assumes x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and ec': \"ec' \\<in> set (k_succs ec)\"\n      and S: \"simAbs ec = simAbs x\"\n  shows \"\\<exists>ec''. lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') = Some ec''\n              \\<and> simAbs ec'' \\<in> simAbs ` set (k_succs ec)\n              \\<and> simObs a ec'' = simObs a ec'\"", "lemma k_invariant_step_old_aux:\n  assumes x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and S: \"simAbs ec \\<noteq> simAbs x\"\n  shows \"lookup tOps (foldr (transUpdate x) X Y) (ec, obs)\n       = lookup tOps Y (ec, obs)\"", "lemma k_invariant_step_old:\n  assumes x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and S: \"simAbs ec \\<noteq> simAbs x\"\n  shows \"lookup tOps (aTrans (k_ins x A)) (ec, obs)\n       = lookup tOps (aTrans A) (ec, obs)\"", "lemma k_invariant_frame:\n  assumes B: \"lookup tOps Y (ec, obs) = lookup tOps Y (ec', obs)\"\n      and x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and ec': \"k_isNode ec'\"\n      and S: \"simAbs ec' = simAbs ec\"\n  shows \"lookup tOps (foldr (transUpdate x) X Y) (ec, obs) = lookup tOps (foldr (transUpdate x) X Y) (ec', obs)\"", "lemma k_invariant_step[simp]:\n  assumes N: \"k_isNode x\"\n      and I: \"k_invariant A\"\n      and M: \"\\<not> k_memb x A\"\n  shows \"k_invariant (k_ins x A)\"", "lemma k_frontier_is_node[intro, simp]:\n  \"list_all k_isNode (k_frontier a)\"", "lemma mkAutoSim_simps[simp]:\n  \"pInit (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a) = simInit a\"\n  \"pTrans (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a)\n = (\\<lambda>obs ec. the (lookup tOps (aTrans (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a) (frontier a))) (ec, obs)))\"\n  \"pAct (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a)\n = (\\<lambda>ec. the (lookup aOps (aActs (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a) (frontier a))) ec))\"", "lemma k_dfs_gen_dfs_unfold[simp]:\n  \"k_dfs = gen_dfs k_succs k_ins k_memb k_empt (k_frontier a)\"", "lemma k_dfs_invariant: \"k_invariant k_dfs\"", "lemma k_reachable:\n  \"simAbs ` KBPAlg.reachable (set (k_frontier a)) = sim_equiv_class a ` jkbpC\"\n(*<*)(is \"?lhs = ?rhs\")", "lemma k_memb_rep:\n  assumes N: \"k_isNode rec\"\n  shows \"k_memb rec k_dfs\"", "lemma k_mkAlgAuto_mkAutoSim_equiv:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\"", "lemma k_mkAlgAuto_ec:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\"", "lemma k_mkAlgAuto_mkAutoSim_act_eq:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"set \\<circ> actJP k_mkAlgAuto t = set \\<circ> actJP mkAutoSim t\"", "theorem k_mkAlgAuto_implements: \"implements k_mkAlgAuto\""], "translations": [["", "lemma k_isNode_cong:\n  \"simAbs ec' = simAbs ec \\<Longrightarrow> k_isNode ec' \\<longleftrightarrow> k_isNode ec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs ec \\<Longrightarrow> k_isNode ec' = k_isNode ec", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs ec \\<Longrightarrow>\n    (simAbs ec' \\<in> sim_equiv_class a ` jkbpC) =\n    (simAbs ec \\<in> sim_equiv_class a ` jkbpC)", "by simp"], ["", "lemma alg_MapOps_empty[simp]:\n  \"k_isNode ec \\<Longrightarrow> lookup aOps (empty aOps) ec = None\"\n  \"k_isNode (fst k) \\<Longrightarrow> lookup tOps (empty tOps) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k_isNode ec \\<Longrightarrow>\n     lookup aOps (MapOps.empty aOps) ec = None) &&&\n    (k_isNode (fst k) \\<Longrightarrow>\n     lookup tOps (MapOps.empty tOps) k = None)", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (simAbs ec \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n     lookup aOps (MapOps.empty aOps) ec = None) &&&\n    (simAbs (fst k) \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n     lookup tOps (MapOps.empty tOps) k = None)", "using MapOps_emptyD[OF _ aOps] MapOps_emptyD[OF _ tOps]"], ["proof (prove)\nusing this:\n  simAbs ?k \\<in> (\\<Union>a. sim_equiv_class a ` jkbpC) \\<Longrightarrow>\n  lookup aOps (MapOps.empty aOps) ?k = None\n  (simAbs (fst ?k), snd ?k)\n  \\<in> (\\<Union>a. sim_equiv_class a ` jkbpC) \\<times>\n        UNIV \\<Longrightarrow>\n  lookup tOps (MapOps.empty tOps) ?k = None\n\ngoal (1 subgoal):\n 1. (simAbs ec \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n     lookup aOps (MapOps.empty aOps) ec = None) &&&\n    (simAbs (fst k) \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n     lookup tOps (MapOps.empty tOps) k = None)", "by blast+"], ["", "lemma alg_aOps_lookup_update[simp]:\n  \"\\<lbrakk> k_isNode ec; k_isNode ec' \\<rbrakk> \\<Longrightarrow> lookup aOps (update aOps ec e M) ec' = (if simAbs ec' = simAbs ec then Some e else lookup aOps M ec')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_isNode ec'\\<rbrakk>\n    \\<Longrightarrow> lookup aOps (update aOps ec e M) ec' =\n                      (if simAbs ec' = simAbs ec then Some e\n                       else lookup aOps M ec')", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simAbs ec \\<in> sim_equiv_class a ` jkbpC;\n     simAbs ec' \\<in> sim_equiv_class a ` jkbpC\\<rbrakk>\n    \\<Longrightarrow> lookup aOps (update aOps ec e M) ec' =\n                      (if simAbs ec' = simAbs ec then Some e\n                       else lookup aOps M ec')", "using MapOps_lookup_updateD[OF _ _ aOps]"], ["proof (prove)\nusing this:\n  \\<lbrakk>simAbs ?k \\<in> (\\<Union>a. sim_equiv_class a ` jkbpC);\n   simAbs ?k' \\<in> (\\<Union>a. sim_equiv_class a ` jkbpC)\\<rbrakk>\n  \\<Longrightarrow> lookup aOps (update aOps ?k ?e ?M) ?k' =\n                    (if simAbs ?k' = simAbs ?k then Some ?e\n                     else lookup aOps ?M ?k')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>simAbs ec \\<in> sim_equiv_class a ` jkbpC;\n     simAbs ec' \\<in> sim_equiv_class a ` jkbpC\\<rbrakk>\n    \\<Longrightarrow> lookup aOps (update aOps ec e M) ec' =\n                      (if simAbs ec' = simAbs ec then Some e\n                       else lookup aOps M ec')", "by blast"], ["", "lemma alg_tOps_lookup_update[simp]:\n  \"\\<lbrakk> k_isNode (fst k); k_isNode (fst k') \\<rbrakk> \\<Longrightarrow> lookup tOps (update tOps k e M) k' = (if (simAbs (fst k'), snd k') = (simAbs (fst k), snd k) then Some e else lookup tOps M k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode (fst k); k_isNode (fst k')\\<rbrakk>\n    \\<Longrightarrow> lookup tOps (update tOps k e M) k' =\n                      (if (simAbs (fst k'), snd k') =\n                          (simAbs (fst k), snd k)\n                       then Some e else lookup tOps M k')", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simAbs (fst k) \\<in> sim_equiv_class a ` jkbpC;\n     simAbs (fst k') \\<in> sim_equiv_class a ` jkbpC\\<rbrakk>\n    \\<Longrightarrow> lookup tOps (update tOps k e M) k' =\n                      (if (simAbs (fst k'), snd k') =\n                          (simAbs (fst k), snd k)\n                       then Some e else lookup tOps M k')", "using MapOps_lookup_updateD[OF _ _ tOps]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(simAbs (fst ?k), snd ?k)\n           \\<in> (\\<Union>a. sim_equiv_class a ` jkbpC) \\<times> UNIV;\n   (simAbs (fst ?k'), snd ?k')\n   \\<in> (\\<Union>a. sim_equiv_class a ` jkbpC) \\<times> UNIV\\<rbrakk>\n  \\<Longrightarrow> lookup tOps (update tOps ?k ?e ?M) ?k' =\n                    (if (simAbs (fst ?k'), snd ?k') =\n                        (simAbs (fst ?k), snd ?k)\n                     then Some ?e else lookup tOps ?M ?k')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>simAbs (fst k) \\<in> sim_equiv_class a ` jkbpC;\n     simAbs (fst k') \\<in> sim_equiv_class a ` jkbpC\\<rbrakk>\n    \\<Longrightarrow> lookup tOps (update tOps k e M) k' =\n                      (if (simAbs (fst k'), snd k') =\n                          (simAbs (fst k), snd k)\n                       then Some e else lookup tOps M k')", "by blast"], ["", "lemma k_succs_is_node[intro, simp]:\n  assumes x: \"k_isNode x\"\n  shows \"list_all k_isNode (k_succs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all k_isNode (k_succs x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_all k_isNode (k_succs x)", "from x"], ["proof (chain)\npicking this:\n  k_isNode x", "obtain t\n    where tC: \"t \\<in> jkbpC\"\n      and sx: \"simAbs x = sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  k_isNode x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> jkbpC; simAbs x = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding k_isNode_def"], ["proof (prove)\nusing this:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> jkbpC; simAbs x = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. list_all k_isNode (k_succs x)", "have F: \"\\<And>y. y \\<in> set (k_succs x) \\<Longrightarrow> simAbs y \\<in> simAbs ` set (k_succs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> set (k_succs x) \\<Longrightarrow>\n       simAbs y \\<in> simAbs ` set (k_succs x)", "by simp"], ["proof (state)\nthis:\n  ?y11 \\<in> set (k_succs x) \\<Longrightarrow>\n  simAbs ?y11 \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. list_all k_isNode (k_succs x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all k_isNode (k_succs x)", "using simTrans[rule_format, where a=a and t=t] tC sx"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (k_succs ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. list_all k_isNode (k_succs x)", "unfolding k_isNode_def [abs_def]"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (k_succs ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>ec. simAbs ec \\<in> sim_equiv_class a ` jkbpC)\n     (k_succs x)", "apply (auto iff: list_all_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ec.\n       \\<lbrakk>\\<And>ec.\n                   simAbs ec = sim_equiv_class a t \\<Longrightarrow>\n                   simAbs ` set (k_succs ec) =\n                   {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n                    t' \\<leadsto> s \\<in> jkbpC \\<and>\n                    jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs x = sim_equiv_class a t;\n        ec \\<in> set (k_succs x)\\<rbrakk>\n       \\<Longrightarrow> simAbs ec \\<in> sim_equiv_class a ` jkbpC", "apply (frule F)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ec.\n       \\<lbrakk>\\<And>ec.\n                   simAbs ec = sim_equiv_class a t \\<Longrightarrow>\n                   simAbs ` set (k_succs ec) =\n                   {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n                    t' \\<leadsto> s \\<in> jkbpC \\<and>\n                    jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs x = sim_equiv_class a t;\n        ec \\<in> set (k_succs x);\n        simAbs ec \\<in> simAbs ` set (k_succs x)\\<rbrakk>\n       \\<Longrightarrow> simAbs ec \\<in> sim_equiv_class a ` jkbpC", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_all k_isNode (k_succs x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma k_memb_empt[simp]:\n  \"k_isNode x \\<Longrightarrow> \\<not>k_memb x k_empt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_isNode x \\<Longrightarrow> \\<not> k_memb x k_empt", "unfolding k_memb_def k_empt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_isNode x \\<Longrightarrow>\n    \\<not> isSome\n            (lookup aOps\n              (aActs\n                \\<lparr>aActs = MapOps.empty aOps,\n                   aTrans = MapOps.empty tOps\\<rparr>)\n              x)", "by simp"], ["", "(*>*)"], ["", "subsubsection\\<open>Algorithm invariant\\<close>"], ["", "text\\<open>\n\nThe invariant for the automata construction is straightforward, viz\nthat at each step of the process the state represents an automaton\nthat concords with @{term \"mkAutoSim\"} on the visited equivalence\nclasses. We also need to know that the state has preserved the @{term\n\"MapOps\"} invariants.\n\n\\<close>"], ["", "definition k_invariant :: \"('ma, 'mt) AlgState \\<Rightarrow> bool\" where\n  \"k_invariant A \\<equiv>\n      (\\<forall>ec ec'. k_isNode ec \\<and> k_isNode ec' \\<and> simAbs ec' = simAbs ec\n        \\<longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec')\n    \\<and> (\\<forall>ec ec' obs. k_isNode ec \\<and> k_isNode ec' \\<and> simAbs ec' = simAbs ec\n        \\<longrightarrow> lookup tOps (aTrans A) (ec, obs) = lookup tOps (aTrans A) (ec', obs))\n    \\<and> (\\<forall>ec. k_isNode ec \\<and> k_memb ec A\n        \\<longrightarrow> (\\<exists>acts. lookup aOps (aActs A) ec = Some acts\n                   \\<and> set acts = set (simAction a ec)))\n    \\<and> (\\<forall>ec obs. k_isNode ec \\<and> k_memb ec A\n              \\<and> obs \\<in> simObs a ` set (simTrans a ec)\n        \\<longrightarrow> (\\<exists>ec'. lookup tOps (aTrans A) (ec, obs) = Some ec'\n                  \\<and> simAbs ec' \\<in> simAbs ` set (simTrans a ec)\n                  \\<and> simObs a ec' = obs))\""], ["", "(*<*)"], ["", "lemma k_invariantI[intro]:\n  \"\\<lbrakk> \\<And>ec ec'. \\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec \\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec';\n     \\<And>ec ec' obs. \\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec \\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) = lookup tOps (aTrans A) (ec', obs);\n     \\<And>ec. \\<lbrakk> k_isNode ec; k_memb ec A \\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts. lookup aOps (aActs A) ec = Some acts \\<and> set acts = set (simAction a ec);\n     \\<And>ec obs ecs'. \\<lbrakk> k_isNode ec; k_memb ec A; obs \\<in> simObs a ` set (simTrans a ec) \\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'. lookup tOps (aTrans A) (ec, obs) = Some ec'\n               \\<and> simAbs ec' \\<in> simAbs ` set (simTrans a ec)\n               \\<and> simObs a ec' = obs \\<rbrakk>\n  \\<Longrightarrow> k_invariant A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ec ec'.\n                \\<lbrakk>k_isNode ec; k_isNode ec';\n                 simAbs ec' = simAbs ec\\<rbrakk>\n                \\<Longrightarrow> lookup aOps (aActs A) ec =\n                                  lookup aOps (aActs A) ec';\n     \\<And>ec ec' obs.\n        \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n        \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) =\n                          lookup tOps (aTrans A) (ec', obs);\n     \\<And>ec.\n        \\<lbrakk>k_isNode ec; k_memb ec A\\<rbrakk>\n        \\<Longrightarrow> \\<exists>acts.\n                             lookup aOps (aActs A) ec = Some acts \\<and>\n                             set acts = set (simAction a ec);\n     \\<And>ec obs ecs'.\n        \\<lbrakk>k_isNode ec; k_memb ec A;\n         obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ec'.\n                             lookup tOps (aTrans A) (ec, obs) =\n                             Some ec' \\<and>\n                             simAbs ec'\n                             \\<in> simAbs ` set (k_succs ec) \\<and>\n                             simObs a ec' = obs\\<rbrakk>\n    \\<Longrightarrow> k_invariant A", "unfolding k_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ec ec'.\n                \\<lbrakk>k_isNode ec; k_isNode ec';\n                 simAbs ec' = simAbs ec\\<rbrakk>\n                \\<Longrightarrow> lookup aOps (aActs A) ec =\n                                  lookup aOps (aActs A) ec';\n     \\<And>ec ec' obs.\n        \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n        \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) =\n                          lookup tOps (aTrans A) (ec', obs);\n     \\<And>ec.\n        \\<lbrakk>k_isNode ec; k_memb ec A\\<rbrakk>\n        \\<Longrightarrow> \\<exists>acts.\n                             lookup aOps (aActs A) ec = Some acts \\<and>\n                             set acts = set (simAction a ec);\n     \\<And>ec obs ecs'.\n        \\<lbrakk>k_isNode ec; k_memb ec A;\n         obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ec'.\n                             lookup tOps (aTrans A) (ec, obs) =\n                             Some ec' \\<and>\n                             simAbs ec'\n                             \\<in> simAbs ` set (k_succs ec) \\<and>\n                             simObs a ec' = obs\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>ec ec'.\n                          k_isNode ec \\<and>\n                          k_isNode ec' \\<and>\n                          simAbs ec' = simAbs ec \\<longrightarrow>\n                          lookup aOps (aActs A) ec =\n                          lookup aOps (aActs A) ec') \\<and>\n                      (\\<forall>ec ec' obs.\n                          k_isNode ec \\<and>\n                          k_isNode ec' \\<and>\n                          simAbs ec' = simAbs ec \\<longrightarrow>\n                          lookup tOps (aTrans A) (ec, obs) =\n                          lookup tOps (aTrans A) (ec', obs)) \\<and>\n                      (\\<forall>ec.\n                          k_isNode ec \\<and> k_memb ec A \\<longrightarrow>\n                          (\\<exists>acts.\n                              lookup aOps (aActs A) ec = Some acts \\<and>\n                              set acts = set (simAction a ec))) \\<and>\n                      (\\<forall>ec obs.\n                          k_isNode ec \\<and>\n                          k_memb ec A \\<and>\n                          obs\n                          \\<in> simObs a `\n                                set (k_succs ec) \\<longrightarrow>\n                          (\\<exists>ec'.\n                              lookup tOps (aTrans A) (ec, obs) =\n                              Some ec' \\<and>\n                              simAbs ec'\n                              \\<in> simAbs ` set (k_succs ec) \\<and>\n                              simObs a ec' = obs))", "by (simp (no_asm_simp))"], ["", "lemma k_invariantAOD:\n  \"\\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec; k_invariant A \\<rbrakk>\n     \\<Longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec;\n     k_invariant A\\<rbrakk>\n    \\<Longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec'", "unfolding k_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec;\n     (\\<forall>ec ec'.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup aOps (aActs A) ec = lookup aOps (aActs A) ec') \\<and>\n     (\\<forall>ec ec' obs.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup tOps (aTrans A) (ec, obs) =\n         lookup tOps (aTrans A) (ec', obs)) \\<and>\n     (\\<forall>ec.\n         k_isNode ec \\<and> k_memb ec A \\<longrightarrow>\n         (\\<exists>acts.\n             lookup aOps (aActs A) ec = Some acts \\<and>\n             set acts = set (simAction a ec))) \\<and>\n     (\\<forall>ec obs.\n         k_isNode ec \\<and>\n         k_memb ec A \\<and>\n         obs \\<in> simObs a ` set (k_succs ec) \\<longrightarrow>\n         (\\<exists>ec'.\n             lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n             simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n             simObs a ec' = obs))\\<rbrakk>\n    \\<Longrightarrow> lookup aOps (aActs A) ec = lookup aOps (aActs A) ec'", "by blast"], ["", "lemma k_invariantTOD:\n  \"\\<lbrakk> k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec; k_invariant A \\<rbrakk>\n     \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) = lookup tOps (aTrans A) (ec', obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec;\n     k_invariant A\\<rbrakk>\n    \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) =\n                      lookup tOps (aTrans A) (ec', obs)", "unfolding k_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec;\n     (\\<forall>ec ec'.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup aOps (aActs A) ec = lookup aOps (aActs A) ec') \\<and>\n     (\\<forall>ec ec' obs.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup tOps (aTrans A) (ec, obs) =\n         lookup tOps (aTrans A) (ec', obs)) \\<and>\n     (\\<forall>ec.\n         k_isNode ec \\<and> k_memb ec A \\<longrightarrow>\n         (\\<exists>acts.\n             lookup aOps (aActs A) ec = Some acts \\<and>\n             set acts = set (simAction a ec))) \\<and>\n     (\\<forall>ec obs.\n         k_isNode ec \\<and>\n         k_memb ec A \\<and>\n         obs \\<in> simObs a ` set (k_succs ec) \\<longrightarrow>\n         (\\<exists>ec'.\n             lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n             simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n             simObs a ec' = obs))\\<rbrakk>\n    \\<Longrightarrow> lookup tOps (aTrans A) (ec, obs) =\n                      lookup tOps (aTrans A) (ec', obs)", "by blast"], ["", "lemma k_invariantAD:\n  \"\\<lbrakk> k_isNode ec; k_memb ec A; k_invariant A \\<rbrakk>\n     \\<Longrightarrow> \\<exists>acts. lookup aOps (aActs A) ec = Some acts \\<and> set acts = set (simAction a ec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_memb ec A; k_invariant A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>acts.\n                         lookup aOps (aActs A) ec = Some acts \\<and>\n                         set acts = set (simAction a ec)", "unfolding k_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_memb ec A;\n     (\\<forall>ec ec'.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup aOps (aActs A) ec = lookup aOps (aActs A) ec') \\<and>\n     (\\<forall>ec ec' obs.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup tOps (aTrans A) (ec, obs) =\n         lookup tOps (aTrans A) (ec', obs)) \\<and>\n     (\\<forall>ec.\n         k_isNode ec \\<and> k_memb ec A \\<longrightarrow>\n         (\\<exists>acts.\n             lookup aOps (aActs A) ec = Some acts \\<and>\n             set acts = set (simAction a ec))) \\<and>\n     (\\<forall>ec obs.\n         k_isNode ec \\<and>\n         k_memb ec A \\<and>\n         obs \\<in> simObs a ` set (k_succs ec) \\<longrightarrow>\n         (\\<exists>ec'.\n             lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n             simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n             simObs a ec' = obs))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>acts.\n                         lookup aOps (aActs A) ec = Some acts \\<and>\n                         set acts = set (simAction a ec)", "by blast"], ["", "lemma k_invariantTD:\n  \"\\<lbrakk> k_isNode ec; k_memb ec A; obs \\<in> simObs a ` set (simTrans a ec); k_invariant A \\<rbrakk>\n     \\<Longrightarrow> \\<exists>ec'. lookup tOps (aTrans A) (ec, obs) = Some ec'\n             \\<and> simAbs ec' \\<in> simAbs ` set (simTrans a ec)\n             \\<and> simObs a ec' = obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_memb ec A;\n     obs \\<in> simObs a ` set (k_succs ec); k_invariant A\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ec'.\n                         lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n                         simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a ec' = obs", "unfolding k_invariant_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_isNode ec; k_memb ec A;\n     obs \\<in> simObs a ` set (k_succs ec);\n     (\\<forall>ec ec'.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup aOps (aActs A) ec = lookup aOps (aActs A) ec') \\<and>\n     (\\<forall>ec ec' obs.\n         k_isNode ec \\<and>\n         k_isNode ec' \\<and> simAbs ec' = simAbs ec \\<longrightarrow>\n         lookup tOps (aTrans A) (ec, obs) =\n         lookup tOps (aTrans A) (ec', obs)) \\<and>\n     (\\<forall>ec.\n         k_isNode ec \\<and> k_memb ec A \\<longrightarrow>\n         (\\<exists>acts.\n             lookup aOps (aActs A) ec = Some acts \\<and>\n             set acts = set (simAction a ec))) \\<and>\n     (\\<forall>ec obs.\n         k_isNode ec \\<and>\n         k_memb ec A \\<and>\n         obs \\<in> simObs a ` set (k_succs ec) \\<longrightarrow>\n         (\\<exists>ec'.\n             lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n             simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n             simObs a ec' = obs))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ec'.\n                         lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n                         simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a ec' = obs", "by blast"], ["", "lemma k_invariant_empt[simp]:\n  \"k_invariant k_empt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_invariant k_empt", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ec ec'.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs k_empt) ec =\n                         lookup aOps (aActs k_empt) ec'\n 2. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans k_empt) (ec, obs) =\n                         lookup tOps (aTrans k_empt) (ec', obs)\n 3. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec k_empt\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs k_empt) ec = Some acts \\<and>\n                            set acts = set (simAction a ec)\n 4. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec k_empt;\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans k_empt) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ec ec'.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs k_empt) ec =\n                         lookup aOps (aActs k_empt) ec'\n 2. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans k_empt) (ec, obs) =\n                         lookup tOps (aTrans k_empt) (ec', obs)", "apply (auto iff: k_empt_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma k_invariant_step_new_aux:\n  assumes X: \"set X \\<subseteq> set (k_succs x)\"\n      and x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and ec': \"simAbs ec' \\<in> simAbs ` set X\"\n      and S: \"simAbs ec = simAbs x\"\n  shows \"\\<exists>r. lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r\n           \\<and> simAbs r \\<in> simAbs ` set (k_succs ec)\n           \\<and> simObs a r = simObs a ec'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "using X ec'"], ["proof (prove)\nusing this:\n  set X \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set X\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "proof(induct X arbitrary: Y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>set [] \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) [] Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'\n 2. \\<And>aa X Y.\n       \\<lbrakk>\\<And>Y.\n                   \\<lbrakk>set X \\<subseteq> set (k_succs x);\n                    simAbs ec' \\<in> simAbs ` set X\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>r.\n  lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r \\<and>\n  simAbs r \\<in> simAbs ` set (k_succs ec) \\<and> simObs a r = simObs a ec';\n        set (aa # X) \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set (aa # X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) (aa # X) Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set []\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>set [] \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) [] Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'\n 2. \\<And>aa X Y.\n       \\<lbrakk>\\<And>Y.\n                   \\<lbrakk>set X \\<subseteq> set (k_succs x);\n                    simAbs ec' \\<in> simAbs ` set X\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>r.\n  lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r \\<and>\n  simAbs r \\<in> simAbs ` set (k_succs ec) \\<and> simObs a r = simObs a ec';\n        set (aa # X) \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set (aa # X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) (aa # X) Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'", "thus ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set []\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps (foldr (transUpdate x) [] Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "by simp"], ["proof (state)\nthis:\n  \\<exists>r.\n     lookup tOps (foldr (transUpdate x) [] Y) (ec, simObs a ec') =\n     Some r \\<and>\n     simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a r = simObs a ec'\n\ngoal (1 subgoal):\n 1. \\<And>aa X Y.\n       \\<lbrakk>\\<And>Y.\n                   \\<lbrakk>set X \\<subseteq> set (k_succs x);\n                    simAbs ec' \\<in> simAbs ` set X\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>r.\n  lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r \\<and>\n  simAbs r \\<in> simAbs ` set (k_succs ec) \\<and> simObs a r = simObs a ec';\n        set (aa # X) \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set (aa # X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) (aa # X) Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa X Y.\n       \\<lbrakk>\\<And>Y.\n                   \\<lbrakk>set X \\<subseteq> set (k_succs x);\n                    simAbs ec' \\<in> simAbs ` set X\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>r.\n  lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r \\<and>\n  simAbs r \\<in> simAbs ` set (k_succs ec) \\<and> simObs a r = simObs a ec';\n        set (aa # X) \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set (aa # X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) (aa # X) Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys ?Y11)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>aa X Y.\n       \\<lbrakk>\\<And>Y.\n                   \\<lbrakk>set X \\<subseteq> set (k_succs x);\n                    simAbs ec' \\<in> simAbs ` set X\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>r.\n  lookup tOps (foldr (transUpdate x) X Y) (ec, simObs a ec') = Some r \\<and>\n  simAbs r \\<in> simAbs ` set (k_succs ec) \\<and> simObs a r = simObs a ec';\n        set (aa # X) \\<subseteq> set (k_succs x);\n        simAbs ec' \\<in> simAbs ` set (aa # X)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            lookup tOps (foldr (transUpdate x) (aa # X) Y)\n                             (ec, simObs a ec') =\n                            Some r \\<and>\n                            simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a r = simObs a ec'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "proof(cases \"simAbs ec' = simAbs y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'\n 2. simAbs ec' \\<noteq> simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "case False"], ["proof (state)\nthis:\n  simAbs ec' \\<noteq> simAbs y\n\ngoal (2 subgoals):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'\n 2. simAbs ec' \\<noteq> simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "with x ec S Cons"], ["proof (chain)\npicking this:\n  k_isNode x\n  k_isNode ec\n  simAbs ec = simAbs x\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys ?Y11)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' \\<noteq> simAbs y", "show ?thesis"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  simAbs ec = simAbs x\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys ?Y11)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' \\<noteq> simAbs y\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "unfolding transUpdate_def"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  simAbs ec = simAbs x\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps\n                        (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                          ys ?Y11)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' \\<noteq> simAbs y\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (y # ys) Y)\n        (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>k_isNode x; k_isNode ec; simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x);\n        simObs a ec' = simObs a y\\<rbrakk>\n       \\<Longrightarrow> simAbs y \\<in> simAbs ` set (k_succs ec)", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>simAbs x \\<in> sim_equiv_class a ` jkbpC;\n        simAbs ec \\<in> sim_equiv_class a ` jkbpC; simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x);\n        simObs a ec' = simObs a y\\<rbrakk>\n       \\<Longrightarrow> simAbs y \\<in> simAbs ` set (k_succs ec)", "apply (erule imageE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa t ta.\n       \\<lbrakk>simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x); simObs a ec' = simObs a y;\n        simAbs x = sim_equiv_class a t; t \\<in> jkbpC;\n        simAbs ec = sim_equiv_class a ta; ta \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs y \\<in> simAbs ` set (k_succs ec)", "apply (cut_tac a=a and t=ta and ec=x and ec'=ec in simTrans_simAbs_cong[symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa t ta.\n       \\<lbrakk>simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x); simObs a ec' = simObs a y;\n        simAbs x = sim_equiv_class a t; t \\<in> jkbpC;\n        simAbs ec = sim_equiv_class a ta; ta \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> ta \\<in> jkbpC\n 2. \\<And>xa t ta.\n       \\<lbrakk>simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x); simObs a ec' = simObs a y;\n        simAbs x = sim_equiv_class a t; t \\<in> jkbpC;\n        simAbs ec = sim_equiv_class a ta; ta \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs x = sim_equiv_class a ta\n 3. \\<And>xa t ta.\n       \\<lbrakk>simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x); simObs a ec' = simObs a y;\n        simAbs x = sim_equiv_class a t; t \\<in> jkbpC;\n        simAbs ec = sim_equiv_class a ta; ta \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs x = simAbs ec\n 4. \\<And>xa t ta.\n       \\<lbrakk>simAbs ec = simAbs x;\n        \\<And>Y.\n           \\<exists>r.\n              lookup tOps\n               (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n               (ec, simObs a y) =\n              Some r \\<and>\n              simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n              simObs a r = simObs a y;\n        simAbs xa \\<noteq> simAbs y; simAbs ec' = simAbs xa;\n        xa \\<in> set ys; y \\<in> set (k_succs x);\n        set ys \\<subseteq> set (k_succs x); simObs a ec' = simObs a y;\n        simAbs x = sim_equiv_class a t; t \\<in> jkbpC;\n        simAbs ec = sim_equiv_class a ta; ta \\<in> jkbpC;\n        simAbs ` set (k_succs ec) = simAbs ` set (k_succs x)\\<rbrakk>\n       \\<Longrightarrow> simAbs y \\<in> simAbs ` set (k_succs ec)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r.\n     lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n     Some r \\<and>\n     simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a r = simObs a ec'\n\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "case True"], ["proof (state)\nthis:\n  simAbs ec' = simAbs y\n\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys ?Y11)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' = simAbs y", "have F: \"simAbs y \\<in> simAbs ` set (k_succs x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys ?Y11)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' = simAbs y\n\ngoal (1 subgoal):\n 1. simAbs y \\<in> simAbs ` set (k_succs x)", "by auto"], ["proof (state)\nthis:\n  simAbs y \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "from x"], ["proof (chain)\npicking this:\n  k_isNode x", "obtain t\n      where tC: \"t \\<in> jkbpC\"\n        and x': \"simAbs x = sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  k_isNode x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> jkbpC; simAbs x = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding k_isNode_def"], ["proof (prove)\nusing this:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> jkbpC; simAbs x = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "from F"], ["proof (chain)\npicking this:\n  simAbs y \\<in> simAbs ` set (k_succs x)", "obtain t' s\n      where \"simAbs y = sim_equiv_class a (t' \\<leadsto> s)\"\n        and tsC: \"t' \\<leadsto> s \\<in> jkbpC\"\n        and tt': \"jview a t = jview a t'\""], ["proof (prove)\nusing this:\n  simAbs y \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. (\\<And>t' s.\n        \\<lbrakk>simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n         t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using simTrans[rule_format, where a=a and t=t] tC x'"], ["proof (prove)\nusing this:\n  simAbs y \\<in> simAbs ` set (k_succs x)\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (k_succs ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. (\\<And>t' s.\n        \\<lbrakk>simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n         t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  simAbs y = sim_equiv_class a (t' \\<leadsto> s)\n  t' \\<leadsto> s \\<in> jkbpC\n  jview a t = jview a t'\n\ngoal (1 subgoal):\n 1. simAbs ec' = simAbs y \\<Longrightarrow>\n    \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "with Cons.hyps[where Y11=Y] Cons(2) Cons(3) True S x ec"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys Y)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' = simAbs y\n  simAbs ec = simAbs x\n  k_isNode x\n  k_isNode ec\n  simAbs y = sim_equiv_class a (t' \\<leadsto> s)\n  t' \\<leadsto> s \\<in> jkbpC\n  jview a t = jview a t'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps (foldr (transUpdate x) ys Y)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' = simAbs y\n  simAbs ec = simAbs x\n  k_isNode x\n  k_isNode ec\n  simAbs y = sim_equiv_class a (t' \\<leadsto> s)\n  t' \\<leadsto> s \\<in> jkbpC\n  jview a t = jview a t'\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "unfolding transUpdate_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ys \\<subseteq> set (k_succs x);\n   simAbs ec' \\<in> simAbs ` set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>r.\n                       lookup tOps\n                        (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                          ys Y)\n                        (ec, simObs a ec') =\n                       Some r \\<and>\n                       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                       simObs a r = simObs a ec'\n  set (y # ys) \\<subseteq> set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (y # ys)\n  simAbs ec' = simAbs y\n  simAbs ec = simAbs x\n  k_isNode x\n  k_isNode ec\n  simAbs y = sim_equiv_class a (t' \\<leadsto> s)\n  t' \\<leadsto> s \\<in> jkbpC\n  jview a t = jview a t'\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (y # ys) Y)\n        (ec, simObs a ec') =\n       Some r \\<and>\n       simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a r = simObs a ec'", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s)\n                      \\<in> simAbs ` set (k_succs ec)\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply (subst simTrans_simAbs_cong[where t=t' and ec'=x])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> t' \\<in> jkbpC\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = sim_equiv_class a t'\n 3. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = simAbs x\n 4. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s)\n                      \\<in> simAbs ` set (k_succs x)\n 5. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = sim_equiv_class a t'\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = simAbs x\n 3. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s)\n                      \\<in> simAbs ` set (k_succs x)\n 4. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "using x' tt'"], ["proof (prove)\nusing this:\n  simAbs x = sim_equiv_class a t\n  jview a t = jview a t'\n\ngoal (4 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = sim_equiv_class a t'\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = simAbs x\n 3. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s)\n                      \\<in> simAbs ` set (k_succs x)\n 4. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> simAbs ec = simAbs x\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s)\n                      \\<in> simAbs ` set (k_succs x)\n 3. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s)\n                      \\<in> simAbs ` set (k_succs x)\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply (rule image_eqI[where x=y])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (t' \\<leadsto> s) = simAbs y\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (k_succs x)\n 3. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a y) =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a y;\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' = simObs a y\\<rbrakk>\n    \\<Longrightarrow> y \\<in> set (k_succs x)\n 2. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "using simObs[rule_format, where a=a and t=\"t'\\<leadsto>s\"]"], ["proof (prove)\nusing this:\n  t' \\<leadsto> s \\<in> jkbpC \\<and>\n  simAbs ?ec = sim_equiv_class a (t' \\<leadsto> s) \\<Longrightarrow>\n  simObs a ?ec = envObs a (tLast (t' \\<leadsto> s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sim_equiv_class a (t' \\<leadsto> s)\n             \\<in> simAbs ` set ys \\<Longrightarrow>\n             \\<exists>r.\n                lookup tOps\n                 (foldr (\\<lambda>b. update tOps (x, simObs a b) b) ys Y)\n                 (ec, simObs a ec') =\n                Some r \\<and>\n                simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                simObs a r = simObs a ec';\n     simAbs ec' = sim_equiv_class a (t' \\<leadsto> s); simAbs ec = simAbs x;\n     k_isNode x; k_isNode ec;\n     simAbs y = sim_equiv_class a (t' \\<leadsto> s);\n     t' \\<leadsto> s \\<in> jkbpC; jview a t = jview a t';\n     y \\<in> set (k_succs x); set ys \\<subseteq> set (k_succs x);\n     simObs a ec' \\<noteq> simObs a y\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r.\n                         lookup tOps\n                          (foldr (\\<lambda>b. update tOps (x, simObs a b) b)\n                            ys Y)\n                          (ec, simObs a ec') =\n                         Some r \\<and>\n                         simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a r = simObs a ec'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>r.\n     lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n     Some r \\<and>\n     simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a r = simObs a ec'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>r.\n     lookup tOps (foldr (transUpdate x) (y # ys) Y) (ec, simObs a ec') =\n     Some r \\<and>\n     simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a r = simObs a ec'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma k_invariant_step_new:\n  assumes x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and ec': \"ec' \\<in> set (k_succs ec)\"\n      and S: \"simAbs ec = simAbs x\"\n  shows \"\\<exists>ec''. lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') = Some ec''\n              \\<and> simAbs ec'' \\<in> simAbs ` set (k_succs ec)\n              \\<and> simObs a ec'' = simObs a ec'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ec''.\n       lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') =\n       Some ec'' \\<and>\n       simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a ec'' = simObs a ec'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ec''.\n       lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') =\n       Some ec'' \\<and>\n       simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a ec'' = simObs a ec'", "from x ec'"], ["proof (chain)\npicking this:\n  k_isNode x\n  ec' \\<in> set (k_succs ec)", "have ec': \"simAbs ec' \\<in> simAbs ` set (k_succs x)\""], ["proof (prove)\nusing this:\n  k_isNode x\n  ec' \\<in> set (k_succs ec)\n\ngoal (1 subgoal):\n 1. simAbs ec' \\<in> simAbs ` set (k_succs x)", "unfolding k_isNode_def"], ["proof (prove)\nusing this:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  ec' \\<in> set (k_succs ec)\n\ngoal (1 subgoal):\n 1. simAbs ec' \\<in> simAbs ` set (k_succs x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs ec' \\<in> simAbs ` set (k_succs x)", "apply (subst simTrans_simAbs_cong[OF _ _ S, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> ?t12 xa \\<in> jkbpC\n 2. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs ec = sim_equiv_class a (?t12 xa)\n 3. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs ec' \\<in> simAbs ` set (k_succs ec)", "using S"], ["proof (prove)\nusing this:\n  simAbs ec = simAbs x\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> ?t12 xa \\<in> jkbpC\n 2. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs ec = sim_equiv_class a (?t12 xa)\n 3. \\<And>xa.\n       \\<lbrakk>ec' \\<in> set (k_succs ec); simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs ec' \\<in> simAbs ` set (k_succs ec)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simAbs ec' \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. \\<exists>ec''.\n       lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') =\n       Some ec'' \\<and>\n       simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a ec'' = simObs a ec'", "thus ?thesis"], ["proof (prove)\nusing this:\n  simAbs ec' \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. \\<exists>ec''.\n       lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') =\n       Some ec'' \\<and>\n       simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a ec'' = simObs a ec'", "using k_invariant_step_new_aux[OF subset_refl x ec _ S, where ec'=ec']"], ["proof (prove)\nusing this:\n  simAbs ec' \\<in> simAbs ` set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (k_succs x) \\<Longrightarrow>\n  \\<exists>r.\n     lookup tOps (foldr (transUpdate x) (k_succs x) ?Y) (ec, simObs a ec') =\n     Some r \\<and>\n     simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a r = simObs a ec'\n\ngoal (1 subgoal):\n 1. \\<exists>ec''.\n       lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') =\n       Some ec'' \\<and>\n       simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a ec'' = simObs a ec'", "unfolding k_ins_def"], ["proof (prove)\nusing this:\n  simAbs ec' \\<in> simAbs ` set (k_succs x)\n  simAbs ec' \\<in> simAbs ` set (k_succs x) \\<Longrightarrow>\n  \\<exists>r.\n     lookup tOps (foldr (transUpdate x) (k_succs x) ?Y) (ec, simObs a ec') =\n     Some r \\<and>\n     simAbs r \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a r = simObs a ec'\n\ngoal (1 subgoal):\n 1. \\<exists>ec''.\n       lookup tOps\n        (aTrans\n          \\<lparr>aActs = actsUpdate x A,\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        (ec, simObs a ec') =\n       Some ec'' \\<and>\n       simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n       simObs a ec'' = simObs a ec'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ec''.\n     lookup tOps (aTrans (k_ins x A)) (ec, simObs a ec') = Some ec'' \\<and>\n     simAbs ec'' \\<in> simAbs ` set (k_succs ec) \\<and>\n     simObs a ec'' = simObs a ec'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma k_invariant_step_old_aux:\n  assumes x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and S: \"simAbs ec \\<noteq> simAbs x\"\n  shows \"lookup tOps (foldr (transUpdate x) X Y) (ec, obs)\n       = lookup tOps Y (ec, obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup tOps (foldr (transUpdate x) X Y) (ec, obs) =\n    lookup tOps Y (ec, obs)", "proof(induct X)"], ["proof (state)\ngoal (2 subgoals):\n 1. lookup tOps (foldr (transUpdate x) [] Y) (ec, obs) =\n    lookup tOps Y (ec, obs)\n 2. \\<And>a X.\n       lookup tOps (foldr (transUpdate x) X Y) (ec, obs) =\n       lookup tOps Y (ec, obs) \\<Longrightarrow>\n       lookup tOps (foldr (transUpdate x) (a # X) Y) (ec, obs) =\n       lookup tOps Y (ec, obs)", "case (Cons z zs)"], ["proof (state)\nthis:\n  lookup tOps (foldr (transUpdate x) zs Y) (ec, obs) =\n  lookup tOps Y (ec, obs)\n\ngoal (2 subgoals):\n 1. lookup tOps (foldr (transUpdate x) [] Y) (ec, obs) =\n    lookup tOps Y (ec, obs)\n 2. \\<And>a X.\n       lookup tOps (foldr (transUpdate x) X Y) (ec, obs) =\n       lookup tOps Y (ec, obs) \\<Longrightarrow>\n       lookup tOps (foldr (transUpdate x) (a # X) Y) (ec, obs) =\n       lookup tOps Y (ec, obs)", "with x ec S"], ["proof (chain)\npicking this:\n  k_isNode x\n  k_isNode ec\n  simAbs ec \\<noteq> simAbs x\n  lookup tOps (foldr (transUpdate x) zs Y) (ec, obs) =\n  lookup tOps Y (ec, obs)", "show ?case"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  simAbs ec \\<noteq> simAbs x\n  lookup tOps (foldr (transUpdate x) zs Y) (ec, obs) =\n  lookup tOps Y (ec, obs)\n\ngoal (1 subgoal):\n 1. lookup tOps (foldr (transUpdate x) (z # zs) Y) (ec, obs) =\n    lookup tOps Y (ec, obs)", "by (cases \"lookup tOps Y (ec, obs)\") (simp_all add: transUpdate_def)"], ["proof (state)\nthis:\n  lookup tOps (foldr (transUpdate x) (z # zs) Y) (ec, obs) =\n  lookup tOps Y (ec, obs)\n\ngoal (1 subgoal):\n 1. lookup tOps (foldr (transUpdate x) [] Y) (ec, obs) =\n    lookup tOps Y (ec, obs)", "qed simp"], ["", "lemma k_invariant_step_old:\n  assumes x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and S: \"simAbs ec \\<noteq> simAbs x\"\n  shows \"lookup tOps (aTrans (k_ins x A)) (ec, obs)\n       = lookup tOps (aTrans A) (ec, obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n    lookup tOps (aTrans A) (ec, obs)", "unfolding k_ins_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup tOps\n     (aTrans\n       \\<lparr>aActs = actsUpdate x A,\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     (ec, obs) =\n    lookup tOps (aTrans A) (ec, obs)", "using k_invariant_step_old_aux[OF x ec S]"], ["proof (prove)\nusing this:\n  lookup tOps (foldr (transUpdate x) ?X ?Y) (ec, ?obs) =\n  lookup tOps ?Y (ec, ?obs)\n\ngoal (1 subgoal):\n 1. lookup tOps\n     (aTrans\n       \\<lparr>aActs = actsUpdate x A,\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     (ec, obs) =\n    lookup tOps (aTrans A) (ec, obs)", "by simp"], ["", "lemma k_invariant_frame:\n  assumes B: \"lookup tOps Y (ec, obs) = lookup tOps Y (ec', obs)\"\n      and x: \"k_isNode x\"\n      and ec: \"k_isNode ec\"\n      and ec': \"k_isNode ec'\"\n      and S: \"simAbs ec' = simAbs ec\"\n  shows \"lookup tOps (foldr (transUpdate x) X Y) (ec, obs) = lookup tOps (foldr (transUpdate x) X Y) (ec', obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup tOps (foldr (transUpdate x) X Y) (ec, obs) =\n    lookup tOps (foldr (transUpdate x) X Y) (ec', obs)", "apply (induct X)"], ["proof (prove)\ngoal (2 subgoals):\n 1. lookup tOps (foldr (transUpdate x) [] Y) (ec, obs) =\n    lookup tOps (foldr (transUpdate x) [] Y) (ec', obs)\n 2. \\<And>a X.\n       lookup tOps (foldr (transUpdate x) X Y) (ec, obs) =\n       lookup tOps (foldr (transUpdate x) X Y) (ec', obs) \\<Longrightarrow>\n       lookup tOps (foldr (transUpdate x) (a # X) Y) (ec, obs) =\n       lookup tOps (foldr (transUpdate x) (a # X) Y) (ec', obs)", "unfolding transUpdate_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) [] Y)\n     (ec, obs) =\n    lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) [] Y)\n     (ec', obs)\n 2. \\<And>aa X.\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec, obs) =\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec', obs) \\<Longrightarrow>\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec, obs) =\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec', obs)", "using B"], ["proof (prove)\nusing this:\n  lookup tOps Y (ec, obs) = lookup tOps Y (ec', obs)\n\ngoal (2 subgoals):\n 1. lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) [] Y)\n     (ec, obs) =\n    lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) [] Y)\n     (ec', obs)\n 2. \\<And>aa X.\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec, obs) =\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec', obs) \\<Longrightarrow>\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec, obs) =\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec', obs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa X.\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec, obs) =\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec', obs) \\<Longrightarrow>\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec, obs) =\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec', obs)", "using x ec ec' S"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec\n\ngoal (1 subgoal):\n 1. \\<And>aa X.\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec, obs) =\n       lookup tOps (foldr (\\<lambda>b. update tOps (x, simObs a b) b) X Y)\n        (ec', obs) \\<Longrightarrow>\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec, obs) =\n       lookup tOps\n        (foldr (\\<lambda>b. update tOps (x, simObs a b) b) (aa # X) Y)\n        (ec', obs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma k_invariant_step[simp]:\n  assumes N: \"k_isNode x\"\n      and I: \"k_invariant A\"\n      and M: \"\\<not> k_memb x A\"\n  shows \"k_invariant (k_ins x A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_invariant (k_ins x A)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_invariant (k_ins x A)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ec ec'.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs (k_ins x A)) ec =\n                         lookup aOps (aActs (k_ins x A)) ec'\n 2. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 3. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 4. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "fix ec ec'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ec ec'.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs (k_ins x A)) ec =\n                         lookup aOps (aActs (k_ins x A)) ec'\n 2. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 3. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 4. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "assume ec: \"k_isNode ec\" and ec': \"k_isNode ec'\" and X: \"simAbs ec' = simAbs ec\""], ["proof (state)\nthis:\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec\n\ngoal (4 subgoals):\n 1. \\<And>ec ec'.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup aOps (aActs (k_ins x A)) ec =\n                         lookup aOps (aActs (k_ins x A)) ec'\n 2. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 3. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 4. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "with N"], ["proof (chain)\npicking this:\n  k_isNode x\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec", "show \"lookup aOps (aActs (k_ins x A)) ec = lookup aOps (aActs (k_ins x A)) ec'\""], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec\n\ngoal (1 subgoal):\n 1. lookup aOps (aActs (k_ins x A)) ec = lookup aOps (aActs (k_ins x A)) ec'", "unfolding k_ins_def actsUpdate_def"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec\n\ngoal (1 subgoal):\n 1. lookup aOps\n     (aActs\n       \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     ec =\n    lookup aOps\n     (aActs\n       \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     ec'", "using k_invariantAOD[OF ec ec' X I]"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec\n  lookup aOps (aActs A) ec = lookup aOps (aActs A) ec'\n\ngoal (1 subgoal):\n 1. lookup aOps\n     (aActs\n       \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     ec =\n    lookup aOps\n     (aActs\n       \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     ec'", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lookup aOps (aActs (k_ins x A)) ec = lookup aOps (aActs (k_ins x A)) ec'\n\ngoal (3 subgoals):\n 1. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 2. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 3. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 2. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 3. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "fix ec ec' obs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 2. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 3. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "assume ec: \"k_isNode ec\" and ec': \"k_isNode ec'\" and X: \"simAbs ec' = simAbs ec\""], ["proof (state)\nthis:\n  k_isNode ec\n  k_isNode ec'\n  simAbs ec' = simAbs ec\n\ngoal (3 subgoals):\n 1. \\<And>ec ec' obs.\n       \\<lbrakk>k_isNode ec; k_isNode ec'; simAbs ec' = simAbs ec\\<rbrakk>\n       \\<Longrightarrow> lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                         lookup tOps (aTrans (k_ins x A)) (ec', obs)\n 2. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 3. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "show \"lookup tOps (aTrans (k_ins x A)) (ec, obs) = lookup tOps (aTrans (k_ins x A)) (ec', obs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n    lookup tOps (aTrans (k_ins x A)) (ec', obs)", "unfolding k_ins_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup tOps\n     (aTrans\n       \\<lparr>aActs = actsUpdate x A,\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     (ec, obs) =\n    lookup tOps\n     (aTrans\n       \\<lparr>aActs = actsUpdate x A,\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     (ec', obs)", "using k_invariant_frame[OF k_invariantTOD[OF ec ec' X I] N ec ec' X]"], ["proof (prove)\nusing this:\n  lookup tOps (foldr (transUpdate x) ?X (aTrans A)) (ec, ?obs) =\n  lookup tOps (foldr (transUpdate x) ?X (aTrans A)) (ec', ?obs)\n\ngoal (1 subgoal):\n 1. lookup tOps\n     (aTrans\n       \\<lparr>aActs = actsUpdate x A,\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     (ec, obs) =\n    lookup tOps\n     (aTrans\n       \\<lparr>aActs = actsUpdate x A,\n          aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n     (ec', obs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n  lookup tOps (aTrans (k_ins x A)) (ec', obs)\n\ngoal (2 subgoals):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 2. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 2. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "fix ec obs ecs'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 2. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "assume n: \"k_isNode ec\"\n    and ec: \"k_memb ec (k_ins x A)\"\n    and obs: \"obs \\<in> simObs a ` set (simTrans a ec)\""], ["proof (state)\nthis:\n  k_isNode ec\n  k_memb ec (k_ins x A)\n  obs \\<in> simObs a ` set (k_succs ec)\n\ngoal (2 subgoals):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)\n 2. \\<And>ec obs ecs'.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A);\n        obs \\<in> simObs a ` set (k_succs ec)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ec'.\n                            lookup tOps (aTrans (k_ins x A)) (ec, obs) =\n                            Some ec' \\<and>\n                            simAbs ec'\n                            \\<in> simAbs ` set (k_succs ec) \\<and>\n                            simObs a ec' = obs", "show \"\\<exists>ec'. lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec'\n            \\<and> simAbs ec' \\<in> simAbs ` set (k_succs ec)\n            \\<and> simObs a ec' = obs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "proof(cases \"simAbs ec = simAbs x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. simAbs ec = simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs\n 2. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "case True"], ["proof (state)\nthis:\n  simAbs ec = simAbs x\n\ngoal (2 subgoals):\n 1. simAbs ec = simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs\n 2. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "with N n obs"], ["proof (chain)\npicking this:\n  k_isNode x\n  k_isNode ec\n  obs \\<in> simObs a ` set (k_succs ec)\n  simAbs ec = simAbs x", "show ?thesis"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  obs \\<in> simObs a ` set (k_succs ec)\n  simAbs ec = simAbs x\n\ngoal (1 subgoal):\n 1. \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "using k_invariant_step_new"], ["proof (prove)\nusing this:\n  k_isNode x\n  k_isNode ec\n  obs \\<in> simObs a ` set (k_succs ec)\n  simAbs ec = simAbs x\n  \\<lbrakk>k_isNode ?x; k_isNode ?ec; ?ec' \\<in> set (k_succs ?ec);\n   simAbs ?ec = simAbs ?x\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ec''.\n                       lookup tOps (aTrans (k_ins ?x ?A))\n                        (?ec, simObs a ?ec') =\n                       Some ec'' \\<and>\n                       simAbs ec'' \\<in> simAbs ` set (k_succs ?ec) \\<and>\n                       simObs a ec'' = simObs a ?ec'\n\ngoal (1 subgoal):\n 1. \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "by auto"], ["proof (state)\nthis:\n  \\<exists>ec'.\n     lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n     simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs\n\ngoal (1 subgoal):\n 1. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "case False"], ["proof (state)\nthis:\n  simAbs ec \\<noteq> simAbs x\n\ngoal (1 subgoal):\n 1. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "with I N n ec obs"], ["proof (chain)\npicking this:\n  k_invariant A\n  k_isNode x\n  k_isNode ec\n  k_memb ec (k_ins x A)\n  obs \\<in> simObs a ` set (k_succs ec)\n  simAbs ec \\<noteq> simAbs x", "show ?thesis"], ["proof (prove)\nusing this:\n  k_invariant A\n  k_isNode x\n  k_isNode ec\n  k_memb ec (k_ins x A)\n  obs \\<in> simObs a ` set (k_succs ec)\n  simAbs ec \\<noteq> simAbs x\n\ngoal (1 subgoal):\n 1. \\<exists>ec'.\n       lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n       simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs", "apply (simp add: k_invariant_step_old)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec; k_memb ec (k_ins x A);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ec'.\n                         lookup tOps (aTrans A) (ec, obs) = Some ec' \\<and>\n                         simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and>\n                         simObs a ec' = obs", "apply (rule k_invariantTD)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec; k_memb ec (k_ins x A);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_isNode ec\n 2. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec; k_memb ec (k_ins x A);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_memb ec A\n 3. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec; k_memb ec (k_ins x A);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> obs \\<in> simObs a ` set (k_succs ec)\n 4. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec; k_memb ec (k_ins x A);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_invariant A", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec; k_memb ec (k_ins x A);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_memb ec A", "unfolding k_ins_def k_memb_def actsUpdate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k_invariant A; k_isNode x; k_isNode ec;\n     isSome\n      (lookup aOps\n        (aActs\n          \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        ec);\n     obs \\<in> simObs a ` set (k_succs ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> isSome (lookup aOps (aActs A) ec)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ec'.\n     lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n     simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ec'.\n     lookup tOps (aTrans (k_ins x A)) (ec, obs) = Some ec' \\<and>\n     simAbs ec' \\<in> simAbs ` set (k_succs ec) \\<and> simObs a ec' = obs\n\ngoal (1 subgoal):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)", "fix ec"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)", "assume n: \"k_isNode ec\"\n     and ec: \"k_memb ec (k_ins x A)\""], ["proof (state)\nthis:\n  k_isNode ec\n  k_memb ec (k_ins x A)\n\ngoal (1 subgoal):\n 1. \\<And>ec.\n       \\<lbrakk>k_isNode ec; k_memb ec (k_ins x A)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>acts.\n                            lookup aOps (aActs (k_ins x A)) ec =\n                            Some acts \\<and>\n                            set acts = set (simAction a ec)", "show \"\\<exists>acts. lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and> set acts = set (simAction a ec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "proof(cases \"simAbs ec = simAbs x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. simAbs ec = simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)\n 2. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "case True"], ["proof (state)\nthis:\n  simAbs ec = simAbs x\n\ngoal (2 subgoals):\n 1. simAbs ec = simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)\n 2. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "with aOps N n"], ["proof (chain)\npicking this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n  k_isNode x\n  k_isNode ec\n  simAbs ec = simAbs x", "show ?thesis"], ["proof (prove)\nusing this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n  k_isNode x\n  k_isNode ec\n  simAbs ec = simAbs x\n\ngoal (1 subgoal):\n 1. \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "unfolding k_ins_def actsUpdate_def"], ["proof (prove)\nusing this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n  k_isNode x\n  k_isNode ec\n  simAbs ec = simAbs x\n\ngoal (1 subgoal):\n 1. \\<exists>acts.\n       lookup aOps\n        (aActs\n          \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        ec =\n       Some acts \\<and>\n       set acts = set (simAction a ec)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_isNode ec; simAbs ec = simAbs x\\<rbrakk>\n    \\<Longrightarrow> set (simAction a x) = set (simAction a ec)", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     simAbs x \\<in> sim_equiv_class a ` jkbpC;\n     simAbs ec \\<in> sim_equiv_class a ` jkbpC;\n     simAbs ec = simAbs x\\<rbrakk>\n    \\<Longrightarrow> set (simAction a x) = set (simAction a ec)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n        simAbs ec = sim_equiv_class a xa; simAbs x = sim_equiv_class a xa;\n        xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> set (simAction a x) = set (simAction a ec)", "apply (erule jAction_simAbs_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n        simAbs ec = sim_equiv_class a xa;\n        simAbs x = sim_equiv_class a xa\\<rbrakk>\n       \\<Longrightarrow> simAbs x = sim_equiv_class a xa\n 2. \\<And>xa.\n       \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n        simAbs ec = sim_equiv_class a xa;\n        simAbs x = sim_equiv_class a xa\\<rbrakk>\n       \\<Longrightarrow> simAbs x = simAbs ec", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>acts.\n     lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n     set acts = set (simAction a ec)\n\ngoal (1 subgoal):\n 1. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "case False"], ["proof (state)\nthis:\n  simAbs ec \\<noteq> simAbs x\n\ngoal (1 subgoal):\n 1. simAbs ec \\<noteq> simAbs x \\<Longrightarrow>\n    \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "with aOps N I M n ec"], ["proof (chain)\npicking this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n  k_isNode x\n  k_invariant A\n  \\<not> k_memb x A\n  k_isNode ec\n  k_memb ec (k_ins x A)\n  simAbs ec \\<noteq> simAbs x", "show ?thesis"], ["proof (prove)\nusing this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n  k_isNode x\n  k_invariant A\n  \\<not> k_memb x A\n  k_isNode ec\n  k_memb ec (k_ins x A)\n  simAbs ec \\<noteq> simAbs x\n\ngoal (1 subgoal):\n 1. \\<exists>acts.\n       lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n       set acts = set (simAction a ec)", "unfolding k_ins_def actsUpdate_def"], ["proof (prove)\nusing this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n  k_isNode x\n  k_invariant A\n  \\<not> k_memb x A\n  k_isNode ec\n  k_memb ec\n   \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n      aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>\n  simAbs ec \\<noteq> simAbs x\n\ngoal (1 subgoal):\n 1. \\<exists>acts.\n       lookup aOps\n        (aActs\n          \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        ec =\n       Some acts \\<and>\n       set acts = set (simAction a ec)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> k_memb x A; k_isNode ec;\n     k_memb ec\n      \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n         aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>;\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>acts.\n                         lookup aOps (aActs A) ec = Some acts \\<and>\n                         set acts = set (simAction a ec)", "apply (rule k_invariantAD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> k_memb x A; k_isNode ec;\n     k_memb ec\n      \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n         aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>;\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_isNode ec\n 2. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> k_memb x A; k_isNode ec;\n     k_memb ec\n      \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n         aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>;\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_memb ec A\n 3. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> k_memb x A; k_isNode ec;\n     k_memb ec\n      \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n         aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>;\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_invariant A", "unfolding k_memb_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> isSome (lookup aOps (aActs A) x);\n     k_isNode ec;\n     isSome\n      (lookup aOps\n        (aActs\n          \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_isNode ec\n 2. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> isSome (lookup aOps (aActs A) x);\n     k_isNode ec;\n     isSome\n      (lookup aOps\n        (aActs\n          \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> isSome (lookup aOps (aActs A) ec)\n 3. \\<lbrakk>MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps;\n     k_isNode x; k_invariant A; \\<not> isSome (lookup aOps (aActs A) x);\n     k_isNode ec;\n     isSome\n      (lookup aOps\n        (aActs\n          \\<lparr>aActs = update aOps x (simAction a x) (aActs A),\n             aTrans = foldr (transUpdate x) (k_succs x) (aTrans A)\\<rparr>)\n        ec);\n     simAbs ec \\<noteq> simAbs x\\<rbrakk>\n    \\<Longrightarrow> k_invariant A", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>acts.\n     lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n     set acts = set (simAction a ec)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>acts.\n     lookup aOps (aActs (k_ins x A)) ec = Some acts \\<and>\n     set acts = set (simAction a ec)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)\n\n(*>*)"], ["", "text\\<open>\n\nShowing that the invariant holds of @{term \"k_empt\"} and is respected\nby @{term \"k_ins\"} is routine.\n\nThe initial frontier is the partition of the set of initial states\nunder the initial observation function.\n\n\\<close>"], ["", "definition (in Algorithm) k_frontier :: \"'a \\<Rightarrow> 'rep list\" where\n  \"k_frontier a \\<equiv> map (simInit a \\<circ> envObs a) envInit\""], ["", "(*<*)"], ["", "lemma k_frontier_is_node[intro, simp]:\n  \"list_all k_isNode (k_frontier a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all k_isNode (k_frontier a)", "unfolding k_frontier_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all k_isNode (map (simInit a \\<circ> envObs a) envInit)", "by (auto iff: simInit list_all_iff k_isNode_def jviewInit jviewIncr)"], ["", "(*>*)"], ["", "end"], ["", "(* context AlgorithmForAgent *)"], ["", "text\\<open>\n\nWe now instantiate the @{term \"DFS\"} locale with respect to the @{term\n\"AlgorithmForAgent\"} locale. The instantiated lemmas are given the\nmandatory prefix \\<open>KBPAlg\\<close> in the @{term \"AlgorithmForAgent\"}\nlocale.\n\n\\<close>"], ["", "sublocale AlgorithmForAgent\n        < KBPAlg: DFS k_succs k_isNode k_invariant k_ins k_memb k_empt simAbs"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS k_succs k_isNode k_invariant k_ins k_memb k_empt simAbs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. DFS k_succs k_isNode k_invariant k_ins k_memb k_empt simAbs", "apply (unfold_locales)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>k_isNode x; k_isNode y; k_invariant S;\n        \\<not> k_memb y S\\<rbrakk>\n       \\<Longrightarrow> k_memb x (k_ins y S) =\n                         (simAbs x = simAbs y \\<or> k_memb x S)\n 2. \\<And>x y.\n       \\<lbrakk>k_isNode x; k_isNode y; simAbs x = simAbs y\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)\n 3. \\<And>x. k_isNode x \\<Longrightarrow> \\<not> k_memb x k_empt\n 4. \\<And>x. k_isNode x \\<Longrightarrow> list_all k_isNode (k_succs x)\n 5. k_invariant k_empt\n 6. \\<And>x S.\n       \\<lbrakk>k_isNode x; k_invariant S; \\<not> k_memb x S\\<rbrakk>\n       \\<Longrightarrow> k_invariant (k_ins x S)\n 7. finite (simAbs ` Collect k_isNode)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>k_isNode x; k_isNode y; k_invariant S;\n        \\<not> k_memb y S\\<rbrakk>\n       \\<Longrightarrow> k_memb x (k_ins y S) =\n                         (simAbs x = simAbs y \\<or> k_memb x S)\n 2. \\<And>x y.\n       \\<lbrakk>k_isNode x; k_isNode y; simAbs x = simAbs y\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)", "unfolding k_memb_def k_ins_def actsUpdate_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>k_isNode x; k_isNode y; k_invariant S;\n        \\<not> isSome (lookup aOps (aActs S) y)\\<rbrakk>\n       \\<Longrightarrow> isSome\n                          (lookup aOps\n                            (aActs\n                              \\<lparr>aActs =\n  update aOps y (simAction a y) (aActs S),\n                                 aTrans =\n                                   foldr (transUpdate y) (k_succs y)\n                                    (aTrans S)\\<rparr>)\n                            x) =\n                         (simAbs x = simAbs y \\<or>\n                          isSome (lookup aOps (aActs S) x))\n 2. \\<And>x y.\n       \\<lbrakk>k_isNode x; k_isNode y; simAbs x = simAbs y\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)", "using aOps"], ["proof (prove)\nusing this:\n  MapOps simAbs (\\<Union>a. sim_equiv_class a ` jkbpC) aOps\n\ngoal (2 subgoals):\n 1. \\<And>x y S.\n       \\<lbrakk>k_isNode x; k_isNode y; k_invariant S;\n        \\<not> isSome (lookup aOps (aActs S) y)\\<rbrakk>\n       \\<Longrightarrow> isSome\n                          (lookup aOps\n                            (aActs\n                              \\<lparr>aActs =\n  update aOps y (simAction a y) (aActs S),\n                                 aTrans =\n                                   foldr (transUpdate y) (k_succs y)\n                                    (aTrans S)\\<rparr>)\n                            x) =\n                         (simAbs x = simAbs y \\<or>\n                          isSome (lookup aOps (aActs S) x))\n 2. \\<And>x y.\n       \\<lbrakk>k_isNode x; k_isNode y; simAbs x = simAbs y\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)", "apply (auto iff: isSome_eq)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>k_isNode x; k_isNode y; simAbs x = simAbs y\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)", "unfolding k_isNode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>simAbs x \\<in> sim_equiv_class a ` jkbpC;\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        simAbs x = simAbs y\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa.\n       \\<lbrakk>simAbs x = sim_equiv_class a xa;\n        simAbs y = sim_equiv_class a xa; xa \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs ` set (k_succs x) = simAbs ` set (k_succs y)", "apply (erule simTrans_simAbs_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa.\n       \\<lbrakk>simAbs x = sim_equiv_class a xa;\n        simAbs y = sim_equiv_class a xa\\<rbrakk>\n       \\<Longrightarrow> simAbs x = sim_equiv_class a xa\n 2. \\<And>x y xa.\n       \\<lbrakk>simAbs x = sim_equiv_class a xa;\n        simAbs y = sim_equiv_class a xa\\<rbrakk>\n       \\<Longrightarrow> simAbs x = simAbs y", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text_raw\\<open>\n\\begin{figure}\n\\begin{isabellebody}%\n\\<close>"], ["", "definition\n  alg_dfs :: \"('ma, 'rep, 'aAct list) MapOps\n         \\<Rightarrow> ('mt, 'rep \\<times> 'obs, 'rep) MapOps\n         \\<Rightarrow> ('rep \\<Rightarrow> 'obs)\n         \\<Rightarrow> ('rep \\<Rightarrow> 'rep list)\n         \\<Rightarrow> ('rep \\<Rightarrow> 'aAct list)\n         \\<Rightarrow> 'rep list\n         \\<Rightarrow> ('ma, 'mt) AlgState\"\nwhere\n  \"alg_dfs aOps tOps simObs simTrans simAction \\<equiv>\n    let k_empt = \\<lparr> aActs = empty aOps, aTrans = empty tOps \\<rparr>;\n       k_memb = (\\<lambda>s A. isSome (lookup aOps (aActs A) s));\n       k_succs = simTrans;\n       actsUpdate = \\<lambda>ec A. update aOps ec (simAction ec) (aActs A);\n       transUpdate = \\<lambda>ec ec' at. update tOps (ec, simObs ec') ec' at;\n       k_ins = \\<lambda>ec A. \\<lparr> aActs = actsUpdate ec A,\n                         aTrans = foldr (transUpdate ec) (k_succs ec) (aTrans A) \\<rparr>\n     in gen_dfs k_succs k_ins k_memb k_empt\""], ["", "text\\<open>\\<close>"], ["", "definition\n  mkAlgAuto :: \"('ma, 'rep, 'aAct list) MapOps\n            \\<Rightarrow> ('mt, 'rep \\<times> 'obs, 'rep) MapOps\n            \\<Rightarrow> ('a \\<Rightarrow> 'rep \\<Rightarrow> 'obs)\n            \\<Rightarrow> ('a \\<Rightarrow> 'obs \\<Rightarrow> 'rep)\n            \\<Rightarrow> ('a \\<Rightarrow> 'rep \\<Rightarrow> 'rep list)\n            \\<Rightarrow> ('a \\<Rightarrow> 'rep \\<Rightarrow> 'aAct list)\n            \\<Rightarrow> ('a \\<Rightarrow> 'rep list)\n            \\<Rightarrow> ('a, 'obs, 'aAct, 'rep) JointProtocol\"\nwhere\n  \"mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier \\<equiv> \\<lambda>a.\n    let auto = alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n                       (frontier a)\n     in \\<lparr> pInit = simInit a,\n          pTrans = \\<lambda>obs ec. the (lookup tOps (aTrans auto) (ec, obs)),\n          pAct = \\<lambda>ec. the (lookup aOps (aActs auto) ec) \\<rparr>\""], ["", "text_raw\\<open>\n  \\end{isabellebody}%\n  \\caption{The algorithm. The function @{term \"the\"} projects a value from the\n    @{typ \"'a option\"} type, diverging on @{term \"None\"}.}\n  \\label{fig:kbps-alg-algorithm}\n\\end{figure}\n\\<close>"], ["", "(*<*)"], ["", "lemma mkAutoSim_simps[simp]:\n  \"pInit (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a) = simInit a\"\n  \"pTrans (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a)\n = (\\<lambda>obs ec. the (lookup tOps (aTrans (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a) (frontier a))) (ec, obs)))\"\n  \"pAct (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a)\n = (\\<lambda>ec. the (lookup aOps (aActs (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a) (frontier a))) ec))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pInit\n     (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a) =\n    simInit a &&&\n    pTrans\n     (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a) =\n    (\\<lambda>obs ec.\n        the (lookup tOps\n              (aTrans\n                (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n                  (frontier a)))\n              (ec, obs))) &&&\n    pAct\n     (mkAlgAuto aOps tOps simObs simInit simTrans simAction frontier a) =\n    (\\<lambda>ec.\n        the (lookup aOps\n              (aActs\n                (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n                  (frontier a)))\n              ec))", "unfolding mkAlgAuto_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pInit\n     (let auto =\n            alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n             (frontier a)\n      in \\<lparr>pInit = simInit a,\n            pTrans =\n              \\<lambda>obs ec. the (lookup tOps (aTrans auto) (ec, obs)),\n            pAct = \\<lambda>ec. the (lookup aOps (aActs auto) ec)\\<rparr>) =\n    simInit a &&&\n    pTrans\n     (let auto =\n            alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n             (frontier a)\n      in \\<lparr>pInit = simInit a,\n            pTrans =\n              \\<lambda>obs ec. the (lookup tOps (aTrans auto) (ec, obs)),\n            pAct = \\<lambda>ec. the (lookup aOps (aActs auto) ec)\\<rparr>) =\n    (\\<lambda>obs ec.\n        the (lookup tOps\n              (aTrans\n                (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n                  (frontier a)))\n              (ec, obs))) &&&\n    pAct\n     (let auto =\n            alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n             (frontier a)\n      in \\<lparr>pInit = simInit a,\n            pTrans =\n              \\<lambda>obs ec. the (lookup tOps (aTrans auto) (ec, obs)),\n            pAct = \\<lambda>ec. the (lookup aOps (aActs auto) ec)\\<rparr>) =\n    (\\<lambda>ec.\n        the (lookup aOps\n              (aActs\n                (alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a)\n                  (frontier a)))\n              ec))", "apply (simp_all add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Later we want to show that a particular DFS implementation does the\nright thing. *)"], ["", "definition\n  alg_mk_auto :: \"('ma, 'rep, 'aAct list) MapOps\n                \\<Rightarrow> ('mt, 'rep \\<times> 'obs, 'rep) MapOps\n                \\<Rightarrow> ('obs \\<Rightarrow> 'rep)\n                \\<Rightarrow> ('ma, 'mt) AlgState\n                \\<Rightarrow> ('obs, 'aAct, 'rep) Protocol\"\nwhere\n  \"alg_mk_auto aOps tOps simInit k_dfs \\<equiv>\n    \\<lparr> pInit = simInit,\n      pTrans = \\<lambda>obs ec. the (lookup tOps (aTrans k_dfs) (ec, obs)),\n      pAct = \\<lambda>ec. the (lookup aOps (aActs k_dfs) ec)\n    \\<rparr>\""], ["", "(*>*)"], ["", "context AlgorithmForAgent\nbegin"], ["", "text\\<open>\n\nThe final algorithm, with the constants inlined, is shown in\nFigure~\\ref{fig:kbps-alg-algorithm}. The rest of this section shows\nits correctness.\n\nFirstly it follows immediately from \\<open>dfs_invariant\\<close> that the\ninvariant holds of the result of the DFS:\n\n\\<close>"], ["", "(*<*)"], ["", "abbreviation\n  \"k_dfs \\<equiv> KBPsAlg.alg_dfs aOps tOps (simObs a) (simTrans a) (simAction a) (k_frontier a)\""], ["", "(* This is a syntactic nightmare. *)"], ["", "lemma k_dfs_gen_dfs_unfold[simp]:\n  \"k_dfs = gen_dfs k_succs k_ins k_memb k_empt (k_frontier a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_dfs = KBPAlg.dfs k_empt (k_frontier a)", "unfolding alg_dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let k_empt =\n           \\<lparr>aActs = MapOps.empty aOps,\n              aTrans = MapOps.empty tOps\\<rparr>;\n         k_memb = \\<lambda>s A. isSome (lookup aOps (aActs A) s);\n         k_succs = k_succs;\n         actsUpdate =\n           \\<lambda>ec A. update aOps ec (simAction a ec) (aActs A);\n         transUpdate = \\<lambda>ec ec'. update tOps (ec, simObs a ec') ec';\n         k_ins =\n           \\<lambda>ec A.\n              \\<lparr>aActs = actsUpdate ec A,\n                 aTrans =\n                   foldr (transUpdate ec) (k_succs ec) (aTrans A)\\<rparr>\n     in gen_dfs k_succs k_ins k_memb k_empt)\n     (k_frontier a) =\n    KBPAlg.dfs k_empt (k_frontier a)", "apply (fold k_empt_def k_memb_def actsUpdate_def transUpdate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let k_empt = k_empt; k_memb = k_memb; k_succs = k_succs;\n         actsUpdate = actsUpdate; transUpdate = transUpdate;\n         k_ins =\n           \\<lambda>ec A.\n              \\<lparr>aActs = actsUpdate ec A,\n                 aTrans =\n                   foldr (transUpdate ec) (k_succs ec) (aTrans A)\\<rparr>\n     in gen_dfs k_succs k_ins k_memb k_empt)\n     (k_frontier a) =\n    KBPAlg.dfs k_empt (k_frontier a)", "apply (simp add: k_ins_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma k_dfs_invariant: \"k_invariant k_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_invariant k_dfs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_invariant k_dfs", "using KBPAlg.dfs_invariant[where S=\"k_empt\" and xs=\"k_frontier a\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>k_invariant k_empt; list_all k_isNode (k_frontier a)\\<rbrakk>\n  \\<Longrightarrow> k_invariant (KBPAlg.dfs k_empt (k_frontier a))\n\ngoal (1 subgoal):\n 1. k_invariant k_dfs", "by simp"], ["", "(*>*)"], ["", "text\\<open>\n\nSecondly we can see that the set of reachable equivalence classes\ncoincides with the partition of @{term \"jkbpC\"} under the simulation\nand representation functions:\n\n\\<close>"], ["", "lemma k_reachable:\n  \"simAbs ` KBPAlg.reachable (set (k_frontier a)) = sim_equiv_class a ` jkbpC\"\n(*<*)(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs ` KBPAlg.reachable (set (k_frontier a)) =\n    sim_equiv_class a ` jkbpC", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. simAbs ` KBPAlg.reachable (set (k_frontier a))\n    \\<subseteq> sim_equiv_class a ` jkbpC\n 2. sim_equiv_class a ` jkbpC\n    \\<subseteq> simAbs ` KBPAlg.reachable (set (k_frontier a))", "show \"?lhs \\<subseteq> ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs ` KBPAlg.reachable (set (k_frontier a))\n    \\<subseteq> sim_equiv_class a ` jkbpC", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "fix sx"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "assume \"sx \\<in> ?lhs\""], ["proof (state)\nthis:\n  sx \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "then"], ["proof (chain)\npicking this:\n  sx \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "obtain x\n      where x: \"x \\<in> KBPAlg.reachable (set (k_frontier a))\"\n        and sx: \"simAbs x = sx\""], ["proof (prove)\nusing this:\n  sx \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> KBPAlg.reachable (set (k_frontier a));\n         simAbs x = sx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> KBPAlg.reachable (set (k_frontier a))\n  simAbs x = sx\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "hence \"x \\<in> ({ (x, y). y \\<in> set (k_succs x) })\\<^sup>*\n                 `` set (map (simInit a \\<circ> envObs a) envInit)\""], ["proof (prove)\nusing this:\n  x \\<in> KBPAlg.reachable (set (k_frontier a))\n  simAbs x = sx\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n            set (map (simInit a \\<circ> envObs a) envInit)", "unfolding KBPAlg.reachable_def k_frontier_def"], ["proof (prove)\nusing this:\n  x \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n          set (map (simInit a \\<circ> envObs a) envInit)\n  simAbs x = sx\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n            set (map (simInit a \\<circ> envObs a) envInit)", "by simp"], ["proof (state)\nthis:\n  x \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n          set (map (simInit a \\<circ> envObs a) envInit)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "then"], ["proof (chain)\npicking this:\n  x \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n          set (map (simInit a \\<circ> envObs a) envInit)", "obtain s iobs\n      where R: \"(simInit a iobs, x) \\<in> ({ (x, y). y \\<in> set (k_succs x)})\\<^sup>*\"\n        and sI: \"s \\<in> set envInit\"\n        and iobs: \"envObs a s = iobs\""], ["proof (prove)\nusing this:\n  x \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n          set (map (simInit a \\<circ> envObs a) envInit)\n\ngoal (1 subgoal):\n 1. (\\<And>iobs s.\n        \\<lbrakk>(simInit a iobs, x)\n                 \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n         s \\<in> set envInit; envObs a s = iobs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  s \\<in> set envInit\n  envObs a s = iobs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "from R x"], ["proof (chain)\npicking this:\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  x \\<in> KBPAlg.reachable (set (k_frontier a))", "have \"simAbs x \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  x \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. simAbs x \\<in> sim_equiv_class a ` jkbpC", "proof(induct arbitrary: sx rule: rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. simInit a iobs\n    \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n    simAbs (simInit a iobs) \\<in> sim_equiv_class a ` jkbpC\n 2. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "case base"], ["proof (state)\nthis:\n  simInit a iobs \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (2 subgoals):\n 1. simInit a iobs\n    \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n    simAbs (simInit a iobs) \\<in> sim_equiv_class a ` jkbpC\n 2. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "with sI iobs"], ["proof (chain)\npicking this:\n  s \\<in> set envInit\n  envObs a s = iobs\n  simInit a iobs \\<in> KBPAlg.reachable (set (k_frontier a))", "show ?case"], ["proof (prove)\nusing this:\n  s \\<in> set envInit\n  envObs a s = iobs\n  simInit a iobs \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. simAbs (simInit a iobs) \\<in> sim_equiv_class a ` jkbpC", "by (auto simp: jviewInit simInit)"], ["proof (state)\nthis:\n  simAbs (simInit a iobs) \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "case (step x y)"], ["proof (state)\nthis:\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\n  x \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  y \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "with sI iobs"], ["proof (chain)\npicking this:\n  s \\<in> set envInit\n  envObs a s = iobs\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\n  x \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  y \\<in> KBPAlg.reachable (set (k_frontier a))", "have \"simAbs x \\<in> sim_equiv_class a ` jkbpC\""], ["proof (prove)\nusing this:\n  s \\<in> set envInit\n  envObs a s = iobs\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\n  x \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  y \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. simAbs x \\<in> sim_equiv_class a ` jkbpC", "unfolding KBPAlg.reachable_def Image_def k_frontier_def"], ["proof (prove)\nusing this:\n  s \\<in> set envInit\n  envObs a s = iobs\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\n  x \\<in> {y. \\<exists>x\\<in>set (map (simInit a \\<circ> envObs a) envInit).\n                 (x, y)\n                 \\<in> {(x, y).\n                        y \\<in> set (k_succs x)}\\<^sup>*} \\<Longrightarrow>\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  y \\<in> {y. \\<exists>x\\<in>set (map (simInit a \\<circ> envObs a) envInit).\n                 (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*}\n\ngoal (1 subgoal):\n 1. simAbs x \\<in> sim_equiv_class a ` jkbpC", "by auto"], ["proof (state)\nthis:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "then"], ["proof (chain)\npicking this:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC", "obtain t\n        where tC: \"t \\<in> jkbpC\"\n          and F: \"simAbs x = sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> jkbpC; simAbs x = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "from step"], ["proof (chain)\npicking this:\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\n  x \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  y \\<in> KBPAlg.reachable (set (k_frontier a))", "have \"simAbs y \\<in> simAbs ` set (k_succs x)\""], ["proof (prove)\nusing this:\n  (simInit a iobs, x) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n  (x, y) \\<in> {(x, y). y \\<in> set (k_succs x)}\n  x \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n  y \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. simAbs y \\<in> simAbs ` set (k_succs x)", "by auto"], ["proof (state)\nthis:\n  simAbs y \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>(simInit a iobs, y)\n                \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*;\n        (y, z) \\<in> {(x, y). y \\<in> set (k_succs x)};\n        y \\<in> KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n        simAbs y \\<in> sim_equiv_class a ` jkbpC;\n        z \\<in> KBPAlg.reachable (set (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> simAbs z \\<in> sim_equiv_class a ` jkbpC", "thus  ?case"], ["proof (prove)\nusing this:\n  simAbs y \\<in> simAbs ` set (k_succs x)\n\ngoal (1 subgoal):\n 1. simAbs y \\<in> sim_equiv_class a ` jkbpC", "using simTrans[rule_format, where a=a and t=t] tC F"], ["proof (prove)\nusing this:\n  simAbs y \\<in> simAbs ` set (k_succs x)\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (k_succs ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n  simAbs x = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. simAbs y \\<in> sim_equiv_class a ` jkbpC", "by auto"], ["proof (state)\nthis:\n  simAbs y \\<in> sim_equiv_class a ` jkbpC\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> simAbs `\n               KBPAlg.reachable (set (k_frontier a)) \\<Longrightarrow>\n       x \\<in> sim_equiv_class a ` jkbpC", "with sx"], ["proof (chain)\npicking this:\n  simAbs x = sx\n  simAbs x \\<in> sim_equiv_class a ` jkbpC", "show \"sx \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  simAbs x = sx\n  simAbs x \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. sx \\<in> sim_equiv_class a ` jkbpC", "by simp"], ["proof (state)\nthis:\n  sx \\<in> sim_equiv_class a ` jkbpC\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  simAbs ` KBPAlg.reachable (set (k_frontier a))\n  \\<subseteq> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. sim_equiv_class a ` jkbpC\n    \\<subseteq> simAbs ` KBPAlg.reachable (set (k_frontier a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sim_equiv_class a ` jkbpC\n    \\<subseteq> simAbs ` KBPAlg.reachable (set (k_frontier a))", "show \"?rhs \\<subseteq> ?lhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_equiv_class a ` jkbpC\n    \\<subseteq> simAbs ` KBPAlg.reachable (set (k_frontier a))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n       x \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "fix ec"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n       x \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "assume \"ec \\<in> ?rhs\""], ["proof (state)\nthis:\n  ec \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n       x \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "then"], ["proof (chain)\npicking this:\n  ec \\<in> sim_equiv_class a ` jkbpC", "obtain t\n      where tC: \"t \\<in> jkbpC\"\n        and ec: \"ec = sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  ec \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n  ec = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sim_equiv_class a ` jkbpC \\<Longrightarrow>\n       x \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "thus \"ec \\<in> ?lhs\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  ec = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "proof(induct t arbitrary: ec)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ec.\n       \\<lbrakk>tInit x \\<in> jkbpC;\n        ec = sim_equiv_class a (tInit x)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))\n 2. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "case (tInit s)"], ["proof (state)\nthis:\n  tInit s \\<in> jkbpC\n  ec = sim_equiv_class a (tInit s)\n\ngoal (2 subgoals):\n 1. \\<And>x ec.\n       \\<lbrakk>tInit x \\<in> jkbpC;\n        ec = sim_equiv_class a (tInit x)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))\n 2. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "thus ?case"], ["proof (prove)\nusing this:\n  tInit s \\<in> jkbpC\n  ec = sim_equiv_class a (tInit s)\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "unfolding KBPAlg.reachable_def"], ["proof (prove)\nusing this:\n  tInit s \\<in> jkbpC\n  ec = sim_equiv_class a (tInit s)\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs `\n             {(x, y). y \\<in> set (k_succs x)}\\<^sup>* `` set (k_frontier a)", "(* FIXME ouch this is touchy *)"], ["proof (prove)\nusing this:\n  tInit s \\<in> jkbpC\n  ec = sim_equiv_class a (tInit s)\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs `\n             {(x, y). y \\<in> set (k_succs x)}\\<^sup>* `` set (k_frontier a)", "unfolding k_frontier_def"], ["proof (prove)\nusing this:\n  tInit s \\<in> jkbpC\n  ec = sim_equiv_class a (tInit s)\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs `\n             {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n             set (map (simInit a \\<circ> envObs a) envInit)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set envInit; ec = sim_equiv_class a (tInit s)\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (tInit s)\n                      \\<in> simAbs `\n                            {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n                            (\\<lambda>x. simInit a (envObs a x)) `\n                            set envInit", "apply (rule image_eqI[where x=\"simInit a (envObs a s)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set envInit; ec = sim_equiv_class a (tInit s)\\<rbrakk>\n    \\<Longrightarrow> sim_equiv_class a (tInit s) =\n                      simAbs (simInit a (envObs a s))\n 2. \\<lbrakk>s \\<in> set envInit; ec = sim_equiv_class a (tInit s)\\<rbrakk>\n    \\<Longrightarrow> simInit a (envObs a s)\n                      \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n                            (\\<lambda>x. simInit a (envObs a x)) `\n                            set envInit", "apply (simp add: simInit jviewInit)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> set envInit; ec = sim_equiv_class a (tInit s)\\<rbrakk>\n    \\<Longrightarrow> simInit a (envObs a s)\n                      \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* ``\n                            (\\<lambda>x. simInit a (envObs a x)) `\n                            set envInit", "apply (rule ImageI[where a=\"simInit a (envObs a s)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set envInit; ec = sim_equiv_class a (tInit s)\\<rbrakk>\n    \\<Longrightarrow> (simInit a (envObs a s), simInit a (envObs a s))\n                      \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n 2. \\<lbrakk>s \\<in> set envInit; ec = sim_equiv_class a (tInit s)\\<rbrakk>\n    \\<Longrightarrow> simInit a (envObs a s)\n                      \\<in> (\\<lambda>x. simInit a (envObs a x)) `\n                            set envInit", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "case (tStep t s)"], ["proof (state)\nthis:\n  \\<lbrakk>t \\<in> jkbpC; ?ec11 = sim_equiv_class a t\\<rbrakk>\n  \\<Longrightarrow> ?ec11\n                    \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "hence tsC: \"t \\<leadsto> s \\<in> jkbpC\"\n        and ec: \"ec = sim_equiv_class a (t \\<leadsto> s)\"\n        and \"sim_equiv_class a t\n           \\<in> simAbs ` DFS.reachable k_succs (set (k_frontier a))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t \\<in> jkbpC; ?ec11 = sim_equiv_class a t\\<rbrakk>\n  \\<Longrightarrow> ?ec11\n                    \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. t \\<leadsto> s \\<in> jkbpC &&&\n    ec = sim_equiv_class a (t \\<leadsto> s) &&&\n    sim_equiv_class a t \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "by auto"], ["proof (state)\nthis:\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n  sim_equiv_class a t \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "then"], ["proof (chain)\npicking this:\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n  sim_equiv_class a t \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "obtain rect\n        where rect: \"rect \\<in> DFS.reachable k_succs (set (k_frontier a))\"\n          and srect: \"simAbs rect = sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n  sim_equiv_class a t \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. (\\<And>rect.\n        \\<lbrakk>rect \\<in> KBPAlg.reachable (set (k_frontier a));\n         simAbs rect = sim_equiv_class a t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rect \\<in> KBPAlg.reachable (set (k_frontier a))\n  simAbs rect = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "from tsC ec srect"], ["proof (chain)\npicking this:\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n  simAbs rect = sim_equiv_class a t", "have \"ec \\<in> simAbs ` set (simTrans a rect)\""], ["proof (prove)\nusing this:\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n  simAbs rect = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs ` set (k_succs rect)", "using simTrans[rule_format, where a=a and t=\"t\" and ec=\"rect\"] srect"], ["proof (prove)\nusing this:\n  t \\<leadsto> s \\<in> jkbpC\n  ec = sim_equiv_class a (t \\<leadsto> s)\n  simAbs rect = sim_equiv_class a t\n  t \\<in> jkbpC \\<and> simAbs rect = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (k_succs rect) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  simAbs rect = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. ec \\<in> simAbs ` set (k_succs rect)", "by auto"], ["proof (state)\nthis:\n  ec \\<in> simAbs ` set (k_succs rect)\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "then"], ["proof (chain)\npicking this:\n  ec \\<in> simAbs ` set (k_succs rect)", "obtain rec\n        where rec: \"ec = simAbs rec\"\n          and F: \"rec \\<in> set (simTrans a rect)\""], ["proof (prove)\nusing this:\n  ec \\<in> simAbs ` set (k_succs rect)\n\ngoal (1 subgoal):\n 1. (\\<And>rec.\n        \\<lbrakk>ec = simAbs rec; rec \\<in> set (k_succs rect)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ec = simAbs rec\n  rec \\<in> set (k_succs rect)\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "from rect"], ["proof (chain)\npicking this:\n  rect \\<in> KBPAlg.reachable (set (k_frontier a))", "obtain rec0\n        where rec0: \"rec0 \\<in> set (k_frontier a)\"\n          and rec0rect: \"(rec0, rect) \\<in> ({ (x, y). y \\<in> set (k_succs x)})\\<^sup>*\""], ["proof (prove)\nusing this:\n  rect \\<in> KBPAlg.reachable (set (k_frontier a))\n\ngoal (1 subgoal):\n 1. (\\<And>rec0.\n        \\<lbrakk>rec0 \\<in> set (k_frontier a);\n         (rec0, rect)\n         \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding KBPAlg.reachable_def"], ["proof (prove)\nusing this:\n  rect \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* `` set (k_frontier a)\n\ngoal (1 subgoal):\n 1. (\\<And>rec0.\n        \\<lbrakk>rec0 \\<in> set (k_frontier a);\n         (rec0, rect)\n         \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  rec0 \\<in> set (k_frontier a)\n  (rec0, rect) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>t x2 ec.\n       \\<lbrakk>\\<And>ec.\n                   \\<lbrakk>t \\<in> jkbpC; ec = sim_equiv_class a t\\<rbrakk>\n                   \\<Longrightarrow> ec \\<in> simAbs `\n        KBPAlg.reachable (set (k_frontier a));\n        t \\<leadsto> x2 \\<in> jkbpC;\n        ec = sim_equiv_class a (t \\<leadsto> x2)\\<rbrakk>\n       \\<Longrightarrow> ec \\<in> simAbs `\n                                  KBPAlg.reachable (set (k_frontier a))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))", "apply (rule image_eqI[where x=\"rec\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ec = simAbs rec\n 2. rec \\<in> KBPAlg.reachable (set (k_frontier a))", "apply (rule rec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec \\<in> KBPAlg.reachable (set (k_frontier a))", "unfolding KBPAlg.reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec\n    \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>* `` set (k_frontier a)", "apply (rule ImageI[where a=\"rec0\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (rec0, rec) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n 2. rec0 \\<in> set (k_frontier a)", "apply (rule rtrancl_into_rtrancl[where b=\"rect\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (rec0, rect) \\<in> {(x, y). y \\<in> set (k_succs x)}\\<^sup>*\n 2. (rect, rec) \\<in> {(x, y). y \\<in> set (k_succs x)}\n 3. rec0 \\<in> set (k_frontier a)", "apply (rule rec0rect)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (rect, rec) \\<in> {(x, y). y \\<in> set (k_succs x)}\n 2. rec0 \\<in> set (k_frontier a)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. rec \\<in> set (k_succs rect)\n 2. rec0 \\<in> set (k_frontier a)", "apply (rule F)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec0 \\<in> set (k_frontier a)", "apply (rule rec0)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ec \\<in> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sim_equiv_class a ` jkbpC\n  \\<subseteq> simAbs ` KBPAlg.reachable (set (k_frontier a))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nLeft to right follows from an induction on the reflexive, transitive\nclosure, and right to left by induction over canonical traces.\n\nThis result immediately yields the same result at the level of\nrepresentations:\n\n\\<close>"], ["", "lemma k_memb_rep:\n  assumes N: \"k_isNode rec\"\n  shows \"k_memb rec k_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "from N"], ["proof (chain)\npicking this:\n  k_isNode rec", "obtain rec'\n    where r: \"rec' \\<in> DFS.reachable k_succs (set (k_frontier a))\"\n      and rec': \"simAbs rec = simAbs rec'\""], ["proof (prove)\nusing this:\n  k_isNode rec\n\ngoal (1 subgoal):\n 1. (\\<And>rec'.\n        \\<lbrakk>rec' \\<in> KBPAlg.reachable (set (k_frontier a));\n         simAbs rec = simAbs rec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding k_isNode_def"], ["proof (prove)\nusing this:\n  simAbs rec \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. (\\<And>rec'.\n        \\<lbrakk>rec' \\<in> KBPAlg.reachable (set (k_frontier a));\n         simAbs rec = simAbs rec'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto iff: k_reachable[symmetric])"], ["proof (state)\nthis:\n  rec' \\<in> KBPAlg.reachable (set (k_frontier a))\n  simAbs rec = simAbs rec'\n\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "from N k_isNode_cong[OF rec', symmetric]"], ["proof (chain)\npicking this:\n  k_isNode rec\n  k_isNode rec' = k_isNode rec", "have N': \"k_isNode rec'\""], ["proof (prove)\nusing this:\n  k_isNode rec\n  k_isNode rec' = k_isNode rec\n\ngoal (1 subgoal):\n 1. k_isNode rec'", "unfolding k_isNode_def"], ["proof (prove)\nusing this:\n  simAbs rec \\<in> sim_equiv_class a ` jkbpC\n  (simAbs rec' \\<in> sim_equiv_class a ` jkbpC) =\n  (simAbs rec \\<in> sim_equiv_class a ` jkbpC)\n\ngoal (1 subgoal):\n 1. simAbs rec' \\<in> sim_equiv_class a ` jkbpC", "by auto"], ["proof (state)\nthis:\n  k_isNode rec'\n\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "show \"k_memb rec k_dfs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "using KBPAlg.reachable_imp_dfs[OF N' k_frontier_is_node r]"], ["proof (prove)\nusing this:\n  \\<exists>y'.\n     simAbs y' = simAbs rec' \\<and>\n     k_memb y' (KBPAlg.dfs k_empt (k_frontier a))\n\ngoal (1 subgoal):\n 1. k_memb rec k_dfs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        k_memb y' (KBPAlg.dfs k_empt (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> k_memb rec (KBPAlg.dfs k_empt (k_frontier a))", "apply (subst k_memb_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        k_memb y' (KBPAlg.dfs k_empt (k_frontier a))\\<rbrakk>\n       \\<Longrightarrow> isSome\n                          (lookup aOps\n                            (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec)", "apply (subst (asm) k_memb_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome\n         (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a)))\n           y')\\<rbrakk>\n       \\<Longrightarrow> isSome\n                          (lookup aOps\n                            (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec)", "using k_invariantAOD[OF N' N rec' k_dfs_invariant, symmetric]"], ["proof (prove)\nusing this:\n  lookup aOps (aActs k_dfs) rec = lookup aOps (aActs k_dfs) rec'\n\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome\n         (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a)))\n           y')\\<rbrakk>\n       \\<Longrightarrow> isSome\n                          (lookup aOps\n                            (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec)", "apply (cut_tac ec=y' and ec'=rec' in k_invariantAOD[OF _ _ _ k_dfs_invariant, symmetric])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs k_dfs) rec =\n        lookup aOps (aActs k_dfs) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode y'\n 2. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs k_dfs) rec =\n        lookup aOps (aActs k_dfs) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode rec'\n 3. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs k_dfs) rec =\n        lookup aOps (aActs k_dfs) rec'\\<rbrakk>\n       \\<Longrightarrow> simAbs rec' = simAbs y'\n 4. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs k_dfs) rec = lookup aOps (aActs k_dfs) rec';\n        lookup aOps (aActs k_dfs) rec' =\n        lookup aOps (aActs k_dfs) y'\\<rbrakk>\n       \\<Longrightarrow> isSome\n                          (lookup aOps\n                            (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode y'\n 2. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode rec'", "apply (cut_tac ec=rec' and ec'=y' in k_isNode_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> simAbs y' = simAbs rec'\n 2. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec';\n        k_isNode y' = k_isNode rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode y'\n 3. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode rec'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec';\n        k_isNode y' = k_isNode rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode y'\n 2. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode rec'", "using N'"], ["proof (prove)\nusing this:\n  k_isNode rec'\n\ngoal (2 subgoals):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec';\n        k_isNode y' = k_isNode rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode y'\n 2. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode rec'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y'.\n       \\<lbrakk>simAbs y' = simAbs rec';\n        isSome (lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) y');\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec =\n        lookup aOps (aActs (KBPAlg.dfs k_empt (k_frontier a))) rec'\\<rbrakk>\n       \\<Longrightarrow> k_isNode rec'", "apply (rule N')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  k_memb rec k_dfs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "(* context AlgorithmForAgent *)"], ["", "text\\<open>\n\nThis concludes our agent-specific reasoning; we now show that the\nalgorithm works for all agents. The following command generalises all\nour lemmas in the @{term \"AlgorithmForAgent\"} to the @{term\n\"Algorithm\"} locale, giving them the mandatory prefix \\<open>KBP\\<close>:\n\n\\<close>"], ["", "sublocale Algorithm\n        < KBP: AlgorithmForAgent\n            jkbp envInit envAction envTrans envVal jview envObs\n            jviewInit jviewIncr simf simRels simVal simAbs simObs\n            simInit simTrans simAction aOps tOps a for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. AlgorithmForAgent jkbp envInit envAction envTrans envVal jview envObs\n     jviewInit jviewIncr simf simRels simVal simAbs simObs simInit simTrans\n     simAction aOps tOps", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. AlgorithmForAgent jkbp envInit envAction envTrans envVal jview envObs\n     jviewInit jviewIncr simf simRels simVal simAbs simObs simInit simTrans\n     simAction aOps tOps", "by unfold_locales"], ["", "(*>*)"], ["", "context Algorithm\nbegin"], ["", "abbreviation\n  \"k_mkAlgAuto \\<equiv>\n    mkAlgAuto aOps tOps simObs simInit simTrans simAction k_frontier\""], ["", "(*<*)"], ["", "lemma k_mkAlgAuto_mkAutoSim_equiv:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)", "using tC"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)", "proof(induct t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       tInit x \\<in> jkbpC \\<Longrightarrow>\n       simAbs (runJP k_mkAlgAuto (tInit x) a) =\n       simAbs (runJP mkAutoSim (tInit x) a)\n 2. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "case (tInit s)"], ["proof (state)\nthis:\n  tInit s \\<in> jkbpC\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       tInit x \\<in> jkbpC \\<Longrightarrow>\n       simAbs (runJP k_mkAlgAuto (tInit x) a) =\n       simAbs (runJP mkAutoSim (tInit x) a)\n 2. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "thus ?case"], ["proof (prove)\nusing this:\n  tInit s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto (tInit s) a) =\n    simAbs (runJP mkAutoSim (tInit s) a)", "by simp"], ["proof (state)\nthis:\n  simAbs (runJP k_mkAlgAuto (tInit s) a) =\n  simAbs (runJP mkAutoSim (tInit s) a)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "case (tStep t s)"], ["proof (state)\nthis:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "hence tC: \"t \\<in> jkbpC\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. t \\<in> jkbpC", "by blast"], ["proof (state)\nthis:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "from tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC", "have N: \"KBP.k_isNode a (runJP k_mkAlgAuto t a)\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. KBP.k_isNode a (runJP k_mkAlgAuto t a)", "unfolding KBP.k_isNode_def"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) \\<in> sim_equiv_class a ` jkbpC", "by (simp only: mkAutoSim_ec) auto"], ["proof (state)\nthis:\n  KBP.k_isNode a (runJP k_mkAlgAuto t a)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "from tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC", "have ect: \"simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t", "by (simp only: mkAutoSim_ec) auto"], ["proof (state)\nthis:\n  simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "from tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC", "have \"sim_equiv_class a (t \\<leadsto> s) \\<in> simAbs ` set (simTrans a (runJP k_mkAlgAuto t a))\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. sim_equiv_class a (t \\<leadsto> s)\n    \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "using simTrans[rule_format, where a=a and t=t] tC ect"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<in> jkbpC \\<and> simAbs ?ec = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (KBP.k_succs a ?ec) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n  simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. sim_equiv_class a (t \\<leadsto> s)\n    \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "by auto"], ["proof (state)\nthis:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "then"], ["proof (chain)\npicking this:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "obtain ec\n    where ec: \"ec \\<in> set (simTrans a (runJP k_mkAlgAuto t a))\"\n      and sec: \"simAbs ec = sim_equiv_class a (t \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  sim_equiv_class a (t \\<leadsto> s)\n  \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. (\\<And>ec.\n        \\<lbrakk>ec \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n         simAbs ec = sim_equiv_class a (t \\<leadsto> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ec \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a))\n  simAbs ec = sim_equiv_class a (t \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "from tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC", "have F: \"envObs a s \\<in> simObs a ` set (simTrans a (runJP k_mkAlgAuto t a))\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. envObs a s \\<in> simObs a ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "using simObs[rule_format, where a=a and t=\"t\\<leadsto>s\", symmetric] sec ec"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n  t \\<leadsto> s \\<in> jkbpC \\<and>\n  simAbs ?ec = sim_equiv_class a (t \\<leadsto> s) \\<Longrightarrow>\n  envObs a (tLast (t \\<leadsto> s)) = simObs a ?ec\n  simAbs ec = sim_equiv_class a (t \\<leadsto> s)\n  ec \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. envObs a s \\<in> simObs a ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "by auto"], ["proof (state)\nthis:\n  envObs a s \\<in> simObs a ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "from KBP.k_memb_rep[OF N]"], ["proof (chain)\npicking this:\n  KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)", "have E: \"KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)\""], ["proof (prove)\nusing this:\n  KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)\n\ngoal (1 subgoal):\n 1. KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)", "by blast"], ["proof (state)\nthis:\n  KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "have G: \"simAbs (runJP k_mkAlgAuto (t \\<leadsto> s) a) = sim_equiv_class a (t \\<leadsto> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto (t \\<leadsto> s) a) =\n    sim_equiv_class a (t \\<leadsto> s)", "using KBP.k_invariantTD[OF N E F KBP.k_dfs_invariant]"], ["proof (prove)\nusing this:\n  \\<exists>ec'.\n     lookup tOps (aTrans (KBP.k_dfs a))\n      (runJP k_mkAlgAuto t a, envObs a s) =\n     Some ec' \\<and>\n     simAbs ec'\n     \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) \\<and>\n     simObs a ec' = envObs a s\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto (t \\<leadsto> s) a) =\n    sim_equiv_class a (t \\<leadsto> s)", "apply (clarsimp simp: jviewIncr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a))\\<rbrakk>\n       \\<Longrightarrow> simAbs x =\n                         simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' = jviewIncr a (envObs a s) (jview a t)}", "using simTrans[rule_format, where a=a and t=t and ec=\"runJP k_mkAlgAuto t a\"] tC ect"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<and>\n  simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t \\<Longrightarrow>\n  simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n  {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n   t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t}\n  t \\<in> jkbpC\n  simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\n\ngoal (1 subgoal):\n 1. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a))\\<rbrakk>\n       \\<Longrightarrow> simAbs x =\n                         simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' = jviewIncr a (envObs a s) (jview a t)}", "apply (subgoal_tac \"simAbs x \\<in> simAbs ` set (simTrans a (runJP k_mkAlgAuto t a))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        t \\<in> jkbpC \\<and>\n        simAbs (runJP k_mkAlgAuto t a) =\n        sim_equiv_class a t \\<Longrightarrow>\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t;\n        simAbs x\n        \\<in> simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a))\\<rbrakk>\n       \\<Longrightarrow> simAbs x =\n                         simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' = jviewIncr a (envObs a s) (jview a t)}\n 2. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        t \\<in> jkbpC \\<and>\n        simAbs (runJP k_mkAlgAuto t a) =\n        sim_equiv_class a t \\<Longrightarrow>\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC;\n        simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> simAbs x\n                         \\<in> simAbs `\n                               set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "apply (clarsimp simp: jviewIncr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ec' x t' sa.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s;\n        simAbs ec' =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {simf `\n         {t'a \\<in> jkbpC.\n          jview a t'a = jviewIncr a (envObs a s) (jview a t')} |\n         t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t;\n        simAbs x =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        t' \\<leadsto> sa \\<in> jkbpC; jview a t' = jview a t\\<rbrakk>\n       \\<Longrightarrow> simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' =\n                          jviewIncr a (envObs a sa) (jview a t)} =\n                         simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' = jviewIncr a (envObs a s) (jview a t)}\n 2. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        t \\<in> jkbpC \\<and>\n        simAbs (runJP k_mkAlgAuto t a) =\n        sim_equiv_class a t \\<Longrightarrow>\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC;\n        simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> simAbs x\n                         \\<in> simAbs `\n                               set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "apply (cut_tac a=a and ec=ec' and t=\"t'\\<leadsto>sa\" in simObs[rule_format])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ec' x t' sa.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s;\n        simAbs ec' =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {simf `\n         {t'a \\<in> jkbpC.\n          jview a t'a = jviewIncr a (envObs a s) (jview a t')} |\n         t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t;\n        simAbs x =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        t' \\<leadsto> sa \\<in> jkbpC; jview a t' = jview a t\\<rbrakk>\n       \\<Longrightarrow> t' \\<leadsto> sa \\<in> jkbpC \\<and>\n                         simAbs ec' = sim_equiv_class a (t' \\<leadsto> sa)\n 2. \\<And>ec' x t' sa.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s;\n        simAbs ec' =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {simf `\n         {t'a \\<in> jkbpC.\n          jview a t'a = jviewIncr a (envObs a s) (jview a t')} |\n         t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t;\n        simAbs x =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        t' \\<leadsto> sa \\<in> jkbpC; jview a t' = jview a t;\n        simObs a ec' = envObs a (tLast (t' \\<leadsto> sa))\\<rbrakk>\n       \\<Longrightarrow> simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' =\n                          jviewIncr a (envObs a sa) (jview a t)} =\n                         simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' = jviewIncr a (envObs a s) (jview a t)}\n 3. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        t \\<in> jkbpC \\<and>\n        simAbs (runJP k_mkAlgAuto t a) =\n        sim_equiv_class a t \\<Longrightarrow>\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC;\n        simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> simAbs x\n                         \\<in> simAbs `\n                               set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "apply (simp add: jviewIncr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ec' x t' sa.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s;\n        simAbs ec' =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {simf `\n         {t'a \\<in> jkbpC.\n          jview a t'a = jviewIncr a (envObs a s) (jview a t')} |\n         t' s. t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC; simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t;\n        simAbs x =\n        simf `\n        {t' \\<in> jkbpC.\n         jview a t' = jviewIncr a (envObs a sa) (jview a t)};\n        t' \\<leadsto> sa \\<in> jkbpC; jview a t' = jview a t;\n        simObs a ec' = envObs a (tLast (t' \\<leadsto> sa))\\<rbrakk>\n       \\<Longrightarrow> simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' =\n                          jviewIncr a (envObs a sa) (jview a t)} =\n                         simf `\n                         {t' \\<in> jkbpC.\n                          jview a t' = jviewIncr a (envObs a s) (jview a t)}\n 2. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        t \\<in> jkbpC \\<and>\n        simAbs (runJP k_mkAlgAuto t a) =\n        sim_equiv_class a t \\<Longrightarrow>\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC;\n        simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> simAbs x\n                         \\<in> simAbs `\n                               set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ec' x.\n       \\<lbrakk>lookup tOps\n                 (aTrans (KBP.KBPAlg.dfs a KBP.k_empt (k_frontier a)))\n                 (runJP k_mkAlgAuto t a, envObs a s) =\n                Some ec';\n        simObs a ec' = envObs a s; simAbs ec' = simAbs x;\n        x \\<in> set (KBP.k_succs a (runJP k_mkAlgAuto t a));\n        t \\<in> jkbpC \\<and>\n        simAbs (runJP k_mkAlgAuto t a) =\n        sim_equiv_class a t \\<Longrightarrow>\n        simAbs ` set (KBP.k_succs a (runJP k_mkAlgAuto t a)) =\n        {sim_equiv_class a (t' \\<leadsto> s) |t' s.\n         t' \\<leadsto> s \\<in> jkbpC \\<and> jview a t' = jview a t};\n        t \\<in> jkbpC;\n        simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\\<rbrakk>\n       \\<Longrightarrow> simAbs x\n                         \\<in> simAbs `\n                               set (KBP.k_succs a (runJP k_mkAlgAuto t a))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simAbs (runJP k_mkAlgAuto (t \\<leadsto> s) a) =\n  sim_equiv_class a (t \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. \\<And>t x2.\n       \\<lbrakk>t \\<in> jkbpC \\<Longrightarrow>\n                simAbs (runJP k_mkAlgAuto t a) =\n                simAbs (runJP mkAutoSim t a);\n        t \\<leadsto> x2 \\<in> jkbpC\\<rbrakk>\n       \\<Longrightarrow> simAbs (runJP k_mkAlgAuto (t \\<leadsto> x2) a) =\n                         simAbs (runJP mkAutoSim (t \\<leadsto> x2) a)", "from tStep"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC", "show ?case"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC \\<Longrightarrow>\n  simAbs (runJP k_mkAlgAuto t a) = simAbs (runJP mkAutoSim t a)\n  t \\<leadsto> s \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto (t \\<leadsto> s) a) =\n    simAbs (runJP mkAutoSim (t \\<leadsto> s) a)", "by (simp only: G mkAutoSim_ec)"], ["proof (state)\nthis:\n  simAbs (runJP k_mkAlgAuto (t \\<leadsto> s) a) =\n  simAbs (runJP mkAutoSim (t \\<leadsto> s) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nRunning the automata produced by the DFS on a canonical trace @{term\n\"t\"} yields some representation of the expected equivalence class:\n\n\\<close>"], ["", "lemma k_mkAlgAuto_ec:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t", "using k_mkAlgAuto_mkAutoSim_equiv[OF tC] mkAutoSim_ec[OF tC]"], ["proof (prove)\nusing this:\n  simAbs (runJP k_mkAlgAuto t ?a) = simAbs (runJP mkAutoSim t ?a)\n  simAbs (runJP mkAutoSim t ?a) = sim_equiv_class ?a t\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) = sim_equiv_class a t", "by simp"], ["", "(*>*)"], ["", "text\\<open>\n\nThis involves an induction over the canonical trace @{term \"t\"}.\n\nThat the DFS and @{term \"mkAutoSim\"} yield the same actions on\ncanonical traces follows immediately from this result and the\ninvariant:\n\n\\<close>"], ["", "lemma k_mkAlgAuto_mkAutoSim_act_eq:\n  assumes tC: \"t \\<in> jkbpC\"\n  shows \"set \\<circ> actJP k_mkAlgAuto t = set \\<circ> actJP mkAutoSim t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<circ> actJP k_mkAlgAuto t = set \\<circ> actJP mkAutoSim t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set \\<circ> actJP k_mkAlgAuto t = set \\<circ> actJP mkAutoSim t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "let ?ec = \"sim_equiv_class a t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "let ?rec = \"runJP k_mkAlgAuto t a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "from tC"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC", "have E: \"?ec \\<in> sim_equiv_class a ` jkbpC\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n\ngoal (1 subgoal):\n 1. sim_equiv_class a t \\<in> sim_equiv_class a ` jkbpC", "by auto"], ["proof (state)\nthis:\n  sim_equiv_class a t \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "from tC E"], ["proof (chain)\npicking this:\n  t \\<in> jkbpC\n  sim_equiv_class a t \\<in> sim_equiv_class a ` jkbpC", "have N: \"KBP.k_isNode a (runJP k_mkAlgAuto t a)\""], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  sim_equiv_class a t \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. KBP.k_isNode a (runJP k_mkAlgAuto t a)", "unfolding KBP.k_isNode_def"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\n  sim_equiv_class a t \\<in> sim_equiv_class a ` jkbpC\n\ngoal (1 subgoal):\n 1. simAbs (runJP k_mkAlgAuto t a) \\<in> sim_equiv_class a ` jkbpC", "by (simp add: k_mkAlgAuto_ec[OF tC])"], ["proof (state)\nthis:\n  KBP.k_isNode a (runJP k_mkAlgAuto t a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "from KBP.k_memb_rep[OF N]"], ["proof (chain)\npicking this:\n  KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)", "have E: \"KBP.k_memb ?rec (KBP.k_dfs a)\""], ["proof (prove)\nusing this:\n  KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)\n\ngoal (1 subgoal):\n 1. KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)", "by blast"], ["proof (state)\nthis:\n  KBP.k_memb (runJP k_mkAlgAuto t a) (KBP.k_dfs a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "obtain acts\n    where \"lookup aOps (aActs (KBP.k_dfs a)) ?rec = Some acts\"\n      and \"set acts = set (simAction a ?rec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>acts.\n        \\<lbrakk>lookup aOps (aActs (KBP.k_dfs a)) (runJP k_mkAlgAuto t a) =\n                 Some acts;\n         set acts = set (simAction a (runJP k_mkAlgAuto t a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using KBP.k_invariantAD[OF N E KBP.k_dfs_invariant]"], ["proof (prove)\nusing this:\n  \\<exists>acts.\n     lookup aOps (aActs (KBP.k_dfs a)) (runJP k_mkAlgAuto t a) =\n     Some acts \\<and>\n     set acts = set (simAction a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. (\\<And>acts.\n        \\<lbrakk>lookup aOps (aActs (KBP.k_dfs a)) (runJP k_mkAlgAuto t a) =\n                 Some acts;\n         set acts = set (simAction a (runJP k_mkAlgAuto t a))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  lookup aOps (aActs (KBP.k_dfs a)) (runJP k_mkAlgAuto t a) = Some acts\n  set acts = set (simAction a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (set \\<circ> actJP k_mkAlgAuto t) x =\n       (set \\<circ> actJP mkAutoSim t) x", "thus \"(set \\<circ> actJP k_mkAlgAuto t) a = (set \\<circ> actJP mkAutoSim t) a\""], ["proof (prove)\nusing this:\n  lookup aOps (aActs (KBP.k_dfs a)) (runJP k_mkAlgAuto t a) = Some acts\n  set acts = set (simAction a (runJP k_mkAlgAuto t a))\n\ngoal (1 subgoal):\n 1. (set \\<circ> actJP k_mkAlgAuto t) a = (set \\<circ> actJP mkAutoSim t) a", "by (auto intro!: jAction_simAbs_cong[OF tC]\n               simp: k_mkAlgAuto_ec[OF tC] mkAutoSim_ec[OF tC])"], ["proof (state)\nthis:\n  (set \\<circ> actJP k_mkAlgAuto t) a = (set \\<circ> actJP mkAutoSim t) a\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nTherefore these two constructions are behaviourally equivalent, and so\nthe DFS generates an implementation of @{term \"jkbp\"} in the given\nenvironment:\n\n\\<close>"], ["", "theorem k_mkAlgAuto_implements: \"implements k_mkAlgAuto\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements k_mkAlgAuto", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. implements k_mkAlgAuto", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. implements k_mkAlgAuto", "have \"behaviourally_equiv mkAutoSim k_mkAlgAuto\""], ["proof (prove)\ngoal (1 subgoal):\n 1. behaviourally_equiv mkAutoSim k_mkAlgAuto", "by rule (simp only: k_mkAlgAuto_mkAutoSim_act_eq)"], ["proof (state)\nthis:\n  behaviourally_equiv mkAutoSim k_mkAlgAuto\n\ngoal (1 subgoal):\n 1. implements k_mkAlgAuto", "with mkAutoSim_implements"], ["proof (chain)\npicking this:\n  implements mkAutoSim\n  behaviourally_equiv mkAutoSim k_mkAlgAuto", "show ?thesis"], ["proof (prove)\nusing this:\n  implements mkAutoSim\n  behaviourally_equiv mkAutoSim k_mkAlgAuto\n\ngoal (1 subgoal):\n 1. implements k_mkAlgAuto", "by (simp add: behaviourally_equiv_implements)"], ["proof (state)\nthis:\n  implements k_mkAlgAuto\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "(* context Algorithm *)"], ["", "text\\<open>\n\nClearly the automata generated by this algorithm are large. We discuss\nthis issue in \\S\\ref{sec:kbps-alg-auto-min}.\n\n\\FloatBarrier\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}