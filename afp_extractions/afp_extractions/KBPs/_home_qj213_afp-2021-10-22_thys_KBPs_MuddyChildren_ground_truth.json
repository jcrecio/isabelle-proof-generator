{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/MuddyChildren.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma Agent_univ: \"(UNIV :: Agent set) = {Child0, Child1, Child2}\"", "lemma Act_univ: \"(UNIV :: ChildAct set) = {SayIKnow, SayNothing}\"", "lemma (in FiniteLinorderEnvironment)\n  \"MC.Clock.implements mc_ClockAlg\"", "lemma (in FiniteDetBroadcastEnvironment)\n  \"MC.SPR.implements mc_SPRAlg\""], "translations": [["", "lemma Agent_univ: \"(UNIV :: Agent set) = {Child0, Child1, Child2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {Child0, Child1, Child2}", "unfolding UNIV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext (\\<lambda>x. True) = {Child0, Child1, Child2}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> Child0; x \\<noteq> Child1\\<rbrakk>\n       \\<Longrightarrow> x = Child2", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> Child0; x \\<noteq> Child1; x = Child0\\<rbrakk>\n       \\<Longrightarrow> x = Child2\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> Child0; x \\<noteq> Child1; x = Child1\\<rbrakk>\n       \\<Longrightarrow> x = Child2\n 3. \\<And>x.\n       \\<lbrakk>x \\<noteq> Child0; x \\<noteq> Child1; x = Child2\\<rbrakk>\n       \\<Longrightarrow> x = Child2", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance Agent :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Agent, finite_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite UNIV", "apply (auto iff: Agent_univ)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation Agent :: linorder\nbegin"], ["", "fun\n  less_Agent\nwhere\n  \"less_Agent Child0 Child0 = False\"\n| \"less_Agent Child0 _      = True\"\n| \"less_Agent Child1 Child2 = True\"\n| \"less_Agent Child1 _      = False\"\n| \"less_Agent Child2 _      = False\""], ["", "definition\n  less_eq_Agent :: \"Agent \\<Rightarrow> Agent \\<Rightarrow> bool\"\nwhere\n  \"less_eq_Agent x y \\<equiv> x = y \\<or> x < y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Agent, linorder_class)", "apply intro_classes"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "unfolding less_eq_Agent_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       (x < y) = ((x = y \\<or> x < y) \\<and> \\<not> (y = x \\<or> y < x))\n 2. \\<And>x. x = x \\<or> x < x\n 3. \\<And>x y z.\n       \\<lbrakk>x = y \\<or> x < y; y = z \\<or> y < z\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 4. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y. (x = y \\<or> x < y) \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac y, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y.\n       x = Child1 \\<Longrightarrow>\n       (Child1 < y) =\n       ((Child1 = y \\<or> Child1 < y) \\<and>\n        y \\<noteq> Child1 \\<and> \\<not> y < Child1)\n 2. \\<And>x y z.\n       \\<lbrakk>x = y \\<or> x < y; y = z \\<or> y < z\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 3. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x = y \\<or> x < y; y = z \\<or> y < z\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 2. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x = Child0 \\<or> x < Child0; Child0 = z \\<or> Child0 < z;\n        y = Child0\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 2. \\<And>x y z.\n       \\<lbrakk>x = Child1 \\<or> x < Child1; Child1 = z \\<or> Child1 < z;\n        y = Child1\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 3. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 4. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac y, case_tac z, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x = Child1 \\<or> x < Child1; Child1 = z \\<or> Child1 < z;\n        y = Child1\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 2. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac z, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac y, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>Child1 = y \\<or> Child1 < y; y = Child1 \\<or> y < Child1;\n        x = Child1\\<rbrakk>\n       \\<Longrightarrow> Child1 = y\n 2. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac y, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       x = Child1 \\<Longrightarrow>\n       Child1 = y \\<or> Child1 < y \\<or> y = Child1 \\<or> y < Child1\n 2. \\<And>x y.\n       x = Child2 \\<Longrightarrow>\n       Child2 = y \\<or> y = Child2 \\<or> y < Child2", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = Child2 \\<Longrightarrow>\n       Child2 = y \\<or> y = Child2 \\<or> y < Child2", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "instantiation Agent :: enum\nbegin"], ["", "definition\n  \"enum_class.enum = [Child0, Child1, Child2]\""], ["", "definition\n  \"enum_class.enum_all P = (P Child0 \\<and> P Child1 \\<and> P Child2)\""], ["", "definition\n  \"enum_class.enum_ex P = (P Child0 \\<or> P Child1 \\<or> P Child2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Agent, enum_class)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. UNIV = set enum_class.enum\n 2. distinct enum_class.enum\n 3. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 4. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "unfolding enum_Agent_def enum_all_Agent_def enum_ex_Agent_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. UNIV = set [Child0, Child1, Child2]\n 2. distinct [Child0, Child1, Child2]\n 3. \\<And>P. (P Child0 \\<and> P Child1 \\<and> P Child2) = Ball UNIV P\n 4. \\<And>P. (P Child0 \\<or> P Child1 \\<or> P Child2) = Bex UNIV P", "by auto (case_tac x, auto)+"], ["", "end"], ["", "lemma Act_univ: \"(UNIV :: ChildAct set) = {SayIKnow, SayNothing}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {SayIKnow, SayNothing}", "unfolding UNIV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ext (\\<lambda>x. True) = {SayIKnow, SayNothing}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<noteq> SayIKnow \\<Longrightarrow> x = SayNothing", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> SayIKnow; x = SayIKnow\\<rbrakk>\n       \\<Longrightarrow> x = SayNothing\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> SayIKnow; x = SayNothing\\<rbrakk>\n       \\<Longrightarrow> x = SayNothing", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instance ChildAct :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(ChildAct, finite_class)", "by standard (auto iff: Act_univ)"], ["", "instantiation ChildAct :: enum\nbegin"], ["", "definition\n  \"enum_class.enum = [SayIKnow, SayNothing]\""], ["", "definition\n  \"enum_class.enum_all P = (P SayIKnow \\<and> P SayNothing)\""], ["", "definition\n  \"enum_class.enum_ex P = (P SayIKnow \\<or> P SayNothing)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(ChildAct, enum_class)", "apply standard"], ["proof (prove)\ngoal (4 subgoals):\n 1. UNIV = set enum_class.enum\n 2. distinct enum_class.enum\n 3. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 4. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "unfolding enum_ChildAct_def enum_all_ChildAct_def enum_ex_ChildAct_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. UNIV = set [SayIKnow, SayNothing]\n 2. distinct [SayIKnow, SayNothing]\n 3. \\<And>P. (P SayIKnow \\<and> P SayNothing) = Ball UNIV P\n 4. \\<And>P. (P SayIKnow \\<or> P SayNothing) = Bex UNIV P", "by auto (case_tac x, auto)+"], ["", "end"], ["", "instantiation ChildAct :: linorder\nbegin"], ["", "fun\n  less_ChildAct\nwhere\n  \"less_ChildAct SayIKnow SayNothing = True\"\n| \"less_ChildAct _ _ = False\""], ["", "definition\n  less_eq_ChildAct :: \"ChildAct \\<Rightarrow> ChildAct \\<Rightarrow> bool\"\nwhere\n  \"less_eq_ChildAct x y \\<equiv> x = y \\<or> x < y\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(ChildAct, linorder_class)", "apply intro_classes"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> y \\<or> y \\<le> x", "unfolding less_eq_ChildAct_def"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y.\n       (x < y) = ((x = y \\<or> x < y) \\<and> \\<not> (y = x \\<or> y < x))\n 2. \\<And>x. x = x \\<or> x < x\n 3. \\<And>x y z.\n       \\<lbrakk>x = y \\<or> x < y; y = z \\<or> y < z\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 4. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 5. \\<And>x y. (x = y \\<or> x < y) \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac y, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x = y \\<or> x < y; y = z \\<or> y < z\\<rbrakk>\n       \\<Longrightarrow> x = z \\<or> x < z\n 2. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 3. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x = y \\<or> x < y; y = x \\<or> y < x\\<rbrakk>\n       \\<Longrightarrow> x = y\n 2. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x = y \\<or> x < y \\<or> y = x \\<or> y < x", "apply (case_tac x, case_tac y, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       x = SayNothing \\<Longrightarrow>\n       SayNothing = y \\<or> y = SayNothing \\<or> y < SayNothing", "apply (case_tac y, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "type_synonym EnvAct = \"unit\""], ["", "type_synonym EnvState = \"(bool \\<times> bool \\<times> bool) \\<times> (ChildAct \\<times> ChildAct \\<times> ChildAct)\""], ["", "type_synonym AgentState = \"bool \\<times> bool \\<times> bool\""], ["", "type_synonym GlobalState = \"(Agent, EnvState, AgentState) BEState\""], ["", "definition \"agents \\<equiv> fromList [Child0, Child1, Child2]\""], ["", "fun\n  aChildIsDirty :: \"bool \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> bool\"\nwhere\n  \"aChildIsDirty False False False = False\"\n| \"aChildIsDirty _ _ _ = True\""], ["", "definition\n  initPS :: \"bool \\<Rightarrow> bool \\<Rightarrow> bool \\<Rightarrow> (Agent \\<times> (bool \\<times> bool \\<times> bool)) odlist\"\nwhere\n  \"initPS c0 c1 c2 \\<equiv>\n     let acid = aChildIsDirty c0 c1 c2\n      in fromList [ (Child0, (acid, c1, c2)), (Child1, (acid, c0, c2)), (Child2, (acid, c0, c1))]\""], ["", "definition\n  envInit :: \"GlobalState list\"\nwhere\n  \"envInit \\<equiv>\n    let bu = [False, True]\n     in [ \\<lparr> es = ((c0, c1, c2), (SayNothing, SayNothing, SayNothing)), ps = initPS c0 c1 c2 \\<rparr> .\n             c0 \\<leftarrow> bu, c1 \\<leftarrow> bu, c2 \\<leftarrow> bu ]\""], ["", "(* The environment is passive, but it still needs to do something in\n   each round for the system as a whole to evolve. *)"], ["", "definition\n  envAction :: \"GlobalState \\<Rightarrow> EnvAct list\"\nwhere\n  \"envAction \\<equiv> \\<lambda>_. [()]\""], ["", "(* Transitions involve broadcasting the children's private actions,\nleaving their private states unchanged. *)"], ["", "definition\n  envTransES :: \"EnvAct \\<Rightarrow> (Agent \\<Rightarrow> ChildAct) \\<Rightarrow> EnvState \\<Rightarrow> EnvState\"\nwhere\n  \"envTransES \\<equiv> \\<lambda>eAct aAct s. (fst s, aAct Child0, aAct Child1, aAct Child2)\""], ["", "definition\n  envTrans :: \"EnvAct \\<Rightarrow> (Agent \\<Rightarrow> ChildAct) \\<Rightarrow> GlobalState \\<Rightarrow> GlobalState\"\nwhere\n  \"envTrans eact aact s \\<equiv> s \\<lparr> es := envTransES eact aact (es s) \\<rparr>\""], ["", "(* Common observation: the actions of the agents. *)"], ["", "definition \"envObsC \\<equiv> snd\""], ["", "definition\n  envVal :: \"GlobalState \\<Rightarrow> Proposition \\<Rightarrow> bool\"\nwhere\n  \"envVal \\<equiv> \\<lambda>s p.\n     case p of Dirty a \\<Rightarrow>\n       (case es s of ((c0, c1, c2), _) \\<Rightarrow>\n         (case a of\n            Child0 \\<Rightarrow> c0\n          | Child1 \\<Rightarrow> c1\n          | Child2 \\<Rightarrow> c2))\""], ["", "(* FIXME This is a bit grot, this definition is already made for us in the locale. *)"], ["", "definition \"envObs \\<equiv> \\<lambda>a s. (envObsC (es s), ODList.lookup (ps s) a)\""], ["", "(* The KBP. Clearly subjective and deterministic. *)"], ["", "abbreviation\n  \"Kor \\<phi> \\<psi> \\<equiv> Knot (Kand (Knot \\<phi>) (Knot \\<psi>))\""], ["", "definition\n  jkbp :: \"Agent \\<Rightarrow> (Agent, Proposition, ChildAct) KBP\"\nwhere\n  \"jkbp a = [ \\<lparr> guard = Kor (\\<^bold>K\\<^sub>a (Kprop (Dirty a)))\n                            (\\<^bold>K\\<^sub>a (Knot (Kprop (Dirty a)))), action = SayIKnow \\<rparr>,\n              \\<lparr> guard = Kand (Knot (\\<^bold>K\\<^sub>a (Kprop (Dirty a))))\n                             (Knot (\\<^bold>K\\<^sub>a (Knot (Kprop (Dirty a))))), action = SayNothing \\<rparr> ]\""], ["", "subsubsection\\<open>Locale instantiations\\<close>"], ["", "interpretation MC: Environment jkbp envInit envAction envTrans envVal envObs"], ["proof (prove)\ngoal (1 subgoal):\n 1. Environment jkbp", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a gc.\n       gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc)", "apply (auto simp: jkbp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>The Clock view implementation\\<close>"], ["", "interpretation MC_Clock:\n  FiniteLinorderEnvironment jkbp envInit envAction envTrans envVal envObs agents"], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteLinorderEnvironment jkbp agents", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. toSet agents = UNIV", "apply (simp add: Agent_univ agents_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  mc_ClockDFS\nwhere\n  \"mc_ClockDFS \\<equiv> ClockAutoDFS agents jkbp envInit envAction envTrans envVal envObs\""], ["", "definition\n  mc_ClockAlg\nwhere\n  \"mc_ClockAlg \\<equiv> mkClockAuto agents jkbp envInit envAction envTrans envVal envObs\""], ["", "lemma (in FiniteLinorderEnvironment)\n  \"MC.Clock.implements mc_ClockAlg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MC.Clock.implements mc_ClockAlg", "unfolding mc_ClockAlg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MC.Clock.implements\n     (mkClockAuto agents jkbp envInit envAction envTrans envVal envObs)", "by (rule MC_Clock.mkClockAuto_implements)"], ["", "subsubsection\\<open>The SPR view implementation\\<close>"], ["", "interpretation MC_SPR:\n  FiniteDetBroadcastEnvironment jkbp envInit envAction envTrans envVal envObs agents envObsC"], ["proof (prove)\ngoal (1 subgoal):\n 1. FiniteDetBroadcastEnvironment jkbp envInit envAction envTrans envVal\n     agents envObsC &&&\n    (\\<And>a s.\n        envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a))", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. toSet agents = UNIV\n 2. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 3. \\<forall>a.\n       \\<forall>t\\<in>PreEnvironmentJView.jkbpC jkbp envInit envAction\n                       envTrans envVal\n                       (Environment.spr_jview\n                         (\\<lambda>a s.\n                             (envObsC (es s), ODList.lookup (ps s) a))).\n          length\n           (MC.jAction\n             (PreEnvironmentJView.mkM envVal\n               (Environment.spr_jview\n                 (\\<lambda>a s. (envObsC (es s), ODList.lookup (ps s) a)))\n               (PreEnvironmentJView.jkbpC jkbp envInit envAction envTrans\n                 envVal\n                 (Environment.spr_jview\n                   (\\<lambda>a s.\n                       (envObsC (es s), ODList.lookup (ps s) a)))))\n             t a)\n          \\<le> 1\n 4. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "prefer 3"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>a.\n       \\<forall>t\\<in>PreEnvironmentJView.jkbpC jkbp envInit envAction\n                       envTrans envVal\n                       (Environment.spr_jview\n                         (\\<lambda>a s.\n                             (envObsC (es s), ODList.lookup (ps s) a))).\n          length\n           (MC.jAction\n             (PreEnvironmentJView.mkM envVal\n               (Environment.spr_jview\n                 (\\<lambda>a s. (envObsC (es s), ODList.lookup (ps s) a)))\n               (PreEnvironmentJView.jkbpC jkbp envInit envAction envTrans\n                 envVal\n                 (Environment.spr_jview\n                   (\\<lambda>a s.\n                       (envObsC (es s), ODList.lookup (ps s) a)))))\n             t a)\n          \\<le> 1\n 2. toSet agents = UNIV\n 3. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 4. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "apply (fold envObs_def envAction_def envTrans_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>a.\n       \\<forall>t\\<in>MC.SPR.jkbpC.\n          length (MC.jAction MC.SPR.MC t a) \\<le> 1\n 2. toSet agents = UNIV\n 3. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 4. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a t.\n       t \\<in> MC.SPR.jkbpC \\<Longrightarrow>\n       length (MC.jAction MC.SPR.MC t a) \\<le> 1\n 2. toSet agents = UNIV\n 3. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 4. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "apply (erule MC.SPR.jkbpDetI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a t. \\<forall>a. distinct (map guard (jkbp a))\n 2. \\<And>a t.\n       \\<forall>a gc gc'.\n          gc \\<in> set (jkbp a) \\<and>\n          gc' \\<in> set (jkbp a) \\<and>\n          t \\<in> MC.SPR.jkbpC \\<longrightarrow>\n          guard gc = guard gc' \\<or>\n          \\<not> (MC.SPR.MC, t \\<Turnstile> guard gc \\<and>\n                  MC.SPR.MC, t \\<Turnstile> guard gc')\n 3. toSet agents = UNIV\n 4. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 5. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "apply (simp add: jkbp_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a t.\n       \\<forall>a gc gc'.\n          gc \\<in> set (jkbp a) \\<and>\n          gc' \\<in> set (jkbp a) \\<and>\n          t \\<in> MC.SPR.jkbpC \\<longrightarrow>\n          guard gc = guard gc' \\<or>\n          \\<not> (MC.SPR.MC, t \\<Turnstile> guard gc \\<and>\n                  MC.SPR.MC, t \\<Turnstile> guard gc')\n 2. toSet agents = UNIV\n 3. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 4. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "apply (auto simp: jkbp_def)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. toSet agents = UNIV\n 2. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup (ps (envTrans eact aact s)) a =\n       ODList.lookup (ps (envTrans eact' aact' s')) a\n 3. \\<And>a s. envObs a s \\<equiv> (envObsC (es s), ODList.lookup (ps s) a)", "unfolding envAction_def envTrans_def envObs_def agents_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. toSet (fromList [Child0, Child1, Child2]) = UNIV\n 2. \\<forall>s s' a eact eact' aact aact'.\n       ODList.lookup (ps s) a = ODList.lookup (ps s') a \\<and>\n       aact a = aact' a \\<longrightarrow>\n       ODList.lookup\n        (ps (s\\<lparr>es := envTransES eact aact (es s)\\<rparr>)) a =\n       ODList.lookup\n        (ps (s'\\<lparr>es := envTransES eact' aact' (es s')\\<rparr>)) a\n 3. \\<And>a s.\n       (envObsC (es s), ODList.lookup (ps s) a) \\<equiv>\n       (envObsC (es s), ODList.lookup (ps s) a)", "apply (simp_all add: Agent_univ jkbp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  mc_SPRDFS\nwhere\n  \"mc_SPRDFS \\<equiv> SPRDetAutoDFS agents jkbp envInit envAction envTrans envVal envObsC envObs\""], ["", "definition\n  mc_SPRAlg\nwhere\n  \"mc_SPRAlg \\<equiv> mkSPRDetAuto agents jkbp envInit envAction envTrans envVal envObsC envObs\""], ["", "lemma (in FiniteDetBroadcastEnvironment)\n  \"MC.SPR.implements mc_SPRAlg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MC.SPR.implements mc_SPRAlg", "unfolding mc_SPRAlg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. MC.SPR.implements\n     (mkSPRDetAuto agents jkbp envInit envAction envTrans envVal envObsC\n       envObs)", "by (rule MC_SPR.mkSPRDetAuto_implements)"], ["", "end"], ["", "(*>*)"]]}