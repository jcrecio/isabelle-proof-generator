{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/MapOps.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma MapOpsI[intro]:\n  \"\\<lbrakk> \\<And>k. \\<alpha> k \\<in> d \\<Longrightarrow> lookup ops (empty ops) k = None;\n     \\<And>e k k' M. \\<lbrakk> \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d \\<rbrakk> \\<Longrightarrow>\n                 lookup ops (update ops k e M) k'\n              = (if \\<alpha> k' = \\<alpha> k then Some e else lookup ops M k') \\<rbrakk>\n     \\<Longrightarrow> MapOps \\<alpha> d ops\"", "lemma MapOps_emptyD:\n  \"\\<lbrakk> \\<alpha> k \\<in> d; MapOps \\<alpha> d ops \\<rbrakk> \\<Longrightarrow> lookup ops (empty ops) k = None\"", "lemma MapOps_lookup_updateD:\n  \"\\<lbrakk> \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d; MapOps \\<alpha> d ops \\<rbrakk> \\<Longrightarrow> lookup ops (update ops k e M) k' = (if \\<alpha> k' = \\<alpha> k then Some e else lookup ops M k')\"", "lemma isSome_simps[simp]:\n  \"\\<And>x. isSome (Some x)\"\n  \"\\<And>x. \\<not> isSome x \\<longleftrightarrow> x = None\"", "lemma isSome_eq:\n  \"isSome x \\<longleftrightarrow> (\\<exists>y. x = Some y)\"", "lemma isSomeE: \"\\<lbrakk> isSome x; \\<And>s. x = Some s \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], "translations": [["", "lemma MapOpsI[intro]:\n  \"\\<lbrakk> \\<And>k. \\<alpha> k \\<in> d \\<Longrightarrow> lookup ops (empty ops) k = None;\n     \\<And>e k k' M. \\<lbrakk> \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d \\<rbrakk> \\<Longrightarrow>\n                 lookup ops (update ops k e M) k'\n              = (if \\<alpha> k' = \\<alpha> k then Some e else lookup ops M k') \\<rbrakk>\n     \\<Longrightarrow> MapOps \\<alpha> d ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                \\<alpha> k \\<in> d \\<Longrightarrow>\n                lookup ops (MapOps.empty ops) k = None;\n     \\<And>e k k' M.\n        \\<lbrakk>\\<alpha> k \\<in> d; \\<alpha> k' \\<in> d\\<rbrakk>\n        \\<Longrightarrow> lookup ops (update ops k e M) k' =\n                          (if \\<alpha> k' = \\<alpha> k then Some e\n                           else lookup ops M k')\\<rbrakk>\n    \\<Longrightarrow> MapOps \\<alpha> d ops", "unfolding MapOps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k.\n                \\<alpha> k \\<in> d \\<Longrightarrow>\n                lookup ops (MapOps.empty ops) k = None;\n     \\<And>e k k' M.\n        \\<lbrakk>\\<alpha> k \\<in> d; \\<alpha> k' \\<in> d\\<rbrakk>\n        \\<Longrightarrow> lookup ops (update ops k e M) k' =\n                          (if \\<alpha> k' = \\<alpha> k then Some e\n                           else lookup ops M k')\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>k.\n                          \\<alpha> k \\<in> d \\<longrightarrow>\n                          lookup ops (MapOps.empty ops) k = None) \\<and>\n                      (\\<forall>e k k' M.\n                          \\<alpha> k \\<in> d \\<and>\n                          \\<alpha> k' \\<in> d \\<longrightarrow>\n                          lookup ops (update ops k e M) k' =\n                          (if \\<alpha> k' = \\<alpha> k then Some e\n                           else lookup ops M k'))", "by blast"], ["", "lemma MapOps_emptyD:\n  \"\\<lbrakk> \\<alpha> k \\<in> d; MapOps \\<alpha> d ops \\<rbrakk> \\<Longrightarrow> lookup ops (empty ops) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> k \\<in> d; MapOps \\<alpha> d ops\\<rbrakk>\n    \\<Longrightarrow> lookup ops (MapOps.empty ops) k = None", "unfolding MapOps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> k \\<in> d;\n     (\\<forall>k.\n         \\<alpha> k \\<in> d \\<longrightarrow>\n         lookup ops (MapOps.empty ops) k = None) \\<and>\n     (\\<forall>e k k' M.\n         \\<alpha> k \\<in> d \\<and> \\<alpha> k' \\<in> d \\<longrightarrow>\n         lookup ops (update ops k e M) k' =\n         (if \\<alpha> k' = \\<alpha> k then Some e\n          else lookup ops M k'))\\<rbrakk>\n    \\<Longrightarrow> lookup ops (MapOps.empty ops) k = None", "by simp"], ["", "lemma MapOps_lookup_updateD:\n  \"\\<lbrakk> \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d; MapOps \\<alpha> d ops \\<rbrakk> \\<Longrightarrow> lookup ops (update ops k e M) k' = (if \\<alpha> k' = \\<alpha> k then Some e else lookup ops M k')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> k \\<in> d; \\<alpha> k' \\<in> d;\n     MapOps \\<alpha> d ops\\<rbrakk>\n    \\<Longrightarrow> lookup ops (update ops k e M) k' =\n                      (if \\<alpha> k' = \\<alpha> k then Some e\n                       else lookup ops M k')", "unfolding MapOps_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> k \\<in> d; \\<alpha> k' \\<in> d;\n     (\\<forall>k.\n         \\<alpha> k \\<in> d \\<longrightarrow>\n         lookup ops (MapOps.empty ops) k = None) \\<and>\n     (\\<forall>e k k' M.\n         \\<alpha> k \\<in> d \\<and> \\<alpha> k' \\<in> d \\<longrightarrow>\n         lookup ops (update ops k e M) k' =\n         (if \\<alpha> k' = \\<alpha> k then Some e\n          else lookup ops M k'))\\<rbrakk>\n    \\<Longrightarrow> lookup ops (update ops k e M) k' =\n                      (if \\<alpha> k' = \\<alpha> k then Some e\n                       else lookup ops M k')", "by simp"], ["", "(*>*)"], ["", "text\\<open>\n\nThe function @{term \"\\<alpha>\"} abstracts concrete keys of type @{typ \"'k\"},\nand the parameter @{term \"d\"} specifies the valid abstract keys.\n\nThis approach has the advantage over a locale that we can pass records\nto functions, while for a locale we would need to pass the three\nfunctions separately (as in the DFS theory of \\S\\ref{sec:dfs}).\n\nWe use the following function to test for membership in the domain of\nthe map:\n\n\\<close>"], ["", "definition isSome :: \"'a option \\<Rightarrow> bool\" where\n  \"isSome opt \\<equiv> case opt of None \\<Rightarrow> False | Some _ \\<Rightarrow> True\""], ["", "(*<*)"], ["", "lemma isSome_simps[simp]:\n  \"\\<And>x. isSome (Some x)\"\n  \"\\<And>x. \\<not> isSome x \\<longleftrightarrow> x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. isSome (Some x)) &&& (\\<And>x. (\\<not> isSome x) = (x = None))", "unfolding isSome_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        case Some x of None \\<Rightarrow> False\n        | Some x \\<Rightarrow> True) &&&\n    (\\<And>x.\n        (\\<not> (case x of None \\<Rightarrow> False\n                 | Some x \\<Rightarrow> True)) =\n        (x = None))", "by (auto split: option.split)"], ["", "lemma isSome_eq:\n  \"isSome x \\<longleftrightarrow> (\\<exists>y. x = Some y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSome x = (\\<exists>y. x = Some y)", "unfolding isSome_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> False | Some x \\<Rightarrow> True) =\n    (\\<exists>y. x = Some y)", "by (auto split: option.split)"], ["", "lemma isSomeE: \"\\<lbrakk> isSome x; \\<And>s. x = Some s \\<Longrightarrow> Q \\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isSome x; \\<And>s. x = Some s \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "unfolding isSome_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case x of None \\<Rightarrow> False | Some x \\<Rightarrow> True;\n     \\<And>s. x = Some s \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (cases x) auto"], ["", "end"], ["", "(*>*)"]]}