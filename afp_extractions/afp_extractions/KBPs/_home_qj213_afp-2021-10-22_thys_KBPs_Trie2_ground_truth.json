{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/Trie2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma [simp]:\n  \"trie_update_with [] v f (Trie vo ts) =\n    Trie (Some (f (case vo of None \\<Rightarrow> v | Some v' \\<Rightarrow> v'))) ts\"", "lemma [simp]:\n  \"trie_update_with (k#ks) v f (Trie vo ts) =\n    Trie vo (AList.update_with_aux empty_trie k (trie_update_with ks v f) ts)\"", "lemma lookup_empty_trie [simp]: \"lookup_trie empty_trie ks = None\"", "lemma lookup_trie_update_with:\n  \"lookup_trie (trie_update_with ks v f t) ks'\n = (if ks = ks' then Some (f (case lookup_trie t ks of None \\<Rightarrow> v | Some v' \\<Rightarrow> v')) else lookup_trie t ks')\"", "lemma lookup_trie_update:\n  \"lookup_trie (trie_update ks v t) ks' = (if ks = ks' then Some v else lookup_trie t ks')\"", "lemma trie_MapOps[intro, simp]:\n  \"inj_on \\<alpha> { x . \\<alpha> x \\<in> d } \\<Longrightarrow> MapOps \\<alpha> d trie_MapOps\"", "lemma trie_odlist_MapOps[intro, simp]:\n  \"inj_on \\<alpha> { x . \\<alpha> x \\<in> d } \\<Longrightarrow> MapOps \\<alpha> d trie_odlist_MapOps\""], "translations": [["", "lemma [simp]:\n  \"trie_update_with [] v f (Trie vo ts) =\n    Trie (Some (f (case vo of None \\<Rightarrow> v | Some v' \\<Rightarrow> v'))) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trie_update_with [] v f (Trie vo ts) =\n    Trie\n     (Some (f (case vo of None \\<Rightarrow> v | Some v' \\<Rightarrow> v')))\n     ts", "by(simp add: trie_update_with_def)"], ["", "lemma [simp]:\n  \"trie_update_with (k#ks) v f (Trie vo ts) =\n    Trie vo (AList.update_with_aux empty_trie k (trie_update_with ks v f) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trie_update_with (k # ks) v f (Trie vo ts) =\n    Trie vo\n     (AList.update_with_aux empty_trie k (trie_update_with ks v f) ts)", "by(simp add: trie_update_with_def empty_trie_def)"], ["", "abbreviation\n  trie_update_with' :: \"'k list \\<Rightarrow> ('k, 'v) trie \\<Rightarrow> 'v \\<Rightarrow> ('v \\<Rightarrow> 'v) \\<Rightarrow> ('k, 'v) trie\"\nwhere\n  \"trie_update_with' \\<equiv> (\\<lambda>k m v f. trie_update_with k v f m)\""], ["", "definition\n  trie_update :: \"'key list \\<Rightarrow> 'val \\<Rightarrow> ('key, 'val) trie \\<Rightarrow> ('key, 'val) trie\"\nwhere\n  \"trie_update k v t = trie_update_with k v (\\<lambda>v'. v) t\""], ["", "text \\<open>@{term \"trie_lookup\"}\\<close>"], ["", "lemma lookup_empty_trie [simp]: \"lookup_trie empty_trie ks = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie empty_trie ks = None", "by (cases ks) (simp_all)"], ["", "lemma lookup_trie_update_with:\n  \"lookup_trie (trie_update_with ks v f t) ks'\n = (if ks = ks' then Some (f (case lookup_trie t ks of None \\<Rightarrow> v | Some v' \\<Rightarrow> v')) else lookup_trie t ks')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (trie_update_with' ks t v f) ks' =\n    (if ks = ks'\n     then Some\n           (f (case lookup_trie t ks of None \\<Rightarrow> v\n               | Some v' \\<Rightarrow> v'))\n     else lookup_trie t ks')", "proof(induct ks \"(%vo. f(case vo of None \\<Rightarrow> v | Some v \\<Rightarrow> v))\" t arbitrary: v ks' rule: update_with_trie.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v ps va ks'.\n       lookup_trie (trie_update_with' [] (Trie v ps) va f) ks' =\n       (if [] = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) [] of None \\<Rightarrow> va\n                  | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')\n 2. \\<And>k ks v ps va ks'.\n       (\\<And>x v ks'.\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> va\n                  | Some v \\<Rightarrow> v)) =\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> v\n                  | Some v \\<Rightarrow> v)) \\<Longrightarrow>\n           lookup_trie (trie_update_with' ks x v f) ks' =\n           (if ks = ks'\n            then Some\n                  (f (case lookup_trie x ks of None \\<Rightarrow> v\n                      | Some v' \\<Rightarrow> v'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (trie_update_with' (k # ks) (Trie v ps) va f) ks' =\n       (if k # ks = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) (k # ks) of\n                  None \\<Rightarrow> va | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')", "case (1 v ps vo ks')"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>v ps va ks'.\n       lookup_trie (trie_update_with' [] (Trie v ps) va f) ks' =\n       (if [] = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) [] of None \\<Rightarrow> va\n                  | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')\n 2. \\<And>k ks v ps va ks'.\n       (\\<And>x v ks'.\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> va\n                  | Some v \\<Rightarrow> v)) =\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> v\n                  | Some v \\<Rightarrow> v)) \\<Longrightarrow>\n           lookup_trie (trie_update_with' ks x v f) ks' =\n           (if ks = ks'\n            then Some\n                  (f (case lookup_trie x ks of None \\<Rightarrow> v\n                      | Some v' \\<Rightarrow> v'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (trie_update_with' (k # ks) (Trie v ps) va f) ks' =\n       (if k # ks = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) (k # ks) of\n                  None \\<Rightarrow> va | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (trie_update_with' [] (Trie v ps) vo f) ks' =\n    (if [] = ks'\n     then Some\n           (f (case lookup_trie (Trie v ps) [] of None \\<Rightarrow> vo\n               | Some v' \\<Rightarrow> v'))\n     else lookup_trie (Trie v ps) ks')", "by (fastforce simp add: neq_Nil_conv dest: not_sym)"], ["proof (state)\nthis:\n  lookup_trie (trie_update_with' [] (Trie v ps) vo f) ks' =\n  (if [] = ks'\n   then Some\n         (f (case lookup_trie (Trie v ps) [] of None \\<Rightarrow> vo\n             | Some v' \\<Rightarrow> v'))\n   else lookup_trie (Trie v ps) ks')\n\ngoal (1 subgoal):\n 1. \\<And>k ks v ps va ks'.\n       (\\<And>x v ks'.\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> va\n                  | Some v \\<Rightarrow> v)) =\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> v\n                  | Some v \\<Rightarrow> v)) \\<Longrightarrow>\n           lookup_trie (trie_update_with' ks x v f) ks' =\n           (if ks = ks'\n            then Some\n                  (f (case lookup_trie x ks of None \\<Rightarrow> v\n                      | Some v' \\<Rightarrow> v'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (trie_update_with' (k # ks) (Trie v ps) va f) ks' =\n       (if k # ks = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) (k # ks) of\n                  None \\<Rightarrow> va | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k ks v ps va ks'.\n       (\\<And>x v ks'.\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> va\n                  | Some v \\<Rightarrow> v)) =\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> v\n                  | Some v \\<Rightarrow> v)) \\<Longrightarrow>\n           lookup_trie (trie_update_with' ks x v f) ks' =\n           (if ks = ks'\n            then Some\n                  (f (case lookup_trie x ks of None \\<Rightarrow> v\n                      | Some v' \\<Rightarrow> v'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (trie_update_with' (k # ks) (Trie v ps) va f) ks' =\n       (if k # ks = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) (k # ks) of\n                  None \\<Rightarrow> va | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')", "case (2 k ks v ps vo ks')"], ["proof (state)\nthis:\n  (\\<lambda>voa.\n      f (case voa of None \\<Rightarrow> vo | Some v \\<Rightarrow> v)) =\n  (\\<lambda>vo.\n      f (case vo of None \\<Rightarrow> ?v\n         | Some v \\<Rightarrow> v)) \\<Longrightarrow>\n  lookup_trie (trie_update_with' ks ?x ?v f) ?ks' =\n  (if ks = ?ks'\n   then Some\n         (f (case lookup_trie ?x ks of None \\<Rightarrow> ?v\n             | Some v' \\<Rightarrow> v'))\n   else lookup_trie ?x ?ks')\n\ngoal (1 subgoal):\n 1. \\<And>k ks v ps va ks'.\n       (\\<And>x v ks'.\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> va\n                  | Some v \\<Rightarrow> v)) =\n           (\\<lambda>vo.\n               f (case vo of None \\<Rightarrow> v\n                  | Some v \\<Rightarrow> v)) \\<Longrightarrow>\n           lookup_trie (trie_update_with' ks x v f) ks' =\n           (if ks = ks'\n            then Some\n                  (f (case lookup_trie x ks of None \\<Rightarrow> v\n                      | Some v' \\<Rightarrow> v'))\n            else lookup_trie x ks')) \\<Longrightarrow>\n       lookup_trie (trie_update_with' (k # ks) (Trie v ps) va f) ks' =\n       (if k # ks = ks'\n        then Some\n              (f (case lookup_trie (Trie v ps) (k # ks) of\n                  None \\<Rightarrow> va | Some v' \\<Rightarrow> v'))\n        else lookup_trie (Trie v ps) ks')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (trie_update_with' (k # ks) (Trie v ps) vo f) ks' =\n    (if k # ks = ks'\n     then Some\n           (f (case lookup_trie (Trie v ps) (k # ks) of\n               None \\<Rightarrow> vo | Some v' \\<Rightarrow> v'))\n     else lookup_trie (Trie v ps) ks')", "by(cases ks')(auto simp add: map_of_update_with_aux \"2\" empty_trie_def split: option.split)"], ["proof (state)\nthis:\n  lookup_trie (trie_update_with' (k # ks) (Trie v ps) vo f) ks' =\n  (if k # ks = ks'\n   then Some\n         (f (case lookup_trie (Trie v ps) (k # ks) of None \\<Rightarrow> vo\n             | Some v' \\<Rightarrow> v'))\n   else lookup_trie (Trie v ps) ks')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_trie_update:\n  \"lookup_trie (trie_update ks v t) ks' = (if ks = ks' then Some v else lookup_trie t ks')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (trie_update ks v t) ks' =\n    (if ks = ks' then Some v else lookup_trie t ks')", "unfolding trie_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_trie (trie_update_with' ks t v (\\<lambda>v'. v)) ks' =\n    (if ks = ks' then Some v else lookup_trie t ks')", "by (auto simp add: lookup_trie_update_with)"], ["", "text\\<open>@{term \"MapOps\"}\\<close>"], ["", "definition\n  trie_MapOps :: \"(('k, 'e) trie, 'k list, 'e) MapOps\"\nwhere\n  \"trie_MapOps \\<equiv>\n     \\<lparr> MapOps.empty = empty_trie,\n       lookup = lookup_trie,\n       update = trie_update \\<rparr>\""], ["", "lemma trie_MapOps[intro, simp]:\n  \"inj_on \\<alpha> { x . \\<alpha> x \\<in> d } \\<Longrightarrow> MapOps \\<alpha> d trie_MapOps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<alpha>\n     (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d)) \\<Longrightarrow>\n    MapOps \\<alpha> d trie_MapOps", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trie_MapOps\n                          (MapOps.empty trie_MapOps) k =\n                         None\n 2. \\<And>e k k' M.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trie_MapOps\n                          (update trie_MapOps k e M) k' =\n                         (if \\<alpha> k' = \\<alpha> k then Some e\n                          else MapOps.lookup trie_MapOps M k')", "unfolding trie_MapOps_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup\n                          \\<lparr>MapOps.empty = empty_trie,\n                             lookup = lookup_trie,\n                             update = trie_update\\<rparr>\n                          (MapOps.empty\n                            \\<lparr>MapOps.empty = empty_trie,\n                               lookup = lookup_trie,\n                               update = trie_update\\<rparr>)\n                          k =\n                         None\n 2. \\<And>e k k' M.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup\n                          \\<lparr>MapOps.empty = empty_trie,\n                             lookup = lookup_trie,\n                             update = trie_update\\<rparr>\n                          (update\n                            \\<lparr>MapOps.empty = empty_trie,\n                               lookup = lookup_trie,\n                               update = trie_update\\<rparr>\n                            k e M)\n                          k' =\n                         (if \\<alpha> k' = \\<alpha> k then Some e\n                          else MapOps.lookup\n                                \\<lparr>MapOps.empty = empty_trie,\n                                   lookup = lookup_trie,\n                                   update = trie_update\\<rparr>\n                                M k')", "apply (auto dest: inj_onD simp add: lookup_trie_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  \"trie_odlist_lookup = (\\<lambda>M. lookup_trie M \\<circ> toList)\""], ["", "definition\n  \"trie_odlist_update = (\\<lambda>k v. trie_update (toList k) v)\""], ["", "definition\n  trie_odlist_update_with :: \"('k :: linorder) odlist \\<Rightarrow> ('k, 'v) trie \\<Rightarrow> 'v \\<Rightarrow> ('v \\<Rightarrow> 'v) \\<Rightarrow> ('k, 'v) trie\"\nwhere\n  \"trie_odlist_update_with = (\\<lambda>k m v f. trie_update_with (toList k) v f m)\""], ["", "definition\n  trie_odlist_MapOps :: \"(('k, 'e) trie, ('k ::linorder) odlist, 'e) MapOps\"\nwhere\n  \"trie_odlist_MapOps \\<equiv>\n     \\<lparr> MapOps.empty = empty_trie,\n       lookup = trie_odlist_lookup,\n       update = trie_odlist_update \\<rparr>\""], ["", "lemma trie_odlist_MapOps[intro, simp]:\n  \"inj_on \\<alpha> { x . \\<alpha> x \\<in> d } \\<Longrightarrow> MapOps \\<alpha> d trie_odlist_MapOps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<alpha>\n     (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d)) \\<Longrightarrow>\n    MapOps \\<alpha> d trie_odlist_MapOps", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trie_odlist_MapOps\n                          (MapOps.empty trie_odlist_MapOps) k =\n                         None\n 2. \\<And>e k k' M.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup trie_odlist_MapOps\n                          (update trie_odlist_MapOps k e M) k' =\n                         (if \\<alpha> k' = \\<alpha> k then Some e\n                          else MapOps.lookup trie_odlist_MapOps M k')", "unfolding trie_odlist_MapOps_def trie_odlist_lookup_def trie_odlist_update_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup\n                          \\<lparr>MapOps.empty = empty_trie,\n                             lookup =\n                               \\<lambda>M. lookup_trie M \\<circ> toList,\n                             update =\n                               \\<lambda>k. trie_update (toList k)\\<rparr>\n                          (MapOps.empty\n                            \\<lparr>MapOps.empty = empty_trie,\n                               lookup =\n                                 \\<lambda>M. lookup_trie M \\<circ> toList,\n                               update =\n                                 \\<lambda>k. trie_update (toList k)\\<rparr>)\n                          k =\n                         None\n 2. \\<And>e k k' M.\n       \\<lbrakk>inj_on \\<alpha> (rel_ext (\\<lambda>x. \\<alpha> x \\<in> d));\n        \\<alpha> k \\<in> d; \\<alpha> k' \\<in> d\\<rbrakk>\n       \\<Longrightarrow> MapOps.lookup\n                          \\<lparr>MapOps.empty = empty_trie,\n                             lookup =\n                               \\<lambda>M. lookup_trie M \\<circ> toList,\n                             update =\n                               \\<lambda>k. trie_update (toList k)\\<rparr>\n                          (update\n                            \\<lparr>MapOps.empty = empty_trie,\n                               lookup =\n                                 \\<lambda>M. lookup_trie M \\<circ> toList,\n                               update =\n                                 \\<lambda>k. trie_update (toList k)\\<rparr>\n                            k e M)\n                          k' =\n                         (if \\<alpha> k' = \\<alpha> k then Some e\n                          else MapOps.lookup\n                                \\<lparr>MapOps.empty = empty_trie,\n                                   lookup =\n                                     \\<lambda>M.\n  lookup_trie M \\<circ> toList,\n                                   update =\n                                     \\<lambda>k.\n  trie_update (toList k)\\<rparr>\n                                M k')", "apply (auto dest: inj_onD simp add: lookup_trie_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}