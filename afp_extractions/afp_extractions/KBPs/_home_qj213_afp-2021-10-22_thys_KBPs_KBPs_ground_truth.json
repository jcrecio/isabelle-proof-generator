{"file_name": "/home/qj213/afp-2021-10-22/thys/KBPs/KBPs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/KBPs", "problem_names": ["lemma S5n_subjective_eq:\n  assumes S5n: \"S5n M\"\n  assumes subj: \"subjective a \\<phi>\"\n  assumes ww': \"(w, w') \\<in> relations M a\"\n  shows \"M, w \\<Turnstile> \\<phi> \\<longleftrightarrow> M, w' \\<Turnstile> \\<phi>\"", "lemma S5n_jAction_eq:\n  assumes S5n: \"S5n M\"\n  assumes ww': \"(w, w') \\<in> relations M a\"\n  shows \"jAction M w a = jAction M w' a\"", "lemma gen_model_jAction_eq:\n  assumes S: \"gen_model M w = gen_model M' w\"\n  assumes w': \"w' \\<in> worlds (gen_model M' w)\"\n  assumes M: \"kripke M\"\n  assumes M': \"kripke M'\"\n  shows \"jAction M w' = jAction M' w'\"", "lemma simulation_jAction_eq:\n  assumes M: \"kripke M\"\n  assumes sim: \"sim M M' f\"\n  assumes w: \"w \\<in> worlds M\"\n  shows \"jAction M w = jAction M' (f w)\"", "lemma mkM_kripke[intro, simp]: \"kripke (mkM T)\"", "lemma mkM_S5n[intro, simp]: \"S5n (mkM T)\"", "lemma mkM_simps[simp]:\n  \"worlds (mkM T) = T\"\n  \"\\<lbrakk> (t, t') \\<in> relations (mkM T) a \\<rbrakk> \\<Longrightarrow> jview a t = jview a t'\"\n  \"\\<lbrakk> (t, t') \\<in> relations (mkM T) a \\<rbrakk> \\<Longrightarrow> t \\<in> T\"\n  \"\\<lbrakk> (t, t') \\<in> relations (mkM T) a \\<rbrakk> \\<Longrightarrow> t' \\<in> T\"\n  \"valuation (mkM T) = envVal \\<circ> tLast\"", "lemma mkM_rel_length[simp]:\n  assumes tt': \"(t, t') \\<in> relations (mkM T) a\"\n  shows \"tLength t' = tLength t\"", "lemma jkbpTn_length:\n  \"t \\<in> jkbpTn n T \\<Longrightarrow> tLength t = n\"", "lemma jkbpT_tLength_inv:\n  \"\\<lbrakk> t \\<in> jkbpT T; tLength t = n \\<rbrakk> \\<Longrightarrow> t \\<in> jkbpTn n T\"", "lemma jkbpT_traces_of_length:\n   \"{ t \\<in> jkbpT T . tLength t = n } = jkbpTn n T\"", "lemma representsI:\n  \"jkbpT T = T \\<Longrightarrow> represents T\"", "lemma representsD:\n  \"represents T \\<Longrightarrow> jkbpT T = T\"", "lemma sync_tLength_eq_trc:\n  assumes \"(t, t') \\<in> (\\<Union>a\\<in>as. relations (mkM T) a)\\<^sup>*\"\n  shows \"tLength t = tLength t'\"", "lemma sync_gen_model_tLength:\n  assumes traces: \"{ t \\<in> T . tLength t = n } = { t \\<in> T' . tLength t = n }\"\n      and tT: \"t \\<in> { t \\<in> T . tLength t = n }\"\n  shows \"gen_model (mkM T) t = gen_model (mkM T') t\"", "lemma sync_jview_jAction_eq:\n  assumes traces: \"{ t \\<in> T . tLength t = n } = { t \\<in> T' . tLength t = n }\"\n  assumes tT: \"t \\<in> { t \\<in> T . tLength t = n }\"\n  shows \"jAction (mkM T) t = jAction (mkM T') t\"", "lemma jkbpCn_step_inv:\n  \"t \\<leadsto> s \\<in> jkbpCn (Suc n) \\<Longrightarrow> t \\<in> jkbpCn n\"", "lemma jkbpCn_length[simp]:\n  \"t \\<in> jkbpCn n \\<Longrightarrow> tLength t = n\"", "lemma jkbpCn_init_inv[intro]:\n  \"tInit s \\<in> jkbpCn n \\<Longrightarrow> s \\<in> set envInit\"", "lemma jkbpCn_tFirst_init_inv[intro]:\n \"t \\<in> jkbpCn n \\<Longrightarrow> tFirst t \\<in> set envInit\"", "lemma jkbpCn_jkbpC_subset:\n  \"jkbpCn n \\<subseteq> jkbpC\"", "lemma jkbpCn_jkbpC_inc[intro]:\n  \"t \\<in> jkbpCn n \\<Longrightarrow> t \\<in> jkbpC\"", "lemma jkbpC_tLength_inv[intro]:\n  \"\\<lbrakk> t \\<in> jkbpC; tLength t = n \\<rbrakk> \\<Longrightarrow> t \\<in> jkbpCn n\"", "lemma jkbpC_traces_of_length:\n   \"{ t \\<in> jkbpC . tLength t = n } = jkbpCn n\"", "lemma jkbpC_prefix_closed[dest]:\n  \"t \\<leadsto> s \\<in> jkbpC \\<Longrightarrow> t \\<in> jkbpC\"", "lemma jkbpC_init[iff]:\n  \"tInit s \\<in> jkbpC \\<longleftrightarrow> s \\<in> set envInit\"", "lemma jkbpC_jkbpCn_rels:\n  \"\\<lbrakk> (u, v) \\<in> relations MC a; tLength u = n \\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> relations (MC\\<^bsub>n\\<^esub>) a\"", "lemma jkbpC_tFirst_init_inv[intro]:\n  \"t \\<in> jkbpC \\<Longrightarrow> tFirst t \\<in> set envInit\"", "lemma jkbpC_jkbpCn_jAction_eq:\n  assumes tCn: \"t \\<in> jkbpC\\<^bsub>n\\<^esub>\"\n  shows \"jAction MC t = jAction MC\\<^bsub>n\\<^esub> t\"", "lemma jkbpTn_jkbpCn_represents: \"jkbpT\\<^bsub>n\\<^esub> jkbpC = jkbpC\\<^bsub>n\\<^esub>\"", "theorem jkbpC_represents: \"represents jkbpC\"", "theorem jkbpC_represents_uniquely:\n  assumes repT: \"represents T\"\n  shows \"T = jkbpC\""], "translations": [["", "lemma S5n_subjective_eq:\n  assumes S5n: \"S5n M\"\n  assumes subj: \"subjective a \\<phi>\"\n  assumes ww': \"(w, w') \\<in> relations M a\"\n  shows \"M, w \\<Turnstile> \\<phi> \\<longleftrightarrow> M, w' \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M, w \\<Turnstile> \\<phi> = M, w' \\<Turnstile> \\<phi>", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. M, w \\<Turnstile> \\<phi> = M, w' \\<Turnstile> \\<phi>", "using subj ww'"], ["proof (prove)\nusing this:\n  subjective a \\<phi>\n  (w, w') \\<in> relations M a\n\ngoal (1 subgoal):\n 1. M, w \\<Turnstile> \\<phi> = M, w' \\<Turnstile> \\<phi>", "proof(induct \\<phi> rule: subjective.induct[case_names Kprop Knot Kand Kknows Kcknows])"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kprop p =\n                         M, w' \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        subjective a (Knot f); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Knot f =\n                         M, w' \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        \\<lbrakk>subjective a g; (w, w') \\<in> relations M a\\<rbrakk>\n        \\<Longrightarrow> M, w \\<Turnstile> g = M, w' \\<Turnstile> g;\n        subjective a (Kand f g); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kand f g =\n                         M, w' \\<Turnstile> Kand f g\n 4. \\<And>a a' f.\n       \\<lbrakk>subjective a \\<^bold>K\\<^sub>a' f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>K\\<^sub>a' f =\n                         M, w' \\<Turnstile> \\<^bold>K\\<^sub>a' f\n 5. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         M, w' \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "case (Kcknows a as \\<phi>)"], ["proof (state)\nthis:\n  subjective a \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n  (w, w') \\<in> relations M a\n\ngoal (5 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kprop p =\n                         M, w' \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        subjective a (Knot f); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Knot f =\n                         M, w' \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        \\<lbrakk>subjective a g; (w, w') \\<in> relations M a\\<rbrakk>\n        \\<Longrightarrow> M, w \\<Turnstile> g = M, w' \\<Turnstile> g;\n        subjective a (Kand f g); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kand f g =\n                         M, w' \\<Turnstile> Kand f g\n 4. \\<And>a a' f.\n       \\<lbrakk>subjective a \\<^bold>K\\<^sub>a' f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>K\\<^sub>a' f =\n                         M, w' \\<Turnstile> \\<^bold>K\\<^sub>a' f\n 5. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         M, w' \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "hence \"(w, w') \\<in> (\\<Union>a\\<in>set as. relations M a)\\<^sup>+\""], ["proof (prove)\nusing this:\n  subjective a \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n  (w, w') \\<in> relations M a\n\ngoal (1 subgoal):\n 1. (w, w') \\<in> (\\<Union> (relations M ` set as))\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (w, w') \\<in> (\\<Union> (relations M ` set as))\\<^sup>+\n\ngoal (5 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kprop p =\n                         M, w' \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        subjective a (Knot f); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Knot f =\n                         M, w' \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        \\<lbrakk>subjective a g; (w, w') \\<in> relations M a\\<rbrakk>\n        \\<Longrightarrow> M, w \\<Turnstile> g = M, w' \\<Turnstile> g;\n        subjective a (Kand f g); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kand f g =\n                         M, w' \\<Turnstile> Kand f g\n 4. \\<And>a a' f.\n       \\<lbrakk>subjective a \\<^bold>K\\<^sub>a' f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>K\\<^sub>a' f =\n                         M, w' \\<Turnstile> \\<^bold>K\\<^sub>a' f\n 5. \\<And>a as f.\n       \\<lbrakk>subjective a \\<^bold>C\\<^bsub>as\\<^esub> f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f =\n                         M, w' \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> f", "with Kcknows S5n"], ["proof (chain)\npicking this:\n  subjective a \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n  (w, w') \\<in> relations M a\n  S5n M\n  (w, w') \\<in> (\\<Union> (relations M ` set as))\\<^sup>+", "show ?case"], ["proof (prove)\nusing this:\n  subjective a \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n  (w, w') \\<in> relations M a\n  S5n M\n  (w, w') \\<in> (\\<Union> (relations M ` set as))\\<^sup>+\n\ngoal (1 subgoal):\n 1. M, w \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi> =\n    M, w' \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>", "by (auto dest: S5n_tc_rels_eq)"], ["proof (state)\nthis:\n  M, w \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi> =\n  M, w' \\<Turnstile> \\<^bold>C\\<^bsub>as\\<^esub> \\<phi>\n\ngoal (4 subgoals):\n 1. \\<And>a p.\n       \\<lbrakk>subjective a (Kprop p); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kprop p =\n                         M, w' \\<Turnstile> Kprop p\n 2. \\<And>a f.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        subjective a (Knot f); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Knot f =\n                         M, w' \\<Turnstile> Knot f\n 3. \\<And>a f g.\n       \\<lbrakk>\\<lbrakk>subjective a f;\n                 (w, w') \\<in> relations M a\\<rbrakk>\n                \\<Longrightarrow> M, w \\<Turnstile> f =\n                                  M, w' \\<Turnstile> f;\n        \\<lbrakk>subjective a g; (w, w') \\<in> relations M a\\<rbrakk>\n        \\<Longrightarrow> M, w \\<Turnstile> g = M, w' \\<Turnstile> g;\n        subjective a (Kand f g); (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> Kand f g =\n                         M, w' \\<Turnstile> Kand f g\n 4. \\<And>a a' f.\n       \\<lbrakk>subjective a \\<^bold>K\\<^sub>a' f;\n        (w, w') \\<in> relations M a\\<rbrakk>\n       \\<Longrightarrow> M, w \\<Turnstile> \\<^bold>K\\<^sub>a' f =\n                         M, w' \\<Turnstile> \\<^bold>K\\<^sub>a' f", "qed (auto dest: S5n_rels_eq[OF S5n])"], ["", "(*>*)"], ["", "text\\<open>\n\nThe proof is by induction over the formula @{term \"\\<phi>\"}, using the\nproperties of $S5_n$ Kripke structures in the knowledge cases.\n\nWe capture the fixed but arbitrary JKBP using a locale, and work in\nthis context for the rest of this section.\n\n\\<close>"], ["", "locale JKBP =\n  fixes jkbp :: \"('a, 'p, 'aAct) JKBP\"\n  assumes subj: \"\\<forall>a gc. gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc)\""], ["", "context JKBP\nbegin"], ["", "text\\<open>\n\nThe action of the JKBP at a world is the list of all actions that are\nenabled at that world:\n\n\\<close>"], ["", "definition jAction :: \"('a, 'p, 'w) KripkeStructure \\<Rightarrow> 'w \\<Rightarrow> 'a \\<Rightarrow> 'aAct list\"\nwhere \"jAction \\<equiv> \\<lambda>M w a. [ action gc. gc \\<leftarrow> jkbp a, M, w \\<Turnstile> guard gc ]\""], ["", "text\\<open>\n\nAll of our machinery on Kripke structures lifts from the models\nrelation of \\S\\ref{sec:kbps-logic-of-knowledge} through @{term\n\"jAction\"}, due to the subjectivity requirement. In particular, the\nKBP for agent $a$ behaves the same at worlds that $a$ cannot\ndistinguish amongst:\n\n\\<close>"], ["", "lemma S5n_jAction_eq:\n  assumes S5n: \"S5n M\"\n  assumes ww': \"(w, w') \\<in> relations M a\"\n  shows \"jAction M w a = jAction M w' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "fix gc"], ["proof (state)\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "assume \"gc \\<in> set (jkbp a)\""], ["proof (state)\nthis:\n  gc \\<in> set (jkbp a)\n\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "with subj"], ["proof (chain)\npicking this:\n  \\<forall>a gc.\n     gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc)\n  gc \\<in> set (jkbp a)", "have \"subjective a (guard gc)\""], ["proof (prove)\nusing this:\n  \\<forall>a gc.\n     gc \\<in> set (jkbp a) \\<longrightarrow> subjective a (guard gc)\n  gc \\<in> set (jkbp a)\n\ngoal (1 subgoal):\n 1. subjective a (guard gc)", "by auto"], ["proof (state)\nthis:\n  subjective a (guard gc)\n\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "with S5n ww'"], ["proof (chain)\npicking this:\n  S5n M\n  (w, w') \\<in> relations M a\n  subjective a (guard gc)", "have \"M, w \\<Turnstile> guard gc = M, w' \\<Turnstile> guard gc\""], ["proof (prove)\nusing this:\n  S5n M\n  (w, w') \\<in> relations M a\n  subjective a (guard gc)\n\ngoal (1 subgoal):\n 1. M, w \\<Turnstile> guard gc = M, w' \\<Turnstile> guard gc", "by - (rule S5n_subjective_eq, simp_all)"], ["proof (state)\nthis:\n  M, w \\<Turnstile> guard gc = M, w' \\<Turnstile> guard gc\n\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "}"], ["proof (state)\nthis:\n  ?gc3 \\<in> set (jkbp a) \\<Longrightarrow>\n  M, w \\<Turnstile> guard ?gc3 = M, w' \\<Turnstile> guard ?gc3\n\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?gc3 \\<in> set (jkbp a) \\<Longrightarrow>\n  M, w \\<Turnstile> guard ?gc3 = M, w' \\<Turnstile> guard ?gc3\n\ngoal (1 subgoal):\n 1. jAction M w a = jAction M w' a", "unfolding jAction_def"], ["proof (prove)\nusing this:\n  ?gc3 \\<in> set (jkbp a) \\<Longrightarrow>\n  M, w \\<Turnstile> guard ?gc3 = M, w' \\<Turnstile> guard ?gc3\n\ngoal (1 subgoal):\n 1. concat\n     (map (\\<lambda>gc.\n              if M, w \\<Turnstile> guard gc then [action gc] else [])\n       (jkbp a)) =\n    concat\n     (map (\\<lambda>gc.\n              if M, w' \\<Turnstile> guard gc then [action gc] else [])\n       (jkbp a))", "by - (rule arg_cong[where f=concat], simp)"], ["proof (state)\nthis:\n  jAction M w a = jAction M w' a\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nAlso the JKBP behaves the same on relevant generated models for all\nagents:\n\n\\<close>"], ["", "lemma gen_model_jAction_eq:\n  assumes S: \"gen_model M w = gen_model M' w\"\n  assumes w': \"w' \\<in> worlds (gen_model M' w)\"\n  assumes M: \"kripke M\"\n  assumes M': \"kripke M'\"\n  shows \"jAction M w' = jAction M' w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction M w' = jAction M' w'", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction M w' = jAction M' w'", "unfolding jAction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        concat\n         (map (\\<lambda>gc.\n                  if M, w' \\<Turnstile> guard gc then [action gc] else [])\n           (jkbp a))) =\n    (\\<lambda>a.\n        concat\n         (map (\\<lambda>gc.\n                  if M', w' \\<Turnstile> guard gc then [action gc] else [])\n           (jkbp a)))", "by (auto iff: gen_model_eq[OF M M' S w'])"], ["", "(*>*)"], ["", "text\\<open>\n\nFinally, @{term \"jAction\"} is invariant under simulations:\n\n\\<close>"], ["", "lemma simulation_jAction_eq:\n  assumes M: \"kripke M\"\n  assumes sim: \"sim M M' f\"\n  assumes w: \"w \\<in> worlds M\"\n  shows \"jAction M w = jAction M' (f w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction M w = jAction M' (f w)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction M w = jAction M' (f w)", "unfolding jAction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        concat\n         (map (\\<lambda>gc.\n                  if M, w \\<Turnstile> guard gc then [action gc] else [])\n           (jkbp a))) =\n    (\\<lambda>a.\n        concat\n         (map (\\<lambda>gc.\n                  if M', f w \\<Turnstile> guard gc then [action gc] else [])\n           (jkbp a)))", "using assms"], ["proof (prove)\nusing this:\n  kripke M\n  sim M M' f\n  w \\<in> worlds M\n\ngoal (1 subgoal):\n 1. (\\<lambda>a.\n        concat\n         (map (\\<lambda>gc.\n                  if M, w \\<Turnstile> guard gc then [action gc] else [])\n           (jkbp a))) =\n    (\\<lambda>a.\n        concat\n         (map (\\<lambda>gc.\n                  if M', f w \\<Turnstile> guard gc then [action gc] else [])\n           (jkbp a)))", "by (auto iff: sim_semantic_equivalence)"], ["", "(*>*)"], ["", "end"], ["", "section\\<open>Environments and Views\\<close>"], ["", "text\\<open>\n\n\\label{sec:kbps-theory-environments}\n\nThe previous section showed how a JKBP can be interpreted statically,\nwith respect to a fixed Kripke structure. As we also wish to capture\nhow agents interact, we adopt the \\emph{interpreted systems} and\n\\emph{contexts} of \\cite{FHMV:1995}, which we term \\emph{environments}\nfollowing \\cite{Ron:1996}.\n\nA \\emph{pre-environment} consists of the following:\n\\begin{itemize}\n\n\\item @{term \"envInit\"}, an arbitrary set of initial states;\n\n\\item The protocol of the environment @{term \"envAction\"}, which\n  depends on the current state;\n\n\\item A transition function @{term \"envTrans\"}, which incorporates the\n  environment's action and agents' behaviour into a state change; and\n\n\\item A propositional evaluation function @{term \"envVal\"}.\n\n\\end{itemize}\nWe extend the @{term \"JKBP\"} locale with these constants:\n\n\\<close>"], ["", "locale PreEnvironment = JKBP jkbp for jkbp :: \"('a, 'p, 'aAct) JKBP\"\n+ fixes envInit :: \"'s list\"\n    and envAction :: \"'s \\<Rightarrow> 'eAct list\"\n    and envTrans :: \"'eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's\"\n    and envVal :: \"'s \\<Rightarrow> 'p \\<Rightarrow> bool\""], ["", "text\\<open>\n\n\\label{sec:kbps-views}\n\nWe represent the possible evolutions of the system as finite sequences\nof states, represented by a left-recursive type @{typ \"'s Trace\"} with\nconstructors @{term \"tInit s\"} and @{term \"t \\<leadsto> s\"}, equipped with\n@{term \"tFirst\"}, @{term \"tLast\"}, @{term \"tLength\"} and @{term\n\"tMap\"} functions.\n\nConstructing these traces requires us to determine the agents' actions\nat a given state. To do so we need to find an appropriate S$5_n$\nstructure for interpreting @{term \"jkbp\"}.\n\nGiven that we want the agents to make optimal use of the information\nthey have access to, we allow these structures to depend on the entire\nhistory of the system, suitably conditioned by what the agents can\nobserve. We capture this notion of observation with a \\emph{view}\n\\citep{Ron:1996}, which is an arbitrary function of a trace:\n\n\\<close>"], ["", "type_synonym ('s, 'tview) View = \"'s Trace \\<Rightarrow> 'tview\""], ["", "type_synonym ('a, 's, 'tview) JointView = \"'a \\<Rightarrow> 's Trace \\<Rightarrow> 'tview\""], ["", "text\\<open>\n\n\\label{sec:kbps-synchrony}\n\nWe require views to be \\emph{synchronous}, i.e. that agents be able to\ntell the time using their view by distinguishing two traces of\ndifferent lengths. As we will see in the next section, this guarantees\nthat the JKBP has an essentially unique implementation.\n\nWe extend the @{term \"PreEnvironment\"} locale with a view:\n\n\\<close>"], ["", "locale PreEnvironmentJView =\n  PreEnvironment jkbp envInit envAction envTrans envVal\n    for jkbp :: \"('a, 'p, 'aAct) JKBP\"\n    and envInit :: \"'s list\"\n    and envAction :: \"'s \\<Rightarrow> 'eAct list\"\n    and envTrans :: \"'eAct \\<Rightarrow> ('a \\<Rightarrow> 'aAct) \\<Rightarrow> 's \\<Rightarrow> 's\"\n    and envVal :: \"'s \\<Rightarrow> 'p \\<Rightarrow> bool\"\n+ fixes jview :: \"('a, 's, 'tview) JointView\"\n  assumes sync: \"\\<forall>a t t'. jview a t = jview a t' \\<longrightarrow> tLength t = tLength t'\""], ["", "text\\<open>\n\nThe two principle synchronous views are the clock view and the\nperfect-recall view which we discuss further in\n\\S\\ref{sec:kbps-theory-views}. We will later derive an agent's\nconcrete view from an instantaneous observation of the global state in\n\\S\\ref{sec:kbps-environments}.\n\nWe build a Kripke structure from a set of traces by relating traces\nthat yield the same view. To obtain an S$5_n$ structure we also need a\nway to evaluate propositions: we apply @{term \"envVal\"} to the final\nstate of a trace:\n\n\\<close>"], ["", "definition (in PreEnvironmentJView)\n  mkM :: \"'s Trace set \\<Rightarrow> ('a, 'p, 's Trace) KripkeStructure\"\nwhere\n  \"mkM T \\<equiv>\n      \\<lparr> worlds = T,\n        relations = \\<lambda>a. { (t, t') . {t, t'} \\<subseteq> T \\<and> jview a t = jview a t' },\n        valuation = envVal \\<circ> tLast \\<rparr>\""], ["", "(*<*)"], ["", "context PreEnvironmentJView\nbegin"], ["", "lemma mkM_kripke[intro, simp]: \"kripke (mkM T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kripke (mkM T)", "unfolding mkM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. kripke\n     \\<lparr>worlds = T,\n        relations =\n          \\<lambda>a.\n             {(t, t'). {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n        valuation = envVal \\<circ> tLast\\<rparr>", "by (rule kripkeI) fastforce"], ["", "lemma mkM_S5n[intro, simp]: \"S5n (mkM T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S5n (mkM T)", "unfolding mkM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S5n \\<lparr>worlds = T,\n           relations =\n             \\<lambda>a.\n                {(t, t').\n                 {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n           valuation = envVal \\<circ> tLast\\<rparr>", "by (intro S5nI equivI)\n     (bestsimp intro: equivI refl_onI symI transI)+"], ["", "lemma mkM_simps[simp]:\n  \"worlds (mkM T) = T\"\n  \"\\<lbrakk> (t, t') \\<in> relations (mkM T) a \\<rbrakk> \\<Longrightarrow> jview a t = jview a t'\"\n  \"\\<lbrakk> (t, t') \\<in> relations (mkM T) a \\<rbrakk> \\<Longrightarrow> t \\<in> T\"\n  \"\\<lbrakk> (t, t') \\<in> relations (mkM T) a \\<rbrakk> \\<Longrightarrow> t' \\<in> T\"\n  \"valuation (mkM T) = envVal \\<circ> tLast\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (worlds (mkM T) = T &&&\n     ((t, t') \\<in> relations (mkM T) a \\<Longrightarrow>\n      jview a t = jview a t')) &&&\n    ((t, t') \\<in> relations (mkM T) a \\<Longrightarrow> t \\<in> T) &&&\n    ((t, t') \\<in> relations (mkM T) a \\<Longrightarrow> t' \\<in> T) &&&\n    valuation (mkM T) = envVal \\<circ> tLast", "unfolding mkM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (worlds\n      \\<lparr>worlds = T,\n         relations =\n           \\<lambda>a.\n              {(t, t').\n               {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n         valuation = envVal \\<circ> tLast\\<rparr> =\n     T &&&\n     ((t, t')\n      \\<in> relations\n             \\<lparr>worlds = T,\n                relations =\n                  \\<lambda>a.\n                     {(t, t').\n                      {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n                valuation = envVal \\<circ> tLast\\<rparr>\n             a \\<Longrightarrow>\n      jview a t = jview a t')) &&&\n    ((t, t')\n     \\<in> relations\n            \\<lparr>worlds = T,\n               relations =\n                 \\<lambda>a.\n                    {(t, t').\n                     {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n               valuation = envVal \\<circ> tLast\\<rparr>\n            a \\<Longrightarrow>\n     t \\<in> T) &&&\n    ((t, t')\n     \\<in> relations\n            \\<lparr>worlds = T,\n               relations =\n                 \\<lambda>a.\n                    {(t, t').\n                     {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n               valuation = envVal \\<circ> tLast\\<rparr>\n            a \\<Longrightarrow>\n     t' \\<in> T) &&&\n    valuation\n     \\<lparr>worlds = T,\n        relations =\n          \\<lambda>a.\n             {(t, t'). {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n        valuation = envVal \\<circ> tLast\\<rparr> =\n    envVal \\<circ> tLast", "by simp_all"], ["", "lemma mkM_rel_length[simp]:\n  assumes tt': \"(t, t') \\<in> relations (mkM T) a\"\n  shows \"tLength t' = tLength t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tLength t' = tLength t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. tLength t' = tLength t", "from tt'"], ["proof (chain)\npicking this:\n  (t, t') \\<in> relations (mkM T) a", "have \"jview a t = jview a t'\""], ["proof (prove)\nusing this:\n  (t, t') \\<in> relations (mkM T) a\n\ngoal (1 subgoal):\n 1. jview a t = jview a t'", "by simp"], ["proof (state)\nthis:\n  jview a t = jview a t'\n\ngoal (1 subgoal):\n 1. tLength t' = tLength t", "thus ?thesis"], ["proof (prove)\nusing this:\n  jview a t = jview a t'\n\ngoal (1 subgoal):\n 1. tLength t' = tLength t", "by (bestsimp dest: sync[rule_format])"], ["proof (state)\nthis:\n  tLength t' = tLength t\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\n\nThis construction supplants the role of the \\emph{local states} of\n\\citet{FHMV:1995}.\n\nThe following section shows how we can canonically interpret the JKBP\nwith respect to this structure.\n\n\\<close>"], ["", "section\\<open>Canonical Structures\\<close>"], ["", "text\\<open>\n\n\\label{sec:kbps-canonical-kripke}\n\nOur goal in this section is to find the canonical set of traces for a\ngiven JKBP in a particular environment. As we will see, this always\nexists with respect to synchronous views.\n\nWe inductively define an \\emph{interpretation} of a JKBP with respect\nto an arbitrary set of traces @{term \"T\"} by constructing a sequence\nof sets of traces of increasing length:\n\n\\<close>"], ["", "fun jkbpTn :: \"nat \\<Rightarrow> 's Trace set \\<Rightarrow> 's Trace set\"(*<*)(\"jkbpT\\<^bsub>_\\<^esub>\")(*>*) where\n  \"jkbpT\\<^bsub>0\\<^esub> T     = { tInit s |s. s \\<in> set envInit }\"\n| \"jkbpT\\<^bsub>Suc n\\<^esub> T = { t \\<leadsto> envTrans eact aact (tLast t) |t eact aact.\n                             t \\<in> jkbpT\\<^bsub>n\\<^esub> T \\<and> eact \\<in> set (envAction (tLast t))\n                          \\<and> (\\<forall>a. aact a \\<in> set (jAction (mkM T) t a)) }\""], ["", "text\\<open>\n\nThis model reflects the failure of any agent to provide an action as\nfailure of the entire system. In general @{term \"envTrans\"} may\nincorporate a scheduler and communication failure models.\n\nThe union of this sequence gives us a closure property:\n\n\\<close>"], ["", "definition jkbpT :: \"'s Trace set \\<Rightarrow> 's Trace set\" where\n  \"jkbpT T \\<equiv> \\<Union>n. jkbpT\\<^bsub>n\\<^esub> T\""], ["", "(*<*)"], ["", "lemma jkbpTn_length:\n  \"t \\<in> jkbpTn n T \\<Longrightarrow> tLength t = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jkbpT\\<^bsub>n\\<^esub> T \\<Longrightarrow> tLength t = n", "by (induct n arbitrary: t, auto)"], ["", "lemma jkbpT_tLength_inv:\n  \"\\<lbrakk> t \\<in> jkbpT T; tLength t = n \\<rbrakk> \\<Longrightarrow> t \\<in> jkbpTn n T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> jkbpT T; tLength t = n\\<rbrakk>\n    \\<Longrightarrow> t \\<in> jkbpT\\<^bsub>n\\<^esub> T", "unfolding jkbpT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> (\\<Union>n. jkbpT\\<^bsub>n\\<^esub> T);\n     tLength t = n\\<rbrakk>\n    \\<Longrightarrow> t \\<in> jkbpT\\<^bsub>n\\<^esub> T", "by (induct n arbitrary: t) (fastforce simp: jkbpTn_length)+"], ["", "lemma jkbpT_traces_of_length:\n   \"{ t \\<in> jkbpT T . tLength t = n } = jkbpTn n T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jkbpT T. tLength t = n} = jkbpT\\<^bsub>n\\<^esub> T", "using jkbpT_tLength_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<in> jkbpT ?T; tLength ?t = ?n\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> jkbpT\\<^bsub>?n\\<^esub> ?T\n\ngoal (1 subgoal):\n 1. {t \\<in> jkbpT T. tLength t = n} = jkbpT\\<^bsub>n\\<^esub> T", "unfolding jkbpT_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?t \\<in> (\\<Union>n. jkbpT\\<^bsub>n\\<^esub> ?T);\n   tLength ?t = ?n\\<rbrakk>\n  \\<Longrightarrow> ?t \\<in> jkbpT\\<^bsub>?n\\<^esub> ?T\n\ngoal (1 subgoal):\n 1. {t \\<in> \\<Union>n. jkbpT\\<^bsub>n\\<^esub> T. tLength t = n} =\n    jkbpT\\<^bsub>n\\<^esub> T", "by (bestsimp simp: jkbpTn_length)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe say that a set of traces @{term \"T\"} \\emph{represents} a JKBP if it\nis closed under @{term \"jkbpT\"}:\n\n\\<close>"], ["", "definition represents :: \"'s Trace set \\<Rightarrow> bool\" where\n  \"represents T \\<equiv> jkbpT T = T\""], ["", "(*<*)"], ["", "lemma representsI:\n  \"jkbpT T = T \\<Longrightarrow> represents T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpT T = T \\<Longrightarrow> represents T", "unfolding represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpT T = T \\<Longrightarrow> jkbpT T = T", "by simp"], ["", "lemma representsD:\n  \"represents T \\<Longrightarrow> jkbpT T = T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents T \\<Longrightarrow> jkbpT T = T", "unfolding represents_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpT T = T \\<Longrightarrow> jkbpT T = T", "by simp"], ["", "(*>*)"], ["", "text\\<open>\n\nThis is the vicious cycle that we break using our assumption that the\nview is synchronous. The key property of such views is that the\nsatisfaction of an epistemic formula is determined by the set of\ntraces in the model that have the same length. Lifted to @{term\n\"jAction\"}, we have:\n\n\\<close>"], ["", "(*<*)"], ["", "lemma sync_tLength_eq_trc:\n  assumes \"(t, t') \\<in> (\\<Union>a\\<in>as. relations (mkM T) a)\\<^sup>*\"\n  shows \"tLength t = tLength t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tLength t = tLength t'", "using assms"], ["proof (prove)\nusing this:\n  (t, t') \\<in> (\\<Union> (relations (mkM T) ` as))\\<^sup>*\n\ngoal (1 subgoal):\n 1. tLength t = tLength t'", "by (induct rule: rtrancl_induct) auto"], ["", "lemma sync_gen_model_tLength:\n  assumes traces: \"{ t \\<in> T . tLength t = n } = { t \\<in> T' . tLength t = n }\"\n      and tT: \"t \\<in> { t \\<in> T . tLength t = n }\"\n  shows \"gen_model (mkM T) t = gen_model (mkM T') t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_model (mkM T) t = gen_model (mkM T') t", "apply(rule gen_model_subset[where T=\"{ t \\<in> T . tLength t = n }\"])"], ["proof (prove)\ngoal (8 subgoals):\n 1. kripke (mkM T)\n 2. kripke (mkM T')\n 3. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 4. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 5. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 6. t \\<in> worlds (mkM T)\n 7. t \\<in> worlds (mkM T')\n 8. valuation (mkM T) = valuation (mkM T')", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. t \\<in> T\n 5. t \\<in> T'", "(* t \\<in> T and t \\<in> T' *)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. t \\<in> T\n 5. t \\<in> T'", "prefer 4"], ["proof (prove)\ngoal (5 subgoals):\n 1. t \\<in> T\n 2. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 5. t \\<in> T'", "using tT"], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> T. tLength t = n}\n\ngoal (5 subgoals):\n 1. t \\<in> T\n 2. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 5. t \\<in> T'", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. t \\<in> T'", "prefer 4"], ["proof (prove)\ngoal (4 subgoals):\n 1. t \\<in> T'\n 2. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "using tT traces"], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> T. tLength t = n}\n  {t \\<in> T. tLength t = n} = {t \\<in> T'. tLength t = n}\n\ngoal (4 subgoals):\n 1. t \\<in> T'\n 2. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 4. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       Restr (relations (mkM T) a) {t \\<in> T. tLength t = n} =\n       Restr (relations (mkM T') a) {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "apply (unfold mkM_def)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a.\n       Restr\n        (relations\n          \\<lparr>worlds = T,\n             relations =\n               \\<lambda>a.\n                  {(t, t').\n                   {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n             valuation = envVal \\<circ> tLast\\<rparr>\n          a)\n        {t \\<in> T. tLength t = n} =\n       Restr\n        (relations\n          \\<lparr>worlds = T',\n             relations =\n               \\<lambda>a.\n                  {(t, t').\n                   {t, t'} \\<subseteq> T' \\<and> jview a t = jview a t'},\n             valuation = envVal \\<circ> tLast\\<rparr>\n          a)\n        {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "using tT traces"], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> T. tLength t = n}\n  {t \\<in> T. tLength t = n} = {t \\<in> T'. tLength t = n}\n\ngoal (3 subgoals):\n 1. \\<And>a.\n       Restr\n        (relations\n          \\<lparr>worlds = T,\n             relations =\n               \\<lambda>a.\n                  {(t, t').\n                   {t, t'} \\<subseteq> T \\<and> jview a t = jview a t'},\n             valuation = envVal \\<circ> tLast\\<rparr>\n          a)\n        {t \\<in> T. tLength t = n} =\n       Restr\n        (relations\n          \\<lparr>worlds = T',\n             relations =\n               \\<lambda>a.\n                  {(t, t').\n                   {t, t'} \\<subseteq> T' \\<and> jview a t = jview a t'},\n             valuation = envVal \\<circ> tLast\\<rparr>\n          a)\n        {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 3. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "apply (auto)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "using tT"], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> T. tLength t = n}\n\ngoal (2 subgoals):\n 1. (\\<Union> (range (relations (mkM T))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}\n 2. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "apply (auto dest: sync_tLength_eq_trc[where as=UNIV] kripke_rels_trc_worlds)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "using tT traces"], ["proof (prove)\nusing this:\n  t \\<in> {t \\<in> T. tLength t = n}\n  {t \\<in> T. tLength t = n} = {t \\<in> T'. tLength t = n}\n\ngoal (1 subgoal):\n 1. (\\<Union> (range (relations (mkM T'))))\\<^sup>* `` {t}\n    \\<subseteq> {t \\<in> T. tLength t = n}", "apply (auto dest: sync_tLength_eq_trc[where as=UNIV] kripke_rels_trc_worlds)[1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "lemma sync_jview_jAction_eq:\n  assumes traces: \"{ t \\<in> T . tLength t = n } = { t \\<in> T' . tLength t = n }\"\n  assumes tT: \"t \\<in> { t \\<in> T . tLength t = n }\"\n  shows \"jAction (mkM T) t = jAction (mkM T') t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction (mkM T) t = jAction (mkM T') t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction (mkM T) t = jAction (mkM T') t", "apply (rule gen_model_jAction_eq[where w=t])"], ["proof (prove)\ngoal (4 subgoals):\n 1. gen_model (mkM T) t = gen_model (mkM T') t\n 2. t \\<in> worlds (gen_model (mkM T') t)\n 3. kripke (mkM T)\n 4. kripke (mkM T')", "apply (rule sync_gen_model_tLength)"], ["proof (prove)\ngoal (5 subgoals):\n 1. {t \\<in> T. tLength t = ?n5} = {t \\<in> T'. tLength t = ?n5}\n 2. t \\<in> {t \\<in> T. tLength t = ?n5}\n 3. t \\<in> worlds (gen_model (mkM T') t)\n 4. kripke (mkM T)\n 5. kripke (mkM T')", "using assms"], ["proof (prove)\nusing this:\n  {t \\<in> T. tLength t = n} = {t \\<in> T'. tLength t = n}\n  t \\<in> {t \\<in> T. tLength t = n}\n\ngoal (5 subgoals):\n 1. {t \\<in> T. tLength t = ?n5} = {t \\<in> T'. tLength t = ?n5}\n 2. t \\<in> {t \\<in> T. tLength t = ?n5}\n 3. t \\<in> worlds (gen_model (mkM T') t)\n 4. kripke (mkM T)\n 5. kripke (mkM T')", "apply (auto intro: gen_model_world_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*>*)"], ["", "text\\<open>\n\nThis implies that for a synchronous view we can inductively define the\n\\emph{canonical traces} of a JKBP. These are the traces that a JKBP\ngenerates when it is interpreted with respect to those very same\ntraces. We do this by constructing the sequence \\<open>jkbpC\\<^sub>n\\<close> of\n\\emph{(canonical) temporal slices} similarly to @{term \"jkbpT\\<^bsub>n\\<^esub>\"}:\n\n\\<close>"], ["", "fun jkbpCn :: \"nat \\<Rightarrow> 's Trace set\"(*<*)(\"jkbpC\\<^bsub>_\\<^esub>\")(*>*) where\n  \"jkbpC\\<^bsub>0\\<^esub>      = { tInit s |s. s \\<in> set envInit }\"\n| \"jkbpC\\<^bsub>Suc n\\<^esub> = { t \\<leadsto> envTrans eact aact (tLast t) |t eact aact.\n                             t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<and> eact \\<in> set (envAction (tLast t))\n                          \\<and> (\\<forall>a. aact a \\<in> set (jAction (mkM jkbpC\\<^bsub>n\\<^esub>) t a)) }\""], ["", "abbreviation MCn :: \"nat \\<Rightarrow> ('a, 'p, 's Trace) KripkeStructure\"(*<*)(\"MC\\<^bsub>_\\<^esub>\")(*>*) where\n  \"MC\\<^bsub>n\\<^esub> \\<equiv> mkM jkbpC\\<^bsub>n\\<^esub>\""], ["", "(*<*)"], ["", "lemma jkbpCn_step_inv:\n  \"t \\<leadsto> s \\<in> jkbpCn (Suc n) \\<Longrightarrow> t \\<in> jkbpCn n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<leadsto> s \\<in> jkbpC\\<^bsub>Suc n\\<^esub> \\<Longrightarrow>\n    t \\<in> jkbpC\\<^bsub>n\\<^esub>", "by (induct n arbitrary: t, (fastforce simp add: Let_def)+)"], ["", "lemma jkbpCn_length[simp]:\n  \"t \\<in> jkbpCn n \\<Longrightarrow> tLength t = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<Longrightarrow> tLength t = n", "by (induct n arbitrary: t, (fastforce simp add: Let_def)+)"], ["", "lemma jkbpCn_init_inv[intro]:\n  \"tInit s \\<in> jkbpCn n \\<Longrightarrow> s \\<in> set envInit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tInit s \\<in> jkbpC\\<^bsub>n\\<^esub> \\<Longrightarrow>\n    s \\<in> set envInit", "by (frule jkbpCn_length) auto"], ["", "lemma jkbpCn_tFirst_init_inv[intro]:\n \"t \\<in> jkbpCn n \\<Longrightarrow> tFirst t \\<in> set envInit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<Longrightarrow>\n    tFirst t \\<in> set envInit", "by (induct n arbitrary: t) (auto iff: Let_def)"], ["", "(*>*)"], ["", "text\\<open>\n\nThe canonical set of traces for a JKBP with respect to a joint view is\nthe set of canonical traces of all lengths.\n\n\\<close>"], ["", "definition jkbpC :: \"'s Trace set\" where\n  \"jkbpC \\<equiv> \\<Union>n. jkbpC\\<^bsub>n\\<^esub>\""], ["", "abbreviation MC :: \"('a, 'p, 's Trace) KripkeStructure\" where\n  \"MC \\<equiv> mkM jkbpC\""], ["", "(*<*)"], ["", "lemma jkbpCn_jkbpC_subset:\n  \"jkbpCn n \\<subseteq> jkbpC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpC\\<^bsub>n\\<^esub> \\<subseteq> jkbpC", "unfolding jkbpC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpC\\<^bsub>n\\<^esub> \\<subseteq> \\<Union> (range jkbpCn)", "by blast"], ["", "lemma jkbpCn_jkbpC_inc[intro]:\n  \"t \\<in> jkbpCn n \\<Longrightarrow> t \\<in> jkbpC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<Longrightarrow> t \\<in> jkbpC", "unfolding jkbpC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jkbpC\\<^bsub>n\\<^esub> \\<Longrightarrow>\n    t \\<in> \\<Union> (range jkbpCn)", "by best"], ["", "lemma jkbpC_tLength_inv[intro]:\n  \"\\<lbrakk> t \\<in> jkbpC; tLength t = n \\<rbrakk> \\<Longrightarrow> t \\<in> jkbpCn n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> jkbpC; tLength t = n\\<rbrakk>\n    \\<Longrightarrow> t \\<in> jkbpC\\<^bsub>n\\<^esub>", "unfolding jkbpC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<in> \\<Union> (range jkbpCn); tLength t = n\\<rbrakk>\n    \\<Longrightarrow> t \\<in> jkbpC\\<^bsub>n\\<^esub>", "by (induct n arbitrary: t, (fastforce simp add: Let_def)+)"], ["", "lemma jkbpC_traces_of_length:\n   \"{ t \\<in> jkbpC . tLength t = n } = jkbpCn n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> jkbpC. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>", "unfolding jkbpC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> \\<Union> (range jkbpCn). tLength t = n} =\n    jkbpC\\<^bsub>n\\<^esub>", "by bestsimp"], ["", "lemma jkbpC_prefix_closed[dest]:\n  \"t \\<leadsto> s \\<in> jkbpC \\<Longrightarrow> t \\<in> jkbpC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<leadsto> s \\<in> jkbpC \\<Longrightarrow> t \\<in> jkbpC", "apply (drule jkbpC_tLength_inv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. tLength (t \\<leadsto> s) = ?n\n 2. t \\<leadsto> s \\<in> jkbpC\\<^bsub>?n\\<^esub> \\<Longrightarrow>\n    t \\<in> jkbpC", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<leadsto> s\n    \\<in> jkbpC\\<^bsub>Suc (tLength t)\\<^esub> \\<Longrightarrow>\n    t \\<in> jkbpC", "apply (auto iff: Let_def jkbpC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jkbpC_init[iff]:\n  \"tInit s \\<in> jkbpC \\<longleftrightarrow> s \\<in> set envInit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tInit s \\<in> jkbpC) = (s \\<in> set envInit)", "unfolding jkbpC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tInit s \\<in> \\<Union> (range jkbpCn)) = (s \\<in> set envInit)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. tInit s \\<in> \\<Union> (range jkbpCn) \\<Longrightarrow>\n    s \\<in> set envInit\n 2. s \\<in> set envInit \\<Longrightarrow>\n    tInit s \\<in> \\<Union> (range jkbpCn)", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> set envInit \\<Longrightarrow>\n    tInit s \\<in> \\<Union> (range jkbpCn)", "apply (subgoal_tac \"tInit s \\<in> jkbpCn 0\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<in> set envInit;\n     tInit s \\<in> jkbpC\\<^bsub>0\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> tInit s \\<in> \\<Union> (range jkbpCn)\n 2. s \\<in> set envInit \\<Longrightarrow>\n    tInit s \\<in> jkbpC\\<^bsub>0\\<^esub>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<in> set envInit \\<Longrightarrow>\n    \\<exists>x. tInit s \\<in> jkbpC\\<^bsub>x\\<^esub>\n 2. s \\<in> set envInit \\<Longrightarrow>\n    tInit s \\<in> jkbpC\\<^bsub>0\\<^esub>", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<in> set envInit \\<Longrightarrow>\n    tInit s \\<in> jkbpC\\<^bsub>0\\<^esub>\n 2. s \\<in> set envInit \\<Longrightarrow>\n    tInit s \\<in> jkbpC\\<^bsub>0\\<^esub>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma jkbpC_jkbpCn_rels:\n  \"\\<lbrakk> (u, v) \\<in> relations MC a; tLength u = n \\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> relations (MC\\<^bsub>n\\<^esub>) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> relations MC a; tLength u = n\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> relations MC\\<^bsub>n\\<^esub> a", "unfolding mkM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v)\n             \\<in> relations\n                    \\<lparr>worlds = jkbpC,\n                       relations =\n                         \\<lambda>a.\n                            {(t, t').\n                             {t, t'} \\<subseteq> jkbpC \\<and>\n                             jview a t = jview a t'},\n                       valuation = envVal \\<circ> tLast\\<rparr>\n                    a;\n     tLength u = n\\<rbrakk>\n    \\<Longrightarrow> (u, v)\n                      \\<in> relations\n                             \\<lparr>worlds = jkbpC\\<^bsub>n\\<^esub>,\n                                relations =\n                                  \\<lambda>a.\n                                     {(t, t').\n{t, t'} \\<subseteq> jkbpC\\<^bsub>n\\<^esub> \\<and> jview a t = jview a t'},\n                                valuation = envVal \\<circ> tLast\\<rparr>\n                             a", "by (fastforce dest: sync[rule_format])"], ["", "lemma jkbpC_tFirst_init_inv[intro]:\n  \"t \\<in> jkbpC \\<Longrightarrow> tFirst t \\<in> set envInit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> jkbpC \\<Longrightarrow> tFirst t \\<in> set envInit", "unfolding jkbpC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> \\<Union> (range jkbpCn) \\<Longrightarrow>\n    tFirst t \\<in> set envInit", "by blast"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can show that @{term \"jkbpC\"} represents the joint knowledge-based\nprogram @{term \"jkbp\"} with respect to @{term \"jview\"}:\n\n\\<close>"], ["", "lemma jkbpC_jkbpCn_jAction_eq:\n  assumes tCn: \"t \\<in> jkbpC\\<^bsub>n\\<^esub>\"\n  shows \"jAction MC t = jAction MC\\<^bsub>n\\<^esub> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction MC t = jAction MC\\<^bsub>n\\<^esub> t", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. jAction MC t = jAction MC\\<^bsub>n\\<^esub> t", "using assms"], ["proof (prove)\nusing this:\n  t \\<in> jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. jAction MC t = jAction MC\\<^bsub>n\\<^esub> t", "by - (rule sync_jview_jAction_eq, auto iff: jkbpC_traces_of_length)"], ["", "(*>*)"], ["", "text\\<open>\\<close>"], ["", "lemma jkbpTn_jkbpCn_represents: \"jkbpT\\<^bsub>n\\<^esub> jkbpC = jkbpC\\<^bsub>n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. jkbpT\\<^bsub>n\\<^esub> jkbpC = jkbpC\\<^bsub>n\\<^esub>", "by (induct n) (fastforce simp: Let_def jkbpC_jkbpCn_jAction_eq)+"], ["", "text\\<open>\\<close>"], ["", "theorem jkbpC_represents: \"represents jkbpC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. represents jkbpC", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. represents jkbpC", "using jkbpTn_jkbpCn_represents"], ["proof (prove)\nusing this:\n  jkbpT\\<^bsub>?n\\<^esub> jkbpC = jkbpC\\<^bsub>?n\\<^esub>\n\ngoal (1 subgoal):\n 1. represents jkbpC", "by (simp add: representsI jkbpC_def jkbpT_def)"], ["", "(*>*)"], ["", "text\\<open>\n\nWe can show uniqueness too, by a similar argument:\n\n\\<close>"], ["", "theorem jkbpC_represents_uniquely:\n  assumes repT: \"represents T\"\n  shows \"T = jkbpC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = jkbpC", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. T = jkbpC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T = jkbpC", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. T = jkbpC", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. T = jkbpC", "have \"{ t \\<in> T . tLength t = n } = { t \\<in> jkbpC . tLength t = n }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> T. tLength t = n} = {t \\<in> jkbpC. tLength t = n}", "proof(induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. {t \\<in> T. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {t \\<in> T. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "from repT"], ["proof (chain)\npicking this:\n  represents T", "have F: \"{t \\<in> T. tLength t = 0} = jkbpTn 0 T\""], ["proof (prove)\nusing this:\n  represents T\n\ngoal (1 subgoal):\n 1. {t \\<in> T. tLength t = 0} = jkbpT\\<^bsub>0\\<^esub> T", "by - (subst jkbpT_traces_of_length[symmetric], simp add: representsD)"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = 0} = jkbpT\\<^bsub>0\\<^esub> T\n\ngoal (2 subgoals):\n 1. {t \\<in> T. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n 2. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "thus ?case"], ["proof (prove)\nusing this:\n  {t \\<in> T. tLength t = 0} = jkbpT\\<^bsub>0\\<^esub> T\n\ngoal (1 subgoal):\n 1. {t \\<in> T. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}", "by (simp add: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = 0} = {t \\<in> jkbpC. tLength t = 0}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "case (Suc n)"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "hence indhyp: \"{t \\<in> T. tLength t = n} = jkbpCn n\""], ["proof (prove)\nusing this:\n  {t \\<in> T. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>", "by (simp add: jkbpC_traces_of_length)"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "(* F and H are very similar. *)"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "from repT"], ["proof (chain)\npicking this:\n  represents T", "have F: \"\\<And>n. jkbpTn n T = {t \\<in> T. tLength t = n}\""], ["proof (prove)\nusing this:\n  represents T\n\ngoal (1 subgoal):\n 1. \\<And>n. jkbpT\\<^bsub>n\\<^esub> T = {t \\<in> T. tLength t = n}", "by - (subst jkbpT_traces_of_length[symmetric], simp add: representsD)"], ["proof (state)\nthis:\n  jkbpT\\<^bsub>?n1\\<^esub> T = {t \\<in> T. tLength t = ?n1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "from indhyp F"], ["proof (chain)\npicking this:\n  {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n  jkbpT\\<^bsub>?n1\\<^esub> T = {t \\<in> T. tLength t = ?n1}", "have G: \"jkbpTn n T = jkbpCn n\""], ["proof (prove)\nusing this:\n  {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n  jkbpT\\<^bsub>?n1\\<^esub> T = {t \\<in> T. tLength t = ?n1}\n\ngoal (1 subgoal):\n 1. jkbpT\\<^bsub>n\\<^esub> T = jkbpC\\<^bsub>n\\<^esub>", "by simp"], ["proof (state)\nthis:\n  jkbpT\\<^bsub>n\\<^esub> T = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "from repT"], ["proof (chain)\npicking this:\n  represents T", "have H: \"\\<And>n. {t \\<in> T. tLength t = n} = {t \\<in> jkbpTn n T. tLength t = n}\""], ["proof (prove)\nusing this:\n  represents T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpT\\<^bsub>n\\<^esub> T. tLength t = n}", "by (subst representsD[OF repT, symmetric], auto iff: jkbpT_traces_of_length jkbpTn_length)"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = ?n1} =\n  {t \\<in> jkbpT\\<^bsub>?n1\\<^esub> T. tLength t = ?n1}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "from F indhyp"], ["proof (chain)\npicking this:\n  jkbpT\\<^bsub>?n1\\<^esub> T = {t \\<in> T. tLength t = ?n1}\n  {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>", "have ACTS:\n        \"\\<And>t. t \\<in> jkbpTn n T\n          \\<Longrightarrow> jAction (mkM T) t = jAction (MCn n) t\""], ["proof (prove)\nusing this:\n  jkbpT\\<^bsub>?n1\\<^esub> T = {t \\<in> T. tLength t = ?n1}\n  {t \\<in> T. tLength t = n} = jkbpC\\<^bsub>n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> jkbpT\\<^bsub>n\\<^esub> T \\<Longrightarrow>\n       jAction (mkM T) t = jAction MC\\<^bsub>n\\<^esub> t", "by - (rule sync_jview_jAction_eq[where n=\"n\"], auto)"], ["proof (state)\nthis:\n  ?t1 \\<in> jkbpT\\<^bsub>n\\<^esub> T \\<Longrightarrow>\n  jAction (mkM T) ?t1 = jAction MC\\<^bsub>n\\<^esub> ?t1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       {t \\<in> T. tLength t = n} =\n       {t \\<in> jkbpC. tLength t = n} \\<Longrightarrow>\n       {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}", "apply (auto iff: Let_def ACTS G H jkbpC_traces_of_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t eact aact.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a.\n           aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a))\n 2. \\<And>t eact aact.\n       \\<lbrakk>t \\<in> jkbpC\\<^bsub>n\\<^esub>;\n        eact \\<in> set (envAction (tLast t));\n        \\<forall>a.\n           aact a \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>eacta aacta.\n                            envTrans eact aact (tLast t) =\n                            envTrans eacta aacta (tLast t) \\<and>\n                            eacta \\<in> set (envAction (tLast t)) \\<and>\n                            (\\<forall>a.\n                                aacta a\n                                \\<in> set (jAction MC\\<^bsub>n\\<^esub> t a))", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = Suc n} = {t \\<in> jkbpC. tLength t = Suc n}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = n} = {t \\<in> jkbpC. tLength t = n}\n\ngoal (1 subgoal):\n 1. T = jkbpC", "}"], ["proof (state)\nthis:\n  {t \\<in> T. tLength t = ?n3} = {t \\<in> jkbpC. tLength t = ?n3}\n\ngoal (1 subgoal):\n 1. T = jkbpC", "thus ?thesis"], ["proof (prove)\nusing this:\n  {t \\<in> T. tLength t = ?n3} = {t \\<in> jkbpC. tLength t = ?n3}\n\ngoal (1 subgoal):\n 1. T = jkbpC", "by auto"], ["proof (state)\nthis:\n  T = jkbpC\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "end"], ["", "(* context PreEnvironmentJView *)"], ["", "text\\<open>\n\nThus, at least with synchronous views, we are justified in talking\nabout \\emph{the} representation of a JKBP in a given environment. More\ngenerally these results are also valid for the more general notion of\n\\emph{provides witnesses} as shown by \\citet[Lemma 7.2.4]{FHMV:1995}\nand \\citet{DBLP:journals/dc/FaginHMV97}: it requires only that if a\nsubjective knowledge formula is false on a trace then there is a trace\nof the same length or less that bears witness to that effect. This is\na useful generalisation in asynchronous settings.\n\nThe next section shows how we can construct canonical representations\nof JKBPs using automata.\n\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}