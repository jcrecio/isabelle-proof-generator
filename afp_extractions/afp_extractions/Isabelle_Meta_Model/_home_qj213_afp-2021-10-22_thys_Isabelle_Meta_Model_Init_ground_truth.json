{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model/Init.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model", "problem_names": ["lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  L.map_def\n  L.flatten_def\n  L.mapi_def\n  L.iter_def\n  L.maps_def\n  L.append_def\n  L.filter_def\n  L.rev_map_def\n  L.mapM_def\n  L.assoc_def\n  L.split_def\n  L.upto_def\n  L.split_at_def\n  L.take_def\n  L.take_last_def\n  L.take_first_def\n  L.replace_gen_def\n  L.nsplit_f_def\n  L.replace_def\n  L.map_find_def\n\n  \\<comment> \\<open>fun\\<close>\n  L.map_find_aux.simps", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  S.flatten_def\n  String.flatten_def\n  String.make_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.map_gen_def\n  String.foldl_one_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.foldl_def\n  S.replace_integers_def\n  String.map_def\n  String.replace_integers_def\n  String.all_def\n  String.length_def\n  String.to_list_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_list_def\n  String.meta_of_logic_def\n  String.to_String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_String_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.is_empty_def\n  String.equal_def\n  String.assoc_def\n  String.member_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.flatten_def\n\n  \\<comment> \\<open>fun\\<close>\n  String.map_gen.simps\n  String.foldl.simps\n  String.is_empty.simps", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  String.lowercase_def\n  String.uppercase_def\n  String.to_bold_number_def\n  String.nat_to_digit10_def\n  String.natural_to_digit10_def\n  String.integer_to_digit16_def\n\n  \\<comment> \\<open>fun\\<close>\n  String.nat_to_digit10_aux.simps", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  String.base255_def\n  String.isub_def\n  String.isup_def"], "translations": [["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  L.map_def\n  L.flatten_def\n  L.mapi_def\n  L.iter_def\n  L.maps_def\n  L.append_def\n  L.filter_def\n  L.rev_map_def\n  L.mapM_def\n  L.assoc_def\n  L.split_def\n  L.upto_def\n  L.split_at_def\n  L.take_def\n  L.take_last_def\n  L.take_first_def\n  L.replace_gen_def\n  L.nsplit_f_def\n  L.replace_def\n  L.map_find_def\n\n  \\<comment> \\<open>fun\\<close>\n  L.map_find_aux.simps"], ["", "subsection\\<open>Operations on Char\\<close>"], ["", "definition ascii_of_literal (\"INT\") where\n          \"ascii_of_literal = hd o String.asciis_of_literal\""], ["", "definition \"(integer_escape :: integer) = 0x09\""], ["", "definition \"ST0 c = \\<lless>[c]\\<ggreater>\""], ["", "definition \"ST0_base c = ST' [c]\""], ["", "subsection\\<open>Operations on String (I)\\<close>"], ["", "notation \"String.asciis_of_literal\" (\"INTS\")"], ["", "locale S"], ["", "locale String"], ["", "locale String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e"], ["", "definition (in S) \"flatten = String_concatWith \\<open>\\<close>\""], ["", "definition (in String) \"flatten a b = S.flatten [a, b]\""], ["", "notation String.flatten (infixr \"@@\" 65)"], ["", "definition (in String) \"make n c = \\<lless>L.map (\\<lambda>_. c) (L.upto 1 n)\\<ggreater>\""], ["", "definition (in String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \"map_gen replace g = (\\<lambda> ST s \\<Rightarrow> replace \\<open>\\<close> (Some s) \\<open>\\<close>\n                                                | ST' s \\<Rightarrow> S.flatten (L.map g s))\""], ["", "fun (in String) map_gen where\n   \"map_gen replace g e =\n     (\\<lambda> SS_base s \\<Rightarrow> String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.map_gen replace g s\n      | String_concatWith abr l \\<Rightarrow> String_concatWith (map_gen replace g abr) (List.map (map_gen replace g) l)) e\""], ["", "definition (in String) \"foldl_one f accu = foldl f accu o INTS\""], ["", "definition (in String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) foldl where \"foldl f accu = (\\<lambda> ST s \\<Rightarrow> String.foldl_one f accu s\n                                                       | ST' s \\<Rightarrow> List.foldl f accu s)\""], ["", "fun (in String) foldl where\n   \"foldl f accu e =\n     (\\<lambda> SS_base s \\<Rightarrow> String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.foldl f accu s\n      | String_concatWith abr l \\<Rightarrow>\n        (case l of [] \\<Rightarrow> accu\n                 | x # xs \\<Rightarrow> List.foldl (\\<lambda>accu. foldl f (foldl f accu abr)) (foldl f accu x) xs)) e\""], ["", "definition (in S) \"replace_integers f s1 s s2 =\n  s1 @@ (case s of None \\<Rightarrow> \\<open>\\<close> | Some s \\<Rightarrow> flatten (L.map f (INTS s))) @@ s2\""], ["", "definition (in String) map where \"map f = map_gen (S.replace_integers (\\<lambda>c. \\<degree>f c\\<degree>)) (\\<lambda>x. \\<degree>f x\\<degree>)\""], ["", "definition (in String) \"replace_integers f = map_gen (S.replace_integers (\\<lambda>c. f c)) f\""], ["", "definition (in String) \"all f = foldl (\\<lambda>b s. b & f s) True\""], ["", "definition (in String) length where \"length = foldl (\\<lambda>n _. Suc n) 0\""], ["", "definition (in String) \"to_list s = rev (foldl (\\<lambda>l c. c # l) [] s)\""], ["", "definition (in String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \"to_list = (\\<lambda> ST s \\<Rightarrow> INTS s | ST' l \\<Rightarrow> l)\""], ["", "definition (in String) \"meta_of_logic = String.literal_of_asciis o to_list\""], ["", "definition (in String) \"to_String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e = (\\<lambda> SS_base s \\<Rightarrow> s | s \\<Rightarrow> ST' (to_list s))\""], ["", "definition (in String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \"to_String = SS_base\""], ["", "definition (in String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \"is_empty = (\\<lambda> ST s \\<Rightarrow> s = STR ''''\n                                       | ST' s \\<Rightarrow> s = [])\""], ["", "fun (in String) is_empty where\n   \"is_empty e = (\\<lambda> SS_base s \\<Rightarrow> String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.is_empty s | String_concatWith _ l \\<Rightarrow> list_all is_empty l) e\""], ["", "definition (in String) \"equal s1 s2 = (to_list s1 = to_list s2)\""], ["", "notation String.equal (infixl \"\\<triangleq>\" 50)"], ["", "definition (in String) \"assoc x l = L.assoc (to_list x) (L.map (map_prod String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_list id) l)\""], ["", "definition (in String) \"member l x = List.member (L.map String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_list l) (to_list x)\""], ["", "definition (in String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \"flatten l = String.to_String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (S.flatten (L.map to_String l))\""], ["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  S.flatten_def\n  String.flatten_def\n  String.make_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.map_gen_def\n  String.foldl_one_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.foldl_def\n  S.replace_integers_def\n  String.map_def\n  String.replace_integers_def\n  String.all_def\n  String.length_def\n  String.to_list_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_list_def\n  String.meta_of_logic_def\n  String.to_String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_String_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.is_empty_def\n  String.equal_def\n  String.assoc_def\n  String.member_def\n  String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.flatten_def\n\n  \\<comment> \\<open>fun\\<close>\n  String.map_gen.simps\n  String.foldl.simps\n  String.is_empty.simps"], ["", "subsection\\<open>Operations on String (II)\\<close>"], ["", "definition \"wildcard = \\<open>_\\<close>\""], ["", "context String\nbegin"], ["", "definition \"lowercase = map (\\<lambda>n. if n < 97 then n + 32 else n)\""], ["", "definition \"uppercase = map (\\<lambda>n. if n < 97 then n else n - 32)\""], ["", "definition \"to_bold_number = replace_integers (\\<lambda>n. [\\<open>\\<zero>\\<close>, \\<open>\\<one>\\<close>, \\<open>\\<two>\\<close>, \\<open>\\<three>\\<close>, \\<open>\\<four>\\<close>, \\<open>\\<five>\\<close>, \\<open>\\<six>\\<close>, \\<open>\\<seven>\\<close>, \\<open>\\<eight>\\<close>, \\<open>\\<nine>\\<close>] ! nat_of_integer (n - 48))\""], ["", "fun nat_to_digit10_aux where\n   \"nat_to_digit10_aux l (n :: Nat.nat) = (if n < 10 then n # l else nat_to_digit10_aux (n mod 10 # l) (n div 10))\""], ["", "definition \"nat_to_digit10 n =\n (let nat_raw_to_str = L.map (integer_of_nat o (+) 0x30) in\n  \\<lless>nat_raw_to_str (nat_to_digit10_aux [] n)\\<ggreater>)\""], ["", "definition \"natural_to_digit10 = nat_to_digit10 o nat_of_natural\""], ["", "declare[[cartouche_type = \"String.literal\"]]"], ["", "definition \"integer_to_digit16 =\n (let f = nth (INTS \\<open>0123456789ABCDEF\\<close>) o nat_of_integer in\n  \\<lambda>n \\<Rightarrow> \\<lless>[f (n div 16), f (n mod 16)]\\<ggreater>)\""], ["", "end"], ["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  String.lowercase_def\n  String.uppercase_def\n  String.to_bold_number_def\n  String.nat_to_digit10_def\n  String.natural_to_digit10_def\n  String.integer_to_digit16_def\n\n  \\<comment> \\<open>fun\\<close>\n  String.nat_to_digit10_aux.simps"], ["", "definition \"add_0 n =\n (let n = nat_of_integer n in\n  S.flatten (L.map (\\<lambda>_. \\<open>0\\<close>) (upt 0 (if n < 10 then 2 else if n < 100 then 1 else 0)))\n  @@ String.nat_to_digit10 n)\""], ["", "declare[[cartouche_type = \"String.literal\"]]"], ["", "definition \"is_letter =\n (let int_A = INT \\<open>A\\<close>; int_Z = INT \\<open>Z\\<close>; int_a = INT \\<open>a\\<close>; int_z = INT \\<open>z\\<close> in\n  (\\<lambda>n. n \\<ge> int_A & n \\<le> int_Z | n \\<ge> int_a & n \\<le> int_z))\""], ["", "definition \"is_digit =\n (let int_0 = INT \\<open>0\\<close>; int_9 = INT \\<open>9\\<close> in\n  (\\<lambda>n. n \\<ge> int_0 & n \\<le> int_9))\""], ["", "definition \"is_special = List.member (INTS \\<open> <>^_=-./(){}\\<close>)\""], ["", "context String\nbegin"], ["", "definition \"base255 = replace_integers (\\<lambda>c. if is_letter c then \\<degree>c\\<degree> else add_0 c)\""], ["", "declare[[cartouche_type = \"abr_string\"]]"], ["", "definition \"isub =\n  replace_integers (let is_und = List.member (INTS (STR ''_'')) in\n                    (\\<lambda>c. if is_letter c | is_digit c | is_und c then \\<open>\\<^sub>\\<close> @@ \\<degree>c\\<degree> else add_0 c))\""], ["", "definition \"isup s = \\<open>__\\<close> @@ s\""], ["", "end"], ["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  String.base255_def\n  String.isub_def\n  String.isup_def"], ["", "declare[[cartouche_type = \"abr_string\"]]"], ["", "definition \"text_of_str str =\n (let s = \\<open>c\\<close>\n    ; ap = \\<open> # \\<close> in\n  S.flatten [ \\<open>(let \\<close>, s, \\<open> = char_of :: nat \\<Rightarrow> char in \\<close>\n          , String.replace_integers (\\<lambda>c.\n                                    if is_letter c then\n                                      S.flatten [\\<open>CHR ''\\<close>,\\<degree>c\\<degree>,\\<open>''\\<close>,ap]\n                                    else\n                                      S.flatten [s, \\<open> \\<close>,  add_0 c, ap])\n                                 str\n          , \\<open>[])\\<close>])\""], ["", "definition \\<open>text2_of_str = String.replace_integers (\\<lambda>c. S.flatten [\\<open>\\\\<close>, \\<open><\\<close>, \\<degree>c\\<degree>, \\<open>>\\<close>])\\<close>"], ["", "definition \"textstr_of_str f_flatten f_integer f_str str =\n (let str0 = String.to_list str\n    ; f_letter = \\<lambda>c. is_letter c | is_digit c | is_special c\n    ; s = \\<open>c\\<close>\n    ; f_text = \\<lambda> Nsplit_text l \\<Rightarrow> S.flatten [f_str (S.flatten [\\<open>STR ''\\<close>,\\<lless>l\\<ggreater>,\\<open>''\\<close>])]\n               | Nsplit_sep c \\<Rightarrow> S.flatten [f_integer c]\n    ; str = case L.nsplit_f str0 (Not o f_letter) of\n              [] \\<Rightarrow> S.flatten [f_str \\<open>STR ''''\\<close>]\n            | [x] \\<Rightarrow> f_text x\n            | l \\<Rightarrow> S.flatten (L.map (\\<lambda>x. \\<open>(\\<close> @@ f_text x @@ \\<open>) # \\<close>) l) @@ \\<open>[]\\<close> in\n  if list_all f_letter str0 then\n    str\n  else\n    f_flatten (S.flatten [ \\<open>(\\<close>, str, \\<open>)\\<close> ]))\""], ["", "definition \\<open>escape_sml = String.replace_integers (\\<lambda>n. if n = 0x22 then \\<open>\\\"\\<close> else \\<degree>n\\<degree>)\\<close>"], ["", "definition \"mk_constr_name name = (\\<lambda> x. S.flatten [String.isub name, \\<open>_\\<close>, String.isub x])\""], ["", "definition \"mk_dot s1 s2 = S.flatten [\\<open>.\\<close>, s1, s2]\""], ["", "definition \"mk_dot_par_gen dot l_s = S.flatten [dot, \\<open>(\\<close>, case l_s of [] \\<Rightarrow> \\<open>\\<close> | x # xs \\<Rightarrow> S.flatten [x, S.flatten (L.map (\\<lambda>s. \\<open>, \\<close> @@ s) xs) ], \\<open>)\\<close>]\""], ["", "definition \"mk_dot_par dot s = mk_dot_par_gen dot [s]\""], ["", "definition \"mk_dot_comment s1 s2 s3 = mk_dot s1 (S.flatten [s2, \\<open> /*\\<close>, s3, \\<open>*/\\<close>])\""], ["", "definition \"hol_definition s = S.flatten [s, \\<open>_def\\<close>]\""], ["", "definition \"hol_split s = S.flatten [s, \\<open>.split\\<close>]\""], ["", "end"]]}