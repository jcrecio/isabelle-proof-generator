{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model/meta_isabelle/Meta_Isabelle.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model", "problem_names": ["lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  T.thm_def\n  T.thms_def\n  T.THEN_def\n  T.simplified_def\n  T.symmetric_def\n  T.where_def\n  T.of'_def\n  T.OF_def\n  T.OF_l_def\n  T.simplified_l_def", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  M.Method_simp_add_del_def\n  M.Method_subst_l_def\n  M.rule'_def\n  M.rule_def\n  M.drule_def\n  M.erule_def\n  M.intro_def\n  M.elim_def\n  M.subst_l0_def\n  M.subst_l_def\n  M.insert_def\n  M.plus_def\n  M.option_def\n  M.or_def\n  M.meth_gen_simp_def\n  M.meth_gen_simp_add2_def\n  M.meth_gen_simp_add_del_def\n  M.meth_gen_simp_add_del_split_def\n  M.meth_gen_simp_add_split_def\n  M.meth_gen_simp_only_def\n  M.meth_gen_simp_only'_def\n  M.meth_gen_simp_add0_def\n  M.simp_def\n  M.simp_add2_def\n  M.simp_add_del_def\n  M.simp_add_del_split_def\n  M.simp_add_split_def\n  M.simp_only_def\n  M.simp_only'_def\n  M.simp_add0_def\n  M.simp_add_def\n  M.simp_all_def\n  M.simp_all_add_def\n  M.simp_all_only_def\n  M.simp_all_only'_def\n  M.auto_simp_add2_def\n  M.auto_simp_add_split_def\n  M.rename_tac_def\n  M.case_tac_def\n  M.blast_def\n  M.clarify_def\n  M.metis_def\n  M.metis0_def\n  M.subst_asm_def\n  M.subst_def\n  M.auto_simp_add_def\n  M.auto_def", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  C.done_def\n  C.by_def\n  C.sorry_def\n  C.apply_end_def\n  C.apply_def\n  C.using_def\n  C.unfolding_def\n  C.let'_def\n  C.fix_let_def\n  C.fix_def\n  C.have_def\n  C.have0_def"], "translations": [["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  T.thm_def\n  T.thms_def\n  T.THEN_def\n  T.simplified_def\n  T.symmetric_def\n  T.where_def\n  T.of'_def\n  T.OF_def\n  T.OF_l_def\n  T.simplified_l_def"], ["", "definition \"Opt s = Typ_apply (Typ_base \\<open>option\\<close>) [Typ_base s]\""], ["", "definition \"Raw = Typ_base\""], ["", "definition \"Type_synonym' n = Type_synonym n []\""], ["", "definition \"Type_synonym'' n l f = Type_synonym n l (f l)\""], ["", "definition \"Term_annot' e s = Term_annot e (Typ_base s)\""], ["", "definition \"Term_lambdas s = Term_bind \\<open>\\<lambda>\\<close> (Term_basic s)\""], ["", "definition \"Term_lambda x = Term_lambdas [x]\""], ["", "definition \"Term_lambdas0 = Term_bind \\<open>\\<lambda>\\<close>\""], ["", "definition \"Term_lam x f = Term_lambdas0 (Term_basic [x]) (f x)\""], ["", "definition \"Term_some = Term_paren \\<open>\\<lfloor>\\<close> \\<open>\\<rfloor>\\<close>\""], ["", "definition \"Term_parenthesis \\<comment> \\<open>mandatory parenthesis\\<close> = Term_paren \\<open>(\\<close> \\<open>)\\<close>\""], ["", "definition \"Term_warning_parenthesis \\<comment> \\<open>optional parenthesis that can be removed but a warning will be raised\\<close> = Term_parenthesis\""], ["", "definition \"Term_pat b = Term_basic [\\<open>?\\<close> @@ b]\""], ["", "definition \"Term_And x f = Term_bind \\<open>\\<And>\\<close> (Term_basic [x]) (f x)\""], ["", "definition \"Term_exists x f = Term_bind \\<open>\\<exists>\\<close> (Term_basic [x]) (f x)\""], ["", "definition \"Term_binop = Term_rewrite\""], ["", "definition \"term_binop s l = (case rev l of x # xs \\<Rightarrow> List.fold (\\<lambda>x. Term_binop x s) xs x)\""], ["", "definition \"term_binop' s l = (case rev l of x # xs \\<Rightarrow> List.fold (\\<lambda>x. Term_parenthesis o Term_binop x s) xs x)\""], ["", "definition \"Term_set l = (case l of [] \\<Rightarrow> Term_basic [\\<open>{}\\<close>] | _ \\<Rightarrow> Term_paren \\<open>{\\<close> \\<open>}\\<close> (term_binop \\<open>,\\<close> l))\""], ["", "definition \"Term_list l = (case l of [] \\<Rightarrow> Term_basic [\\<open>[]\\<close>] | _ \\<Rightarrow> Term_paren \\<open>[\\<close> \\<open>]\\<close> (term_binop \\<open>,\\<close> l))\""], ["", "definition \"Term_list' f l = Term_list (L.map f l)\""], ["", "definition \"Term_pair e1 e2 = Term_parenthesis (Term_binop e1 \\<open>,\\<close> e2)\""], ["", "definition \"Term_pair' l = (case l of [] \\<Rightarrow> Term_basic [\\<open>()\\<close>] | _ \\<Rightarrow> Term_paren \\<open>(\\<close> \\<open>)\\<close> (term_binop \\<open>,\\<close> l))\""], ["", "definition \\<open>Term_string s = Term_basic [S.flatten [\\<open>\"\\<close>, s, \\<open>\"\\<close>]]\\<close>"], ["", "definition \"Term_applys0 e l = Term_parenthesis (Term_apply e (L.map Term_parenthesis l))\""], ["", "definition \"Term_applys e l = Term_applys0 (Term_parenthesis e) l\""], ["", "definition \"Term_app e = Term_applys0 (Term_basic [e])\""], ["", "definition \"Term_preunary e1 e2 = Term_apply e1 [e2]\" \\<comment> \\<open>no parenthesis and separated with one space\\<close>"], ["", "definition \"Term_postunary e1 e2 = Term_apply e1 [e2]\" \\<comment> \\<open>no parenthesis and separated with one space\\<close>"], ["", "definition \"Term_case = Term_fun_case o Some\""], ["", "definition \"Term_function = Term_fun_case None\""], ["", "definition \"Term_term' = Term_term []\""], ["", "definition \"Lemmas_simp = Lemmas_simp_thm True\""], ["", "definition \"Lemmas_nosimp = Lemmas_simp_thm False\""], ["", "definition \"Consts_value = \\<open>(_)\\<close>\""], ["", "definition \"Consts_raw0 s l e o_arg =\n       Consts s l (String.replace_integers (\\<lambda>n. if n = 0x5F then \\<open>'_\\<close> else \\<degree>n\\<degree>) e @@ (case o_arg of\n         None \\<Rightarrow> \\<open>\\<close>\n       | Some arg \\<Rightarrow>\n           let ap = \\<lambda>s. \\<open>'(\\<close> @@ s @@ \\<open>')\\<close> in\n           ap (if arg = 0 then\n                \\<open>\\<close>\n              else\n                Consts_value @@ (S.flatten (L.map (\\<lambda>_. \\<open>,\\<close> @@ Consts_value) (L.upto 2 arg))))))\""], ["", "definition \"Ty_arrow = Typ_apply_bin \\<open>\\<Rightarrow>\\<close>\""], ["", "definition \"Ty_times = Typ_apply_bin \\<open>\\<times>\\<close>\""], ["", "definition \"Ty_arrow' x = Ty_arrow x (Typ_base \\<open>_\\<close>)\""], ["", "definition \"Ty_paren = Typ_apply_paren \\<open>(\\<close> \\<open>)\\<close>\""], ["", "definition \"Consts' s l e = Consts_raw0 s (Ty_arrow (Typ_base \\<open>'\\<alpha>\\<close>) l) e None\""], ["", "definition \"Overloading' n ty = Overloading n (Term_annot (Term_basic [n]) ty)\""], ["", "locale M\nbegin"], ["", "definition \"Method_simp_add_del l_a l_d = Method_simp_add_del_split l_a l_d []\""], ["", "definition \"Method_subst_l = Method_subst False\""], ["", "definition \"rule' = Method_rule None\""], ["", "definition \"rule = Method_rule o Some\""], ["", "definition \"drule = Method_drule\""], ["", "definition \"erule = Method_erule\""], ["", "definition \"intro = Method_intro\""], ["", "definition \"elim = Method_elim\""], ["", "definition \"subst_l0 = Method_subst\""], ["", "definition \"subst_l = Method_subst_l\""], ["", "definition insert where \"insert = Method_insert o L.map Thms_single\""], ["", "definition plus where \"plus = Method_plus\""], ["", "definition \"option = Method_option\""], ["", "definition \"or = Method_or\""], ["", "definition \"meth_gen_simp = Method_simp_add_del [] []\""], ["", "definition \"meth_gen_simp_add2 l1 l2 = Method_simp_add_del (L.flatten [ L.map Thms_mult l1\n                                                    , L.map (Thms_single o Thm_thm) l2])\n                                           []\""], ["", "definition \"meth_gen_simp_add_del l1 l2 = Method_simp_add_del (L.map (Thms_single o Thm_thm) l1)\n                                              (L.map (Thms_single o Thm_thm) l2)\""], ["", "definition \"meth_gen_simp_add_del_split l1 l2 l3 = Method_simp_add_del_split (L.map Thms_single l1)\n                                                             (L.map Thms_single l2)\n                                                             (L.map Thms_single l3)\""], ["", "definition \"meth_gen_simp_add_split l1 l2 = Method_simp_add_del_split (L.map Thms_single l1)\n                                                      []\n                                                      (L.map Thms_single l2)\""], ["", "definition \"meth_gen_simp_only l = Method_simp_only (L.map Thms_single l)\""], ["", "definition \"meth_gen_simp_only' l = Method_simp_only (L.map Thms_mult l)\""], ["", "definition \"meth_gen_simp_add0 l = Method_simp_add_del (L.map Thms_single l) []\""], ["", "definition \"simp = Method_one meth_gen_simp\""], ["", "definition \"simp_add2 l1 l2 = Method_one (meth_gen_simp_add2 l1 l2)\""], ["", "definition \"simp_add_del l1 l2 = Method_one (meth_gen_simp_add_del l1 l2)\""], ["", "definition \"simp_add_del_split l1 l2 l3 = Method_one (meth_gen_simp_add_del_split l1 l2 l3)\""], ["", "definition \"simp_add_split l1 l2 = Method_one (meth_gen_simp_add_split l1 l2)\""], ["", "definition \"simp_only l = Method_one (meth_gen_simp_only l)\""], ["", "definition \"simp_only' l = Method_one (meth_gen_simp_only' l)\""], ["", "definition \"simp_add0 l = Method_one (meth_gen_simp_add0 l)\""], ["", "definition \"simp_add = simp_add2 []\""], ["", "definition \"simp_all = Method_all meth_gen_simp\""], ["", "definition \"simp_all_add l = Method_all (meth_gen_simp_add2 [] l)\""], ["", "definition \"simp_all_only l = Method_all (meth_gen_simp_only l)\""], ["", "definition \"simp_all_only' l = Method_all (meth_gen_simp_only' l)\""], ["", "definition \"auto_simp_add2 l1 l2 = Method_auto_simp_add_split (L.flatten [ L.map Thms_mult l1\n                                                                , L.map (Thms_single o Thm_thm) l2]) []\""], ["", "definition \"auto_simp_add_split l = Method_auto_simp_add_split (L.map Thms_single l)\""], ["", "definition \"rename_tac = Method_rename_tac\""], ["", "definition \"case_tac = Method_case_tac\""], ["", "definition \"blast = Method_blast\""], ["", "definition \"clarify = Method_clarify\""], ["", "definition \"metis = Method_metis []\""], ["", "definition \"metis0 = Method_metis\""], ["", "definition \"subst_asm b = subst_l0 b [\\<open>0\\<close>]\""], ["", "definition \"subst = subst_l [\\<open>0\\<close>]\""], ["", "definition \"auto_simp_add = auto_simp_add2 []\""], ["", "definition \"auto = auto_simp_add []\""], ["", "end"], ["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  M.Method_simp_add_del_def\n  M.Method_subst_l_def\n  M.rule'_def\n  M.rule_def\n  M.drule_def\n  M.erule_def\n  M.intro_def\n  M.elim_def\n  M.subst_l0_def\n  M.subst_l_def\n  M.insert_def\n  M.plus_def\n  M.option_def\n  M.or_def\n  M.meth_gen_simp_def\n  M.meth_gen_simp_add2_def\n  M.meth_gen_simp_add_del_def\n  M.meth_gen_simp_add_del_split_def\n  M.meth_gen_simp_add_split_def\n  M.meth_gen_simp_only_def\n  M.meth_gen_simp_only'_def\n  M.meth_gen_simp_add0_def\n  M.simp_def\n  M.simp_add2_def\n  M.simp_add_del_def\n  M.simp_add_del_split_def\n  M.simp_add_split_def\n  M.simp_only_def\n  M.simp_only'_def\n  M.simp_add0_def\n  M.simp_add_def\n  M.simp_all_def\n  M.simp_all_add_def\n  M.simp_all_only_def\n  M.simp_all_only'_def\n  M.auto_simp_add2_def\n  M.auto_simp_add_split_def\n  M.rename_tac_def\n  M.case_tac_def\n  M.blast_def\n  M.clarify_def\n  M.metis_def\n  M.metis0_def\n  M.subst_asm_def\n  M.subst_def\n  M.auto_simp_add_def\n  M.auto_def"], ["", "definition \"ty_arrow l = (case rev l of x # xs \\<Rightarrow> List.fold Ty_arrow xs x)\""], ["", "locale C \nbegin"], ["", "definition \"done = Command_done\""], ["", "definition \"by = Command_by\""], ["", "definition \"sorry = Command_sorry\""], ["", "definition \"apply_end = Command_apply_end\""], ["", "definition \"apply = Command_apply\""], ["", "definition \"using = Command_using o L.map Thms_single\""], ["", "definition \"unfolding = Command_unfolding o L.map Thms_single\""], ["", "definition \"let' = Command_let\""], ["", "definition \"fix_let = Command_fix_let\""], ["", "definition \"fix l = Command_fix_let l [] None []\""], ["", "definition \"have n = Command_have n False\""], ["", "definition \"have0 = Command_have\""], ["", "end"], ["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  C.done_def\n  C.by_def\n  C.sorry_def\n  C.apply_end_def\n  C.apply_def\n  C.using_def\n  C.unfolding_def\n  C.let'_def\n  C.fix_let_def\n  C.fix_def\n  C.have_def\n  C.have0_def"], ["", "fun cross_abs_aux where\n   \"cross_abs_aux f l x = (\\<lambda> (Suc n, Abs s _ t) \\<Rightarrow> f s (cross_abs_aux f (s # l) (n, t))\n                         | (_, e) \\<Rightarrow> Term_term l e)\n                         x\""], ["", "definition \"cross_abs f n l = cross_abs_aux f [] (n, l)\""], ["", "subsection\\<open>Operations of Fold, Map, ..., on the Meta-Model\\<close>"], ["", "definition \"map_lemma f = (\\<lambda> Theory_lemma x \\<Rightarrow> Theory_lemma (f x)\n                           | x \\<Rightarrow> x)\""], ["", "end"]]}