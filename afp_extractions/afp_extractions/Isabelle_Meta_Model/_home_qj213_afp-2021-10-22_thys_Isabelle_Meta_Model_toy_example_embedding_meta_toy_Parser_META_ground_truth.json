{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model/toy_example/embedding/meta_toy/Parser_META.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model", "problem_names": ["lemma [code]: \"compiler_env_config.extend = (\\<lambda>env v. compiler_env_config_rec0 (co14 (\\<lambda>f. f v) compiler_env_config_ext) env)\"", "lemma [code]: \"compiler_env_config.make = co14 (\\<lambda>f. f ()) compiler_env_config_ext\"", "lemma [code]: \"compiler_env_config.truncate = compiler_env_config_rec (co14 K compiler_env_config.make)\"", "lemmas [code] =\n  Parse.of_toy_flush_all_def\n  Parse.of_floor_def\n  Parse.of_all_meta_embedding_def\n  Parse.of_generation_semantics_toy_def\n  Parse.of_generation_lemma_mode_def\n  Parse.of_compiler_env_config_def", "lemmas [code] =\n  Parse_Isabelle.Of_Pair_def\n  Parse_Isabelle.Of_Nil_def\n  Parse_Isabelle.Of_Cons_def\n  Parse_Isabelle.Of_None_def\n  Parse_Isabelle.Of_Some_def\n  Parse_Isabelle.of_pair_def\n  Parse_Isabelle.of_list_def\n  Parse_Isabelle.of_option_def\n  Parse_Isabelle.of_unit_def\n  Parse_Isabelle.of_bool_def\n  Parse_Isabelle.of_string_gen_def\n  Parse_Isabelle.of_string_def\n  Parse_Isabelle.of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n  Parse_Isabelle.of_nat_def\n\n  Parse_Isabelle.compiler_env_config_def", "lemmas [code] =\n  Parse_SML.Of_Pair_def\n  Parse_SML.Of_Nil_def\n  Parse_SML.Of_Cons_def\n  Parse_SML.Of_None_def\n  Parse_SML.Of_Some_def\n\n  Parse_SML.of_pair_def\n  Parse_SML.of_list_def\n  Parse_SML.of_option_def\n  Parse_SML.of_unit_def\n  Parse_SML.of_bool_def\n  Parse_SML.of_string_def\n  Parse_SML.of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n  Parse_SML.of_nat_def\n\n  Parse_SML.sml_escape_def\n  Parse_SML.compiler_env_config_def"], "translations": [["", "lemma [code]: \"compiler_env_config.extend = (\\<lambda>env v. compiler_env_config_rec0 (co14 (\\<lambda>f. f v) compiler_env_config_ext) env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_env_config.extend =\n    (\\<lambda>env v.\n        compiler_env_config_rec0\n         (co14 (\\<lambda>f. f v) compiler_env_config_ext) env)", "by(intro ext, simp add: compiler_env_config_rec0_def\n                        compiler_env_config.extend_def\n                        co14_def K_def)"], ["", "lemma [code]: \"compiler_env_config.make = co14 (\\<lambda>f. f ()) compiler_env_config_ext\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_env_config.make =\n    co14 (\\<lambda>f. f ()) compiler_env_config_ext", "by(intro ext, simp add: compiler_env_config.make_def\n                        co14_def)"], ["", "lemma [code]: \"compiler_env_config.truncate = compiler_env_config_rec (co14 K compiler_env_config.make)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compiler_env_config.truncate =\n    compiler_env_config_rec (co14 K compiler_env_config.make)", "by(intro ext, simp add: compiler_env_config_rec0_def\n                        compiler_env_config_rec_def\n                        compiler_env_config.truncate_def\n                        compiler_env_config.make_def\n                        co14_def K_def)"], ["", "subsection\\<open>Main\\<close>"], ["", "context Parse\nbegin"], ["", "definition \"of_toy_flush_all a b = rec_toy_flush_all\n  (b \\<open>ToyFlushAll\\<close>)\""], ["", "definition \"of_floor a b = rec_floor\n  (b \\<open>Floor1\\<close>)\n  (b \\<open>Floor2\\<close>)\n  (b \\<open>Floor3\\<close>)\""], ["", "definition \"of_all_meta_embedding a b = rec_all_meta_embedding\n  (ap1 a (b \\<open>META_enum\\<close>) (of_toy_enum a b))\n  (ap2 a (b \\<open>META_class_raw\\<close>) (of_floor a b) (of_toy_class_raw a b (K of_unit)))\n  (ap1 a (b \\<open>META_association\\<close>) (of_toy_association a b (K of_unit)))\n  (ap2 a (b \\<open>META_ass_class\\<close>) (of_floor a b) (of_toy_ass_class a b))\n  (ap2 a (b \\<open>META_ctxt\\<close>) (of_floor a b) (of_toy_ctxt a b (K of_unit)))\n\n  (ap1 a (b \\<open>META_class_synonym\\<close>) (of_toy_class_synonym a b))\n  (ap1 a (b \\<open>META_instance\\<close>) (of_toy_instance a b))\n  (ap1 a (b \\<open>META_def_base_l\\<close>) (of_toy_def_base_l a b))\n  (ap2 a (b \\<open>META_def_state\\<close>) (of_floor a b) (of_toy_def_state a b))\n  (ap2 a (b \\<open>META_def_pre_post\\<close>) (of_floor a b) (of_toy_def_pre_post a b))\n  (ap1 a (b \\<open>META_flush_all\\<close>) (of_toy_flush_all a b))\""], ["", "definition \"of_generation_semantics_toy a b = rec_generation_semantics_toy\n  (b \\<open>Gen_only_design\\<close>)\n  (b \\<open>Gen_only_analysis\\<close>)\n  (b \\<open>Gen_default\\<close>)\""], ["", "definition \"of_generation_lemma_mode a b = rec_generation_lemma_mode\n  (b \\<open>Gen_sorry\\<close>)\n  (b \\<open>Gen_no_dirty\\<close>)\""], ["", "definition \"of_compiler_env_config a b f = compiler_env_config_rec\n  (ap15 a (b (ext \\<open>compiler_env_config_ext\\<close>))\n    (of_bool b)\n    (of_option a b (of_pair a b (of_string a b) (of_pair a b (of_list a b (of_string a b)) (of_string a b))))\n    (of_internal_oids a b)\n    (of_pair a b (of_nat a b) (of_nat a b))\n    (of_generation_semantics_toy a b)\n    (of_option a b (of_toy_class a b))\n    (of_list a b (of_all_meta_embedding a b))\n    (of_list a b (of_pair a b (of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b) (of_pair a b (of_toy_instance_single a b (K of_unit)) (of_internal_oids a b))))\n    (of_list a b (of_pair a b (of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b) (of_list a b (of_pair a b (of_internal_oids a b) (of_toy_def_state_core a b (of_pair a b (of_string a b) (of_toy_instance_single a b  (K of_unit))))))))\n    (of_bool b)\n    (of_bool b)\n    (of_pair a b (of_list a b (of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b)) (of_list a b (of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b)))\n    (of_list a b (of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b))\n    (of_pair a b (of_option a b (of_generation_lemma_mode a b)) (of_bool b))\n    (f a b))\""], ["", "end"], ["", "lemmas [code] =\n  Parse.of_toy_flush_all_def\n  Parse.of_floor_def\n  Parse.of_all_meta_embedding_def\n  Parse.of_generation_semantics_toy_def\n  Parse.of_generation_lemma_mode_def\n  Parse.of_compiler_env_config_def"], ["", "section\\<open>Finalizing the Parser\\<close>"], ["", "text\\<open>It should be feasible to invent a meta-command (e.g., \\<open>datatype'\\<close>)\nto automatically generate the previous recursors in \\<open>Parse\\<close>.\n\nOtherwise as an extra check, one can also overload polymorphic cartouches in @{theory Isabelle_Meta_Model.Init}\nto really check that all the given constructor exists at the time of editing\n(similarly as writing @{verbatim \"@{term ...}\"},\nwhen it is embedded in a @{verbatim \"text\"} command).\\<close>"], ["", "subsection\\<open>Isabelle Syntax\\<close>"], ["", "locale Parse_Isabelle\nbegin"], ["", "definition \"Of_Pair = \\<open>Pair\\<close>\""], ["", "definition \"Of_Nil = \\<open>Nil\\<close>\""], ["", "definition \"Of_Cons = \\<open>Cons\\<close>\""], ["", "definition \"Of_None = \\<open>None\\<close>\""], ["", "definition \"Of_Some = \\<open>Some\\<close>\"\n\n\\<comment> \\<open>recursor types\\<close>"], ["", "definition \"of_pair a b f1 f2 = (\\<lambda>f. \\<lambda>(c, d) \\<Rightarrow> f c d)\n  (ap2 a (b Of_Pair) f1 f2)\""], ["", "definition \"of_list a b f = (\\<lambda>f0. rec_list f0 o co1 K)\n  (b Of_Nil)\n  (ar2 a (b Of_Cons) f)\""], ["", "definition \"of_option a b f = rec_option\n  (b Of_None)\n  (ap1 a (b Of_Some) f)\"\n\n\\<comment> \\<open>ground types\\<close>"], ["", "definition \"of_unit b = case_unit\n  (b \\<open>()\\<close>)\""], ["", "definition of_bool where \"of_bool b = case_bool\n  (b \\<open>True\\<close>)\n  (b \\<open>False\\<close>)\""], ["", "definition \"of_string_gen s_flatten s_st0 s_st a b s = \n  b (let s = textstr_of_str (\\<lambda>c. \\<open>(\\<close> @@ s_flatten @@ \\<open> \\<close> @@ c @@ \\<open>)\\<close>)\n                            (\\<lambda>c \\<Rightarrow> s_st0 (S.flatten [\\<open> 0x\\<close>, String.integer_to_digit16 c]))\n                            (\\<lambda>c. s_st (S.flatten [\\<open> (\\<close>, c, \\<open>)\\<close>]))\n                            s in\n     S.flatten [ \\<open>(\\<close>, s, \\<open>)\\<close> ])\""], ["", "definition \"of_string = of_string_gen \\<open>Init.S.flatten\\<close>\n                                          (\\<lambda>s. S.flatten [\\<open>(Init.ST0\\<close>, s, \\<open>)\\<close>])\n                                          (\\<lambda>s. S.flatten [\\<open>(Init.abr_string.SS_base (Init.string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.ST\\<close>, s, \\<open>))\\<close>])\""], ["", "definition \"of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b s = of_string_gen \\<open>Init.String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.flatten\\<close>\n                                                   (\\<lambda>s. S.flatten [\\<open>(Init.ST0_base\\<close>, s, \\<open>)\\<close>])\n                                                   (\\<lambda>s. S.flatten [\\<open>(Init.string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.ST\\<close>, s, \\<open>)\\<close>])\n                                                   a\n                                                   b\n                                                   (String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_String s)\""], ["", "definition of_nat where \"of_nat a b = b o String.natural_to_digit10\""], ["", "end"], ["", "sublocale Parse_Isabelle < Parse \"id\"\n                              Parse_Isabelle.of_string\n                              Parse_Isabelle.of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              Parse_Isabelle.of_nat\n                              Parse_Isabelle.of_unit\n                              Parse_Isabelle.of_bool\n                              Parse_Isabelle.Of_Pair\n                              Parse_Isabelle.Of_Nil\n                              Parse_Isabelle.Of_Cons\n                              Parse_Isabelle.Of_None\n                              Parse_Isabelle.Of_Some"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context Parse_Isabelle begin"], ["", "definition \"compiler_env_config a b =\n    of_compiler_env_config a b (\\<lambda> a b.\n      of_pair a b\n        (of_list a b (of_all_meta_embedding a b))\n        (of_option a b (of_string a b)))\""], ["", "end"], ["", "definition \"isabelle_of_compiler_env_config = Parse_Isabelle.compiler_env_config\""], ["", "lemmas [code] =\n  Parse_Isabelle.Of_Pair_def\n  Parse_Isabelle.Of_Nil_def\n  Parse_Isabelle.Of_Cons_def\n  Parse_Isabelle.Of_None_def\n  Parse_Isabelle.Of_Some_def\n  Parse_Isabelle.of_pair_def\n  Parse_Isabelle.of_list_def\n  Parse_Isabelle.of_option_def\n  Parse_Isabelle.of_unit_def\n  Parse_Isabelle.of_bool_def\n  Parse_Isabelle.of_string_gen_def\n  Parse_Isabelle.of_string_def\n  Parse_Isabelle.of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n  Parse_Isabelle.of_nat_def\n\n  Parse_Isabelle.compiler_env_config_def"], ["", "(* *)"], ["", "definition \"isabelle_apply s l = S.flatten [s, S.flatten (L.map (\\<lambda> s. S.flatten [\\<open> (\\<close>, s, \\<open>)\\<close>]) l)]\""], ["", "subsection\\<open>SML Syntax\\<close>"], ["", "locale Parse_SML\nbegin"], ["", "definition \"Of_Pair = \\<open>I\\<close>\""], ["", "definition \"Of_Nil = \\<open>nil\\<close>\""], ["", "definition \"Of_Cons = \\<open>uncurry cons\\<close>\""], ["", "(* val cons2 = uncurry cons *)"], ["", "definition \"Of_None = \\<open>NONE\\<close>\""], ["", "definition \"Of_Some = \\<open>SOME\\<close>\""], ["", "(* *)"], ["", "definition \"of_pair a b f1 f2 = (\\<lambda>f. \\<lambda>(c, d) \\<Rightarrow> f c d)\n  (ap2 a (b Of_Pair) f1 f2)\""], ["", "definition \"of_list a b f = (\\<lambda>f0. rec_list f0 o co1 K)\n  (b Of_Nil)\n  (ar2 a (b Of_Cons) f)\""], ["", "definition \"of_option a b f = rec_option\n  (b Of_None)\n  (ap1 a (b Of_Some) f)\""], ["", "(* *)"], ["", "definition \"of_unit b = case_unit\n  (b \\<open>()\\<close>)\""], ["", "definition of_bool where \"of_bool b = case_bool\n  (b \\<open>true\\<close>)\n  (b \\<open>false\\<close>)\""], ["", "definition \\<open>sml_escape =\n  String.replace_integers (\\<lambda>x. if x = 0x0A then \\<open>\\n\\<close>\n                               else if x = 0x05 then \\<open>\\005\\<close>\n                               else if x = 0x06 then \\<open>\\006\\<close>\n                               else if x = 0x7F then \\<open>\\127\\<close>\n                               else \\<degree>x\\<degree>)\\<close>"], ["", "definition \\<open>of_string a b =\n (\\<lambda>x. b (S.flatten [ \\<open>(META.SS_base (META.ST \"\\<close>\n                  , sml_escape x\n                  , \\<open>\"))\\<close>]))\\<close>"], ["", "definition \\<open>of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e a b =\n (\\<lambda>x. b (S.flatten [ \\<open>(META.ST \"\\<close>\n                  , sml_escape (String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.to_String x)\n                  , \\<open>\")\\<close>]))\\<close>"], ["", "definition of_nat where \"of_nat a b = (\\<lambda>x. b (S.flatten [\\<open>(Code_Numeral.natural_of_integer \\<close>, String.natural_to_digit10 x, \\<open>)\\<close>]))\""], ["", "end"], ["", "sublocale Parse_SML < Parse \"\\<lambda>c. case String.to_list c of x # xs \\<Rightarrow> S.flatten [String.uppercase \\<lless>[x]\\<ggreater>, \\<lless>xs\\<ggreater>]\"\n                         Parse_SML.of_string\n                         Parse_SML.of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         Parse_SML.of_nat\n                         Parse_SML.of_unit\n                         Parse_SML.of_bool\n                         Parse_SML.Of_Pair\n                         Parse_SML.Of_Nil\n                         Parse_SML.Of_Cons\n                         Parse_SML.Of_None\n                         Parse_SML.Of_Some"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context Parse_SML begin"], ["", "definition \"compiler_env_config a b = of_compiler_env_config a b (\\<lambda> _. of_unit)\""], ["", "end"], ["", "definition \"sml_of_compiler_env_config = Parse_SML.compiler_env_config\""], ["", "lemmas [code] =\n  Parse_SML.Of_Pair_def\n  Parse_SML.Of_Nil_def\n  Parse_SML.Of_Cons_def\n  Parse_SML.Of_None_def\n  Parse_SML.Of_Some_def\n\n  Parse_SML.of_pair_def\n  Parse_SML.of_list_def\n  Parse_SML.of_option_def\n  Parse_SML.of_unit_def\n  Parse_SML.of_bool_def\n  Parse_SML.of_string_def\n  Parse_SML.of_string\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n  Parse_SML.of_nat_def\n\n  Parse_SML.sml_escape_def\n  Parse_SML.compiler_env_config_def"], ["", "(* *)"], ["", "definition \"sml_apply s l = S.flatten [s, \\<open> (\\<close>, case l of x # xs \\<Rightarrow> S.flatten [x, S.flatten (L.map (\\<lambda>s. S.flatten [\\<open>, \\<close>, s]) xs)], \\<open>)\\<close> ]\""], ["", "end"]]}