{"file_name": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model/toy_example/embedding/meta_toy/Meta_Toy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Isabelle_Meta_Model", "problem_names": ["lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  RBTS.lookup_def\n  RBTS.insert_def\n  RBTS.map_entry_def\n  RBTS.modify_def_def\n  RBTS.keys_def\n  RBTS.lookup2_def\n  RBTS.insert2_def\n  RBTS.fold_def\n  RBTS.entries_def"], "translations": [["", "lemmas [code] =\n  \\<comment> \\<open>def\\<close>\n  RBTS.lookup_def\n  RBTS.insert_def\n  RBTS.map_entry_def\n  RBTS.modify_def_def\n  RBTS.keys_def\n  RBTS.lookup2_def\n  RBTS.insert2_def\n  RBTS.fold_def\n  RBTS.entries_def"], ["", "syntax \"_rbt_lookup\" :: \"_ \\<Rightarrow> _\" (\"lookup\")"], ["", "translations \"lookup\" \\<rightleftharpoons> \"CONST RBTS.lookup\""], ["", "syntax \"_rbt_insert\" :: \"_ \\<Rightarrow> _\" (\"insert\")"], ["", "translations \"insert\" \\<rightleftharpoons> \"CONST RBTS.insert\""], ["", "syntax \"_rbt_map_entry\" :: \"_ \\<Rightarrow> _\" (\"map'_entry\")"], ["", "translations \"map_entry\" \\<rightleftharpoons> \"CONST RBTS.map_entry\""], ["", "syntax \"_rbt_modify_def\" :: \"_ \\<Rightarrow> _\" (\"modify'_def\")"], ["", "translations \"modify_def\" \\<rightleftharpoons> \"CONST RBTS.modify_def\""], ["", "syntax \"_rbt_keys\" :: \"_ \\<Rightarrow> _\" (\"keys\")"], ["", "translations \"keys\" \\<rightleftharpoons> \"CONST RBTS.keys\""], ["", "syntax \"_rbt_lookup2\" :: \"_ \\<Rightarrow> _\" (\"lookup2\")"], ["", "translations \"lookup2\" \\<rightleftharpoons> \"CONST RBTS.lookup2\""], ["", "syntax \"_rbt_insert2\" :: \"_ \\<Rightarrow> _\" (\"insert2\")"], ["", "translations \"insert2\" \\<rightleftharpoons> \"CONST RBTS.insert2\""], ["", "syntax \"_rbt_fold\" :: \"_ \\<Rightarrow> _\" (\"fold\")"], ["", "translations \"fold\" \\<rightleftharpoons> \"CONST RBTS.fold\""], ["", "syntax \"_rbt_entries\" :: \"_ \\<Rightarrow> _\" (\"entries\")"], ["", "translations \"entries\" \\<rightleftharpoons> \"CONST RBTS.entries\""], ["", "function (sequential) class_unflat_aux where\n(* (* FIXME replace with this simplified form *)\n   \"class_unflat_aux rbt rbt_inv rbt_cycle r =\n   (case lookup rbt_cycle r of (None \\<comment> \\<open>cycle detection\\<close>) \\<Rightarrow>\n      ToyClass\n        r\n        (case lookup rbt r of Some l \\<Rightarrow> l)\n        (L.map\n          (class_unflat_aux rbt rbt_inv (insert r () rbt_cycle))\n          (case lookup rbt_inv r of None \\<Rightarrow> [] | Some l \\<Rightarrow> l)))\"\n*)\n   \"class_unflat_aux rbt rbt_inv rbt_cycle r =\n   (case lookup rbt_inv r of\n  None \\<Rightarrow>\n(case lookup rbt_cycle r of (None \\<comment> \\<open>cycle detection\\<close>) \\<Rightarrow>\n      ToyClass\n        r\n        (case lookup rbt r of Some l \\<Rightarrow> l)\n        ( ( [])))\n| Some l \\<Rightarrow>\n(case lookup rbt_cycle r of (None \\<comment> \\<open>cycle detection\\<close>) \\<Rightarrow>\n      ToyClass\n        r\n        (case lookup rbt r of Some l \\<Rightarrow> l)\n        (L.map\n          (class_unflat_aux rbt rbt_inv (insert r () rbt_cycle))\n          ( l))))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>rbt rbt_inv rbt_cycle r.\n           x = (rbt, rbt_inv, rbt_cycle, r) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>rbt rbt_inv rbt_cycle r rbta rbt_inva rbt_cyclea ra.\n       (rbt, rbt_inv, rbt_cycle, r) =\n       (rbta, rbt_inva, rbt_cyclea, ra) \\<Longrightarrow>\n       (case lookup rbt_inv r of\n        None \\<Rightarrow>\n          case lookup rbt_cycle r of\n          None \\<Rightarrow>\n            ToyClass r (case lookup rbt r of Some l \\<Rightarrow> l) []\n        | Some l \\<Rightarrow>\n            case lookup rbt_cycle r of\n            None \\<Rightarrow>\n              ToyClass r (case lookup rbt r of Some l \\<Rightarrow> l)\n               (L.map\n                 (\\<lambda>x3.\n                     class_unflat_aux_sumC\n                      (rbt, rbt_inv, insert r () rbt_cycle, x3))\n                 l)) =\n       (case lookup rbt_inva ra of\n        None \\<Rightarrow>\n          case lookup rbt_cyclea ra of\n          None \\<Rightarrow>\n            ToyClass ra (case lookup rbta ra of Some l \\<Rightarrow> l) []\n        | Some l \\<Rightarrow>\n            case lookup rbt_cyclea ra of\n            None \\<Rightarrow>\n              ToyClass ra (case lookup rbta ra of Some l \\<Rightarrow> l)\n               (L.map\n                 (\\<lambda>x3.\n                     class_unflat_aux_sumC\n                      (rbta, rbt_inva, insert ra () rbt_cyclea, x3))\n                 l))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have arith_diff: \"\\<And>a1 a2 (b :: Nat.nat). a1 = a2 \\<Longrightarrow> a1 > b \\<Longrightarrow> a1 - (b + 1) < a2 - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2 b.\n       \\<lbrakk>a1 = a2; b < a1\\<rbrakk>\n       \\<Longrightarrow> a1 - (b + 1) < a2 - b", "by arith"], ["proof (state)\nthis:\n  \\<lbrakk>?a1.0 = ?a2.0; ?b < ?a1.0\\<rbrakk>\n  \\<Longrightarrow> ?a1.0 - (?b + 1) < ?a2.0 - ?b\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have arith_less: \"\\<And>(a:: Nat.nat) b c. b \\<ge> max (a + 1) c \\<Longrightarrow> a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c. max (a + 1) c \\<le> b \\<Longrightarrow> a < b", "by arith"], ["proof (state)\nthis:\n  max (?a + 1) ?c \\<le> ?b \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_length: \"\\<And>rbt_cycle r v. RBT.lookup rbt_cycle r = None \\<Longrightarrow>\n     length (RBT.keys (RBT.insert r v rbt_cycle)) = length (RBT.keys rbt_cycle) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle r v.\n       RBT.lookup rbt_cycle r = None \\<Longrightarrow>\n       length (RBT.keys (RBT.insert r v rbt_cycle)) =\n       length (RBT.keys rbt_cycle) + 1", "apply(subst (1 2) distinct_card[symmetric], (rule distinct_keys)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle r v.\n       RBT.lookup rbt_cycle r = None \\<Longrightarrow>\n       card (set (RBT.keys (RBT.insert r v rbt_cycle))) =\n       card (set (RBT.keys rbt_cycle)) + 1", "apply(simp only: lookup_keys[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle r.\n       RBT.lookup rbt_cycle r = None \\<Longrightarrow>\n       card (insert r (dom (RBT.lookup rbt_cycle))) =\n       Suc (card (dom (RBT.lookup rbt_cycle)))", "by (metis card_insert_if domIff finite_dom_lookup)"], ["proof (state)\nthis:\n  RBT.lookup ?rbt_cycle ?r = None \\<Longrightarrow>\n  length (RBT.keys (RBT.insert ?r ?v ?rbt_cycle)) =\n  length (RBT.keys ?rbt_cycle) + 1\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_fold_union'': \"\\<And>ab a x k. dom (\\<lambda>b. if b = ab then Some a else k b) = {ab} \\<union> dom k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ab a x k.\n       dom (\\<lambda>b. if b = ab then Some a else k b) =\n       {ab} \\<union> dom k", "by(auto)"], ["proof (state)\nthis:\n  dom (\\<lambda>b. if b = ?ab1 then Some ?a1 else ?k1 b) =\n  {?ab1} \\<union> dom ?k1\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_fold_union': \"\\<And>l rbt_inv a.\n       dom (RBT.lookup (List.fold (\\<lambda>(k, _). RBT.insert k a) l rbt_inv)) =\n       dom (map_of l) \\<union> dom (RBT.lookup rbt_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l rbt_inv a.\n       dom (RBT.lookup\n             (fold (\\<lambda>(k, uu_). RBT.insert k a) l rbt_inv)) =\n       dom (map_of l) \\<union> dom (RBT.lookup rbt_inv)", "apply(rule_tac P = \"\\<lambda>rbt_inv . dom (RBT.lookup (List.fold (\\<lambda>(k, _). RBT.insert k a) l rbt_inv)) =\n       dom (map_of l) \\<union> dom (RBT.lookup rbt_inv)\" in allE, simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a.\n       \\<forall>x.\n          dom (RBT.lookup (fold (\\<lambda>(k, uu_). RBT.insert k a) l x)) =\n          dom (map_of l) \\<union> dom (RBT.lookup x)", "apply(induct_tac l, simp, rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a aa list x.\n       \\<forall>x.\n          dom (RBT.lookup\n                (fold\n                  (\\<lambda>b.\n                      case b of (k, uu_) \\<Rightarrow> RBT.insert k a)\n                  list x)) =\n          dom (map_of list) \\<union> dom (RBT.lookup x) \\<Longrightarrow>\n       dom (RBT.lookup\n             (fold\n               (\\<lambda>b. case b of (k, uu_) \\<Rightarrow> RBT.insert k a)\n               (aa # list) x)) =\n       dom (map_of (aa # list)) \\<union> dom (RBT.lookup x)", "apply(case_tac aa, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa list x ab b.\n       \\<lbrakk>\\<forall>x.\n                   dom (RBT.lookup\n                         (fold (\\<lambda>(k, uu_). RBT.insert k a) list\n                           x)) =\n                   dom (map_of list) \\<union> dom (RBT.lookup x);\n        aa = (ab, b)\\<rbrakk>\n       \\<Longrightarrow> dom (map_of list) \\<union>\n                         dom (\\<lambda>b.\n                                 if b = ab then Some a\n                                 else RBT.lookup x b) =\n                         dom (\\<lambda>a.\n                                 if a = ab then Some b\n                                 else map_of list a) \\<union>\n                         dom (RBT.lookup x)", "apply(simp add: rbt_fold_union'')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom (RBT.lookup\n        (fold (\\<lambda>(k, uu_). RBT.insert k ?a2) ?l2 ?rbt_inv2)) =\n  dom (map_of ?l2) \\<union> dom (RBT.lookup ?rbt_inv2)\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_fold_union: \"\\<And>rbt_cycle rbt_inv a.\n   dom (RBT.lookup (RBT.fold (\\<lambda>k _. RBT.insert k a) rbt_cycle rbt_inv)) =\n   dom (RBT.lookup rbt_cycle) \\<union> dom (RBT.lookup rbt_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv a.\n       dom (RBT.lookup\n             (RBT.fold (\\<lambda>k _. RBT.insert k a) rbt_cycle rbt_inv)) =\n       dom (RBT.lookup rbt_cycle) \\<union> dom (RBT.lookup rbt_inv)", "apply(simp add: fold_fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv a.\n       dom (RBT.lookup\n             (fold (\\<lambda>(k, uu_). RBT.insert k a)\n               (RBT.entries rbt_cycle) rbt_inv)) =\n       dom (RBT.lookup rbt_cycle) \\<union> dom (RBT.lookup rbt_inv)", "apply(subst (2) map_of_entries[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv a.\n       dom (RBT.lookup\n             (fold (\\<lambda>(k, uu_). RBT.insert k a)\n               (RBT.entries rbt_cycle) rbt_inv)) =\n       dom (map_of (RBT.entries rbt_cycle)) \\<union>\n       dom (RBT.lookup rbt_inv)", "apply(rule rbt_fold_union')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom (RBT.lookup\n        (RBT.fold (\\<lambda>k _. RBT.insert k ?a3) ?rbt_cycle3 ?rbt_inv3)) =\n  dom (RBT.lookup ?rbt_cycle3) \\<union> dom (RBT.lookup ?rbt_inv3)\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_fold_eq: \"\\<And>rbt_cycle rbt_inv a b.\n   dom (RBT.lookup (RBT.fold (\\<lambda>k _. RBT.insert k a) rbt_cycle rbt_inv)) =\n   dom (RBT.lookup (RBT.fold (\\<lambda>k _. RBT.insert k b) rbt_inv rbt_cycle))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv a b.\n       dom (RBT.lookup\n             (RBT.fold (\\<lambda>k _. RBT.insert k a) rbt_cycle rbt_inv)) =\n       dom (RBT.lookup\n             (RBT.fold (\\<lambda>k _. RBT.insert k b) rbt_inv rbt_cycle))", "by(simp add: rbt_fold_union Un_commute)"], ["proof (state)\nthis:\n  dom (RBT.lookup\n        (RBT.fold (\\<lambda>k _. RBT.insert k ?a4) ?rbt_cycle4 ?rbt_inv4)) =\n  dom (RBT.lookup\n        (RBT.fold (\\<lambda>k _. RBT.insert k ?b4) ?rbt_inv4 ?rbt_cycle4))\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "let ?len = \"\\<lambda>x. length (RBT.keys x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "let ?len_merge = \"\\<lambda>rbt_cycle rbt_inv. ?len (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle rbt_inv)\""], ["proof (state)\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_fold_large: \"\\<And>rbt_cycle rbt_inv. ?len_merge rbt_cycle rbt_inv \\<ge> max (?len rbt_cycle) (?len rbt_inv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv.\n       max (length (RBT.keys rbt_cycle)) (length (RBT.keys rbt_inv))\n       \\<le> length\n              (RBT.keys\n                (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                  rbt_inv))", "apply(subst (1 2 3) distinct_card[symmetric], (rule distinct_keys)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv.\n       max (card (set (RBT.keys rbt_cycle))) (card (set (RBT.keys rbt_inv)))\n       \\<le> card\n              (set (RBT.keys\n                     (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                       rbt_inv)))", "apply(simp only: lookup_keys[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv.\n       card (dom (RBT.lookup rbt_cycle))\n       \\<le> card\n              (dom (RBT.lookup\n                     (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                       rbt_inv))) \\<and>\n       card (dom (RBT.lookup rbt_inv))\n       \\<le> card\n              (dom (RBT.lookup\n                     (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                       rbt_inv)))", "apply(subst (1 2) card_mono, simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rbt_cycle rbt_inv.\n       dom (RBT.lookup rbt_inv)\n       \\<subseteq> dom (RBT.lookup\n                         (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                           rbt_inv))\n 2. \\<And>rbt_cycle rbt_inv.\n       dom (RBT.lookup rbt_cycle)\n       \\<subseteq> dom (RBT.lookup\n                         (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                           rbt_inv))", "apply(simp add: rbt_fold_union)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  max (length (RBT.keys ?rbt_cycle7)) (length (RBT.keys ?rbt_inv7))\n  \\<le> length\n         (RBT.keys\n           (RBT.fold (\\<lambda>k _. RBT.insert k []) ?rbt_cycle7 ?rbt_inv7))\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "have rbt_fold_eq: \"\\<And>rbt_cycle rbt_inv r a.\n     RBT.lookup rbt_inv r = Some a \\<Longrightarrow>\n     ?len_merge (RBT.insert r () rbt_cycle) rbt_inv = ?len_merge rbt_cycle rbt_inv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv r a.\n       RBT.lookup rbt_inv r = Some a \\<Longrightarrow>\n       length\n        (RBT.keys\n          (RBT.fold (\\<lambda>k _. RBT.insert k [])\n            (RBT.insert r () rbt_cycle) rbt_inv)) =\n       length\n        (RBT.keys\n          (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle rbt_inv))", "apply(subst (1 2) distinct_card[symmetric], (rule distinct_keys)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv r a.\n       RBT.lookup rbt_inv r = Some a \\<Longrightarrow>\n       card\n        (set (RBT.keys\n               (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                 (RBT.insert r () rbt_cycle) rbt_inv))) =\n       card\n        (set (RBT.keys\n               (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                 rbt_inv)))", "apply(simp only: lookup_keys[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv r a.\n       RBT.lookup rbt_inv r = Some a \\<Longrightarrow>\n       card\n        (dom (RBT.lookup\n               (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                 (RBT.insert r () rbt_cycle) rbt_inv))) =\n       card\n        (dom (RBT.lookup\n               (RBT.fold (\\<lambda>k _. RBT.insert k []) rbt_cycle\n                 rbt_inv)))", "apply(simp add: rbt_fold_union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_cycle rbt_inv r a.\n       RBT.lookup rbt_inv r = Some a \\<Longrightarrow>\n       card\n        (insert r\n          (dom (RBT.lookup rbt_cycle) \\<union> dom (RBT.lookup rbt_inv))) =\n       card (dom (RBT.lookup rbt_cycle) \\<union> dom (RBT.lookup rbt_inv))", "by (metis Un_insert_right insert_dom)"], ["proof (state)\nthis:\n  RBT.lookup ?rbt_inv8 ?r8 = Some ?a8 \\<Longrightarrow>\n  length\n   (RBT.keys\n     (RBT.fold (\\<lambda>k _. RBT.insert k [])\n       (RBT.insert ?r8 () ?rbt_cycle8) ?rbt_inv8)) =\n  length\n   (RBT.keys\n     (RBT.fold (\\<lambda>k _. RBT.insert k []) ?rbt_cycle8 ?rbt_inv8))\n\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. All class_unflat_aux_dom", "apply(relation \"measure (\\<lambda>(_, rbt_inv, rbt_cycle, _).\n                           ?len_merge rbt_cycle rbt_inv - ?len rbt_cycle)\"\n       , simp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>lookup rbt_inv r = Some x2;\n        lookup rbt_cycle r = None\\<rbrakk>\n       \\<Longrightarrow> length\n                          (RBT.keys\n                            (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                              (insert r () rbt_cycle) rbt_inv)) -\n                         length (RBT.keys (insert r () rbt_cycle))\n                         < length\n                            (RBT.keys\n                              (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                rbt_cycle rbt_inv)) -\n                           length (RBT.keys rbt_cycle)", "unfolding RBTS.lookup_def RBTS.insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> length\n                          (RBT.keys\n                            (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                              (RBT.insert (String.to_list r) () rbt_cycle)\n                              rbt_inv)) -\n                         length\n                          (RBT.keys\n                            (RBT.insert (String.to_list r) () rbt_cycle))\n                         < length\n                            (RBT.keys\n                              (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                rbt_cycle rbt_inv)) -\n                           length (RBT.keys rbt_cycle)", "apply(subst rbt_length, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> length\n                          (RBT.keys\n                            (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                              (RBT.insert (String.to_list r) () rbt_cycle)\n                              rbt_inv)) -\n                         (length (RBT.keys rbt_cycle) + 1)\n                         < length\n                            (RBT.keys\n                              (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                rbt_cycle rbt_inv)) -\n                           length (RBT.keys rbt_cycle)", "apply(rule arith_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> length\n                          (RBT.keys\n                            (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                              (RBT.insert (String.to_list r) () rbt_cycle)\n                              rbt_inv)) =\n                         length\n                          (RBT.keys\n                            (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                              rbt_cycle rbt_inv))\n 2. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> length (RBT.keys rbt_cycle)\n                         < length\n                            (RBT.keys\n                              (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                (RBT.insert (String.to_list r) () rbt_cycle)\n                                rbt_inv))", "apply(rule rbt_fold_eq, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> length (RBT.keys rbt_cycle)\n                         < length\n                            (RBT.keys\n                              (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                (RBT.insert (String.to_list r) () rbt_cycle)\n                                rbt_inv))", "apply(rule arith_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> max (length (RBT.keys rbt_cycle) + 1)\n                          (?c16 rbt_inv rbt_cycle r x2)\n                         \\<le> length\n                                (RBT.keys\n                                  (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                    (RBT.insert (String.to_list r) ()\nrbt_cycle)\n                                    rbt_inv))", "apply(subst rbt_length[symmetric], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>rbt_inv rbt_cycle r x2.\n       \\<lbrakk>RBT.lookup rbt_inv (String.to_list r) = Some x2;\n        RBT.lookup rbt_cycle (String.to_list r) = None\\<rbrakk>\n       \\<Longrightarrow> max (length\n                               (RBT.keys\n                                 (RBT.insert (String.to_list r)\n                                   (?v18 rbt_inv rbt_cycle r x2)\n                                   rbt_cycle)))\n                          (?c19 rbt_inv rbt_inv rbt_cycle rbt_cycle r r x2\n                            (?x2.18 rbt_inv rbt_cycle r x2))\n                         \\<le> length\n                                (RBT.keys\n                                  (RBT.fold (\\<lambda>k _. RBT.insert k [])\n                                    (RBT.insert (String.to_list r) ()\nrbt_cycle)\n                                    rbt_inv))", "apply(rule rbt_fold_large)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  All class_unflat_aux_dom\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"ty_obj_to_string = (\\<lambda>ToyTyObj (ToyTyCore_pre s) _ \\<Rightarrow> s)\""], ["", "definition \"cl_name_to_string = ty_obj_to_string o ClassRaw_name\""], ["", "definition \"class_unflat = (\\<lambda> (l_class, l_ass).\n  let l =\n    let const_toyany' = ToyTyCore_pre const_toyany\n      ; rbt = \\<comment> \\<open>fold classes:\\<close>\n              \\<comment> \\<open>set \\<open>ToyAny\\<close> as default inherited class (for all classes linking to zero inherited classes)\\<close>\n              insert\n                const_toyany\n                (toy_class_raw.make (ToyTyObj const_toyany' []) [] [] False)\n                (List.fold\n                  (\\<lambda> cflat \\<Rightarrow>\n                    insert (cl_name_to_string cflat) (cflat \\<lparr> ClassRaw_name := case ClassRaw_name cflat of ToyTyObj n [] \\<Rightarrow> ToyTyObj n [[const_toyany']] | x \\<Rightarrow> x \\<rparr>))\n                  l_class\n                  RBT.empty) in\n    \\<comment> \\<open>fold associations:\\<close>\n    \\<comment> \\<open>add remaining 'object' attributes\\<close>\n    L.map snd (entries (List.fold (\\<lambda> (ass_oid, ass) \\<Rightarrow>\n      let l_rel = ToyAss_relation' ass in\n      fold_max\n        (let n_rel = natural_of_nat (List.length l_rel) in\n         (\\<lambda> (cpt_to, (name_to, category_to)).\n           case TyRole category_to of\n             Some role_to \\<Rightarrow>\n               List.fold (\\<lambda> (cpt_from, (name_from, mult_from)).\n                 let name_from = ty_obj_to_string name_from in\n                 map_entry name_from (\\<lambda>cflat. cflat \\<lparr> ClassRaw_own := (role_to,\n                   ToyTy_class (toy_ty_class_ext const_oid ass_oid n_rel\n                     (toy_ty_class_node_ext cpt_from mult_from name_from ())\n                     (toy_ty_class_node_ext cpt_to category_to (ty_obj_to_string name_to) ())\n                     ())) # ClassRaw_own cflat \\<rparr>))\n           | _ \\<Rightarrow> \\<lambda>_. id))\n        l_rel) (L.mapi Pair l_ass) rbt)) in\n  class_unflat_aux\n    (List.fold (\\<lambda> cflat. insert (cl_name_to_string cflat) (L.map (map_prod id remove_binding) (ClassRaw_own cflat))) l RBT.empty)\n    (List.fold\n      (\\<lambda> cflat.\n        case ClassRaw_name cflat of\n          ToyTyObj n [] \\<Rightarrow> id\n        | ToyTyObj n l \\<Rightarrow> case rev ([n] # l) of x0 # xs \\<Rightarrow> \\<lambda>rbt. \n            snd (List.fold\n                  (\\<lambda> x (x0, rbt).\n                    (x, List.fold (\\<lambda> ToyTyCore_pre k \\<Rightarrow> modify_def [] k (\\<lambda>l. L.flatten [L.map (\\<lambda>ToyTyCore_pre s \\<Rightarrow> s) x, l]))\n                                  x0\n                                  rbt))\n                  xs\n                  (x0, rbt)))\n      l\n      RBT.empty)\n    RBT.empty\n    const_toyany)\""], ["", "definition \"apply_optim_ass_arity ty_obj v =\n  (if TyObj_ass_arity ty_obj \\<le> 2 then None\n   else Some v)\""], ["", "definition \"is_higher_order = (\\<lambda> ToyTy_collection _ _ \\<Rightarrow> True | ToyTy_pair _ _ \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "definition \"parse_ty_raw = (\\<lambda> ToyTy_raw s \\<Rightarrow> if s = \\<open>int\\<close> then ToyTy_base_integer else ToyTy_raw s\n                            | x \\<Rightarrow> x)\""], ["", "definition \"is_sequence = list_ex (\\<lambda> Sequence \\<Rightarrow> True | _ \\<Rightarrow> False) o TyCollect\""], ["", "fun str_of_ty where \"str_of_ty e =\n (\\<lambda> ToyTy_base_void \\<Rightarrow> \\<open>Void\\<close>\n  | ToyTy_base_boolean \\<Rightarrow> \\<open>Boolean\\<close>\n  | ToyTy_base_integer \\<Rightarrow> \\<open>Integer\\<close>\n  | ToyTy_base_unlimitednatural \\<Rightarrow> \\<open>UnlimitedNatural\\<close>\n  | ToyTy_base_real \\<Rightarrow> \\<open>Real\\<close>\n  | ToyTy_base_string \\<Rightarrow> \\<open>String\\<close>\n  | ToyTy_object (ToyTyObj (ToyTyCore_pre s) _) \\<Rightarrow> s\n  \\<^cancel>\\<open>| ToyTy_object (ToyTyObj (ToyTyCore ty_obj) _)\\<close>\n  | ToyTy_collection t toy_ty \\<Rightarrow> (if is_sequence t then\n                                    S.flatten [\\<open>Sequence(\\<close>, str_of_ty toy_ty,\\<open>)\\<close>]\n                                  else\n                                    S.flatten [\\<open>Set(\\<close>, str_of_ty toy_ty,\\<open>)\\<close>])\n  | ToyTy_pair toy_ty1 toy_ty2 \\<Rightarrow> S.flatten [\\<open>Pair(\\<close>, str_of_ty toy_ty1, \\<open>,\\<close>, str_of_ty toy_ty2,\\<open>)\\<close>]\n  | ToyTy_binding (_, toy_ty) \\<Rightarrow> str_of_ty toy_ty\n  | ToyTy_class_syn s \\<Rightarrow> s\n  | ToyTy_enum s \\<Rightarrow> s\n  | ToyTy_raw s \\<Rightarrow> S.flatten [\\<open>\\<acute>\\<close>, s, \\<open>\\<acute>\\<close>]) e\""], ["", "definition \"ty_void = str_of_ty ToyTy_base_void\""], ["", "definition \"ty_boolean = str_of_ty ToyTy_base_boolean\""], ["", "definition \"ty_integer = str_of_ty ToyTy_base_integer\""], ["", "definition \"ty_unlimitednatural = str_of_ty ToyTy_base_unlimitednatural\""], ["", "definition \"ty_real = str_of_ty ToyTy_base_real\""], ["", "definition \"ty_string = str_of_ty ToyTy_base_string\""], ["", "definition \"pref_ty_enum s = \\<open>ty_enum\\<close> @@ String.isub s\""], ["", "definition \"pref_ty_syn s = \\<open>ty_syn\\<close> @@ String.isub s\""], ["", "definition \"pref_constr_enum s = \\<open>constr\\<close> @@ String.isub s\""], ["", "fun str_hol_of_ty_all where \"str_hol_of_ty_all f b e =\n (\\<lambda> ToyTy_base_void \\<Rightarrow> b \\<open>unit\\<close>\n  | ToyTy_base_boolean \\<Rightarrow> b \\<open>bool\\<close>\n  | ToyTy_base_integer \\<Rightarrow> b \\<open>int\\<close>\n  | ToyTy_base_unlimitednatural \\<Rightarrow> b \\<open>nat\\<close>\n  | ToyTy_base_real \\<Rightarrow> b \\<open>real\\<close>\n  | ToyTy_base_string \\<Rightarrow> b \\<open>string\\<close>\n  | ToyTy_object (ToyTyObj (ToyTyCore_pre s) _) \\<Rightarrow> b const_oid\n  | ToyTy_object (ToyTyObj (ToyTyCore ty_obj) _) \\<Rightarrow> f (b var_ty_list) [b (TyObj_name ty_obj)]\n  | ToyTy_collection _ ty \\<Rightarrow> f (b var_ty_list) [str_hol_of_ty_all f b ty]\n  | ToyTy_pair ty1 ty2 \\<Rightarrow> f (b var_ty_prod) [str_hol_of_ty_all f b ty1, str_hol_of_ty_all f b ty2]\n  | ToyTy_binding (_, t) \\<Rightarrow> str_hol_of_ty_all f b t\n  | ToyTy_class_syn s \\<Rightarrow> b (pref_ty_syn s)\n  | ToyTy_enum s \\<Rightarrow> b (pref_ty_enum s)\n  | ToyTy_raw s \\<Rightarrow> b s) e\""], ["", "fun get_class_hierarchy_strict_aux where\n   \"get_class_hierarchy_strict_aux dataty l_res =\n   (List.fold\n     (\\<lambda> ToyClass name l_attr dataty \\<Rightarrow> \\<lambda> l_res.\n       get_class_hierarchy_strict_aux dataty (ToyClass name l_attr dataty # l_res))\n     dataty\n     l_res)\""], ["", "definition \"get_class_hierarchy_strict d = get_class_hierarchy_strict_aux d []\""], ["", "fun get_class_hierarchy'_aux where\n   \"get_class_hierarchy'_aux l_res (ToyClass name l_attr dataty) =\n   (let l_res = ToyClass name l_attr dataty # l_res in\n    case dataty of [] \\<Rightarrow> rev l_res\n                 | dataty \\<Rightarrow> List.fold (\\<lambda>x acc. get_class_hierarchy'_aux acc x) dataty l_res)\""], ["", "definition \"get_class_hierarchy' = get_class_hierarchy'_aux []\""], ["", "definition \"get_class_hierarchy e = L.map (\\<lambda> ToyClass n l _ \\<Rightarrow> (n, l)) (get_class_hierarchy' e)\""], ["", "definition \"var_in_pre_state = \\<open>in_pre_state\\<close>\""], ["", "definition \"var_in_post_state = \\<open>in_post_state\\<close>\""], ["", "definition \"var_at_when_hol_post = \\<open>\\<close>\""], ["", "definition \"var_at_when_hol_pre = \\<open>at_pre\\<close>\""], ["", "definition \"var_at_when_toy_post = \\<open>\\<close>\""], ["", "definition \"var_at_when_toy_pre = \\<open>@pre\\<close>\""], ["", "datatype 'a tmp_sub = Tsub 'a"], ["", "record 'a inheritance =\n  Inh :: 'a\n  Inh_sib :: \"('a \\<times> 'a list \\<comment> \\<open>flat version of the 1st component\\<close>) list\" \\<comment> \\<open>sibling\\<close>\n  Inh_sib_unflat :: \"'a list\" \\<comment> \\<open>sibling\\<close>"], ["", "datatype 'a tmp_inh = Tinh 'a"], ["", "datatype 'a tmp_univ = Tuniv 'a"], ["", "definition \"of_inh = (\\<lambda>Tinh l \\<Rightarrow> l)\""], ["", "definition \"of_linh = L.map Inh\""], ["", "definition \"of_sub = (\\<lambda>Tsub l \\<Rightarrow> l)\""], ["", "definition \"of_univ = (\\<lambda>Tuniv l \\<Rightarrow> l)\""], ["", "definition \"map_inh f = (\\<lambda>Tinh l \\<Rightarrow> Tinh (f l))\""], ["", "fun fold_class_gen_aux where\n   \"fold_class_gen_aux l_inh f accu (ToyClass name l_attr dataty) =\n (let accu = f (\\<lambda>s. s @@ String.isub name)\n               name\n               l_attr\n               (Tinh l_inh)\n               (Tsub (get_class_hierarchy_strict dataty)) \\<comment> \\<open>order: bfs or dfs (modulo reversing)\\<close>\n               dataty\n               accu in\n  case dataty of [] \\<Rightarrow> accu\n               | _ \\<Rightarrow>\n    fst (List.fold\n       (\\<lambda> node (accu, l_inh_l, l_inh_r).\n         ( fold_class_gen_aux\n             ( \\<lparr> Inh = ToyClass name l_attr dataty\n               , Inh_sib = L.flatten (L.map (L.map (\\<lambda>l. (l, get_class_hierarchy' l))) [l_inh_l, tl l_inh_r])\n               , Inh_sib_unflat = L.flatten [l_inh_l, tl l_inh_r] \\<rparr>\n             # l_inh)\n             f accu node\n         , hd l_inh_r # l_inh_l\n         , tl l_inh_r))\n      dataty\n      (accu, [], dataty)))\""], ["", "definition \"fold_class_gen f accu expr =\n (let (l_res, accu) =\n    fold_class_gen_aux\n      []\n      (\\<lambda> isub_name name l_attr l_inh l_subtree next_dataty (l_res, accu).\n        let (r, accu) = f isub_name name l_attr l_inh l_subtree next_dataty accu in\n        (r # l_res, accu))\n      ([], accu)\n      expr in\n  (L.flatten l_res, accu))\""], ["", "definition \"map_class_gen f = fst o fold_class_gen\n  (\\<lambda> isub_name name l_attr l_inh l_subtree last_d. \\<lambda> () \\<Rightarrow>\n    (f isub_name name l_attr l_inh l_subtree last_d, ())) ()\""], ["", "definition \"add_hierarchy'''' f x = (\\<lambda>isub_name name l_attr l_inh l_subtree _. f isub_name name (Tuniv (get_class_hierarchy x)) l_attr (map_inh (L.map (\\<lambda> ToyClass _ l _ \\<Rightarrow> l) o of_linh) l_inh) l_subtree)\""], ["", "definition \"map_class f = map_class_gen (\\<lambda>isub_name name l_attr l_inh l_subtree next_dataty. [f isub_name name l_attr l_inh (Tsub (L.map (\\<lambda> ToyClass n _ _ \\<Rightarrow> n) (of_sub l_subtree))) next_dataty])\""], ["", "definition \"fold_class f = fold_class_gen (\\<lambda>isub_name name l_attr l_inh l_subtree next_dataty accu. let (x, accu) = f isub_name name l_attr (map_inh of_linh l_inh) (Tsub (L.map (\\<lambda> ToyClass n _ _ \\<Rightarrow> n) (of_sub l_subtree))) next_dataty accu in ([x], accu))\""], ["", "definition \"map_class_gen_h'''' f x = map_class_gen (add_hierarchy'''' (\\<lambda>isub_name name l_inherited l_attr l_inh l_subtree. f isub_name name l_inherited l_attr l_inh (Tsub (L.map (\\<lambda> ToyClass n _ _ \\<Rightarrow> n) (of_sub l_subtree)))) x) x\""], ["", "definition \"class_arity = RBT.keys o (\\<lambda>l. List.fold (\\<lambda>x. RBT.insert x ()) l RBT.empty) o\n  L.flatten o L.flatten o map_class (\\<lambda> _ _ l_attr _ _ _.\n    L.map (\\<lambda> (_, ToyTy_object (ToyTyObj (ToyTyCore ty_obj) _)) \\<Rightarrow> [TyObj_ass_arity ty_obj]\n              | _ \\<Rightarrow> []) l_attr)\""], ["", "definition \"map_class_inh l_inherited = L.map (\\<lambda> ToyClass _ l _ \\<Rightarrow> l) (of_inh (map_inh of_linh l_inherited))\""], ["", "end"]]}