{"file_name": "/home/qj213/afp-2021-10-22/thys/NormByEval/NBE.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/NormByEval", "problem_names": ["lemma pure_Lam[simp]: \"pure(\\<Lambda> t) = pure t\"", "lemma depth_At_foldl:\n \"depth_At(s \\<bullet>\\<bullet> ts) = depth_At s + size ts\"", "lemma foldl_At_eq_lemma: \"size ts = size ts' \\<Longrightarrow>\n s \\<bullet>\\<bullet> ts = s' \\<bullet>\\<bullet> ts' \\<longleftrightarrow> s = s' \\<and> ts = ts'\"", "lemma foldl_At_eq_length:\n \"s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow> length ts = length ts'\"", "lemma foldl_At_eq[simp]: \"s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<longleftrightarrow> ts = ts'\"", "lemma term_eq_foldl_At[simp]:\n  \"term v = t \\<bullet>\\<bullet> ts \\<longleftrightarrow> t = term v \\<and> ts = []\"", "lemma At_eq_foldl_At[simp]:\n  \"r \\<bullet> s = t \\<bullet>\\<bullet> ts \\<longleftrightarrow>\n  (if ts=[] then t = r \\<bullet> s else s = last ts \\<and> r = t \\<bullet>\\<bullet> butlast ts)\"", "lemma foldl_At_eq_At[simp]:\n  \"t \\<bullet>\\<bullet> ts = r \\<bullet> s \\<longleftrightarrow>\n  (if ts=[] then t = r \\<bullet> s else s = last ts \\<and> r = t \\<bullet>\\<bullet> butlast ts)\"", "lemma Lam_eq_foldl_At[simp]:\n  \"\\<Lambda> s = t \\<bullet>\\<bullet> ts \\<longleftrightarrow> t = \\<Lambda> s \\<and> ts = []\"", "lemma foldl_At_eq_Lam[simp]:\n  \"t \\<bullet>\\<bullet> ts = \\<Lambda> s \\<longleftrightarrow> t = \\<Lambda> s \\<and> ts = []\"", "lemma [simp]: \"s \\<bullet> t \\<noteq> s\"", "lemma head_tm_foldl_At[simp]: \"head_tm(s \\<bullet>\\<bullet> ts) = head_tm s\"", "lemma args_tm_foldl_At[simp]: \"args_tm(s \\<bullet>\\<bullet> ts) = args_tm s @ ts\"", "lemma tm_eq_iff:\n  \"atomic_tm(head_tm s) \\<Longrightarrow> atomic_tm(head_tm t)\n   \\<Longrightarrow> s = t \\<longleftrightarrow> head_tm s = head_tm t \\<and> args_tm s = args_tm t\"", "lemma atomic_tm_head_tm: \"atomic_tm(head_tm t)\"", "lemma head_tm_idem: \"head_tm(head_tm t) = head_tm t\"", "lemma args_tm_head_tm: \"args_tm(head_tm t) = []\"", "lemma eta_head_args: \"t = head_tm t \\<bullet>\\<bullet> args_tm t\"", "lemma tm_vector_cases:\n  \"(\\<exists>n ts. t = V n \\<bullet>\\<bullet> ts) \\<or>\n   (\\<exists>nm ts. t = C nm \\<bullet>\\<bullet> ts) \\<or>\n   (\\<exists>t' ts. t = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n   (\\<exists>v ts. t = term v \\<bullet>\\<bullet> ts)\"", "lemma fv_head_C[simp]: \"fv (t \\<bullet>\\<bullet> ts) = fv t \\<union> (\\<Union>t\\<in>set ts. fv t)\"", "lemmas ml_induct = lift_ml.induct[of \"\\<lambda>i v. P v\"] for P", "lemma apply_cons[simp]:\n  \"(t##\\<sigma>) i = (if i=0 then t::tm else lift 0 (\\<sigma>(i - 1)))\"", "lemma apply_cons_ML[simp]:\n  \"(v##\\<sigma>) i = (if i=0 then v::ml else lift\\<^sub>M\\<^sub>L 0 (\\<sigma>(i - 1)))\"", "lemma lift_foldl_At[simp]:\n  \"lift k (s \\<bullet>\\<bullet> ts) = (lift k s) \\<bullet>\\<bullet> (map (lift k) ts)\"", "lemma lift_lift_ml: fixes v :: ml shows\n  \"i < k+1 \\<Longrightarrow> lift (Suc k) (lift i v) = lift i (lift k v)\"", "lemma lift_lift_tm: fixes t :: tm shows\n    \"i < k+1 \\<Longrightarrow> lift (Suc k) (lift i t) = lift i (lift k t)\"", "lemma lift_lift_ML:\n  \"i < k+1 \\<Longrightarrow> lift\\<^sub>M\\<^sub>L (Suc k) (lift\\<^sub>M\\<^sub>L i v) = lift\\<^sub>M\\<^sub>L i (lift\\<^sub>M\\<^sub>L k v)\"", "lemma lift_lift_ML_comm:\n  \"lift j (lift\\<^sub>M\\<^sub>L i v) = lift\\<^sub>M\\<^sub>L i (lift j v)\"", "lemma V_ML_cons_ML_subst_decr[simp]:\n  \"V\\<^sub>M\\<^sub>L 0 ## subst_decr_ML k v = subst_decr_ML (Suc k) (lift\\<^sub>M\\<^sub>L 0 v)\"", "lemma shift_subst_decr[simp]:\n \"V 0 ## subst_decr k t = subst_decr (Suc k) (lift 0 t)\"", "lemma lift_comp_subst_decr[simp]:\n  \"lift 0 o subst_decr_ML k v = subst_decr_ML k (lift 0 v)\"", "lemma subst_ML_ext: \"\\<forall>i. \\<sigma> i = \\<sigma>' i \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = subst\\<^sub>M\\<^sub>L \\<sigma>' v\"", "lemma subst_ext: \"\\<forall>i. \\<sigma> i = \\<sigma>' i \\<Longrightarrow> subst \\<sigma> v = subst \\<sigma>' v\"", "lemma lift_Pure_tms[simp]: \"pure t \\<Longrightarrow> pure(lift k t)\"", "lemma cons_ML_V_ML[simp]: \"(V\\<^sub>M\\<^sub>L 0 ## V\\<^sub>M\\<^sub>L) = V\\<^sub>M\\<^sub>L\"", "lemma cons_V[simp]: \"(V 0 ## V) = V\"", "lemma lift_o_shift: \"lift k \\<circ> (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) = (V\\<^sub>M\\<^sub>L 0 ## (lift k \\<circ> \\<sigma>))\"", "lemma lift_subst_ML:\n \"lift k (subst\\<^sub>M\\<^sub>L \\<sigma> v) = subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k v)\"", "lemma lift_ML_subst_ML:\n \"lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n  subst\\<^sub>M\\<^sub>L (\\<lambda>i. if i<k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i) else if i=k then V\\<^sub>M\\<^sub>L k else lift\\<^sub>M\\<^sub>L k (\\<sigma>(i - 1))) (lift\\<^sub>M\\<^sub>L k v)\"\n  (is \"_ = subst\\<^sub>M\\<^sub>L (?insrt k \\<sigma>) (lift\\<^sub>M\\<^sub>L k v)\")", "lemma lift_ML_id[simp]: \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k v = v\"", "lemma subst_ML_id:\n  \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v\"", "lemma subst_ML_coincidence:\n  \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> \\<forall>i<k. \\<sigma> i = \\<sigma>' i \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = subst\\<^sub>M\\<^sub>L \\<sigma>' v\"", "lemma subst_ML_comp:\n  \"subst\\<^sub>M\\<^sub>L \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) = subst\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma>  \\<circ> \\<sigma>') v\"", "lemma subst_ML_comp2:\n  \"\\<forall>i. \\<sigma>'' i = subst\\<^sub>M\\<^sub>L \\<sigma> (\\<sigma>' i) \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) = subst\\<^sub>M\\<^sub>L \\<sigma>'' v\"", "lemma closed_tm_ML_foldl_At:\n  \"closed\\<^sub>M\\<^sub>L k (t \\<bullet>\\<bullet> ts) \\<longleftrightarrow> closed\\<^sub>M\\<^sub>L k t \\<and> (\\<forall>t \\<in> set ts. closed\\<^sub>M\\<^sub>L k t)\"", "lemma closed_ML_lift[simp]:\n  fixes v :: ml shows \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> closed\\<^sub>M\\<^sub>L k (lift m v)\"", "lemma closed_ML_Suc: \"closed\\<^sub>M\\<^sub>L n v \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc n) (lift\\<^sub>M\\<^sub>L k v)\"", "lemma closed_ML_subst_ML:\n  \"\\<forall>i. closed\\<^sub>M\\<^sub>L k (\\<sigma> i) \\<Longrightarrow> closed\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v)\"", "lemma closed_ML_subst_ML2:\n  \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> \\<forall>i<k. closed\\<^sub>M\\<^sub>L l (\\<sigma> i) \\<Longrightarrow> closed\\<^sub>M\\<^sub>L l (subst\\<^sub>M\\<^sub>L \\<sigma> v)\"", "lemma subst_foldl[simp]:\n \"subst \\<sigma> (s \\<bullet>\\<bullet> ts) = (subst \\<sigma> s) \\<bullet>\\<bullet> (map (subst \\<sigma>) ts)\"", "lemma subst_V: \"pure t \\<Longrightarrow> subst V t = t\"", "lemma lift_subst_aux:\n  \"pure t \\<Longrightarrow> \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i) \\<Longrightarrow>\n   \\<forall>i\\<ge>k. \\<sigma>'(Suc i) = lift k (\\<sigma> i) \\<Longrightarrow> \n  \\<sigma>' k = V k \\<Longrightarrow> lift k (subst \\<sigma> t) = subst \\<sigma>' (lift k t)\"", "lemma subst_comp:\n  \"pure t \\<Longrightarrow> \\<forall>i. pure(\\<sigma>' i) \\<Longrightarrow>\n   \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i)) \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) = subst \\<sigma>'' t\"", "lemma pattern_Lam[simp]: \"\\<not> pattern(\\<Lambda> t)\"", "lemma pattern_At'D12: \"pattern r \\<Longrightarrow> r = (s \\<bullet> t) \\<Longrightarrow> pattern s \\<and> pattern t\"", "lemma pattern_AtD12: \"pattern(s \\<bullet> t) \\<Longrightarrow> pattern s \\<and> pattern t\"", "lemma pattern_At_vecD: \"pattern(s \\<bullet>\\<bullet> ts) \\<Longrightarrow> patterns ts\"", "lemma pattern_At_decomp: \"pattern(s \\<bullet> t) \\<Longrightarrow> \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss\"", "lemma Reds_tm_list_refl[simp]: fixes ts :: \"tm list\" shows \"ts \\<rightarrow>* ts\"", "lemma Red_tm_append: \"rs \\<rightarrow>* rs' \\<Longrightarrow> ts \\<rightarrow>* ts' \\<Longrightarrow> rs @ ts \\<rightarrow>* rs' @ ts'\"", "lemma Red_tm_rev: \"ts \\<rightarrow>* ts' \\<Longrightarrow> rev ts \\<rightarrow>* rev ts'\"", "lemma red_Lam[simp]: \"t \\<rightarrow>* t' \\<Longrightarrow> \\<Lambda> t \\<rightarrow>* \\<Lambda> t'\"", "lemma red_At1[simp]: \"t \\<rightarrow>* t' \\<Longrightarrow> t \\<bullet> s \\<rightarrow>* t' \\<bullet> s\"", "lemma red_At2[simp]: \"t \\<rightarrow>* t' \\<Longrightarrow> s \\<bullet> t \\<rightarrow>* s \\<bullet> t'\"", "lemma Reds_tm_list_foldl_At:\n \"ts \\<rightarrow>* ts' \\<Longrightarrow> s \\<rightarrow>* s' \\<Longrightarrow> s \\<bullet>\\<bullet> ts \\<rightarrow>* s' \\<bullet>\\<bullet> ts'\"", "lemma termination_no_match_ML:\n  \"i < length ps \\<Longrightarrow> rev ps ! i = C\\<^sub>U nm vs\n   \\<Longrightarrow> sum_list (map size vs) < sum_list (map size ps)\"", "lemma sum_list_size'[simp]:\n \"v \\<in> set vs \\<Longrightarrow> size' v < Suc(sum_list (map size' vs))\"", "lemma size'_lift_ML: \"size' (lift\\<^sub>M\\<^sub>L k v) = size' v\"", "lemma size'_subst_ML[simp]:\n \"\\<forall>i j. size'(\\<sigma> i) = 1 \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v\"", "lemma size'_lift[simp]: \"size' (lift i v) = size' v\"", "lemma kernel_pure: assumes \"pure t\" shows \"t! = t\"", "lemma kernel_foldl_At[simp]: \"(s \\<bullet>\\<bullet> ts)! = (s!) \\<bullet>\\<bullet> (map kernelt ts)\"", "lemma kernelt_o_term[simp]: \"(kernelt \\<circ> term) = kernel\"", "lemma pure_foldl:\n \"pure t \\<Longrightarrow> \\<forall>t\\<in>set ts. pure t \\<Longrightarrow> \n (!!s t. pure s \\<Longrightarrow> pure t \\<Longrightarrow> pure(f s t)) \\<Longrightarrow>\n pure(foldl f t ts)\"", "lemma pure_kernel: fixes v :: ml shows \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure(v!)\"", "lemma kernel_lift_tm: fixes v :: ml shows\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> (lift i v)! = lift i (v!)\"", "lemma lift_ML_subst_ml:\n  \"lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) = subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v)\"", "lemma subst_ml_subst_ML:\n  \"subst_ml \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) = subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma> o \\<sigma>') (subst_ml \\<sigma> v)\"", "lemma lift_is_subst_ml: \"lift k v = subst_ml (\\<lambda>n. if n<k then n else n+1) v\"", "lemma subst_ml_comp:  \"subst_ml \\<sigma> (subst_ml \\<sigma>' v) = subst_ml (\\<sigma> o \\<sigma>') v\"", "lemma subst_kernel:\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>  subst (\\<lambda>n. V(\\<sigma> n)) (v!) = (subst_ml \\<sigma> v)!\"", "lemma if_cong0: \"If x y z = If x y z\"", "lemma kernel_subst1:\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0) u \\<Longrightarrow>\n   kernel(u[v/0]) = (kernel((lift 0 u)[V\\<^sub>U 0 []/0]))[v!/0]\"", "lemma size_args_less_size_tm[simp]: \"s \\<in> set (args_tm t) \\<Longrightarrow> size s < size t\"", "lemma comp_pat_V[simp]: \"comp_pat(V X) = V\\<^sub>M\\<^sub>L X\"", "lemma comp_pat_C[simp]:\n  \"comp_pat(C nm \\<bullet>\\<bullet> ts) = C\\<^sub>U nm (map comp_pat (rev ts))\"", "lemma comp_pat_C_Nil[simp]: \"comp_pat(C nm) = C\\<^sub>U nm []\"", "lemma fv_ML_comp_open: \"pure t \\<Longrightarrow> fv\\<^sub>M\\<^sub>L(comp_open t) = fv t\"", "lemma fv_ML_comp_pat: \"pattern t \\<Longrightarrow> fv\\<^sub>M\\<^sub>L(comp_pat t) = fv t\"", "lemma fv_compR_aux:\n  \"(nm,ts,t') : R \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L (comp_open t')\n   \\<Longrightarrow> \\<exists>t\\<in>set ts. x \\<in> fv\\<^sub>M\\<^sub>L(comp_pat t)\"", "lemma fv_compR:\n  \"(nm,vs,v) : compR \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L v \\<Longrightarrow> \\<exists>u\\<in>set vs. x \\<in> fv\\<^sub>M\\<^sub>L u\"", "lemma lift_compile:\n  \"pure t \\<Longrightarrow> \\<forall>\\<sigma> k. lift k (compile t \\<sigma>) = compile t (lift k \\<circ> \\<sigma>)\"", "lemma subst_ML_compile:\n  \"pure t \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>' (compile t \\<sigma>) = compile t (subst\\<^sub>M\\<^sub>L \\<sigma>' o \\<sigma>)\"", "theorem kernel_compile:\n  \"pure t \\<Longrightarrow> \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow> (compile t \\<sigma>)! = t\"", "lemma kernel_subst_ML_pat:\n  \"pure t \\<Longrightarrow> pattern t \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   (subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t))! = subst (kernel \\<circ> \\<sigma>) t\"", "lemma kernel_subst_ML:\n  \"pure t \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   (subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t))! = subst (kernel \\<circ> \\<sigma>) t\"", "lemma kernel_subst_ML_pat_map:\n  \"\\<forall>t \\<in> set ts. pure t \\<Longrightarrow> patterns ts \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   map kernel (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ts)) =\n   map (subst (kernel \\<circ> \\<sigma>)) ts\"", "lemma compR_Red_tm: \"(nm, vs, v) : compR \\<Longrightarrow> \\<forall> i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n  \\<Longrightarrow> C nm \\<bullet>\\<bullet> (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs))! \\<rightarrow>* (subst\\<^sub>M\\<^sub>L \\<sigma> v)!\"", "lemma eq_Red_tm_trans: \"s = t \\<Longrightarrow> t \\<rightarrow> t' \\<Longrightarrow> s \\<rightarrow> t'\"", "theorem fixes v :: ml shows Red_ml_sound:\n  \"v \\<Rightarrow> v' \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> v! \\<rightarrow>* v'! \\<and> closed\\<^sub>M\\<^sub>L 0 v'\" and\n  \"vs \\<Rightarrow> vs' \\<Longrightarrow> \\<forall>v\\<in>set vs. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n   vs! \\<rightarrow>* vs'! \\<and> (\\<forall>v'\\<in>set vs'. closed\\<^sub>M\\<^sub>L 0 v')\"", "theorem Red_term_sound:\n  \"t \\<Rightarrow> t' \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow> kernelt t \\<rightarrow>* kernelt t'  \\<and> closed\\<^sub>M\\<^sub>L 0 t'\"", "lemma  closed_ML_compile:\n  \"pure t \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>)\"", "theorem nbe_correct: fixes t :: tm\nassumes \"pure t\" and \"term (comp_fixed t) \\<Rightarrow>* t'\" and \"pure t'\" shows \"t \\<rightarrow>* t'\"", "lemma size_tm_foldl_At: \"size_tm(t \\<bullet>\\<bullet> ts) = size_tm t + size_list size_tm ts\"", "lemma termination_no_match:\n  \"i < length ss \\<Longrightarrow> ss ! i = C nm \\<bullet>\\<bullet> ts\n   \\<Longrightarrow> sum_list (map size_tm ts) < sum_list (map size_tm ss)\"", "lemma no_match: \"no_match ps ts \\<Longrightarrow> \\<not>(\\<exists>\\<sigma>. map (subst \\<sigma>) ps = ts)\"", "lemma no_match_take: \"no_match ps ts \\<Longrightarrow> no_match ps (take (size ps) ts)\"", "lemma dterm_pure[simp]: \"pure t \\<Longrightarrow> dterm t = t\"", "lemma map_dterm_pure[simp]: \"\\<forall>t\\<in>set ts. pure t \\<Longrightarrow> map dterm ts = ts\"", "lemma map_dterm_term[simp]: \"map dterm (map term vs) = map dterm\\<^sub>M\\<^sub>L vs\"", "lemma dterm_foldl_At[simp]: \"dterm(t \\<bullet>\\<bullet> ts) = dterm t \\<bullet>\\<bullet> map dterm ts\"", "lemma no_match_coincide:\n  \"no_match\\<^sub>M\\<^sub>L ps vs \\<Longrightarrow>\n  no_match (map dterm\\<^sub>M\\<^sub>L (rev ps)) (map dterm\\<^sub>M\\<^sub>L (rev vs))\"", "lemma dterm_ML_comp_patD:\n  \"pattern t \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (comp_pat t) = C nm \\<bullet>\\<bullet> rs \\<Longrightarrow> \\<exists>ts. t = C nm \\<bullet>\\<bullet> ts\"", "lemma no_match_R_coincide_aux[rule_format]: \"patterns ts \\<Longrightarrow>\n  no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs \\<longrightarrow> no_match ts rs\"", "lemma no_match_R_coincide:\n  \"no_match_compR nm (rev vs) \\<Longrightarrow> no_match_R nm (map dterm\\<^sub>M\\<^sub>L vs)\"", "lemma C_normal_term[simp]: \"C_normal(term v) = C_normal\\<^sub>M\\<^sub>L v\"", "lemma [simp]: \"C_normal(\\<Lambda> t) = C_normal t\"", "lemma [simp]: \"C_normal(V x)\"", "lemma [simp]: \"dterm (dterm\\<^sub>M\\<^sub>L v) = dterm\\<^sub>M\\<^sub>L v\"", "lemma \"u\\<Rightarrow>(v::ml) \\<Longrightarrow> True\" and\n  Red_ml_list_length: \"vs \\<Rightarrow> vs' \\<Longrightarrow> length vs = length vs'\"", "lemma \"(v::ml) \\<Rightarrow> v' \\<Longrightarrow> True\" and\n  Red_ml_list_nth: \"(vs::ml list) \\<Rightarrow> vs'\n  \\<Longrightarrow> \\<exists>v' k. k<size vs \\<and> vs!k \\<Rightarrow> v' \\<and> vs' = vs[k := v']\"", "lemma Red_ml_list_pres_no_match:\n  \"no_match\\<^sub>M\\<^sub>L ps vs \\<Longrightarrow> vs \\<Rightarrow> vs' \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps vs'\"", "lemma no_match_ML_subst_ML[rule_format]:\n  \"\\<forall>v\\<in>set vs. \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v. C_normal\\<^sub>M\\<^sub>L (\\<sigma> x) \\<Longrightarrow>\n   no_match\\<^sub>M\\<^sub>L ps vs \\<longrightarrow> no_match\\<^sub>M\\<^sub>L ps (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)\"", "lemma lift_is_CUD:\n  \"lift\\<^sub>M\\<^sub>L k v = C\\<^sub>U nm vs' \\<Longrightarrow> \\<exists>vs. v = C\\<^sub>U nm vs \\<and> vs' = map (lift\\<^sub>M\\<^sub>L k) vs\"", "lemma no_match_ML_lift_ML:\n  \"no_match\\<^sub>M\\<^sub>L ps (map (lift\\<^sub>M\\<^sub>L k) vs) = no_match\\<^sub>M\\<^sub>L ps vs\"", "lemma C_normal_ML_lift_ML: \"C_normal\\<^sub>M\\<^sub>L(lift\\<^sub>M\\<^sub>L k v) = C_normal\\<^sub>M\\<^sub>L v\"", "lemma no_match_compR_Cons:\n  \"no_match_compR nm vs \\<Longrightarrow> no_match_compR nm (v # vs)\"", "lemma C_normal_ML_comp_open: \"pure t \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L(comp_open t)\"", "lemma C_normal_compR_rhs: \"(nm, vs, v) \\<in> compR \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v\"", "lemma C_normal_ML_subst_ML:\n  \"C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow> (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v. C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\"", "lemma C_normal_ML_subst_ML_iff: \"C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n  C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<longleftrightarrow> (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v. C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\"", "lemma C_normal_ML_inv: \"v \\<Rightarrow> v' \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v'\" and\n      \"vs \\<Rightarrow> vs' \\<Longrightarrow> \\<forall>v\\<in>set vs. C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> \\<forall>v'\\<in>set vs'. C_normal\\<^sub>M\\<^sub>L v'\"", "lemma Red_term_hnf_induct[consumes 1]:\nassumes \"(t::tm) \\<Rightarrow> t'\"\n  \"\\<And>nm vs ts. P ((term (C\\<^sub>U nm vs)) \\<bullet>\\<bullet> ts) ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts)\"\n  \"\\<And>x vs ts. P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts) ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts)\"\n  \"\\<And>vf vs n ts.\n    P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n     ((\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))) \\<bullet>\\<bullet> ts)\"\n  \"\\<And>t t' ts. \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk> \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts) (\\<Lambda> t' \\<bullet>\\<bullet> ts)\"\n  \"\\<And>v v' ts. v \\<Rightarrow> v' \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts)\"\n  \"\\<And>x i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (V x  \\<bullet>\\<bullet> ts) (V x \\<bullet>\\<bullet> ts[i:=t'])\"\n  \"\\<And>nm i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (C nm  \\<bullet>\\<bullet> ts) (C nm \\<bullet>\\<bullet> ts[i:=t'])\"\n  \"\\<And>t i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts) (\\<Lambda> t \\<bullet>\\<bullet> ts[i:=t'])\"\n  \"\\<And>v i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (term v  \\<bullet>\\<bullet> ts) (term v \\<bullet>\\<bullet> (ts[i:=t']))\"\nshows \"P t t'\"", "lemma [simp]: \"C_normal(term v \\<bullet>\\<bullet> ts) \\<longleftrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<and> ts = []\"", "lemma [simp]: \"C_normal(\\<Lambda> t \\<bullet>\\<bullet> ts) \\<longleftrightarrow> C_normal t \\<and> ts = []\"", "lemma [simp]: \"C_normal(C nm \\<bullet>\\<bullet> ts) \\<longleftrightarrow>\n  (\\<forall>t\\<in>set ts. C_normal t) \\<and> no_match_R nm (map dterm ts)\"", "lemma [simp]: \"C_normal(V x \\<bullet>\\<bullet> ts) \\<longleftrightarrow> (\\<forall>t \\<in> set ts. C_normal t)\"", "lemma no_match_ML_lift:\n  \"no_match\\<^sub>M\\<^sub>L ps vs \\<longrightarrow> no_match\\<^sub>M\\<^sub>L ps (map (lift k) vs)\"", "lemma no_match_compR_lift:\n  \"no_match_compR nm vs \\<Longrightarrow> no_match_compR nm (map (lift k) vs)\"", "lemma [simp]: \"C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L(lift k v)\"", "lemma Red_term_pres_no_match:\n  \"\\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t'; no_match ps dts; dts = (map dterm ts)\\<rbrakk>\n   \\<Longrightarrow> no_match ps (map dterm (ts[i := t']))\"", "lemma Red_term_pres_no_match_it:\n  \"\\<lbrakk> \\<forall> i < length ts. (ts ! i, ts' ! i) : Red_term ^^ (ns!i);\n    size ts' = size ts; size ns = size ts;\n    no_match ps (map dterm ts)\\<rbrakk>\n   \\<Longrightarrow> no_match ps (map dterm ts')\"", "lemma Red_term_pres_no_match_star:\nassumes \"\\<forall>i < length(ts::tm list). ts ! i \\<Rightarrow>* ts' ! i\" and \"size ts' = size ts\"\n    and \"no_match ps (map dterm ts)\"\nshows \"no_match ps (map dterm ts')\"", "lemma not_pure_term[simp]: \"\\<not> pure(term v)\"", "lemma [simp]: \"C\\<^sub>U_args(C nm \\<bullet>\\<bullet> ts) = ts\"", "lemma redts_term_cong: \"v \\<Rightarrow>* v' \\<Longrightarrow> term v \\<Rightarrow>* term v'\"", "lemma C_Red_term_ML:\n  \"v \\<Rightarrow> v' \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\n   \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' = C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args(term v')) \\<and>\n      C\\<^sub>U_args(term v) [\\<Rightarrow>*] C\\<^sub>U_args(term v') \\<and>\n      ts = map dterm (C\\<^sub>U_args(term v))\" and\n  \"(vs:: ml list) \\<Rightarrow> vs' \\<Longrightarrow> i < length vs \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i\"", "lemma C_normal_subterm:\n  \"C_normal t \\<Longrightarrow> dterm t = C nm \\<bullet>\\<bullet> ts \\<Longrightarrow> s \\<in> set(C\\<^sub>U_args t) \\<Longrightarrow> C_normal s\"", "lemma C_normal_subterms:\n  \"C_normal t \\<Longrightarrow> dterm t = C nm \\<bullet>\\<bullet> ts \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args t)\"", "lemma C_redt: \"t \\<Rightarrow> t' \\<Longrightarrow> C_normal t \\<Longrightarrow> \n    C_normal t' \\<and> (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n    (\\<exists>ts'. ts' = map dterm (C\\<^sub>U_args t') \\<and> dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n     C\\<^sub>U_args t [\\<Rightarrow>*] C\\<^sub>U_args t'))\"", "lemma C_redts: \"t \\<Rightarrow>* t' \\<Longrightarrow> C_normal t \\<Longrightarrow>\n    C_normal t' \\<and> (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n    (\\<exists>ts'. dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and> C\\<^sub>U_args t [\\<Rightarrow>*] C\\<^sub>U_args t' \\<and>\n     ts' = map dterm (C\\<^sub>U_args t')))\"", "lemma no_match_preserved:\n  \"\\<forall>t\\<in>set ts. C_normal t \\<Longrightarrow> ts [\\<Rightarrow>*] ts'\n   \\<Longrightarrow> no_match ps os \\<Longrightarrow> os = map dterm ts \\<Longrightarrow> no_match ps (map dterm ts')\"", "lemma Lam_Red_term_itE:\n  \"(\\<Lambda> t, t') : Red_term^^i \\<Longrightarrow> \\<exists>t''. t' = \\<Lambda> t'' \\<and> (t,t'') : Red_term^^i\"", "lemma Red_term_it: \"(V x \\<bullet>\\<bullet> rs, r) : Red_term^^i\n  \\<Longrightarrow> \\<exists>ts is. r = V x \\<bullet>\\<bullet> ts \\<and> size ts = size rs & size is = size rs \\<and>\n       (\\<forall>j<size ts. (rs!j, ts!j) : Red_term^^(is!j) \\<and> is!j <= i)\"", "lemma C_Red_term_it:  \"(C nm \\<bullet>\\<bullet> rs, r) : Red_term^^i\n  \\<Longrightarrow> \\<exists>ts is. r = C nm \\<bullet>\\<bullet> ts \\<and> size ts = size rs \\<and> size is = size rs \\<and>\n        (\\<forall>j<size ts. (rs!j, ts!j) \\<in> Red_term^^(is!j) \\<and> is!j \\<le> i)\"", "lemma pure_At[simp]: \"pure(s \\<bullet> t) \\<longleftrightarrow> pure s \\<and> pure t\"", "lemma pure_foldl_At[simp]: \"pure(s \\<bullet>\\<bullet> ts) \\<longleftrightarrow> pure s \\<and> (\\<forall>t\\<in>set ts. pure t)\"", "lemma nbe_C_normal_ML:\n  assumes \"term v \\<Rightarrow>* t'\" \"C_normal\\<^sub>M\\<^sub>L v\" \"pure t'\" shows \"normal t'\"", "lemma C_normal_ML_compile:\n  \"pure t \\<Longrightarrow> \\<forall>i. C_normal\\<^sub>M\\<^sub>L(\\<sigma> i) \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (compile t \\<sigma>)\"", "lemma size_foldl_At: \"size(C nm \\<bullet>\\<bullet> ts) = size ts + sum_list(map size ts)\"", "lemma termination_linpats:\n  \"i < length ts \\<Longrightarrow> ts!i = C nm \\<bullet>\\<bullet> ts'\n   \\<Longrightarrow> length ts' + sum_list (map size ts') < length ts + sum_list (map size ts)\"", "lemma eq_lists_iff_eq_nth:\n  \"size xs = size ys \\<Longrightarrow> (xs=ys) = (\\<forall>i<size xs. xs!i = ys!i)\"", "lemma pattern_subst_ML_coincidence:\n \"pattern t \\<Longrightarrow> \\<forall>i\\<in>fv t. \\<sigma> i = \\<sigma>' i\n  \\<Longrightarrow> subst_ML \\<sigma> (comp_pat t) = subst_ML \\<sigma>' (comp_pat t)\"", "lemma linpats_pattern: \"linpats ts \\<Longrightarrow> patterns ts\"", "lemma no_match_ML_swap_rev:\n  \"length ps = length vs \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps (rev vs) \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev ps) vs\"", "lemma no_match_ML_aux:\n  \"\\<forall>v \\<in> set cvs. C\\<^sub>Us v \\<Longrightarrow> linpats ps \\<Longrightarrow> size ps = size cvs \\<Longrightarrow>\n  \\<forall>\\<sigma>. map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ps) \\<noteq> cvs \\<Longrightarrow>\n  no_match\\<^sub>M\\<^sub>L (map comp_pat ps) cvs\""], "translations": [["", "lemma pure_Lam[simp]: \"pure(\\<Lambda> t) = pure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (\\<Lambda> t) = pure t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pure (\\<Lambda> t) \\<Longrightarrow> pure t\n 2. pure t \\<Longrightarrow> pure (\\<Lambda> t)", "assume \"pure(\\<Lambda> t)\""], ["proof (state)\nthis:\n  pure (\\<Lambda> t)\n\ngoal (2 subgoals):\n 1. pure (\\<Lambda> t) \\<Longrightarrow> pure t\n 2. pure t \\<Longrightarrow> pure (\\<Lambda> t)", "thus \"pure t\""], ["proof (prove)\nusing this:\n  pure (\\<Lambda> t)\n\ngoal (1 subgoal):\n 1. pure t", "proof cases"], ["proof (state)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> pure t", "qed auto"], ["proof (state)\nthis:\n  pure t\n\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> pure (\\<Lambda> t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> pure (\\<Lambda> t)", "assume \"pure t\""], ["proof (state)\nthis:\n  pure t\n\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> pure (\\<Lambda> t)", "thus \"pure(\\<Lambda> t)\""], ["proof (prove)\nusing this:\n  pure t\n\ngoal (1 subgoal):\n 1. pure (\\<Lambda> t)", "by(rule Lam)"], ["proof (state)\nthis:\n  pure (\\<Lambda> t)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Closed terms w.r.t.\\ ML variables:\\<close>"], ["", "fun closed_ML :: \"nat \\<Rightarrow> ml \\<Rightarrow> bool\" (\"closed\\<^sub>M\\<^sub>L\") where\n\"closed\\<^sub>M\\<^sub>L i (C\\<^sub>M\\<^sub>L nm) = True\" |\n\"closed\\<^sub>M\\<^sub>L i (V\\<^sub>M\\<^sub>L X) = (X<i)\"  |\n\"closed\\<^sub>M\\<^sub>L i (A\\<^sub>M\\<^sub>L v vs) = (closed\\<^sub>M\\<^sub>L i v \\<and> (\\<forall>v \\<in> set vs. closed\\<^sub>M\\<^sub>L i v))\" |\n\"closed\\<^sub>M\\<^sub>L i (Lam\\<^sub>M\\<^sub>L v) = closed\\<^sub>M\\<^sub>L (i+1) v\" |\n\"closed\\<^sub>M\\<^sub>L i (C\\<^sub>U nm vs) = (\\<forall>v \\<in> set vs. closed\\<^sub>M\\<^sub>L i v)\" |\n\"closed\\<^sub>M\\<^sub>L i (V\\<^sub>U nm vs) = (\\<forall>v \\<in> set vs. closed\\<^sub>M\\<^sub>L i v)\" |\n\"closed\\<^sub>M\\<^sub>L i (Clo f vs n) = (closed\\<^sub>M\\<^sub>L i f \\<and> (\\<forall>v \\<in> set vs. closed\\<^sub>M\\<^sub>L i v))\" |\n\"closed\\<^sub>M\\<^sub>L i (apply v w) = (closed\\<^sub>M\\<^sub>L i v \\<and> closed\\<^sub>M\\<^sub>L i w)\""], ["", "fun closed_tm_ML :: \"nat \\<Rightarrow> tm \\<Rightarrow> bool\" (\"closed\\<^sub>M\\<^sub>L\") where\n\"closed_tm_ML i (r\\<bullet>s) = (closed_tm_ML i r \\<and> closed_tm_ML i s)\" |\n\"closed_tm_ML i (\\<Lambda> t) = (closed_tm_ML i t)\" |\n\"closed_tm_ML i (term v) = closed_ML i v\" |\n\"closed_tm_ML i v = True\""], ["", "text\\<open>Free variables:\\<close>"], ["", "fun fv_ML :: \"ml \\<Rightarrow> ml_vname set\" (\"fv\\<^sub>M\\<^sub>L\") where\n\"fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) = {}\" |\n\"fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) = {X}\"  |\n\"fv\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs) = fv\\<^sub>M\\<^sub>L v \\<union> (\\<Union>v \\<in> set vs. fv\\<^sub>M\\<^sub>L v)\" |\n\"fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v) = {X. Suc X : fv\\<^sub>M\\<^sub>L v}\" |\n\"fv\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs) = (\\<Union>v \\<in> set vs. fv\\<^sub>M\\<^sub>L v)\" |\n\"fv\\<^sub>M\\<^sub>L (V\\<^sub>U nm vs) = (\\<Union>v \\<in> set vs. fv\\<^sub>M\\<^sub>L v)\" |\n\"fv\\<^sub>M\\<^sub>L (Clo f vs n) = fv\\<^sub>M\\<^sub>L f \\<union> (\\<Union>v \\<in> set vs. fv\\<^sub>M\\<^sub>L v)\" |\n\"fv\\<^sub>M\\<^sub>L (apply v w) = fv\\<^sub>M\\<^sub>L v \\<union> fv\\<^sub>M\\<^sub>L w\""], ["", "primrec fv :: \"tm \\<Rightarrow> vname set\" where\n\"fv (C nm) = {}\" |\n\"fv (V X) = {X}\"  |\n\"fv (s \\<bullet> t) = fv s \\<union> fv t\" |\n\"fv (\\<Lambda> t) = {X. Suc X : fv t}\""], ["", "subsection \"Iterated Term Application\""], ["", "abbreviation foldl_At (infix \"\\<bullet>\\<bullet>\" 90) where\n\"t \\<bullet>\\<bullet> ts \\<equiv> foldl (\\<bullet>) t ts\""], ["", "text\\<open>Auxiliary measure function:\\<close>"], ["", "primrec depth_At :: \"tm \\<Rightarrow> nat\"\nwhere\n  \"depth_At(C nm) = 0\"\n| \"depth_At(V x) = 0\"\n| \"depth_At(s \\<bullet> t) = depth_At s + 1\"\n| \"depth_At(\\<Lambda> t) = 0\"\n| \"depth_At(term v) = 0\""], ["", "lemma depth_At_foldl:\n \"depth_At(s \\<bullet>\\<bullet> ts) = depth_At s + size ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. depth_At (s \\<bullet>\\<bullet> ts) = depth_At s + length ts", "by (induct ts arbitrary: s) simp_all"], ["", "lemma foldl_At_eq_lemma: \"size ts = size ts' \\<Longrightarrow>\n s \\<bullet>\\<bullet> ts = s' \\<bullet>\\<bullet> ts' \\<longleftrightarrow> s = s' \\<and> ts = ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts = length ts' \\<Longrightarrow>\n    (s \\<bullet>\\<bullet> ts = s' \\<bullet>\\<bullet> ts') =\n    (s = s' \\<and> ts = ts')", "by (induct arbitrary: s s' rule:list_induct2) simp_all"], ["", "lemma foldl_At_eq_length:\n \"s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow> length ts = length ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    length ts = length ts'", "apply(subgoal_tac \"depth_At(s \\<bullet>\\<bullet> ts) = depth_At(s \\<bullet>\\<bullet> ts')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts';\n     depth_At (s \\<bullet>\\<bullet> ts) =\n     depth_At (s \\<bullet>\\<bullet> ts')\\<rbrakk>\n    \\<Longrightarrow> length ts = length ts'\n 2. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    depth_At (s \\<bullet>\\<bullet> ts) = depth_At (s \\<bullet>\\<bullet> ts')", "apply(erule thin_rl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. depth_At (s \\<bullet>\\<bullet> ts) =\n    depth_At (s \\<bullet>\\<bullet> ts') \\<Longrightarrow>\n    length ts = length ts'\n 2. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    depth_At (s \\<bullet>\\<bullet> ts) = depth_At (s \\<bullet>\\<bullet> ts')", "apply (simp add:depth_At_foldl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    depth_At (s \\<bullet>\\<bullet> ts) = depth_At (s \\<bullet>\\<bullet> ts')", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldl_At_eq[simp]: \"s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<longleftrightarrow> ts = ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts') = (ts = ts')", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    ts = ts'\n 2. ts = ts' \\<Longrightarrow>\n    s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. ts = ts' \\<Longrightarrow>\n    s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts'\n 2. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    ts = ts'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<bullet>\\<bullet> ts = s \\<bullet>\\<bullet> ts' \\<Longrightarrow>\n    ts = ts'", "apply(blast dest:foldl_At_eq_lemma foldl_At_eq_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma term_eq_foldl_At[simp]:\n  \"term v = t \\<bullet>\\<bullet> ts \\<longleftrightarrow> t = term v \\<and> ts = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (term v = t \\<bullet>\\<bullet> ts) = (t = term v \\<and> ts = [])", "by (induct ts arbitrary:t) auto"], ["", "lemma At_eq_foldl_At[simp]:\n  \"r \\<bullet> s = t \\<bullet>\\<bullet> ts \\<longleftrightarrow>\n  (if ts=[] then t = r \\<bullet> s else s = last ts \\<and> r = t \\<bullet>\\<bullet> butlast ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n    (if ts = [] then t = r \\<bullet> s\n     else s = last ts \\<and> r = t \\<bullet>\\<bullet> butlast ts)", "apply (induct ts arbitrary:t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t.\n       (r \\<bullet> s = t \\<bullet>\\<bullet> []) =\n       (if [] = [] then t = r \\<bullet> s\n        else s = last [] \\<and> r = t \\<bullet>\\<bullet> butlast [])\n 2. \\<And>a ts t.\n       (\\<And>t.\n           (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n           (if ts = [] then t = r \\<bullet> s\n            else s = last ts \\<and>\n                 r = t \\<bullet>\\<bullet> butlast ts)) \\<Longrightarrow>\n       (r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)) =\n       (if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ts t.\n       (\\<And>t.\n           (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n           (if ts = [] then t = r \\<bullet> s\n            else s = last ts \\<and>\n                 r = t \\<bullet>\\<bullet> butlast ts)) \\<Longrightarrow>\n       (r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)) =\n       (if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)\\<rbrakk>\n       \\<Longrightarrow> if a # ts = [] then t = r \\<bullet> s\n                         else s = last (a # ts) \\<and>\n                              r = t \\<bullet>\\<bullet> butlast (a # ts)\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then ta = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> (ts = [] \\<longrightarrow>\n                          s = a \\<and> r = t) \\<and>\n                         (ts \\<noteq> [] \\<longrightarrow>\n                          s = last ts \\<and>\n                          r = t \\<bullet> a \\<bullet>\\<bullet> butlast ts)\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then ta = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts = [] \\<longrightarrow> s = a \\<and> r = t\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then ta = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts \\<noteq> [] \\<longrightarrow>\n                         s = last ts \\<and>\n                         r = t \\<bullet> a \\<bullet>\\<bullet> butlast ts\n 3. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then ta = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts \\<noteq> [] \\<longrightarrow>\n                         s = last ts \\<and>\n                         r = t \\<bullet> a \\<bullet>\\<bullet> butlast ts\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (s = last ts \\<and>\n                    r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts;\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> s = last ts \\<and>\n                         r = t \\<bullet> a \\<bullet>\\<bullet> butlast ts\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "apply(subgoal_tac \"\\<exists>ts' t'. ts = ts' @ [t']\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (s = last ts \\<and>\n                    r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts; ts \\<noteq> [];\n        \\<exists>ts' t'. ts = ts' @ [t']\\<rbrakk>\n       \\<Longrightarrow> s = last ts \\<and>\n                         r = t \\<bullet> a \\<bullet>\\<bullet> butlast ts\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (s = last ts \\<and>\n                    r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts;\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts' t'. ts = ts' @ [t']\n 3. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (s = last ts \\<and>\n                    r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts;\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts' t'. ts = ts' @ [t']\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>t.\n                   (r \\<bullet> s = t \\<bullet>\\<bullet> ts) =\n                   (if ts = [] then t = r \\<bullet> s\n                    else s = last ts \\<and>\n                         r = t \\<bullet>\\<bullet> butlast ts);\n        if a # ts = [] then t = r \\<bullet> s\n        else s = last (a # ts) \\<and>\n             r = t \\<bullet>\\<bullet> butlast (a # ts)\\<rbrakk>\n       \\<Longrightarrow> r \\<bullet> s = t \\<bullet>\\<bullet> (a # ts)\n 2. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (s = last ts \\<and>\n                    r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts;\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts' t'. ts = ts' @ [t']", "apply (clarsimp split:list.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ts t.\n       \\<lbrakk>\\<And>ta.\n                   (t \\<bullet> a \\<bullet>\\<bullet> ts =\n                    ta \\<bullet>\\<bullet> ts) =\n                   (s = last ts \\<and>\n                    r = ta \\<bullet>\\<bullet> butlast ts);\n        r \\<bullet> s = t \\<bullet> a \\<bullet>\\<bullet> ts;\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts' t'. ts = ts' @ [t']", "apply (metis append_butlast_last_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldl_At_eq_At[simp]:\n  \"t \\<bullet>\\<bullet> ts = r \\<bullet> s \\<longleftrightarrow>\n  (if ts=[] then t = r \\<bullet> s else s = last ts \\<and> r = t \\<bullet>\\<bullet> butlast ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<bullet>\\<bullet> ts = r \\<bullet> s) =\n    (if ts = [] then t = r \\<bullet> s\n     else s = last ts \\<and> r = t \\<bullet>\\<bullet> butlast ts)", "by(metis At_eq_foldl_At)"], ["", "lemma Lam_eq_foldl_At[simp]:\n  \"\\<Lambda> s = t \\<bullet>\\<bullet> ts \\<longleftrightarrow> t = \\<Lambda> s \\<and> ts = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> s = t \\<bullet>\\<bullet> ts) =\n    (t = \\<Lambda> s \\<and> ts = [])", "by (induct ts arbitrary:t) auto"], ["", "lemma foldl_At_eq_Lam[simp]:\n  \"t \\<bullet>\\<bullet> ts = \\<Lambda> s \\<longleftrightarrow> t = \\<Lambda> s \\<and> ts = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<bullet>\\<bullet> ts = \\<Lambda> s) =\n    (t = \\<Lambda> s \\<and> ts = [])", "by (induct ts arbitrary:t) auto"], ["", "lemma [simp]: \"s \\<bullet> t \\<noteq> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<bullet> t \\<noteq> s", "apply(subgoal_tac \"size(s \\<bullet> t) \\<noteq> size s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. size (s \\<bullet> t) \\<noteq> size s \\<Longrightarrow>\n    s \\<bullet> t \\<noteq> s\n 2. size (s \\<bullet> t) \\<noteq> size s", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. size (s \\<bullet> t) \\<noteq> size s", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* Better: a simproc for disproving \"s = t\"\n   if s is a subterm of t or vice versa, by proving \"size s ~= size t\"\n*)"], ["", "fun atomic_tm :: \"tm \\<Rightarrow> bool\" where\n\"atomic_tm(s \\<bullet> t) = False\" |\n\"atomic_tm(_) = True\""], ["", "fun head_tm where\n\"head_tm(s \\<bullet> t) = head_tm s\" |\n\"head_tm(s) = s\""], ["", "fun args_tm where\n\"args_tm(s \\<bullet> t) = args_tm s @ [t]\" |\n\"args_tm(_) = []\""], ["", "lemma head_tm_foldl_At[simp]: \"head_tm(s \\<bullet>\\<bullet> ts) = head_tm s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_tm (s \\<bullet>\\<bullet> ts) = head_tm s", "by(induct ts arbitrary: s) auto"], ["", "lemma args_tm_foldl_At[simp]: \"args_tm(s \\<bullet>\\<bullet> ts) = args_tm s @ ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args_tm (s \\<bullet>\\<bullet> ts) = args_tm s @ ts", "by(induct ts arbitrary: s) auto"], ["", "lemma tm_eq_iff:\n  \"atomic_tm(head_tm s) \\<Longrightarrow> atomic_tm(head_tm t)\n   \\<Longrightarrow> s = t \\<longleftrightarrow> head_tm s = head_tm t \\<and> args_tm s = args_tm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>atomic_tm (head_tm s); atomic_tm (head_tm t)\\<rbrakk>\n    \\<Longrightarrow> (s = t) =\n                      (head_tm s = head_tm t \\<and> args_tm s = args_tm t)", "apply(induct s arbitrary: t)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       \\<lbrakk>atomic_tm (head_tm (C x)); atomic_tm (head_tm t)\\<rbrakk>\n       \\<Longrightarrow> (C x = t) =\n                         (head_tm (C x) = head_tm t \\<and>\n                          args_tm (C x) = args_tm t)\n 2. \\<And>x t.\n       \\<lbrakk>atomic_tm (head_tm (V x)); atomic_tm (head_tm t)\\<rbrakk>\n       \\<Longrightarrow> (V x = t) =\n                         (head_tm (V x) = head_tm t \\<and>\n                          args_tm (V x) = args_tm t)\n 3. \\<And>s t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>atomic_tm (head_tm s);\n                    atomic_tm (head_tm t)\\<rbrakk>\n                   \\<Longrightarrow> (s = t) =\n                                     (head_tm s = head_tm t \\<and>\nargs_tm s = args_tm t);\n        atomic_tm (head_tm (\\<Lambda> s)); atomic_tm (head_tm t)\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> s = t) =\n                         (head_tm (\\<Lambda> s) = head_tm t \\<and>\n                          args_tm (\\<Lambda> s) = args_tm t)\n 4. \\<And>s1 s2 t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>atomic_tm (head_tm s1);\n                    atomic_tm (head_tm t)\\<rbrakk>\n                   \\<Longrightarrow> (s1 = t) =\n                                     (head_tm s1 = head_tm t \\<and>\nargs_tm s1 = args_tm t);\n        \\<And>t.\n           \\<lbrakk>atomic_tm (head_tm s2); atomic_tm (head_tm t)\\<rbrakk>\n           \\<Longrightarrow> (s2 = t) =\n                             (head_tm s2 = head_tm t \\<and>\n                              args_tm s2 = args_tm t);\n        atomic_tm (head_tm (s1 \\<bullet> s2));\n        atomic_tm (head_tm t)\\<rbrakk>\n       \\<Longrightarrow> (s1 \\<bullet> s2 = t) =\n                         (head_tm (s1 \\<bullet> s2) = head_tm t \\<and>\n                          args_tm (s1 \\<bullet> s2) = args_tm t)\n 5. \\<And>x t.\n       \\<lbrakk>atomic_tm (head_tm (term x)); atomic_tm (head_tm t)\\<rbrakk>\n       \\<Longrightarrow> (term x = t) =\n                         (head_tm (term x) = head_tm t \\<and>\n                          args_tm (term x) = args_tm t)", "apply(case_tac t, simp+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare\n  tm_eq_iff[of \"h \\<bullet>\\<bullet> ts\", simp]\n  tm_eq_iff[of _ \"h \\<bullet>\\<bullet> ts\", simp]\n  for h ts"], ["", "lemma atomic_tm_head_tm: \"atomic_tm(head_tm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atomic_tm (head_tm t)", "by(induct t) auto"], ["", "lemma head_tm_idem: \"head_tm(head_tm t) = head_tm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head_tm (head_tm t) = head_tm t", "by(induct t) auto"], ["", "lemma args_tm_head_tm: \"args_tm(head_tm t) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args_tm (head_tm t) = []", "by(induct t) auto"], ["", "lemma eta_head_args: \"t = head_tm t \\<bullet>\\<bullet> args_tm t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = head_tm t \\<bullet>\\<bullet> args_tm t", "by (subst tm_eq_iff) (auto simp: atomic_tm_head_tm head_tm_idem args_tm_head_tm)"], ["", "lemma tm_vector_cases:\n  \"(\\<exists>n ts. t = V n \\<bullet>\\<bullet> ts) \\<or>\n   (\\<exists>nm ts. t = C nm \\<bullet>\\<bullet> ts) \\<or>\n   (\\<exists>t' ts. t = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n   (\\<exists>v ts. t = term v \\<bullet>\\<bullet> ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n ts. t = V n \\<bullet>\\<bullet> ts) \\<or>\n    (\\<exists>nm ts. t = C nm \\<bullet>\\<bullet> ts) \\<or>\n    (\\<exists>t' ts. t = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n    (\\<exists>v ts. t = term v \\<bullet>\\<bullet> ts)", "apply(induct t)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       (\\<exists>n ts. C x = V n \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>nm ts. C x = C nm \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>t' ts. C x = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>v ts. C x = term v \\<bullet>\\<bullet> ts)\n 2. \\<And>x.\n       (\\<exists>n ts. V x = V n \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>nm ts. V x = C nm \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>t' ts. V x = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>v ts. V x = term v \\<bullet>\\<bullet> ts)\n 3. \\<And>t.\n       (\\<exists>n ts. t = V n \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>nm ts. t = C nm \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>t' ts. t = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>v ts. t = term v \\<bullet>\\<bullet> ts) \\<Longrightarrow>\n       (\\<exists>n ts. \\<Lambda> t = V n \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>nm ts. \\<Lambda> t = C nm \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>t' ts.\n           \\<Lambda> t = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>v ts. \\<Lambda> t = term v \\<bullet>\\<bullet> ts)\n 4. \\<And>t1 t2.\n       \\<lbrakk>(\\<exists>n ts. t1 = V n \\<bullet>\\<bullet> ts) \\<or>\n                (\\<exists>nm ts. t1 = C nm \\<bullet>\\<bullet> ts) \\<or>\n                (\\<exists>t' ts.\n                    t1 = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n                (\\<exists>v ts. t1 = term v \\<bullet>\\<bullet> ts);\n        (\\<exists>n ts. t2 = V n \\<bullet>\\<bullet> ts) \\<or>\n        (\\<exists>nm ts. t2 = C nm \\<bullet>\\<bullet> ts) \\<or>\n        (\\<exists>t' ts. t2 = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n        (\\<exists>v ts. t2 = term v \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n ts.\n                             t1 \\<bullet> t2 =\n                             V n \\<bullet>\\<bullet> ts) \\<or>\n                         (\\<exists>nm ts.\n                             t1 \\<bullet> t2 =\n                             C nm \\<bullet>\\<bullet> ts) \\<or>\n                         (\\<exists>t' ts.\n                             t1 \\<bullet> t2 =\n                             \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n                         (\\<exists>v ts.\n                             t1 \\<bullet> t2 = term v \\<bullet>\\<bullet> ts)\n 5. \\<And>x.\n       (\\<exists>n ts. term x = V n \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>nm ts. term x = C nm \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>t' ts. term x = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n       (\\<exists>v ts. term x = term v \\<bullet>\\<bullet> ts)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>(\\<exists>n ts. t1 = V n \\<bullet>\\<bullet> ts) \\<or>\n                (\\<exists>nm ts. t1 = C nm \\<bullet>\\<bullet> ts) \\<or>\n                (\\<exists>t' ts.\n                    t1 = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n                (\\<exists>v ts. t1 = term v \\<bullet>\\<bullet> ts);\n        (\\<exists>n ts. t2 = V n \\<bullet>\\<bullet> ts) \\<or>\n        (\\<exists>nm ts. t2 = C nm \\<bullet>\\<bullet> ts) \\<or>\n        (\\<exists>t' ts. t2 = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n        (\\<exists>v ts. t2 = term v \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>n ts.\n                             ts \\<noteq> [] \\<and>\n                             (ts \\<noteq> [] \\<longrightarrow>\n                              t2 = last ts \\<and>\n                              t1 = V n \\<bullet>\\<bullet> butlast ts)) \\<or>\n                         (\\<exists>nm ts.\n                             ts \\<noteq> [] \\<and>\n                             (ts \\<noteq> [] \\<longrightarrow>\n                              t2 = last ts \\<and>\n                              t1 =\n                              C nm \\<bullet>\\<bullet> butlast ts)) \\<or>\n                         (\\<exists>t' ts.\n                             ts \\<noteq> [] \\<and>\n                             (ts \\<noteq> [] \\<longrightarrow>\n                              t2 = last ts \\<and>\n                              t1 =\n                              \\<Lambda> t' \\<bullet>\\<bullet>\n                              butlast ts)) \\<or>\n                         (\\<exists>v ts.\n                             ts \\<noteq> [] \\<and>\n                             (ts \\<noteq> [] \\<longrightarrow>\n                              t2 = last ts \\<and>\n                              t1 = term v \\<bullet>\\<bullet> butlast ts))", "by (metis snoc_eq_iff_butlast)"], ["", "lemma fv_head_C[simp]: \"fv (t \\<bullet>\\<bullet> ts) = fv t \\<union> (\\<Union>t\\<in>set ts. fv t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fv (t \\<bullet>\\<bullet> ts) = fv t \\<union> \\<Union> (fv ` set ts)", "by(induct ts arbitrary:t) auto"], ["", "subsection \"Lifting and Substitution\""], ["", "fun lift_ml :: \"nat \\<Rightarrow> ml \\<Rightarrow> ml\" (\"lift\") where\n\"lift i (C\\<^sub>M\\<^sub>L nm) = C\\<^sub>M\\<^sub>L nm\" |\n\"lift i (V\\<^sub>M\\<^sub>L X) = V\\<^sub>M\\<^sub>L X\" |\n\"lift i (A\\<^sub>M\\<^sub>L v vs) = A\\<^sub>M\\<^sub>L (lift i v) (map (lift i) vs)\" |\n\"lift i (Lam\\<^sub>M\\<^sub>L v) = Lam\\<^sub>M\\<^sub>L (lift i v)\" |\n\"lift i (C\\<^sub>U nm vs) = C\\<^sub>U nm (map (lift i) vs)\" |\n\"lift i (V\\<^sub>U x vs) = V\\<^sub>U (if x < i then x else x+1) (map (lift i) vs)\" |\n\"lift i (Clo v vs n) = Clo (lift i v) (map (lift i) vs) n\" |\n\"lift i (apply u v) = apply (lift i u) (lift i v)\""], ["", "lemmas ml_induct = lift_ml.induct[of \"\\<lambda>i v. P v\"] for P"], ["", "fun lift_tm :: \"nat \\<Rightarrow> tm \\<Rightarrow> tm\" (\"lift\") where\n\"lift i (C nm) = C nm\" |\n\"lift i (V x) = V(if x < i then x else x+1)\" |\n\"lift i (s\\<bullet>t) = (lift i s)\\<bullet>(lift i t)\" |\n\"lift i (\\<Lambda> t) = \\<Lambda>(lift (i+1) t)\" |\n\"lift i (term v) = term (lift i v)\""], ["", "fun lift_ML :: \"nat \\<Rightarrow> ml \\<Rightarrow> ml\" (\"lift\\<^sub>M\\<^sub>L\") where\n\"lift\\<^sub>M\\<^sub>L i (C\\<^sub>M\\<^sub>L nm) = C\\<^sub>M\\<^sub>L nm\" |\n\"lift\\<^sub>M\\<^sub>L i (V\\<^sub>M\\<^sub>L X) = V\\<^sub>M\\<^sub>L (if X < i then X else X+1)\" |\n\"lift\\<^sub>M\\<^sub>L i (A\\<^sub>M\\<^sub>L v vs) = A\\<^sub>M\\<^sub>L (lift\\<^sub>M\\<^sub>L i v) (map (lift\\<^sub>M\\<^sub>L i) vs)\" |\n\"lift\\<^sub>M\\<^sub>L i (Lam\\<^sub>M\\<^sub>L v) = Lam\\<^sub>M\\<^sub>L (lift\\<^sub>M\\<^sub>L (i+1) v)\" |\n\"lift\\<^sub>M\\<^sub>L i (C\\<^sub>U nm vs) = C\\<^sub>U nm (map (lift\\<^sub>M\\<^sub>L i) vs)\" |\n\"lift\\<^sub>M\\<^sub>L i (V\\<^sub>U x vs) = V\\<^sub>U x (map (lift\\<^sub>M\\<^sub>L i) vs)\" |\n\"lift\\<^sub>M\\<^sub>L i (Clo v vs n) = Clo (lift\\<^sub>M\\<^sub>L i v) (map (lift\\<^sub>M\\<^sub>L i) vs) n\" |\n\"lift\\<^sub>M\\<^sub>L i (apply u v) = apply (lift\\<^sub>M\\<^sub>L i u) (lift\\<^sub>M\\<^sub>L i v)\""], ["", "definition\n cons :: \"tm \\<Rightarrow> (nat \\<Rightarrow> tm) \\<Rightarrow> (nat \\<Rightarrow> tm)\" (infix \"##\" 65) where\n\"t##\\<sigma> \\<equiv> \\<lambda>i. case i of 0 \\<Rightarrow> t | Suc j \\<Rightarrow> lift 0 (\\<sigma> j)\""], ["", "definition\n cons_ML :: \"ml \\<Rightarrow> (nat \\<Rightarrow> ml) \\<Rightarrow> (nat \\<Rightarrow> ml)\" (infix \"##\" 65) where\n\"v##\\<sigma> \\<equiv> \\<lambda>i. case i of 0 \\<Rightarrow> v::ml | Suc j \\<Rightarrow> lift\\<^sub>M\\<^sub>L 0 (\\<sigma> j)\""], ["", "text\\<open>Only for pure terms!\\<close>"], ["", "primrec subst :: \"(nat \\<Rightarrow> tm) \\<Rightarrow> tm \\<Rightarrow> tm\"\nwhere\n  \"subst \\<sigma> (C nm) = C nm\"\n| \"subst \\<sigma> (V x) = \\<sigma> x\"\n| \"subst \\<sigma> (\\<Lambda> t) = \\<Lambda>(subst (V 0 ## \\<sigma>) t)\"\n| \"subst \\<sigma> (s\\<bullet>t) = (subst \\<sigma> s) \\<bullet> (subst \\<sigma> t)\""], ["", "fun subst_ML :: \"(nat \\<Rightarrow> ml) \\<Rightarrow> ml \\<Rightarrow> ml\" (\"subst\\<^sub>M\\<^sub>L\") where\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm) = C\\<^sub>M\\<^sub>L nm\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X) = \\<sigma> X\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (A\\<^sub>M\\<^sub>L v vs) = A\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v) = Lam\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v)\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs) = C\\<^sub>U nm (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs) = V\\<^sub>U x (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n) = Clo (subst\\<^sub>M\\<^sub>L \\<sigma> v) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs) n\" |\n\"subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v) = apply (subst\\<^sub>M\\<^sub>L \\<sigma> u) (subst\\<^sub>M\\<^sub>L \\<sigma> v)\""], ["", "(* FIXME currrently needed for code generator\nlemmas [code] = lift_tm.simps lift_ml.simps\nlemmas [code] = subst_ML.simps *)"], ["", "abbreviation\n  subst_decr :: \"nat \\<Rightarrow> tm \\<Rightarrow> nat \\<Rightarrow> tm\" where\n  \"subst_decr k t \\<equiv> \\<lambda>n. if n<k then V n else if n=k then t else V(n - 1)\""], ["", "abbreviation\n  subst_decr_ML :: \"nat \\<Rightarrow> ml \\<Rightarrow> nat \\<Rightarrow> ml\" where\n\"subst_decr_ML k v \\<equiv> \\<lambda>n. if n<k then V\\<^sub>M\\<^sub>L n else if n=k then v else V\\<^sub>M\\<^sub>L(n - 1)\""], ["", "abbreviation\n  subst1 :: \"tm \\<Rightarrow> tm \\<Rightarrow> nat \\<Rightarrow> tm\" (\"(_/[_'/_])\" [300, 0, 0] 300) where\n \"s[t/k] \\<equiv> subst (subst_decr k t) s\""], ["", "abbreviation\n  subst1_ML :: \"ml \\<Rightarrow> ml \\<Rightarrow> nat \\<Rightarrow> ml\" (\"(_/[_'/_])\" [300, 0, 0] 300) where\n \"u[v/k] \\<equiv> subst\\<^sub>M\\<^sub>L (subst_decr_ML k v) u\""], ["", "lemma apply_cons[simp]:\n  \"(t##\\<sigma>) i = (if i=0 then t::tm else lift 0 (\\<sigma>(i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t ## \\<sigma>) i = (if i = 0 then t else lift 0 (\\<sigma> (i - 1)))", "by(simp add: cons_def split:nat.split)"], ["", "lemma apply_cons_ML[simp]:\n  \"(v##\\<sigma>) i = (if i=0 then v::ml else lift\\<^sub>M\\<^sub>L 0 (\\<sigma>(i - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v ## \\<sigma>) i =\n    (if i = 0 then v else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1)))", "by(simp add: cons_ML_def split:nat.split)"], ["", "lemma lift_foldl_At[simp]:\n  \"lift k (s \\<bullet>\\<bullet> ts) = (lift k s) \\<bullet>\\<bullet> (map (lift k) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift k (s \\<bullet>\\<bullet> ts) =\n    lift k s \\<bullet>\\<bullet> map (lift k) ts", "by(induct ts arbitrary:s) simp_all"], ["", "lemma lift_lift_ml: fixes v :: ml shows\n  \"i < k+1 \\<Longrightarrow> lift (Suc k) (lift i v) = lift i (lift k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k + 1 \\<Longrightarrow> lift (Suc k) (lift i v) = lift i (lift k v)", "by(induct i v rule:lift_ml.induct)\n  simp_all"], ["", "lemma lift_lift_tm: fixes t :: tm shows\n    \"i < k+1 \\<Longrightarrow> lift (Suc k) (lift i t) = lift i (lift k t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k + 1 \\<Longrightarrow> lift (Suc k) (lift i t) = lift i (lift k t)", "by(induct t arbitrary: i rule:lift_tm.induct)(simp_all add:lift_lift_ml)"], ["", "lemma lift_lift_ML:\n  \"i < k+1 \\<Longrightarrow> lift\\<^sub>M\\<^sub>L (Suc k) (lift\\<^sub>M\\<^sub>L i v) = lift\\<^sub>M\\<^sub>L i (lift\\<^sub>M\\<^sub>L k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < k + 1 \\<Longrightarrow>\n    lift\\<^sub>M\\<^sub>L (Suc k) (lift\\<^sub>M\\<^sub>L i v) =\n    lift\\<^sub>M\\<^sub>L i (lift\\<^sub>M\\<^sub>L k v)", "by(induct v arbitrary: i rule:lift_ML.induct)\n  simp_all"], ["", "lemma lift_lift_ML_comm:\n  \"lift j (lift\\<^sub>M\\<^sub>L i v) = lift\\<^sub>M\\<^sub>L i (lift j v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift j (lift\\<^sub>M\\<^sub>L i v) = lift\\<^sub>M\\<^sub>L i (lift j v)", "by(induct v arbitrary: i j rule:lift_ML.induct)\n  simp_all"], ["", "lemma V_ML_cons_ML_subst_decr[simp]:\n  \"V\\<^sub>M\\<^sub>L 0 ## subst_decr_ML k v = subst_decr_ML (Suc k) (lift\\<^sub>M\\<^sub>L 0 v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^sub>M\\<^sub>L 0 ## subst_decr_ML k v =\n    subst_decr_ML (Suc k) (lift\\<^sub>M\\<^sub>L 0 v)", "by(rule ext)(simp add:cons_ML_def split:nat.split)"], ["", "lemma shift_subst_decr[simp]:\n \"V 0 ## subst_decr k t = subst_decr (Suc k) (lift 0 t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V 0 ## subst_decr k t = subst_decr (Suc k) (lift 0 t)", "by(rule ext)(simp add:cons_def split:nat.split)"], ["", "lemma lift_comp_subst_decr[simp]:\n  \"lift 0 o subst_decr_ML k v = subst_decr_ML k (lift 0 v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 \\<circ> subst_decr_ML k v = subst_decr_ML k (lift 0 v)", "by(rule ext) simp"], ["", "lemma subst_ML_ext: \"\\<forall>i. \\<sigma> i = \\<sigma>' i \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = subst\\<^sub>M\\<^sub>L \\<sigma>' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<sigma> i = \\<sigma>' i \\<Longrightarrow>\n    subst\\<^sub>M\\<^sub>L \\<sigma> v = subst\\<^sub>M\\<^sub>L \\<sigma>' v", "by(metis ext)"], ["", "lemma subst_ext: \"\\<forall>i. \\<sigma> i = \\<sigma>' i \\<Longrightarrow> subst \\<sigma> v = subst \\<sigma>' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<sigma> i = \\<sigma>' i \\<Longrightarrow>\n    subst \\<sigma> v = subst \\<sigma>' v", "by(metis ext)"], ["", "lemma lift_Pure_tms[simp]: \"pure t \\<Longrightarrow> pure(lift k t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> pure (lift k t)", "by(induct arbitrary:k pred:pure) simp_all"], ["", "lemma cons_ML_V_ML[simp]: \"(V\\<^sub>M\\<^sub>L 0 ## V\\<^sub>M\\<^sub>L) = V\\<^sub>M\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^sub>M\\<^sub>L 0 ## V\\<^sub>M\\<^sub>L = V\\<^sub>M\\<^sub>L", "by(rule ext) simp"], ["", "lemma cons_V[simp]: \"(V 0 ## V) = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V 0 ## V = V", "by(rule ext) simp"], ["", "lemma lift_o_shift: \"lift k \\<circ> (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) = (V\\<^sub>M\\<^sub>L 0 ## (lift k \\<circ> \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift k \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n    V\\<^sub>M\\<^sub>L 0 ## (lift k \\<circ> \\<sigma>)", "by(rule ext)(simp add: lift_lift_ML_comm)"], ["", "lemma lift_subst_ML:\n \"lift k (subst\\<^sub>M\\<^sub>L \\<sigma> v) = subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n    subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k v)", "apply(induct \\<sigma> v rule:subst_ML.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm.\n       lift k (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n        (lift k (C\\<^sub>M\\<^sub>L nm))\n 2. \\<And>\\<sigma> X.\n       lift k (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n        (lift k (V\\<^sub>M\\<^sub>L X))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>lift k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k v);\n        \\<And>x.\n           x \\<in> set vs \\<Longrightarrow>\n           lift k (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n            (lift k x)\\<rbrakk>\n       \\<Longrightarrow> lift k\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n                          (lift k (A\\<^sub>M\\<^sub>L v vs))\n 4. \\<And>\\<sigma> v.\n       lift k (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n       subst\\<^sub>M\\<^sub>L\n        (lift k \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n        (lift k v) \\<Longrightarrow>\n       lift k (subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v)) =\n       subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n        (lift k (Lam\\<^sub>M\\<^sub>L v))\n 5. \\<And>\\<sigma> nm vs.\n       (\\<And>x.\n           x \\<in> set vs \\<Longrightarrow>\n           lift k (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n            (lift k x)) \\<Longrightarrow>\n       lift k (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs)) =\n       subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n        (lift k (C\\<^sub>U nm vs))\n 6. \\<And>\\<sigma> x vs.\n       (\\<And>xa.\n           xa \\<in> set vs \\<Longrightarrow>\n           lift k (subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n           subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n            (lift k xa)) \\<Longrightarrow>\n       lift k (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs)) =\n       subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n        (lift k (V\\<^sub>U x vs))\n 7. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>lift k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k v);\n        \\<And>x.\n           x \\<in> set vs \\<Longrightarrow>\n           lift k (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n            (lift k x)\\<rbrakk>\n       \\<Longrightarrow> lift k\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n                          (lift k (Clo v vs n))\n 8. \\<And>\\<sigma> u v.\n       \\<lbrakk>lift k (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k u);\n        lift k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>) (lift k v)\\<rbrakk>\n       \\<Longrightarrow> lift k\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         subst\\<^sub>M\\<^sub>L (lift k \\<circ> \\<sigma>)\n                          (lift k (apply u v))", "apply(simp_all add: o_assoc lift_o_shift del:apply_cons_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v.\n       lift k (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n       subst\\<^sub>M\\<^sub>L\n        (V\\<^sub>M\\<^sub>L 0 ## (lift k \\<circ> \\<sigma>))\n        (lift k v) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L\n        (V\\<^sub>M\\<^sub>L 0 ## (lift k \\<circ> \\<sigma>)) (lift k v) =\n       subst\\<^sub>M\\<^sub>L\n        (V\\<^sub>M\\<^sub>L 0 ## (\\<lambda>a. lift k (\\<sigma> a)))\n        (lift k v)", "apply(simp add:o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary lift_subst_ML1:\n  \"\\<forall>v k. lift_ml 0 (u[v/k]) = (lift_ml 0 u)[lift 0 v/k]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v k. lift 0 (u[v/k]) = lift 0 u[lift 0 v/k]", "apply(induct u rule:ml_induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i nm.\n       \\<forall>v k.\n          lift 0 (C\\<^sub>M\\<^sub>L nm[v/k]) =\n          lift 0 (C\\<^sub>M\\<^sub>L nm)[lift 0 v/k]\n 2. \\<And>i X.\n       \\<forall>v k.\n          lift 0 (V\\<^sub>M\\<^sub>L X[v/k]) =\n          lift 0 (V\\<^sub>M\\<^sub>L X)[lift 0 v/k]\n 3. \\<And>i v vs.\n       \\<lbrakk>\\<forall>va k. lift 0 (v[va/k]) = lift 0 v[lift 0 va/k];\n        \\<And>x.\n           x \\<in> set vs \\<Longrightarrow>\n           \\<forall>v k. lift 0 (x[v/k]) = lift 0 x[lift 0 v/k]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va k.\n                            lift 0 (A\\<^sub>M\\<^sub>L v vs[va/k]) =\n                            lift 0 (A\\<^sub>M\\<^sub>L v vs)[lift 0 va/k]\n 4. \\<And>i v.\n       \\<forall>va k.\n          lift 0 (v[va/k]) = lift 0 v[lift 0 va/k] \\<Longrightarrow>\n       \\<forall>va k.\n          lift 0 (Lam\\<^sub>M\\<^sub>L v[va/k]) =\n          lift 0 (Lam\\<^sub>M\\<^sub>L v)[lift 0 va/k]\n 5. \\<And>i nm vs.\n       (\\<And>x.\n           x \\<in> set vs \\<Longrightarrow>\n           \\<forall>v k.\n              lift 0 (x[v/k]) = lift 0 x[lift 0 v/k]) \\<Longrightarrow>\n       \\<forall>v k.\n          lift 0 (C\\<^sub>U nm vs[v/k]) =\n          lift 0 (C\\<^sub>U nm vs)[lift 0 v/k]\n 6. \\<And>i x vs.\n       (\\<And>xa.\n           xa \\<in> set vs \\<Longrightarrow>\n           \\<forall>v k.\n              lift 0 (xa[v/k]) = lift 0 xa[lift 0 v/k]) \\<Longrightarrow>\n       \\<forall>v k.\n          lift 0 (V\\<^sub>U x vs[v/k]) = lift 0 (V\\<^sub>U x vs)[lift 0 v/k]\n 7. \\<And>i v vs n.\n       \\<lbrakk>\\<forall>va k. lift 0 (v[va/k]) = lift 0 v[lift 0 va/k];\n        \\<And>x.\n           x \\<in> set vs \\<Longrightarrow>\n           \\<forall>v k. lift 0 (x[v/k]) = lift 0 x[lift 0 v/k]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va k.\n                            lift 0 (Clo v vs n[va/k]) =\n                            lift 0 (Clo v vs n)[lift 0 va/k]\n 8. \\<And>i u v.\n       \\<lbrakk>\\<forall>v k. lift 0 (u[v/k]) = lift 0 u[lift 0 v/k];\n        \\<forall>va k. lift 0 (v[va/k]) = lift 0 v[lift 0 va/k]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>va k.\n                            lift 0 (apply u v[va/k]) =\n                            lift 0 (apply u v)[lift 0 va/k]", "apply(simp_all add:lift_lift_ml lift_subst_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<forall>va k.\n          lift 0 v[lift 0 (lift\\<^sub>M\\<^sub>L 0 va)/Suc k] =\n          lift 0 v[lift\\<^sub>M\\<^sub>L 0 (lift 0 va)/Suc k]", "apply(subst lift_lift_ML_comm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<forall>va k.\n          lift 0 v[lift\\<^sub>M\\<^sub>L 0 (lift 0 va)/Suc k] =\n          lift 0 v[lift\\<^sub>M\\<^sub>L 0 (lift 0 va)/Suc k]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lift_ML_subst_ML:\n \"lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n  subst\\<^sub>M\\<^sub>L (\\<lambda>i. if i<k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i) else if i=k then V\\<^sub>M\\<^sub>L k else lift\\<^sub>M\\<^sub>L k (\\<sigma>(i - 1))) (lift\\<^sub>M\\<^sub>L k v)\"\n  (is \"_ = subst\\<^sub>M\\<^sub>L (?insrt k \\<sigma>) (lift\\<^sub>M\\<^sub>L k v)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n    subst\\<^sub>M\\<^sub>L\n     (\\<lambda>i.\n         if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n         else if i = k then V\\<^sub>M\\<^sub>L k\n              else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n     (lift\\<^sub>M\\<^sub>L k v)", "apply (induct k v arbitrary: \\<sigma> k rule: lift_ML.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i nm \\<sigma> k.\n       lift\\<^sub>M\\<^sub>L k\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n            else if i = k then V\\<^sub>M\\<^sub>L k\n                 else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L k (C\\<^sub>M\\<^sub>L nm))\n 2. \\<And>i X \\<sigma> k.\n       lift\\<^sub>M\\<^sub>L k\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n            else if i = k then V\\<^sub>M\\<^sub>L k\n                 else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L k (V\\<^sub>M\\<^sub>L X))\n 3. \\<And>i v vs \\<sigma> k.\n       \\<lbrakk>\\<And>\\<sigma> k.\n                   lift\\<^sub>M\\<^sub>L k\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>i.\n                        if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                        else if i = k then V\\<^sub>M\\<^sub>L k\n                             else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n                    (lift\\<^sub>M\\<^sub>L k v);\n        \\<And>x \\<sigma> k.\n           x \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k x)\\<rbrakk>\n       \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>i.\n                              if i < k\n                              then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                              else if i = k then V\\<^sub>M\\<^sub>L k\n                                   else lift\\<^sub>M\\<^sub>L k\n   (\\<sigma> (i - 1)))\n                          (lift\\<^sub>M\\<^sub>L k (A\\<^sub>M\\<^sub>L v vs))\n 4. \\<And>i v \\<sigma> k.\n       (\\<And>\\<sigma> k.\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k v)) \\<Longrightarrow>\n       lift\\<^sub>M\\<^sub>L k\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n            else if i = k then V\\<^sub>M\\<^sub>L k\n                 else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L k (Lam\\<^sub>M\\<^sub>L v))\n 5. \\<And>i nm vs \\<sigma> k.\n       (\\<And>x \\<sigma> k.\n           x \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k x)) \\<Longrightarrow>\n       lift\\<^sub>M\\<^sub>L k\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n            else if i = k then V\\<^sub>M\\<^sub>L k\n                 else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L k (C\\<^sub>U nm vs))\n 6. \\<And>i x vs \\<sigma> k.\n       (\\<And>xa \\<sigma> k.\n           xa \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k xa)) \\<Longrightarrow>\n       lift\\<^sub>M\\<^sub>L k\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n            else if i = k then V\\<^sub>M\\<^sub>L k\n                 else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L k (V\\<^sub>U x vs))\n 7. \\<And>i v vs n \\<sigma> k.\n       \\<lbrakk>\\<And>\\<sigma> k.\n                   lift\\<^sub>M\\<^sub>L k\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>i.\n                        if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                        else if i = k then V\\<^sub>M\\<^sub>L k\n                             else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n                    (lift\\<^sub>M\\<^sub>L k v);\n        \\<And>x \\<sigma> k.\n           x \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k x)\\<rbrakk>\n       \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>i.\n                              if i < k\n                              then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                              else if i = k then V\\<^sub>M\\<^sub>L k\n                                   else lift\\<^sub>M\\<^sub>L k\n   (\\<sigma> (i - 1)))\n                          (lift\\<^sub>M\\<^sub>L k (Clo v vs n))\n 8. \\<And>i u v \\<sigma> k.\n       \\<lbrakk>\\<And>\\<sigma> k.\n                   lift\\<^sub>M\\<^sub>L k\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                   subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>i.\n                        if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                        else if i = k then V\\<^sub>M\\<^sub>L k\n                             else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n                    (lift\\<^sub>M\\<^sub>L k u);\n        \\<And>\\<sigma> k.\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k v)\\<rbrakk>\n       \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>i.\n                              if i < k\n                              then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                              else if i = k then V\\<^sub>M\\<^sub>L k\n                                   else lift\\<^sub>M\\<^sub>L k\n   (\\<sigma> (i - 1)))\n                          (lift\\<^sub>M\\<^sub>L k (apply u v))", "apply (simp_all add: o_assoc lift_o_shift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma> k.\n       (\\<And>\\<sigma> k.\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k v)) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i < Suc k\n            then lift\\<^sub>M\\<^sub>L (Suc k)\n                  ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i)\n            else if i = Suc k then V\\<^sub>M\\<^sub>L (Suc k)\n                 else lift\\<^sub>M\\<^sub>L (Suc k)\n                       ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) (i - 1)))\n        (lift\\<^sub>M\\<^sub>L (Suc k) v) =\n       subst\\<^sub>M\\<^sub>L\n        (V\\<^sub>M\\<^sub>L 0 ##\n         (\\<lambda>i.\n             if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n             else if i = k then V\\<^sub>M\\<^sub>L k\n                  else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1))))\n        (lift\\<^sub>M\\<^sub>L (Suc k) v)", "apply(subgoal_tac \"V\\<^sub>M\\<^sub>L 0 ## ?insrt k \\<sigma> = ?insrt (Suc k) (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma> k.\n       \\<lbrakk>\\<And>\\<sigma> k.\n                   lift\\<^sub>M\\<^sub>L k\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>i.\n                        if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                        else if i = k then V\\<^sub>M\\<^sub>L k\n                             else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n                    (lift\\<^sub>M\\<^sub>L k v);\n        V\\<^sub>M\\<^sub>L 0 ##\n        (\\<lambda>a.\n            if a < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> a)\n            else if a = k then V\\<^sub>M\\<^sub>L k\n                 else lift\\<^sub>M\\<^sub>L k (\\<sigma> (a - 1))) =\n        (\\<lambda>a.\n            if a < Suc k\n            then lift\\<^sub>M\\<^sub>L (Suc k)\n                  ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) a)\n            else if a = Suc k then V\\<^sub>M\\<^sub>L (Suc k)\n                 else lift\\<^sub>M\\<^sub>L (Suc k)\n                       ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) (a - 1)))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>i.\n                              if i < Suc k\n                              then lift\\<^sub>M\\<^sub>L (Suc k)\n                                    ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i)\n                              else if i = Suc k\n                                   then V\\<^sub>M\\<^sub>L (Suc k)\n                                   else lift\\<^sub>M\\<^sub>L (Suc k)\n   ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) (i - 1)))\n                          (lift\\<^sub>M\\<^sub>L (Suc k) v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (V\\<^sub>M\\<^sub>L 0 ##\n                           (\\<lambda>i.\n                               if i < k\n                               then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                               else if i = k then V\\<^sub>M\\<^sub>L k\n                                    else lift\\<^sub>M\\<^sub>L k\n    (\\<sigma> (i - 1))))\n                          (lift\\<^sub>M\\<^sub>L (Suc k) v)\n 2. \\<And>v \\<sigma> k.\n       (\\<And>\\<sigma> k.\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k v)) \\<Longrightarrow>\n       V\\<^sub>M\\<^sub>L 0 ##\n       (\\<lambda>a.\n           if a < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> a)\n           else if a = k then V\\<^sub>M\\<^sub>L k\n                else lift\\<^sub>M\\<^sub>L k (\\<sigma> (a - 1))) =\n       (\\<lambda>a.\n           if a < Suc k\n           then lift\\<^sub>M\\<^sub>L (Suc k)\n                 ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) a)\n           else if a = Suc k then V\\<^sub>M\\<^sub>L (Suc k)\n                else lift\\<^sub>M\\<^sub>L (Suc k)\n                      ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) (a - 1)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma> k.\n       (\\<And>\\<sigma> k.\n           lift\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L\n            (\\<lambda>i.\n                if i < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> i)\n                else if i = k then V\\<^sub>M\\<^sub>L k\n                     else lift\\<^sub>M\\<^sub>L k (\\<sigma> (i - 1)))\n            (lift\\<^sub>M\\<^sub>L k v)) \\<Longrightarrow>\n       V\\<^sub>M\\<^sub>L 0 ##\n       (\\<lambda>a.\n           if a < k then lift\\<^sub>M\\<^sub>L k (\\<sigma> a)\n           else if a = k then V\\<^sub>M\\<^sub>L k\n                else lift\\<^sub>M\\<^sub>L k (\\<sigma> (a - 1))) =\n       (\\<lambda>a.\n           if a < Suc k\n           then lift\\<^sub>M\\<^sub>L (Suc k)\n                 ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) a)\n           else if a = Suc k then V\\<^sub>M\\<^sub>L (Suc k)\n                else lift\\<^sub>M\\<^sub>L (Suc k)\n                      ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) (a - 1)))", "apply (simp add:fun_eq_iff lift_lift_ML cons_ML_def split:nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary subst_cons_lift:\n \"subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) o (lift\\<^sub>M\\<^sub>L 0) = lift\\<^sub>M\\<^sub>L 0 o (subst\\<^sub>M\\<^sub>L \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) \\<circ>\n    lift\\<^sub>M\\<^sub>L 0 =\n    lift\\<^sub>M\\<^sub>L 0 \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) \\<circ>\n        lift\\<^sub>M\\<^sub>L 0)\n        x =\n       (lift\\<^sub>M\\<^sub>L 0 \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>) x", "apply(simp add: lift_ML_subst_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n        (lift\\<^sub>M\\<^sub>L 0 x) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i = 0 then V\\<^sub>M\\<^sub>L 0\n            else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L 0 x)", "apply(subgoal_tac \"(V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) = (\\<lambda>i. if i = 0 then V\\<^sub>M\\<^sub>L 0 else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n       (\\<lambda>i.\n           if i = 0 then V\\<^sub>M\\<^sub>L 0\n           else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1))) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n        (lift\\<^sub>M\\<^sub>L 0 x) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>i.\n            if i = 0 then V\\<^sub>M\\<^sub>L 0\n            else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1)))\n        (lift\\<^sub>M\\<^sub>L 0 x)\n 2. \\<And>x.\n       V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n       (\\<lambda>i.\n           if i = 0 then V\\<^sub>M\\<^sub>L 0\n           else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n       (\\<lambda>i.\n           if i = 0 then V\\<^sub>M\\<^sub>L 0\n           else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - 1)))", "apply(rule ext, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lift_ML_id[simp]: \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow>\n    lift\\<^sub>M\\<^sub>L k v = v", "by(induct k v rule: lift_ML.induct)(simp_all add:list_eq_iff_nth_eq)"], ["", "lemma subst_ML_id:\n  \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n     \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n    \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v", "apply (induct \\<sigma> v arbitrary: k rule: subst_ML.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm k.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L k (C\\<^sub>M\\<^sub>L nm);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>M\\<^sub>L nm) =\n                         C\\<^sub>M\\<^sub>L nm\n 2. \\<And>\\<sigma> X k.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L k (V\\<^sub>M\\<^sub>L X);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (V\\<^sub>M\\<^sub>L X) =\n                         V\\<^sub>M\\<^sub>L X\n 3. \\<And>\\<sigma> v vs k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        closed\\<^sub>M\\<^sub>L k (A\\<^sub>M\\<^sub>L v vs);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (A\\<^sub>M\\<^sub>L v vs) =\n                         A\\<^sub>M\\<^sub>L v vs\n 4. \\<And>\\<sigma> v k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k.\n                       (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i =\n                       V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n(V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v =\n                                     v;\n        closed\\<^sub>M\\<^sub>L k (Lam\\<^sub>M\\<^sub>L v);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (Lam\\<^sub>M\\<^sub>L v) =\n                         Lam\\<^sub>M\\<^sub>L v\n 5. \\<And>\\<sigma> nm vs k.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        closed\\<^sub>M\\<^sub>L k (C\\<^sub>U nm vs);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs) =\n                         C\\<^sub>U nm vs\n 6. \\<And>\\<sigma> x vs k.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        closed\\<^sub>M\\<^sub>L k (V\\<^sub>U x vs);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs) =\n                         V\\<^sub>U x vs\n 7. \\<And>\\<sigma> v vs n k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        closed\\<^sub>M\\<^sub>L k (Clo v vs n);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n) =\n                         Clo v vs n\n 8. \\<And>\\<sigma> u v k.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k u;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> u = u;\n        \\<And>k.\n           \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        closed\\<^sub>M\\<^sub>L k (apply u v);\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v) =\n                         apply u v", "apply (auto simp add: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 4. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(simp add:Ball_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x.\n           x \\<in> set vs \\<longrightarrow> closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 4. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"vs!i\" in meta_allE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x.\n           x \\<in> set vs \\<longrightarrow> closed\\<^sub>M\\<^sub>L k x;\n        i < length vs;\n        \\<And>k.\n           \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                             vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 4. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"k\" in meta_allE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x.\n           x \\<in> set vs \\<longrightarrow> closed\\<^sub>M\\<^sub>L k x;\n        i < length vs;\n        \\<And>k.\n           \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                             vs ! i;\n        \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 4. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"k\" in meta_allE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x.\n           x \\<in> set vs \\<longrightarrow> closed\\<^sub>M\\<^sub>L k x;\n        i < length vs;\n        \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                          vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 4. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"vs!i\" in meta_allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i; i < length vs;\n        \\<And>k.\n           \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                             vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"k\" in meta_allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i; i < length vs;\n        \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                          vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 3. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs; closed\\<^sub>M\\<^sub>L k xa;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> xa = xa;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"vs!i\" in meta_allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i; i < length vs;\n        \\<And>k.\n           \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                             vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"k\" in meta_allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> vs k i.\n       \\<lbrakk>\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i; i < length vs;\n        \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                          vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i\n 2. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; closed\\<^sub>M\\<^sub>L k x;\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> x = x;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x;\n        i < length vs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"vs!i\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<And>k.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n                    \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n                   \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x; i < length vs;\n        \\<And>k.\n           \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                             vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"k\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x; i < length vs;\n        \\<And>k.\n           \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n            \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                             vs ! i;\n        \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply(erule_tac x=\"k\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v vs k i.\n       \\<lbrakk>\\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i;\n        closed\\<^sub>M\\<^sub>L k v;\n        \\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L k x; i < length vs;\n        \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v;\n        \\<lbrakk>vs ! i \\<in> set vs; closed\\<^sub>M\\<^sub>L k (vs ! i);\n         \\<forall>i<k. \\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n        \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) =\n                          vs ! i\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (vs ! i) = vs ! i", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary subst_ML_id2[simp]: \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n    subst\\<^sub>M\\<^sub>L \\<sigma> v = v", "using subst_ML_id[where k=0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 ?v;\n   \\<forall>i<0. ?\\<sigma> i = V\\<^sub>M\\<^sub>L i\\<rbrakk>\n  \\<Longrightarrow> subst\\<^sub>M\\<^sub>L ?\\<sigma> ?v = ?v\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n    subst\\<^sub>M\\<^sub>L \\<sigma> v = v", "by simp"], ["", "lemma subst_ML_coincidence:\n  \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> \\<forall>i<k. \\<sigma> i = \\<sigma>' i \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v = subst\\<^sub>M\\<^sub>L \\<sigma>' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n     \\<forall>i<k. \\<sigma> i = \\<sigma>' i\\<rbrakk>\n    \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v =\n                      subst\\<^sub>M\\<^sub>L \\<sigma>' v", "by (induct \\<sigma> v arbitrary: k \\<sigma>' rule: subst_ML.induct) auto"], ["", "lemma subst_ML_comp:\n  \"subst\\<^sub>M\\<^sub>L \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) = subst\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma>  \\<circ> \\<sigma>') v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) =\n    subst\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> \\<sigma>')\n     v", "apply (induct \\<sigma>' v arbitrary: \\<sigma> rule: subst_ML.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm \\<sigma>'.\n       subst\\<^sub>M\\<^sub>L \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       subst\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n        (C\\<^sub>M\\<^sub>L nm)\n 2. \\<And>\\<sigma> X \\<sigma>'.\n       subst\\<^sub>M\\<^sub>L \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       subst\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n        (V\\<^sub>M\\<^sub>L X)\n 3. \\<And>\\<sigma> v vs \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst\\<^sub>M\\<^sub>L \\<sigma>'\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) v;\n        \\<And>x \\<sigma>'.\n           x \\<in> set vs \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) x\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n                          (A\\<^sub>M\\<^sub>L v vs)\n 4. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            v) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v)) =\n       subst\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n        (Lam\\<^sub>M\\<^sub>L v)\n 5. \\<And>\\<sigma> nm vs \\<sigma>'.\n       (\\<And>x \\<sigma>'.\n           x \\<in> set vs \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n            x) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs)) =\n       subst\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) (C\\<^sub>U nm vs)\n 6. \\<And>\\<sigma> x vs \\<sigma>'.\n       (\\<And>xa \\<sigma>'.\n           xa \\<in> set vs \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n            xa) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs)) =\n       subst\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) (V\\<^sub>U x vs)\n 7. \\<And>\\<sigma> v vs n \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst\\<^sub>M\\<^sub>L \\<sigma>'\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) v;\n        \\<And>x \\<sigma>'.\n           x \\<in> set vs \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) x\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n                          (Clo v vs n)\n 8. \\<And>\\<sigma> u v \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst\\<^sub>M\\<^sub>L \\<sigma>'\n                    (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) u;\n        \\<And>\\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n                          (apply u v)", "apply (simp_all add: list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            v) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n         V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n        v =\n       subst\\<^sub>M\\<^sub>L\n        (V\\<^sub>M\\<^sub>L 0 ##\n         (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>))\n        v", "apply(rule subst_ML_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            v) \\<Longrightarrow>\n       \\<forall>i.\n          (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n           V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n           i =\n          (V\\<^sub>M\\<^sub>L 0 ##\n           (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>))\n           i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            v) \\<Longrightarrow>\n       \\<forall>i>0.\n          subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')\n           (lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (i - Suc 0))) =\n          lift\\<^sub>M\\<^sub>L 0\n           (subst\\<^sub>M\\<^sub>L \\<sigma>' (\\<sigma> (i - Suc 0)))", "apply (metis o_apply subst_cons_lift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_ML_comp2:\n  \"\\<forall>i. \\<sigma>'' i = subst\\<^sub>M\\<^sub>L \\<sigma> (\\<sigma>' i) \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) = subst\\<^sub>M\\<^sub>L \\<sigma>'' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<sigma>'' i =\n       subst\\<^sub>M\\<^sub>L \\<sigma> (\\<sigma>' i) \\<Longrightarrow>\n    subst\\<^sub>M\\<^sub>L \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) =\n    subst\\<^sub>M\\<^sub>L \\<sigma>'' v", "by(simp add:subst_ML_comp subst_ML_ext)"], ["", "lemma closed_tm_ML_foldl_At:\n  \"closed\\<^sub>M\\<^sub>L k (t \\<bullet>\\<bullet> ts) \\<longleftrightarrow> closed\\<^sub>M\\<^sub>L k t \\<and> (\\<forall>t \\<in> set ts. closed\\<^sub>M\\<^sub>L k t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L k (t \\<bullet>\\<bullet> ts) =\n    (closed\\<^sub>M\\<^sub>L k t \\<and>\n     (\\<forall>t\\<in>set ts. closed\\<^sub>M\\<^sub>L k t))", "by(induct ts arbitrary: t) simp_all"], ["", "lemma closed_ML_lift[simp]:\n  fixes v :: ml shows \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> closed\\<^sub>M\\<^sub>L k (lift m v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L k (lift m v)", "by(induct k v arbitrary: m rule: lift_ML.induct)\n  (simp_all add:list_eq_iff_nth_eq)"], ["", "lemma closed_ML_Suc: \"closed\\<^sub>M\\<^sub>L n v \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc n) (lift\\<^sub>M\\<^sub>L k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L n v \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc n) (lift\\<^sub>M\\<^sub>L k v)", "by (induct k v arbitrary: n rule: lift_ML.induct) simp_all"], ["", "lemma closed_ML_subst_ML:\n  \"\\<forall>i. closed\\<^sub>M\\<^sub>L k (\\<sigma> i) \\<Longrightarrow> closed\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. closed\\<^sub>M\\<^sub>L k (\\<sigma> i) \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L k (subst\\<^sub>M\\<^sub>L \\<sigma> v)", "by(induct \\<sigma> v arbitrary: k rule: subst_ML.induct) (auto simp: closed_ML_Suc)"], ["", "lemma closed_ML_subst_ML2:\n  \"closed\\<^sub>M\\<^sub>L k v \\<Longrightarrow> \\<forall>i<k. closed\\<^sub>M\\<^sub>L l (\\<sigma> i) \\<Longrightarrow> closed\\<^sub>M\\<^sub>L l (subst\\<^sub>M\\<^sub>L \\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed\\<^sub>M\\<^sub>L k v;\n     \\<forall>i<k. closed\\<^sub>M\\<^sub>L l (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L l\n                       (subst\\<^sub>M\\<^sub>L \\<sigma> v)", "by(induct \\<sigma> v arbitrary: k l rule: subst_ML.induct)(auto simp: closed_ML_Suc)"], ["", "lemma subst_foldl[simp]:\n \"subst \\<sigma> (s \\<bullet>\\<bullet> ts) = (subst \\<sigma> s) \\<bullet>\\<bullet> (map (subst \\<sigma>) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (s \\<bullet>\\<bullet> ts) =\n    subst \\<sigma> s \\<bullet>\\<bullet> map (subst \\<sigma>) ts", "by (induct ts arbitrary: s) auto"], ["", "lemma subst_V: \"pure t \\<Longrightarrow> subst V t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> subst V t = t", "by(induct pred:pure) simp_all"], ["", "lemma lift_subst_aux:\n  \"pure t \\<Longrightarrow> \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i) \\<Longrightarrow>\n   \\<forall>i\\<ge>k. \\<sigma>'(Suc i) = lift k (\\<sigma> i) \\<Longrightarrow> \n  \\<sigma>' k = V k \\<Longrightarrow> lift k (subst \\<sigma> t) = subst \\<sigma>' (lift k t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n     \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n     \\<sigma>' k = V k\\<rbrakk>\n    \\<Longrightarrow> lift k (subst \\<sigma> t) = subst \\<sigma>' (lift k t)", "apply(induct arbitrary:\\<sigma> \\<sigma>' k pred:pure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma> \\<sigma>' k.\n       \\<lbrakk>\\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> lift k (subst \\<sigma> (C nm)) =\n                         subst \\<sigma>' (lift k (C nm))\n 2. \\<And>x \\<sigma> \\<sigma>' k.\n       \\<lbrakk>\\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> lift k (subst \\<sigma> (V x)) =\n                         subst \\<sigma>' (lift k (V x))\n 3. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' k.\n           \\<lbrakk>\\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n            \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n            \\<sigma>' k = V k\\<rbrakk>\n           \\<Longrightarrow> lift k (subst \\<sigma> t) =\n                             subst \\<sigma>' (lift k t);\n        \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> lift k (subst \\<sigma> (\\<Lambda> t)) =\n                         subst \\<sigma>' (lift k (\\<Lambda> t))\n 4. \\<And>s t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma> \\<sigma>' k.\n           \\<lbrakk>\\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n            \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n            \\<sigma>' k = V k\\<rbrakk>\n           \\<Longrightarrow> lift k (subst \\<sigma> s) =\n                             subst \\<sigma>' (lift k s);\n        pure t;\n        \\<And>\\<sigma> \\<sigma>' k.\n           \\<lbrakk>\\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n            \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n            \\<sigma>' k = V k\\<rbrakk>\n           \\<Longrightarrow> lift k (subst \\<sigma> t) =\n                             subst \\<sigma>' (lift k t);\n        \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> lift k (subst \\<sigma> (s \\<bullet> t)) =\n                         subst \\<sigma>' (lift k (s \\<bullet> t))", "apply (simp_all add: split:nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' k.\n           \\<lbrakk>\\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n            \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n            \\<sigma>' k = V k\\<rbrakk>\n           \\<Longrightarrow> lift k (subst \\<sigma> t) =\n                             subst \\<sigma>' (lift k t);\n        \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> lift (Suc k) (subst (V 0 ## \\<sigma>) t) =\n                         subst (V 0 ## \\<sigma>') (lift (Suc k) t)", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k;\n        \\<lbrakk>\\<forall>i<?k14 t \\<sigma> \\<sigma>' k.\n                    ?\\<sigma>'12 t \\<sigma> \\<sigma>' k i =\n                    lift (?k14 t \\<sigma> \\<sigma>' k)\n                     (?\\<sigma>10 t \\<sigma> \\<sigma>' k i);\n         \\<forall>i\\<ge>?k14 t \\<sigma> \\<sigma>' k.\n            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (Suc i) =\n            lift (?k14 t \\<sigma> \\<sigma>' k)\n             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i);\n         ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (?k14 t \\<sigma> \\<sigma>' k) =\n         V (?k14 t \\<sigma> \\<sigma>' k)\\<rbrakk>\n        \\<Longrightarrow> lift (?k14 t \\<sigma> \\<sigma>' k)\n                           (subst (?\\<sigma>10 t \\<sigma> \\<sigma>' k) t) =\n                          subst (?\\<sigma>'12 t \\<sigma> \\<sigma>' k)\n                           (lift (?k14 t \\<sigma> \\<sigma>' k) t)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc k) (subst (V 0 ## \\<sigma>) t) =\n                         subst (V 0 ## \\<sigma>') (lift (Suc k) t)", "apply(erule meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<?k14 t \\<sigma> \\<sigma>' k.\n                            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k i =\n                            lift (?k14 t \\<sigma> \\<sigma>' k)\n                             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i)\n 2. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k;\n        \\<lbrakk>\\<forall>i\\<ge>?k14 t \\<sigma> \\<sigma>' k.\n                    ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (Suc i) =\n                    lift (?k14 t \\<sigma> \\<sigma>' k)\n                     (?\\<sigma>10 t \\<sigma> \\<sigma>' k i);\n         ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (?k14 t \\<sigma> \\<sigma>' k) =\n         V (?k14 t \\<sigma> \\<sigma>' k)\\<rbrakk>\n        \\<Longrightarrow> lift (?k14 t \\<sigma> \\<sigma>' k)\n                           (subst (?\\<sigma>10 t \\<sigma> \\<sigma>' k) t) =\n                          subst (?\\<sigma>'12 t \\<sigma> \\<sigma>' k)\n                           (lift (?k14 t \\<sigma> \\<sigma>' k) t)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc k) (subst (V 0 ## \\<sigma>) t) =\n                         subst (V 0 ## \\<sigma>') (lift (Suc k) t)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k;\n        \\<lbrakk>\\<forall>i\\<ge>?k14 t \\<sigma> \\<sigma>' k.\n                    ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (Suc i) =\n                    lift (?k14 t \\<sigma> \\<sigma>' k)\n                     (?\\<sigma>10 t \\<sigma> \\<sigma>' k i);\n         ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (?k14 t \\<sigma> \\<sigma>' k) =\n         V (?k14 t \\<sigma> \\<sigma>' k)\\<rbrakk>\n        \\<Longrightarrow> lift (?k14 t \\<sigma> \\<sigma>' k)\n                           (subst (?\\<sigma>10 t \\<sigma> \\<sigma>' k) t) =\n                          subst (?\\<sigma>'12 t \\<sigma> \\<sigma>' k)\n                           (lift (?k14 t \\<sigma> \\<sigma>' k) t)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc k) (subst (V 0 ## \\<sigma>) t) =\n                         subst (V 0 ## \\<sigma>') (lift (Suc k) t)\n 2. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<?k14 t \\<sigma> \\<sigma>' k.\n                            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k i =\n                            lift (?k14 t \\<sigma> \\<sigma>' k)\n                             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i)", "apply(erule meta_impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>?k14 t \\<sigma> \\<sigma>' k.\n                            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (Suc i) =\n                            lift (?k14 t \\<sigma> \\<sigma>' k)\n                             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i)\n 2. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k;\n        ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (?k14 t \\<sigma> \\<sigma>' k) =\n        V (?k14 t \\<sigma> \\<sigma>' k) \\<Longrightarrow>\n        lift (?k14 t \\<sigma> \\<sigma>' k)\n         (subst (?\\<sigma>10 t \\<sigma> \\<sigma>' k) t) =\n        subst (?\\<sigma>'12 t \\<sigma> \\<sigma>' k)\n         (lift (?k14 t \\<sigma> \\<sigma>' k) t)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc k) (subst (V 0 ## \\<sigma>) t) =\n                         subst (V 0 ## \\<sigma>') (lift (Suc k) t)\n 3. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<?k14 t \\<sigma> \\<sigma>' k.\n                            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k i =\n                            lift (?k14 t \\<sigma> \\<sigma>' k)\n                             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i)", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k;\n        ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (?k14 t \\<sigma> \\<sigma>' k) =\n        V (?k14 t \\<sigma> \\<sigma>' k) \\<Longrightarrow>\n        lift (?k14 t \\<sigma> \\<sigma>' k)\n         (subst (?\\<sigma>10 t \\<sigma> \\<sigma>' k) t) =\n        subst (?\\<sigma>'12 t \\<sigma> \\<sigma>' k)\n         (lift (?k14 t \\<sigma> \\<sigma>' k) t)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc k) (subst (V 0 ## \\<sigma>) t) =\n                         subst (V 0 ## \\<sigma>') (lift (Suc k) t)\n 2. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<?k14 t \\<sigma> \\<sigma>' k.\n                            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k i =\n                            lift (?k14 t \\<sigma> \\<sigma>' k)\n                             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i)\n 3. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>?k14 t \\<sigma> \\<sigma>' k.\n                            ?\\<sigma>'12 t \\<sigma> \\<sigma>' k (Suc i) =\n                            lift (?k14 t \\<sigma> \\<sigma>' k)\n                             (?\\<sigma>10 t \\<sigma> \\<sigma>' k i)", "apply(erule meta_mp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> (V 0 ## \\<sigma>') (Suc k) = V (Suc k)\n 2. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<Suc k.\n                            (V 0 ## \\<sigma>') i =\n                            lift (Suc k) ((V 0 ## \\<sigma>) i)\n 3. \\<And>t \\<sigma> \\<sigma>' k.\n       \\<lbrakk>pure t; \\<forall>i<k. \\<sigma>' i = lift k (\\<sigma> i);\n        \\<forall>i\\<ge>k. \\<sigma>' (Suc i) = lift k (\\<sigma> i);\n        \\<sigma>' k = V k\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i\\<ge>Suc k.\n                            (V 0 ## \\<sigma>') (Suc i) =\n                            lift (Suc k) ((V 0 ## \\<sigma>) i)", "apply (simp_all add: cons_def lift_lift_ml lift_lift_tm split:nat.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary lift_subst:\n  \"pure t \\<Longrightarrow> lift 0 (subst \\<sigma> t) = subst (V 0 ## \\<sigma>) (lift 0 t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow>\n    lift 0 (subst \\<sigma> t) = subst (V 0 ## \\<sigma>) (lift 0 t)", "by (simp add: lift_subst_aux lift_lift_ml)"], ["", "lemma subst_comp:\n  \"pure t \\<Longrightarrow> \\<forall>i. pure(\\<sigma>' i) \\<Longrightarrow>\n   \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i)) \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) = subst \\<sigma>'' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n     \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n    \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                      subst \\<sigma>'' t", "apply(induct arbitrary:\\<sigma> \\<sigma>' \\<sigma>'' pred:pure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (C nm)) =\n                         subst \\<sigma>'' (C nm)\n 2. \\<And>x \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (V x)) =\n                         subst \\<sigma>'' (V x)\n 3. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (\\<Lambda> t)) =\n                         subst \\<sigma>'' (\\<Lambda> t)\n 4. \\<And>s t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' s) =\n                             subst \\<sigma>'' s;\n        pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (s \\<bullet> t)) =\n                         subst \\<sigma>'' (s \\<bullet> t)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (V x)) =\n                         subst \\<sigma>'' (V x)\n 2. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (\\<Lambda> t)) =\n                         subst \\<sigma>'' (\\<Lambda> t)\n 3. \\<And>s t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' s) =\n                             subst \\<sigma>'' s;\n        pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (s \\<bullet> t)) =\n                         subst \\<sigma>'' (s \\<bullet> t)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (\\<Lambda> t)) =\n                         subst \\<sigma>'' (\\<Lambda> t)\n 2. \\<And>s t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' s) =\n                             subst \\<sigma>'' s;\n        pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (s \\<bullet> t)) =\n                         subst \\<sigma>'' (s \\<bullet> t)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' s) =\n                             subst \\<sigma>'' s;\n        pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (s \\<bullet> t)) =\n                         subst \\<sigma>'' (s \\<bullet> t)\n 2. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (\\<Lambda> t)) =\n                         subst \\<sigma>'' (\\<Lambda> t)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' (\\<Lambda> t)) =\n                         subst \\<sigma>'' (\\<Lambda> t)", "apply (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n           \\<lbrakk>\\<forall>i. pure (\\<sigma>' i);\n            \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n           \\<Longrightarrow> subst \\<sigma> (subst \\<sigma>' t) =\n                             subst \\<sigma>'' t;\n        \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## \\<sigma>)\n                          (subst (V 0 ## \\<sigma>') t) =\n                         subst (V 0 ## \\<sigma>'') t", "apply(erule meta_allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i));\n        \\<lbrakk>\\<forall>i.\n                    pure (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'' i);\n         ?\\<sigma>''8 t \\<sigma> \\<sigma>' \\<sigma>'' =\n         (\\<lambda>i.\n             subst (?\\<sigma>4 t \\<sigma> \\<sigma>' \\<sigma>'')\n              (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'' i))\\<rbrakk>\n        \\<Longrightarrow> subst (?\\<sigma>4 t \\<sigma> \\<sigma>' \\<sigma>'')\n                           (subst\n                             (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'')\n                             t) =\n                          subst\n                           (?\\<sigma>''8 t \\<sigma> \\<sigma>' \\<sigma>'')\n                           t\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## \\<sigma>)\n                          (subst (V 0 ## \\<sigma>') t) =\n                         subst (V 0 ## \\<sigma>'') t", "apply(erule meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i.\n                            pure\n                             (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'' i)\n 2. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i));\n        ?\\<sigma>''8 t \\<sigma> \\<sigma>' \\<sigma>'' =\n        (\\<lambda>i.\n            subst (?\\<sigma>4 t \\<sigma> \\<sigma>' \\<sigma>'')\n             (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>''\n               i)) \\<Longrightarrow>\n        subst (?\\<sigma>4 t \\<sigma> \\<sigma>' \\<sigma>'')\n         (subst (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'') t) =\n        subst (?\\<sigma>''8 t \\<sigma> \\<sigma>' \\<sigma>'') t\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## \\<sigma>)\n                          (subst (V 0 ## \\<sigma>') t) =\n                         subst (V 0 ## \\<sigma>'') t", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i));\n        ?\\<sigma>''8 t \\<sigma> \\<sigma>' \\<sigma>'' =\n        (\\<lambda>i.\n            subst (?\\<sigma>4 t \\<sigma> \\<sigma>' \\<sigma>'')\n             (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>''\n               i)) \\<Longrightarrow>\n        subst (?\\<sigma>4 t \\<sigma> \\<sigma>' \\<sigma>'')\n         (subst (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'') t) =\n        subst (?\\<sigma>''8 t \\<sigma> \\<sigma>' \\<sigma>'') t\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## \\<sigma>)\n                          (subst (V 0 ## \\<sigma>') t) =\n                         subst (V 0 ## \\<sigma>'') t\n 2. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i.\n                            pure\n                             (?\\<sigma>'6 t \\<sigma> \\<sigma>' \\<sigma>'' i)", "apply(erule meta_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> V 0 ## \\<sigma>'' =\n                         (\\<lambda>i.\n                             subst (V 0 ## \\<sigma>) ((V 0 ## \\<sigma>') i))\n 2. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i. pure ((V 0 ## \\<sigma>') i)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i. pure ((V 0 ## \\<sigma>') i)\n 2. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> V 0 ## \\<sigma>'' =\n                         (\\<lambda>i.\n                             subst (V 0 ## \\<sigma>) ((V 0 ## \\<sigma>') i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> V 0 ## \\<sigma>'' =\n                         (\\<lambda>i.\n                             subst (V 0 ## \\<sigma>) ((V 0 ## \\<sigma>') i))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' \\<sigma>'' i.\n       \\<lbrakk>pure t; \\<forall>i. pure (\\<sigma>' i);\n        \\<sigma>'' = (\\<lambda>i. subst \\<sigma> (\\<sigma>' i))\\<rbrakk>\n       \\<Longrightarrow> (V 0 ## \\<sigma>'') i =\n                         subst (V 0 ## \\<sigma>) ((V 0 ## \\<sigma>') i)", "apply(simp add:lift_subst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \"Reduction\""], ["", "subsection \"Patterns\""], ["", "inductive pattern :: \"tm \\<Rightarrow> bool\"\n      and patterns :: \"tm list \\<Rightarrow> bool\" where\n       \"patterns ts \\<equiv> \\<forall>t\\<in>set ts. pattern t\" |\npat_V: \"pattern(V X)\" |\npat_C: \"patterns ts \\<Longrightarrow> pattern(C nm \\<bullet>\\<bullet> ts)\""], ["", "lemma pattern_Lam[simp]: \"\\<not> pattern(\\<Lambda> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> pattern (\\<Lambda> t)", "by(auto elim!: pattern.cases)"], ["", "lemma pattern_At'D12: \"pattern r \\<Longrightarrow> r = (s \\<bullet> t) \\<Longrightarrow> pattern s \\<and> pattern t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pattern r; r = s \\<bullet> t\\<rbrakk>\n    \\<Longrightarrow> pattern s \\<and> pattern t", "proof(induct arbitrary: s t pred:pattern)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X s t.\n       V X = s \\<bullet> t \\<Longrightarrow> pattern s \\<and> pattern t\n 2. \\<And>ts nm s t.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   pattern t \\<and>\n                   (\\<forall>x xa.\n                       t = x \\<bullet> xa \\<longrightarrow>\n                       pattern x \\<and> pattern xa);\n        C nm \\<bullet>\\<bullet> ts = s \\<bullet> t\\<rbrakk>\n       \\<Longrightarrow> pattern s \\<and> pattern t", "case pat_V"], ["proof (state)\nthis:\n  V X_ = s \\<bullet> t\n\ngoal (2 subgoals):\n 1. \\<And>X s t.\n       V X = s \\<bullet> t \\<Longrightarrow> pattern s \\<and> pattern t\n 2. \\<And>ts nm s t.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   pattern t \\<and>\n                   (\\<forall>x xa.\n                       t = x \\<bullet> xa \\<longrightarrow>\n                       pattern x \\<and> pattern xa);\n        C nm \\<bullet>\\<bullet> ts = s \\<bullet> t\\<rbrakk>\n       \\<Longrightarrow> pattern s \\<and> pattern t", "thus ?case"], ["proof (prove)\nusing this:\n  V X_ = s \\<bullet> t\n\ngoal (1 subgoal):\n 1. pattern s \\<and> pattern t", "by simp"], ["proof (state)\nthis:\n  pattern s \\<and> pattern t\n\ngoal (1 subgoal):\n 1. \\<And>ts nm s t.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   pattern t \\<and>\n                   (\\<forall>x xa.\n                       t = x \\<bullet> xa \\<longrightarrow>\n                       pattern x \\<and> pattern xa);\n        C nm \\<bullet>\\<bullet> ts = s \\<bullet> t\\<rbrakk>\n       \\<Longrightarrow> pattern s \\<and> pattern t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts nm s t.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   pattern t \\<and>\n                   (\\<forall>x xa.\n                       t = x \\<bullet> xa \\<longrightarrow>\n                       pattern x \\<and> pattern xa);\n        C nm \\<bullet>\\<bullet> ts = s \\<bullet> t\\<rbrakk>\n       \\<Longrightarrow> pattern s \\<and> pattern t", "case pat_C"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ts_.\n     pattern t \\<and>\n     (\\<forall>x xa.\n         t = x \\<bullet> xa \\<longrightarrow> pattern x \\<and> pattern xa)\n  C nm_ \\<bullet>\\<bullet> ts_ = s \\<bullet> t\n\ngoal (1 subgoal):\n 1. \\<And>ts nm s t.\n       \\<lbrakk>\\<forall>t\\<in>set ts.\n                   pattern t \\<and>\n                   (\\<forall>x xa.\n                       t = x \\<bullet> xa \\<longrightarrow>\n                       pattern x \\<and> pattern xa);\n        C nm \\<bullet>\\<bullet> ts = s \\<bullet> t\\<rbrakk>\n       \\<Longrightarrow> pattern s \\<and> pattern t", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set ts_.\n     pattern t \\<and>\n     (\\<forall>x xa.\n         t = x \\<bullet> xa \\<longrightarrow> pattern x \\<and> pattern xa)\n  C nm_ \\<bullet>\\<bullet> ts_ = s \\<bullet> t\n\ngoal (1 subgoal):\n 1. pattern s \\<and> pattern t", "by (simp add: atomic_tm_head_tm split:if_split_asm)\n       (metis eta_head_args in_set_butlastD pattern.pat_C)"], ["proof (state)\nthis:\n  pattern s \\<and> pattern t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pattern_AtD12: \"pattern(s \\<bullet> t) \\<Longrightarrow> pattern s \\<and> pattern t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern (s \\<bullet> t) \\<Longrightarrow> pattern s \\<and> pattern t", "by(metis pattern_At'D12)"], ["", "lemma pattern_At_vecD: \"pattern(s \\<bullet>\\<bullet> ts) \\<Longrightarrow> patterns ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern (s \\<bullet>\\<bullet> ts) \\<Longrightarrow> patterns ts", "apply(induct ts rule:rev_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. pattern (s \\<bullet>\\<bullet> []) \\<Longrightarrow> patterns []\n 2. \\<And>x xs.\n       \\<lbrakk>pattern (s \\<bullet>\\<bullet> xs) \\<Longrightarrow>\n                patterns xs;\n        pattern (s \\<bullet>\\<bullet> (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> patterns (xs @ [x])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>pattern (s \\<bullet>\\<bullet> xs) \\<Longrightarrow>\n                patterns xs;\n        pattern (s \\<bullet>\\<bullet> (xs @ [x]))\\<rbrakk>\n       \\<Longrightarrow> patterns (xs @ [x])", "apply (fastforce dest!:pattern_AtD12)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pattern_At_decomp: \"pattern(s \\<bullet> t) \\<Longrightarrow> \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern (s \\<bullet> t) \\<Longrightarrow>\n    \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss", "proof(induct s arbitrary: t)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x t.\n       pattern (C x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. C x = C nm \\<bullet>\\<bullet> ss\n 2. \\<And>x t.\n       pattern (V x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. V x = C nm \\<bullet>\\<bullet> ss\n 3. \\<And>s t.\n       \\<lbrakk>\\<And>t.\n                   pattern (s \\<bullet> t) \\<Longrightarrow>\n                   \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss;\n        pattern (\\<Lambda> s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ss.\n                            \\<Lambda> s = C nm \\<bullet>\\<bullet> ss\n 4. \\<And>s1 s2 t.\n       \\<lbrakk>\\<And>t.\n                   pattern (s1 \\<bullet> t) \\<Longrightarrow>\n                   \\<exists>nm ss. s1 = C nm \\<bullet>\\<bullet> ss;\n        \\<And>t.\n           pattern (s2 \\<bullet> t) \\<Longrightarrow>\n           \\<exists>nm ss. s2 = C nm \\<bullet>\\<bullet> ss;\n        pattern ((s1 \\<bullet> s2) \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ss.\n                            s1 \\<bullet> s2 = C nm \\<bullet>\\<bullet> ss\n 5. \\<And>x t.\n       pattern (term x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. term x = C nm \\<bullet>\\<bullet> ss", "case (At s1 s2)"], ["proof (state)\nthis:\n  pattern (s1 \\<bullet> ?t) \\<Longrightarrow>\n  \\<exists>nm ss. s1 = C nm \\<bullet>\\<bullet> ss\n  pattern (s2 \\<bullet> ?t) \\<Longrightarrow>\n  \\<exists>nm ss. s2 = C nm \\<bullet>\\<bullet> ss\n  pattern ((s1 \\<bullet> s2) \\<bullet> t)\n\ngoal (5 subgoals):\n 1. \\<And>x t.\n       pattern (C x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. C x = C nm \\<bullet>\\<bullet> ss\n 2. \\<And>x t.\n       pattern (V x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. V x = C nm \\<bullet>\\<bullet> ss\n 3. \\<And>s t.\n       \\<lbrakk>\\<And>t.\n                   pattern (s \\<bullet> t) \\<Longrightarrow>\n                   \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss;\n        pattern (\\<Lambda> s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ss.\n                            \\<Lambda> s = C nm \\<bullet>\\<bullet> ss\n 4. \\<And>s1 s2 t.\n       \\<lbrakk>\\<And>t.\n                   pattern (s1 \\<bullet> t) \\<Longrightarrow>\n                   \\<exists>nm ss. s1 = C nm \\<bullet>\\<bullet> ss;\n        \\<And>t.\n           pattern (s2 \\<bullet> t) \\<Longrightarrow>\n           \\<exists>nm ss. s2 = C nm \\<bullet>\\<bullet> ss;\n        pattern ((s1 \\<bullet> s2) \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ss.\n                            s1 \\<bullet> s2 = C nm \\<bullet>\\<bullet> ss\n 5. \\<And>x t.\n       pattern (term x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. term x = C nm \\<bullet>\\<bullet> ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>nm ss. s1 \\<bullet> s2 = C nm \\<bullet>\\<bullet> ss", "using At"], ["proof (prove)\nusing this:\n  pattern (s1 \\<bullet> ?t) \\<Longrightarrow>\n  \\<exists>nm ss. s1 = C nm \\<bullet>\\<bullet> ss\n  pattern (s2 \\<bullet> ?t) \\<Longrightarrow>\n  \\<exists>nm ss. s2 = C nm \\<bullet>\\<bullet> ss\n  pattern ((s1 \\<bullet> s2) \\<bullet> t)\n\ngoal (1 subgoal):\n 1. \\<exists>nm ss. s1 \\<bullet> s2 = C nm \\<bullet>\\<bullet> ss", "by (metis foldl_Cons foldl_Nil foldl_append pattern_AtD12)"], ["proof (state)\nthis:\n  \\<exists>nm ss. s1 \\<bullet> s2 = C nm \\<bullet>\\<bullet> ss\n\ngoal (4 subgoals):\n 1. \\<And>x t.\n       pattern (C x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. C x = C nm \\<bullet>\\<bullet> ss\n 2. \\<And>x t.\n       pattern (V x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. V x = C nm \\<bullet>\\<bullet> ss\n 3. \\<And>s t.\n       \\<lbrakk>\\<And>t.\n                   pattern (s \\<bullet> t) \\<Longrightarrow>\n                   \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss;\n        pattern (\\<Lambda> s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ss.\n                            \\<Lambda> s = C nm \\<bullet>\\<bullet> ss\n 4. \\<And>x t.\n       pattern (term x \\<bullet> t) \\<Longrightarrow>\n       \\<exists>nm ss. term x = C nm \\<bullet>\\<bullet> ss", "qed (auto elim!: pattern.cases split:if_split_asm)"], ["", "subsection \"Reduction of \\<open>\\<lambda>\\<close>-terms\""], ["", "text\\<open>The source program:\\<close>"], ["", "axiomatization R :: \"(cname * tm list * tm)set\" where\npure_R: \"(nm,ts,t) : R \\<Longrightarrow> (\\<forall>t \\<in> set ts. pure t) \\<and> pure t\" and\nfv_R:   \"(nm,ts,t) : R \\<Longrightarrow> X : fv t \\<Longrightarrow> \\<exists>t' \\<in> set ts. X : fv t'\" and\npattern_R: \"(nm,ts,t') : R \\<Longrightarrow> patterns ts\""], ["", "inductive_set\n  Red_tm :: \"(tm * tm)set\"\n  and red_tm :: \"[tm, tm] => bool\"  (infixl \"\\<rightarrow>\" 50)\nwhere\n  \"s \\<rightarrow> t \\<equiv> (s, t) \\<in> Red_tm\"\n \\<comment> \\<open>$\\beta$-reduction\\<close>\n| \"(\\<Lambda> t) \\<bullet> s \\<rightarrow> t[s/0]\"\n \\<comment> \\<open>$\\eta$-expansion\\<close>\n| \"t \\<rightarrow> \\<Lambda> ((lift 0 t) \\<bullet> (V 0))\"\n \\<comment> \\<open>Rewriting\\<close>\n| \"(nm,ts,t) : R \\<Longrightarrow> (C nm) \\<bullet>\\<bullet> (map (subst \\<sigma>) ts) \\<rightarrow> subst \\<sigma> t\"\n| \"t \\<rightarrow> t' \\<Longrightarrow> \\<Lambda> t \\<rightarrow> \\<Lambda> t'\"\n| \"s \\<rightarrow> s' \\<Longrightarrow> s \\<bullet> t \\<rightarrow> s' \\<bullet> t\"\n| \"t \\<rightarrow> t' \\<Longrightarrow> s \\<bullet> t \\<rightarrow> s \\<bullet> t'\""], ["", "abbreviation\n  reds_tm :: \"[tm, tm] => bool\"  (infixl \"\\<rightarrow>*\" 50) where\n  \"s \\<rightarrow>* t \\<equiv> (s, t) \\<in> Red_tm^*\""], ["", "inductive_set\n  Reds_tm_list :: \"(tm list * tm list) set\"\n  and reds_tm_list :: \"[tm list, tm list] \\<Rightarrow> bool\" (infixl \"\\<rightarrow>*\" 50)\nwhere\n  \"ss \\<rightarrow>* ts \\<equiv> (ss, ts) \\<in> Reds_tm_list\"\n| \"[] \\<rightarrow>* []\"\n| \"ts \\<rightarrow>* ts' \\<Longrightarrow> t \\<rightarrow>* t' \\<Longrightarrow> t#ts \\<rightarrow>* t'#ts'\""], ["", "declare Reds_tm_list.intros[simp]"], ["", "lemma Reds_tm_list_refl[simp]: fixes ts :: \"tm list\" shows \"ts \\<rightarrow>* ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<rightarrow>* ts", "by(induct ts) auto"], ["", "lemma Red_tm_append: \"rs \\<rightarrow>* rs' \\<Longrightarrow> ts \\<rightarrow>* ts' \\<Longrightarrow> rs @ ts \\<rightarrow>* rs' @ ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rs \\<rightarrow>* rs'; ts \\<rightarrow>* ts'\\<rbrakk>\n    \\<Longrightarrow> rs @ ts \\<rightarrow>* rs' @ ts'", "by(induct set: Reds_tm_list) auto"], ["", "lemma Red_tm_rev: \"ts \\<rightarrow>* ts' \\<Longrightarrow> rev ts \\<rightarrow>* rev ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<rightarrow>* ts' \\<Longrightarrow> rev ts \\<rightarrow>* rev ts'", "by(induct set: Reds_tm_list) (auto simp:Red_tm_append)"], ["", "lemma red_Lam[simp]: \"t \\<rightarrow>* t' \\<Longrightarrow> \\<Lambda> t \\<rightarrow>* \\<Lambda> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t' \\<Longrightarrow>\n    \\<Lambda> t \\<rightarrow>* \\<Lambda> t'", "apply(induct rule:rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Lambda> t \\<rightarrow>* \\<Lambda> t\n 2. \\<And>y z.\n       \\<lbrakk>t \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<Lambda> t \\<rightarrow>* \\<Lambda> y\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t \\<rightarrow>* \\<Lambda> z", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>t \\<rightarrow>* y; y \\<rightarrow> z;\n        \\<Lambda> t \\<rightarrow>* \\<Lambda> y\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t \\<rightarrow>* \\<Lambda> z", "apply(blast intro: rtrancl_into_rtrancl Red_tm.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_At1[simp]: \"t \\<rightarrow>* t' \\<Longrightarrow> t \\<bullet> s \\<rightarrow>* t' \\<bullet> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t' \\<Longrightarrow>\n    t \\<bullet> s \\<rightarrow>* t' \\<bullet> s", "apply(induct rule:rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t \\<bullet> s \\<rightarrow>* t \\<bullet> s\n 2. \\<And>y z.\n       \\<lbrakk>t \\<rightarrow>* y; y \\<rightarrow> z;\n        t \\<bullet> s \\<rightarrow>* y \\<bullet> s\\<rbrakk>\n       \\<Longrightarrow> t \\<bullet> s \\<rightarrow>* z \\<bullet> s", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>t \\<rightarrow>* y; y \\<rightarrow> z;\n        t \\<bullet> s \\<rightarrow>* y \\<bullet> s\\<rbrakk>\n       \\<Longrightarrow> t \\<bullet> s \\<rightarrow>* z \\<bullet> s", "apply(blast intro: rtrancl_into_rtrancl Red_tm.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma red_At2[simp]: \"t \\<rightarrow>* t' \\<Longrightarrow> s \\<bullet> t \\<rightarrow>* s \\<bullet> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t' \\<Longrightarrow>\n    s \\<bullet> t \\<rightarrow>* s \\<bullet> t'", "apply(induct rule:rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<bullet> t \\<rightarrow>* s \\<bullet> t\n 2. \\<And>y z.\n       \\<lbrakk>t \\<rightarrow>* y; y \\<rightarrow> z;\n        s \\<bullet> t \\<rightarrow>* s \\<bullet> y\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t \\<rightarrow>* s \\<bullet> z", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>t \\<rightarrow>* y; y \\<rightarrow> z;\n        s \\<bullet> t \\<rightarrow>* s \\<bullet> y\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t \\<rightarrow>* s \\<bullet> z", "apply(blast intro:rtrancl_into_rtrancl Red_tm.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Reds_tm_list_foldl_At:\n \"ts \\<rightarrow>* ts' \\<Longrightarrow> s \\<rightarrow>* s' \\<Longrightarrow> s \\<bullet>\\<bullet> ts \\<rightarrow>* s' \\<bullet>\\<bullet> ts'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts \\<rightarrow>* ts'; s \\<rightarrow>* s'\\<rbrakk>\n    \\<Longrightarrow> s \\<bullet>\\<bullet> ts \\<rightarrow>*\n                      s' \\<bullet>\\<bullet> ts'", "apply(induct arbitrary:s s' rule:Reds_tm_list.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       s \\<rightarrow>* s' \\<Longrightarrow>\n       s \\<bullet>\\<bullet> [] \\<rightarrow>* s' \\<bullet>\\<bullet> []\n 2. \\<And>ts ts' t t' s s'.\n       \\<lbrakk>ts \\<rightarrow>* ts';\n        \\<And>s s'.\n           s \\<rightarrow>* s' \\<Longrightarrow>\n           s \\<bullet>\\<bullet> ts \\<rightarrow>* s' \\<bullet>\\<bullet> ts';\n        t \\<rightarrow>* t'; s \\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet>\\<bullet> (t # ts) \\<rightarrow>*\n                         s' \\<bullet>\\<bullet> (t' # ts')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts ts' t t' s s'.\n       \\<lbrakk>ts \\<rightarrow>* ts';\n        \\<And>s s'.\n           s \\<rightarrow>* s' \\<Longrightarrow>\n           s \\<bullet>\\<bullet> ts \\<rightarrow>* s' \\<bullet>\\<bullet> ts';\n        t \\<rightarrow>* t'; s \\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet>\\<bullet> (t # ts) \\<rightarrow>*\n                         s' \\<bullet>\\<bullet> (t' # ts')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts ts' t t' s s'.\n       \\<lbrakk>ts \\<rightarrow>* ts';\n        \\<And>s s'.\n           s \\<rightarrow>* s' \\<Longrightarrow>\n           s \\<bullet>\\<bullet> ts \\<rightarrow>* s' \\<bullet>\\<bullet> ts';\n        t \\<rightarrow>* t'; s \\<rightarrow>* s'\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t \\<bullet>\\<bullet> ts \\<rightarrow>*\n                         s' \\<bullet> t' \\<bullet>\\<bullet> ts'", "apply(blast dest: red_At1 red_At2 intro:rtrancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Reduction of ML-terms\""], ["", "text\\<open>The compiled rule set:\\<close>"], ["", "consts compR :: \"(cname * ml list * ml)set\""], ["", "text\\<open>\\noindent\nThe actual definition is given in \\S\\ref{sec:Compiler} below.\\<close>"], ["", "text\\<open>Now we characterize ML values that cannot possibly be rewritten by a\nrule in @{const compR}.\\<close>"], ["", "lemma termination_no_match_ML:\n  \"i < length ps \\<Longrightarrow> rev ps ! i = C\\<^sub>U nm vs\n   \\<Longrightarrow> sum_list (map size vs) < sum_list (map size ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ps; rev ps ! i = C\\<^sub>U nm vs\\<rbrakk>\n    \\<Longrightarrow> sum_list (map size vs) < sum_list (map size ps)", "apply(subgoal_tac \"C\\<^sub>U nm vs : set ps\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n     C\\<^sub>U nm vs \\<in> set ps\\<rbrakk>\n    \\<Longrightarrow> sum_list (map size vs) < sum_list (map size ps)\n 2. \\<lbrakk>i < length ps; rev ps ! i = C\\<^sub>U nm vs\\<rbrakk>\n    \\<Longrightarrow> C\\<^sub>U nm vs \\<in> set ps", "apply(drule sum_list_map_remove1[of _ _ size])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n     sum_list (map size ps) =\n     size (C\\<^sub>U nm vs) +\n     sum_list (map size (remove1 (C\\<^sub>U nm vs) ps))\\<rbrakk>\n    \\<Longrightarrow> sum_list (map size vs) < sum_list (map size ps)\n 2. \\<lbrakk>i < length ps; rev ps ! i = C\\<^sub>U nm vs\\<rbrakk>\n    \\<Longrightarrow> C\\<^sub>U nm vs \\<in> set ps", "apply (simp add:size_list_conv_sum_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ps; rev ps ! i = C\\<^sub>U nm vs\\<rbrakk>\n    \\<Longrightarrow> C\\<^sub>U nm vs \\<in> set ps", "apply (metis in_set_conv_nth length_rev set_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare conj_cong[fundef_cong]"], ["", "function no_match_ML (\"no'_match\\<^sub>M\\<^sub>L\") where\n\"no_match\\<^sub>M\\<^sub>L ps os =\n  (\\<exists>i < min (size os) (size ps).\n   \\<exists>nm nm' vs vs'. (rev ps)!i = C\\<^sub>U nm vs \\<and> (rev os)!i = C\\<^sub>U nm' vs' \\<and>\n      (nm=nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>ps os. x = (ps, os) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>ps os psa osa.\n       (ps, os) = (psa, osa) \\<Longrightarrow>\n       (\\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match_ML_sumC (vs, vs'))) =\n       (\\<exists>i<min (length osa) (length psa).\n           \\<exists>nm nm' vs vs'.\n              rev psa ! i = C\\<^sub>U nm vs \\<and>\n              rev osa ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match_ML_sumC (vs, vs')))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All no_match_ML_dom", "apply(relation \"measure(%(vs::ml list,_). \\<Sum>v\\<leftarrow>vs. size v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(vs, uu_). sum_list (map size vs)))\n 2. \\<And>ps os x xa xb xc xd.\n       \\<lbrakk>x < min (length os) (length ps);\n        rev ps ! x = C\\<^sub>U xa xc; rev os ! x = C\\<^sub>U xb xd;\n        xa = xb\\<rbrakk>\n       \\<Longrightarrow> ((xc, xd), ps, os)\n                         \\<in> measure\n                                (\\<lambda>(vs, uu_). sum_list (map size vs))", "apply (auto simp:termination_no_match_ML)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "abbreviation\n\"no_match_compR nm os \\<equiv>\n  \\<forall>(nm',ps,v)\\<in> compR. nm=nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L ps os\""], ["", "declare no_match_ML.simps[simp del]"], ["", "inductive_set\n  Red_ml :: \"(ml * ml)set\"\n  and Red_ml_list :: \"(ml list * ml list)set\"\n  and red_ml :: \"[ml, ml] => bool\"  (infixl \"\\<Rightarrow>\" 50)\n  and red_ml_list :: \"[ml list, ml list] => bool\"  (infixl \"\\<Rightarrow>\" 50)\n  and reds_ml :: \"[ml, ml] => bool\"  (infixl \"\\<Rightarrow>*\" 50)\nwhere\n  \"s \\<Rightarrow> t \\<equiv> (s, t) \\<in> Red_ml\"\n| \"ss \\<Rightarrow> ts \\<equiv> (ss, ts) \\<in> Red_ml_list\"\n| \"s \\<Rightarrow>* t \\<equiv> (s, t) \\<in> Red_ml^*\"\n \\<comment> \\<open>ML $\\beta$-reduction\\<close>\n| \"A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v] \\<Rightarrow> u[v/0]\"\n \\<comment> \\<open>Execution of a compiled rewrite rule\\<close>\n| \"(nm,vs,v) : compR \\<Longrightarrow> \\<forall> i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs) \\<Rightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> v\"\n\\<comment> \\<open>default rule:\\<close>\n| \"\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n   \\<Longrightarrow> vs = map V\\<^sub>M\\<^sub>L [0..<arity nm] \\<Longrightarrow> vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs\n   \\<Longrightarrow> no_match_compR nm vs'\n   \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs' \\<Rightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs)\"\n \\<comment> \\<open>Equations for function \\texttt{apply}\\<close>\n| apply_Clo1: \"apply (Clo f vs (Suc 0)) v \\<Rightarrow> A\\<^sub>M\\<^sub>L f (v # vs)\"\n| apply_Clo2: \"n > 0 \\<Longrightarrow>\n apply (Clo f vs (Suc n)) v \\<Rightarrow> Clo f (v # vs) n\"\n| apply_C: \"apply (C\\<^sub>U nm vs) v \\<Rightarrow> C\\<^sub>U nm (v # vs)\"\n| apply_V: \"apply (V\\<^sub>U x vs) v \\<Rightarrow> V\\<^sub>U x (v # vs)\"\n \\<comment> \\<open>Context rules\\<close>\n| ctxt_C: \"vs \\<Rightarrow> vs' \\<Longrightarrow> C\\<^sub>U nm vs \\<Rightarrow> C\\<^sub>U nm vs'\"\n| ctxt_V: \"vs \\<Rightarrow> vs' \\<Longrightarrow> V\\<^sub>U x vs \\<Rightarrow> V\\<^sub>U x vs'\"\n| ctxt_Clo1: \"f \\<Rightarrow> f'   \\<Longrightarrow> Clo f vs n \\<Rightarrow> Clo f' vs n\"\n| ctxt_Clo3: \"vs \\<Rightarrow> vs' \\<Longrightarrow> Clo f vs n \\<Rightarrow> Clo f vs' n\"\n| ctxt_apply1: \"s \\<Rightarrow> s'   \\<Longrightarrow> apply s t \\<Rightarrow> apply s' t\"\n| ctxt_apply2: \"t \\<Rightarrow> t'   \\<Longrightarrow> apply s t \\<Rightarrow> apply s t'\"\n| ctxt_A_ML1: \"f \\<Rightarrow> f'   \\<Longrightarrow> A\\<^sub>M\\<^sub>L f vs \\<Rightarrow> A\\<^sub>M\\<^sub>L f' vs\"\n| ctxt_A_ML2: \"vs \\<Rightarrow> vs' \\<Longrightarrow> A\\<^sub>M\\<^sub>L f vs \\<Rightarrow> A\\<^sub>M\\<^sub>L f vs'\"\n| ctxt_list1: \"v \\<Rightarrow> v'   \\<Longrightarrow> v#vs \\<Rightarrow> v'#vs\"\n| ctxt_list2: \"vs \\<Rightarrow> vs' \\<Longrightarrow> v#vs \\<Rightarrow> v#vs'\""], ["", "inductive_set\n  Red_term :: \"(tm * tm)set\"\n  and red_term :: \"[tm, tm] => bool\"  (infixl \"\\<Rightarrow>\" 50)\n  and reds_term :: \"[tm, tm] => bool\"  (infixl \"\\<Rightarrow>*\" 50)\nwhere\n  \"s \\<Rightarrow> t \\<equiv> (s, t) \\<in> Red_term\"\n| \"s \\<Rightarrow>* t \\<equiv> (s, t) \\<in> Red_term^*\"\n \\<comment> \\<open>function \\texttt{term}\\<close>\n| term_C: \"term (C\\<^sub>U nm vs) \\<Rightarrow> (C nm) \\<bullet>\\<bullet> (map term (rev vs))\"\n| term_V: \"term (V\\<^sub>U x vs) \\<Rightarrow> (V x) \\<bullet>\\<bullet> (map term (rev vs))\"\n| term_Clo: \"term(Clo vf vs n) \\<Rightarrow> \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\"\n \\<comment> \\<open>context rules\\<close>\n| ctxt_Lam: \"t \\<Rightarrow> t' \\<Longrightarrow> \\<Lambda> t \\<Rightarrow> \\<Lambda> t'\"\n| ctxt_At1: \"s \\<Rightarrow> s' \\<Longrightarrow> s \\<bullet> t \\<Rightarrow> s' \\<bullet> t\"\n| ctxt_At2: \"t \\<Rightarrow> t' \\<Longrightarrow> s \\<bullet> t \\<Rightarrow> s \\<bullet> t'\"\n| ctxt_term: \"v \\<Rightarrow> v' \\<Longrightarrow> term v \\<Rightarrow> term v'\""], ["", "section \"Kernel\""], ["", "text\\<open>First a special size function and some lemmas for the\ntermination proof of the kernel function.\\<close>"], ["", "fun size' :: \"ml \\<Rightarrow> nat\" where\n\"size' (C\\<^sub>M\\<^sub>L nm) = 1\" |\n\"size' (V\\<^sub>M\\<^sub>L X) = 1\"  |\n\"size' (A\\<^sub>M\\<^sub>L v vs) = (size' v + (\\<Sum>v\\<leftarrow>vs. size' v))+1\" |\n\"size' (Lam\\<^sub>M\\<^sub>L v) = size' v + 1\" |\n\"size' (C\\<^sub>U nm vs) = (\\<Sum>v\\<leftarrow>vs. size' v)+1\" |\n\"size' (V\\<^sub>U nm vs) = (\\<Sum>v\\<leftarrow>vs. size' v)+1\" |\n\"size' (Clo f vs n) = (size' f + (\\<Sum>v\\<leftarrow>vs. size' v))+1\" |\n\"size' (apply v w) = (size' v + size' w)+1\""], ["", "lemma sum_list_size'[simp]:\n \"v \\<in> set vs \\<Longrightarrow> size' v < Suc(sum_list (map size' vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow> size' v < Suc (sum_list (map size' vs))", "by(induct vs)(auto)"], ["", "corollary cor_sum_list_size'[simp]:\n \"v \\<in> set vs \\<Longrightarrow> size' v < Suc(m + sum_list (map size' vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow>\n    size' v < Suc (m + sum_list (map size' vs))", "using sum_list_size'[of v vs]"], ["proof (prove)\nusing this:\n  v \\<in> set vs \\<Longrightarrow> size' v < Suc (sum_list (map size' vs))\n\ngoal (1 subgoal):\n 1. v \\<in> set vs \\<Longrightarrow>\n    size' v < Suc (m + sum_list (map size' vs))", "by arith"], ["", "lemma size'_lift_ML: \"size' (lift\\<^sub>M\\<^sub>L k v) = size' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size' (lift\\<^sub>M\\<^sub>L k v) = size' v", "apply(induct v arbitrary:k rule:size'.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm k.\n       size' (lift\\<^sub>M\\<^sub>L k (C\\<^sub>M\\<^sub>L nm)) =\n       size' (C\\<^sub>M\\<^sub>L nm)\n 2. \\<And>X k.\n       size' (lift\\<^sub>M\\<^sub>L k (V\\<^sub>M\\<^sub>L X)) =\n       size' (V\\<^sub>M\\<^sub>L X)\n 3. \\<And>v vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k v) = size' v;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (lift\\<^sub>M\\<^sub>L k\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         size' (A\\<^sub>M\\<^sub>L v vs)\n 4. \\<And>v k.\n       (\\<And>k.\n           size' (lift\\<^sub>M\\<^sub>L k v) = size' v) \\<Longrightarrow>\n       size' (lift\\<^sub>M\\<^sub>L k (Lam\\<^sub>M\\<^sub>L v)) =\n       size' (Lam\\<^sub>M\\<^sub>L v)\n 5. \\<And>nm vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       size' (lift\\<^sub>M\\<^sub>L k (C\\<^sub>U nm vs)) =\n       size' (C\\<^sub>U nm vs)\n 6. \\<And>nm vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       size' (lift\\<^sub>M\\<^sub>L k (V\\<^sub>U nm vs)) =\n       size' (V\\<^sub>U nm vs)\n 7. \\<And>f vs n k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> size' (lift\\<^sub>M\\<^sub>L k (Clo f vs n)) =\n                         size' (Clo f vs n)\n 8. \\<And>v w k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k v) = size' v;\n        \\<And>k. size' (lift\\<^sub>M\\<^sub>L k w) = size' w\\<rbrakk>\n       \\<Longrightarrow> size' (lift\\<^sub>M\\<^sub>L k (apply v w)) =\n                         size' (apply v w)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k v) = size' v;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)\n 2. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 3. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 4. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k v) = size' v;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs =\n                         map size' vs\n 2. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 3. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 4. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v vs k x.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k v) = size' v;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> lift\\<^sub>M\\<^sub>L k) x = size' x\n 2. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 3. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 4. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 2. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 3. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs = map size' vs\n 2. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 3. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs k x.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       x \\<in> set vs \\<longrightarrow>\n       (size' \\<circ> lift\\<^sub>M\\<^sub>L k) x = size' x\n 2. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 3. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n       sum_list (map size' vs)\n 2. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs = map size' vs\n 2. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs k x.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x) \\<Longrightarrow>\n       x \\<in> set vs \\<longrightarrow>\n       (size' \\<circ> lift\\<^sub>M\\<^sub>L k) x = size' x\n 2. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs k.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> lift\\<^sub>M\\<^sub>L k) vs =\n                         map size' vs", "apply(rule map_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs k x.\n       \\<lbrakk>\\<And>k. size' (lift\\<^sub>M\\<^sub>L k f) = size' f;\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift\\<^sub>M\\<^sub>L k x) = size' x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> lift\\<^sub>M\\<^sub>L k) x = size' x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size'_subst_ML[simp]:\n \"\\<forall>i j. size'(\\<sigma> i) = 1 \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n    size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v", "apply(induct v arbitrary:\\<sigma> rule:size'.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n       size' (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       size' (C\\<^sub>M\\<^sub>L nm)\n 2. \\<And>X \\<sigma>.\n       \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n       size' (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       size' (V\\<^sub>M\\<^sub>L X)\n 3. \\<And>v vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         size' (A\\<^sub>M\\<^sub>L v vs)\n 4. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (Lam\\<^sub>M\\<^sub>L v)) =\n                         size' (Lam\\<^sub>M\\<^sub>L v)\n 5. \\<And>nm vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         size' (C\\<^sub>U nm vs)\n 6. \\<And>nm vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U nm vs)) =\n                         size' (V\\<^sub>U nm vs)\n 7. \\<And>f vs n \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo f vs n)) =\n                         size' (Clo f vs n)\n 8. \\<And>v w \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<And>\\<sigma>.\n           \\<forall>i j. size' (\\<sigma> i) = 1 \\<Longrightarrow>\n           size' (subst\\<^sub>M\\<^sub>L \\<sigma> w) = size' w;\n        \\<forall>i j. size' (\\<sigma> i) = 1\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply v w)) =\n                         size' (apply v w)", "apply simp_all"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n                         size' v\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 4. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 5. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          vs =\n                         map size' vs\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n                         size' v\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 4. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 5. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v vs \\<sigma> x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>) x =\n                         size' x\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n                         size' v\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 4. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 5. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> v) = size' v;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n                         size' v\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 4. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(erule meta_allE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<forall>i. size' (\\<sigma> i) = Suc 0;\n        \\<forall>i.\n           size' (?\\<sigma>13 v \\<sigma> i) = Suc 0 \\<Longrightarrow>\n        size' (subst\\<^sub>M\\<^sub>L (?\\<sigma>13 v \\<sigma>) v) =\n        size' v\\<rbrakk>\n       \\<Longrightarrow> size'\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n                         size' v\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 4. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(erule meta_mp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n       \\<forall>i. size' ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i) = Suc 0\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 4. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(simp add: size'_lift_ML split:nat.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 3. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          vs =\n                         map size' vs\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 3. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs \\<sigma> x.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>) x =\n                         size' x\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 3. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)\n 2. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          vs =\n                         map size' vs\n 2. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs \\<sigma> x.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set vs;\n                    \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n                   \\<Longrightarrow> size'\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>) x =\n                         size' x\n 2. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> sum_list\n                          (map (size' \\<circ>\n                                subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          vs =\n                         map size' vs", "apply(rule map_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs \\<sigma> x.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>i. size' (\\<sigma> i) = Suc 0 \\<Longrightarrow>\n                   size' (subst\\<^sub>M\\<^sub>L \\<sigma> f) = size' f;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set vs;\n            \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n           \\<Longrightarrow> size' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             size' x;\n        \\<forall>i. size' (\\<sigma> i) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> subst\\<^sub>M\\<^sub>L \\<sigma>) x =\n                         size' x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size'_lift[simp]: \"size' (lift i v) = size' v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size' (lift i v) = size' v", "apply(induct v arbitrary:i rule:size'.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm i.\n       size' (lift i (C\\<^sub>M\\<^sub>L nm)) = size' (C\\<^sub>M\\<^sub>L nm)\n 2. \\<And>X i.\n       size' (lift i (V\\<^sub>M\\<^sub>L X)) = size' (V\\<^sub>M\\<^sub>L X)\n 3. \\<And>v vs i.\n       \\<lbrakk>\\<And>i. size' (lift i v) = size' v;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> size' (lift i (A\\<^sub>M\\<^sub>L v vs)) =\n                         size' (A\\<^sub>M\\<^sub>L v vs)\n 4. \\<And>v i.\n       (\\<And>i. size' (lift i v) = size' v) \\<Longrightarrow>\n       size' (lift i (Lam\\<^sub>M\\<^sub>L v)) =\n       size' (Lam\\<^sub>M\\<^sub>L v)\n 5. \\<And>nm vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       size' (lift i (C\\<^sub>U nm vs)) = size' (C\\<^sub>U nm vs)\n 6. \\<And>nm vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       size' (lift i (V\\<^sub>U nm vs)) = size' (V\\<^sub>U nm vs)\n 7. \\<And>f vs n i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> size' (lift i (Clo f vs n)) = size' (Clo f vs n)\n 8. \\<And>v w i.\n       \\<lbrakk>\\<And>i. size' (lift i v) = size' v;\n        \\<And>i. size' (lift i w) = size' w\\<rbrakk>\n       \\<Longrightarrow> size' (lift i (apply v w)) = size' (apply v w)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v vs i.\n       \\<lbrakk>\\<And>i. size' (lift i v) = size' v;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)\n 2. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 3. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 4. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v vs i.\n       \\<lbrakk>\\<And>i. size' (lift i v) = size' v;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> lift i) vs = map size' vs\n 2. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 3. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 4. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v vs i x.\n       \\<lbrakk>\\<And>i. size' (lift i v) = size' v;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> lift i) x = size' x\n 2. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 3. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 4. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 2. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 3. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       map (size' \\<circ> lift i) vs = map size' vs\n 2. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 3. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs i x.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       x \\<in> set vs \\<longrightarrow> (size' \\<circ> lift i) x = size' x\n 2. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 3. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       sum_list (map (size' \\<circ> lift i) vs) = sum_list (map size' vs)\n 2. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs i.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       map (size' \\<circ> lift i) vs = map size' vs\n 2. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule map_ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>vs i x.\n       (\\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x) \\<Longrightarrow>\n       x \\<in> set vs \\<longrightarrow> (size' \\<circ> lift i) x = size' x\n 2. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> sum_list (map (size' \\<circ> lift i) vs) =\n                         sum_list (map size' vs)", "apply(rule arg_cong[where f = sum_list])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> map (size' \\<circ> lift i) vs = map size' vs", "apply(rule map_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f vs i x.\n       \\<lbrakk>\\<And>i. size' (lift i f) = size' f;\n        \\<And>x i.\n           x \\<in> set vs \\<Longrightarrow>\n           size' (lift i x) = size' x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set vs \\<longrightarrow>\n                         (size' \\<circ> lift i) x = size' x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "function kernel  :: \"ml \\<Rightarrow> tm\"  (\"_!\" 300) where\n\"(C\\<^sub>M\\<^sub>L nm)! = C nm\" |\n\"(A\\<^sub>M\\<^sub>L v vs)! = v! \\<bullet>\\<bullet> (map kernel (rev vs))\" |\n\"(Lam\\<^sub>M\\<^sub>L v)! = \\<Lambda> (((lift 0 v)[V\\<^sub>U 0 []/0])!)\" |\n\"(C\\<^sub>U nm vs)! = (C nm) \\<bullet>\\<bullet> (map kernel (rev vs))\" |\n\"(V\\<^sub>U x vs)! = (V x) \\<bullet>\\<bullet> (map kernel (rev vs))\" |\n\"(Clo f vs n)! = f! \\<bullet>\\<bullet> (map kernel (rev vs))\" |\n\"(apply v w)! = v! \\<bullet> (w!)\" |\n\"(V\\<^sub>M\\<^sub>L X)! = undefined\""], ["proof (prove)\ngoal (37 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>nm. x = C\\<^sub>M\\<^sub>L nm \\<Longrightarrow> P;\n        \\<And>v vs. x = A\\<^sub>M\\<^sub>L v vs \\<Longrightarrow> P;\n        \\<And>v. x = Lam\\<^sub>M\\<^sub>L v \\<Longrightarrow> P;\n        \\<And>nm vs. x = C\\<^sub>U nm vs \\<Longrightarrow> P;\n        \\<And>xa vs. x = V\\<^sub>U xa vs \\<Longrightarrow> P;\n        \\<And>f vs n. x = Clo f vs n \\<Longrightarrow> P;\n        \\<And>v w. x = apply v w \\<Longrightarrow> P;\n        \\<And>X. x = V\\<^sub>M\\<^sub>L X \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>nm nma.\n       C\\<^sub>M\\<^sub>L nm = C\\<^sub>M\\<^sub>L nma \\<Longrightarrow>\n       C nm = C nma\n 3. \\<And>nm v vs.\n       C\\<^sub>M\\<^sub>L nm = A\\<^sub>M\\<^sub>L v vs \\<Longrightarrow>\n       C nm = kernel_sumC v \\<bullet>\\<bullet> map kernel_sumC (rev vs)\n 4. \\<And>nm v.\n       C\\<^sub>M\\<^sub>L nm = Lam\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n       C nm = \\<Lambda> (kernel_sumC (lift 0 v[V\\<^sub>U 0 []/0]))\n 5. \\<And>nm nma vs.\n       C\\<^sub>M\\<^sub>L nm = C\\<^sub>U nma vs \\<Longrightarrow>\n       C nm = C nma \\<bullet>\\<bullet> map kernel_sumC (rev vs)\n 6. \\<And>nm x vs.\n       C\\<^sub>M\\<^sub>L nm = V\\<^sub>U x vs \\<Longrightarrow>\n       C nm = V x \\<bullet>\\<bullet> map kernel_sumC (rev vs)\n 7. \\<And>nm f vs n.\n       C\\<^sub>M\\<^sub>L nm = Clo f vs n \\<Longrightarrow>\n       C nm = kernel_sumC f \\<bullet>\\<bullet> map kernel_sumC (rev vs)\n 8. \\<And>nm v w.\n       C\\<^sub>M\\<^sub>L nm = apply v w \\<Longrightarrow>\n       C nm = kernel_sumC v \\<bullet> kernel_sumC w\n 9. \\<And>nm X.\n       C\\<^sub>M\\<^sub>L nm = V\\<^sub>M\\<^sub>L X \\<Longrightarrow>\n       C nm = undefined\n 10. \\<And>v vs va vsa.\n        A\\<^sub>M\\<^sub>L v vs = A\\<^sub>M\\<^sub>L va vsa \\<Longrightarrow>\n        kernel_sumC v \\<bullet>\\<bullet> map kernel_sumC (rev vs) =\n        kernel_sumC va \\<bullet>\\<bullet> map kernel_sumC (rev vsa)\nA total of 37 subgoals...", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All kernel_dom", "by(relation \"measure size'\") auto"], ["", "primrec kernelt :: \"tm \\<Rightarrow> tm\" (\"_!\" 300)\nwhere\n  \"(C nm)! = C nm\"\n| \"(V x)! = V x\"\n| \"(s \\<bullet> t)! = (s!) \\<bullet> (t!)\"\n| \"(\\<Lambda> t)! = \\<Lambda>(t!)\"\n| \"(term v)! = v!\""], ["", "abbreviation\n  kernels :: \"ml list \\<Rightarrow> tm list\" (\"_!\" 300) where\n  \"vs! \\<equiv> map kernel vs\""], ["", "lemma kernel_pure: assumes \"pure t\" shows \"t! = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t! = t", "using assms"], ["proof (prove)\nusing this:\n  pure t\n\ngoal (1 subgoal):\n 1. t! = t", "by (induct) simp_all"], ["", "lemma kernel_foldl_At[simp]: \"(s \\<bullet>\\<bullet> ts)! = (s!) \\<bullet>\\<bullet> (map kernelt ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<bullet>\\<bullet> ts! = s! \\<bullet>\\<bullet> map kernelt ts", "by (induct ts arbitrary: s) simp_all"], ["", "lemma kernelt_o_term[simp]: \"(kernelt \\<circ> term) = kernel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. kernelt \\<circ> term = kernel", "by(rule ext) simp"], ["", "lemma pure_foldl:\n \"pure t \\<Longrightarrow> \\<forall>t\\<in>set ts. pure t \\<Longrightarrow> \n (!!s t. pure s \\<Longrightarrow> pure t \\<Longrightarrow> pure(f s t)) \\<Longrightarrow>\n pure(foldl f t ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; \\<forall>t\\<in>set ts. pure t;\n     \\<And>s t.\n        \\<lbrakk>pure s; pure t\\<rbrakk>\n        \\<Longrightarrow> pure (f s t)\\<rbrakk>\n    \\<Longrightarrow> pure (foldl f t ts)", "by(induct ts arbitrary: t) simp_all"], ["", "lemma pure_kernel: fixes v :: ml shows \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure(v!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!)", "proof(induct v rule:kernel.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "case (3 v)"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n  pure (lift 0 v[V\\<^sub>U 0 []/0]!)\n  closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\n\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "hence \"closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 v)\""], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n  pure (lift 0 v[V\\<^sub>U 0 []/0]!)\n  closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 v)", "by simp"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 v)\n\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "then"], ["proof (chain)\npicking this:\n  closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 v)", "have \"subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v) = lift 0 v[V\\<^sub>U 0 []/0]\""], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 v)\n\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v) =\n    lift 0 v[V\\<^sub>U 0 []/0]", "by(rule subst_ML_coincidence) simp"], ["proof (state)\nthis:\n  subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v) =\n  lift 0 v[V\\<^sub>U 0 []/0]\n\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "moreover"], ["proof (state)\nthis:\n  subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v) =\n  lift 0 v[V\\<^sub>U 0 []/0]\n\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "have \"closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v))", "by(simp add: closed_ML_subst_ML)"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0\n   (subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v))\n\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "ultimately"], ["proof (chain)\npicking this:\n  subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v) =\n  lift 0 v[V\\<^sub>U 0 []/0]\n  closed\\<^sub>M\\<^sub>L 0\n   (subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v))", "have \"closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0])\""], ["proof (prove)\nusing this:\n  subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v) =\n  lift 0 v[V\\<^sub>U 0 []/0]\n  closed\\<^sub>M\\<^sub>L 0\n   (subst\\<^sub>M\\<^sub>L (\\<lambda>n. V\\<^sub>U 0 []) (lift 0 v))\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0])", "by simp"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0])\n\ngoal (8 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n                 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                pure (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> pure (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 5. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 6. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 7. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 8. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "thus ?case"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0])\n\ngoal (1 subgoal):\n 1. pure (Lam\\<^sub>M\\<^sub>L v!)", "using 3(1)"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0])\n  closed\\<^sub>M\\<^sub>L 0 (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n  pure (lift 0 v[V\\<^sub>U 0 []/0]!)\n\ngoal (1 subgoal):\n 1. pure (Lam\\<^sub>M\\<^sub>L v!)", "by (simp add:pure_foldl)"], ["proof (state)\nthis:\n  pure (Lam\\<^sub>M\\<^sub>L v!)\n\ngoal (7 subgoals):\n 1. \\<And>nm.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       pure (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> pure (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> pure (C\\<^sub>U nm vs!)\n 4. \\<And>x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> pure (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> pure (V\\<^sub>U x vs!)\n 5. \\<And>f vs n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow> pure (f!);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> pure (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> pure (Clo f vs n!)\n 6. \\<And>v w.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> pure (v!);\n        closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow> pure (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> pure (apply v w!)\n 7. \\<And>X.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       pure (V\\<^sub>M\\<^sub>L X!)", "qed (simp_all add:pure_foldl)"], ["", "corollary subst_V_kernel: fixes v :: ml shows\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> subst V (v!) = v!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> subst V (v!) = v!", "by (metis pure_kernel subst_V)"], ["", "lemma kernel_lift_tm: fixes v :: ml shows\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> (lift i v)! = lift i (v!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> lift i v! = lift i (v!)", "apply(induct v arbitrary: i rule: kernel.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm i.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       lift i (C\\<^sub>M\\<^sub>L nm)! = lift i (C\\<^sub>M\\<^sub>L nm!)\n 2. \\<And>v vs i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n                   lift i v! = lift i (v!);\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> lift i (A\\<^sub>M\\<^sub>L v vs)! =\n                         lift i (A\\<^sub>M\\<^sub>L v vs!)\n 3. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                   lift i (lift 0 v[V\\<^sub>U 0 []/0])! =\n                   lift i (lift 0 v[V\\<^sub>U 0 []/0]!);\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> lift i (Lam\\<^sub>M\\<^sub>L v)! =\n                         lift i (Lam\\<^sub>M\\<^sub>L v!)\n 4. \\<And>nm vs i.\n       \\<lbrakk>\\<And>x i.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> lift i (C\\<^sub>U nm vs)! =\n                         lift i (C\\<^sub>U nm vs!)\n 5. \\<And>x vs i.\n       \\<lbrakk>\\<And>xa i.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> lift i xa! = lift i (xa!);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> lift i (V\\<^sub>U x vs)! = lift i (V\\<^sub>U x vs!)\n 6. \\<And>f vs n i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n                   lift i f! = lift i (f!);\n        \\<And>x i.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> lift i (Clo f vs n)! = lift i (Clo f vs n!)\n 7. \\<And>v w i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n                   lift i v! = lift i (v!);\n        \\<And>i.\n           closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow>\n           lift i w! = lift i (w!);\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> lift i (apply v w)! = lift i (apply v w!)\n 8. \\<And>X i.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       lift i (V\\<^sub>M\\<^sub>L X)! = lift i (V\\<^sub>M\\<^sub>L X!)", "apply (simp_all add:list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v vs i.\n       \\<lbrakk>\\<And>i. lift i v! = lift i (v!);\n        \\<And>x i. x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 v \\<and>\n        (\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L 0 x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 2. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))! =\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!);\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)\n 3. \\<And>vs i.\n       \\<lbrakk>\\<And>x i.\n                   x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 4. \\<And>vs i.\n       \\<lbrakk>\\<And>xa i.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   lift i xa! = lift i (xa!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 5. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. lift i f! = lift i (f!);\n        \\<And>x i. x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))! =\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!);\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)\n 2. \\<And>vs i.\n       \\<lbrakk>\\<And>x i.\n                   x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 3. \\<And>vs i.\n       \\<lbrakk>\\<And>xa i.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   lift i xa! = lift i (xa!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 4. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. lift i f! = lift i (f!);\n        \\<And>x i. x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>vs i.\n       \\<lbrakk>\\<And>x i.\n                   x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 2. \\<And>vs i.\n       \\<lbrakk>\\<And>xa i.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   lift i xa! = lift i (xa!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 3. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. lift i f! = lift i (f!);\n        \\<And>x i. x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 4. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))! =\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!);\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs i.\n       \\<lbrakk>\\<And>xa i.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   lift i xa! = lift i (xa!);\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 2. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. lift i f! = lift i (f!);\n        \\<And>x i. x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 3. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))! =\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!);\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f vs i.\n       \\<lbrakk>\\<And>i. lift i f! = lift i (f!);\n        \\<And>x i. x \\<in> set vs \\<Longrightarrow> lift i x! = lift i (x!);\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia<length vs.\n                            rev (map (lift i) vs) ! ia! =\n                            lift i (rev vs ! ia!)\n 2. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))! =\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!);\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v i.\n       \\<lbrakk>\\<And>i.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))! =\n                   lift i\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!);\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)", "apply(erule_tac x=\"Suc i\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        closed\\<^sub>M\\<^sub>L 0\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)) \\<Longrightarrow>\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)", "apply(erule meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))\n 2. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)\n 2. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))", "apply (simp add:lift_subst_ML)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\\<^sub>M\\<^sub>L\n         (lift (Suc i) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (lift (Suc i) (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)\n 2. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))", "apply(subgoal_tac \"lift (Suc i) \\<circ> (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)) = (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\\<^sub>M\\<^sub>L\n         (lift (Suc i) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (lift (Suc i) (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!);\n        lift (Suc i) \\<circ>\n        (\\<lambda>n.\n            if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)) =\n        (\\<lambda>n.\n            if n = 0 then V\\<^sub>U 0 []\n            else V\\<^sub>M\\<^sub>L (n - 1))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (lift i v))! =\n                         lift (Suc i)\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!)\n 2. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\\<^sub>M\\<^sub>L\n         (lift (Suc i) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (lift (Suc i) (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc i) \\<circ>\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1)) =\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n 3. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))", "apply (simp add:lift_lift_ml)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\\<^sub>M\\<^sub>L\n         (lift (Suc i) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (lift (Suc i) (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> lift (Suc i) \\<circ>\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1)) =\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n 2. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))", "apply(rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v i n.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\\<^sub>M\\<^sub>L\n         (lift (Suc i) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (lift (Suc i) (lift 0 v))! =\n        lift (Suc i)\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!)\\<rbrakk>\n       \\<Longrightarrow> (lift (Suc i) \\<circ>\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1)))\n                          n =\n                         (if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n 2. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))", "apply(subst closed_ML_subst_ML2[of \"1\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 1 (lift 0 v)\n 2. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       \\<forall>i<1.\n          closed\\<^sub>M\\<^sub>L 0\n           (if i = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (i - 1))\n 3. \\<And>v i. closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow> True", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       \\<forall>i<1.\n          closed\\<^sub>M\\<^sub>L 0\n           (if i = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (i - 1))\n 2. \\<And>v i. closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow> True", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v i. closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow> True", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"An auxiliary substitution\""], ["", "text\\<open>This function is only introduced to prove the involved susbtitution\nlemma \\<open>kernel_subst1\\<close> below.\\<close>"], ["", "fun subst_ml :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> ml \\<Rightarrow> ml\" where\n\"subst_ml \\<sigma> (C\\<^sub>M\\<^sub>L nm) = C\\<^sub>M\\<^sub>L nm\" |\n\"subst_ml \\<sigma> (V\\<^sub>M\\<^sub>L X) = V\\<^sub>M\\<^sub>L X\" |\n\"subst_ml \\<sigma> (A\\<^sub>M\\<^sub>L v vs) = A\\<^sub>M\\<^sub>L (subst_ml \\<sigma> v) (map (subst_ml \\<sigma>) vs)\" |\n\"subst_ml \\<sigma> (Lam\\<^sub>M\\<^sub>L v) = Lam\\<^sub>M\\<^sub>L (subst_ml \\<sigma> v)\" |\n\"subst_ml \\<sigma> (C\\<^sub>U nm vs) = C\\<^sub>U nm (map (subst_ml \\<sigma>) vs)\" |\n\"subst_ml \\<sigma> (V\\<^sub>U x vs) = V\\<^sub>U (\\<sigma> x) (map (subst_ml \\<sigma>) vs)\" |\n\"subst_ml \\<sigma> (Clo v vs n) = Clo (subst_ml \\<sigma> v) (map (subst_ml \\<sigma>) vs) n\" |\n\"subst_ml \\<sigma> (apply u v) = apply (subst_ml \\<sigma> u) (subst_ml \\<sigma> v)\""], ["", "lemma lift_ML_subst_ml:\n  \"lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) = subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) =\n    subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v)", "apply (induct \\<sigma> v arbitrary: k rule:subst_ml.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm k.\n       lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k (C\\<^sub>M\\<^sub>L nm))\n 2. \\<And>\\<sigma> X k.\n       lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k (V\\<^sub>M\\<^sub>L X))\n 3. \\<And>\\<sigma> v vs k.\n       \\<lbrakk>\\<And>k.\n                   lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) =\n                   subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v);\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> x) =\n           subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k x)\\<rbrakk>\n       \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k\n                          (subst_ml \\<sigma> (A\\<^sub>M\\<^sub>L v vs)) =\n                         subst_ml \\<sigma>\n                          (lift\\<^sub>M\\<^sub>L k (A\\<^sub>M\\<^sub>L v vs))\n 4. \\<And>\\<sigma> v k.\n       (\\<And>k.\n           lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) =\n           subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v)) \\<Longrightarrow>\n       lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> (Lam\\<^sub>M\\<^sub>L v)) =\n       subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k (Lam\\<^sub>M\\<^sub>L v))\n 5. \\<And>\\<sigma> nm vs k.\n       (\\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> x) =\n           subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k x)) \\<Longrightarrow>\n       lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> (C\\<^sub>U nm vs)) =\n       subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k (C\\<^sub>U nm vs))\n 6. \\<And>\\<sigma> x vs k.\n       (\\<And>xa k.\n           xa \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> xa) =\n           subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k xa)) \\<Longrightarrow>\n       lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> (V\\<^sub>U x vs)) =\n       subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k (V\\<^sub>U x vs))\n 7. \\<And>\\<sigma> v vs n k.\n       \\<lbrakk>\\<And>k.\n                   lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) =\n                   subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v);\n        \\<And>x k.\n           x \\<in> set vs \\<Longrightarrow>\n           lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> x) =\n           subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k x)\\<rbrakk>\n       \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k\n                          (subst_ml \\<sigma> (Clo v vs n)) =\n                         subst_ml \\<sigma>\n                          (lift\\<^sub>M\\<^sub>L k (Clo v vs n))\n 8. \\<And>\\<sigma> u v k.\n       \\<lbrakk>\\<And>k.\n                   lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> u) =\n                   subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k u);\n        \\<And>k.\n           lift\\<^sub>M\\<^sub>L k (subst_ml \\<sigma> v) =\n           subst_ml \\<sigma> (lift\\<^sub>M\\<^sub>L k v)\\<rbrakk>\n       \\<Longrightarrow> lift\\<^sub>M\\<^sub>L k\n                          (subst_ml \\<sigma> (apply u v)) =\n                         subst_ml \\<sigma>\n                          (lift\\<^sub>M\\<^sub>L k (apply u v))", "apply (simp_all add:list_eq_iff_nth_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_ml_subst_ML:\n  \"subst_ml \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) = subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma> o \\<sigma>') (subst_ml \\<sigma> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml \\<sigma> (subst\\<^sub>M\\<^sub>L \\<sigma>' v) =\n    subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma> \\<circ> \\<sigma>')\n     (subst_ml \\<sigma> v)", "apply (induct \\<sigma>' v arbitrary: \\<sigma> rule: subst_ML.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm \\<sigma>'.\n       subst_ml \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n        (subst_ml \\<sigma>' (C\\<^sub>M\\<^sub>L nm))\n 2. \\<And>\\<sigma> X \\<sigma>'.\n       subst_ml \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n        (subst_ml \\<sigma>' (V\\<^sub>M\\<^sub>L X))\n 3. \\<And>\\<sigma> v vs \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n                    (subst_ml \\<sigma>' v);\n        \\<And>x \\<sigma>'.\n           x \\<in> set vs \\<Longrightarrow>\n           subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n            (subst_ml \\<sigma>' x)\\<rbrakk>\n       \\<Longrightarrow> subst_ml \\<sigma>'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n                          (subst_ml \\<sigma>' (A\\<^sub>M\\<^sub>L v vs))\n 4. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst_ml \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            (subst_ml \\<sigma>' v)) \\<Longrightarrow>\n       subst_ml \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v)) =\n       subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n        (subst_ml \\<sigma>' (Lam\\<^sub>M\\<^sub>L v))\n 5. \\<And>\\<sigma> nm vs \\<sigma>'.\n       (\\<And>x \\<sigma>'.\n           x \\<in> set vs \\<Longrightarrow>\n           subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n            (subst_ml \\<sigma>' x)) \\<Longrightarrow>\n       subst_ml \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs)) =\n       subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n        (subst_ml \\<sigma>' (C\\<^sub>U nm vs))\n 6. \\<And>\\<sigma> x vs \\<sigma>'.\n       (\\<And>xa \\<sigma>'.\n           xa \\<in> set vs \\<Longrightarrow>\n           subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n           subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n            (subst_ml \\<sigma>' xa)) \\<Longrightarrow>\n       subst_ml \\<sigma>'\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs)) =\n       subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n        (subst_ml \\<sigma>' (V\\<^sub>U x vs))\n 7. \\<And>\\<sigma> v vs n \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n                    (subst_ml \\<sigma>' v);\n        \\<And>x \\<sigma>'.\n           x \\<in> set vs \\<Longrightarrow>\n           subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n           subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n            (subst_ml \\<sigma>' x)\\<rbrakk>\n       \\<Longrightarrow> subst_ml \\<sigma>'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n                          (subst_ml \\<sigma>' (Clo v vs n))\n 8. \\<And>\\<sigma> u v \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n                    (subst_ml \\<sigma>' u);\n        \\<And>\\<sigma>'.\n           subst_ml \\<sigma>' (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n           subst\\<^sub>M\\<^sub>L (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n            (subst_ml \\<sigma>' v)\\<rbrakk>\n       \\<Longrightarrow> subst_ml \\<sigma>'\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         subst\\<^sub>M\\<^sub>L\n                          (subst_ml \\<sigma>' \\<circ> \\<sigma>)\n                          (subst_ml \\<sigma>' (apply u v))", "apply(simp_all add:list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst_ml \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            (subst_ml \\<sigma>' v)) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L\n        (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n        (subst_ml \\<sigma>' v) =\n       subst\\<^sub>M\\<^sub>L\n        (V\\<^sub>M\\<^sub>L 0 ## (subst_ml \\<sigma>' \\<circ> \\<sigma>))\n        (subst_ml \\<sigma>' v)", "apply(subgoal_tac \"(subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) = V\\<^sub>M\\<^sub>L 0 ## (subst_ml \\<sigma>' \\<circ> \\<sigma>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> v \\<sigma>'.\n       \\<lbrakk>\\<And>\\<sigma>'.\n                   subst_ml \\<sigma>'\n                    (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                      v) =\n                   subst\\<^sub>M\\<^sub>L\n                    (subst_ml \\<sigma>' \\<circ>\n                     V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                    (subst_ml \\<sigma>' v);\n        subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n        V\\<^sub>M\\<^sub>L 0 ##\n        (subst_ml \\<sigma>' \\<circ> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml \\<sigma>' \\<circ>\n                           V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                          (subst_ml \\<sigma>' v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (V\\<^sub>M\\<^sub>L 0 ##\n                           (subst_ml \\<sigma>' \\<circ> \\<sigma>))\n                          (subst_ml \\<sigma>' v)\n 2. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst_ml \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            (subst_ml \\<sigma>' v)) \\<Longrightarrow>\n       subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n       V\\<^sub>M\\<^sub>L 0 ## (subst_ml \\<sigma>' \\<circ> \\<sigma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<sigma>'.\n       (\\<And>\\<sigma>'.\n           subst_ml \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            (subst_ml \\<sigma>' v)) \\<Longrightarrow>\n       subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n       V\\<^sub>M\\<^sub>L 0 ## (subst_ml \\<sigma>' \\<circ> \\<sigma>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> v \\<sigma>' x.\n       (\\<And>\\<sigma>'.\n           subst_ml \\<sigma>'\n            (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) v) =\n           subst\\<^sub>M\\<^sub>L\n            (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n            (subst_ml \\<sigma>' v)) \\<Longrightarrow>\n       (subst_ml \\<sigma>' \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) x =\n       (V\\<^sub>M\\<^sub>L 0 ## (subst_ml \\<sigma>' \\<circ> \\<sigma>)) x", "apply(simp add: lift_ML_subst_ml)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Maybe this should be the def of lift:\\<close>"], ["", "lemma lift_is_subst_ml: \"lift k v = subst_ml (\\<lambda>n. if n<k then n else n+1) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift k v = subst_ml (\\<lambda>n. if n < k then n else n + 1) v", "by(induct k v rule:lift_ml.induct)(simp_all add:list_eq_iff_nth_eq)"], ["", "lemma subst_ml_comp:  \"subst_ml \\<sigma> (subst_ml \\<sigma>' v) = subst_ml (\\<sigma> o \\<sigma>') v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml \\<sigma> (subst_ml \\<sigma>' v) =\n    subst_ml (\\<sigma> \\<circ> \\<sigma>') v", "by(induct \\<sigma>' v rule:subst_ml.induct)(simp_all add:list_eq_iff_nth_eq)"], ["", "lemma subst_kernel:\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>  subst (\\<lambda>n. V(\\<sigma> n)) (v!) = (subst_ml \\<sigma> v)!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n    subst (\\<lambda>n. V (\\<sigma> n)) (v!) = subst_ml \\<sigma> v!", "apply (induct v arbitrary: \\<sigma> rule:kernel.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm \\<sigma>.\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       subst (\\<lambda>n. V (\\<sigma> n)) (C\\<^sub>M\\<^sub>L nm!) =\n       subst_ml \\<sigma> (C\\<^sub>M\\<^sub>L nm)!\n 2. \\<And>v vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (v!) =\n                   subst_ml \\<sigma> v!;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n)) (x!) =\n                             subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n))\n                          (A\\<^sub>M\\<^sub>L v vs!) =\n                         subst_ml \\<sigma> (A\\<^sub>M\\<^sub>L v vs)!\n 3. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (lift 0 v[V\\<^sub>U 0 []/0]) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (lift 0 v[V\\<^sub>U 0 []/0]!) =\n                   subst_ml \\<sigma> (lift 0 v[V\\<^sub>U 0 []/0])!;\n        closed\\<^sub>M\\<^sub>L 0 (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n))\n                          (Lam\\<^sub>M\\<^sub>L v!) =\n                         subst_ml \\<sigma> (Lam\\<^sub>M\\<^sub>L v)!\n 4. \\<And>nm vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n                   \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n))\n(x!) =\n                                     subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n))\n                          (C\\<^sub>U nm vs!) =\n                         subst_ml \\<sigma> (C\\<^sub>U nm vs)!\n 5. \\<And>x vs \\<sigma>.\n       \\<lbrakk>\\<And>xa \\<sigma>.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 xa\\<rbrakk>\n                   \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n))\n(xa!) =\n                                     subst_ml \\<sigma> xa!;\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n))\n                          (V\\<^sub>U x vs!) =\n                         subst_ml \\<sigma> (V\\<^sub>U x vs)!\n 6. \\<And>f vs n \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (f!) =\n                   subst_ml \\<sigma> f!;\n        \\<And>x \\<sigma>.\n           \\<lbrakk>x \\<in> set (rev vs);\n            closed\\<^sub>M\\<^sub>L 0 x\\<rbrakk>\n           \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n)) (x!) =\n                             subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n)) (Clo f vs n!) =\n                         subst_ml \\<sigma> (Clo f vs n)!\n 7. \\<And>v w \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (v!) =\n                   subst_ml \\<sigma> v!;\n        \\<And>\\<sigma>.\n           closed\\<^sub>M\\<^sub>L 0 w \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (w!) = subst_ml \\<sigma> w!;\n        closed\\<^sub>M\\<^sub>L 0 (apply v w)\\<rbrakk>\n       \\<Longrightarrow> subst (\\<lambda>n. V (\\<sigma> n)) (apply v w!) =\n                         subst_ml \\<sigma> (apply v w)!\n 8. \\<And>X \\<sigma>.\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       subst (\\<lambda>n. V (\\<sigma> n)) (V\\<^sub>M\\<^sub>L X!) =\n       subst_ml \\<sigma> (V\\<^sub>M\\<^sub>L X)!", "apply (simp_all add:list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>v vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   subst (\\<lambda>n. V (\\<sigma> n)) (v!) =\n                   subst_ml \\<sigma> v!;\n        \\<And>x \\<sigma>.\n           x \\<in> set vs \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (x!) = subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 v \\<and>\n        (\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L 0 x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!) =\n                   subst_ml \\<sigma>\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))!;\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   x \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (x!) =\n                   subst_ml \\<sigma> x!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 4. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>xa \\<sigma>.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (xa!) =\n                   subst_ml \\<sigma> xa!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 5. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   subst (\\<lambda>n. V (\\<sigma> n)) (f!) =\n                   subst_ml \\<sigma> f!;\n        \\<And>x \\<sigma>.\n           x \\<in> set vs \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (x!) = subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!) =\n                   subst_ml \\<sigma>\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))!;\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   x \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (x!) =\n                   subst_ml \\<sigma> x!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 3. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>xa \\<sigma>.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (xa!) =\n                   subst_ml \\<sigma> xa!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 4. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   subst (\\<lambda>n. V (\\<sigma> n)) (f!) =\n                   subst_ml \\<sigma> f!;\n        \\<And>x \\<sigma>.\n           x \\<in> set vs \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (x!) = subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!", "defer"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>x \\<sigma>.\n                   x \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (x!) =\n                   subst_ml \\<sigma> x!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 2. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>xa \\<sigma>.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (xa!) =\n                   subst_ml \\<sigma> xa!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 3. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   subst (\\<lambda>n. V (\\<sigma> n)) (f!) =\n                   subst_ml \\<sigma> f!;\n        \\<And>x \\<sigma>.\n           x \\<in> set vs \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (x!) = subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 4. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!) =\n                   subst_ml \\<sigma>\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))!;\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs \\<sigma>.\n       \\<lbrakk>\\<And>xa \\<sigma>.\n                   xa \\<in> set vs \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n)) (xa!) =\n                   subst_ml \\<sigma> xa!;\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 2. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   subst (\\<lambda>n. V (\\<sigma> n)) (f!) =\n                   subst_ml \\<sigma> f!;\n        \\<And>x \\<sigma>.\n           x \\<in> set vs \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (x!) = subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 3. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!) =\n                   subst_ml \\<sigma>\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))!;\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f vs \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   subst (\\<lambda>n. V (\\<sigma> n)) (f!) =\n                   subst_ml \\<sigma> f!;\n        \\<And>x \\<sigma>.\n           x \\<in> set vs \\<Longrightarrow>\n           subst (\\<lambda>n. V (\\<sigma> n)) (x!) = subst_ml \\<sigma> x!;\n        closed\\<^sub>M\\<^sub>L 0 f \\<and>\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs.\n                            subst (\\<lambda>n. V (\\<sigma> n))\n                             (rev vs ! i!) =\n                            rev (map (subst_ml \\<sigma>) vs) ! i!\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!) =\n                   subst_ml \\<sigma>\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))!;\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(simp add: rev_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   closed\\<^sub>M\\<^sub>L 0\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)) \\<Longrightarrow>\n                   subst (\\<lambda>n. V (\\<sigma> n))\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v)!) =\n                   subst_ml \\<sigma>\n                    (subst\\<^sub>M\\<^sub>L\n                      (\\<lambda>n.\n                          if n = 0 then V\\<^sub>U 0 []\n                          else V\\<^sub>M\\<^sub>L (n - 1))\n                      (lift 0 v))!;\n        closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(erule_tac x=\"\\<lambda>n. case n of 0 \\<Rightarrow> 0 | Suc k \\<Rightarrow> Suc(\\<sigma> k)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        closed\\<^sub>M\\<^sub>L 0\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)) \\<Longrightarrow>\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(erule_tac meta_impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L 0\n        (subst\\<^sub>M\\<^sub>L\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n          (lift 0 v))\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(rule closed_ML_subst_ML2[where k=\"Suc 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v \\<sigma>.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 v)\n 2. \\<And>v \\<sigma>.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       \\<forall>i<Suc 0.\n          closed\\<^sub>M\\<^sub>L 0\n           (if i = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (i - 1))\n 3. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply (metis closed_ML_lift)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       closed\\<^sub>M\\<^sub>L (Suc 0) v \\<Longrightarrow>\n       \\<forall>i<Suc 0.\n          closed\\<^sub>M\\<^sub>L 0\n           (if i = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (i - 1))\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(subgoal_tac \"(\\<lambda>n. V(case n of 0 \\<Rightarrow> 0 | Suc k \\<Rightarrow> Suc (\\<sigma> k))) = (V 0 ## (\\<lambda>n. V(\\<sigma> n)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1))\n                            (lift 0 v)!) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n.\n                             V (case n of 0 \\<Rightarrow> 0\n                                | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n                         V 0 ## (\\<lambda>n. V (\\<sigma> n))", "apply (simp add:subst_ml_subst_ML)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) (lift 0 v))!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)))\n                            (lift 0 v))! =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n.\n                             V (case n of 0 \\<Rightarrow> 0\n                                | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n                         V 0 ## (\\<lambda>n. V (\\<sigma> n))", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst\n         (\\<lambda>n.\n             V (case n of 0 \\<Rightarrow> 0\n                | Suc k \\<Rightarrow> Suc (\\<sigma> k)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst_ml\n         (\\<lambda>n.\n             case n of 0 \\<Rightarrow> 0\n             | Suc k \\<Rightarrow> Suc (\\<sigma> k))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v))!\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n.\n                             V (case n of 0 \\<Rightarrow> 0\n                                | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n                         V 0 ## (\\<lambda>n. V (\\<sigma> n))\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) (lift 0 v))!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)))\n                            (lift 0 v))! =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(simp add:fun_eq_iff split:nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (lift 0 v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) (lift 0 v))!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)))\n                            (lift 0 v))! =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0 (subst_ml \\<sigma> v))!", "apply(simp add:lift_is_subst_ml subst_ml_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                             Suc)\n                            v)! =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (subst_ml (Suc \\<circ> \\<sigma>) v)!", "apply(rule arg_cong[where f = kernel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                             Suc)\n                            v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (subst_ml (Suc \\<circ> \\<sigma>) v)", "apply(subgoal_tac \"(case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc) = Suc o \\<sigma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n));\n        case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc =\n        Suc \\<circ> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                             Suc)\n                            v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (subst_ml (Suc \\<circ> \\<sigma>) v)\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                         Suc =\n                         Suc \\<circ> \\<sigma>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n))\\<rbrakk>\n       \\<Longrightarrow> case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                         Suc =\n                         Suc \\<circ> \\<sigma>\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n));\n        case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc =\n        Suc \\<circ> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                             Suc)\n                            v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (subst_ml (Suc \\<circ> \\<sigma>) v)", "apply(simp add:fun_eq_iff split:nat.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n));\n        case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc =\n        Suc \\<circ> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                             Suc)\n                            v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (subst_ml (Suc \\<circ> \\<sigma>) v)", "apply(subgoal_tac \"(subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n               (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n             = (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n));\n        case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc =\n        Suc \\<circ> \\<sigma>;\n        subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n        (\\<lambda>n.\n            if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)) =\n        (\\<lambda>n.\n            if n = 0 then V\\<^sub>U 0 []\n            else V\\<^sub>M\\<^sub>L (n - 1))\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)))\n                          (subst_ml\n                            (case_nat 0\n                              (\\<lambda>k. Suc (\\<sigma> k)) \\<circ>\n                             Suc)\n                            v) =\n                         subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (subst_ml (Suc \\<circ> \\<sigma>) v)\n 2. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n));\n        case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc =\n        Suc \\<circ> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst_ml\n                          (case_nat 0\n                            (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1)) =\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v \\<sigma>.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc 0) v;\n        subst (V 0 ## (\\<lambda>n. V (\\<sigma> n)))\n         (subst\\<^sub>M\\<^sub>L\n           (\\<lambda>n.\n               if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n           (subst_ml Suc v)!) =\n        subst\\<^sub>M\\<^sub>L\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n          (\\<lambda>n.\n              if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)))\n         (subst_ml (case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc)\n           v)!;\n        (\\<lambda>n.\n            V (case n of 0 \\<Rightarrow> 0\n               | Suc k \\<Rightarrow> Suc (\\<sigma> k))) =\n        V 0 ## (\\<lambda>n. V (\\<sigma> n));\n        case_nat 0 (\\<lambda>k. Suc (\\<sigma> k)) \\<circ> Suc =\n        Suc \\<circ> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst_ml\n                          (case_nat 0\n                            (\\<lambda>k. Suc (\\<sigma> k))) \\<circ>\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1)) =\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))", "apply(simp add: fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma if_cong0: \"If x y z = If x y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x then y else z) = (if x then y else z)", "by simp"], ["", "lemma kernel_subst1:\n  \"closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0) u \\<Longrightarrow>\n   kernel(u[v/0]) = (kernel((lift 0 u)[V\\<^sub>U 0 []/0]))[v!/0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc 0) u\\<rbrakk>\n    \\<Longrightarrow> u[v/0]! = lift 0 u[V\\<^sub>U 0 []/0]![v!/0]", "proof(induct u arbitrary:v rule:kernel.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>nm v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (C\\<^sub>M\\<^sub>L nm)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>M\\<^sub>L nm[v/0]! =\n                         lift 0 (C\\<^sub>M\\<^sub>L nm)[V\\<^sub>U 0 []/0]!\n                         [v!/0]\n 2. \\<And>v vs va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n                   \\<Longrightarrow> v[va/0]! =\n                                     lift 0 v[V\\<^sub>U 0 []/0]![va!/0];\n        \\<And>x v.\n           \\<lbrakk>x \\<in> set (rev vs); closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n           \\<Longrightarrow> x[v/0]! = lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L v vs[va/0]! =\n                         lift 0 (A\\<^sub>M\\<^sub>L v vs)[V\\<^sub>U 0 []/0]!\n                         [va!/0]\n 3. \\<And>v va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0)\n                     (lift 0 v[V\\<^sub>U 0 []/0])\\<rbrakk>\n                   \\<Longrightarrow> lift 0 v[V\\<^sub>U 0 []/0][va/0]! =\n                                     lift 0 (lift 0 v[V\\<^sub>U 0 []/0])\n                                     [V\\<^sub>U 0 []/0]!\n                                     [va!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> Lam\\<^sub>M\\<^sub>L v[va/0]! =\n                         lift 0 (Lam\\<^sub>M\\<^sub>L v)[V\\<^sub>U 0 []/0]!\n                         [va!/0]\n 4. \\<And>nm vs v.\n       \\<lbrakk>\\<And>x v.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n                   \\<Longrightarrow> x[v/0]! =\n                                     lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs[v/0]! =\n                         lift 0 (C\\<^sub>U nm vs)[V\\<^sub>U 0 []/0]![v!/0]\n 5. \\<And>x vs v.\n       \\<lbrakk>\\<And>xa v.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) xa\\<rbrakk>\n                   \\<Longrightarrow> xa[v/0]! =\n                                     lift 0 xa[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs[v/0]! =\n                         lift 0 (V\\<^sub>U x vs)[V\\<^sub>U 0 []/0]![v!/0]\n 6. \\<And>f vs n v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) f\\<rbrakk>\n                   \\<Longrightarrow> f[v/0]! =\n                                     lift 0 f[V\\<^sub>U 0 []/0]![v!/0];\n        \\<And>x v.\n           \\<lbrakk>x \\<in> set (rev vs); closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n           \\<Longrightarrow> x[v/0]! = lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n[v/0]! =\n                         lift 0 (Clo f vs n)[V\\<^sub>U 0 []/0]![v!/0]\n 7. \\<And>v w va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n                   \\<Longrightarrow> v[va/0]! =\n                                     lift 0 v[V\\<^sub>U 0 []/0]![va!/0];\n        \\<And>v.\n           \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) w\\<rbrakk>\n           \\<Longrightarrow> w[v/0]! = lift 0 w[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (apply v w)\\<rbrakk>\n       \\<Longrightarrow> apply v w[va/0]! =\n                         lift 0 (apply v w)[V\\<^sub>U 0 []/0]![va!/0]\n 8. \\<And>X v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (V\\<^sub>M\\<^sub>L X)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>M\\<^sub>L X[v/0]! =\n                         lift 0 (V\\<^sub>M\\<^sub>L X)[V\\<^sub>U 0 []/0]!\n                         [v!/0]", "case (3 w)"], ["proof (state)\nthis:\n  \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 ?v;\n   closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])\\<rbrakk>\n  \\<Longrightarrow> lift 0 w[V\\<^sub>U 0 []/0][?v/0]! =\n                    lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]!\n                    [?v!/0]\n  closed\\<^sub>M\\<^sub>L 0 v\n  closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L w)\n\ngoal (8 subgoals):\n 1. \\<And>nm v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (C\\<^sub>M\\<^sub>L nm)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>M\\<^sub>L nm[v/0]! =\n                         lift 0 (C\\<^sub>M\\<^sub>L nm)[V\\<^sub>U 0 []/0]!\n                         [v!/0]\n 2. \\<And>v vs va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n                   \\<Longrightarrow> v[va/0]! =\n                                     lift 0 v[V\\<^sub>U 0 []/0]![va!/0];\n        \\<And>x v.\n           \\<lbrakk>x \\<in> set (rev vs); closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n           \\<Longrightarrow> x[v/0]! = lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L v vs[va/0]! =\n                         lift 0 (A\\<^sub>M\\<^sub>L v vs)[V\\<^sub>U 0 []/0]!\n                         [va!/0]\n 3. \\<And>v va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0)\n                     (lift 0 v[V\\<^sub>U 0 []/0])\\<rbrakk>\n                   \\<Longrightarrow> lift 0 v[V\\<^sub>U 0 []/0][va/0]! =\n                                     lift 0 (lift 0 v[V\\<^sub>U 0 []/0])\n                                     [V\\<^sub>U 0 []/0]!\n                                     [va!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> Lam\\<^sub>M\\<^sub>L v[va/0]! =\n                         lift 0 (Lam\\<^sub>M\\<^sub>L v)[V\\<^sub>U 0 []/0]!\n                         [va!/0]\n 4. \\<And>nm vs v.\n       \\<lbrakk>\\<And>x v.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n                   \\<Longrightarrow> x[v/0]! =\n                                     lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs[v/0]! =\n                         lift 0 (C\\<^sub>U nm vs)[V\\<^sub>U 0 []/0]![v!/0]\n 5. \\<And>x vs v.\n       \\<lbrakk>\\<And>xa v.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) xa\\<rbrakk>\n                   \\<Longrightarrow> xa[v/0]! =\n                                     lift 0 xa[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs[v/0]! =\n                         lift 0 (V\\<^sub>U x vs)[V\\<^sub>U 0 []/0]![v!/0]\n 6. \\<And>f vs n v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) f\\<rbrakk>\n                   \\<Longrightarrow> f[v/0]! =\n                                     lift 0 f[V\\<^sub>U 0 []/0]![v!/0];\n        \\<And>x v.\n           \\<lbrakk>x \\<in> set (rev vs); closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n           \\<Longrightarrow> x[v/0]! = lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n[v/0]! =\n                         lift 0 (Clo f vs n)[V\\<^sub>U 0 []/0]![v!/0]\n 7. \\<And>v w va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n                   \\<Longrightarrow> v[va/0]! =\n                                     lift 0 v[V\\<^sub>U 0 []/0]![va!/0];\n        \\<And>v.\n           \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) w\\<rbrakk>\n           \\<Longrightarrow> w[v/0]! = lift 0 w[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (apply v w)\\<rbrakk>\n       \\<Longrightarrow> apply v w[va/0]! =\n                         lift 0 (apply v w)[V\\<^sub>U 0 []/0]![va!/0]\n 8. \\<And>X v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (V\\<^sub>M\\<^sub>L X)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>M\\<^sub>L X[v/0]! =\n                         lift 0 (V\\<^sub>M\\<^sub>L X)[V\\<^sub>U 0 []/0]!\n                         [v!/0]", "show ?case (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"?L = \\<Lambda>(lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0] !)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    \\<Lambda>\n     (lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0]!)", "by (simp cong:if_cong0)"], ["proof (state)\nthis:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  \\<Lambda> (lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0]!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  \\<Lambda> (lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0]!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<dots> = \\<Lambda>((lift 0 w)[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0][V\\<^sub>U 0 []/0]!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0]!) =\n    \\<Lambda>\n     (lift 0 w[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0][V\\<^sub>U 0 []/0]!)", "by(simp only: lift_subst_ML1 lift_lift_ML_comm)"], ["proof (state)\nthis:\n  \\<Lambda>\n   (lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0]!) =\n  \\<Lambda>\n   (lift 0 w[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0][V\\<^sub>U 0 []/0]!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  \\<Lambda>\n   (lift 0 (w[lift\\<^sub>M\\<^sub>L 0 v/Suc 0])[V\\<^sub>U 0 []/0]!) =\n  \\<Lambda>\n   (lift 0 w[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0][V\\<^sub>U 0 []/0]!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<dots> = \\<Lambda>(subst\\<^sub>M\\<^sub>L (\\<lambda>n. if n=0 then V\\<^sub>U 0 [] else\n            if n=Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2)) (lift 0 w) !)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (lift 0 w[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0]\n      [V\\<^sub>U 0 []/0]!) =\n    \\<Lambda>\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n.\n           if n = 0 then V\\<^sub>U 0 []\n           else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n       (lift 0 w)!)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n.\n           if n = 0 then V\\<^sub>M\\<^sub>L n\n           else if n = Suc 0 then lift\\<^sub>M\\<^sub>L 0 (lift 0 v)\n                else V\\<^sub>M\\<^sub>L (n - 1))\n       (lift 0 w))! =\n    subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)!", "apply(rule arg_cong[where f = kernel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n.\n           if n = 0 then V\\<^sub>M\\<^sub>L n\n           else if n = Suc 0 then lift\\<^sub>M\\<^sub>L 0 (lift 0 v)\n                else V\\<^sub>M\\<^sub>L (n - 1))\n       (lift 0 w)) =\n    subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)", "apply(rule subst_ML_comp2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (if i = 0 then V\\<^sub>U 0 []\n        else if i = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (i - 2)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>n.\n            if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n        (if i = 0 then V\\<^sub>M\\<^sub>L i\n         else if i = Suc 0 then lift\\<^sub>M\\<^sub>L 0 (lift 0 v)\n              else V\\<^sub>M\\<^sub>L (i - 1))", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 ?v;\n   closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])\\<rbrakk>\n  \\<Longrightarrow> lift 0 w[V\\<^sub>U 0 []/0][?v/0]! =\n                    lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]!\n                    [?v!/0]\n  closed\\<^sub>M\\<^sub>L 0 v\n  closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L w)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (if i = 0 then V\\<^sub>U 0 []\n        else if i = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (i - 2)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>n.\n            if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n        (if i = 0 then V\\<^sub>M\\<^sub>L i\n         else if i = Suc 0 then lift\\<^sub>M\\<^sub>L 0 (lift 0 v)\n              else V\\<^sub>M\\<^sub>L (i - 1))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Lambda>\n   (lift 0 w[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0][V\\<^sub>U 0 []/0]!) =\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  \\<Lambda>\n   (lift 0 w[lift\\<^sub>M\\<^sub>L 0 (lift 0 v)/Suc 0][V\\<^sub>U 0 []/0]!) =\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<dots> = \\<Lambda>((lift 0 w)[V\\<^sub>U 0 []/0][lift 0 v/0]!)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n.\n           if n = 0 then V\\<^sub>U 0 []\n           else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n       (lift 0 w)!) =\n    \\<Lambda> (lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]!)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)! =\n    subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n. if n = 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 1))\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n.\n           if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n       (lift 0 w))!", "apply(rule arg_cong[where f = kernel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w) =\n    subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n. if n = 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 1))\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n.\n           if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n       (lift 0 w))", "apply(rule subst_ML_comp2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (if i = 0 then V\\<^sub>U 0 []\n        else if i = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (i - 2)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>n. if n = 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 1))\n        (if i = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (i - 1))", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 ?v;\n   closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])\\<rbrakk>\n  \\<Longrightarrow> lift 0 w[V\\<^sub>U 0 []/0][?v/0]! =\n                    lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]!\n                    [?v!/0]\n  closed\\<^sub>M\\<^sub>L 0 v\n  closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L w)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (if i = 0 then V\\<^sub>U 0 []\n        else if i = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (i - 2)) =\n       subst\\<^sub>M\\<^sub>L\n        (\\<lambda>n. if n = 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 1))\n        (if i = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (i - 1))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)!) =\n  \\<Lambda> (lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = Suc 0 then lift 0 v else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 w)!) =\n  \\<Lambda> (lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]!)\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<dots> = \\<Lambda>((lift_ml 0 ((lift_ml 0 w)[V\\<^sub>U 0 []/0]))[V\\<^sub>U 0 []/0]![(lift 0 v)!/0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> (lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]!) =\n    \\<Lambda>\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0])", "apply(rule arg_cong[where f = \\<Lambda>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]! =\n    lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0]", "apply(rule 3(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L 0 (lift 0 v)\n 2. closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])", "apply (metis closed_ML_lift 3(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])", "apply(subgoal_tac \"closed\\<^sub>M\\<^sub>L (Suc(Suc 0)) w\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])\n 2. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\n 2. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 ?v;\n   closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])\\<rbrakk>\n  \\<Longrightarrow> lift 0 w[V\\<^sub>U 0 []/0][?v/0]! =\n                    lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]!\n                    [?v!/0]\n  closed\\<^sub>M\\<^sub>L 0 v\n  closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L w)\n\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\n 2. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])", "apply(subgoal_tac  \"closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) (lift 0 w)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) (lift 0 w)\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0)\n                       (lift 0 w[V\\<^sub>U 0 []/0])\n 2. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) (lift 0 w)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) (lift 0 w)\n 2. \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) (lift 0 w)\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0)\n                       (lift 0 w[V\\<^sub>U 0 []/0])", "apply(erule closed_ML_lift)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) (lift 0 w)\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0)\n                       (lift 0 w[V\\<^sub>U 0 []/0])", "apply(erule closed_ML_subst_ML2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w \\<Longrightarrow>\n    \\<forall>i<Suc (Suc 0).\n       closed\\<^sub>M\\<^sub>L (Suc 0) (subst_decr_ML 0 (V\\<^sub>U 0 []) i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Lambda> (lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]!) =\n  \\<Lambda>\n   (lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  \\<Lambda> (lift 0 w[V\\<^sub>U 0 []/0][lift 0 v/0]!) =\n  \\<Lambda>\n   (lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<dots> = \\<Lambda>((lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 1 []/0])[V\\<^sub>U 0 []/0]![(lift 0 v)!/0])\" (is \"_ = ?M\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0]) =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "apply(subgoal_tac \"lift_ml 0 (lift_ml 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0] =\n                         lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0] \\<Longrightarrow>\n    \\<Lambda>\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0]) =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n 2. lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(subst lift_subst_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> subst_decr_ML 0 (V\\<^sub>U 0 []))\n     (lift 0 (lift 0 w))\n    [V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(simp add:comp_def if_distrib[where f=\"lift_ml 0\"] cong:if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Lambda>\n   (lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]![lift 0 v!/0]) =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "finally"], ["proof (chain)\npicking this:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "have \"?L = ?M\""], ["proof (prove)\nusing this:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "."], ["proof (state)\nthis:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"?R = \\<Lambda> (subst (V 0 ## subst_decr 0 (v!))\n          (lift 0 (lift_ml 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n    \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!))", "apply(subgoal_tac \"(V\\<^sub>M\\<^sub>L 0 ## (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - Suc 0))) = subst_decr_ML (Suc 0) (V\\<^sub>U 0 [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. V\\<^sub>M\\<^sub>L 0 ##\n    (\\<lambda>n.\n        if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - Suc 0)) =\n    subst_decr_ML (Suc 0) (V\\<^sub>U 0 []) \\<Longrightarrow>\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n    \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!))\n 2. V\\<^sub>M\\<^sub>L 0 ##\n    (\\<lambda>n.\n        if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - Suc 0)) =\n    subst_decr_ML (Suc 0) (V\\<^sub>U 0 [])", "apply(simp cong:if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^sub>M\\<^sub>L 0 ##\n    (\\<lambda>n.\n        if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - Suc 0)) =\n    subst_decr_ML (Suc 0) (V\\<^sub>U 0 [])", "apply(simp add:fun_eq_iff cons_ML_def split:nat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!))\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!))\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<dots> = \\<Lambda> (subst (V 0 ## subst_decr 0 (v!))\n          ((lift 0 (lift_ml 0 w))[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0]!))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!)) =\n    \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0]!))", "apply(subgoal_tac \"lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0]) = lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0]) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0] \\<Longrightarrow>\n    \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!)) =\n    \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0]!))\n 2. lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0]) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0]", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0]) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0]", "apply(subst lift_subst_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (lift 0 \\<circ> subst_decr_ML (Suc 0) (V\\<^sub>U 0 []))\n     (lift 0 (lift 0 w)) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0]", "apply(simp add:comp_def if_distrib[where f=\"lift_ml 0\"] cong:if_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!)) =\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0]!))\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w[V\\<^sub>U 0 []/Suc 0])[V\\<^sub>U 0 []/0]!)) =\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0]!))\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"(lift_ml 0 (lift_ml 0 w))[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n               (lift 0 (lift_ml 0 w))[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/ 0]\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "have \"?l = subst\\<^sub>M\\<^sub>L (\\<lambda>n. if n= 0 then V\\<^sub>U 0 [] else if n = 1 then V\\<^sub>U 1 [] else\n                      V\\<^sub>M\\<^sub>L (n - 2))\n               (lift_ml 0 (lift_ml 0 w))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = 1 then V\\<^sub>U 1 [] else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 (lift 0 w))", "by(auto intro!:subst_ML_comp2)"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n.\n       if n = 0 then V\\<^sub>U 0 []\n       else if n = 1 then V\\<^sub>U 1 [] else V\\<^sub>M\\<^sub>L (n - 2))\n   (lift 0 (lift 0 w))\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "also"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n.\n       if n = 0 then V\\<^sub>U 0 []\n       else if n = 1 then V\\<^sub>U 1 [] else V\\<^sub>M\\<^sub>L (n - 2))\n   (lift 0 (lift 0 w))\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "have \"\\<dots> = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n.\n         if n = 0 then V\\<^sub>U 0 []\n         else if n = 1 then V\\<^sub>U 1 [] else V\\<^sub>M\\<^sub>L (n - 2))\n     (lift 0 (lift 0 w)) =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "by(auto intro!:subst_ML_comp2[symmetric])"], ["proof (state)\nthis:\n  subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n.\n       if n = 0 then V\\<^sub>U 0 []\n       else if n = 1 then V\\<^sub>U 1 [] else V\\<^sub>M\\<^sub>L (n - 2))\n   (lift 0 (lift 0 w)) =\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "finally"], ["proof (chain)\npicking this:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "show ?thesis"], ["proof (prove)\nusing this:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]", "."], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "also"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/Suc 0][V\\<^sub>U 0 []/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "have \"\\<Lambda> (subst (V 0 ## subst_decr 0 (v!)) (?r !)) = ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)) =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)) =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "have \"subst (subst_decr (Suc 0) (lift_tm 0 (kernel v))) (lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!) =\n    subst (subst_decr 0 (kernel(lift_ml 0 v))) (lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]!)\" (is \"?a = ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "define pi where \"pi n = (if n = 0 then 1 else if n = 1 then 0 else n)\" for n :: nat"], ["proof (state)\nthis:\n  pi ?n = (if ?n = 0 then 1 else if ?n = 1 then 0 else ?n)\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "have \"(\\<lambda>i. V (pi i)[lift 0 (v!)/0]) = subst_decr (Suc 0) (lift 0 (v!))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) = subst_decr (Suc 0) (lift 0 (v!))", "by(rule ext)(simp add:pi_def)"], ["proof (state)\nthis:\n  (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) = subst_decr (Suc 0) (lift 0 (v!))\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "hence \"?a =\n  subst (subst_decr 0 (lift_tm 0 (kernel v))) (subst (\\<lambda> n. V(pi n)) (lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!))\""], ["proof (prove)\nusing this:\n  (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) = subst_decr (Suc 0) (lift 0 (v!))\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    subst (\\<lambda>n. V (pi n))\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n    [lift 0 (v!)/0]", "apply(subst subst_comp[OF _ _ refl])"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    pure (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))\n 3. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    subst (\\<lambda>i. V (pi i)[lift 0 (v!)/0])\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    subst (\\<lambda>i. V (pi i)[lift 0 (v!)/0])\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    pure (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n 3. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    pure (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "using 3(3)"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L w)\n\ngoal (2 subgoals):\n 1. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    pure (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> pure\n                       (subst\\<^sub>M\\<^sub>L\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 1 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n                         (subst\\<^sub>M\\<^sub>L\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1))\n                           (lift 0 (lift 0 w)))!)\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply(rule pure_kernel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0\n                       (subst\\<^sub>M\\<^sub>L\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 1 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n                         (subst\\<^sub>M\\<^sub>L\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1))\n                           (lift 0 (lift 0 w))))\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply(rule closed_ML_subst_ML2[where k=\"Suc 0\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0)\n                       (subst\\<^sub>M\\<^sub>L\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n                         (lift 0 (lift 0 w)))\n 2. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 3. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply(rule closed_ML_subst_ML2[where k=\"Suc(Suc 0)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc (Suc 0))\n                       (lift 0 (lift 0 w))\n 2. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc (Suc 0).\n                         closed\\<^sub>M\\<^sub>L (Suc 0)\n                          (if i = 0 then V\\<^sub>U 0 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 3. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 4. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc (Suc 0).\n                         closed\\<^sub>M\\<^sub>L (Suc 0)\n                          (if i = 0 then V\\<^sub>U 0 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 2. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 3. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<lambda>i. if pi i = 0 then lift 0 (v!) else V (pi i - 1)) =\n             (\\<lambda>n.\n                 if n = 0 then V n\n                 else if n = Suc 0 then lift 0 (v!) else V (n - 1));\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 2. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. V (pi i)[lift 0 (v!)/0]) =\n    subst_decr (Suc 0) (lift 0 (v!)) \\<Longrightarrow>\n    \\<forall>i. pure (V (pi i))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  subst (\\<lambda>n. V (pi n))\n   (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n  [lift 0 (v!)/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "also"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  subst (\\<lambda>n. V (pi n))\n   (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n  [lift 0 (v!)/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "have \"\\<dots> =\n (subst_ml pi (lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]))![lift_tm 0 (v!)/0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (\\<lambda>n. V (pi n))\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0]", "apply(subst subst_kernel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])\n 2. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0]", "using 3"], ["proof (prove)\nusing this:\n  \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 ?v;\n   closed\\<^sub>M\\<^sub>L (Suc 0) (lift 0 w[V\\<^sub>U 0 []/0])\\<rbrakk>\n  \\<Longrightarrow> lift 0 w[V\\<^sub>U 0 []/0][?v/0]! =\n                    lift 0 (lift 0 w[V\\<^sub>U 0 []/0])[V\\<^sub>U 0 []/0]!\n                    [?v!/0]\n  closed\\<^sub>M\\<^sub>L 0 v\n  closed\\<^sub>M\\<^sub>L (Suc 0) (Lam\\<^sub>M\\<^sub>L w)\n\ngoal (2 subgoals):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])\n 2. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0]", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0\n                       (subst\\<^sub>M\\<^sub>L\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 1 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n                         (subst\\<^sub>M\\<^sub>L\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1))\n                           (lift 0 (lift 0 w))))", "apply(rule closed_ML_subst_ML2[where k=\"Suc 0\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc 0)\n                       (subst\\<^sub>M\\<^sub>L\n                         (\\<lambda>n.\n                             if n = 0 then V\\<^sub>U 0 []\n                             else V\\<^sub>M\\<^sub>L (n - 1))\n                         (lift 0 (lift 0 w)))\n 2. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))", "apply(rule closed_ML_subst_ML2[where k=\"Suc(Suc 0)\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L (Suc (Suc 0))\n                       (lift 0 (lift 0 w))\n 2. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc (Suc 0).\n                         closed\\<^sub>M\\<^sub>L (Suc 0)\n                          (if i = 0 then V\\<^sub>U 0 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 3. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc (Suc 0).\n                         closed\\<^sub>M\\<^sub>L (Suc 0)\n                          (if i = 0 then V\\<^sub>U 0 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))\n 2. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                 closed\\<^sub>M\\<^sub>L (Suc 0)\n                  (subst\\<^sub>M\\<^sub>L\n                    (\\<lambda>n.\n                        if n = 0 then V\\<^sub>U 0 []\n                        else V\\<^sub>M\\<^sub>L (n - 1))\n                    (lift 0 w))\\<rbrakk>\n                \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                                   (\\<lambda>n.\n if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0 w))! =\n                                  subst\n                                   (\\<lambda>n.\n if n = 0 then v! else V (n - 1))\n                                   (subst\\<^sub>M\\<^sub>L\n                                     (\\<lambda>n.\n   if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n                                     (lift 0\n (subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1))\n   (lift 0 w)))!);\n     closed\\<^sub>M\\<^sub>L 0 v;\n     closed\\<^sub>M\\<^sub>L (Suc (Suc 0)) w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc 0.\n                         closed\\<^sub>M\\<^sub>L 0\n                          (if i = 0 then V\\<^sub>U 1 []\n                           else V\\<^sub>M\\<^sub>L (i - 1))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst (\\<lambda>n. V (pi n))\n   (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n  [lift 0 (v!)/0] =\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 (v!)/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "also"], ["proof (state)\nthis:\n  subst (\\<lambda>n. V (pi n))\n   (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)\n  [lift 0 (v!)/0] =\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 (v!)/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "have \"\\<dots> = (subst_ml pi (lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]))![lift 0 v!/0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0]", "have \"lift 0 (v!) = lift 0 v!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 (v!) = lift 0 v!", "by (metis 3(2) kernel_lift_tm)"], ["proof (state)\nthis:\n  lift 0 (v!) = lift 0 v!\n\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0]", "thus ?thesis"], ["proof (prove)\nusing this:\n  lift 0 (v!) = lift 0 v!\n\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 (v!)/0] =\n    subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0]", "by (simp cong:if_cong)"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 (v!)/0] =\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 v!/0]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 (v!)/0] =\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 v!/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "also"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 (v!)/0] =\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 v!/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "have \"\\<dots> = ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "have 1: \"subst_ml pi (lift 0 (lift 0 w)) = lift 0 (lift 0 w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)) = lift 0 (lift 0 w)", "apply(simp add:lift_is_subst_ml subst_ml_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml (pi \\<circ> (Suc \\<circ> Suc)) w = subst_ml (Suc \\<circ> Suc) w", "apply(subgoal_tac \"pi \\<circ> (Suc \\<circ> Suc) = (Suc \\<circ> Suc)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. pi \\<circ> (Suc \\<circ> Suc) = Suc \\<circ> Suc \\<Longrightarrow>\n    subst_ml (pi \\<circ> (Suc \\<circ> Suc)) w = subst_ml (Suc \\<circ> Suc) w\n 2. pi \\<circ> (Suc \\<circ> Suc) = Suc \\<circ> Suc", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pi \\<circ> (Suc \\<circ> Suc) = Suc \\<circ> Suc", "apply(simp add:pi_def fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)) = lift 0 (lift 0 w)\n\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "have \"subst_ml pi (lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]) =\n             lift_ml 0 (lift_ml 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(subst subst_ml_subst_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 1 []))\n     (subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0])) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(subst subst_ml_subst_ML)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 1 []))\n     (subst\\<^sub>M\\<^sub>L\n       (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 0 []))\n       (subst_ml pi (lift 0 (lift 0 w)))) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(subst 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 1 []))\n     (subst\\<^sub>M\\<^sub>L\n       (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 0 []))\n       (lift 0 (lift 0 w))) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(subst subst_ML_comp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L\n     (subst\\<^sub>M\\<^sub>L\n       (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 1 [])) \\<circ>\n      (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 0 [])))\n     (lift 0 (lift 0 w)) =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]", "apply(rule subst_ML_comp2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (subst\\<^sub>M\\<^sub>L\n         (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 1 [])) \\<circ>\n        (subst_ml pi \\<circ> subst_decr_ML 0 (V\\<^sub>U 0 [])))\n        i =\n       subst_decr_ML 0 (V\\<^sub>U 1 []) i[V\\<^sub>U 0 []/0]", "apply(auto simp:pi_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]) =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]\n\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]) =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]\n\ngoal (1 subgoal):\n 1. subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n    [lift 0 v!/0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "by simp"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 v!/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_ml pi (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0])!\n  [lift 0 v!/0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "finally"], ["proof (chain)\npicking this:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "show ?thesis"], ["proof (prove)\nusing this:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]\n\ngoal (1 subgoal):\n 1. lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n    [lift 0 (v!)/Suc 0] =\n    lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]", "."], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]\n\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)) =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "thus ?thesis"], ["proof (prove)\nusing this:\n  lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!\n  [lift 0 (v!)/Suc 0] =\n  lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0]\n\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst (V 0 ## subst_decr 0 (v!))\n       (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)) =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "by(simp cong:if_cong0 add:shift_subst_decr)"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)) =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst (V 0 ## subst_decr 0 (v!))\n     (lift 0 (lift 0 w)[V\\<^sub>U 0 []/0][V\\<^sub>U 1 []/0]!)) =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "finally"], ["proof (chain)\npicking this:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "have \"?R = ?M\""], ["proof (prove)\nusing this:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n    \\<Lambda>\n     (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "."], ["proof (state)\nthis:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "then"], ["proof (chain)\npicking this:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])", "show \"?L = ?R\""], ["proof (prove)\nusing this:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "using \\<open>?L = ?M\\<close>"], ["proof (prove)\nusing this:\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0] =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  \\<Lambda>\n   (lift 0 (lift 0 w)[V\\<^sub>U 1 []/0][V\\<^sub>U 0 []/0]![lift 0 v!/0])\n\ngoal (1 subgoal):\n 1. Lam\\<^sub>M\\<^sub>L w[v/0]! =\n    lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]", "by metis"], ["proof (state)\nthis:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lam\\<^sub>M\\<^sub>L w[v/0]! =\n  lift 0 (Lam\\<^sub>M\\<^sub>L w)[V\\<^sub>U 0 []/0]![v!/0]\n\ngoal (7 subgoals):\n 1. \\<And>nm v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (C\\<^sub>M\\<^sub>L nm)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>M\\<^sub>L nm[v/0]! =\n                         lift 0 (C\\<^sub>M\\<^sub>L nm)[V\\<^sub>U 0 []/0]!\n                         [v!/0]\n 2. \\<And>v vs va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n                   \\<Longrightarrow> v[va/0]! =\n                                     lift 0 v[V\\<^sub>U 0 []/0]![va!/0];\n        \\<And>x v.\n           \\<lbrakk>x \\<in> set (rev vs); closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n           \\<Longrightarrow> x[v/0]! = lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L v vs[va/0]! =\n                         lift 0 (A\\<^sub>M\\<^sub>L v vs)[V\\<^sub>U 0 []/0]!\n                         [va!/0]\n 3. \\<And>nm vs v.\n       \\<lbrakk>\\<And>x v.\n                   \\<lbrakk>x \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n                   \\<Longrightarrow> x[v/0]! =\n                                     lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs[v/0]! =\n                         lift 0 (C\\<^sub>U nm vs)[V\\<^sub>U 0 []/0]![v!/0]\n 4. \\<And>x vs v.\n       \\<lbrakk>\\<And>xa v.\n                   \\<lbrakk>xa \\<in> set (rev vs);\n                    closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) xa\\<rbrakk>\n                   \\<Longrightarrow> xa[v/0]! =\n                                     lift 0 xa[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs[v/0]! =\n                         lift 0 (V\\<^sub>U x vs)[V\\<^sub>U 0 []/0]![v!/0]\n 5. \\<And>f vs n v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) f\\<rbrakk>\n                   \\<Longrightarrow> f[v/0]! =\n                                     lift 0 f[V\\<^sub>U 0 []/0]![v!/0];\n        \\<And>x v.\n           \\<lbrakk>x \\<in> set (rev vs); closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) x\\<rbrakk>\n           \\<Longrightarrow> x[v/0]! = lift 0 x[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n[v/0]! =\n                         lift 0 (Clo f vs n)[V\\<^sub>U 0 []/0]![v!/0]\n 6. \\<And>v w va.\n       \\<lbrakk>\\<And>va.\n                   \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 va;\n                    closed\\<^sub>M\\<^sub>L (Suc 0) v\\<rbrakk>\n                   \\<Longrightarrow> v[va/0]! =\n                                     lift 0 v[V\\<^sub>U 0 []/0]![va!/0];\n        \\<And>v.\n           \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n            closed\\<^sub>M\\<^sub>L (Suc 0) w\\<rbrakk>\n           \\<Longrightarrow> w[v/0]! = lift 0 w[V\\<^sub>U 0 []/0]![v!/0];\n        closed\\<^sub>M\\<^sub>L 0 va;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (apply v w)\\<rbrakk>\n       \\<Longrightarrow> apply v w[va/0]! =\n                         lift 0 (apply v w)[V\\<^sub>U 0 []/0]![va!/0]\n 7. \\<And>X v.\n       \\<lbrakk>closed\\<^sub>M\\<^sub>L 0 v;\n        closed\\<^sub>M\\<^sub>L (Suc 0) (V\\<^sub>M\\<^sub>L X)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>M\\<^sub>L X[v/0]! =\n                         lift 0 (V\\<^sub>M\\<^sub>L X)[V\\<^sub>U 0 []/0]!\n                         [v!/0]", "qed (simp_all add:list_eq_iff_nth_eq, (simp_all add:rev_nth)?)"], ["", "section \\<open>Compiler \\label{sec:Compiler}\\<close>"], ["", "axiomatization arity :: \"cname \\<Rightarrow> nat\""], ["", "primrec compile :: \"tm \\<Rightarrow> (nat \\<Rightarrow> ml) \\<Rightarrow> ml\"\nwhere\n  \"compile (V x) \\<sigma> = \\<sigma> x\"\n| \"compile (C nm) \\<sigma> =\n    (if arity nm > 0 then Clo (C\\<^sub>M\\<^sub>L nm) [] (arity nm) else A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) [])\"\n| \"compile (s \\<bullet> t) \\<sigma> = apply (compile s \\<sigma>) (compile t \\<sigma>)\"\n| \"compile (\\<Lambda> t) \\<sigma> = Clo (Lam\\<^sub>M\\<^sub>L (compile t (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))) [] 1\""], ["", "text\\<open>Compiler for open terms and for terms with fixed free variables:\\<close>"], ["", "definition \"comp_open t = compile t V\\<^sub>M\\<^sub>L\""], ["", "abbreviation \"comp_fixed t \\<equiv> compile t (\\<lambda>i. V\\<^sub>U i [])\""], ["", "text\\<open>Compiled rules:\\<close>"], ["", "lemma size_args_less_size_tm[simp]: \"s \\<in> set (args_tm t) \\<Longrightarrow> size s < size t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> set (args_tm t) \\<Longrightarrow> size s < size t", "by(induct t) auto"], ["", "fun comp_pat where\n\"comp_pat t =\n   (case head_tm t of\n     C nm \\<Rightarrow> C\\<^sub>U nm (map comp_pat (rev (args_tm t)))\n   | V X \\<Rightarrow> V\\<^sub>M\\<^sub>L X)\""], ["", "declare comp_pat.simps[simp del] size_args_less_size_tm[simp del]"], ["", "lemma comp_pat_V[simp]: \"comp_pat(V X) = V\\<^sub>M\\<^sub>L X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_pat (V X) = V\\<^sub>M\\<^sub>L X", "by(simp add:comp_pat.simps)"], ["", "lemma comp_pat_C[simp]:\n  \"comp_pat(C nm \\<bullet>\\<bullet> ts) = C\\<^sub>U nm (map comp_pat (rev ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_pat (C nm \\<bullet>\\<bullet> ts) =\n    C\\<^sub>U nm (map comp_pat (rev ts))", "by(simp add:comp_pat.simps)"], ["", "lemma comp_pat_C_Nil[simp]: \"comp_pat(C nm) = C\\<^sub>U nm []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_pat (C nm) = C\\<^sub>U nm []", "by(simp add:comp_pat.simps)"], ["", "overloading compR \\<equiv> compR\nbegin"], ["", "definition \"compR \\<equiv> (\\<lambda>(nm,ts,t). (nm, map comp_pat (rev ts), comp_open t)) ` R\""], ["", "end"], ["", "lemma fv_ML_comp_open: \"pure t \\<Longrightarrow> fv\\<^sub>M\\<^sub>L(comp_open t) = fv t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> fv\\<^sub>M\\<^sub>L (comp_open t) = fv t", "by(induct t pred:pure) (simp_all add:comp_open_def)"], ["", "lemma fv_ML_comp_pat: \"pattern t \\<Longrightarrow> fv\\<^sub>M\\<^sub>L(comp_pat t) = fv t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pattern t \\<Longrightarrow> fv\\<^sub>M\\<^sub>L (comp_pat t) = fv t", "by(induct t pred:pattern)(simp_all add:comp_open_def)"], ["", "lemma fv_compR_aux:\n  \"(nm,ts,t') : R \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L (comp_open t')\n   \\<Longrightarrow> \\<exists>t\\<in>set ts. x \\<in> fv\\<^sub>M\\<^sub>L(comp_pat t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(nm, ts, t') \\<in> R;\n     x \\<in> fv\\<^sub>M\\<^sub>L (comp_open t')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set ts.\n                         x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t)", "apply(frule pure_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(nm, ts, t') \\<in> R;\n     x \\<in> fv\\<^sub>M\\<^sub>L (comp_open t');\n     (\\<forall>t\\<in>set ts. pure t) \\<and> pure t'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set ts.\n                         x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t)", "apply(simp add:fv_ML_comp_open)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t';\n     (\\<forall>t\\<in>set ts. pure t) \\<and> pure t'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set ts.\n                         x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t)", "apply(frule (1) fv_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t';\n     (\\<forall>t\\<in>set ts. pure t) \\<and> pure t';\n     \\<exists>t'\\<in>set ts. x \\<in> fv t'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t\\<in>set ts.\n                         x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t'; t'a \\<in> set ts;\n        x \\<in> fv t'a; \\<forall>t\\<in>set ts. pure t; pure t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t\\<in>set ts.\n                            x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t)", "apply(rule bexI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t'a.\n       \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t'; t'a \\<in> set ts;\n        x \\<in> fv t'a; \\<forall>t\\<in>set ts. pure t; pure t'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat (?t7 t'a))\n 2. \\<And>t'a.\n       \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t'; t'a \\<in> set ts;\n        x \\<in> fv t'a; \\<forall>t\\<in>set ts. pure t; pure t'\\<rbrakk>\n       \\<Longrightarrow> ?t7 t'a \\<in> set ts", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t'a.\n       \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t'; t'a \\<in> set ts;\n        x \\<in> fv t'a; \\<forall>t\\<in>set ts. pure t; pure t'\\<rbrakk>\n       \\<Longrightarrow> ?t7 t'a \\<in> set ts\n 2. \\<And>t'a.\n       \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t'; t'a \\<in> set ts;\n        x \\<in> fv t'a; \\<forall>t\\<in>set ts. pure t; pure t'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat (?t7 t'a))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>(nm, ts, t') \\<in> R; x \\<in> fv t'; t'a \\<in> set ts;\n        x \\<in> fv t'a; \\<forall>t\\<in>set ts. pure t; pure t'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t'a)", "apply(drule pattern_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t'a.\n       \\<lbrakk>x \\<in> fv t'; t'a \\<in> set ts; x \\<in> fv t'a;\n        \\<forall>t\\<in>set ts. pure t; pure t'; patterns ts\\<rbrakk>\n       \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L (comp_pat t'a)", "apply(simp add:fv_ML_comp_pat)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fv_compR:\n  \"(nm,vs,v) : compR \\<Longrightarrow> x \\<in> fv\\<^sub>M\\<^sub>L v \\<Longrightarrow> \\<exists>u\\<in>set vs. x \\<in> fv\\<^sub>M\\<^sub>L u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(nm, vs, v) \\<in> compR; x \\<in> fv\\<^sub>M\\<^sub>L v\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u\\<in>set vs. x \\<in> fv\\<^sub>M\\<^sub>L u", "by(fastforce simp add:compR_def image_def dest: fv_compR_aux)"], ["", "lemma lift_compile:\n  \"pure t \\<Longrightarrow> \\<forall>\\<sigma> k. lift k (compile t \\<sigma>) = compile t (lift k \\<circ> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow>\n    \\<forall>\\<sigma> k.\n       lift k (compile t \\<sigma>) = compile t (lift k \\<circ> \\<sigma>)", "apply(induct pred:pure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm.\n       \\<forall>\\<sigma> k.\n          lift k (compile (C nm) \\<sigma>) =\n          compile (C nm) (lift k \\<circ> \\<sigma>)\n 2. \\<And>x.\n       \\<forall>\\<sigma> k.\n          lift k (compile (V x) \\<sigma>) =\n          compile (V x) (lift k \\<circ> \\<sigma>)\n 3. \\<And>t.\n       \\<lbrakk>pure t;\n        \\<forall>\\<sigma> k.\n           lift k (compile t \\<sigma>) =\n           compile t (lift k \\<circ> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma> k.\n                            lift k (compile (\\<Lambda> t) \\<sigma>) =\n                            compile (\\<Lambda> t) (lift k \\<circ> \\<sigma>)\n 4. \\<And>s t.\n       \\<lbrakk>pure s;\n        \\<forall>\\<sigma> k.\n           lift k (compile s \\<sigma>) =\n           compile s (lift k \\<circ> \\<sigma>);\n        pure t;\n        \\<forall>\\<sigma> k.\n           lift k (compile t \\<sigma>) =\n           compile t (lift k \\<circ> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma> k.\n                            lift k (compile (s \\<bullet> t) \\<sigma>) =\n                            compile (s \\<bullet> t)\n                             (lift k \\<circ> \\<sigma>)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>pure t;\n        \\<forall>\\<sigma> k.\n           lift k (compile t \\<sigma>) =\n           compile t (\\<lambda>a. lift k (\\<sigma> a))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma> k.\n                            compile t\n                             (\\<lambda>a.\n                                 lift k\n                                  (if a = 0 then V\\<^sub>M\\<^sub>L 0\n                                   else lift\\<^sub>M\\<^sub>L 0\n   (\\<sigma> (a - 1)))) =\n                            compile t\n                             (V\\<^sub>M\\<^sub>L 0 ##\n                              (\\<lambda>a. lift k (\\<sigma> a)))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> k.\n       \\<lbrakk>pure t;\n        \\<forall>\\<sigma> k.\n           lift k (compile t \\<sigma>) =\n           compile t (\\<lambda>a. lift k (\\<sigma> a))\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (\\<lambda>a.\n                              lift k\n                               (if a = 0 then V\\<^sub>M\\<^sub>L 0\n                                else lift\\<^sub>M\\<^sub>L 0\n(\\<sigma> (a - 1)))) =\n                         compile t\n                          (V\\<^sub>M\\<^sub>L 0 ##\n                           (\\<lambda>a. lift k (\\<sigma> a)))", "apply(rule_tac f = \"compile t\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> k.\n       \\<lbrakk>pure t;\n        \\<forall>\\<sigma> k.\n           lift k (compile t \\<sigma>) =\n           compile t (\\<lambda>a. lift k (\\<sigma> a))\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a.\n                             lift k\n                              (if a = 0 then V\\<^sub>M\\<^sub>L 0\n                               else lift\\<^sub>M\\<^sub>L 0\n                                     (\\<sigma> (a - 1)))) =\n                         V\\<^sub>M\\<^sub>L 0 ##\n                         (\\<lambda>a. lift k (\\<sigma> a))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> k x.\n       \\<lbrakk>pure t;\n        \\<forall>\\<sigma> k.\n           lift k (compile t \\<sigma>) =\n           compile t (\\<lambda>a. lift k (\\<sigma> a))\\<rbrakk>\n       \\<Longrightarrow> lift k\n                          (if x = 0 then V\\<^sub>M\\<^sub>L 0\n                           else lift\\<^sub>M\\<^sub>L 0 (\\<sigma> (x - 1))) =\n                         (V\\<^sub>M\\<^sub>L 0 ##\n                          (\\<lambda>a. lift k (\\<sigma> a)))\n                          x", "apply (clarsimp simp: lift_lift_ML_comm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subst_ML_compile:\n  \"pure t \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>' (compile t \\<sigma>) = compile t (subst\\<^sub>M\\<^sub>L \\<sigma>' o \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow>\n    subst\\<^sub>M\\<^sub>L \\<sigma>' (compile t \\<sigma>) =\n    compile t (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)", "apply(induct arbitrary: \\<sigma> \\<sigma>' pred:pure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma> \\<sigma>'.\n       subst\\<^sub>M\\<^sub>L \\<sigma>' (compile (C nm) \\<sigma>) =\n       compile (C nm) (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n 2. \\<And>x \\<sigma> \\<sigma>'.\n       subst\\<^sub>M\\<^sub>L \\<sigma>' (compile (V x) \\<sigma>) =\n       compile (V x) (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n 3. \\<And>t \\<sigma> \\<sigma>'.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>' (compile t \\<sigma>) =\n           compile t\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>'\n                          (compile (\\<Lambda> t) \\<sigma>) =\n                         compile (\\<Lambda> t)\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\n 4. \\<And>s t \\<sigma> \\<sigma>'.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma> \\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>' (compile s \\<sigma>) =\n           compile s (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>);\n        pure t;\n        \\<And>\\<sigma> \\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>' (compile t \\<sigma>) =\n           compile t\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>'\n                          (compile (s \\<bullet> t) \\<sigma>) =\n                         compile (s \\<bullet> t)\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>'.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma> \\<sigma>'.\n           subst\\<^sub>M\\<^sub>L \\<sigma>' (compile t \\<sigma>) =\n           compile t\n            (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n                           V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) =\n                         compile t\n                          (V\\<^sub>M\\<^sub>L 0 ##\n                           (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n                            \\<sigma>))", "apply(erule_tac x=\"V\\<^sub>M\\<^sub>L 0 ## \\<sigma>'\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>'.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>''.\n           subst\\<^sub>M\\<^sub>L \\<sigma>''\n            (compile t (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')) =\n           compile t\n            (subst\\<^sub>M\\<^sub>L \\<sigma>'' \\<circ>\n             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n                           V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) =\n                         compile t\n                          (V\\<^sub>M\\<^sub>L 0 ##\n                           (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n                            \\<sigma>))", "apply(erule_tac x= \"V\\<^sub>M\\<^sub>L 0 ## (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>)\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>'.\n       \\<lbrakk>pure t;\n        subst\\<^sub>M\\<^sub>L\n         (V\\<^sub>M\\<^sub>L 0 ## (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>))\n         (compile t (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')) =\n        compile t\n         (subst\\<^sub>M\\<^sub>L\n           (V\\<^sub>M\\<^sub>L 0 ##\n            (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>)) \\<circ>\n          V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (subst\\<^sub>M\\<^sub>L\n                            (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n                           V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) =\n                         compile t\n                          (V\\<^sub>M\\<^sub>L 0 ##\n                           (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n                            \\<sigma>))", "apply(rule_tac f = \"compile t\" in arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>'.\n       \\<lbrakk>pure t;\n        subst\\<^sub>M\\<^sub>L\n         (V\\<^sub>M\\<^sub>L 0 ## (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>))\n         (compile t (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')) =\n        compile t\n         (subst\\<^sub>M\\<^sub>L\n           (V\\<^sub>M\\<^sub>L 0 ##\n            (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>)) \\<circ>\n          V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n                         V\\<^sub>M\\<^sub>L 0 ## \\<sigma> =\n                         V\\<^sub>M\\<^sub>L 0 ##\n                         (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ> \\<sigma>)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> \\<sigma>' x.\n       \\<lbrakk>pure t;\n        subst\\<^sub>M\\<^sub>L\n         (V\\<^sub>M\\<^sub>L 0 ## (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>))\n         (compile t (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')) =\n        compile t\n         (subst\\<^sub>M\\<^sub>L\n           (V\\<^sub>M\\<^sub>L 0 ##\n            (lift\\<^sub>M\\<^sub>L 0 \\<circ> \\<sigma>)) \\<circ>\n          V\\<^sub>M\\<^sub>L 0 ## \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> (subst\\<^sub>M\\<^sub>L\n                           (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>') \\<circ>\n                          V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                          x =\n                         (V\\<^sub>M\\<^sub>L 0 ##\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>' \\<circ>\n                           \\<sigma>))\n                          x", "apply (auto simp add:subst_ML_ext lift_ML_subst_ML)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem kernel_compile:\n  \"pure t \\<Longrightarrow> \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow> (compile t \\<sigma>)! = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n    \\<Longrightarrow> compile t \\<sigma>! = t", "apply(induct arbitrary: \\<sigma> pred:pure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n       compile (C nm) \\<sigma>! = C nm\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n       compile (V x) \\<sigma>! = V x\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> compile (\\<Lambda> t) \\<sigma>! = \\<Lambda> t\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile s \\<sigma>! = s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> compile (s \\<bullet> t) \\<sigma>! = s \\<bullet> t", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (lift 0\n                            (compile t\n                              (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)))! =\n                         t", "apply(subst lift_compile)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> pure t\n 2. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (compile t\n                            (lift 0 \\<circ>\n                             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))! =\n                         t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1))\n                          (compile t\n                            (lift 0 \\<circ>\n                             V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))! =\n                         t", "apply(subst subst_ML_compile)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> pure t\n 2. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n                           (lift 0 \\<circ>\n                            V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))! =\n                         t", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n                           (lift 0 \\<circ>\n                            V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))! =\n                         t", "apply(subgoal_tac \"(subst\\<^sub>M\\<^sub>L (\\<lambda>n. if n = 0 then V\\<^sub>U 0 [] else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n               (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)) = (\\<lambda>a. V\\<^sub>U a [])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i [];\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>n.\n             if n = 0 then V\\<^sub>U 0 []\n             else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n        (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) =\n        (\\<lambda>a. V\\<^sub>U a [])\\<rbrakk>\n       \\<Longrightarrow> compile t\n                          (subst\\<^sub>M\\<^sub>L\n                            (\\<lambda>n.\n                                if n = 0 then V\\<^sub>U 0 []\n                                else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n                           (lift 0 \\<circ>\n                            V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))! =\n                         t\n 2. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n                         (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) =\n                         (\\<lambda>a. V\\<^sub>U a [])", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>n.\n                              if n = 0 then V\\<^sub>U 0 []\n                              else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n                         (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) =\n                         (\\<lambda>a. V\\<^sub>U a [])", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> a.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i. \\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n           compile t \\<sigma>! = t;\n        \\<forall>i. \\<sigma> i = V\\<^sub>U i []\\<rbrakk>\n       \\<Longrightarrow> (subst\\<^sub>M\\<^sub>L\n                           (\\<lambda>n.\n                               if n = 0 then V\\<^sub>U 0 []\n                               else V\\<^sub>M\\<^sub>L (n - 1)) \\<circ>\n                          (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))\n                          a =\n                         V\\<^sub>U a []", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma kernel_subst_ML_pat:\n  \"pure t \\<Longrightarrow> pattern t \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   (subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t))! = subst (kernel \\<circ> \\<sigma>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; pattern t;\n     \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n                      subst (kernel \\<circ> \\<sigma>) t", "apply(induct arbitrary: \\<sigma> pred:pure)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<lbrakk>pattern (C nm);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (C nm))! =\n                         subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<lbrakk>pattern (V x);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (V x))! =\n                         subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern t;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n                             subst (kernel \\<circ> \\<sigma>) t;\n        pattern (\\<Lambda> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_pat (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern s;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat s)! =\n                             subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern t;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n                             subst (kernel \\<circ> \\<sigma>) t;\n        pattern (s \\<bullet> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_pat (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern s;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat s)! =\n                             subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern t;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n                             subst (kernel \\<circ> \\<sigma>) t;\n        pattern (s \\<bullet> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_pat (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) s \\<bullet>\n                         subst (kernel \\<circ> \\<sigma>) t", "apply(frule pattern_At_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern s;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat s)! =\n                             subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern t;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n                             subst (kernel \\<circ> \\<sigma>) t;\n        pattern (s \\<bullet> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_pat (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) s \\<bullet>\n                         subst (kernel \\<circ> \\<sigma>) t", "apply(frule pattern_AtD12)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern s;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat s)! =\n                             subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<lbrakk>pattern t;\n            \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n           \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n                             subst (kernel \\<circ> \\<sigma>) t;\n        pattern (s \\<bullet> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        \\<exists>nm ss. s = C nm \\<bullet>\\<bullet> ss;\n        pattern s \\<and> pattern t\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_pat (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) s \\<bullet>\n                         subst (kernel \\<circ> \\<sigma>) t", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> nm ss.\n       \\<lbrakk>pure (C nm \\<bullet>\\<bullet> ss);\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 (rev ss))! =\n           map (subst (kernel \\<circ> \\<sigma>)) ss;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        pattern ((C nm \\<bullet>\\<bullet> ss) \\<bullet> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        pattern (C nm \\<bullet>\\<bullet> ss); pattern t\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_pat\n                            ((C nm \\<bullet>\\<bullet> ss) \\<bullet> t))! =\n                         (C nm \\<bullet>\\<bullet>\n                          map (subst (kernel \\<circ> \\<sigma>))\n                           ss) \\<bullet>\n                         subst (kernel \\<circ> \\<sigma>) t", "apply(subst comp_pat.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t \\<sigma> nm ss.\n       \\<lbrakk>pure (C nm \\<bullet>\\<bullet> ss);\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 (rev ss))! =\n           map (subst (kernel \\<circ> \\<sigma>)) ss;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        pattern ((C nm \\<bullet>\\<bullet> ss) \\<bullet> t);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        pattern (C nm \\<bullet>\\<bullet> ss); pattern t\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (case head_tm\n                                 ((C nm \\<bullet>\\<bullet> ss) \\<bullet>\n                                  t) of\n                           C nma \\<Rightarrow>\n                             C\\<^sub>U nma\n                              (map comp_pat\n                                (rev (args_tm\n ((C nm \\<bullet>\\<bullet> ss) \\<bullet> t))))\n                           | V x \\<Rightarrow> V\\<^sub>M\\<^sub>L x)! =\n                         (C nm \\<bullet>\\<bullet>\n                          map (subst (kernel \\<circ> \\<sigma>))\n                           ss) \\<bullet>\n                         subst (kernel \\<circ> \\<sigma>) t", "apply(simp add: rev_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma kernel_subst_ML:\n  \"pure t \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   (subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t))! = subst (kernel \\<circ> \\<sigma>) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t;\n     \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n                      subst (kernel \\<circ> \\<sigma>) t", "proof(induct arbitrary: \\<sigma> pred:pure)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "case (Lam t)"], ["proof (state)\nthis:\n  pure t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (?\\<sigma> i) \\<Longrightarrow>\n  subst\\<^sub>M\\<^sub>L ?\\<sigma> (comp_open t)! =\n  subst (kernel \\<circ> ?\\<sigma>) t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "have \"lift 0 o V\\<^sub>M\\<^sub>L = V\\<^sub>M\\<^sub>L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 \\<circ> V\\<^sub>M\\<^sub>L = V\\<^sub>M\\<^sub>L", "by (simp add:fun_eq_iff)"], ["proof (state)\nthis:\n  lift 0 \\<circ> V\\<^sub>M\\<^sub>L = V\\<^sub>M\\<^sub>L\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "hence \"(subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t)))! =\n    \\<Lambda> (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) (comp_open t)[V\\<^sub>U 0 []/0]!)\""], ["proof (prove)\nusing this:\n  lift 0 \\<circ> V\\<^sub>M\\<^sub>L = V\\<^sub>M\\<^sub>L\n\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n    \\<Lambda>\n     (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n       (comp_open t)\n      [V\\<^sub>U 0 []/0]!)", "using Lam"], ["proof (prove)\nusing this:\n  lift 0 \\<circ> V\\<^sub>M\\<^sub>L = V\\<^sub>M\\<^sub>L\n  pure t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (?\\<sigma> i) \\<Longrightarrow>\n  subst\\<^sub>M\\<^sub>L ?\\<sigma> (comp_open t)! =\n  subst (kernel \\<circ> ?\\<sigma>) t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n    \\<Lambda>\n     (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n       (comp_open t)\n      [V\\<^sub>U 0 []/0]!)", "by(simp add: lift_subst_ML comp_open_def lift_compile)"], ["proof (state)\nthis:\n  subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n     (comp_open t)\n    [V\\<^sub>U 0 []/0]!)\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "also"], ["proof (state)\nthis:\n  subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n     (comp_open t)\n    [V\\<^sub>U 0 []/0]!)\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "have \"\\<dots> = \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n       (comp_open t)\n      [V\\<^sub>U 0 []/0]!) =\n    \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t)", "using Lam"], ["proof (prove)\nusing this:\n  pure t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (?\\<sigma> i) \\<Longrightarrow>\n  subst\\<^sub>M\\<^sub>L ?\\<sigma> (comp_open t)! =\n  subst (kernel \\<circ> ?\\<sigma>) t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. \\<Lambda>\n     (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n       (comp_open t)\n      [V\\<^sub>U 0 []/0]!) =\n    \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t)", "by(simp add: subst_ML_comp subst_ext kernel_lift_tm)"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n     (comp_open t)\n    [V\\<^sub>U 0 []/0]!) =\n  \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t)\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "also"], ["proof (state)\nthis:\n  \\<Lambda>\n   (subst\\<^sub>M\\<^sub>L (lift 0 \\<circ> V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n     (comp_open t)\n    [V\\<^sub>U 0 []/0]!) =\n  \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t)\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "have \"\\<dots> = subst (kernel o \\<sigma>) (\\<Lambda> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t) =\n    subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)", "by simp"], ["proof (state)\nthis:\n  \\<Lambda> (subst (V 0 ## (kernel \\<circ> \\<sigma>)) t) =\n  subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n\ngoal (4 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>t \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (\\<Lambda> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n 4. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "finally"], ["proof (chain)\npicking this:\n  subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n  subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)", "show ?case"], ["proof (prove)\nusing this:\n  subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n  subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n\ngoal (1 subgoal):\n 1. subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n    subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)", "."], ["proof (state)\nthis:\n  subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (\\<Lambda> t))! =\n  subst (kernel \\<circ> \\<sigma>) (\\<Lambda> t)\n\ngoal (3 subgoals):\n 1. \\<And>nm \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (C nm))! =\n       subst (kernel \\<circ> \\<sigma>) (C nm)\n 2. \\<And>x \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n       subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open (V x))! =\n       subst (kernel \\<circ> \\<sigma>) (V x)\n 3. \\<And>s t \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open s)! =\n           subst (kernel \\<circ> \\<sigma>) s;\n        pure t;\n        \\<And>\\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open t)! =\n           subst (kernel \\<circ> \\<sigma>) t;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (comp_open (s \\<bullet> t))! =\n                         subst (kernel \\<circ> \\<sigma>) (s \\<bullet> t)", "qed (simp_all add:comp_open_def)"], ["", "lemma kernel_subst_ML_pat_map:\n  \"\\<forall>t \\<in> set ts. pure t \\<Longrightarrow> patterns ts \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i) \\<Longrightarrow>\n   map kernel (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ts)) =\n   map (subst (kernel \\<circ> \\<sigma>)) ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t\\<in>set ts. pure t; patterns ts;\n     \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                       (map comp_pat ts)! =\n                      map (subst (kernel \\<circ> \\<sigma>)) ts", "by(simp add:list_eq_iff_nth_eq kernel_subst_ML_pat)"], ["", "lemma compR_Red_tm: \"(nm, vs, v) : compR \\<Longrightarrow> \\<forall> i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n  \\<Longrightarrow> C nm \\<bullet>\\<bullet> (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs))! \\<rightarrow>* (subst\\<^sub>M\\<^sub>L \\<sigma> v)!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(nm, vs, v) \\<in> compR;\n     \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                      map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                       (rev vs)! \\<rightarrow>*\n                      subst\\<^sub>M\\<^sub>L \\<sigma> v!", "apply(auto simp add:compR_def rev_map simp del: map_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b;\n        vs = map comp_pat (rev aa)\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          (map comp_pat aa)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open b)!", "apply(frule pure_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          (map comp_pat aa)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> (comp_open b)!", "apply(subst kernel_subst_ML)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> pure b\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          (map comp_pat aa)! \\<rightarrow>*\n                         subst (kernel \\<circ> \\<sigma>) b", "apply fast+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                          (map comp_pat aa)! \\<rightarrow>*\n                         subst (kernel \\<circ> \\<sigma>) b", "apply(subst kernel_subst_ML_pat_map)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> Ball (set aa) pure\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> patterns aa\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n 4. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst (kernel \\<circ> \\<sigma>))\n                          aa \\<rightarrow>*\n                         subst (kernel \\<circ> \\<sigma>) b", "apply fast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> patterns aa\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst (kernel \\<circ> \\<sigma>))\n                          aa \\<rightarrow>*\n                         subst (kernel \\<circ> \\<sigma>) b", "apply(fast dest:pattern_R)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst (kernel \\<circ> \\<sigma>))\n                          aa \\<rightarrow>*\n                         subst (kernel \\<circ> \\<sigma>) b", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst (kernel \\<circ> \\<sigma>))\n                          aa \\<rightarrow>*\n                         subst (kernel \\<circ> \\<sigma>) b", "apply(rule r_into_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        (nm, aa, b) \\<in> R; v = comp_open b; vs = map comp_pat (rev aa);\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> C nm \\<bullet>\\<bullet>\n                         map (subst (kernel \\<circ> \\<sigma>))\n                          aa \\<rightarrow>\n                         subst (kernel \\<circ> \\<sigma>) b", "apply(erule Red_tm.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \"Correctness\""], ["", "(* Without this special rule one \"also\" in the next proof *diverges*,\n   probably because of HOU. *)"], ["", "lemma eq_Red_tm_trans: \"s = t \\<Longrightarrow> t \\<rightarrow> t' \\<Longrightarrow> s \\<rightarrow> t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = t; t \\<rightarrow> t'\\<rbrakk>\n    \\<Longrightarrow> s \\<rightarrow> t'", "by simp"], ["", "text\\<open>Soundness of reduction:\\<close>"], ["", "theorem fixes v :: ml shows Red_ml_sound:\n  \"v \\<Rightarrow> v' \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow> v! \\<rightarrow>* v'! \\<and> closed\\<^sub>M\\<^sub>L 0 v'\" and\n  \"vs \\<Rightarrow> vs' \\<Longrightarrow> \\<forall>v\\<in>set vs. closed\\<^sub>M\\<^sub>L 0 v \\<Longrightarrow>\n   vs! \\<rightarrow>* vs'! \\<and> (\\<forall>v'\\<in>set vs'. closed\\<^sub>M\\<^sub>L 0 v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>v \\<Rightarrow> v'; closed\\<^sub>M\\<^sub>L 0 v\\<rbrakk>\n     \\<Longrightarrow> v! \\<rightarrow>* v'! \\<and>\n                       closed\\<^sub>M\\<^sub>L 0 v') &&&\n    (\\<lbrakk>vs \\<Rightarrow> vs';\n      \\<forall>v\\<in>set vs. closed\\<^sub>M\\<^sub>L 0 v\\<rbrakk>\n     \\<Longrightarrow> vs! \\<rightarrow>* vs'! \\<and>\n                       (\\<forall>v'\\<in>set vs'.\n                           closed\\<^sub>M\\<^sub>L 0 v'))", "proof(induct rule:Red_ml_Red_ml_list.inducts)"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "fix u v"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "let ?v = \"A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]\""], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "assume cl: \"closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v])\""], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v])\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "let ?u' = \"(lift_ml 0 u)[V\\<^sub>U 0 []/0]\""], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "have \"?v! = (\\<Lambda>((?u')!)) \\<bullet> (v !)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! =\n    \\<Lambda> (lift 0 u[V\\<^sub>U 0 []/0]!) \\<bullet> v!", "by simp"], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! =\n  \\<Lambda> (lift 0 u[V\\<^sub>U 0 []/0]!) \\<bullet> v!\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "also"], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! =\n  \\<Lambda> (lift 0 u[V\\<^sub>U 0 []/0]!) \\<bullet> v!\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "have \"\\<dots> \\<rightarrow> (?u' !)[v!/0]\" (is \"_ \\<rightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> (lift 0 u[V\\<^sub>U 0 []/0]!) \\<bullet> v! \\<rightarrow>\n    lift 0 u[V\\<^sub>U 0 []/0]![v!/0]", "by(rule Red_tm.intros)"], ["proof (state)\nthis:\n  \\<Lambda> (lift 0 u[V\\<^sub>U 0 []/0]!) \\<bullet> v! \\<rightarrow>\n  lift 0 u[V\\<^sub>U 0 []/0]![v!/0]\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "also(eq_Red_tm_trans)"], ["proof (state)\nthis:\n  \\<Lambda> (lift 0 u[V\\<^sub>U 0 []/0]!) \\<bullet> v! \\<rightarrow>\n  lift 0 u[V\\<^sub>U 0 []/0]![v!/0]\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "have \"?R = u[v/0]!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift 0 u[V\\<^sub>U 0 []/0]![v!/0] = u[v/0]!", "using cl"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v])\n\ngoal (1 subgoal):\n 1. lift 0 u[V\\<^sub>U 0 []/0]![v!/0] = u[v/0]!", "apply(cut_tac u = \"u\" and v = \"v\" in kernel_subst1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L 0 v\n 2. closed\\<^sub>M\\<^sub>L 0\n     (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n    closed\\<^sub>M\\<^sub>L (Suc 0) u\n 3. \\<lbrakk>closed\\<^sub>M\\<^sub>L 0\n              (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]);\n     u[v/0]! = lift 0 u[V\\<^sub>U 0 []/0]![v!/0]\\<rbrakk>\n    \\<Longrightarrow> lift 0 u[V\\<^sub>U 0 []/0]![v!/0] = u[v/0]!", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lift 0 u[V\\<^sub>U 0 []/0]![v!/0] = u[v/0]!\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "finally"], ["proof (chain)\npicking this:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow> u[v/0]!", "have \"kernel(A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<rightarrow>* kernel(u[v/0])\" (is ?A)"], ["proof (prove)\nusing this:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow> u[v/0]!\n\ngoal (1 subgoal):\n 1. A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>* u[v/0]!", "by(rule r_into_rtrancl)"], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>* u[v/0]!\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "moreover"], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>* u[v/0]!\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "have \"closed\\<^sub>M\\<^sub>L 0 (u[v/0])\" (is \"?C\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "let ?\\<sigma> = \"\\<lambda>n. if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "let ?\\<sigma>' = \"\\<lambda>n. v\""], ["proof (state)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "have clu: \"closed\\<^sub>M\\<^sub>L (Suc 0) u\" and clv: \"closed\\<^sub>M\\<^sub>L 0 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L (Suc 0) u &&& closed\\<^sub>M\\<^sub>L 0 v", "using cl"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v])\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L (Suc 0) u &&& closed\\<^sub>M\\<^sub>L 0 v", "by simp+"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L (Suc 0) u\n  closed\\<^sub>M\\<^sub>L 0 v\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "have \"closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L ?\\<sigma>' u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L (\\<lambda>n. v) u)", "by (metis closed_ML_subst_ML clv)"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L (\\<lambda>n. v) u)\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "hence \"closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L ?\\<sigma> u)\""], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L (\\<lambda>n. v) u)\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n. if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1)) u)", "using subst_ML_coincidence[OF clu, of ?\\<sigma> ?\\<sigma>']"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L (\\<lambda>n. v) u)\n  \\<forall>i<Suc 0.\n     (if i = 0 then v else V\\<^sub>M\\<^sub>L (i - 1)) = v \\<Longrightarrow>\n  subst\\<^sub>M\\<^sub>L\n   (\\<lambda>n. if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1)) u =\n  subst\\<^sub>M\\<^sub>L (\\<lambda>n. v) u\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (subst\\<^sub>M\\<^sub>L\n       (\\<lambda>n. if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1)) u)", "by auto"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0\n   (subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n. if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1)) u)\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "thus ?thesis"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0\n   (subst\\<^sub>M\\<^sub>L\n     (\\<lambda>n. if n = 0 then v else V\\<^sub>M\\<^sub>L (n - 1)) u)\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "by simp"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n\ngoal (17 subgoals):\n 1. \\<And>u v.\n       closed\\<^sub>M\\<^sub>L 0\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n       u[v/0]! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n         f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\nA total of 17 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>* u[v/0]!\n  closed\\<^sub>M\\<^sub>L 0 (u[v/0])", "show \"?A \\<and> ?C\""], ["proof (prove)\nusing this:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>* u[v/0]!\n  closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n\ngoal (1 subgoal):\n 1. A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n    u[v/0]! \\<and>\n    closed\\<^sub>M\\<^sub>L 0 (u[v/0])", ".."], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]! \\<rightarrow>*\n  u[v/0]! \\<and>\n  closed\\<^sub>M\\<^sub>L 0 (u[v/0])\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "fix \\<sigma> :: \"nat \\<Rightarrow> ml\" and nm vs v"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "assume \\<sigma>: \"\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\"  and compR: \"(nm, vs, v) \\<in> compR\""], ["proof (state)\nthis:\n  \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\n  (nm, vs, v) \\<in> compR\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "have \"map (subst V) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!) = map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (subst V) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!) =\n    map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!", "by(simp add:list_eq_iff_nth_eq subst_V_kernel closed_ML_subst_ML[OF \\<sigma>])"], ["proof (state)\nthis:\n  map (subst V) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!) =\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "with compR_Red_tm[OF compR \\<sigma>]"], ["proof (chain)\npicking this:\n  C nm \\<bullet>\\<bullet>\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n  map (subst V) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!) =\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!", "have \"(C nm) \\<bullet>\\<bullet> ((map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)) !) \\<rightarrow>* (subst\\<^sub>M\\<^sub>L \\<sigma> v)!\""], ["proof (prove)\nusing this:\n  C nm \\<bullet>\\<bullet>\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n  map (subst V) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!) =\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)!\n\ngoal (1 subgoal):\n 1. C nm \\<bullet>\\<bullet>\n    map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)! \\<rightarrow>*\n    subst\\<^sub>M\\<^sub>L \\<sigma> v!", "by(simp add:subst_V_kernel closed_ML_subst_ML[OF \\<sigma>])"], ["proof (state)\nthis:\n  C nm \\<bullet>\\<bullet>\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "hence \"A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>* subst\\<^sub>M\\<^sub>L \\<sigma> v!\" (is ?A)"], ["proof (prove)\nusing this:\n  C nm \\<bullet>\\<bullet>\n  map (subst\\<^sub>M\\<^sub>L \\<sigma>) (rev vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n\ngoal (1 subgoal):\n 1. A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n     (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n    subst\\<^sub>M\\<^sub>L \\<sigma> v!", "by(simp add:rev_map)"], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n   (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "moreover"], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n   (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "have \"closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)\" (is ?C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)", "by(metis closed_ML_subst_ML \\<sigma>)"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n\ngoal (16 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                            vs)! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 3. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 4. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 5. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 6. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 7. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 8. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 9. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 10. \\<And>vs vs' f n.\n        \\<lbrakk>vs \\<Rightarrow> vs';\n         Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n         vs! \\<rightarrow>* vs'! \\<and>\n         Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n         closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\nA total of 16 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n   (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)", "show \"?A \\<and> ?C\""], ["proof (prove)\nusing this:\n  A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n   (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v!\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n\ngoal (1 subgoal):\n 1. A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n     (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n    subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n    closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)", ".."], ["proof (state)\nthis:\n  A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n   (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)! \\<rightarrow>*\n  subst\\<^sub>M\\<^sub>L \\<sigma> v! \\<and>\n  closed\\<^sub>M\\<^sub>L 0 (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n\ngoal (15 subgoals):\n 1. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        closed\\<^sub>M\\<^sub>L 0\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                          vs'! \\<rightarrow>*\n                         subst\\<^sub>M\\<^sub>L \\<sigma>\n                          (C\\<^sub>U nm vs)! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 2. \\<And>f vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       apply (Clo f vs (Suc 0)) v! \\<rightarrow>*\n       A\\<^sub>M\\<^sub>L f (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (A\\<^sub>M\\<^sub>L f (v # vs))\n 3. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        closed\\<^sub>M\\<^sub>L 0 (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> apply (Clo f vs (Suc n)) v! \\<rightarrow>*\n                         Clo f (v # vs) n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f (v # vs) n)\n 4. \\<And>nm vs v.\n       closed\\<^sub>M\\<^sub>L 0\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       apply (C\\<^sub>U nm vs) v! \\<rightarrow>*\n       C\\<^sub>U nm (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm (v # vs))\n 5. \\<And>x vs v.\n       closed\\<^sub>M\\<^sub>L 0 (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       apply (V\\<^sub>U x vs) v! \\<rightarrow>* V\\<^sub>U x (v # vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x (v # vs))\n 6. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C\\<^sub>U nm vs! \\<rightarrow>*\n                         C\\<^sub>U nm vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (C\\<^sub>U nm vs')\n 7. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> V\\<^sub>U x vs! \\<rightarrow>*\n                         V\\<^sub>U x vs'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (V\\<^sub>U x vs')\n 8. \\<And>f f' vs n.\n       \\<lbrakk>f \\<Rightarrow> f';\n        closed\\<^sub>M\\<^sub>L 0 f \\<Longrightarrow>\n        f! \\<rightarrow>* f'! \\<and> closed\\<^sub>M\\<^sub>L 0 f';\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f' vs n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f' vs n)\n 9. \\<And>vs vs' f n.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) (closed\\<^sub>M\\<^sub>L 0) \\<Longrightarrow>\n        vs! \\<rightarrow>* vs'! \\<and>\n        Ball (set vs') (closed\\<^sub>M\\<^sub>L 0);\n        closed\\<^sub>M\\<^sub>L 0 (Clo f vs n)\\<rbrakk>\n       \\<Longrightarrow> Clo f vs n! \\<rightarrow>* Clo f vs' n! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (Clo f vs' n)\n 10. \\<And>s s' t.\n        \\<lbrakk>s \\<Rightarrow> s';\n         closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n         s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n         closed\\<^sub>M\\<^sub>L 0 (apply s t)\\<rbrakk>\n        \\<Longrightarrow> apply s t! \\<rightarrow>* apply s' t! \\<and>\n                          closed\\<^sub>M\\<^sub>L 0 (apply s' t)\nA total of 15 subgoals...", "qed (auto simp:Reds_tm_list_foldl_At Red_tm_rev rev_map[symmetric])"], ["", "theorem Red_term_sound:\n  \"t \\<Rightarrow> t' \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow> kernelt t \\<rightarrow>* kernelt t'  \\<and> closed\\<^sub>M\\<^sub>L 0 t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<Rightarrow> t'; closed\\<^sub>M\\<^sub>L 0 t\\<rbrakk>\n    \\<Longrightarrow> t! \\<rightarrow>* t'! \\<and>\n                      closed\\<^sub>M\\<^sub>L 0 t'", "proof(induct rule:Red_term.inducts)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>nm vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (C\\<^sub>U nm vs)) \\<Longrightarrow>\n       term (C\\<^sub>U nm vs)! \\<rightarrow>*\n       C nm \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C nm \\<bullet>\\<bullet> map term (rev vs))\n 2. \\<And>x vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x vs)) \\<Longrightarrow>\n       term (V\\<^sub>U x vs)! \\<rightarrow>*\n       V x \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V x \\<bullet>\\<bullet> map term (rev vs))\n 3. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 4. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 5. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 6. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 7. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "case term_C"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (term (C\\<^sub>U nm_ vs_))\n\ngoal (7 subgoals):\n 1. \\<And>nm vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (C\\<^sub>U nm vs)) \\<Longrightarrow>\n       term (C\\<^sub>U nm vs)! \\<rightarrow>*\n       C nm \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (C nm \\<bullet>\\<bullet> map term (rev vs))\n 2. \\<And>x vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x vs)) \\<Longrightarrow>\n       term (V\\<^sub>U x vs)! \\<rightarrow>*\n       V x \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V x \\<bullet>\\<bullet> map term (rev vs))\n 3. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 4. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 5. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 6. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 7. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "thus ?case"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (term (C\\<^sub>U nm_ vs_))\n\ngoal (1 subgoal):\n 1. term (C\\<^sub>U nm_ vs_)! \\<rightarrow>*\n    C nm_ \\<bullet>\\<bullet> map term (rev vs_)! \\<and>\n    closed\\<^sub>M\\<^sub>L 0 (C nm_ \\<bullet>\\<bullet> map term (rev vs_))", "by (auto simp:closed_tm_ML_foldl_At)"], ["proof (state)\nthis:\n  term (C\\<^sub>U nm_ vs_)! \\<rightarrow>*\n  C nm_ \\<bullet>\\<bullet> map term (rev vs_)! \\<and>\n  closed\\<^sub>M\\<^sub>L 0 (C nm_ \\<bullet>\\<bullet> map term (rev vs_))\n\ngoal (6 subgoals):\n 1. \\<And>x vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x vs)) \\<Longrightarrow>\n       term (V\\<^sub>U x vs)! \\<rightarrow>*\n       V x \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V x \\<bullet>\\<bullet> map term (rev vs))\n 2. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 3. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 4. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 5. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 6. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x vs)) \\<Longrightarrow>\n       term (V\\<^sub>U x vs)! \\<rightarrow>*\n       V x \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V x \\<bullet>\\<bullet> map term (rev vs))\n 2. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 3. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 4. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 5. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 6. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "case term_V"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x_ vs_))\n\ngoal (6 subgoals):\n 1. \\<And>x vs.\n       closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x vs)) \\<Longrightarrow>\n       term (V\\<^sub>U x vs)! \\<rightarrow>*\n       V x \\<bullet>\\<bullet> map term (rev vs)! \\<and>\n       closed\\<^sub>M\\<^sub>L 0 (V x \\<bullet>\\<bullet> map term (rev vs))\n 2. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 3. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 4. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 5. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 6. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "thus ?case"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (term (V\\<^sub>U x_ vs_))\n\ngoal (1 subgoal):\n 1. term (V\\<^sub>U x_ vs_)! \\<rightarrow>*\n    V x_ \\<bullet>\\<bullet> map term (rev vs_)! \\<and>\n    closed\\<^sub>M\\<^sub>L 0 (V x_ \\<bullet>\\<bullet> map term (rev vs_))", "by (auto simp:closed_tm_ML_foldl_At)"], ["proof (state)\nthis:\n  term (V\\<^sub>U x_ vs_)! \\<rightarrow>*\n  V x_ \\<bullet>\\<bullet> map term (rev vs_)! \\<and>\n  closed\\<^sub>M\\<^sub>L 0 (V x_ \\<bullet>\\<bullet> map term (rev vs_))\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "case (term_Clo vf vs n)"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n))\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "hence \"(lift 0 vf!) \\<bullet>\\<bullet> map kernel (rev (map (lift 0) vs))\n         = lift 0 (vf! \\<bullet>\\<bullet> (rev vs)!)\""], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n))\n\ngoal (1 subgoal):\n 1. lift 0 vf! \\<bullet>\\<bullet> rev (map (lift 0) vs)! =\n    lift 0 (vf! \\<bullet>\\<bullet> rev vs!)", "apply (simp add:kernel_lift_tm list_eq_iff_nth_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 vf \\<and>\n    (\\<forall>x\\<in>set vs. closed\\<^sub>M\\<^sub>L 0 x) \\<Longrightarrow>\n    \\<forall>i<length vs. rev (map (lift 0) vs) ! i! = lift 0 (rev vs ! i!)", "apply(simp add:rev_nth rev_map kernel_lift_tm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lift 0 vf! \\<bullet>\\<bullet> rev (map (lift 0) vs)! =\n  lift 0 (vf! \\<bullet>\\<bullet> rev vs!)\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "hence \"term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!\""], ["proof (prove)\nusing this:\n  lift 0 vf! \\<bullet>\\<bullet> rev (map (lift 0) vs)! =\n  lift 0 (vf! \\<bullet>\\<bullet> rev vs!)\n\ngoal (1 subgoal):\n 1. term (Clo vf vs n)! \\<rightarrow>*\n    \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!", "using term_Clo"], ["proof (prove)\nusing this:\n  lift 0 vf! \\<bullet>\\<bullet> rev (map (lift 0) vs)! =\n  lift 0 (vf! \\<bullet>\\<bullet> rev vs!)\n  closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n))\n\ngoal (1 subgoal):\n 1. term (Clo vf vs n)! \\<rightarrow>*\n    \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!", "by(simp del:lift_foldl_At add: r_into_rtrancl Red_tm.intros(2))"], ["proof (state)\nthis:\n  term (Clo vf vs n)! \\<rightarrow>*\n  \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "moreover"], ["proof (state)\nthis:\n  term (Clo vf vs n)! \\<rightarrow>*\n  \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "have \"closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))", "using term_Clo"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n))\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0\n     (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))", "by simp"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0\n   (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n.\n       closed\\<^sub>M\\<^sub>L 0 (term (Clo vf vs n)) \\<Longrightarrow>\n       term (Clo vf vs n)! \\<rightarrow>*\n       \\<Lambda>\n        (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n       closed\\<^sub>M\\<^sub>L 0\n        (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n 2. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 3. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 4. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 5. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "ultimately"], ["proof (chain)\npicking this:\n  term (Clo vf vs n)! \\<rightarrow>*\n  \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!\n  closed\\<^sub>M\\<^sub>L 0\n   (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))", "show ?case"], ["proof (prove)\nusing this:\n  term (Clo vf vs n)! \\<rightarrow>*\n  \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))!\n  closed\\<^sub>M\\<^sub>L 0\n   (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n\ngoal (1 subgoal):\n 1. term (Clo vf vs n)! \\<rightarrow>*\n    \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n    closed\\<^sub>M\\<^sub>L 0\n     (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))", ".."], ["proof (state)\nthis:\n  term (Clo vf vs n)! \\<rightarrow>*\n  \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))! \\<and>\n  closed\\<^sub>M\\<^sub>L 0\n   (\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))))\n\ngoal (4 subgoals):\n 1. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 2. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 3. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 4. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 2. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 3. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 4. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "case ctxt_term"], ["proof (state)\nthis:\n  v_ \\<Rightarrow> v'_\n  closed\\<^sub>M\\<^sub>L 0 (term v_)\n\ngoal (4 subgoals):\n 1. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 2. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 3. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')\n 4. \\<And>v v'.\n       \\<lbrakk>v \\<Rightarrow> v';\n        closed\\<^sub>M\\<^sub>L 0 (term v)\\<rbrakk>\n       \\<Longrightarrow> term v! \\<rightarrow>* term v'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (term v')", "thus ?case"], ["proof (prove)\nusing this:\n  v_ \\<Rightarrow> v'_\n  closed\\<^sub>M\\<^sub>L 0 (term v_)\n\ngoal (1 subgoal):\n 1. term v_! \\<rightarrow>* term v'_! \\<and>\n    closed\\<^sub>M\\<^sub>L 0 (term v'_)", "by simp (metis Red_ml_sound)"], ["proof (state)\nthis:\n  term v_! \\<rightarrow>* term v'_! \\<and>\n  closed\\<^sub>M\\<^sub>L 0 (term v'_)\n\ngoal (3 subgoals):\n 1. \\<And>t t'.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t)\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> t! \\<rightarrow>* \\<Lambda> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (\\<Lambda> t')\n 2. \\<And>s s' t.\n       \\<lbrakk>s \\<Rightarrow> s';\n        closed\\<^sub>M\\<^sub>L 0 s \\<Longrightarrow>\n        s! \\<rightarrow>* s'! \\<and> closed\\<^sub>M\\<^sub>L 0 s';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s' \\<bullet> t! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s' \\<bullet> t)\n 3. \\<And>t t' s.\n       \\<lbrakk>t \\<Rightarrow> t';\n        closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow>\n        t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t';\n        closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t)\\<rbrakk>\n       \\<Longrightarrow> s \\<bullet> t! \\<rightarrow>*\n                         s \\<bullet> t'! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 (s \\<bullet> t')", "qed auto"], ["", "corollary kernel_inv:\n \"(t :: tm) \\<Rightarrow>* t' \\<Longrightarrow> closed\\<^sub>M\\<^sub>L 0 t \\<Longrightarrow> t! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t' \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<Rightarrow>* t'; closed\\<^sub>M\\<^sub>L 0 t\\<rbrakk>\n    \\<Longrightarrow> t! \\<rightarrow>* t'! \\<and>\n                      closed\\<^sub>M\\<^sub>L 0 t'", "apply(induct rule: rtrancl.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       closed\\<^sub>M\\<^sub>L 0 a \\<Longrightarrow>\n       a! \\<rightarrow>* a! \\<and> closed\\<^sub>M\\<^sub>L 0 a\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<Rightarrow>* b;\n        closed\\<^sub>M\\<^sub>L 0 a \\<Longrightarrow>\n        a! \\<rightarrow>* b! \\<and> closed\\<^sub>M\\<^sub>L 0 b;\n        b \\<Rightarrow> c; closed\\<^sub>M\\<^sub>L 0 a\\<rbrakk>\n       \\<Longrightarrow> a! \\<rightarrow>* c! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 c", "apply (metis rtrancl_eq_or_trancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<Rightarrow>* b;\n        closed\\<^sub>M\\<^sub>L 0 a \\<Longrightarrow>\n        a! \\<rightarrow>* b! \\<and> closed\\<^sub>M\\<^sub>L 0 b;\n        b \\<Rightarrow> c; closed\\<^sub>M\\<^sub>L 0 a\\<rbrakk>\n       \\<Longrightarrow> a! \\<rightarrow>* c! \\<and>\n                         closed\\<^sub>M\\<^sub>L 0 c", "apply (metis Red_term_sound rtrancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  closed_ML_compile:\n  \"pure t \\<Longrightarrow> \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t;\n     \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>)", "proof(induct arbitrary:n \\<sigma> pred:pure)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>nm n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (C nm) \\<sigma>)\n 2. \\<And>x n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (V x) \\<sigma>)\n 3. \\<And>t n \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (\\<Lambda> t) \\<sigma>)\n 4. \\<And>s t n \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile s \\<sigma>);\n        pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (s \\<bullet> t) \\<sigma>)", "case (Lam t)"], ["proof (state)\nthis:\n  pure t\n  \\<forall>i. closed\\<^sub>M\\<^sub>L ?n (?\\<sigma> i) \\<Longrightarrow>\n  closed\\<^sub>M\\<^sub>L ?n (compile t ?\\<sigma>)\n  \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\n\ngoal (4 subgoals):\n 1. \\<And>nm n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (C nm) \\<sigma>)\n 2. \\<And>x n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (V x) \\<sigma>)\n 3. \\<And>t n \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (\\<Lambda> t) \\<sigma>)\n 4. \\<And>s t n \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile s \\<sigma>);\n        pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (s \\<bullet> t) \\<sigma>)", "have 1: \"\\<forall>i. closed\\<^sub>M\\<^sub>L (Suc n) ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       closed\\<^sub>M\\<^sub>L (Suc n) ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i)", "using Lam(3-)"], ["proof (prove)\nusing this:\n  \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       closed\\<^sub>M\\<^sub>L (Suc n) ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i)", "by (auto simp: closed_ML_Suc)"], ["proof (state)\nthis:\n  \\<forall>i.\n     closed\\<^sub>M\\<^sub>L (Suc n) ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) i)\n\ngoal (4 subgoals):\n 1. \\<And>nm n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (C nm) \\<sigma>)\n 2. \\<And>x n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (V x) \\<sigma>)\n 3. \\<And>t n \\<sigma>.\n       \\<lbrakk>pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (\\<Lambda> t) \\<sigma>)\n 4. \\<And>s t n \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile s \\<sigma>);\n        pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (s \\<bullet> t) \\<sigma>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L n (compile (\\<Lambda> t) \\<sigma>)", "using Lam(2)[OF 1]"], ["proof (prove)\nusing this:\n  closed\\<^sub>M\\<^sub>L (Suc n)\n   (compile t (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>))\n\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L n (compile (\\<Lambda> t) \\<sigma>)", "by (simp del:apply_cons_ML)"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L n (compile (\\<Lambda> t) \\<sigma>)\n\ngoal (3 subgoals):\n 1. \\<And>nm n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (C nm) \\<sigma>)\n 2. \\<And>x n \\<sigma>.\n       \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n       closed\\<^sub>M\\<^sub>L n (compile (V x) \\<sigma>)\n 3. \\<And>s t n \\<sigma>.\n       \\<lbrakk>pure s;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile s \\<sigma>);\n        pure t;\n        \\<And>n \\<sigma>.\n           \\<forall>i.\n              closed\\<^sub>M\\<^sub>L n (\\<sigma> i) \\<Longrightarrow>\n           closed\\<^sub>M\\<^sub>L n (compile t \\<sigma>);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L n (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> closed\\<^sub>M\\<^sub>L n\n                          (compile (s \\<bullet> t) \\<sigma>)", "qed simp_all"], ["", "theorem nbe_correct: fixes t :: tm\nassumes \"pure t\" and \"term (comp_fixed t) \\<Rightarrow>* t'\" and \"pure t'\" shows \"t \\<rightarrow>* t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "have ML_cl: \"closed\\<^sub>M\\<^sub>L 0 (term (comp_fixed t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed\\<^sub>M\\<^sub>L 0 (term (comp_fixed t))", "by (simp add: closed_ML_compile[OF \\<open>pure t\\<close>])"], ["proof (state)\nthis:\n  closed\\<^sub>M\\<^sub>L 0 (term (comp_fixed t))\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "have \"(term (comp_fixed t))! = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term (comp_fixed t)! = t", "using kernel_compile[OF \\<open>pure t\\<close>]"], ["proof (prove)\nusing this:\n  \\<forall>i. ?\\<sigma> i = V\\<^sub>U i [] \\<Longrightarrow>\n  compile t ?\\<sigma>! = t\n\ngoal (1 subgoal):\n 1. term (comp_fixed t)! = t", "by simp"], ["proof (state)\nthis:\n  term (comp_fixed t)! = t\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "moreover"], ["proof (state)\nthis:\n  term (comp_fixed t)! = t\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "have \"term (comp_fixed t)! \\<rightarrow>* t'!\""], ["proof (prove)\ngoal (1 subgoal):\n 1. term (comp_fixed t)! \\<rightarrow>* t'!", "using kernel_inv[OF assms(2) ML_cl]"], ["proof (prove)\nusing this:\n  term (comp_fixed t)! \\<rightarrow>* t'! \\<and> closed\\<^sub>M\\<^sub>L 0 t'\n\ngoal (1 subgoal):\n 1. term (comp_fixed t)! \\<rightarrow>* t'!", "by auto"], ["proof (state)\nthis:\n  term (comp_fixed t)! \\<rightarrow>* t'!\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "ultimately"], ["proof (chain)\npicking this:\n  term (comp_fixed t)! = t\n  term (comp_fixed t)! \\<rightarrow>* t'!", "have \"t \\<rightarrow>* t'!\""], ["proof (prove)\nusing this:\n  term (comp_fixed t)! = t\n  term (comp_fixed t)! \\<rightarrow>* t'!\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'!", "by simp"], ["proof (state)\nthis:\n  t \\<rightarrow>* t'!\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<rightarrow>* t'!\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "using kernel_pure[OF \\<open>pure t'\\<close>]"], ["proof (prove)\nusing this:\n  t \\<rightarrow>* t'!\n  t'! = t'\n\ngoal (1 subgoal):\n 1. t \\<rightarrow>* t'", "by simp"], ["proof (state)\nthis:\n  t \\<rightarrow>* t'\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Normal Forms\""], ["", "inductive normal :: \"tm \\<Rightarrow> bool\" where\n\"\\<forall>t\\<in>set ts. normal t \\<Longrightarrow> normal(V x \\<bullet>\\<bullet> ts)\" |\n\"normal t \\<Longrightarrow> normal(\\<Lambda> t)\" |\n\"\\<forall>t\\<in>set ts. normal t \\<Longrightarrow>\n \\<forall>\\<sigma>. \\<forall>(nm',ls,r)\\<in>R. \\<not>(nm = nm' \\<and> take (size ls) ts = map (subst \\<sigma>) ls)\n \\<Longrightarrow> normal(C nm \\<bullet>\\<bullet> ts)\""], ["", "fun C_normal_ML :: \"ml \\<Rightarrow> bool\" (\"C'_normal\\<^sub>M\\<^sub>L\") where\n\"C_normal\\<^sub>M\\<^sub>L(C\\<^sub>U nm vs) =\n  ((\\<forall>v\\<in>set vs. C_normal\\<^sub>M\\<^sub>L v) \\<and> no_match_compR nm vs)\" |\n\"C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L _) = True\" |\n\"C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L _) = True\" |\n\"C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs) = (C_normal\\<^sub>M\\<^sub>L v \\<and> (\\<forall>v \\<in> set vs. C_normal\\<^sub>M\\<^sub>L v))\" |\n\"C_normal\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v) = C_normal\\<^sub>M\\<^sub>L v\" |\n\"C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs) = (\\<forall>v \\<in> set vs. C_normal\\<^sub>M\\<^sub>L v)\" |\n\"C_normal\\<^sub>M\\<^sub>L (Clo v vs _) = (C_normal\\<^sub>M\\<^sub>L v \\<and> (\\<forall>v \\<in> set vs. C_normal\\<^sub>M\\<^sub>L v))\" |\n\"C_normal\\<^sub>M\\<^sub>L (apply u v) = (C_normal\\<^sub>M\\<^sub>L u \\<and> C_normal\\<^sub>M\\<^sub>L v)\""], ["", "fun size_tm :: \"tm \\<Rightarrow> nat\" where\n\"size_tm (C _) = 1\" |\n\"size_tm (At s t) = size_tm s + size_tm t + 1\" |\n\"size_tm _ = 0\""], ["", "lemma size_tm_foldl_At: \"size_tm(t \\<bullet>\\<bullet> ts) = size_tm t + size_list size_tm ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NBE.size_tm (t \\<bullet>\\<bullet> ts) =\n    NBE.size_tm t + size_list NBE.size_tm ts", "by (induct ts arbitrary:t) auto"], ["", "lemma termination_no_match:\n  \"i < length ss \\<Longrightarrow> ss ! i = C nm \\<bullet>\\<bullet> ts\n   \\<Longrightarrow> sum_list (map size_tm ts) < sum_list (map size_tm ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ss; ss ! i = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n    \\<Longrightarrow> sum_list (map NBE.size_tm ts)\n                      < sum_list (map NBE.size_tm ss)", "apply(subgoal_tac \"C nm \\<bullet>\\<bullet> ts : set ss\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length ss; ss ! i = C nm \\<bullet>\\<bullet> ts;\n     C nm \\<bullet>\\<bullet> ts \\<in> set ss\\<rbrakk>\n    \\<Longrightarrow> sum_list (map NBE.size_tm ts)\n                      < sum_list (map NBE.size_tm ss)\n 2. \\<lbrakk>i < length ss; ss ! i = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n    \\<Longrightarrow> C nm \\<bullet>\\<bullet> ts \\<in> set ss", "apply(drule sum_list_map_remove1[of _ _ size_tm])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length ss; ss ! i = C nm \\<bullet>\\<bullet> ts;\n     sum_list (map NBE.size_tm ss) =\n     NBE.size_tm (C nm \\<bullet>\\<bullet> ts) +\n     sum_list\n      (map NBE.size_tm (remove1 (C nm \\<bullet>\\<bullet> ts) ss))\\<rbrakk>\n    \\<Longrightarrow> sum_list (map NBE.size_tm ts)\n                      < sum_list (map NBE.size_tm ss)\n 2. \\<lbrakk>i < length ss; ss ! i = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n    \\<Longrightarrow> C nm \\<bullet>\\<bullet> ts \\<in> set ss", "apply(simp add:size_tm_foldl_At size_list_conv_sum_list)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ss; ss ! i = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n    \\<Longrightarrow> C nm \\<bullet>\\<bullet> ts \\<in> set ss", "apply (metis in_set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare conj_cong [fundef_cong]"], ["", "function no_match :: \"tm list \\<Rightarrow> tm list \\<Rightarrow> bool\" where\n\"no_match ps ts =\n  (\\<exists>i < min (size ts) (size ps).\n   \\<exists>nm nm' rs rs'. ps!i = (C nm) \\<bullet>\\<bullet> rs \\<and> ts!i = (C nm') \\<bullet>\\<bullet> rs' \\<and>\n      (nm=nm' \\<longrightarrow> no_match rs rs'))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>ps ts. x = (ps, ts) \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>ps ts psa tsa.\n       (ps, ts) = (psa, tsa) \\<Longrightarrow>\n       (\\<exists>i<min (length ts) (length ps).\n           \\<exists>nm nm' rs rs'.\n              ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n              ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match_sumC (rs, rs'))) =\n       (\\<exists>i<min (length tsa) (length psa).\n           \\<exists>nm nm' rs rs'.\n              psa ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n              tsa ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match_sumC (rs, rs')))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All no_match_dom", "apply(relation \"measure(%(ts::tm list,_). \\<Sum>t\\<leftarrow>ts. size_tm t)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>(ts, uu_). sum_list (map NBE.size_tm ts)))\n 2. \\<And>ps ts x xa xb xc xd.\n       \\<lbrakk>x < min (length ts) (length ps);\n        ps ! x = C xa \\<bullet>\\<bullet> xc;\n        ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb\\<rbrakk>\n       \\<Longrightarrow> ((xc, xd), ps, ts)\n                         \\<in> measure\n                                (\\<lambda>(ts, uu_).\n                                    sum_list (map NBE.size_tm ts))", "apply (auto simp:termination_no_match)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare no_match.simps[simp del]"], ["", "abbreviation\n\"no_match_R nm ts \\<equiv> \\<forall>(nm',ps,t)\\<in> R. nm=nm' \\<longrightarrow> no_match ps ts\""], ["", "lemma no_match: \"no_match ps ts \\<Longrightarrow> \\<not>(\\<exists>\\<sigma>. map (subst \\<sigma>) ps = ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match ps ts \\<Longrightarrow>\n    \\<nexists>\\<sigma>. map (subst \\<sigma>) ps = ts", "proof(induct ps ts rule:no_match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps ts.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    no_match xc xd\\<rbrakk>\n                   \\<Longrightarrow> \\<nexists>\\<sigma>.\n  map (subst \\<sigma>) xc = xd;\n        no_match ps ts\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>\\<sigma>. map (subst \\<sigma>) ps = ts", "case (1 ps ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x < min (length ts) (length ps);\n   ps ! ?x = C ?xa \\<bullet>\\<bullet> ?xc;\n   ts ! ?x = C ?xb \\<bullet>\\<bullet> ?xd; ?xa = ?xb;\n   no_match ?xc ?xd\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>\\<sigma>. map (subst \\<sigma>) ?xc = ?xd\n  no_match ps ts\n\ngoal (1 subgoal):\n 1. \\<And>ps ts.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    no_match xc xd\\<rbrakk>\n                   \\<Longrightarrow> \\<nexists>\\<sigma>.\n  map (subst \\<sigma>) xc = xd;\n        no_match ps ts\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>\\<sigma>. map (subst \\<sigma>) ps = ts", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < min (length ts) (length ps);\n   ps ! ?x = C ?xa \\<bullet>\\<bullet> ?xc;\n   ts ! ?x = C ?xb \\<bullet>\\<bullet> ?xd; ?xa = ?xb;\n   no_match ?xc ?xd\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>\\<sigma>. map (subst \\<sigma>) ?xc = ?xd\n  no_match ps ts\n\ngoal (1 subgoal):\n 1. \\<nexists>\\<sigma>. map (subst \\<sigma>) ps = ts", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x xa xc xb xd.\n                   \\<lbrakk>x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    map (subst \\<sigma>) xc = xd; xa = xb;\n                    no_match xc xd\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<sigma>.\n  map (subst \\<sigma>) xc \\<noteq> xd;\n        no_match ps (map (subst \\<sigma>) ps);\n        ts = map (subst \\<sigma>) ps\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subst (asm) no_match.simps[of ps])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>x xa xc xb xd.\n                   \\<lbrakk>x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    map (subst \\<sigma>) xc = xd; xa = xb;\n                    no_match xc xd\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>\\<sigma>.\n  map (subst \\<sigma>) xc \\<noteq> xd;\n        \\<exists>i<min (length (map (subst \\<sigma>) ps)) (length ps).\n           \\<exists>nm nm' rs rs'.\n              ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n              map (subst \\<sigma>) ps ! i =\n              C nm' \\<bullet>\\<bullet> rs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match rs rs');\n        ts = map (subst \\<sigma>) ps\\<rbrakk>\n       \\<Longrightarrow> False", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<nexists>\\<sigma>. map (subst \\<sigma>) ps = ts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_match_take: \"no_match ps ts \\<Longrightarrow> no_match ps (take (size ps) ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match ps ts \\<Longrightarrow> no_match ps (take (length ps) ts)", "apply(subst (asm) no_match.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<min (length ts) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n          ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs') \\<Longrightarrow>\n    no_match ps (take (length ps) ts)", "apply(subst no_match.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<min (length ts) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n          ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs') \\<Longrightarrow>\n    \\<exists>i<min (length (take (length ps) ts)) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n          take (length ps) ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "fun dterm_ML :: \"ml \\<Rightarrow> tm\" (\"dterm\\<^sub>M\\<^sub>L\") where\n\"dterm\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs) = C nm \\<bullet>\\<bullet> map dterm\\<^sub>M\\<^sub>L (rev vs)\" |\n\"dterm\\<^sub>M\\<^sub>L _ = V 0\""], ["", "fun dterm :: \"tm \\<Rightarrow> tm\" where\n\"dterm (V n) = V n\" |\n\"dterm (C nm) = C nm\" |\n\"dterm (s \\<bullet> t) = dterm s \\<bullet> dterm t\" |\n\"dterm (\\<Lambda> t) = \\<Lambda> (dterm t)\" |\n\"dterm (term v) = dterm\\<^sub>M\\<^sub>L v\""], ["", "lemma dterm_pure[simp]: \"pure t \\<Longrightarrow> dterm t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> dterm t = t", "by (induct pred:pure) auto"], ["", "lemma map_dterm_pure[simp]: \"\\<forall>t\\<in>set ts. pure t \\<Longrightarrow> map dterm ts = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts. pure t \\<Longrightarrow> map dterm ts = ts", "by (induct ts) auto"], ["", "lemma map_dterm_term[simp]: \"map dterm (map term vs) = map dterm\\<^sub>M\\<^sub>L vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map dterm (map term vs) = map dterm\\<^sub>M\\<^sub>L vs", "by (induct vs) auto"], ["", "lemma dterm_foldl_At[simp]: \"dterm(t \\<bullet>\\<bullet> ts) = dterm t \\<bullet>\\<bullet> map dterm ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dterm (t \\<bullet>\\<bullet> ts) =\n    dterm t \\<bullet>\\<bullet> map dterm ts", "by(induct ts arbitrary: t) auto"], ["", "lemma no_match_coincide:\n  \"no_match\\<^sub>M\\<^sub>L ps vs \\<Longrightarrow>\n  no_match (map dterm\\<^sub>M\\<^sub>L (rev ps)) (map dterm\\<^sub>M\\<^sub>L (rev vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match\\<^sub>M\\<^sub>L ps vs \\<Longrightarrow>\n    no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n     (map dterm\\<^sub>M\\<^sub>L (rev vs))", "apply(induct ps vs rule:no_match_ML.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        no_match\\<^sub>M\\<^sub>L ps os\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>no_match\\<^sub>M\\<^sub>L ps os;\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x < min (length os) (length ps);\n            rev ps ! x = C\\<^sub>U xa xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb; no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n           \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev xc))\n                              (map dterm\\<^sub>M\\<^sub>L (rev xd))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(subst (asm) no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<exists>i<min (length os) (length ps).\n                   \\<exists>nm nm' vs vs'.\n                      rev ps ! i = C\\<^sub>U nm vs \\<and>\n                      rev os ! i = C\\<^sub>U nm' vs' \\<and>\n                      (nm = nm' \\<longrightarrow>\n                       no_match\\<^sub>M\\<^sub>L vs vs');\n        \\<And>x xa xb xc xd.\n           \\<lbrakk>x < min (length os) (length ps);\n            rev ps ! x = C\\<^sub>U xa xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb; no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n           \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev xc))\n                              (map dterm\\<^sub>M\\<^sub>L (rev xd))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(case_tac \"nm=nm'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(subst no_match.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map dterm\\<^sub>M\\<^sub>L (rev os)))\n                                     (length\n (map dterm\\<^sub>M\\<^sub>L (rev ps))).\n                            \\<exists>nm nm' rs rs'.\n                               map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                               C nm \\<bullet>\\<bullet> rs \\<and>\n                               map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                               C nm' \\<bullet>\\<bullet> rs' \\<and>\n                               (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> i < min (length\n                                   (map dterm\\<^sub>M\\<^sub>L (rev os)))\n                              (length\n                                (map dterm\\<^sub>M\\<^sub>L (rev ps))) \\<and>\n                         (\\<exists>nm nm' rs rs'.\n                             map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                             C nm \\<bullet>\\<bullet> rs \\<and>\n                             map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                             C nm' \\<bullet>\\<bullet> rs' \\<and>\n                             (nm = nm' \\<longrightarrow> no_match rs rs'))\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply rule"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> i < min (length\n                                   (map dterm\\<^sub>M\\<^sub>L (rev os)))\n                              (length (map dterm\\<^sub>M\\<^sub>L (rev ps)))\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply (simp (no_asm))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> i < length os \\<and> i < length ps\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply (metis min_less_iff_conj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm \\<noteq> nm'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(simp add:min_less_iff_conj nth_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        nm = nm'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map dterm\\<^sub>M\\<^sub>L (rev xc)) (map dterm\\<^sub>M\\<^sub>L (rev xd));\n        i < min (length os) (length ps); rev ps ! i = C\\<^sub>U nm' vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(erule_tac x=i in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xa xb xc xd.\n           \\<lbrakk>i < min (length os) (length ps);\n            rev ps ! i = C\\<^sub>U xa xc; rev os ! i = C\\<^sub>U xb xd;\n            xa = xb; no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n           \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev xc))\n                              (map dterm\\<^sub>M\\<^sub>L (rev xd))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(erule_tac x=nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xb xc xd.\n           \\<lbrakk>i < min (length os) (length ps);\n            rev ps ! i = C\\<^sub>U nm' xc; rev os ! i = C\\<^sub>U xb xd;\n            nm' = xb; no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n           \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev xc))\n                              (map dterm\\<^sub>M\\<^sub>L (rev xd))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(erule_tac x=nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xc xd.\n           \\<lbrakk>i < min (length os) (length ps);\n            rev ps ! i = C\\<^sub>U nm' xc; rev os ! i = C\\<^sub>U nm' xd;\n            nm' = nm'; no_match\\<^sub>M\\<^sub>L xc xd\\<rbrakk>\n           \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev xc))\n                              (map dterm\\<^sub>M\\<^sub>L (rev xd))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(erule_tac x=\"vs\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xd.\n           \\<lbrakk>i < min (length os) (length ps);\n            rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' xd;\n            nm' = nm'; no_match\\<^sub>M\\<^sub>L vs xd\\<rbrakk>\n           \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                              (map dterm\\<^sub>M\\<^sub>L (rev xd))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(erule_tac x=\"vs'\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev ps))\n                          (map dterm\\<^sub>M\\<^sub>L (rev os))", "apply(subst no_match.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map dterm\\<^sub>M\\<^sub>L (rev os)))\n                                     (length\n (map dterm\\<^sub>M\\<^sub>L (rev ps))).\n                            \\<exists>nm nm' rs rs'.\n                               map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                               C nm \\<bullet>\\<bullet> rs \\<and>\n                               map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                               C nm' \\<bullet>\\<bullet> rs' \\<and>\n                               (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> i < min (length\n                                   (map dterm\\<^sub>M\\<^sub>L (rev os)))\n                              (length\n                                (map dterm\\<^sub>M\\<^sub>L (rev ps))) \\<and>\n                         (\\<exists>nm nm' rs rs'.\n                             map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                             C nm \\<bullet>\\<bullet> rs \\<and>\n                             map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                             C nm' \\<bullet>\\<bullet> rs' \\<and>\n                             (nm = nm' \\<longrightarrow> no_match rs rs'))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> i < min (length\n                                   (map dterm\\<^sub>M\\<^sub>L (rev os)))\n                              (length (map dterm\\<^sub>M\\<^sub>L (rev ps)))\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply (simp (no_asm))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> i < length os \\<and> i < length ps\n 2. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply (metis min_less_iff_conj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(rule_tac x=nm' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm'a rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm' \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm'a \\<bullet>\\<bullet> rs' \\<and>\n                            (nm' = nm'a \\<longrightarrow> no_match rs rs')", "apply(rule_tac x=nm' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm' \\<bullet>\\<bullet> rs \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm' = nm' \\<longrightarrow> no_match rs rs')", "apply(rule_tac x=\"map dterm\\<^sub>M\\<^sub>L (rev vs)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                            C nm' \\<bullet>\\<bullet>\n                            map dterm\\<^sub>M\\<^sub>L (rev vs) \\<and>\n                            map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm' = nm' \\<longrightarrow>\n                             no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                              rs')", "apply(rule_tac x=\"map dterm\\<^sub>M\\<^sub>L (rev vs')\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>i < min (length os) (length ps);\n        rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < min (length os) (length ps);\n         rev ps ! i = C\\<^sub>U nm' vs; rev os ! i = C\\<^sub>U nm' vs';\n         nm' = nm'; no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n        \\<Longrightarrow> no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs'))\\<rbrakk>\n       \\<Longrightarrow> map dterm\\<^sub>M\\<^sub>L (rev ps) ! i =\n                         C nm' \\<bullet>\\<bullet>\n                         map dterm\\<^sub>M\\<^sub>L (rev vs) \\<and>\n                         map dterm\\<^sub>M\\<^sub>L (rev os) ! i =\n                         C nm' \\<bullet>\\<bullet>\n                         map dterm\\<^sub>M\\<^sub>L (rev vs') \\<and>\n                         (nm' = nm' \\<longrightarrow>\n                          no_match (map dterm\\<^sub>M\\<^sub>L (rev vs))\n                           (map dterm\\<^sub>M\\<^sub>L (rev vs')))", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma dterm_ML_comp_patD:\n  \"pattern t \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (comp_pat t) = C nm \\<bullet>\\<bullet> rs \\<Longrightarrow> \\<exists>ts. t = C nm \\<bullet>\\<bullet> ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pattern t;\n     dterm\\<^sub>M\\<^sub>L (comp_pat t) =\n     C nm \\<bullet>\\<bullet> rs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ts. t = C nm \\<bullet>\\<bullet> ts", "by(induct pred:pattern) simp_all"], ["", "lemma no_match_R_coincide_aux[rule_format]: \"patterns ts \\<Longrightarrow>\n  no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs \\<longrightarrow> no_match ts rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns ts \\<Longrightarrow>\n    no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts)\n     rs \\<longrightarrow>\n    no_match ts rs", "apply(induct ts rs rule:no_match.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps\\<rbrakk>\n       \\<Longrightarrow> no_match\n                          (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ps)\n                          ts \\<longrightarrow>\n                         no_match ps ts", "apply(subst (1 2) no_match.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i<min (length ts)\n(length (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ps)).\n                             \\<exists>nm nm' rs rs'.\n                                map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat)\n                                 ps !\n                                i =\n                                C nm \\<bullet>\\<bullet> rs \\<and>\n                                ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match rs rs')) \\<longrightarrow>\n                         (\\<exists>i<min (length ts) (length ps).\n                             \\<exists>nm nm' rs rs'.\n                                ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                                ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match rs rs'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm nm' rs rs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length ts \\<and> x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps; i < length ts; i < length ps;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (ps ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length ts.\n                            i < length ps \\<and>\n                            (\\<exists>nm nm' rs.\n                                ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                                (\\<exists>rs'.\n                                    ts ! i =\n                                    C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match rs rs')))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm nm' rs rs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length ts \\<and> x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps; i < length ts; i < length ps;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (ps ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> i < length ts \\<and>\n                         i < length ps \\<and>\n                         (\\<exists>nm nm' rs.\n                             ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                             (\\<exists>rs'.\n                                 ts ! i =\n                                 C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match rs rs')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm nm' rs rs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length ts \\<and> x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps; i < length ts; i < length ps;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (ps ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm rs.\n                            ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(rule_tac x=nm in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm nm' rs rs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length ts \\<and> x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps; i < length ts; i < length ps;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (ps ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(cut_tac t = \"ps!i\" in dterm_ML_comp_patD, simp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm nm' rs rs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length ts \\<and> x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps; i < length ts; i < length ps;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (ps ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs';\n        \\<exists>ts. ps ! i = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs.\n                            ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length ts \\<and> x < length ps;\n                    ps ! x = C xb \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    patterns xc\\<rbrakk>\n                   \\<Longrightarrow> no_match\n(map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) xc) xd \\<longrightarrow>\n                                     no_match xc xd;\n        patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev tsa))))\n         rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply(erule_tac x = i in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev tsa))))\n         rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n        \\<And>xa xb xc xd.\n           \\<lbrakk>i < length ts \\<and> i < length ps;\n            ps ! i = C xb \\<bullet>\\<bullet> xc;\n            ts ! i = C xb \\<bullet>\\<bullet> xd; xa = xb;\n            patterns xc\\<rbrakk>\n           \\<Longrightarrow> no_match\n                              (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat)\n                                xc)\n                              xd \\<longrightarrow>\n                             no_match xc xd\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply(erule_tac x = nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev tsa))))\n         rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n        \\<And>xb xc xd.\n           \\<lbrakk>i < length ts \\<and> i < length ps;\n            ps ! i = C xb \\<bullet>\\<bullet> xc;\n            ts ! i = C xb \\<bullet>\\<bullet> xd; nm' = xb;\n            patterns xc\\<rbrakk>\n           \\<Longrightarrow> no_match\n                              (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat)\n                                xc)\n                              xd \\<longrightarrow>\n                             no_match xc xd\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply(erule_tac x = nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev tsa))))\n         rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n        \\<And>xc xd.\n           \\<lbrakk>i < length ts \\<and> i < length ps;\n            ps ! i = C nm' \\<bullet>\\<bullet> xc;\n            ts ! i = C nm' \\<bullet>\\<bullet> xd; nm' = nm';\n            patterns xc\\<rbrakk>\n           \\<Longrightarrow> no_match\n                              (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat)\n                                xc)\n                              xd \\<longrightarrow>\n                             no_match xc xd\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply(erule_tac x = tsa in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev tsa))))\n         rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n        \\<And>xd.\n           \\<lbrakk>i < length ts \\<and> i < length ps;\n            ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n            ts ! i = C nm' \\<bullet>\\<bullet> xd; nm' = nm';\n            patterns tsa\\<rbrakk>\n           \\<Longrightarrow> no_match\n                              (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat)\n                                tsa)\n                              xd \\<longrightarrow>\n                             no_match tsa xd\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply(erule_tac x = rs' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev tsa))))\n         rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n        \\<lbrakk>i < length ts \\<and> i < length ps;\n         ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n         ts ! i = C nm' \\<bullet>\\<bullet> rs'; nm' = nm';\n         patterns tsa\\<rbrakk>\n        \\<Longrightarrow> no_match\n                           (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat)\n                             tsa)\n                           rs' \\<longrightarrow>\n                          no_match tsa rs'\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply (simp add:rev_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps ts i nm' rs' tsa.\n       \\<lbrakk>patterns ps; i < length ts; i < length ps;\n        ts ! i = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) tsa) rs';\n        ps ! i = C nm' \\<bullet>\\<bullet> tsa;\n        patterns tsa \\<Longrightarrow> no_match tsa rs'\\<rbrakk>\n       \\<Longrightarrow> no_match tsa rs'", "apply (metis in_set_conv_nth pattern_At_vecD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_match_R_coincide:\n  \"no_match_compR nm (rev vs) \\<Longrightarrow> no_match_R nm (map dterm\\<^sub>M\\<^sub>L vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_compR nm (rev vs) \\<Longrightarrow>\n    no_match_R nm (map dterm\\<^sub>M\\<^sub>L vs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>no_match_compR nm (rev vs); (nm, aa, b) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply(drule_tac x=\"(nm, map comp_pat (rev aa), comp_open b)\" in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow>\n       (nm, map comp_pat (rev aa), comp_open b) \\<in> compR\n 2. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        case (nm, map comp_pat (rev aa), comp_open b) of\n        (nm', ps, v) \\<Rightarrow>\n          nm = nm' \\<longrightarrow>\n          no_match\\<^sub>M\\<^sub>L ps (rev vs)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "unfolding compR_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow>\n       (nm, map comp_pat (rev aa), comp_open b)\n       \\<in> (\\<lambda>(nm, ts, t).\n                 (nm, map comp_pat (rev ts), comp_open t)) `\n             R\n 2. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        case (nm, map comp_pat (rev aa), comp_open b) of\n        (nm', ps, v) \\<Rightarrow>\n          nm = nm' \\<longrightarrow>\n          no_match\\<^sub>M\\<^sub>L ps (rev vs)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply (simp add:image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow>\n       \\<exists>x\\<in>R.\n          (nm, map comp_pat (rev aa), comp_open b) =\n          (case x of\n           (nm, ts, t) \\<Rightarrow>\n             (nm, map comp_pat (rev ts), comp_open t))\n 2. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        case (nm, map comp_pat (rev aa), comp_open b) of\n        (nm', ps, v) \\<Rightarrow>\n          nm = nm' \\<longrightarrow>\n          no_match\\<^sub>M\\<^sub>L ps (rev vs)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply (force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        case (nm, map comp_pat (rev aa), comp_open b) of\n        (nm', ps, v) \\<Rightarrow>\n          nm = nm' \\<longrightarrow>\n          no_match\\<^sub>M\\<^sub>L ps (rev vs)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match\\<^sub>M\\<^sub>L (map comp_pat (rev aa)) (rev vs)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply(drule no_match_coincide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev aa))))\n         (map dterm\\<^sub>M\\<^sub>L (rev (rev vs)))\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply(frule pure_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev aa))))\n         (map dterm\\<^sub>M\\<^sub>L (rev (rev vs)));\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply(drule pattern_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>no_match\n                 (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev aa))))\n                 (map dterm\\<^sub>M\\<^sub>L (rev (rev vs)));\n        (\\<forall>t\\<in>set aa. pure t) \\<and> pure b; patterns aa\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm\\<^sub>M\\<^sub>L vs)", "apply(clarsimp simp add: rev_map no_match.simps[of _ \"map dterm\\<^sub>M\\<^sub>L vs\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm nm' rs rs'.\n       \\<lbrakk>patterns aa; \\<forall>t\\<in>set aa. pure t; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (aa ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length vs.\n                            i < length aa \\<and>\n                            (\\<exists>nm nm' rs.\n                                aa ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                                (\\<exists>rs'.\n                                    map dterm\\<^sub>M\\<^sub>L vs ! i =\n                                    C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match rs rs')))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm nm' rs rs'.\n       \\<lbrakk>patterns aa; \\<forall>t\\<in>set aa. pure t; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (aa ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> i < length vs \\<and>\n                         i < length aa \\<and>\n                         (\\<exists>nm nm' rs.\n                             aa ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                             (\\<exists>rs'.\n                                 map dterm\\<^sub>M\\<^sub>L vs ! i =\n                                 C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match rs rs')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm nm' rs rs'.\n       \\<lbrakk>patterns aa; \\<forall>t\\<in>set aa. pure t; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (aa ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm rs.\n                            aa ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(cut_tac t = \"aa!i\" in dterm_ML_comp_patD, simp, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm nm' rs rs'.\n       \\<lbrakk>patterns aa; \\<forall>t\\<in>set aa. pure t; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (comp_pat (aa ! i)) =\n        C nm \\<bullet>\\<bullet> rs;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs';\n        \\<exists>ts. aa ! i = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm rs.\n                            aa ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm' rs' ts.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map dterm\\<^sub>M\\<^sub>L (rev (map comp_pat (rev ts))))\n         rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> no_match ts rs'", "apply(auto simp: rev_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm' rs' ts.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> no_match ts rs'", "apply(rule no_match_R_coincide_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b i nm' rs' ts x.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts; x \\<in> set ts\\<rbrakk>\n       \\<Longrightarrow> pattern x\n 2. \\<And>aa b i nm' rs' ts.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> no_match\n                          (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts)\n                          rs'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b i nm' rs' ts.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> no_match\n                          (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts)\n                          rs'\n 2. \\<And>aa b i nm' rs' ts x.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts; x \\<in> set ts\\<rbrakk>\n       \\<Longrightarrow> pattern x", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nm' rs' ts x.\n       \\<lbrakk>patterns aa; \\<forall>x\\<in>set aa. pure x; pure b;\n        i < length vs; i < length aa;\n        dterm\\<^sub>M\\<^sub>L (vs ! i) = C nm' \\<bullet>\\<bullet> rs';\n        no_match (map (dterm\\<^sub>M\\<^sub>L \\<circ> comp_pat) ts) rs';\n        aa ! i = C nm' \\<bullet>\\<bullet> ts; x \\<in> set ts\\<rbrakk>\n       \\<Longrightarrow> pattern x", "apply (metis in_set_conv_nth pattern_At_vecD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "inductive C_normal :: \"tm \\<Rightarrow> bool\" where\n\"\\<forall>t\\<in>set ts. C_normal t \\<Longrightarrow> C_normal(V x \\<bullet>\\<bullet> ts)\" |\n\"C_normal t \\<Longrightarrow> C_normal(\\<Lambda> t)\" |\n\"C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> C_normal(term v)\" |\n\"\\<forall>t\\<in>set ts. C_normal t \\<Longrightarrow> no_match_R nm (map dterm ts)\n \\<Longrightarrow> C_normal(C nm \\<bullet>\\<bullet> ts)\""], ["", "declare C_normal.intros[simp]"], ["", "lemma C_normal_term[simp]: \"C_normal(term v) = C_normal\\<^sub>M\\<^sub>L v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (term v) = C_normal\\<^sub>M\\<^sub>L v", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (term v) \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v", "apply(erule C_normal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ts x.\n       \\<lbrakk>term v = V x \\<bullet>\\<bullet> ts;\n        \\<forall>t\\<in>set ts. C_normal t\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v\n 2. \\<And>t.\n       \\<lbrakk>term v = \\<Lambda> t; C_normal t\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v\n 3. \\<And>va.\n       \\<lbrakk>term v = term va; C_normal\\<^sub>M\\<^sub>L va\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v\n 4. \\<And>ts nm.\n       \\<lbrakk>term v = C nm \\<bullet>\\<bullet> ts;\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"C_normal(\\<Lambda> t) = C_normal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (\\<Lambda> t) = C_normal t", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (\\<Lambda> t) \\<Longrightarrow> C_normal t", "apply(erule C_normal.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ts x.\n       \\<lbrakk>\\<Lambda> t = V x \\<bullet>\\<bullet> ts;\n        \\<forall>t\\<in>set ts. C_normal t\\<rbrakk>\n       \\<Longrightarrow> C_normal t\n 2. \\<And>ta.\n       \\<lbrakk>\\<Lambda> t = \\<Lambda> ta; C_normal ta\\<rbrakk>\n       \\<Longrightarrow> C_normal t\n 3. \\<And>v.\n       \\<lbrakk>\\<Lambda> t = term v; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n       \\<Longrightarrow> C_normal t\n 4. \\<And>ts nm.\n       \\<lbrakk>\\<Lambda> t = C nm \\<bullet>\\<bullet> ts;\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal t", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"C_normal(V x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (V x)", "using C_normal.intros(1)[of \"[]\" x]"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set []. C_normal t \\<Longrightarrow>\n  C_normal (V x \\<bullet>\\<bullet> [])\n\ngoal (1 subgoal):\n 1. C_normal (V x)", "by simp"], ["", "lemma [simp]: \"dterm (dterm\\<^sub>M\\<^sub>L v) = dterm\\<^sub>M\\<^sub>L v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dterm (dterm\\<^sub>M\\<^sub>L v) = dterm\\<^sub>M\\<^sub>L v", "apply(induct v rule:dterm_ML.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm vs.\n       (\\<And>x.\n           x \\<in> set (rev vs) \\<Longrightarrow>\n           dterm (dterm\\<^sub>M\\<^sub>L x) =\n           dterm\\<^sub>M\\<^sub>L x) \\<Longrightarrow>\n       dterm (dterm\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)) =\n       dterm\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\n 2. \\<And>v.\n       dterm (dterm\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L v)) =\n       dterm\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L v)\n 3. \\<And>v.\n       dterm (dterm\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L v)) =\n       dterm\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L v)\n 4. \\<And>v va.\n       dterm (dterm\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v va)) =\n       dterm\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v va)\n 5. \\<And>v.\n       dterm (dterm\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v)) =\n       dterm\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v)\n 6. \\<And>v va.\n       dterm (dterm\\<^sub>M\\<^sub>L (V\\<^sub>U v va)) =\n       dterm\\<^sub>M\\<^sub>L (V\\<^sub>U v va)\n 7. \\<And>v va vb.\n       dterm (dterm\\<^sub>M\\<^sub>L (Clo v va vb)) =\n       dterm\\<^sub>M\\<^sub>L (Clo v va vb)\n 8. \\<And>v va.\n       dterm (dterm\\<^sub>M\\<^sub>L (apply v va)) =\n       dterm\\<^sub>M\\<^sub>L (apply v va)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"u\\<Rightarrow>(v::ml) \\<Longrightarrow> True\" and\n  Red_ml_list_length: \"vs \\<Rightarrow> vs' \\<Longrightarrow> length vs = length vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<Rightarrow> v \\<Longrightarrow> True) &&&\n    (vs \\<Rightarrow> vs' \\<Longrightarrow> length vs = length vs')", "by(induct rule: Red_ml_Red_ml_list.inducts) simp_all"], ["", "lemma \"(v::ml) \\<Rightarrow> v' \\<Longrightarrow> True\" and\n  Red_ml_list_nth: \"(vs::ml list) \\<Rightarrow> vs'\n  \\<Longrightarrow> \\<exists>v' k. k<size vs \\<and> vs!k \\<Rightarrow> v' \\<and> vs' = vs[k := v']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<Rightarrow> v' \\<Longrightarrow> True) &&&\n    (vs \\<Rightarrow> vs' \\<Longrightarrow>\n     \\<exists>v' k.\n        k < length vs \\<and>\n        vs ! k \\<Rightarrow> v' \\<and> vs' = vs[k := v'])", "apply (induct rule: Red_ml_Red_ml_list.inducts)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>u v. True\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> True\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs'\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>f vs v. True\n 5. \\<And>n f vs v. 0 < n \\<Longrightarrow> True\n 6. \\<And>nm vs v. True\n 7. \\<And>x vs v. True\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<exists>v' k.\n           k < length vs \\<and>\n           vs ! k \\<Rightarrow> v' \\<and> vs' = vs[k := v']\\<rbrakk>\n       \\<Longrightarrow> True\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<exists>v' k.\n           k < length vs \\<and>\n           vs ! k \\<Rightarrow> v' \\<and> vs' = vs[k := v']\\<rbrakk>\n       \\<Longrightarrow> True\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f'; True\\<rbrakk> \\<Longrightarrow> True\nA total of 17 subgoals...", "apply (auto split:nat.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Red_ml_list_pres_no_match:\n  \"no_match\\<^sub>M\\<^sub>L ps vs \\<Longrightarrow> vs \\<Rightarrow> vs' \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_match\\<^sub>M\\<^sub>L ps vs; vs \\<Rightarrow> vs'\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps vs'", "proof(induct ps vs arbitrary: vs' rule:no_match_ML.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps os vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd vs'.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd;\n                    xd \\<Rightarrow> vs'\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc vs';\n        no_match\\<^sub>M\\<^sub>L ps os; os \\<Rightarrow> vs'\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps vs'", "case (1 vs os)"], ["proof (state)\nthis:\n  \\<lbrakk>?x < min (length os) (length vs);\n   rev vs ! ?x = C\\<^sub>U ?xa ?xc; rev os ! ?x = C\\<^sub>U ?xb ?xd;\n   ?xa = ?xb; no_match\\<^sub>M\\<^sub>L ?xc ?xd;\n   ?xd \\<Rightarrow> ?vs'\\<rbrakk>\n  \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ?xc ?vs'\n  no_match\\<^sub>M\\<^sub>L vs os\n  os \\<Rightarrow> vs'\n\ngoal (1 subgoal):\n 1. \\<And>ps os vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd vs'.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    no_match\\<^sub>M\\<^sub>L xc xd;\n                    xd \\<Rightarrow> vs'\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc vs';\n        no_match\\<^sub>M\\<^sub>L ps os; os \\<Rightarrow> vs'\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps vs'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match\\<^sub>M\\<^sub>L vs vs'", "using 1(2-3)"], ["proof (prove)\nusing this:\n  no_match\\<^sub>M\\<^sub>L vs os\n  os \\<Rightarrow> vs'\n\ngoal (1 subgoal):\n 1. no_match\\<^sub>M\\<^sub>L vs vs'", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_match\\<^sub>M\\<^sub>L vs os; os \\<Rightarrow> vs'\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'", "apply(frule Red_ml_list_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_match\\<^sub>M\\<^sub>L vs os; os \\<Rightarrow> vs';\n     length os = length vs'\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'", "apply(rotate_tac -2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n     no_match\\<^sub>M\\<^sub>L vs os\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'", "apply(subst (asm) no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n     \\<exists>i<min (length os) (length vs).\n        \\<exists>nm nm' vs vs'.\n           rev vs ! i = C\\<^sub>U nm vs \\<and>\n           rev os ! i = C\\<^sub>U nm' vs' \\<and>\n           (nm = nm' \\<longrightarrow>\n            no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' vs vs'.\n       \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n        i < min (length os) (length vs); rev vs ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'", "apply(rename_tac i nm nm' us us')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us'.\n       \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n        i < min (length os) (length vs); rev vs ! i = C\\<^sub>U nm us;\n        rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us'\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'", "apply(subst no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us'.\n       \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n        i < min (length os) (length vs); rev vs ! i = C\\<^sub>U nm us;\n        rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length vs') (length vs).\n                            \\<exists>nm nm' vs vs'.\n                               rev vs ! i = C\\<^sub>U nm vs \\<and>\n                               rev vs' ! i = C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us'.\n       \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n        i < min (length os) (length vs); rev vs ! i = C\\<^sub>U nm us;\n        rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us'\\<rbrakk>\n       \\<Longrightarrow> i < min (length vs') (length vs) \\<and>\n                         (\\<exists>nm nm' vs vs'.\n                             rev vs ! i = C\\<^sub>U nm vs \\<and>\n                             rev vs' ! i = C\\<^sub>U nm' vs' \\<and>\n                             (nm = nm' \\<longrightarrow>\n                              no_match\\<^sub>M\\<^sub>L vs vs'))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us'.\n       \\<lbrakk>os \\<Rightarrow> vs'; length os = length vs';\n        i < length vs' \\<and> i < length vs; rev vs ! i = C\\<^sub>U nm us;\n        rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev vs' ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply(drule Red_ml_list_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us'.\n       \\<lbrakk>length os = length vs'; i < length vs' \\<and> i < length vs;\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        \\<exists>v' k.\n           k < length os \\<and>\n           os ! k \\<Rightarrow> v' \\<and> vs' = os[k := v']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev vs' ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply(rename_tac k)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply(case_tac \"k = length os - Suc i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k = length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 2. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k \\<noteq> length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k \\<noteq> length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 2. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k = length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply(rule_tac x=nm' in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k \\<noteq> length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 2. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k = length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply(rule_tac x=us' in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k \\<noteq> length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> rev (os[k := v']) ! i = C\\<^sub>U nm' us' \\<and>\n                         (nm = nm' \\<longrightarrow>\n                          no_match\\<^sub>M\\<^sub>L us us')\n 2. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k = length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply (simp add: rev_nth nth_list_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>length os = length (os[k := v']);\n        rev vs ! i = C\\<^sub>U nm us; rev os ! i = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length (os[k := v']); i < length vs; k < length os;\n        os ! k \\<Rightarrow> v'; vs' = os[k := v'];\n        k = length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (os[k := v']) ! i = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply (simp add: rev_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us' v' k.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        C\\<^sub>U nm' us' \\<Rightarrow> v';\n        vs' = os[length os - Suc i := v']; k = length os - Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')", "apply(erule Red_ml.cases)"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>i nm nm' us us' v' k u v.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v];\n        v' = u[v/0]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 2. \\<And>i nm nm' us us' v' k nma vs v \\<sigma>.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' =\n        A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nma)\n         (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs);\n        v' = subst\\<^sub>M\\<^sub>L \\<sigma> v; (nma, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 3. \\<And>i nm nm' us us' v' k \\<sigma> vs arity nma vs'.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nma) vs';\n        v' = subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nma vs);\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nma];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nma vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 4. \\<And>i nm nm' us us' v' k f vs v.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = apply (Clo f vs (Suc 0)) v;\n        v' = A\\<^sub>M\\<^sub>L f (v # vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 5. \\<And>i nm nm' us us' v' k n f vs v.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = apply (Clo f vs (Suc n)) v;\n        v' = Clo f (v # vs) n; 0 < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 6. \\<And>i nm nm' us us' v' k nma vs v.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = apply (C\\<^sub>U nma vs) v;\n        v' = C\\<^sub>U nma (v # vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 7. \\<And>i nm nm' us us' v' k x vs v.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = apply (V\\<^sub>U x vs) v;\n        v' = V\\<^sub>U x (v # vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 8. \\<And>i nm nm' us us' v' k vs vs' nma.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = C\\<^sub>U nma vs; v' = C\\<^sub>U nma vs';\n        vs \\<Rightarrow> vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 9. \\<And>i nm nm' us us' v' k vs vs' x.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' us';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := v']; k = length os - Suc i;\n        C\\<^sub>U nm' us' = V\\<^sub>U x vs; v' = V\\<^sub>U x vs';\n        vs \\<Rightarrow> vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            v' = C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L us vs')\n 10. \\<And>i nm nm' us us' v' k f f' vs n.\n        \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n         os ! (length os - Suc i) = C\\<^sub>U nm' us';\n         nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us us';\n         i < length os; i < length vs; length os - Suc i < length os;\n         vs' = os[length os - Suc i := v']; k = length os - Suc i;\n         C\\<^sub>U nm' us' = Clo f vs n; v' = Clo f' vs n;\n         f \\<Rightarrow> f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>nm' vs'.\n                             v' = C\\<^sub>U nm' vs' \\<and>\n                             (nm = nm' \\<longrightarrow>\n                              no_match\\<^sub>M\\<^sub>L us vs')\nA total of 15 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' us us' v' k vs vs'.\n       \\<lbrakk>vs ! (length vs - Suc i) = C\\<^sub>U nm us;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs;\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L us vs;\n        i < length os; i < length vs; length os - Suc i < length os;\n        vs' = os[length os - Suc i := C\\<^sub>U nm' vs'];\n        k = length os - Suc i; us' = vs; v' = C\\<^sub>U nm' vs';\n        vs \\<Rightarrow> vs'\\<rbrakk>\n       \\<Longrightarrow> nm = nm' \\<longrightarrow>\n                         no_match\\<^sub>M\\<^sub>L us vs'", "apply(fastforce intro: 1(1) simp add:rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  no_match\\<^sub>M\\<^sub>L vs vs'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_match_ML_subst_ML[rule_format]:\n  \"\\<forall>v\\<in>set vs. \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v. C_normal\\<^sub>M\\<^sub>L (\\<sigma> x) \\<Longrightarrow>\n   no_match\\<^sub>M\\<^sub>L ps vs \\<longrightarrow> no_match\\<^sub>M\\<^sub>L ps (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>set vs.\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x) \\<Longrightarrow>\n    no_match\\<^sub>M\\<^sub>L ps vs \\<longrightarrow>\n    no_match\\<^sub>M\\<^sub>L ps (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)", "apply(induct ps vs rule:no_match_ML.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < min (length os) (length ps);\n                    rev ps ! x = C\\<^sub>U xa xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps os \\<longrightarrow>\n                         no_match\\<^sub>M\\<^sub>L ps\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) os)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps os \\<longrightarrow>\n                         no_match\\<^sub>M\\<^sub>L ps\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) os)", "apply(subst (1 2) no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>i<min (length os) (length ps).\n                             \\<exists>nm nm' vs vs'.\n                                rev ps ! i = C\\<^sub>U nm vs \\<and>\n                                rev os ! i = C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs\n                                  vs')) \\<longrightarrow>\n                         (\\<exists>i<min\n(length (map (subst\\<^sub>M\\<^sub>L \\<sigma>) os)) (length ps).\n                             \\<exists>nm nm' vs vs'.\n                                rev ps ! i = C\\<^sub>U nm vs \\<and>\n                                rev (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\nos) !\n                                i =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length os.\n                            i < length ps \\<and>\n                            (\\<exists>nm nm' vs.\n                                rev ps ! i = C\\<^sub>U nm vs \\<and>\n                                (\\<exists>vs'.\n                                    rev (map\n    (subst\\<^sub>M\\<^sub>L \\<sigma>) os) !\n                                    i =\n                                    C\\<^sub>U nm' vs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L vs vs')))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> i < length os \\<and>\n                         i < length ps \\<and>\n                         (\\<exists>nm nm' vs.\n                             rev ps ! i = C\\<^sub>U nm vs \\<and>\n                             (\\<exists>vs'.\n                                 rev (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n os) !\n                                 i =\n                                 C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vs vs')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (map (subst\\<^sub>M\\<^sub>L \\<sigma>) os) !\n                            i =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=nm' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            rev (map (subst\\<^sub>M\\<^sub>L \\<sigma>) os) !\n                            i =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=\"map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> rev (map (subst\\<^sub>M\\<^sub>L \\<sigma>) os) ! i =\n                         C\\<^sub>U nm'\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs') \\<and>\n                         (nm = nm' \\<longrightarrow>\n                          no_match\\<^sub>M\\<^sub>L vs\n                           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs'))", "apply (auto simp:rev_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    ps ! (length ps - Suc x) = C\\<^sub>U xb xc;\n                    os ! (length os - Suc x) = C\\<^sub>U xb xd; xa = xb;\n                    \\<forall>v\\<in>set xd.\n                       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (subst\\<^sub>M\\<^sub>L \\<sigma>) xd);\n        \\<forall>v\\<in>set os.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply(erule_tac x = i in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<forall>v\\<in>set os.\n                   \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                      C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xa xb xc xd.\n           \\<lbrakk>i < length os \\<and> i < length ps;\n            ps ! (length ps - Suc i) = C\\<^sub>U xb xc;\n            os ! (length os - Suc i) = C\\<^sub>U xb xd; xa = xb;\n            \\<forall>v\\<in>set xd.\n               \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L xc\n                              (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                                xd)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply(erule_tac x = nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<forall>v\\<in>set os.\n                   \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                      C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xb xc xd.\n           \\<lbrakk>i < length os \\<and> i < length ps;\n            ps ! (length ps - Suc i) = C\\<^sub>U xb xc;\n            os ! (length os - Suc i) = C\\<^sub>U xb xd; nm' = xb;\n            \\<forall>v\\<in>set xd.\n               \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L xc\n                              (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                                xd)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply(erule_tac x = nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<forall>v\\<in>set os.\n                   \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                      C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xc xd.\n           \\<lbrakk>i < length os \\<and> i < length ps;\n            ps ! (length ps - Suc i) = C\\<^sub>U nm' xc;\n            os ! (length os - Suc i) = C\\<^sub>U nm' xd; nm' = nm';\n            \\<forall>v\\<in>set xd.\n               \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L xc\n                              (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                                xd)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply(erule_tac x = vs in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<forall>v\\<in>set os.\n                   \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                      C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<And>xd.\n           \\<lbrakk>i < length os \\<and> i < length ps;\n            ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n            os ! (length os - Suc i) = C\\<^sub>U nm' xd; nm' = nm';\n            \\<forall>v\\<in>set xd.\n               \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs\n                              (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                                xd)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply(erule_tac x = vs' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<forall>v\\<in>set os.\n                   \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                      C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<lbrakk>i < length os \\<and> i < length ps;\n         ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n         os ! (length os - Suc i) = C\\<^sub>U nm' vs'; nm' = nm';\n         \\<forall>v\\<in>set vs'.\n            \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n               C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\\<rbrakk>\n        \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs' \\<longrightarrow>\n                          no_match\\<^sub>M\\<^sub>L vs\n                           (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                             vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm' vs vs'.\n       \\<lbrakk>\\<forall>v\\<in>set os.\n                   \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                      C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm' vs;\n        os ! (length os - Suc i) = C\\<^sub>U nm' vs';\n        no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<forall>v\\<in>set vs'.\n           \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n              C_normal\\<^sub>M\\<^sub>L (\\<sigma> x) \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L vs\n         (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L vs\n                          (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs')", "apply (metis UN_I fv_ML.simps(5) in_set_conv_nth length_rev rev_nth set_rev)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lift_is_CUD:\n  \"lift\\<^sub>M\\<^sub>L k v = C\\<^sub>U nm vs' \\<Longrightarrow> \\<exists>vs. v = C\\<^sub>U nm vs \\<and> vs' = map (lift\\<^sub>M\\<^sub>L k) vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift\\<^sub>M\\<^sub>L k v = C\\<^sub>U nm vs' \\<Longrightarrow>\n    \\<exists>vs.\n       v = C\\<^sub>U nm vs \\<and> vs' = map (lift\\<^sub>M\\<^sub>L k) vs", "by(cases v) auto"], ["", "lemma no_match_ML_lift_ML:\n  \"no_match\\<^sub>M\\<^sub>L ps (map (lift\\<^sub>M\\<^sub>L k) vs) = no_match\\<^sub>M\\<^sub>L ps vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match\\<^sub>M\\<^sub>L ps (map (lift\\<^sub>M\\<^sub>L k) vs) =\n    no_match\\<^sub>M\\<^sub>L ps vs", "apply(induct ps vs rule:no_match_ML.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       (\\<And>x xa xb xc xd.\n           \\<lbrakk>x < min (length os) (length ps);\n            rev ps ! x = C\\<^sub>U xa xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              (map (lift\\<^sub>M\\<^sub>L k) xd) =\n                             no_match\\<^sub>M\\<^sub>L xc\n                              xd) \\<Longrightarrow>\n       no_match\\<^sub>M\\<^sub>L ps (map (lift\\<^sub>M\\<^sub>L k) os) =\n       no_match\\<^sub>M\\<^sub>L ps os", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       (\\<And>x xa xb xc xd.\n           \\<lbrakk>x < length os \\<and> x < length ps;\n            rev ps ! x = C\\<^sub>U xb xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              (map (lift\\<^sub>M\\<^sub>L k) xd) =\n                             no_match\\<^sub>M\\<^sub>L xc\n                              xd) \\<Longrightarrow>\n       no_match\\<^sub>M\\<^sub>L ps (map (lift\\<^sub>M\\<^sub>L k) os) =\n       no_match\\<^sub>M\\<^sub>L ps os", "apply(subst (1 2) no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       (\\<And>x xa xb xc xd.\n           \\<lbrakk>x < length os \\<and> x < length ps;\n            rev ps ! x = C\\<^sub>U xb xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              (map (lift\\<^sub>M\\<^sub>L k) xd) =\n                             no_match\\<^sub>M\\<^sub>L xc\n                              xd) \\<Longrightarrow>\n       (\\<exists>i<min (length (map (lift\\<^sub>M\\<^sub>L k) os))\n                    (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n              C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')) =\n       (\\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length (map (lift\\<^sub>M\\<^sub>L k) os))\n                    (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n              C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length os) (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev os ! i = C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')\n 2. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map (lift\\<^sub>M\\<^sub>L k) os))\n                                     (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                               C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length os.\n                            i < length ps \\<and>\n                            (\\<exists>nm nm' vs.\n                                rev ps ! i = C\\<^sub>U nm vs \\<and>\n                                (\\<exists>vs'.\n                                    rev os ! i = C\\<^sub>U nm' vs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L vs vs')))\n 2. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map (lift\\<^sub>M\\<^sub>L k) os))\n                                     (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                               C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> i < length os \\<and>\n                         i < length ps \\<and>\n                         (\\<exists>nm nm' vs.\n                             rev ps ! i = C\\<^sub>U nm vs \\<and>\n                             (\\<exists>vs'.\n                                 rev os ! i = C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vs vs')))\n 2. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map (lift\\<^sub>M\\<^sub>L k) os))\n                                     (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                               C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply (simp add:rev_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    ps ! (length ps - Suc x) = C\\<^sub>U xb xc;\n                    os ! (length os - Suc x) = C\\<^sub>U xb xd;\n                    xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm vs;\n        lift\\<^sub>M\\<^sub>L k (os ! (length os - Suc i)) =\n        C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            os ! (length os - Suc i) =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')\n 2. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map (lift\\<^sub>M\\<^sub>L k) os))\n                                     (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                               C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply(drule lift_is_CUD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    ps ! (length ps - Suc x) = C\\<^sub>U xb xc;\n                    os ! (length os - Suc x) = C\\<^sub>U xb xd;\n                    xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps;\n        ps ! (length ps - Suc i) = C\\<^sub>U nm vs;\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs';\n        \\<exists>vs.\n           os ! (length os - Suc i) = C\\<^sub>U nm' vs \\<and>\n           vs' = map (lift\\<^sub>M\\<^sub>L k) vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            os ! (length os - Suc i) =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')\n 2. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map (lift\\<^sub>M\\<^sub>L k) os))\n                                     (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                               C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        \\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length\n    (map (lift\\<^sub>M\\<^sub>L k) os))\n                                     (length ps).\n                            \\<exists>nm nm' vs vs'.\n                               rev ps ! i = C\\<^sub>U nm vs \\<and>\n                               rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                               C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length os.\n                            i < length ps \\<and>\n                            (\\<exists>nm nm' vs.\n                                rev ps ! i = C\\<^sub>U nm vs \\<and>\n                                (\\<exists>vs'.\n                                    rev (map (lift\\<^sub>M\\<^sub>L k) os) !\n                                    i =\n                                    C\\<^sub>U nm' vs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L vs vs')))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> i < length os \\<and>\n                         i < length ps \\<and>\n                         (\\<exists>nm nm' vs.\n                             rev ps ! i = C\\<^sub>U nm vs \\<and>\n                             (\\<exists>vs'.\n                                 rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                                 C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vs vs')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=nm' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=\"map (lift\\<^sub>M\\<^sub>L k) vs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n(map (lift\\<^sub>M\\<^sub>L k) xd) =\n                                     no_match\\<^sub>M\\<^sub>L xc xd;\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> rev (map (lift\\<^sub>M\\<^sub>L k) os) ! i =\n                         C\\<^sub>U nm'\n                          (map (lift\\<^sub>M\\<^sub>L k) vs') \\<and>\n                         (nm = nm' \\<longrightarrow>\n                          no_match\\<^sub>M\\<^sub>L vs\n                           (map (lift\\<^sub>M\\<^sub>L k) vs'))", "apply (fastforce simp:rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_normal_ML_lift_ML: \"C_normal\\<^sub>M\\<^sub>L(lift\\<^sub>M\\<^sub>L k v) = C_normal\\<^sub>M\\<^sub>L v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L (lift\\<^sub>M\\<^sub>L k v) =\n    C_normal\\<^sub>M\\<^sub>L v", "by(induct v arbitrary: k rule:C_normal_ML.induct)(auto simp:no_match_ML_lift_ML)"], ["", "lemma no_match_compR_Cons:\n  \"no_match_compR nm vs \\<Longrightarrow> no_match_compR nm (v # vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_compR nm vs \\<Longrightarrow> no_match_compR nm (v # vs)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>no_match_compR nm vs; (nm, aa, b) \\<in> compR\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L aa (v # vs)", "apply(drule bspec, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> compR;\n        case (nm, aa, b) of\n        (nm', ps, v) \\<Rightarrow>\n          nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L ps vs\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L aa (v # vs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> compR;\n        no_match\\<^sub>M\\<^sub>L aa vs\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L aa (v # vs)", "apply(subst (asm) no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> compR;\n        \\<exists>i<min (length vs) (length aa).\n           \\<exists>nm nm' vsa vs'.\n              rev aa ! i = C\\<^sub>U nm vsa \\<and>\n              rev vs ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vsa vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L aa (v # vs)", "apply(subst no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> compR;\n        \\<exists>i<min (length vs) (length aa).\n           \\<exists>nm nm' vsa vs'.\n              rev aa ! i = C\\<^sub>U nm vsa \\<and>\n              rev vs ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vsa vs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length (v # vs)) (length aa).\n                            \\<exists>nm nm' vsa vs'.\n                               rev aa ! i = C\\<^sub>U nm vsa \\<and>\n                               rev (v # vs) ! i = C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vsa vs')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nma nm' vsa vs'.\n       \\<lbrakk>(nm, aa, b) \\<in> compR; i < length vs; i < length aa;\n        rev aa ! i = C\\<^sub>U nma vsa; rev vs ! i = C\\<^sub>U nm' vs';\n        nma = nm' \\<longrightarrow>\n        no_match\\<^sub>M\\<^sub>L vsa vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<Suc (length vs).\n                            i < length aa \\<and>\n                            (\\<exists>nm nm' vsa.\n                                rev aa ! i = C\\<^sub>U nm vsa \\<and>\n                                (\\<exists>vs'.\n                                    (rev vs @ [v]) ! i =\n                                    C\\<^sub>U nm' vs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L vsa vs')))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b i nma nm' vsa vs'.\n       \\<lbrakk>(nm, aa, b) \\<in> compR; i < length vs; i < length aa;\n        rev aa ! i = C\\<^sub>U nma vsa; rev vs ! i = C\\<^sub>U nm' vs';\n        nma = nm' \\<longrightarrow>\n        no_match\\<^sub>M\\<^sub>L vsa vs'\\<rbrakk>\n       \\<Longrightarrow> i < Suc (length vs) \\<and>\n                         i < length aa \\<and>\n                         (\\<exists>nm nm' vsa.\n                             rev aa ! i = C\\<^sub>U nm vsa \\<and>\n                             (\\<exists>vs'.\n                                 (rev vs @ [v]) ! i =\n                                 C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vsa vs')))", "apply (simp add:nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_normal_ML_comp_open: \"pure t \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L(comp_open t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (comp_open t)", "by (induct pred:pure) (auto simp:comp_open_def)"], ["", "lemma C_normal_compR_rhs: \"(nm, vs, v) \\<in> compR \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (nm, vs, v) \\<in> compR \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v", "by(auto simp: compR_def image_def Bex_def pure_R C_normal_ML_comp_open)"], ["", "lemma C_normal_ML_subst_ML:\n  \"C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow> (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v. C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L\n     (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n    \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n       C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)", "proof(induct \\<sigma> v rule:subst_ML.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (C\\<^sub>M\\<^sub>L nm)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (V\\<^sub>M\\<^sub>L X)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (A\\<^sub>M\\<^sub>L v vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (A\\<^sub>M\\<^sub>L v vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 4. \\<And>\\<sigma> v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                   v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L\n                    ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (Lam\\<^sub>M\\<^sub>L v).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 5. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (C\\<^sub>U nm vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 6. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> xa)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>U x vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 7. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 8. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n        \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)", "case 4"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_)\n     v_) \\<Longrightarrow>\n  \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v_.\n     C_normal\\<^sub>M\\<^sub>L ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_) x)\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L \\<sigma>_ (Lam\\<^sub>M\\<^sub>L v_))\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (C\\<^sub>M\\<^sub>L nm)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (V\\<^sub>M\\<^sub>L X)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (A\\<^sub>M\\<^sub>L v vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (A\\<^sub>M\\<^sub>L v vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 4. \\<And>\\<sigma> v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                   v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L\n                    ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (Lam\\<^sub>M\\<^sub>L v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (Lam\\<^sub>M\\<^sub>L v).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 5. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (C\\<^sub>U nm vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 6. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> xa)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>U x vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 7. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 8. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n        \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)", "thus ?case"], ["proof (prove)\nusing this:\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_)\n     v_) \\<Longrightarrow>\n  \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v_.\n     C_normal\\<^sub>M\\<^sub>L ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_) x)\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L \\<sigma>_ (Lam\\<^sub>M\\<^sub>L v_))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_).\n       C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x)", "by(simp del:apply_cons_ML)(force simp add: C_normal_ML_lift_ML)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_).\n     C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x)\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (C\\<^sub>M\\<^sub>L nm)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (V\\<^sub>M\\<^sub>L X)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (A\\<^sub>M\\<^sub>L v vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (A\\<^sub>M\\<^sub>L v vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 4. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (C\\<^sub>U nm vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 5. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> xa)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>U x vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 6. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 7. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n        \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)", "(* weird - force suffices in apply style *)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_).\n     C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x)\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (C\\<^sub>M\\<^sub>L nm)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma>\n          (V\\<^sub>M\\<^sub>L X)) \\<Longrightarrow>\n       \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n          C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (A\\<^sub>M\\<^sub>L v vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (A\\<^sub>M\\<^sub>L v vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 4. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n   (C\\<^sub>U nm vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 5. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma> xa)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n  C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>U x vs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>U x vs).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 6. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs;\n            C_normal\\<^sub>M\\<^sub>L\n             (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)\n 7. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) \\<Longrightarrow>\n                \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<Longrightarrow>\n        \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x);\n        C_normal\\<^sub>M\\<^sub>L\n         (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x)", "qed auto"], ["", "lemma C_normal_ML_subst_ML_iff: \"C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n  C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) \\<longleftrightarrow> (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v. C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n    C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n    (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n        C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "proof(induct \\<sigma> v rule:subst_ML.induct)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                   v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L\n                     ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) x));\n        C_normal\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (Lam\\<^sub>M\\<^sub>L v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (Lam\\<^sub>M\\<^sub>L v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (C\\<^sub>U nm vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 7. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 8. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "case 4"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L v_ \\<Longrightarrow>\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_) v_) =\n  (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v_.\n      C_normal\\<^sub>M\\<^sub>L ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_) x))\n  C_normal\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_)\n\ngoal (8 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>)\n                   v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L\n                     ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>) x));\n        C_normal\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (Lam\\<^sub>M\\<^sub>L v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (Lam\\<^sub>M\\<^sub>L v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (C\\<^sub>U nm vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 7. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 8. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "thus ?case"], ["proof (prove)\nusing this:\n  C_normal\\<^sub>M\\<^sub>L v_ \\<Longrightarrow>\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_) v_) =\n  (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v_.\n      C_normal\\<^sub>M\\<^sub>L ((V\\<^sub>M\\<^sub>L 0 ## \\<sigma>_) x))\n  C_normal\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_)\n\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L\n     (subst\\<^sub>M\\<^sub>L \\<sigma>_ (Lam\\<^sub>M\\<^sub>L v_)) =\n    (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_).\n        C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))", "by(simp del:apply_cons_ML)(force simp add: C_normal_ML_lift_ML)"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L \\<sigma>_ (Lam\\<^sub>M\\<^sub>L v_)) =\n  (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_).\n      C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (C\\<^sub>U nm vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 7. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "(* weird - force suffices in apply style *)"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L \\<sigma>_ (Lam\\<^sub>M\\<^sub>L v_)) =\n  (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v_).\n      C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (C\\<^sub>U nm vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 7. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (C\\<^sub>U nm vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 7. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "case 5"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set vs_; C_normal\\<^sub>M\\<^sub>L ?x\\<rbrakk>\n  \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma>_ ?x) =\n                    (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L ?x.\n                        C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))\n  C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm_ vs_)\n\ngoal (7 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> nm vs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (C\\<^sub>U nm vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 7. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set vs_; C_normal\\<^sub>M\\<^sub>L ?x\\<rbrakk>\n  \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                     (subst\\<^sub>M\\<^sub>L \\<sigma>_ ?x) =\n                    (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L ?x.\n                        C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))\n  C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm_ vs_)\n\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L\n     (subst\\<^sub>M\\<^sub>L \\<sigma>_ (C\\<^sub>U nm_ vs_)) =\n    (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>U nm_ vs_).\n        C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))", "by simp (blast intro: no_match_ML_subst_ML)"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L\n   (subst\\<^sub>M\\<^sub>L \\<sigma>_ (C\\<^sub>U nm_ vs_)) =\n  (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>U nm_ vs_).\n      C_normal\\<^sub>M\\<^sub>L (\\<sigma>_ x))\n\ngoal (6 subgoals):\n 1. \\<And>\\<sigma> nm.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>M\\<^sub>L nm)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 2. \\<And>\\<sigma> X.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L\n        (subst\\<^sub>M\\<^sub>L \\<sigma> (V\\<^sub>M\\<^sub>L X)) =\n       (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X).\n           C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 3. \\<And>\\<sigma> v vs.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (A\\<^sub>M\\<^sub>L v vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (A\\<^sub>M\\<^sub>L v vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 4. \\<And>\\<sigma> x vs.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n(subst\\<^sub>M\\<^sub>L \\<sigma> xa) =\n                                     (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L xa.\n   C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (V\\<^sub>U x vs)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L\n    (V\\<^sub>U x vs).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 5. \\<And>\\<sigma> v vs n.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        \\<And>x.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> x) =\n                             (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L x.\n                                 C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (Clo v vs n)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (Clo v vs n).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))\n 6. \\<And>\\<sigma> u v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                C_normal\\<^sub>M\\<^sub>L\n                 (subst\\<^sub>M\\<^sub>L \\<sigma> u) =\n                (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L u.\n                    C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n        C_normal\\<^sub>M\\<^sub>L (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n        (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L v.\n            C_normal\\<^sub>M\\<^sub>L (\\<sigma> x));\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (apply u v)) =\n                         (\\<forall>x\\<in>fv\\<^sub>M\\<^sub>L (apply u v).\n                             C_normal\\<^sub>M\\<^sub>L (\\<sigma> x))", "qed auto"], ["", "lemma C_normal_ML_inv: \"v \\<Rightarrow> v' \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v'\" and\n      \"vs \\<Rightarrow> vs' \\<Longrightarrow> \\<forall>v\\<in>set vs. C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> \\<forall>v'\\<in>set vs'. C_normal\\<^sub>M\\<^sub>L v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n     \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v') &&&\n    (\\<lbrakk>vs \\<Rightarrow> vs';\n      \\<forall>v\\<in>set vs. C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n     \\<Longrightarrow> \\<forall>v'\\<in>set vs'. C_normal\\<^sub>M\\<^sub>L v')", "apply(induct rule:Red_ml_Red_ml_list.inducts)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>u v.\n       C_normal\\<^sub>M\\<^sub>L\n        (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L (u[v/0])\n 2. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        C_normal\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 3. \\<And>\\<sigma> vs arity nm vs'.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        C_normal\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs')\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> (C\\<^sub>U nm vs))\n 4. \\<And>f vs v.\n       C_normal\\<^sub>M\\<^sub>L\n        (apply (Clo f vs (Suc 0)) v) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L f (v # vs))\n 5. \\<And>n f vs v.\n       \\<lbrakk>0 < n;\n        C_normal\\<^sub>M\\<^sub>L (apply (Clo f vs (Suc n)) v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (Clo f (v # vs) n)\n 6. \\<And>nm vs v.\n       C_normal\\<^sub>M\\<^sub>L\n        (apply (C\\<^sub>U nm vs) v) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm (v # vs))\n 7. \\<And>x vs v.\n       C_normal\\<^sub>M\\<^sub>L (apply (V\\<^sub>U x vs) v) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x (v # vs))\n 8. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) C_normal\\<^sub>M\\<^sub>L \\<Longrightarrow>\n        Ball (set vs') C_normal\\<^sub>M\\<^sub>L;\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs')\n 9. \\<And>vs vs' x.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        Ball (set vs) C_normal\\<^sub>M\\<^sub>L \\<Longrightarrow>\n        Ball (set vs') C_normal\\<^sub>M\\<^sub>L;\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs')\n 10. \\<And>f f' vs n.\n        \\<lbrakk>f \\<Rightarrow> f';\n         C_normal\\<^sub>M\\<^sub>L f \\<Longrightarrow>\n         C_normal\\<^sub>M\\<^sub>L f';\n         C_normal\\<^sub>M\\<^sub>L (Clo f vs n)\\<rbrakk>\n        \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (Clo f' vs n)\nA total of 17 subgoals...", "apply(simp_all add: C_normal_ML_subst_ML_iff)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nm vs v \\<sigma>.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        \\<forall>x\\<in>set vs.\n           C_normal\\<^sub>M\\<^sub>L\n            (subst\\<^sub>M\\<^sub>L \\<sigma> x)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v)\n 2. \\<And>nm vs v.\n       Ball (set vs) C_normal\\<^sub>M\\<^sub>L \\<and>\n       no_match_compR nm vs \\<and>\n       C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n       no_match_compR nm (v # vs)\n 3. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<forall>x\\<in>set vs'. C_normal\\<^sub>M\\<^sub>L x;\n        (\\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x) \\<and>\n        no_match_compR nm vs\\<rbrakk>\n       \\<Longrightarrow> no_match_compR nm vs'", "apply(metis C_normal_ML_subst_ML C_normal_compR_rhs\n        fv_compR C_normal_ML_subst_ML_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm vs v.\n       Ball (set vs) C_normal\\<^sub>M\\<^sub>L \\<and>\n       no_match_compR nm vs \\<and>\n       C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n       no_match_compR nm (v # vs)\n 2. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<forall>x\\<in>set vs'. C_normal\\<^sub>M\\<^sub>L x;\n        (\\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x) \\<and>\n        no_match_compR nm vs\\<rbrakk>\n       \\<Longrightarrow> no_match_compR nm vs'", "apply(blast intro!:no_match_compR_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs vs' nm.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<forall>x\\<in>set vs'. C_normal\\<^sub>M\\<^sub>L x;\n        (\\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x) \\<and>\n        no_match_compR nm vs\\<rbrakk>\n       \\<Longrightarrow> no_match_compR nm vs'", "apply(blast dest:Red_ml_list_pres_no_match)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Red_term_hnf_induct[consumes 1]:\nassumes \"(t::tm) \\<Rightarrow> t'\"\n  \"\\<And>nm vs ts. P ((term (C\\<^sub>U nm vs)) \\<bullet>\\<bullet> ts) ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts)\"\n  \"\\<And>x vs ts. P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts) ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts)\"\n  \"\\<And>vf vs n ts.\n    P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n     ((\\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))) \\<bullet>\\<bullet> ts)\"\n  \"\\<And>t t' ts. \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk> \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts) (\\<Lambda> t' \\<bullet>\\<bullet> ts)\"\n  \"\\<And>v v' ts. v \\<Rightarrow> v' \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts)\"\n  \"\\<And>x i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (V x  \\<bullet>\\<bullet> ts) (V x \\<bullet>\\<bullet> ts[i:=t'])\"\n  \"\\<And>nm i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (C nm  \\<bullet>\\<bullet> ts) (C nm \\<bullet>\\<bullet> ts[i:=t'])\"\n  \"\\<And>t i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts) (\\<Lambda> t \\<bullet>\\<bullet> ts[i:=t'])\"\n  \"\\<And>v i t' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> t' \\<Longrightarrow> P (ts!i) (t')\n    \\<Longrightarrow> P (term v  \\<bullet>\\<bullet> ts) (term v \\<bullet>\\<bullet> (ts[i:=t']))\"\nshows \"P t t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P t t'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P t t'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. P t t'", "fix ts"], ["proof (state)\ngoal (1 subgoal):\n 1. P t t'", "from assms"], ["proof (chain)\npicking this:\n  t \\<Rightarrow> t'\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])", "have \"P (t \\<bullet>\\<bullet> ts) (t' \\<bullet>\\<bullet> ts)\""], ["proof (prove)\nusing this:\n  t \\<Rightarrow> t'\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (t \\<bullet>\\<bullet> ts) (t' \\<bullet>\\<bullet> ts)", "proof(induct arbitrary: ts rule:Red_term.induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>nm vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                          ((C nm \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>x vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                          ((V x \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 4. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 5. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 6. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 7. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "case term_C"], ["proof (state)\nthis:\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (7 subgoals):\n 1. \\<And>nm vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                          ((C nm \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>x vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                          ((V x \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 4. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 5. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 6. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 7. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "thus ?case"], ["proof (prove)\nusing this:\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (term (C\\<^sub>U nm_ vs_) \\<bullet>\\<bullet> ts)\n     ((C nm_ \\<bullet>\\<bullet> map term (rev vs_)) \\<bullet>\\<bullet> ts)", "by metis"], ["proof (state)\nthis:\n  P (term (C\\<^sub>U nm_ vs_) \\<bullet>\\<bullet> ts)\n   ((C nm_ \\<bullet>\\<bullet> map term (rev vs_)) \\<bullet>\\<bullet> ts)\n\ngoal (6 subgoals):\n 1. \\<And>x vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                          ((V x \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 3. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 4. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 5. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 6. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                          ((V x \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 3. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 4. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 5. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 6. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "case term_V"], ["proof (state)\nthis:\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (6 subgoals):\n 1. \\<And>x vs ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                          ((V x \\<bullet>\\<bullet>\n                            map term (rev vs)) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 3. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 4. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 5. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 6. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "thus ?case"], ["proof (prove)\nusing this:\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (term (V\\<^sub>U x_ vs_) \\<bullet>\\<bullet> ts)\n     ((V x_ \\<bullet>\\<bullet> map term (rev vs_)) \\<bullet>\\<bullet> ts)", "by metis"], ["proof (state)\nthis:\n  P (term (V\\<^sub>U x_ vs_) \\<bullet>\\<bullet> ts)\n   ((V x_ \\<bullet>\\<bullet> map term (rev vs_)) \\<bullet>\\<bullet> ts)\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 3. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 4. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 5. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 3. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 4. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 5. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "case term_Clo"], ["proof (state)\nthis:\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (5 subgoals):\n 1. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vs ts.\n                   P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                    ((C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                          (\\<Lambda>\n                            (term\n                              (apply (lift 0 (Clo vf vs n))\n                                (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                           ts)\n 2. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 3. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 4. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 5. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "thus ?case"], ["proof (prove)\nusing this:\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (term (Clo vf_ vs_ n_) \\<bullet>\\<bullet> ts)\n     (\\<Lambda>\n       (term\n         (apply (lift 0 (Clo vf_ vs_ n_))\n           (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n      ts)", "by metis"], ["proof (state)\nthis:\n  P (term (Clo vf_ vs_ n_) \\<bullet>\\<bullet> ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo vf_ vs_ n_))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ts)\n\ngoal (4 subgoals):\n 1. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 3. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 4. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 3. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 4. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "case ctxt_Lam"], ["proof (state)\nthis:\n  t_ \\<Rightarrow> t'_\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t_ \\<bullet>\\<bullet> ?ts)\n                     (t'_ \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (4 subgoals):\n 1. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 3. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 4. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "thus ?case"], ["proof (prove)\nusing this:\n  t_ \\<Rightarrow> t'_\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t_ \\<bullet>\\<bullet> ?ts)\n                     (t'_ \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (\\<Lambda> t_ \\<bullet>\\<bullet> ts)\n     (\\<Lambda> t'_ \\<bullet>\\<bullet> ts)", "by simp (metis foldl_Nil)"], ["proof (state)\nthis:\n  P (\\<Lambda> t_ \\<bullet>\\<bullet> ts)\n   (\\<Lambda> t'_ \\<bullet>\\<bullet> ts)\n\ngoal (3 subgoals):\n 1. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 2. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 3. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 2. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 3. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "case (ctxt_At1 s s' t ts)"], ["proof (state)\nthis:\n  s \\<Rightarrow> s'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (s \\<bullet>\\<bullet> ?ts) (s' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (3 subgoals):\n 1. \\<And>s s' t ts.\n       \\<lbrakk>s \\<Rightarrow> s';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (s \\<bullet>\\<bullet> ts)\n                              (s' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n 2. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 3. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<Rightarrow> s'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (s \\<bullet>\\<bullet> ?ts) (s' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s' \\<bullet> t \\<bullet>\\<bullet> ts)", "using ctxt_At1(2)[of \"t#ts\"]"], ["proof (prove)\nusing this:\n  s \\<Rightarrow> s'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (s \\<bullet>\\<bullet> ?ts) (s' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (s \\<bullet>\\<bullet> (t # ts))\n                     (s' \\<bullet>\\<bullet> (t # ts))\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s' \\<bullet> t \\<bullet>\\<bullet> ts)", "by simp"], ["proof (state)\nthis:\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s' \\<bullet> t \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "case (ctxt_At2 t t' s ts)"], ["proof (state)\nthis:\n  t \\<Rightarrow> t'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t \\<bullet>\\<bullet> ?ts) (t' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "{"], ["proof (state)\nthis:\n  t \\<Rightarrow> t'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t \\<bullet>\\<bullet> ?ts) (t' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "fix n rs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "assume \"s = V n \\<bullet>\\<bullet> rs\""], ["proof (state)\nthis:\n  s = V n \\<bullet>\\<bullet> rs\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "hence ?case"], ["proof (prove)\nusing this:\n  s = V n \\<bullet>\\<bullet> rs\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "using ctxt_At2(8)[of \"size rs\" \"rs @ t # ts\" t' n] ctxt_At2"], ["proof (prove)\nusing this:\n  s = V n \\<bullet>\\<bullet> rs\n  \\<lbrakk>length rs < length (rs @ t # ts);\n   (rs @ t # ts) ! length rs \\<Rightarrow> t';\n   P ((rs @ t # ts) ! length rs) t'\\<rbrakk>\n  \\<Longrightarrow> P (V n \\<bullet>\\<bullet> (rs @ t # ts))\n                     (V n \\<bullet>\\<bullet> (rs @ t # ts)[length rs := t'])\n  t \\<Rightarrow> t'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t \\<bullet>\\<bullet> ?ts) (t' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "by simp (metis foldl_Nil)"], ["proof (state)\nthis:\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "}"], ["proof (state)\nthis:\n  s = V ?n2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "moreover"], ["proof (state)\nthis:\n  s = V ?n2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "{"], ["proof (state)\nthis:\n  s = V ?n2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "fix nm rs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "assume \"s = C nm \\<bullet>\\<bullet> rs\""], ["proof (state)\nthis:\n  s = C nm \\<bullet>\\<bullet> rs\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "hence ?case"], ["proof (prove)\nusing this:\n  s = C nm \\<bullet>\\<bullet> rs\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "using ctxt_At2(9)[of \"size rs\" \"rs @ t # ts\" t' nm] ctxt_At2"], ["proof (prove)\nusing this:\n  s = C nm \\<bullet>\\<bullet> rs\n  \\<lbrakk>length rs < length (rs @ t # ts);\n   (rs @ t # ts) ! length rs \\<Rightarrow> t';\n   P ((rs @ t # ts) ! length rs) t'\\<rbrakk>\n  \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> (rs @ t # ts))\n                     (C nm \\<bullet>\\<bullet> (rs @ t # ts)\n                      [length rs := t'])\n  t \\<Rightarrow> t'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t \\<bullet>\\<bullet> ?ts) (t' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "by simp (metis foldl_Nil)"], ["proof (state)\nthis:\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "}"], ["proof (state)\nthis:\n  s = C ?nm2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "moreover"], ["proof (state)\nthis:\n  s = C ?nm2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "{"], ["proof (state)\nthis:\n  s = C ?nm2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "fix r rs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "assume \"s = \\<Lambda> r \\<bullet>\\<bullet> rs\""], ["proof (state)\nthis:\n  s = \\<Lambda> r \\<bullet>\\<bullet> rs\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "hence ?case"], ["proof (prove)\nusing this:\n  s = \\<Lambda> r \\<bullet>\\<bullet> rs\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "using ctxt_At2(10)[of \"size rs\" \"rs @ t # ts\" t'] ctxt_At2"], ["proof (prove)\nusing this:\n  s = \\<Lambda> r \\<bullet>\\<bullet> rs\n  \\<lbrakk>length rs < length (rs @ t # ts);\n   (rs @ t # ts) ! length rs \\<Rightarrow> t';\n   P ((rs @ t # ts) ! length rs) t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> (rs @ t # ts))\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> (rs @ t # ts)\n                      [length rs := t'])\n  t \\<Rightarrow> t'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t \\<bullet>\\<bullet> ?ts) (t' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "by simp (metis foldl_Nil)"], ["proof (state)\nthis:\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "}"], ["proof (state)\nthis:\n  s = \\<Lambda> ?r2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "moreover"], ["proof (state)\nthis:\n  s = \\<Lambda> ?r2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "{"], ["proof (state)\nthis:\n  s = \\<Lambda> ?r2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "fix v rs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "assume \"s = term v \\<bullet>\\<bullet> rs\""], ["proof (state)\nthis:\n  s = term v \\<bullet>\\<bullet> rs\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "hence ?case"], ["proof (prove)\nusing this:\n  s = term v \\<bullet>\\<bullet> rs\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "using ctxt_At2(11)[of \"size rs\" \"rs @ t # ts\" t'] ctxt_At2"], ["proof (prove)\nusing this:\n  s = term v \\<bullet>\\<bullet> rs\n  \\<lbrakk>length rs < length (rs @ t # ts);\n   (rs @ t # ts) ! length rs \\<Rightarrow> t';\n   P ((rs @ t # ts) ! length rs) t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> (rs @ t # ts))\n                     (term ?v \\<bullet>\\<bullet> (rs @ t # ts)\n                      [length rs := t'])\n  t \\<Rightarrow> t'\n  \\<lbrakk>\\<And>nm vs ts.\n              P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts);\n   \\<And>x vs ts.\n      P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n       ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts);\n   \\<And>vf vs n ts.\n      P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n       (\\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts);\n   \\<And>t t' ts.\n      \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n   \\<And>v v' ts.\n      v \\<Rightarrow> v' \\<Longrightarrow>\n      P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n   \\<And>i ts t' x.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                         (V x \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' nm.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                         (C nm \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' t.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                         (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n   \\<And>i ts t' v.\n      \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n       P (ts ! i) t'\\<rbrakk>\n      \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                         (term v \\<bullet>\\<bullet> ts[i := t'])\\<rbrakk>\n  \\<Longrightarrow> P (t \\<bullet>\\<bullet> ?ts) (t' \\<bullet>\\<bullet> ?ts)\n  P (term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts)\n   ((C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts)\n   ((V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet> ?ts)\n  P (term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts)\n   (\\<Lambda>\n     (term\n       (apply (lift 0 (Clo ?vf ?vs ?n))\n         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n    ?ts)\n  \\<lbrakk>?t \\<Rightarrow> ?t'; P ?t ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t' \\<bullet>\\<bullet> ?ts)\n  ?v \\<Rightarrow> ?v' \\<Longrightarrow>\n  P (term ?v \\<bullet>\\<bullet> ?ts) (term ?v' \\<bullet>\\<bullet> ?ts)\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (V ?x \\<bullet>\\<bullet> ?ts)\n                     (V ?x \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (C ?nm \\<bullet>\\<bullet> ?ts)\n                     (C ?nm \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts)\n                     (\\<Lambda> ?t \\<bullet>\\<bullet> ?ts[?i := ?t'])\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?t';\n   P (?ts ! ?i) ?t'\\<rbrakk>\n  \\<Longrightarrow> P (term ?v \\<bullet>\\<bullet> ?ts)\n                     (term ?v \\<bullet>\\<bullet> ?ts[?i := ?t'])\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "by simp (metis foldl_Nil)"], ["proof (state)\nthis:\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "}"], ["proof (state)\nthis:\n  s = term ?v2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>t t' s ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts.\n           \\<lbrakk>\\<And>nm vs ts.\n                       P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n                        ((C nm \\<bullet>\\<bullet>\n                          map term (rev vs)) \\<bullet>\\<bullet>\n                         ts);\n            \\<And>x vs ts.\n               P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n                ((V x \\<bullet>\\<bullet>\n                  map term (rev vs)) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>vf vs n ts.\n               P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n                (\\<Lambda>\n                  (term\n                    (apply (lift 0 (Clo vf vs n))\n                      (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                 ts);\n            \\<And>t t' ts.\n               \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n            \\<And>v v' ts.\n               v \\<Rightarrow> v' \\<Longrightarrow>\n               P (term v \\<bullet>\\<bullet> ts)\n                (term v' \\<bullet>\\<bullet> ts);\n            \\<And>i ts t' x.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                                  (V x \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' nm.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                                  (C nm \\<bullet>\\<bullet> ts[i := t']);\n            \\<And>i ts t' t.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                                  (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                   [i := t']);\n            \\<And>i ts t' v.\n               \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n                P (ts ! i) t'\\<rbrakk>\n               \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                                  (term v \\<bullet>\\<bullet> ts\n                                   [i := t'])\\<rbrakk>\n           \\<Longrightarrow> P (t \\<bullet>\\<bullet> ts)\n                              (t' \\<bullet>\\<bullet> ts);\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n                          (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n 2. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "ultimately"], ["proof (chain)\npicking this:\n  s = V ?n2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = C ?nm2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = \\<Lambda> ?r2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = term ?v2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "show ?case"], ["proof (prove)\nusing this:\n  s = V ?n2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = C ?nm2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = \\<Lambda> ?r2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = term ?v2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "using tm_vector_cases[of s]"], ["proof (prove)\nusing this:\n  s = V ?n2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = C ?nm2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = \\<Lambda> ?r2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  s = term ?v2 \\<bullet>\\<bullet> ?rs2 \\<Longrightarrow>\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n  (\\<exists>n ts. s = V n \\<bullet>\\<bullet> ts) \\<or>\n  (\\<exists>nm ts. s = C nm \\<bullet>\\<bullet> ts) \\<or>\n  (\\<exists>t' ts. s = \\<Lambda> t' \\<bullet>\\<bullet> ts) \\<or>\n  (\\<exists>v ts. s = term v \\<bullet>\\<bullet> ts)\n\ngoal (1 subgoal):\n 1. P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n     (s \\<bullet> t' \\<bullet>\\<bullet> ts)", "by blast"], ["proof (state)\nthis:\n  P (s \\<bullet> t \\<bullet>\\<bullet> ts)\n   (s \\<bullet> t' \\<bullet>\\<bullet> ts)\n\ngoal (1 subgoal):\n 1. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs ts.\n           P (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)\n            ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>x vs ts.\n           P (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)\n            ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts);\n        \\<And>vf vs n ts.\n           P (term (Clo vf vs n) \\<bullet>\\<bullet> ts)\n            (\\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts);\n        \\<And>t t' ts.\n           \\<lbrakk>t \\<Rightarrow> t'; P t t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t' \\<bullet>\\<bullet> ts);\n        \\<And>v v' ts.\n           v \\<Rightarrow> v' \\<Longrightarrow>\n           P (term v \\<bullet>\\<bullet> ts) (term v' \\<bullet>\\<bullet> ts);\n        \\<And>i ts t' x.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (V x \\<bullet>\\<bullet> ts)\n                              (V x \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' nm.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (C nm \\<bullet>\\<bullet> ts)\n                              (C nm \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' t.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (\\<Lambda> t \\<bullet>\\<bullet> ts)\n                              (\\<Lambda> t \\<bullet>\\<bullet> ts[i := t']);\n        \\<And>i ts t' v.\n           \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n            P (ts ! i) t'\\<rbrakk>\n           \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                              (term v \\<bullet>\\<bullet> ts\n                               [i := t'])\\<rbrakk>\n       \\<Longrightarrow> P (term v \\<bullet>\\<bullet> ts)\n                          (term v' \\<bullet>\\<bullet> ts)", "qed"], ["proof (state)\nthis:\n  P (t \\<bullet>\\<bullet> ts) (t' \\<bullet>\\<bullet> ts)\n\ngoal (1 subgoal):\n 1. P t t'", "}"], ["proof (state)\nthis:\n  P (t \\<bullet>\\<bullet> ?ts2) (t' \\<bullet>\\<bullet> ?ts2)\n\ngoal (1 subgoal):\n 1. P t t'", "from this[of \"[]\"]"], ["proof (chain)\npicking this:\n  P (t \\<bullet>\\<bullet> []) (t' \\<bullet>\\<bullet> [])", "show ?thesis"], ["proof (prove)\nusing this:\n  P (t \\<bullet>\\<bullet> []) (t' \\<bullet>\\<bullet> [])\n\ngoal (1 subgoal):\n 1. P t t'", "by simp"], ["proof (state)\nthis:\n  P t t'\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Red_term_hnf_cases[consumes 1]:\nassumes \"(t::tm) \\<Rightarrow> t'\"\n  \"\\<And>nm vs ts.\n  t = term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts \\<Longrightarrow> P\"\n  \"\\<And>x vs ts.\n  t = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet> ts \\<Longrightarrow> P\"\n  \"\\<And>vf vs n ts. t = term (Clo vf vs n) \\<bullet>\\<bullet> ts \\<Longrightarrow>\n     t' = \\<Lambda> (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 []))) \\<bullet>\\<bullet> ts \\<Longrightarrow> P\"\n  \"\\<And>s s' ts. t = \\<Lambda> s \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = \\<Lambda> s' \\<bullet>\\<bullet> ts \\<Longrightarrow> s \\<Rightarrow> s' \\<Longrightarrow> P\"\n  \"\\<And>v v' ts. t = term v \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = term v' \\<bullet>\\<bullet> ts \\<Longrightarrow> v \\<Rightarrow> v' \\<Longrightarrow> P\"\n  \"\\<And>x i r' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> r'\n    \\<Longrightarrow> t = V x  \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = V x \\<bullet>\\<bullet> ts[i:=r'] \\<Longrightarrow> P\"\n  \"\\<And>nm i r' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> r'\n    \\<Longrightarrow> t = C nm  \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = C nm \\<bullet>\\<bullet> ts[i:=r'] \\<Longrightarrow> P\"\n  \"\\<And>s i r' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> r'\n    \\<Longrightarrow> t = \\<Lambda> s \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i:=r'] \\<Longrightarrow> P\"\n  \"\\<And>v i r' ts. i<size ts \\<Longrightarrow> ts!i \\<Rightarrow> r'\n    \\<Longrightarrow> t = term v  \\<bullet>\\<bullet> ts \\<Longrightarrow> t' = term v \\<bullet>\\<bullet> (ts[i:=r']) \\<Longrightarrow> P\"\nshows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  t \\<Rightarrow> t'\n  \\<lbrakk>t = term (C\\<^sub>U ?nm ?vs) \\<bullet>\\<bullet> ?ts;\n   t' =\n   (C ?nm \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet>\n   ?ts\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>t = term (V\\<^sub>U ?x ?vs) \\<bullet>\\<bullet> ?ts;\n   t' =\n   (V ?x \\<bullet>\\<bullet> map term (rev ?vs)) \\<bullet>\\<bullet>\n   ?ts\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>t = term (Clo ?vf ?vs ?n) \\<bullet>\\<bullet> ?ts;\n   t' =\n   \\<Lambda>\n    (term\n      (apply (lift 0 (Clo ?vf ?vs ?n)) (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n   ?ts\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>t = \\<Lambda> ?s \\<bullet>\\<bullet> ?ts;\n   t' = \\<Lambda> ?s' \\<bullet>\\<bullet> ?ts; ?s \\<Rightarrow> ?s'\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>t = term ?v \\<bullet>\\<bullet> ?ts;\n   t' = term ?v' \\<bullet>\\<bullet> ?ts; ?v \\<Rightarrow> ?v'\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?r';\n   t = V ?x \\<bullet>\\<bullet> ?ts;\n   t' = V ?x \\<bullet>\\<bullet> ?ts[?i := ?r']\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?r';\n   t = C ?nm \\<bullet>\\<bullet> ?ts;\n   t' = C ?nm \\<bullet>\\<bullet> ?ts[?i := ?r']\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?r';\n   t = \\<Lambda> ?s \\<bullet>\\<bullet> ?ts;\n   t' = \\<Lambda> ?s \\<bullet>\\<bullet> ?ts[?i := ?r']\\<rbrakk>\n  \\<Longrightarrow> P\n  \\<lbrakk>?i < length ?ts; ?ts ! ?i \\<Rightarrow> ?r';\n   t = term ?v \\<bullet>\\<bullet> ?ts;\n   t' = term ?v \\<bullet>\\<bullet> ?ts[?i := ?r']\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<Rightarrow> t';\n     \\<And>nm vs ts.\n        \\<lbrakk>t = term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts;\n         t' =\n         (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n         ts\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>x vs ts.\n        \\<lbrakk>t = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n         t' =\n         (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n         ts\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>vf vs n ts.\n        \\<lbrakk>t = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n         t' =\n         \\<Lambda>\n          (term\n            (apply (lift 0 (Clo vf vs n))\n              (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n         ts\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>s ts s'.\n        \\<lbrakk>t = \\<Lambda> s \\<bullet>\\<bullet> ts;\n         t' = \\<Lambda> s' \\<bullet>\\<bullet> ts;\n         s \\<Rightarrow> s'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>v ts v'.\n        \\<lbrakk>t = term v \\<bullet>\\<bullet> ts;\n         t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i ts r' x.\n        \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n         t = V x \\<bullet>\\<bullet> ts;\n         t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i ts r' nm.\n        \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n         t = C nm \\<bullet>\\<bullet> ts;\n         t' = C nm \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i ts r' s.\n        \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n         t = \\<Lambda> s \\<bullet>\\<bullet> ts;\n         t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<And>i ts r' v.\n        \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n         t = term v \\<bullet>\\<bullet> ts;\n         t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply(induct rule:Red_term_hnf_induct)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>nm vs ts.\n       \\<lbrakk>\\<And>nma vsa tsa.\n                   \\<lbrakk>term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n                            term (C\\<^sub>U nma vsa) \\<bullet>\\<bullet> tsa;\n                    (C nm \\<bullet>\\<bullet>\n                     map term (rev vs)) \\<bullet>\\<bullet>\n                    ts =\n                    (C nma \\<bullet>\\<bullet>\n                     map term (rev vsa)) \\<bullet>\\<bullet>\n                    tsa\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>x vsa tsa.\n           \\<lbrakk>term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vsa) \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            (V x \\<bullet>\\<bullet> map term (rev vsa)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vsa n tsa.\n           \\<lbrakk>term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n                    term (Clo vf vsa n) \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vsa n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' x.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n            V x \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            V x \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' nma.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n            C nma \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            C nma \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' s.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' v.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts =\n            term v \\<bullet>\\<bullet> tsa;\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            term v \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>x vs ts.\n       \\<lbrakk>\\<And>nm vsa tsa.\n                   \\<lbrakk>term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n                            term (C\\<^sub>U nm vsa) \\<bullet>\\<bullet> tsa;\n                    (V x \\<bullet>\\<bullet>\n                     map term (rev vs)) \\<bullet>\\<bullet>\n                    ts =\n                    (C nm \\<bullet>\\<bullet>\n                     map term (rev vsa)) \\<bullet>\\<bullet>\n                    tsa\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>xa vsa tsa.\n           \\<lbrakk>term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U xa vsa) \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            (V xa \\<bullet>\\<bullet> map term (rev vsa)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vsa n tsa.\n           \\<lbrakk>term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n                    term (Clo vf vsa n) \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vsa n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' xa.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n            V xa \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            V xa \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' nm.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n            C nm \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            C nm \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' s.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' v.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts =\n            term v \\<bullet>\\<bullet> tsa;\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            ts =\n            term v \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>\\<And>nm vsa tsa.\n                   \\<lbrakk>term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n                            term (C\\<^sub>U nm vsa) \\<bullet>\\<bullet> tsa;\n                    \\<Lambda>\n                     (term\n                       (apply (lift 0 (Clo vf vs n))\n                         (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                    ts =\n                    (C nm \\<bullet>\\<bullet>\n                     map term (rev vsa)) \\<bullet>\\<bullet>\n                    tsa\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>x vsa tsa.\n           \\<lbrakk>term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vsa) \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            (V x \\<bullet>\\<bullet> map term (rev vsa)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vfa vsa na tsa.\n           \\<lbrakk>term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n                    term (Clo vfa vsa na) \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vfa vsa na))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' x.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n            V x \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            V x \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' nm.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n            C nm \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            C nm \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' s.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' v.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term (Clo vf vs n) \\<bullet>\\<bullet> ts =\n            term v \\<bullet>\\<bullet> tsa;\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            ts =\n            term v \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>t t' ts.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<lbrakk>\\<And>nm vs ts.\n                    \\<lbrakk>t =\n                             term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts;\n                     t' =\n                     (C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     ts\\<rbrakk>\n                    \\<Longrightarrow> P;\n         \\<And>x vs ts.\n            \\<lbrakk>t = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n             t' =\n             (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             ts\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>vf vs n ts.\n            \\<lbrakk>t = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n             t' =\n             \\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             ts\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>s ts s'.\n            \\<lbrakk>t = \\<Lambda> s \\<bullet>\\<bullet> ts;\n             t' = \\<Lambda> s' \\<bullet>\\<bullet> ts;\n             s \\<Rightarrow> s'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>v ts v'.\n            \\<lbrakk>t = term v \\<bullet>\\<bullet> ts;\n             t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>i ts r' x.\n            \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n             t = V x \\<bullet>\\<bullet> ts;\n             t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>i ts r' nm.\n            \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n             t = C nm \\<bullet>\\<bullet> ts;\n             t' = C nm \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>i ts r' s.\n            \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n             t = \\<Lambda> s \\<bullet>\\<bullet> ts;\n             t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>i ts r' v.\n            \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n             t = term v \\<bullet>\\<bullet> ts;\n             t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<And>nm vs tsa.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x vs tsa.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vs n tsa.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' x.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts = V x \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            V x \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' nm.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts = C nm \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            C nm \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' s.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' v.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts =\n            term v \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t' \\<bullet>\\<bullet> ts =\n            term v \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 5. \\<And>v v' ts.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm vs tsa.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x vs tsa.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vs n tsa.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>va tsa v'a.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term va \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts = term v'a \\<bullet>\\<bullet> tsa;\n            va \\<Rightarrow> v'a\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' x.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts = V x \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            V x \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' nm.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts = C nm \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            C nm \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' s.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>i tsa r' va.\n           \\<lbrakk>i < length tsa; tsa ! i \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts = term va \\<bullet>\\<bullet> tsa;\n            term v' \\<bullet>\\<bullet> ts =\n            term va \\<bullet>\\<bullet> tsa[i := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 6. \\<And>x i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<lbrakk>\\<And>nm vs tsa.\n                    \\<lbrakk>ts ! i =\n                             term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n                     t' =\n                     (C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     tsa\\<rbrakk>\n                    \\<Longrightarrow> P;\n         \\<And>x vs tsa.\n            \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n             t' =\n             (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>vf vs n tsa.\n            \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n             t' =\n             \\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>s tsa s'.\n            \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n             s \\<Rightarrow> s'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>v tsa v'.\n            \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v' \\<bullet>\\<bullet> tsa;\n             v \\<Rightarrow> v'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' x.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = V x \\<bullet>\\<bullet> tsa;\n             t' = V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' nm.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = C nm \\<bullet>\\<bullet> tsa;\n             t' = C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' s.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' v.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<And>nm vs tsa.\n           \\<lbrakk>V x \\<bullet>\\<bullet> ts =\n                    term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>xa vs tsa.\n           \\<lbrakk>V x \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U xa vs) \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            (V xa \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vs n tsa.\n           \\<lbrakk>V x \\<bullet>\\<bullet> ts =\n                    term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>V x \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>V x \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' xa.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            V x \\<bullet>\\<bullet> ts = V xa \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            V xa \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' nm.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            V x \\<bullet>\\<bullet> ts = C nm \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' s.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            V x \\<bullet>\\<bullet> ts = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' v.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            V x \\<bullet>\\<bullet> ts = term v \\<bullet>\\<bullet> tsa;\n            V x \\<bullet>\\<bullet> ts[i := t'] =\n            term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 7. \\<And>nm i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<lbrakk>\\<And>nm vs tsa.\n                    \\<lbrakk>ts ! i =\n                             term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n                     t' =\n                     (C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     tsa\\<rbrakk>\n                    \\<Longrightarrow> P;\n         \\<And>x vs tsa.\n            \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n             t' =\n             (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>vf vs n tsa.\n            \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n             t' =\n             \\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>s tsa s'.\n            \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n             s \\<Rightarrow> s'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>v tsa v'.\n            \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v' \\<bullet>\\<bullet> tsa;\n             v \\<Rightarrow> v'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' x.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = V x \\<bullet>\\<bullet> tsa;\n             t' = V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' nm.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = C nm \\<bullet>\\<bullet> tsa;\n             t' = C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' s.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' v.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<And>nma vs tsa.\n           \\<lbrakk>C nm \\<bullet>\\<bullet> ts =\n                    term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x vs tsa.\n           \\<lbrakk>C nm \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vs n tsa.\n           \\<lbrakk>C nm \\<bullet>\\<bullet> ts =\n                    term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>C nm \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>C nm \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' x.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            C nm \\<bullet>\\<bullet> ts = V x \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' nma.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            C nm \\<bullet>\\<bullet> ts = C nma \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            C nma \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' s.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            C nm \\<bullet>\\<bullet> ts = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' v.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            C nm \\<bullet>\\<bullet> ts = term v \\<bullet>\\<bullet> tsa;\n            C nm \\<bullet>\\<bullet> ts[i := t'] =\n            term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 8. \\<And>t i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<lbrakk>\\<And>nm vs tsa.\n                    \\<lbrakk>ts ! i =\n                             term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n                     t' =\n                     (C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     tsa\\<rbrakk>\n                    \\<Longrightarrow> P;\n         \\<And>x vs tsa.\n            \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n             t' =\n             (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>vf vs n tsa.\n            \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n             t' =\n             \\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>s tsa s'.\n            \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n             s \\<Rightarrow> s'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>v tsa v'.\n            \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v' \\<bullet>\\<bullet> tsa;\n             v \\<Rightarrow> v'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' x.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = V x \\<bullet>\\<bullet> tsa;\n             t' = V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' nm.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = C nm \\<bullet>\\<bullet> tsa;\n             t' = C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' s.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' v.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<And>nm vs tsa.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x vs tsa.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vs n tsa.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>v tsa v'.\n           \\<lbrakk>\\<Lambda> t \\<bullet>\\<bullet> ts =\n                    term v \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            term v' \\<bullet>\\<bullet> tsa;\n            v \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' x.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts = V x \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' nm.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts = C nm \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' s.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' v.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            \\<Lambda> t \\<bullet>\\<bullet> ts =\n            term v \\<bullet>\\<bullet> tsa;\n            \\<Lambda> t \\<bullet>\\<bullet> ts[i := t'] =\n            term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 9. \\<And>v i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<lbrakk>\\<And>nm vs tsa.\n                    \\<lbrakk>ts ! i =\n                             term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n                     t' =\n                     (C nm \\<bullet>\\<bullet>\n                      map term (rev vs)) \\<bullet>\\<bullet>\n                     tsa\\<rbrakk>\n                    \\<Longrightarrow> P;\n         \\<And>x vs tsa.\n            \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n             t' =\n             (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>vf vs n tsa.\n            \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n             t' =\n             \\<Lambda>\n              (term\n                (apply (lift 0 (Clo vf vs n))\n                  (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n             tsa\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>s tsa s'.\n            \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n             s \\<Rightarrow> s'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>v tsa v'.\n            \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v' \\<bullet>\\<bullet> tsa;\n             v \\<Rightarrow> v'\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' x.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = V x \\<bullet>\\<bullet> tsa;\n             t' = V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' nm.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = C nm \\<bullet>\\<bullet> tsa;\n             t' = C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' s.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = \\<Lambda> s \\<bullet>\\<bullet> tsa;\n             t' = \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P;\n         \\<And>ia tsa r' v.\n            \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n             ts ! i = term v \\<bullet>\\<bullet> tsa;\n             t' = term v \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n            \\<Longrightarrow> P\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<And>nm vs tsa.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            (C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>x vs tsa.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term (V\\<^sub>U x vs) \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>vf vs n tsa.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term (Clo vf vs n) \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda>\n             (term\n               (apply (lift 0 (Clo vf vs n))\n                 (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n            tsa\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>s tsa s'.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s' \\<bullet>\\<bullet> tsa;\n            s \\<Rightarrow> s'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>va tsa v'.\n           \\<lbrakk>term v \\<bullet>\\<bullet> ts =\n                    term va \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            term v' \\<bullet>\\<bullet> tsa;\n            va \\<Rightarrow> v'\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' x.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts = V x \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            V x \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' nm.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts = C nm \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            C nm \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' s.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            \\<Lambda> s \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<And>ia tsa r' va.\n           \\<lbrakk>ia < length tsa; tsa ! ia \\<Rightarrow> r';\n            term v \\<bullet>\\<bullet> ts = term va \\<bullet>\\<bullet> tsa;\n            term v \\<bullet>\\<bullet> ts[i := t'] =\n            term va \\<bullet>\\<bullet> tsa[ia := r']\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply metis+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"C_normal(term v \\<bullet>\\<bullet> ts) \\<longleftrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<and> ts = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (term v \\<bullet>\\<bullet> ts) =\n    (C_normal\\<^sub>M\\<^sub>L v \\<and> ts = [])", "by(fastforce elim: C_normal.cases)"], ["", "lemma [simp]: \"C_normal(\\<Lambda> t \\<bullet>\\<bullet> ts) \\<longleftrightarrow> C_normal t \\<and> ts = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (\\<Lambda> t \\<bullet>\\<bullet> ts) =\n    (C_normal t \\<and> ts = [])", "by(fastforce elim: C_normal.cases)"], ["", "lemma [simp]: \"C_normal(C nm \\<bullet>\\<bullet> ts) \\<longleftrightarrow>\n  (\\<forall>t\\<in>set ts. C_normal t) \\<and> no_match_R nm (map dterm ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (C nm \\<bullet>\\<bullet> ts) =\n    ((\\<forall>t\\<in>set ts. C_normal t) \\<and>\n     no_match_R nm (map dterm ts))", "by(fastforce elim: C_normal.cases)"], ["", "lemma [simp]: \"C_normal(V x \\<bullet>\\<bullet> ts) \\<longleftrightarrow> (\\<forall>t \\<in> set ts. C_normal t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (V x \\<bullet>\\<bullet> ts) =\n    (\\<forall>t\\<in>set ts. C_normal t)", "by(fastforce elim: C_normal.cases)"], ["", "lemma no_match_ML_lift:\n  \"no_match\\<^sub>M\\<^sub>L ps vs \\<longrightarrow> no_match\\<^sub>M\\<^sub>L ps (map (lift k) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match\\<^sub>M\\<^sub>L ps vs \\<longrightarrow>\n    no_match\\<^sub>M\\<^sub>L ps (map (lift k) vs)", "apply(induct ps vs rule:no_match_ML.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       (\\<And>x xa xb xc xd.\n           \\<lbrakk>x < min (length os) (length ps);\n            rev ps ! x = C\\<^sub>U xa xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L xc\n                              (map (lift k) xd)) \\<Longrightarrow>\n       no_match\\<^sub>M\\<^sub>L ps os \\<longrightarrow>\n       no_match\\<^sub>M\\<^sub>L ps (map (lift k) os)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       (\\<And>x xa xb xc xd.\n           \\<lbrakk>x < length os \\<and> x < length ps;\n            rev ps ! x = C\\<^sub>U xb xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L xc\n                              (map (lift k) xd)) \\<Longrightarrow>\n       no_match\\<^sub>M\\<^sub>L ps os \\<longrightarrow>\n       no_match\\<^sub>M\\<^sub>L ps (map (lift k) os)", "apply(subst (1 2) no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os.\n       (\\<And>x xa xb xc xd.\n           \\<lbrakk>x < length os \\<and> x < length ps;\n            rev ps ! x = C\\<^sub>U xb xc; rev os ! x = C\\<^sub>U xb xd;\n            xa = xb\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\n                              xd \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L xc\n                              (map (lift k) xd)) \\<Longrightarrow>\n       (\\<exists>i<min (length os) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev os ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow>\n               no_match\\<^sub>M\\<^sub>L vs vs')) \\<longrightarrow>\n       (\\<exists>i<min (length (map (lift k) os)) (length ps).\n           \\<exists>nm nm' vs vs'.\n              rev ps ! i = C\\<^sub>U nm vs \\<and>\n              rev (map (lift k) os) ! i = C\\<^sub>U nm' vs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (lift k) xd);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length os.\n                            i < length ps \\<and>\n                            (\\<exists>nm nm' vs.\n                                rev ps ! i = C\\<^sub>U nm vs \\<and>\n                                (\\<exists>vs'.\n                                    rev (map (lift k) os) ! i =\n                                    C\\<^sub>U nm' vs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L vs vs')))", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (lift k) xd);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> i < length os \\<and>\n                         i < length ps \\<and>\n                         (\\<exists>nm nm' vs.\n                             rev ps ! i = C\\<^sub>U nm vs \\<and>\n                             (\\<exists>vs'.\n                                 rev (map (lift k) os) ! i =\n                                 C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vs vs')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (lift k) xd);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            rev (map (lift k) os) ! i =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=nm' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (lift k) xd);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs'.\n                            rev (map (lift k) os) ! i =\n                            C\\<^sub>U nm' vs' \\<and>\n                            (nm = nm' \\<longrightarrow>\n                             no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=\"map (lift k) vs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps os i nm nm' vs vs'.\n       \\<lbrakk>\\<And>x xa xb xc xd.\n                   \\<lbrakk>x < length os \\<and> x < length ps;\n                    rev ps ! x = C\\<^sub>U xb xc;\n                    rev os ! x = C\\<^sub>U xb xd; xa = xb\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L xc\nxd \\<longrightarrow>\n                                     no_match\\<^sub>M\\<^sub>L xc\n(map (lift k) xd);\n        i < length os; i < length ps; rev ps ! i = C\\<^sub>U nm vs;\n        rev os ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vs vs'\\<rbrakk>\n       \\<Longrightarrow> rev (map (lift k) os) ! i =\n                         C\\<^sub>U nm' (map (lift k) vs') \\<and>\n                         (nm = nm' \\<longrightarrow>\n                          no_match\\<^sub>M\\<^sub>L vs (map (lift k) vs'))", "apply (fastforce simp:rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_match_compR_lift:\n  \"no_match_compR nm vs \\<Longrightarrow> no_match_compR nm (map (lift k) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_compR nm vs \\<Longrightarrow>\n    no_match_compR nm (map (lift k) vs)", "by (fastforce simp: no_match_ML_lift)"], ["", "lemma [simp]: \"C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L(lift k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n    C_normal\\<^sub>M\\<^sub>L (lift k v)", "apply(induct v arbitrary:k rule:lift_ml.induct)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i nm k.\n       C_normal\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L (lift k (C\\<^sub>M\\<^sub>L nm))\n 2. \\<And>i X k.\n       C_normal\\<^sub>M\\<^sub>L (V\\<^sub>M\\<^sub>L X) \\<Longrightarrow>\n       C_normal\\<^sub>M\\<^sub>L (lift k (V\\<^sub>M\\<^sub>L X))\n 3. \\<And>i v vs k.\n       \\<lbrakk>\\<And>k.\n                   C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                   C_normal\\<^sub>M\\<^sub>L (lift k v);\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k x);\n        C_normal\\<^sub>M\\<^sub>L (A\\<^sub>M\\<^sub>L v vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (lift k (A\\<^sub>M\\<^sub>L v vs))\n 4. \\<And>i v k.\n       \\<lbrakk>\\<And>k.\n                   C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                   C_normal\\<^sub>M\\<^sub>L (lift k v);\n        C_normal\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L\n                          (lift k (Lam\\<^sub>M\\<^sub>L v))\n 5. \\<And>i nm vs k.\n       \\<lbrakk>\\<And>x k.\n                   \\<lbrakk>x \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k x);\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k (C\\<^sub>U nm vs))\n 6. \\<And>i x vs k.\n       \\<lbrakk>\\<And>xa k.\n                   \\<lbrakk>xa \\<in> set vs;\n                    C_normal\\<^sub>M\\<^sub>L xa\\<rbrakk>\n                   \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k xa);\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k (V\\<^sub>U x vs))\n 7. \\<And>i v vs n k.\n       \\<lbrakk>\\<And>k.\n                   C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n                   C_normal\\<^sub>M\\<^sub>L (lift k v);\n        \\<And>x k.\n           \\<lbrakk>x \\<in> set vs; C_normal\\<^sub>M\\<^sub>L x\\<rbrakk>\n           \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k x);\n        C_normal\\<^sub>M\\<^sub>L (Clo v vs n)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k (Clo v vs n))\n 8. \\<And>i u v k.\n       \\<lbrakk>\\<And>k.\n                   C_normal\\<^sub>M\\<^sub>L u \\<Longrightarrow>\n                   C_normal\\<^sub>M\\<^sub>L (lift k u);\n        \\<And>k.\n           C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow>\n           C_normal\\<^sub>M\\<^sub>L (lift k v);\n        C_normal\\<^sub>M\\<^sub>L (apply u v)\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (lift k (apply u v))", "apply(simp_all add:no_match_compR_lift)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[simp_depth_limit = 10]]"], ["", "lemma Red_term_pres_no_match:\n  \"\\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t'; no_match ps dts; dts = (map dterm ts)\\<rbrakk>\n   \\<Longrightarrow> no_match ps (map dterm (ts[i := t']))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t'; no_match ps dts;\n     dts = map dterm ts\\<rbrakk>\n    \\<Longrightarrow> no_match ps (map dterm (ts[i := t']))", "proof(induct ps dts arbitrary: ts i t' rule:no_match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa i t'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa i t'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    i < length tsa; tsa ! i \\<Rightarrow> t';\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm (tsa[i := t']));\n        i < length tsa; tsa ! i \\<Rightarrow> t'; no_match ps ts;\n        ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm (tsa[i := t']))", "case (1 ps dts ts i t')"], ["proof (state)\nthis:\n  \\<lbrakk>?x < min (length dts) (length ps);\n   ps ! ?x = C ?xa \\<bullet>\\<bullet> ?xc;\n   dts ! ?x = C ?xb \\<bullet>\\<bullet> ?xd; ?xa = ?xb; ?i < length ?ts;\n   ?ts ! ?i \\<Rightarrow> ?t'; no_match ?xc ?xd;\n   ?xd = map dterm ?ts\\<rbrakk>\n  \\<Longrightarrow> no_match ?xc (map dterm (?ts[?i := ?t']))\n  i < length ts\n  ts ! i \\<Rightarrow> t'\n  no_match ps dts\n  dts = map dterm ts\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa i t'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa i t'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    i < length tsa; tsa ! i \\<Rightarrow> t';\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm (tsa[i := t']));\n        i < length tsa; tsa ! i \\<Rightarrow> t'; no_match ps ts;\n        ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm (tsa[i := t']))", "from \\<open>no_match ps dts\\<close> \\<open>dts = map dterm ts\\<close>"], ["proof (chain)\npicking this:\n  no_match ps dts\n  dts = map dterm ts", "obtain j nm nm' rs rs' where ob: \"j < size ts\" \"j < size ps\"\n    \"ps!j = C nm \\<bullet>\\<bullet> rs\" \"dterm (ts!j) = C nm' \\<bullet>\\<bullet> rs'\"\n    \"nm = nm' \\<longrightarrow> no_match rs rs'\""], ["proof (prove)\nusing this:\n  no_match ps dts\n  dts = map dterm ts\n\ngoal (1 subgoal):\n 1. (\\<And>j nm rs nm' rs'.\n        \\<lbrakk>j < length ts; j < length ps;\n         ps ! j = C nm \\<bullet>\\<bullet> rs;\n         dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n         nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) no_match.simps) fastforce"], ["proof (state)\nthis:\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa i t'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa i t'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    i < length tsa; tsa ! i \\<Rightarrow> t';\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm (tsa[i := t']));\n        i < length tsa; tsa ! i \\<Rightarrow> t'; no_match ps ts;\n        ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm (tsa[i := t']))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match ps (map dterm (ts[i := t']))", "proof (subst no_match.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "show \"\\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'. ps!k  = C nm \\<bullet>\\<bullet> rs \\<and>\n         map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n        (nm = nm' \\<longrightarrow> no_match rs rs')\"\n      (is \"\\<exists>k < ?m. ?P k\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "assume [simp]: \"j=i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "have \"\\<exists>rs'. dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and> (nm = nm' \\<longrightarrow> no_match rs rs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "using \\<open>ts ! i \\<Rightarrow> t'\\<close>"], ["proof (prove)\nusing this:\n  ts ! i \\<Rightarrow> t'\n\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "proof(cases rule:Red_term_hnf_cases)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>v v' ts.\n       \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 9. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "case (5 v v' ts'')"], ["proof (state)\nthis:\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v' \\<bullet>\\<bullet> ts''\n  v \\<Rightarrow> v'\n\ngoal (9 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>v v' ts.\n       \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 9. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "then"], ["proof (chain)\npicking this:\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v' \\<bullet>\\<bullet> ts''\n  v \\<Rightarrow> v'", "obtain vs where [simp]:\n            \"v = C\\<^sub>U nm' vs\" \"rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\""], ["proof (prove)\nusing this:\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v' \\<bullet>\\<bullet> ts''\n  v \\<Rightarrow> v'\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>v = C\\<^sub>U nm' vs;\n         rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ob"], ["proof (prove)\nusing this:\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v' \\<bullet>\\<bullet> ts''\n  v \\<Rightarrow> v'\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>v = C\\<^sub>U nm' vs;\n         rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases v) auto"], ["proof (state)\nthis:\n  v = C\\<^sub>U nm' vs\n  rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\n\ngoal (9 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>v v' ts.\n       \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 9. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "obtain vs' where [simp]: \"v' = C\\<^sub>U nm' vs'\" \"vs \\<Rightarrow> vs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        \\<lbrakk>v' = C\\<^sub>U nm' vs'; vs \\<Rightarrow> vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>v\\<Rightarrow>v'\\<close>"], ["proof (prove)\nusing this:\n  v \\<Rightarrow> v'\n\ngoal (1 subgoal):\n 1. (\\<And>vs'.\n        \\<lbrakk>v' = C\\<^sub>U nm' vs'; vs \\<Rightarrow> vs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(rule Red_ml.cases) auto"], ["proof (state)\nthis:\n  v' = C\\<^sub>U nm' vs'\n  vs \\<Rightarrow> vs'\n\ngoal (9 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>v v' ts.\n       \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 9. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "obtain v' k where [arith]: \"k<size vs\" and \"vs!k \\<Rightarrow> v'\"\n            and [simp]: \"vs' = vs[k := v']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v'.\n        \\<lbrakk>k < length vs; vs ! k \\<Rightarrow> v';\n         vs' = vs[k := v']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Red_ml_list_nth[OF \\<open>vs\\<Rightarrow>vs'\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>v' k.\n     k < length vs \\<and> vs ! k \\<Rightarrow> v' \\<and> vs' = vs[k := v']\n\ngoal (1 subgoal):\n 1. (\\<And>k v'.\n        \\<lbrakk>k < length vs; vs ! k \\<Rightarrow> v';\n         vs' = vs[k := v']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  k < length vs\n  vs ! k \\<Rightarrow> v'\n  vs' = vs[k := v']\n\ngoal (9 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>v v' ts.\n       \\<lbrakk>ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v' \\<bullet>\\<bullet> ts; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 9. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "show ?thesis (is \"\\<exists>rs'. ?P rs' \\<and> ?Q rs'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "let ?rs' = \"map dterm ((map term (rev vs) @ ts'')[(size vs - k - 1):=term v'])\""], ["proof (state)\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "have \"?P ?rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dterm t' =\n    C nm' \\<bullet>\\<bullet>\n    map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])", "using ob 5"], ["proof (prove)\nusing this:\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v'__ \\<bullet>\\<bullet> ts''\n  v \\<Rightarrow> v'__\n\ngoal (1 subgoal):\n 1. dterm t' =\n    C nm' \\<bullet>\\<bullet>\n    map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])", "by(simp add: list_update_append map_update[symmetric] rev_update)"], ["proof (state)\nthis:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "moreover"], ["proof (state)\nthis:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "have \"?Q ?rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nm = nm' \\<longrightarrow>\n    no_match rs\n     (map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nm = nm' \\<Longrightarrow>\n    no_match rs\n     (map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']))", "apply(rule \"1.hyps\"[OF _ ob(3)])"], ["proof (prove)\ngoal (7 subgoals):\n 1. nm = nm' \\<Longrightarrow> j < min (length dts) (length ps)\n 2. nm = nm' \\<Longrightarrow> dts ! j = C ?xb2 \\<bullet>\\<bullet> ?xd2\n 3. nm = nm' \\<Longrightarrow> nm = ?xb2\n 4. nm = nm' \\<Longrightarrow>\n    length vs - k - 1 < length (map term (rev vs) @ ts'')\n 5. nm = nm' \\<Longrightarrow>\n    (map term (rev vs) @ ts'') ! (length vs - k - 1) \\<Rightarrow> term v'\n 6. nm = nm' \\<Longrightarrow> no_match rs ?xd2\n 7. nm = nm' \\<Longrightarrow> ?xd2 = map dterm (map term (rev vs) @ ts'')", "using \"1.prems\" 5 ob"], ["proof (prove)\nusing this:\n  i < length ts\n  ts ! i \\<Rightarrow> t'\n  no_match ps dts\n  dts = map dterm ts\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v'__ \\<bullet>\\<bullet> ts''\n  v \\<Rightarrow> v'__\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (7 subgoals):\n 1. nm = nm' \\<Longrightarrow> j < min (length dts) (length ps)\n 2. nm = nm' \\<Longrightarrow> dts ! j = C ?xb2 \\<bullet>\\<bullet> ?xd2\n 3. nm = nm' \\<Longrightarrow> nm = ?xb2\n 4. nm = nm' \\<Longrightarrow>\n    length vs - k - 1 < length (map term (rev vs) @ ts'')\n 5. nm = nm' \\<Longrightarrow>\n    (map term (rev vs) @ ts'') ! (length vs - k - 1) \\<Rightarrow> term v'\n 6. nm = nm' \\<Longrightarrow> no_match rs ?xd2\n 7. nm = nm' \\<Longrightarrow> ?xd2 = map dterm (map term (rev vs) @ ts'')", "apply (auto simp:nth_append rev_nth ctxt_term[OF \\<open>vs!k \\<Rightarrow> v'\\<close>] simp del: map_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  nm = nm' \\<longrightarrow>\n  no_match rs\n   (map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']))\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "ultimately"], ["proof (chain)\npicking this:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])\n  nm = nm' \\<longrightarrow>\n  no_match rs\n   (map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']))", "show \"?P ?rs' \\<and> ?Q ?rs'\""], ["proof (prove)\nusing this:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])\n  nm = nm' \\<longrightarrow>\n  no_match rs\n   (map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']))\n\ngoal (1 subgoal):\n 1. dterm t' =\n    C nm' \\<bullet>\\<bullet>\n    map dterm\n     ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']) \\<and>\n    (nm = nm' \\<longrightarrow>\n     no_match rs\n      (map dterm\n        ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])))", ".."], ["proof (state)\nthis:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm\n   ((map term (rev vs) @ ts'')[length vs - k - 1 := term v']) \\<and>\n  (nm = nm' \\<longrightarrow>\n   no_match rs\n    (map dterm ((map term (rev vs) @ ts'')[length vs - k - 1 := term v'])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (8 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "case (7 nm'' k r' ts'')"], ["proof (state)\nthis:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = C nm'' \\<bullet>\\<bullet> ts''\n  t' = C nm'' \\<bullet>\\<bullet> ts''[k := r']\n\ngoal (8 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>nma i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = C nma \\<bullet>\\<bullet> ts;\n        t' = C nma \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 8. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "show ?thesis (is \"\\<exists>rs'. ?P rs'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "show \"?P(map dterm (ts''[k := r']))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> map dterm (ts''[k := r']) \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs (map dterm (ts''[k := r'])))", "using 7 ob"], ["proof (prove)\nusing this:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = C nm'' \\<bullet>\\<bullet> ts''\n  t' = C nm'' \\<bullet>\\<bullet> ts''[k := r']\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> map dterm (ts''[k := r']) \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs (map dterm (ts''[k := r'])))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> no_match rs (map dterm (ts''[k := r']))", "apply(rule \"1.hyps\"[OF _ ob(3)])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> j < min (length dts) (length ps)\n 2. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> dts ! j = C ?xb16 \\<bullet>\\<bullet> ?xd16\n 3. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> nm = ?xb16\n 4. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> k < length ts''\n 5. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> ts'' ! k \\<Rightarrow> r'\n 6. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> no_match rs ?xd16\n 7. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> ?xd16 = map dterm ts''", "using 7 \"1.prems\" ob"], ["proof (prove)\nusing this:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = C nm'' \\<bullet>\\<bullet> ts''\n  t' = C nm'' \\<bullet>\\<bullet> ts''[k := r']\n  i < length ts\n  ts ! i \\<Rightarrow> t'\n  no_match ps dts\n  dts = map dterm ts\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (7 subgoals):\n 1. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> j < min (length dts) (length ps)\n 2. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> dts ! j = C ?xb16 \\<bullet>\\<bullet> ?xd16\n 3. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> nm = ?xb16\n 4. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> k < length ts''\n 5. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> ts'' ! k \\<Rightarrow> r'\n 6. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> no_match rs ?xd16\n 7. \\<lbrakk>k < length ts''; ts'' ! k \\<Rightarrow> r';\n     ts ! i = C nm' \\<bullet>\\<bullet> ts'';\n     t' = C nm' \\<bullet>\\<bullet> ts''[k := r']; i < length ts;\n     i < length ps; ps ! i = C nm' \\<bullet>\\<bullet> rs;\n     no_match rs (map dterm ts''); nm'' = nm'; rs' = map dterm ts'';\n     nm = nm'\\<rbrakk>\n    \\<Longrightarrow> ?xd16 = map dterm ts''", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dterm t' = C nm' \\<bullet>\\<bullet> map dterm (ts''[k := r']) \\<and>\n  (nm = nm' \\<longrightarrow> no_match rs (map dterm (ts''[k := r'])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (7 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "case (9 v k r' ts'')"], ["proof (state)\nthis:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v \\<bullet>\\<bullet> ts''[k := r']\n\ngoal (7 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "then"], ["proof (chain)\npicking this:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v \\<bullet>\\<bullet> ts''[k := r']", "obtain vs where [simp]: \"v = C\\<^sub>U nm' vs\" \"rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\""], ["proof (prove)\nusing this:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v \\<bullet>\\<bullet> ts''[k := r']\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>v = C\\<^sub>U nm' vs;\n         rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ob"], ["proof (prove)\nusing this:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v \\<bullet>\\<bullet> ts''[k := r']\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (1 subgoal):\n 1. (\\<And>vs.\n        \\<lbrakk>v = C\\<^sub>U nm' vs;\n         rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases v) auto"], ["proof (state)\nthis:\n  v = C\\<^sub>U nm' vs\n  rs' = map dterm\\<^sub>M\\<^sub>L (rev vs) @ map dterm ts''\n\ngoal (7 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 7. \\<And>v i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = term v \\<bullet>\\<bullet> ts;\n        t' = term v \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "show ?thesis (is \"\\<exists>rs'. ?P rs' \\<and> ?Q rs'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "let ?rs' = \"map dterm ((map term (rev vs) @ ts'')[k+size vs:=r'])\""], ["proof (state)\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "have \"?P ?rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dterm t' =\n    C nm' \\<bullet>\\<bullet>\n    map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])", "using ob 9"], ["proof (prove)\nusing this:\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v \\<bullet>\\<bullet> ts''[k := r']\n\ngoal (1 subgoal):\n 1. dterm t' =\n    C nm' \\<bullet>\\<bullet>\n    map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])", "by (auto simp: list_update_append)"], ["proof (state)\nthis:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "moreover"], ["proof (state)\nthis:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "have \"?Q ?rs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nm = nm' \\<longrightarrow>\n    no_match rs\n     (map dterm ((map term (rev vs) @ ts'')[k + length vs := r']))", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. nm = nm' \\<Longrightarrow>\n    no_match rs\n     (map dterm ((map term (rev vs) @ ts'')[k + length vs := r']))", "apply(rule \"1.hyps\"[OF _ ob(3)])"], ["proof (prove)\ngoal (7 subgoals):\n 1. nm = nm' \\<Longrightarrow> j < min (length dts) (length ps)\n 2. nm = nm' \\<Longrightarrow> dts ! j = C ?xb2 \\<bullet>\\<bullet> ?xd2\n 3. nm = nm' \\<Longrightarrow> nm = ?xb2\n 4. nm = nm' \\<Longrightarrow>\n    k + length vs < length (map term (rev vs) @ ts'')\n 5. nm = nm' \\<Longrightarrow>\n    (map term (rev vs) @ ts'') ! (k + length vs) \\<Rightarrow> r'\n 6. nm = nm' \\<Longrightarrow> no_match rs ?xd2\n 7. nm = nm' \\<Longrightarrow> ?xd2 = map dterm (map term (rev vs) @ ts'')", "using 9 \"1.prems\" ob"], ["proof (prove)\nusing this:\n  k < length ts''\n  ts'' ! k \\<Rightarrow> r'\n  ts ! i = term v \\<bullet>\\<bullet> ts''\n  t' = term v \\<bullet>\\<bullet> ts''[k := r']\n  i < length ts\n  ts ! i \\<Rightarrow> t'\n  no_match ps dts\n  dts = map dterm ts\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (7 subgoals):\n 1. nm = nm' \\<Longrightarrow> j < min (length dts) (length ps)\n 2. nm = nm' \\<Longrightarrow> dts ! j = C ?xb2 \\<bullet>\\<bullet> ?xd2\n 3. nm = nm' \\<Longrightarrow> nm = ?xb2\n 4. nm = nm' \\<Longrightarrow>\n    k + length vs < length (map term (rev vs) @ ts'')\n 5. nm = nm' \\<Longrightarrow>\n    (map term (rev vs) @ ts'') ! (k + length vs) \\<Rightarrow> r'\n 6. nm = nm' \\<Longrightarrow> no_match rs ?xd2\n 7. nm = nm' \\<Longrightarrow> ?xd2 = map dterm (map term (rev vs) @ ts'')", "by (auto simp:nth_append simp del: map_map)"], ["proof (state)\nthis:\n  nm = nm' \\<longrightarrow>\n  no_match rs (map dterm ((map term (rev vs) @ ts'')[k + length vs := r']))\n\ngoal (1 subgoal):\n 1. dterm t' = C nm' \\<bullet>\\<bullet> ?rs' \\<and>\n    (nm = nm' \\<longrightarrow> no_match rs ?rs')", "ultimately"], ["proof (chain)\npicking this:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])\n  nm = nm' \\<longrightarrow>\n  no_match rs (map dterm ((map term (rev vs) @ ts'')[k + length vs := r']))", "show \"?P ?rs' \\<and> ?Q ?rs'\""], ["proof (prove)\nusing this:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])\n  nm = nm' \\<longrightarrow>\n  no_match rs (map dterm ((map term (rev vs) @ ts'')[k + length vs := r']))\n\ngoal (1 subgoal):\n 1. dterm t' =\n    C nm' \\<bullet>\\<bullet>\n    map dterm ((map term (rev vs) @ ts'')[k + length vs := r']) \\<and>\n    (nm = nm' \\<longrightarrow>\n     no_match rs\n      (map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])))", ".."], ["proof (state)\nthis:\n  dterm t' =\n  C nm' \\<bullet>\\<bullet>\n  map dterm ((map term (rev vs) @ ts'')[k + length vs := r']) \\<and>\n  (nm = nm' \\<longrightarrow>\n   no_match rs\n    (map dterm ((map term (rev vs) @ ts'')[k + length vs := r'])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (6 subgoals):\n 1. \\<And>nma vs ts.\n       \\<lbrakk>ts ! i = term (C\\<^sub>U nma vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (C nma \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>x vs ts.\n       \\<lbrakk>ts ! i = term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts;\n        t' =\n        (V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>vf vs n ts.\n       \\<lbrakk>ts ! i = term (Clo vf vs n) \\<bullet>\\<bullet> ts;\n        t' =\n        \\<Lambda>\n         (term\n           (apply (lift 0 (Clo vf vs n))\n             (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n        ts\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 4. \\<And>s s' ts.\n       \\<lbrakk>ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s' \\<bullet>\\<bullet> ts; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 5. \\<And>x i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = V x \\<bullet>\\<bullet> ts;\n        t' = V x \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 6. \\<And>s i r' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> r';\n        ts ! i = \\<Lambda> s \\<bullet>\\<bullet> ts;\n        t' = \\<Lambda> s \\<bullet>\\<bullet> ts[i := r']\\<rbrakk>\n       \\<Longrightarrow> \\<exists>rs'.\n                            dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')", "qed (insert ob, auto simp del: map_map)"], ["proof (state)\nthis:\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "}"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "hence \"\\<exists>rs'. dterm (ts[i := t'] ! j) = C nm' \\<bullet>\\<bullet> rs' \\<and> (nm = nm' \\<longrightarrow> no_match rs rs')\""], ["proof (prove)\nusing this:\n  j = i \\<Longrightarrow>\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm (ts[i := t'] ! j) = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "using \\<open>i < size ts\\<close> ob"], ["proof (prove)\nusing this:\n  j = i \\<Longrightarrow>\n  \\<exists>rs'.\n     dterm t' = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n  i < length ts\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (1 subgoal):\n 1. \\<exists>rs'.\n       dterm (ts[i := t'] ! j) = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "by(simp add:nth_list_update)"], ["proof (state)\nthis:\n  \\<exists>rs'.\n     dterm (ts[i := t'] ! j) = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "hence \"?P j\""], ["proof (prove)\nusing this:\n  \\<exists>rs'.\n     dterm (ts[i := t'] ! j) = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>nm nm' rs rs'.\n       ps ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n       map dterm (ts[i := t']) ! j = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "using ob"], ["proof (prove)\nusing this:\n  \\<exists>rs'.\n     dterm (ts[i := t'] ! j) = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n  j < length ts\n  j < length ps\n  ps ! j = C nm \\<bullet>\\<bullet> rs\n  dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'\n  nm = nm' \\<longrightarrow> no_match rs rs'\n\ngoal (1 subgoal):\n 1. \\<exists>nm nm' rs rs'.\n       ps ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n       map dterm (ts[i := t']) ! j = C nm' \\<bullet>\\<bullet> rs' \\<and>\n       (nm = nm' \\<longrightarrow> no_match rs rs')", "by auto"], ["proof (state)\nthis:\n  \\<exists>nm nm' rs rs'.\n     ps ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n     map dterm (ts[i := t']) ! j = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "moreover"], ["proof (state)\nthis:\n  \\<exists>nm nm' rs rs'.\n     ps ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n     map dterm (ts[i := t']) ! j = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "have \"j < ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < min (length (map dterm (ts[i := t']))) (length ps)", "using \\<open>j < length ts\\<close> \\<open>j < size ps\\<close>"], ["proof (prove)\nusing this:\n  j < length ts\n  j < length ps\n\ngoal (1 subgoal):\n 1. j < min (length (map dterm (ts[i := t']))) (length ps)", "by simp"], ["proof (state)\nthis:\n  j < min (length (map dterm (ts[i := t']))) (length ps)\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>nm nm' rs rs'.\n     ps ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n     map dterm (ts[i := t']) ! j = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n  j < min (length (map dterm (ts[i := t']))) (length ps)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>nm nm' rs rs'.\n     ps ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n     map dterm (ts[i := t']) ! j = C nm' \\<bullet>\\<bullet> rs' \\<and>\n     (nm = nm' \\<longrightarrow> no_match rs rs')\n  j < min (length (map dterm (ts[i := t']))) (length ps)\n\ngoal (1 subgoal):\n 1. \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "by blast"], ["proof (state)\nthis:\n  \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n     \\<exists>nm nm' rs rs'.\n        ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n        map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n        (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<min (length (map dterm (ts[i := t']))) (length ps).\n     \\<exists>nm nm' rs rs'.\n        ps ! k = C nm \\<bullet>\\<bullet> rs \\<and>\n        map dterm (ts[i := t']) ! k = C nm' \\<bullet>\\<bullet> rs' \\<and>\n        (nm = nm' \\<longrightarrow> no_match rs rs')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  no_match ps (map dterm (ts[i := t']))\n\ngoal:\nNo subgoals!", "qed"], ["", "declare [[simp_depth_limit = 50]]"], ["", "lemma Red_term_pres_no_match_it:\n  \"\\<lbrakk> \\<forall> i < length ts. (ts ! i, ts' ! i) : Red_term ^^ (ns!i);\n    size ts' = size ts; size ns = size ts;\n    no_match ps (map dterm ts)\\<rbrakk>\n   \\<Longrightarrow> no_match ps (map dterm ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<length ts.\n                (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n     length ts' = length ts; length ns = length ts;\n     no_match ps (map dterm ts)\\<rbrakk>\n    \\<Longrightarrow> no_match ps (map dterm ts')", "proof(induct \"sum_list ns\" arbitrary: ts ns)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ns ts.\n       \\<lbrakk>0 = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')\n 2. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "case 0"], ["proof (state)\nthis:\n  0 = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)\n\ngoal (2 subgoals):\n 1. \\<And>ns ts.\n       \\<lbrakk>0 = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')\n 2. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "hence \"\\<forall>i < size ts. ns!i = 0\""], ["proof (prove)\nusing this:\n  0 = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ts. ns ! i = 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length ts. ns ! i = 0\n\ngoal (2 subgoals):\n 1. \\<And>ns ts.\n       \\<lbrakk>0 = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')\n 2. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "with 0"], ["proof (chain)\npicking this:\n  0 = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)\n  \\<forall>i<length ts. ns ! i = 0", "show ?case"], ["proof (prove)\nusing this:\n  0 = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)\n  \\<forall>i<length ts. ns ! i = 0\n\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "by simp (metis nth_equalityI)"], ["proof (state)\nthis:\n  no_match ps (map dterm ts')\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = sum_list ?ns;\n   \\<forall>i<length ?ts. (?ts ! i, ts' ! i) \\<in> Red_term ^^ ?ns ! i;\n   length ts' = length ?ts; length ?ns = length ?ts;\n   no_match ps (map dterm ?ts)\\<rbrakk>\n  \\<Longrightarrow> no_match ps (map dterm ts')\n  Suc n = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>n = sum_list ?ns;\n   \\<forall>i<length ?ts. (?ts ! i, ts' ! i) \\<in> Red_term ^^ ?ns ! i;\n   length ts' = length ?ts; length ?ns = length ?ts;\n   no_match ps (map dterm ?ts)\\<rbrakk>\n  \\<Longrightarrow> no_match ps (map dterm ts')\n  Suc n = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)", "have \"sum_list ns \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>n = sum_list ?ns;\n   \\<forall>i<length ?ts. (?ts ! i, ts' ! i) \\<in> Red_term ^^ ?ns ! i;\n   length ts' = length ?ts; length ?ns = length ?ts;\n   no_match ps (map dterm ?ts)\\<rbrakk>\n  \\<Longrightarrow> no_match ps (map dterm ts')\n  Suc n = sum_list ns\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  length ts' = length ts\n  length ns = length ts\n  no_match ps (map dterm ts)\n\ngoal (1 subgoal):\n 1. sum_list ns \\<noteq> 0", "by arith"], ["proof (state)\nthis:\n  sum_list ns \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "then"], ["proof (chain)\npicking this:\n  sum_list ns \\<noteq> 0", "obtain k l where \"k<size ts\" and [simp]: \"ns!k = Suc l\""], ["proof (prove)\nusing this:\n  sum_list ns \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k l.\n        \\<lbrakk>k < length ts; ns ! k = Suc l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (metis \\<open>length ns = length ts\\<close> gr0_implies_Suc in_set_conv_nth)"], ["proof (state)\nthis:\n  k < length ts\n  ns ! k = Suc l\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "let ?ns = \"ns[k := l]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "have \"n = sum_list ?ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = sum_list (ns[k := l])", "using \\<open>Suc n = sum_list ns\\<close> \\<open>k<size ts\\<close> \\<open>size ns = size ts\\<close>"], ["proof (prove)\nusing this:\n  Suc n = sum_list ns\n  k < length ts\n  length ns = length ts\n\ngoal (1 subgoal):\n 1. n = sum_list (ns[k := l])", "by (simp add:sum_list_update)"], ["proof (state)\nthis:\n  n = sum_list (ns[k := l])\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "obtain t' where \"ts!k \\<Rightarrow> t'\" \"(t', ts'!k) : Red_term^^l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>ts ! k \\<Rightarrow> t';\n         (t', ts' ! k) \\<in> Red_term ^^ l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Suc(3) \\<open>k<size ts\\<close> \\<open>size ns = size ts\\<close> \\<open>ns!k = Suc l\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  k < length ts\n  length ns = length ts\n  ns ! k = Suc l\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>ts ! k \\<Rightarrow> t';\n         (t', ts' ! k) \\<in> Red_term ^^ l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis relpow_Suc_E2)"], ["proof (state)\nthis:\n  ts ! k \\<Rightarrow> t'\n  (t', ts' ! k) \\<in> Red_term ^^ l\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "then"], ["proof (chain)\npicking this:\n  ts ! k \\<Rightarrow> t'\n  (t', ts' ! k) \\<in> Red_term ^^ l", "have 1: \"\\<forall>i<size(ts[k:=t']). (ts[k:=t']!i, ts'!i) : Red_term^^(?ns!i)\""], ["proof (prove)\nusing this:\n  ts ! k \\<Rightarrow> t'\n  (t', ts' ! k) \\<in> Red_term ^^ l\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ts[k := t']).\n       (ts[k := t'] ! i, ts' ! i) \\<in> Red_term ^^ ns[k := l] ! i", "using Suc(3) \\<open>k<size ts\\<close> \\<open>size ns = size ts\\<close>"], ["proof (prove)\nusing this:\n  ts ! k \\<Rightarrow> t'\n  (t', ts' ! k) \\<in> Red_term ^^ l\n  \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i\n  k < length ts\n  length ns = length ts\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (ts[k := t']).\n       (ts[k := t'] ! i, ts' ! i) \\<in> Red_term ^^ ns[k := l] ! i", "by (auto simp add:nth_list_update)"], ["proof (state)\nthis:\n  \\<forall>i<length (ts[k := t']).\n     (ts[k := t'] ! i, ts' ! i) \\<in> Red_term ^^ ns[k := l] ! i\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "note nm1 = Red_term_pres_no_match[OF \\<open>k<size ts\\<close> \\<open>ts!k \\<Rightarrow> t'\\<close> \\<open>no_match ps (map dterm ts)\\<close>]"], ["proof (state)\nthis:\n  map dterm ts = map dterm ts \\<Longrightarrow>\n  no_match ps (map dterm (ts[k := t']))\n\ngoal (1 subgoal):\n 1. \\<And>x ns ts.\n       \\<lbrakk>\\<And>ns ts.\n                   \\<lbrakk>x = sum_list ns;\n                    \\<forall>i<length ts.\n                       (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n                    length ts' = length ts; length ns = length ts;\n                    no_match ps (map dterm ts)\\<rbrakk>\n                   \\<Longrightarrow> no_match ps (map dterm ts');\n        Suc x = sum_list ns;\n        \\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i;\n        length ts' = length ts; length ns = length ts;\n        no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "by(rule Suc(1)[OF \\<open>n = sum_list ?ns\\<close> 1 _ _ nm1])\n               (simp_all add: \\<open>size ts' = size ts\\<close> \\<open>size ns = size ts\\<close>)"], ["proof (state)\nthis:\n  no_match ps (map dterm ts')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Red_term_pres_no_match_star:\nassumes \"\\<forall>i < length(ts::tm list). ts ! i \\<Rightarrow>* ts' ! i\" and \"size ts' = size ts\"\n    and \"no_match ps (map dterm ts)\"\nshows \"no_match ps (map dterm ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "let ?P = \"%ns. size ns = size ts \\<and>\n   (\\<forall>i < length ts.(ts!i, ts'!i) : Red_term^^(ns!i))\""], ["proof (state)\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "have \"\\<exists>ns. ?P ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       length ns = length ts \\<and>\n       (\\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i)", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>i<length ts. ts ! i \\<Rightarrow>* ts' ! i\n\ngoal (1 subgoal):\n 1. \\<exists>ns.\n       length ns = length ts \\<and>\n       (\\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i)", "by(subst Skolem_list_nth[symmetric])\n      (simp add:rtrancl_power)"], ["proof (state)\nthis:\n  \\<exists>ns.\n     length ns = length ts \\<and>\n     (\\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ ns ! i)\n\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "from someI_ex[OF this]"], ["proof (chain)\npicking this:\n  length\n   (SOME x.\n       length x = length ts \\<and>\n       (\\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ x ! i)) =\n  length ts \\<and>\n  (\\<forall>i<length ts.\n      (ts ! i, ts' ! i)\n      \\<in> Red_term ^^\n            (SOME x.\n                length x = length ts \\<and>\n                (\\<forall>i<length ts.\n                    (ts ! i, ts' ! i) \\<in> Red_term ^^ x ! i)) !\n            i)", "show ?thesis"], ["proof (prove)\nusing this:\n  length\n   (SOME x.\n       length x = length ts \\<and>\n       (\\<forall>i<length ts. (ts ! i, ts' ! i) \\<in> Red_term ^^ x ! i)) =\n  length ts \\<and>\n  (\\<forall>i<length ts.\n      (ts ! i, ts' ! i)\n      \\<in> Red_term ^^\n            (SOME x.\n                length x = length ts \\<and>\n                (\\<forall>i<length ts.\n                    (ts ! i, ts' ! i) \\<in> Red_term ^^ x ! i)) !\n            i)\n\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "by(fast intro: Red_term_pres_no_match_it[OF _ assms(2) _ assms(3)])"], ["proof (state)\nthis:\n  no_match ps (map dterm ts')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_pure_term[simp]: \"\\<not> pure(term v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> pure (term v)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. pure (term v) \\<Longrightarrow> False", "assume \"pure(term v)\""], ["proof (state)\nthis:\n  pure (term v)\n\ngoal (1 subgoal):\n 1. pure (term v) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  pure (term v)\n\ngoal (1 subgoal):\n 1. False", "by cases"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation RedMLs :: \"tm list \\<Rightarrow> tm list \\<Rightarrow> bool\" (infix \"[\\<Rightarrow>*]\" 50) where\n\"ss [\\<Rightarrow>*] ts  \\<equiv>  size ss = size ts \\<and> (\\<forall>i<size ss. ss!i \\<Rightarrow>* ts!i)\""], ["", "fun C_U_args :: \"tm \\<Rightarrow> tm list\" (\"C\\<^sub>U'_args\") where\n\"C\\<^sub>U_args(s \\<bullet> t) = C\\<^sub>U_args s @ [t]\" |\n\"C\\<^sub>U_args(term(C\\<^sub>U nm vs)) = map term (rev vs)\" |\n\"C\\<^sub>U_args _ = []\""], ["", "lemma [simp]: \"C\\<^sub>U_args(C nm \\<bullet>\\<bullet> ts) = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C\\<^sub>U_args (C nm \\<bullet>\\<bullet> ts) = ts", "by (induct ts rule:rev_induct) auto"], ["", "lemma redts_term_cong: \"v \\<Rightarrow>* v' \\<Longrightarrow> term v \\<Rightarrow>* term v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Rightarrow>* v' \\<Longrightarrow> term v \\<Rightarrow>* term v'", "apply(erule converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. term v' \\<Rightarrow>* term v'\n 2. \\<And>y z.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* v';\n        term z \\<Rightarrow>* term v'\\<rbrakk>\n       \\<Longrightarrow> term y \\<Rightarrow>* term v'", "apply(rule rtrancl_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* v';\n        term z \\<Rightarrow>* term v'\\<rbrakk>\n       \\<Longrightarrow> term y \\<Rightarrow>* term v'", "apply(fast intro: converse_rtrancl_into_rtrancl dest: ctxt_term)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_Red_term_ML:\n  \"v \\<Rightarrow> v' \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\n   \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' = C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args(term v')) \\<and>\n      C\\<^sub>U_args(term v) [\\<Rightarrow>*] C\\<^sub>U_args(term v') \\<and>\n      ts = map dterm (C\\<^sub>U_args(term v))\" and\n  \"(vs:: ml list) \\<Rightarrow> vs' \\<Longrightarrow> i < length vs \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v;\n      dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n     \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' =\n                       C nm \\<bullet>\\<bullet>\n                       map dterm (C\\<^sub>U_args (term v')) \\<and>\n                       (length (C\\<^sub>U_args (term v)) =\n                        length (C\\<^sub>U_args (term v')) \\<and>\n                        (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                            C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                            C\\<^sub>U_args (term v') ! i)) \\<and>\n                       ts = map dterm (C\\<^sub>U_args (term v))) &&&\n    (\\<lbrakk>vs \\<Rightarrow> vs'; i < length vs\\<rbrakk>\n     \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i)", "apply(induct arbitrary: nm ts and i rule:Red_ml_Red_ml_list.inducts)"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>u v nm ts.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L\n                 (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]);\n        dterm\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (u[v/0]) =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args (term (u[v/0]))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term\n                               (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u)\n                                 [v]))) =\n                          length (C\\<^sub>U_args (term (u[v/0]))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u) [v]))).\n                              C\\<^sub>U_args\n                               (term\n                                 (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u)\n                                   [v])) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args (term (u[v/0])) ! i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term\n                              (A\\<^sub>M\\<^sub>L (Lam\\<^sub>M\\<^sub>L u)\n                                [v])))\n 2. \\<And>nm vs v \\<sigma> nma ts.\n       \\<lbrakk>(nm, vs, v) \\<in> compR;\n        \\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        C_normal\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs));\n        dterm\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n           (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)) =\n        C nma \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma> v) =\n                         C nma \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term\n                              (subst\\<^sub>M\\<^sub>L \\<sigma> v))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term\n                               (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                                 (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                                   vs)))) =\n                          length\n                           (C\\<^sub>U_args\n                             (term\n                               (subst\\<^sub>M\\<^sub>L \\<sigma> v))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args\n   (term\n     (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n       (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs)))).\n                              C\\<^sub>U_args\n                               (term\n                                 (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                                   (map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                                     vs))) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args\n                               (term (subst\\<^sub>M\\<^sub>L \\<sigma> v)) !\n                              i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term\n                              (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                                (map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs))))\n 3. \\<And>\\<sigma> vs arity nm vs' nma ts.\n       \\<lbrakk>\\<forall>i. closed\\<^sub>M\\<^sub>L 0 (\\<sigma> i);\n        vs = map V\\<^sub>M\\<^sub>L [0..<arity nm];\n        vs' = map (subst\\<^sub>M\\<^sub>L \\<sigma>) vs;\n        no_match_compR nm vs';\n        C_normal\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs');\n        dterm\\<^sub>M\\<^sub>L\n         (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs') =\n        C nma \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L\n                          (subst\\<^sub>M\\<^sub>L \\<sigma>\n                            (C\\<^sub>U nm vs)) =\n                         C nma \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term\n                              (subst\\<^sub>M\\<^sub>L \\<sigma>\n                                (C\\<^sub>U nm vs)))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term\n                               (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                                 vs'))) =\n                          length\n                           (C\\<^sub>U_args\n                             (term\n                               (subst\\<^sub>M\\<^sub>L \\<sigma>\n                                 (C\\<^sub>U nm vs)))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm) vs'))).\n                              C\\<^sub>U_args\n                               (term\n                                 (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                                   vs')) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args\n                               (term\n                                 (subst\\<^sub>M\\<^sub>L \\<sigma>\n                                   (C\\<^sub>U nm vs))) !\n                              i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term\n                              (A\\<^sub>M\\<^sub>L (C\\<^sub>M\\<^sub>L nm)\n                                vs')))\n 4. \\<And>f vs v nm ts.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L (apply (Clo f vs (Suc 0)) v);\n        dterm\\<^sub>M\\<^sub>L (apply (Clo f vs (Suc 0)) v) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L\n                          (A\\<^sub>M\\<^sub>L f (v # vs)) =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term (A\\<^sub>M\\<^sub>L f (v # vs)))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term (apply (Clo f vs (Suc 0)) v))) =\n                          length\n                           (C\\<^sub>U_args\n                             (term (A\\<^sub>M\\<^sub>L f (v # vs)))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (apply (Clo f vs (Suc 0)) v))).\n                              C\\<^sub>U_args\n                               (term (apply (Clo f vs (Suc 0)) v)) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args\n                               (term (A\\<^sub>M\\<^sub>L f (v # vs))) !\n                              i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term (apply (Clo f vs (Suc 0)) v)))\n 5. \\<And>n f vs v nm ts.\n       \\<lbrakk>0 < n;\n        C_normal\\<^sub>M\\<^sub>L (apply (Clo f vs (Suc n)) v);\n        dterm\\<^sub>M\\<^sub>L (apply (Clo f vs (Suc n)) v) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (Clo f (v # vs) n) =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args (term (Clo f (v # vs) n))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term (apply (Clo f vs (Suc n)) v))) =\n                          length\n                           (C\\<^sub>U_args (term (Clo f (v # vs) n))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (apply (Clo f vs (Suc n)) v))).\n                              C\\<^sub>U_args\n                               (term (apply (Clo f vs (Suc n)) v)) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args (term (Clo f (v # vs) n)) !\n                              i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term (apply (Clo f vs (Suc n)) v)))\n 6. \\<And>nm vs v nma ts.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L (apply (C\\<^sub>U nm vs) v);\n        dterm\\<^sub>M\\<^sub>L (apply (C\\<^sub>U nm vs) v) =\n        C nma \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (C\\<^sub>U nm (v # vs)) =\n                         C nma \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term (C\\<^sub>U nm (v # vs)))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term (apply (C\\<^sub>U nm vs) v))) =\n                          length\n                           (C\\<^sub>U_args\n                             (term (C\\<^sub>U nm (v # vs)))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (apply (C\\<^sub>U nm vs) v))).\n                              C\\<^sub>U_args\n                               (term (apply (C\\<^sub>U nm vs) v)) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args\n                               (term (C\\<^sub>U nm (v # vs))) !\n                              i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term (apply (C\\<^sub>U nm vs) v)))\n 7. \\<And>x vs v nm ts.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L (apply (V\\<^sub>U x vs) v);\n        dterm\\<^sub>M\\<^sub>L (apply (V\\<^sub>U x vs) v) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (V\\<^sub>U x (v # vs)) =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args\n                            (term (V\\<^sub>U x (v # vs)))) \\<and>\n                         (length\n                           (C\\<^sub>U_args\n                             (term (apply (V\\<^sub>U x vs) v))) =\n                          length\n                           (C\\<^sub>U_args\n                             (term (V\\<^sub>U x (v # vs)))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (apply (V\\<^sub>U x vs) v))).\n                              C\\<^sub>U_args\n                               (term (apply (V\\<^sub>U x vs) v)) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args (term (V\\<^sub>U x (v # vs))) !\n                              i)) \\<and>\n                         ts =\n                         map dterm\n                          (C\\<^sub>U_args (term (apply (V\\<^sub>U x vs) v)))\n 8. \\<And>vs vs' nm nma ts.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        C_normal\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs);\n        dterm\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs) =\n        C nma \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (C\\<^sub>U nm vs') =\n                         C nma \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args (term (C\\<^sub>U nm vs'))) \\<and>\n                         (length (C\\<^sub>U_args (term (C\\<^sub>U nm vs))) =\n                          length\n                           (C\\<^sub>U_args (term (C\\<^sub>U nm vs'))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (C\\<^sub>U nm vs))).\n                              C\\<^sub>U_args (term (C\\<^sub>U nm vs)) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args (term (C\\<^sub>U nm vs')) !\n                              i)) \\<and>\n                         ts =\n                         map dterm (C\\<^sub>U_args (term (C\\<^sub>U nm vs)))\n 9. \\<And>vs vs' x nm ts.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        C_normal\\<^sub>M\\<^sub>L (V\\<^sub>U x vs);\n        dterm\\<^sub>M\\<^sub>L (V\\<^sub>U x vs) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (V\\<^sub>U x vs') =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm\n                          (C\\<^sub>U_args (term (V\\<^sub>U x vs'))) \\<and>\n                         (length (C\\<^sub>U_args (term (V\\<^sub>U x vs))) =\n                          length\n                           (C\\<^sub>U_args (term (V\\<^sub>U x vs'))) \\<and>\n                          (\\<forall>i<length\n (C\\<^sub>U_args (term (V\\<^sub>U x vs))).\n                              C\\<^sub>U_args (term (V\\<^sub>U x vs)) !\n                              i \\<Rightarrow>*\n                              C\\<^sub>U_args (term (V\\<^sub>U x vs')) !\n                              i)) \\<and>\n                         ts =\n                         map dterm (C\\<^sub>U_args (term (V\\<^sub>U x vs)))\n 10. \\<And>f f' vs n nm ts.\n        \\<lbrakk>f \\<Rightarrow> f';\n         \\<And>nm ts.\n            \\<lbrakk>C_normal\\<^sub>M\\<^sub>L f;\n             dterm\\<^sub>M\\<^sub>L f = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n            \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L f' =\n                              C nm \\<bullet>\\<bullet>\n                              map dterm (C\\<^sub>U_args (term f')) \\<and>\n                              (length (C\\<^sub>U_args (term f)) =\n                               length (C\\<^sub>U_args (term f')) \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args (term f)).\n                                   C\\<^sub>U_args (term f) !\n                                   i \\<Rightarrow>*\n                                   C\\<^sub>U_args (term f') ! i)) \\<and>\n                              ts = map dterm (C\\<^sub>U_args (term f));\n         C_normal\\<^sub>M\\<^sub>L (Clo f vs n);\n         dterm\\<^sub>M\\<^sub>L (Clo f vs n) =\n         C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n        \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L (Clo f' vs n) =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm\n                           (C\\<^sub>U_args (term (Clo f' vs n))) \\<and>\n                          (length (C\\<^sub>U_args (term (Clo f vs n))) =\n                           length\n                            (C\\<^sub>U_args (term (Clo f' vs n))) \\<and>\n                           (\\<forall>i<length\n  (C\\<^sub>U_args (term (Clo f vs n))).\n                               C\\<^sub>U_args (term (Clo f vs n)) !\n                               i \\<Rightarrow>*\n                               C\\<^sub>U_args (term (Clo f' vs n)) !\n                               i)) \\<and>\n                          ts =\n                          map dterm (C\\<^sub>U_args (term (Clo f vs n)))\nA total of 17 subgoals...", "apply(simp_all add:Red_ml_list_length del: map_map)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs vs' nm nma.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs' \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        (\\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x) \\<and>\n        no_match_compR nma vs;\n        nm = nma\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs'.\n                            term (rev vs ! i) \\<Rightarrow>*\n                            term (rev vs' ! i)\n 2. \\<And>v v' vs i.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm ts.\n           \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n            dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n           \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' =\n                             C nm \\<bullet>\\<bullet>\n                             map dterm (C\\<^sub>U_args (term v')) \\<and>\n                             length (C\\<^sub>U_args (term v)) =\n                             length (C\\<^sub>U_args (term v')) \\<and>\n                             (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                                 C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                                 C\\<^sub>U_args (term v') ! i) \\<and>\n                             ts = map dterm (C\\<^sub>U_args (term v));\n        i < Suc (length vs)\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v' # vs) ! i\n 3. \\<And>vs vs' v i.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs' \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        i < Suc (length vs')\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v # vs') ! i", "apply(frule Red_ml_list_length)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>vs vs' nm nma.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs' \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        (\\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x) \\<and>\n        no_match_compR nma vs;\n        nm = nma; length vs = length vs'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length vs'.\n                            term (rev vs ! i) \\<Rightarrow>*\n                            term (rev vs' ! i)\n 2. \\<And>v v' vs i.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm ts.\n           \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n            dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n           \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' =\n                             C nm \\<bullet>\\<bullet>\n                             map dterm (C\\<^sub>U_args (term v')) \\<and>\n                             length (C\\<^sub>U_args (term v)) =\n                             length (C\\<^sub>U_args (term v')) \\<and>\n                             (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                                 C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                                 C\\<^sub>U_args (term v') ! i) \\<and>\n                             ts = map dterm (C\\<^sub>U_args (term v));\n        i < Suc (length vs)\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v' # vs) ! i\n 3. \\<And>vs vs' v i.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs' \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        i < Suc (length vs')\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v # vs') ! i", "apply(simp add: redts_term_cong rev_nth del: map_map)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v v' vs i.\n       \\<lbrakk>v \\<Rightarrow> v';\n        \\<And>nm ts.\n           \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n            dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n           \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' =\n                             C nm \\<bullet>\\<bullet>\n                             map dterm (C\\<^sub>U_args (term v')) \\<and>\n                             length (C\\<^sub>U_args (term v)) =\n                             length (C\\<^sub>U_args (term v')) \\<and>\n                             (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                                 C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                                 C\\<^sub>U_args (term v') ! i) \\<and>\n                             ts = map dterm (C\\<^sub>U_args (term v));\n        i < Suc (length vs)\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v' # vs) ! i\n 2. \\<And>vs vs' v i.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs' \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        i < Suc (length vs')\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v # vs') ! i", "apply(simp add:nth_Cons' r_into_rtrancl del: map_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>vs vs' v i.\n       \\<lbrakk>vs \\<Rightarrow> vs';\n        \\<And>i.\n           i < length vs' \\<Longrightarrow> vs ! i \\<Rightarrow>* vs' ! i;\n        i < Suc (length vs')\\<rbrakk>\n       \\<Longrightarrow> (v # vs) ! i \\<Rightarrow>* (v # vs') ! i", "apply(simp add:nth_Cons')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_normal_subterm:\n  \"C_normal t \\<Longrightarrow> dterm t = C nm \\<bullet>\\<bullet> ts \\<Longrightarrow> s \\<in> set(C\\<^sub>U_args t) \\<Longrightarrow> C_normal s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C_normal t; dterm t = C nm \\<bullet>\\<bullet> ts;\n     s \\<in> set (C\\<^sub>U_args t)\\<rbrakk>\n    \\<Longrightarrow> C_normal s", "apply(induct rule: C_normal.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>tsa x.\n       \\<lbrakk>\\<forall>t\\<in>set tsa.\n                   C_normal t \\<and>\n                   (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                    s \\<in> set (C\\<^sub>U_args t) \\<longrightarrow>\n                    C_normal s);\n        dterm (V x \\<bullet>\\<bullet> tsa) = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (V x \\<bullet>\\<bullet> tsa))\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 2. \\<And>t.\n       \\<lbrakk>C_normal t;\n        \\<lbrakk>dterm t = C nm \\<bullet>\\<bullet> ts;\n         s \\<in> set (C\\<^sub>U_args t)\\<rbrakk>\n        \\<Longrightarrow> C_normal s;\n        dterm (\\<Lambda> t) = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (\\<Lambda> t))\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 3. \\<And>v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm (term v) = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v))\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 4. \\<And>tsa nma.\n       \\<lbrakk>\\<forall>t\\<in>set tsa.\n                   C_normal t \\<and>\n                   (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                    s \\<in> set (C\\<^sub>U_args t) \\<longrightarrow>\n                    C_normal s);\n        no_match_R nma (map dterm tsa);\n        dterm (C nma \\<bullet>\\<bullet> tsa) = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (C nma \\<bullet>\\<bullet> tsa))\\<rbrakk>\n       \\<Longrightarrow> C_normal s", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v))\\<rbrakk>\n       \\<Longrightarrow> C_normal s", "apply(case_tac v)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>v x1.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v));\n        v = C\\<^sub>M\\<^sub>L x1\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 2. \\<And>v x2.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v));\n        v = V\\<^sub>M\\<^sub>L x2\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 3. \\<And>v x31 x32.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v));\n        v = A\\<^sub>M\\<^sub>L x31 x32\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 4. \\<And>v x4.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v));\n        v = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 5. \\<And>v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v));\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 6. \\<And>v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v));\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 7. \\<And>v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v)); v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> C_normal s\n 8. \\<And>v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        s \\<in> set (C\\<^sub>U_args (term v)); v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> C_normal s", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_normal_subterms:\n  \"C_normal t \\<Longrightarrow> dterm t = C nm \\<bullet>\\<bullet> ts \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>C_normal t; dterm t = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n    \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args t)", "apply(induct rule: C_normal.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>tsa x.\n       \\<lbrakk>\\<forall>t\\<in>set tsa.\n                   C_normal t \\<and>\n                   (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                    ts = map dterm (C\\<^sub>U_args t));\n        dterm (V x \\<bullet>\\<bullet> tsa) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts =\n                         map dterm\n                          (C\\<^sub>U_args (V x \\<bullet>\\<bullet> tsa))\n 2. \\<And>t.\n       \\<lbrakk>C_normal t;\n        dterm t = C nm \\<bullet>\\<bullet> ts \\<Longrightarrow>\n        ts = map dterm (C\\<^sub>U_args t);\n        dterm (\\<Lambda> t) = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (\\<Lambda> t))\n 3. \\<And>v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm (term v) = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>tsa nma.\n       \\<lbrakk>\\<forall>t\\<in>set tsa.\n                   C_normal t \\<and>\n                   (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                    ts = map dterm (C\\<^sub>U_args t));\n        no_match_R nma (map dterm tsa);\n        dterm (C nma \\<bullet>\\<bullet> tsa) =\n        C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts =\n                         map dterm\n                          (C\\<^sub>U_args (C nma \\<bullet>\\<bullet> tsa))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))", "apply(case_tac v)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>v x1.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>M\\<^sub>L x1\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>v x2.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>M\\<^sub>L x2\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>v x31 x32.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = A\\<^sub>M\\<^sub>L x31 x32\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>v x4.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 5. \\<And>v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 6. \\<And>v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 7. \\<And>v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 8. \\<And>v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_redt: \"t \\<Rightarrow> t' \\<Longrightarrow> C_normal t \\<Longrightarrow> \n    C_normal t' \\<and> (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n    (\\<exists>ts'. ts' = map dterm (C\\<^sub>U_args t') \\<and> dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n     C\\<^sub>U_args t [\\<Rightarrow>*] C\\<^sub>U_args t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<Rightarrow> t'; C_normal t\\<rbrakk>\n    \\<Longrightarrow> C_normal t' \\<and>\n                      (dterm t =\n                       C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                       (\\<exists>ts'.\n                           ts' = map dterm (C\\<^sub>U_args t') \\<and>\n                           dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                           length (C\\<^sub>U_args t) =\n                           length (C\\<^sub>U_args t') \\<and>\n                           (\\<forall>i<length (C\\<^sub>U_args t).\n                               C\\<^sub>U_args t ! i \\<Rightarrow>*\n                               C\\<^sub>U_args t' ! i)))", "apply(induct arbitrary: ts nm rule:Red_term_hnf_induct)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>nm vs ts tsa nma.\n       C_normal\n        (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts) \\<Longrightarrow>\n       C_normal\n        ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n         ts) \\<and>\n       (dterm (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts) =\n        C nma \\<bullet>\\<bullet> tsa \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' =\n            map dterm\n             (C\\<^sub>U_args\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts)) \\<and>\n            dterm\n             ((C nm \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n              ts) =\n            C nma \\<bullet>\\<bullet> ts' \\<and>\n            length\n             (C\\<^sub>U_args\n               (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)) =\n            length\n             (C\\<^sub>U_args\n               ((C nm \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts)) \\<and>\n            (\\<forall>i<length\n                         (C\\<^sub>U_args\n                           (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts)).\n                C\\<^sub>U_args\n                 (term (C\\<^sub>U nm vs) \\<bullet>\\<bullet> ts) !\n                i \\<Rightarrow>*\n                C\\<^sub>U_args\n                 ((C nm \\<bullet>\\<bullet>\n                   map term (rev vs)) \\<bullet>\\<bullet>\n                  ts) !\n                i)))\n 2. \\<And>x vs ts tsa nm.\n       C_normal\n        (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts) \\<Longrightarrow>\n       C_normal\n        ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n         ts) \\<and>\n       (dterm (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts) =\n        C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' =\n            map dterm\n             (C\\<^sub>U_args\n               ((V x \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts)) \\<and>\n            dterm\n             ((V x \\<bullet>\\<bullet> map term (rev vs)) \\<bullet>\\<bullet>\n              ts) =\n            C nm \\<bullet>\\<bullet> ts' \\<and>\n            length\n             (C\\<^sub>U_args\n               (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)) =\n            length\n             (C\\<^sub>U_args\n               ((V x \\<bullet>\\<bullet>\n                 map term (rev vs)) \\<bullet>\\<bullet>\n                ts)) \\<and>\n            (\\<forall>i<length\n                         (C\\<^sub>U_args\n                           (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts)).\n                C\\<^sub>U_args\n                 (term (V\\<^sub>U x vs) \\<bullet>\\<bullet> ts) !\n                i \\<Rightarrow>*\n                C\\<^sub>U_args\n                 ((V x \\<bullet>\\<bullet>\n                   map term (rev vs)) \\<bullet>\\<bullet>\n                  ts) !\n                i)))\n 3. \\<And>vf vs n ts tsa nm.\n       C_normal (term (Clo vf vs n) \\<bullet>\\<bullet> ts) \\<Longrightarrow>\n       C_normal\n        (\\<Lambda>\n          (term\n            (apply (lift 0 (Clo vf vs n))\n              (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n         ts) \\<and>\n       (dterm (term (Clo vf vs n) \\<bullet>\\<bullet> ts) =\n        C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' =\n            map dterm\n             (C\\<^sub>U_args\n               (\\<Lambda>\n                 (term\n                   (apply (lift 0 (Clo vf vs n))\n                     (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                ts)) \\<and>\n            dterm\n             (\\<Lambda>\n               (term\n                 (apply (lift 0 (Clo vf vs n))\n                   (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n              ts) =\n            C nm \\<bullet>\\<bullet> ts' \\<and>\n            length\n             (C\\<^sub>U_args (term (Clo vf vs n) \\<bullet>\\<bullet> ts)) =\n            length\n             (C\\<^sub>U_args\n               (\\<Lambda>\n                 (term\n                   (apply (lift 0 (Clo vf vs n))\n                     (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                ts)) \\<and>\n            (\\<forall>i<length\n                         (C\\<^sub>U_args\n                           (term (Clo vf vs n) \\<bullet>\\<bullet> ts)).\n                C\\<^sub>U_args (term (Clo vf vs n) \\<bullet>\\<bullet> ts) !\n                i \\<Rightarrow>*\n                C\\<^sub>U_args\n                 (\\<Lambda>\n                   (term\n                     (apply (lift 0 (Clo vf vs n))\n                       (V\\<^sub>U 0 []))) \\<bullet>\\<bullet>\n                  ts) !\n                i)))\n 4. \\<And>t t' ts tsa nm.\n       \\<lbrakk>t \\<Rightarrow> t';\n        \\<And>ts nm.\n           C_normal t \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                ts' = map dterm (C\\<^sub>U_args t') \\<and>\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                length (C\\<^sub>U_args t) =\n                length (C\\<^sub>U_args t') \\<and>\n                (\\<forall>i<length (C\\<^sub>U_args t).\n                    C\\<^sub>U_args t ! i \\<Rightarrow>*\n                    C\\<^sub>U_args t' ! i)));\n        C_normal (\\<Lambda> t \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal\n                          (\\<Lambda> t' \\<bullet>\\<bullet> ts) \\<and>\n                         (dterm (\\<Lambda> t \\<bullet>\\<bullet> ts) =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          (\\<exists>ts'.\n                              ts' =\n                              map dterm\n                               (C\\<^sub>U_args\n                                 (\\<Lambda> t' \\<bullet>\\<bullet>\n                                  ts)) \\<and>\n                              dterm (\\<Lambda> t' \\<bullet>\\<bullet> ts) =\n                              C nm \\<bullet>\\<bullet> ts' \\<and>\n                              length\n                               (C\\<^sub>U_args\n                                 (\\<Lambda> t \\<bullet>\\<bullet> ts)) =\n                              length\n                               (C\\<^sub>U_args\n                                 (\\<Lambda> t' \\<bullet>\\<bullet>\n                                  ts)) \\<and>\n                              (\\<forall>i<length\n     (C\\<^sub>U_args (\\<Lambda> t \\<bullet>\\<bullet> ts)).\n                                  C\\<^sub>U_args\n                                   (\\<Lambda> t \\<bullet>\\<bullet> ts) !\n                                  i \\<Rightarrow>*\n                                  C\\<^sub>U_args\n                                   (\\<Lambda> t' \\<bullet>\\<bullet> ts) !\n                                  i)))\n 5. \\<And>v v' ts tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v';\n        C_normal (term v \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal (term v' \\<bullet>\\<bullet> ts) \\<and>\n                         (dterm (term v \\<bullet>\\<bullet> ts) =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          (\\<exists>ts'.\n                              ts' =\n                              map dterm\n                               (C\\<^sub>U_args\n                                 (term v' \\<bullet>\\<bullet> ts)) \\<and>\n                              dterm (term v' \\<bullet>\\<bullet> ts) =\n                              C nm \\<bullet>\\<bullet> ts' \\<and>\n                              length\n                               (C\\<^sub>U_args\n                                 (term v \\<bullet>\\<bullet> ts)) =\n                              length\n                               (C\\<^sub>U_args\n                                 (term v' \\<bullet>\\<bullet> ts)) \\<and>\n                              (\\<forall>i<length\n     (C\\<^sub>U_args (term v \\<bullet>\\<bullet> ts)).\n                                  C\\<^sub>U_args\n                                   (term v \\<bullet>\\<bullet> ts) !\n                                  i \\<Rightarrow>*\n                                  C\\<^sub>U_args\n                                   (term v' \\<bullet>\\<bullet> ts) !\n                                  i)))\n 6. \\<And>x i t' ts tsa nm.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal (ts ! i) \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            (\\<exists>ts'.\n                ts' = map dterm (C\\<^sub>U_args t') \\<and>\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                length (C\\<^sub>U_args (ts ! i)) =\n                length (C\\<^sub>U_args t') \\<and>\n                (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                    C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                    C\\<^sub>U_args t' ! ia)));\n        C_normal (V x \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal\n                          (V x \\<bullet>\\<bullet> ts[i := t']) \\<and>\n                         (dterm (V x \\<bullet>\\<bullet> ts) =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          (\\<exists>ts'.\n                              ts' =\n                              map dterm\n                               (C\\<^sub>U_args\n                                 (V x \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              dterm (V x \\<bullet>\\<bullet> ts[i := t']) =\n                              C nm \\<bullet>\\<bullet> ts' \\<and>\n                              length\n                               (C\\<^sub>U_args\n                                 (V x \\<bullet>\\<bullet> ts)) =\n                              length\n                               (C\\<^sub>U_args\n                                 (V x \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              (\\<forall>ia<length\n      (C\\<^sub>U_args (V x \\<bullet>\\<bullet> ts)).\n                                  C\\<^sub>U_args\n                                   (V x \\<bullet>\\<bullet> ts) !\n                                  ia \\<Rightarrow>*\n                                  C\\<^sub>U_args\n                                   (V x \\<bullet>\\<bullet> ts[i := t']) !\n                                  ia)))\n 7. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal (ts ! i) \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            (\\<exists>ts'.\n                ts' = map dterm (C\\<^sub>U_args t') \\<and>\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                length (C\\<^sub>U_args (ts ! i)) =\n                length (C\\<^sub>U_args t') \\<and>\n                (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                    C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                    C\\<^sub>U_args t' ! ia)));\n        C_normal (C nm \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal\n                          (C nm \\<bullet>\\<bullet> ts[i := t']) \\<and>\n                         (dterm (C nm \\<bullet>\\<bullet> ts) =\n                          C nma \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          (\\<exists>ts'.\n                              ts' =\n                              map dterm\n                               (C\\<^sub>U_args\n                                 (C nm \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              dterm (C nm \\<bullet>\\<bullet> ts[i := t']) =\n                              C nma \\<bullet>\\<bullet> ts' \\<and>\n                              length\n                               (C\\<^sub>U_args\n                                 (C nm \\<bullet>\\<bullet> ts)) =\n                              length\n                               (C\\<^sub>U_args\n                                 (C nm \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              (\\<forall>ia<length\n      (C\\<^sub>U_args (C nm \\<bullet>\\<bullet> ts)).\n                                  C\\<^sub>U_args\n                                   (C nm \\<bullet>\\<bullet> ts) !\n                                  ia \\<Rightarrow>*\n                                  C\\<^sub>U_args\n                                   (C nm \\<bullet>\\<bullet> ts[i := t']) !\n                                  ia)))\n 8. \\<And>t i t' ts tsa nm.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal (ts ! i) \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            (\\<exists>ts'.\n                ts' = map dterm (C\\<^sub>U_args t') \\<and>\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                length (C\\<^sub>U_args (ts ! i)) =\n                length (C\\<^sub>U_args t') \\<and>\n                (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                    C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                    C\\<^sub>U_args t' ! ia)));\n        C_normal (\\<Lambda> t \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal\n                          (\\<Lambda> t \\<bullet>\\<bullet> ts\n                           [i := t']) \\<and>\n                         (dterm (\\<Lambda> t \\<bullet>\\<bullet> ts) =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          (\\<exists>ts'.\n                              ts' =\n                              map dterm\n                               (C\\<^sub>U_args\n                                 (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              dterm\n                               (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                [i := t']) =\n                              C nm \\<bullet>\\<bullet> ts' \\<and>\n                              length\n                               (C\\<^sub>U_args\n                                 (\\<Lambda> t \\<bullet>\\<bullet> ts)) =\n                              length\n                               (C\\<^sub>U_args\n                                 (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              (\\<forall>ia<length\n      (C\\<^sub>U_args (\\<Lambda> t \\<bullet>\\<bullet> ts)).\n                                  C\\<^sub>U_args\n                                   (\\<Lambda> t \\<bullet>\\<bullet> ts) !\n                                  ia \\<Rightarrow>*\n                                  C\\<^sub>U_args\n                                   (\\<Lambda> t \\<bullet>\\<bullet> ts\n                                    [i := t']) !\n                                  ia)))\n 9. \\<And>v i t' ts tsa nm.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal (ts ! i) \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            (\\<exists>ts'.\n                ts' = map dterm (C\\<^sub>U_args t') \\<and>\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                length (C\\<^sub>U_args (ts ! i)) =\n                length (C\\<^sub>U_args t') \\<and>\n                (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                    C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                    C\\<^sub>U_args t' ! ia)));\n        C_normal (term v \\<bullet>\\<bullet> ts)\\<rbrakk>\n       \\<Longrightarrow> C_normal\n                          (term v \\<bullet>\\<bullet> ts[i := t']) \\<and>\n                         (dterm (term v \\<bullet>\\<bullet> ts) =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          (\\<exists>ts'.\n                              ts' =\n                              map dterm\n                               (C\\<^sub>U_args\n                                 (term v \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              dterm\n                               (term v \\<bullet>\\<bullet> ts[i := t']) =\n                              C nm \\<bullet>\\<bullet> ts' \\<and>\n                              length\n                               (C\\<^sub>U_args\n                                 (term v \\<bullet>\\<bullet> ts)) =\n                              length\n                               (C\\<^sub>U_args\n                                 (term v \\<bullet>\\<bullet> ts\n                                  [i := t'])) \\<and>\n                              (\\<forall>ia<length\n      (C\\<^sub>U_args (term v \\<bullet>\\<bullet> ts)).\n                                  C\\<^sub>U_args\n                                   (term v \\<bullet>\\<bullet> ts) !\n                                  ia \\<Rightarrow>*\n                                  C\\<^sub>U_args\n                                   (term v \\<bullet>\\<bullet> ts[i := t']) !\n                                  ia)))", "apply (simp_all del: map_map)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       (\\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x) \\<and>\n       no_match_compR nm vs \\<Longrightarrow>\n       no_match_R nm (map dterm\\<^sub>M\\<^sub>L (rev vs))\n 2. \\<And>v v' tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v' \\<and>\n                         (dterm\\<^sub>M\\<^sub>L v =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          dterm\\<^sub>M\\<^sub>L v' =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm (C\\<^sub>U_args (term v')) \\<and>\n                          length (C\\<^sub>U_args (term v)) =\n                          length (C\\<^sub>U_args (term v')) \\<and>\n                          (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                              C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                              C\\<^sub>U_args (term v') ! i))\n 3. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 4. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply (metis no_match_R_coincide rev_rev_ident)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v v' tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v' \\<and>\n                         (dterm\\<^sub>M\\<^sub>L v =\n                          C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                          dterm\\<^sub>M\\<^sub>L v' =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm (C\\<^sub>U_args (term v')) \\<and>\n                          length (C\\<^sub>U_args (term v)) =\n                          length (C\\<^sub>U_args (term v')) \\<and>\n                          (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                              C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                              C\\<^sub>U_args (term v') ! i))\n 2. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v v' tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n       \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v'\n 2. \\<And>v v' tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v =\n                         C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                         dterm\\<^sub>M\\<^sub>L v' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args (term v')) \\<and>\n                         length (C\\<^sub>U_args (term v)) =\n                         length (C\\<^sub>U_args (term v')) \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                             C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                             C\\<^sub>U_args (term v') ! i)\n 3. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 4. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply (metis C_normal_ML_inv)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v v' tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v =\n                         C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n                         dterm\\<^sub>M\\<^sub>L v' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args (term v')) \\<and>\n                         length (C\\<^sub>U_args (term v)) =\n                         length (C\\<^sub>U_args (term v')) \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                             C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                             C\\<^sub>U_args (term v') ! i)\n 2. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v v' tsa nm.\n       \\<lbrakk>v \\<Rightarrow> v'; C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> tsa\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args (term v')) \\<and>\n                         length (C\\<^sub>U_args (term v)) =\n                         length (C\\<^sub>U_args (term v')) \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                             C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                             C\\<^sub>U_args (term v') ! i)\n 2. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply(drule (2) C_Red_term_ML)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>v v' tsa nm.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> tsa;\n        dterm\\<^sub>M\\<^sub>L v' =\n        C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args (term v')) \\<and>\n        (length (C\\<^sub>U_args (term v)) =\n         length (C\\<^sub>U_args (term v')) \\<and>\n         (\\<forall>i<length (C\\<^sub>U_args (term v)).\n             C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n             C\\<^sub>U_args (term v') ! i)) \\<and>\n        tsa = map dterm (C\\<^sub>U_args (term v))\\<rbrakk>\n       \\<Longrightarrow> dterm\\<^sub>M\\<^sub>L v' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args (term v')) \\<and>\n                         length (C\\<^sub>U_args (term v)) =\n                         length (C\\<^sub>U_args (term v')) \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args (term v)).\n                             C\\<^sub>U_args (term v) ! i \\<Rightarrow>*\n                             C\\<^sub>U_args (term v') ! i)\n 2. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts x.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x;\n        x \\<in> set (ts[i := t'])\\<rbrakk>\n       \\<Longrightarrow> C_normal x\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply (metis insert_iff subsetD set_update_subset_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        (\\<forall>t\\<in>set ts. C_normal t) \\<and>\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> Ball (set (ts[i := t'])) C_normal \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set (ts[i := t']).\n                             C_normal x) \\<and>\n                         no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (ts[i := t']). C_normal x\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply (metis insert_iff subsetD set_update_subset_insert)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match_R nm (map dterm (ts[i := t'])) \\<and>\n                         (nm = nma \\<and>\n                          map dterm ts = tsa \\<longrightarrow>\n                          (\\<forall>ia<length ts.\n                              ts ! ia \\<Rightarrow>* ts[i := t'] ! ia))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match_R nm (map dterm (ts[i := t']))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm i t' ts tsa nma a aa b.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal; no_match_R a (map dterm ts);\n        (a, aa, b) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm (ts[i := t']))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(drule bspec, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm i t' ts tsa nma a aa b.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal; (a, aa, b) \\<in> R;\n        case (a, aa, b) of\n        (nm', ps, t) \\<Rightarrow>\n          a = nm' \\<longrightarrow> no_match ps (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm (ts[i := t']))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal; (a, aa, b) \\<in> R;\n        no_match aa (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm (ts[i := t']))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(subst no_match.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal; (a, aa, b) \\<in> R;\n        no_match aa (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<min (length (map dterm (ts[i := t'])))\n(length aa).\n                            \\<exists>nm nm' rs rs'.\n                               aa ! ia = C nm \\<bullet>\\<bullet> rs \\<and>\n                               map dterm (ts[i := t']) ! ia =\n                               C nm' \\<bullet>\\<bullet> rs' \\<and>\n                               (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(subst (asm) no_match.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        Ball (set ts) C_normal; (a, aa, b) \\<in> R;\n        \\<exists>i<min (length (map dterm ts)) (length aa).\n           \\<exists>nm nm' rs rs'.\n              aa ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n              map dterm ts ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n              (nm = nm' \\<longrightarrow> no_match rs rs')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<min (length (map dterm (ts[i := t'])))\n(length aa).\n                            \\<exists>nm nm' rs rs'.\n                               aa ! ia = C nm \\<bullet>\\<bullet> rs \\<and>\n                               map dterm (ts[i := t']) ! ia =\n                               C nm' \\<bullet>\\<bullet> rs' \\<and>\n                               (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b ia nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        ia < length ts; ia < length aa;\n        aa ! ia = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! ia) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<length ts.\n                            ia < length aa \\<and>\n                            (\\<exists>nm nm' rs.\n                                aa ! ia = C nm \\<bullet>\\<bullet> rs \\<and>\n                                (\\<exists>rs'.\n                                    map dterm (ts[i := t']) ! ia =\n                                    C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match rs rs')))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(rename_tac j nm nm' rs rs')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ia<length ts.\n                            ia < length aa \\<and>\n                            (\\<exists>nm nm' rs.\n                                aa ! ia = C nm \\<bullet>\\<bullet> rs \\<and>\n                                (\\<exists>rs'.\n                                    map dterm (ts[i := t']) ! ia =\n                                    C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                    (nm = nm' \\<longrightarrow>\n                                     no_match rs rs')))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(rule_tac x=j in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> j < length ts \\<and>\n                         j < length aa \\<and>\n                         (\\<exists>nm nm' rs.\n                             aa ! j = C nm \\<bullet>\\<bullet> rs \\<and>\n                             (\\<exists>rs'.\n                                 map dterm (ts[i := t']) ! j =\n                                 C nm' \\<bullet>\\<bullet> rs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match rs rs')))\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(case_tac \"i=j\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i = j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(erule_tac x=rs' in meta_allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i = j;\n        \\<And>nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> rs' \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(erule_tac x=nm' in meta_allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i = j;\n        C_normal t' \\<and>\n        (dterm (ts ! i) = C nm' \\<bullet>\\<bullet> rs' \\<longrightarrow>\n         dterm t' =\n         C nm' \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n         length (C\\<^sub>U_args (ts ! i)) =\n         length (C\\<^sub>U_args t') \\<and>\n         (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n             C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n             C\\<^sub>U_args t' ! ia))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply (clarsimp simp: all_set_conv_all_nth)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>t' ts a aa b j nm' rs rs'.\n       \\<lbrakk>ts ! j \\<Rightarrow> t';\n        \\<forall>i<length ts. C_normal (ts ! i); (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm' \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs'; no_match rs rs';\n        C_normal t';\n        dterm t' = C nm' \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t');\n        length (C\\<^sub>U_args (ts ! j)) = length (C\\<^sub>U_args t');\n        \\<forall>i<length (C\\<^sub>U_args t').\n           C\\<^sub>U_args (ts ! j) ! i \\<Rightarrow>*\n           C\\<^sub>U_args t' ! i\\<rbrakk>\n       \\<Longrightarrow> no_match rs (map dterm (C\\<^sub>U_args t'))\n 2. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 3. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply(metis C_normal_subterms Red_term_pres_no_match_star)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i t' ts a aa b j nm nm' rs rs'.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>x\\<in>set ts. C_normal x; (a, aa, b) \\<in> R;\n        j < length ts; j < length aa; aa ! j = C nm \\<bullet>\\<bullet> rs;\n        dterm (ts ! j) = C nm' \\<bullet>\\<bullet> rs';\n        nm = nm' \\<longrightarrow> no_match rs rs'; i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' rs'.\n                            dterm (ts[i := t'] ! j) =\n                            C nm' \\<bullet>\\<bullet> rs' \\<and>\n                            (nm = nm' \\<longrightarrow> no_match rs rs')\n 2. \\<And>nm i t' ts tsa nma.\n       \\<lbrakk>i < length ts; ts ! i \\<Rightarrow> t';\n        \\<And>tsa nm.\n           C_normal t' \\<and>\n           (dterm (ts ! i) = C nm \\<bullet>\\<bullet> tsa \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args (ts ! i)) =\n            length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n                C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n                C\\<^sub>U_args t' ! ia));\n        \\<forall>t\\<in>set ts. C_normal t;\n        no_match_R nm (map dterm ts)\\<rbrakk>\n       \\<Longrightarrow> nm = nma \\<and>\n                         map dterm ts = tsa \\<longrightarrow>\n                         (\\<forall>ia<length ts.\n                             ts ! ia \\<Rightarrow>* ts[i := t'] ! ia)", "apply (auto simp:nth_list_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma C_redts: \"t \\<Rightarrow>* t' \\<Longrightarrow> C_normal t \\<Longrightarrow>\n    C_normal t' \\<and> (dterm t = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n    (\\<exists>ts'. dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and> C\\<^sub>U_args t [\\<Rightarrow>*] C\\<^sub>U_args t' \\<and>\n     ts' = map dterm (C\\<^sub>U_args t')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t \\<Rightarrow>* t'; C_normal t\\<rbrakk>\n    \\<Longrightarrow> C_normal t' \\<and>\n                      (dterm t =\n                       C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                       (\\<exists>ts'.\n                           dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                           (length (C\\<^sub>U_args t) =\n                            length (C\\<^sub>U_args t') \\<and>\n                            (\\<forall>i<length (C\\<^sub>U_args t).\n                                C\\<^sub>U_args t ! i \\<Rightarrow>*\n                                C\\<^sub>U_args t' ! i)) \\<and>\n                           ts' = map dterm (C\\<^sub>U_args t')))", "apply(induct arbitrary: nm ts rule:converse_rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm ts.\n       C_normal t' \\<Longrightarrow>\n       C_normal t' \\<and>\n       (dterm t' = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n        (\\<exists>ts'.\n            dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n            (length (C\\<^sub>U_args t') = length (C\\<^sub>U_args t') \\<and>\n             (\\<forall>i<length (C\\<^sub>U_args t').\n                 C\\<^sub>U_args t' ! i \\<Rightarrow>*\n                 C\\<^sub>U_args t' ! i)) \\<and>\n            ts' = map dterm (C\\<^sub>U_args t')))\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm ts.\n       C_normal t' \\<Longrightarrow>\n       dterm t' = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n       ts = map dterm (C\\<^sub>U_args t')\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "using tm_vector_cases[of t']"], ["proof (prove)\nusing this:\n  (\\<exists>n ts. t' = V n \\<bullet>\\<bullet> ts) \\<or>\n  (\\<exists>nm ts. t' = C nm \\<bullet>\\<bullet> ts) \\<or>\n  (\\<exists>t'a ts. t' = \\<Lambda> t'a \\<bullet>\\<bullet> ts) \\<or>\n  (\\<exists>v ts. t' = term v \\<bullet>\\<bullet> ts)\n\ngoal (2 subgoals):\n 1. \\<And>nm ts.\n       C_normal t' \\<Longrightarrow>\n       dterm t' = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n       ts = map dterm (C\\<^sub>U_args t')\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply(elim disjE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>n ts. t' = V n \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 2. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>nm ts. t' = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 3. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>t'a ts. t' = \\<Lambda> t'a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 4. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>v ts. t' = term v \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 5. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>nm ts. t' = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 2. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>t'a ts. t' = \\<Lambda> t'a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 3. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>v ts. t' = term v \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 4. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>t'a ts. t' = \\<Lambda> t'a \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 2. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>v ts. t' = term v \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 3. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm ts.\n       \\<lbrakk>C_normal t';\n        \\<exists>v ts. t' = term v \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         ts = map dterm (C\\<^sub>U_args t')\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm ts v.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply(case_tac v)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>nm ts v x1.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>M\\<^sub>L x1\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x2.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>M\\<^sub>L x2\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>nm ts v x31 x32.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = A\\<^sub>M\\<^sub>L x31 x32\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>nm ts v x4.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 5. \\<And>nm ts v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 6. \\<And>nm ts v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 7. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 8. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 9. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>nm ts v x2.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>M\\<^sub>L x2\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x31 x32.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = A\\<^sub>M\\<^sub>L x31 x32\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>nm ts v x4.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>nm ts v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 5. \\<And>nm ts v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 6. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 7. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 8. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>nm ts v x31 x32.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = A\\<^sub>M\\<^sub>L x31 x32\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x4.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>nm ts v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>nm ts v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 5. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 6. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 7. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>nm ts v x4.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>nm ts v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 5. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 6. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>nm ts v x51 x52.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 5. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>nm ts v x61 x62.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 4. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>nm ts v x71 x72 x73.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 3. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nm ts v x81 x82.\n       \\<lbrakk>C_normal\\<^sub>M\\<^sub>L v; t' = term v;\n        dterm\\<^sub>M\\<^sub>L v = C nm \\<bullet>\\<bullet> ts;\n        v = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> ts = map dterm (C\\<^sub>U_args (term v))\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            (\\<exists>ts'.\n                dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                (length (C\\<^sub>U_args z) =\n                 length (C\\<^sub>U_args t') \\<and>\n                 (\\<forall>i<length (C\\<^sub>U_args z).\n                     C\\<^sub>U_args z ! i \\<Rightarrow>*\n                     C\\<^sub>U_args t' ! i)) \\<and>\n                ts' = map dterm (C\\<^sub>U_args t')));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          (\\<exists>ts'.\n                              dterm t' = C nm \\<bullet>\\<bullet> ts' \\<and>\n                              (length (C\\<^sub>U_args y) =\n                               length (C\\<^sub>U_args t') \\<and>\n                               (\\<forall>i<length (C\\<^sub>U_args y).\n                                   C\\<^sub>U_args y ! i \\<Rightarrow>*\n                                   C\\<^sub>U_args t' ! i)) \\<and>\n                              ts' = map dterm (C\\<^sub>U_args t')))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          dterm t' =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm (C\\<^sub>U_args t') \\<and>\n                          length (C\\<^sub>U_args y) =\n                          length (C\\<^sub>U_args t') \\<and>\n                          (\\<forall>i<length (C\\<^sub>U_args y).\n                              C\\<^sub>U_args y ! i \\<Rightarrow>*\n                              C\\<^sub>U_args t' ! i))", "apply(frule_tac nm=nm and ts=\"ts\" in C_redt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y\\<rbrakk>\n       \\<Longrightarrow> C_normal y\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y;\n        C_normal z \\<and>\n        (dterm y = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n         (\\<exists>ts'.\n             ts' = map dterm (C\\<^sub>U_args z) \\<and>\n             dterm z = C nm \\<bullet>\\<bullet> ts' \\<and>\n             length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z) \\<and>\n             (\\<forall>i<length (C\\<^sub>U_args y).\n                 C\\<^sub>U_args y ! i \\<Rightarrow>*\n                 C\\<^sub>U_args z ! i)))\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          dterm t' =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm (C\\<^sub>U_args t') \\<and>\n                          length (C\\<^sub>U_args y) =\n                          length (C\\<^sub>U_args t') \\<and>\n                          (\\<forall>i<length (C\\<^sub>U_args y).\n                              C\\<^sub>U_args y ! i \\<Rightarrow>*\n                              C\\<^sub>U_args t' ! i))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y;\n        C_normal z \\<and>\n        (dterm y = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n         (\\<exists>ts'.\n             ts' = map dterm (C\\<^sub>U_args z) \\<and>\n             dterm z = C nm \\<bullet>\\<bullet> ts' \\<and>\n             length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z) \\<and>\n             (\\<forall>i<length (C\\<^sub>U_args y).\n                 C\\<^sub>U_args y ! i \\<Rightarrow>*\n                 C\\<^sub>U_args z ! i)))\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          dterm t' =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm (C\\<^sub>U_args t') \\<and>\n                          length (C\\<^sub>U_args y) =\n                          length (C\\<^sub>U_args t') \\<and>\n                          (\\<forall>i<length (C\\<^sub>U_args y).\n                              C\\<^sub>U_args y ! i \\<Rightarrow>*\n                              C\\<^sub>U_args t' ! i))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z;\n        dterm y = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' = map dterm (C\\<^sub>U_args z) \\<and>\n            dterm z = C nm \\<bullet>\\<bullet> ts' \\<and>\n            length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z) \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args y).\n                C\\<^sub>U_args y ! i \\<Rightarrow>*\n                C\\<^sub>U_args z ! i))\\<rbrakk>\n       \\<Longrightarrow> C_normal t' \\<and>\n                         (dterm y =\n                          C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                          dterm t' =\n                          C nm \\<bullet>\\<bullet>\n                          map dterm (C\\<^sub>U_args t') \\<and>\n                          length (C\\<^sub>U_args y) =\n                          length (C\\<^sub>U_args t') \\<and>\n                          (\\<forall>i<length (C\\<^sub>U_args y).\n                              C\\<^sub>U_args y ! i \\<Rightarrow>*\n                              C\\<^sub>U_args t' ! i))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z;\n        dterm y = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' = map dterm (C\\<^sub>U_args z) \\<and>\n            dterm z = C nm \\<bullet>\\<bullet> ts' \\<and>\n            length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z) \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args y).\n                C\\<^sub>U_args y ! i \\<Rightarrow>*\n                C\\<^sub>U_args z ! i))\\<rbrakk>\n       \\<Longrightarrow> C_normal t'\n 2. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z;\n        dterm y = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' = map dterm (C\\<^sub>U_args z) \\<and>\n            dterm z = C nm \\<bullet>\\<bullet> ts' \\<and>\n            length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z) \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args y).\n                C\\<^sub>U_args y ! i \\<Rightarrow>*\n                C\\<^sub>U_args z ! i))\\<rbrakk>\n       \\<Longrightarrow> dterm y =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         dterm t' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args t') \\<and>\n                         length (C\\<^sub>U_args y) =\n                         length (C\\<^sub>U_args t') \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args y).\n                             C\\<^sub>U_args y ! i \\<Rightarrow>*\n                             C\\<^sub>U_args t' ! i)", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z;\n        dterm y = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n        (\\<exists>ts'.\n            ts' = map dterm (C\\<^sub>U_args z) \\<and>\n            dterm z = C nm \\<bullet>\\<bullet> ts' \\<and>\n            length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z) \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args y).\n                C\\<^sub>U_args y ! i \\<Rightarrow>*\n                C\\<^sub>U_args z ! i))\\<rbrakk>\n       \\<Longrightarrow> dterm y =\n                         C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n                         dterm t' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args t') \\<and>\n                         length (C\\<^sub>U_args y) =\n                         length (C\\<^sub>U_args t') \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args y).\n                             C\\<^sub>U_args y ! i \\<Rightarrow>*\n                             C\\<^sub>U_args t' ! i)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts ts'.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nm ts.\n           C_normal z \\<Longrightarrow>\n           C_normal t' \\<and>\n           (dterm z = C nm \\<bullet>\\<bullet> ts \\<longrightarrow>\n            dterm t' =\n            C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z; dterm y = C nm \\<bullet>\\<bullet> ts;\n        dterm z = C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args z);\n        length (C\\<^sub>U_args y) = length (C\\<^sub>U_args z);\n        \\<forall>i<length (C\\<^sub>U_args y).\n           C\\<^sub>U_args y ! i \\<Rightarrow>* C\\<^sub>U_args z ! i\\<rbrakk>\n       \\<Longrightarrow> dterm t' =\n                         C nm \\<bullet>\\<bullet>\n                         map dterm (C\\<^sub>U_args t') \\<and>\n                         length (C\\<^sub>U_args y) =\n                         length (C\\<^sub>U_args t') \\<and>\n                         (\\<forall>i<length (C\\<^sub>U_args y).\n                             C\\<^sub>U_args y ! i \\<Rightarrow>*\n                             C\\<^sub>U_args t' ! i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nma ts.\n           C_normal t' \\<and>\n           (nm = nma \\<and>\n            map dterm (C\\<^sub>U_args z) = ts \\<longrightarrow>\n            dterm t' =\n            C nma \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z; dterm y = C nm \\<bullet>\\<bullet> ts;\n        dterm z = C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args z);\n        length (C\\<^sub>U_args y) = length (C\\<^sub>U_args t');\n        \\<forall>i<length (C\\<^sub>U_args t').\n           C\\<^sub>U_args y ! i \\<Rightarrow>* C\\<^sub>U_args z ! i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i<length (C\\<^sub>U_args t').\n                            C\\<^sub>U_args y ! i \\<Rightarrow>*\n                            C\\<^sub>U_args t' ! i", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z nm ts i.\n       \\<lbrakk>y \\<Rightarrow> z; z \\<Rightarrow>* t';\n        \\<And>nma ts.\n           C_normal t' \\<and>\n           (nm = nma \\<and>\n            map dterm (C\\<^sub>U_args z) = ts \\<longrightarrow>\n            dterm t' =\n            C nma \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args t') \\<and>\n            length (C\\<^sub>U_args z) = length (C\\<^sub>U_args t') \\<and>\n            (\\<forall>i<length (C\\<^sub>U_args z).\n                C\\<^sub>U_args z ! i \\<Rightarrow>* C\\<^sub>U_args t' ! i));\n        C_normal y; C_normal z; dterm y = C nm \\<bullet>\\<bullet> ts;\n        dterm z = C nm \\<bullet>\\<bullet> map dterm (C\\<^sub>U_args z);\n        length (C\\<^sub>U_args y) = length (C\\<^sub>U_args t');\n        \\<forall>i<length (C\\<^sub>U_args t').\n           C\\<^sub>U_args y ! i \\<Rightarrow>* C\\<^sub>U_args z ! i\\<rbrakk>\n       \\<Longrightarrow> i < length (C\\<^sub>U_args t') \\<longrightarrow>\n                         C\\<^sub>U_args y ! i \\<Rightarrow>*\n                         C\\<^sub>U_args t' ! i", "apply (metis rtrancl_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_match_preserved:\n  \"\\<forall>t\\<in>set ts. C_normal t \\<Longrightarrow> ts [\\<Rightarrow>*] ts'\n   \\<Longrightarrow> no_match ps os \\<Longrightarrow> os = map dterm ts \\<Longrightarrow> no_match ps (map dterm ts')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t\\<in>set ts. C_normal t;\n     length ts = length ts' \\<and>\n     (\\<forall>i<length ts. ts ! i \\<Rightarrow>* ts' ! i);\n     no_match ps os; os = map dterm ts\\<rbrakk>\n    \\<Longrightarrow> no_match ps (map dterm ts')", "proof(induct ps os arbitrary: ts ts' rule: no_match.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "case (1 ps os)"], ["proof (state)\nthis:\n  \\<lbrakk>?x < min (length os) (length ps);\n   ps ! ?x = C ?xa \\<bullet>\\<bullet> ?xc;\n   os ! ?x = C ?xb \\<bullet>\\<bullet> ?xd; ?xa = ?xb;\n   \\<forall>a\\<in>set ?ts. C_normal a;\n   length ?ts = length ?ts' \\<and>\n   (\\<forall>i<length ?ts. ?ts ! i \\<Rightarrow>* ?ts' ! i);\n   no_match ?xc ?xd; ?xd = map dterm ?ts\\<rbrakk>\n  \\<Longrightarrow> no_match ?xc (map dterm ?ts')\n  \\<forall>a\\<in>set ts. C_normal a\n  length ts = length ts' \\<and>\n  (\\<forall>i<length ts. ts ! i \\<Rightarrow>* ts' ! i)\n  no_match ps os\n  os = map dterm ts\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "obtain i nm nm' ps' os' where a: \"ps!i = C nm  \\<bullet>\\<bullet> ps'\" \"i < size ps\"\n      \"i < size os\" \"os!i = C nm' \\<bullet>\\<bullet> os'\" \"nm=nm' \\<longrightarrow> no_match ps' os'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i nm ps' nm' os'.\n        \\<lbrakk>ps ! i = C nm \\<bullet>\\<bullet> ps'; i < length ps;\n         i < length os; os ! i = C nm' \\<bullet>\\<bullet> os';\n         nm = nm' \\<longrightarrow> no_match ps' os'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1(4) no_match.simps[of ps os]"], ["proof (prove)\nusing this:\n  no_match ps os\n  no_match ps os =\n  (\\<exists>i<min (length os) (length ps).\n      \\<exists>nm nm' rs rs'.\n         ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n         os ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n         (nm = nm' \\<longrightarrow> no_match rs rs'))\n\ngoal (1 subgoal):\n 1. (\\<And>i nm ps' nm' os'.\n        \\<lbrakk>ps ! i = C nm \\<bullet>\\<bullet> ps'; i < length ps;\n         i < length os; os ! i = C nm' \\<bullet>\\<bullet> os';\n         nm = nm' \\<longrightarrow> no_match ps' os'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  ps ! i = C nm \\<bullet>\\<bullet> ps'\n  i < length ps\n  i < length os\n  os ! i = C nm' \\<bullet>\\<bullet> os'\n  nm = nm' \\<longrightarrow> no_match ps' os'\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "note 1(5)[simp]"], ["proof (state)\nthis:\n  os = map dterm ts\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "have \"C_normal (ts ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal (ts ! i)", "using 1(2) \\<open>i < size os\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ts. C_normal a\n  i < length os\n\ngoal (1 subgoal):\n 1. C_normal (ts ! i)", "by auto"], ["proof (state)\nthis:\n  C_normal (ts ! i)\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "have \"ts!i \\<Rightarrow>* ts'!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts ! i \\<Rightarrow>* ts' ! i", "using 1(3) \\<open>i < size os\\<close>"], ["proof (prove)\nusing this:\n  length ts = length ts' \\<and>\n  (\\<forall>i<length ts. ts ! i \\<Rightarrow>* ts' ! i)\n  i < length os\n\ngoal (1 subgoal):\n 1. ts ! i \\<Rightarrow>* ts' ! i", "by auto"], ["proof (state)\nthis:\n  ts ! i \\<Rightarrow>* ts' ! i\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "have \"dterm (ts ! i) = C nm' \\<bullet>\\<bullet> os'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dterm (ts ! i) = C nm' \\<bullet>\\<bullet> os'", "using \\<open>os!i = C nm' \\<bullet>\\<bullet> os'\\<close> \\<open>i < size os\\<close>"], ["proof (prove)\nusing this:\n  os ! i = C nm' \\<bullet>\\<bullet> os'\n  i < length os\n\ngoal (1 subgoal):\n 1. dterm (ts ! i) = C nm' \\<bullet>\\<bullet> os'", "by (simp add:nth_map)"], ["proof (state)\nthis:\n  dterm (ts ! i) = C nm' \\<bullet>\\<bullet> os'\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "with C_redts [OF \\<open>ts!i \\<Rightarrow>* ts'!i\\<close> \\<open>C_normal (ts!i)\\<close>]\n    C_normal_subterm[OF \\<open>C_normal (ts!i)\\<close>]\n    C_normal_subterms[OF \\<open>C_normal (ts!i)\\<close>]"], ["proof (chain)\npicking this:\n  C_normal (ts' ! i) \\<and>\n  (dterm (ts ! i) = C ?nm \\<bullet>\\<bullet> ?ts \\<longrightarrow>\n   (\\<exists>ts'.\n       dterm (ts' ! i) = C ?nm \\<bullet>\\<bullet> ts' \\<and>\n       (length (C\\<^sub>U_args (ts ! i)) =\n        length (C\\<^sub>U_args (ts' ! i)) \\<and>\n        (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n            C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n            C\\<^sub>U_args (ts' ! i) ! ia)) \\<and>\n       ts' = map dterm (C\\<^sub>U_args (ts' ! i))))\n  \\<lbrakk>dterm (ts ! i) = C ?nm \\<bullet>\\<bullet> ?ts;\n   ?s \\<in> set (C\\<^sub>U_args (ts ! i))\\<rbrakk>\n  \\<Longrightarrow> C_normal ?s\n  dterm (ts ! i) = C ?nm \\<bullet>\\<bullet> ?ts \\<Longrightarrow>\n  ?ts = map dterm (C\\<^sub>U_args (ts ! i))\n  dterm (ts ! i) = C nm' \\<bullet>\\<bullet> os'", "obtain ss' rs rs' :: \"tm list\" where b: \"\\<forall>t\\<in>set rs. C_normal t\"\n    \"dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> ss'\" \"length rs = length rs'\"\n    \"\\<forall>i<length rs. rs ! i \\<Rightarrow>* rs' ! i\" \"ss' = map dterm rs'\" \"os' = map dterm rs\""], ["proof (prove)\nusing this:\n  C_normal (ts' ! i) \\<and>\n  (dterm (ts ! i) = C ?nm \\<bullet>\\<bullet> ?ts \\<longrightarrow>\n   (\\<exists>ts'.\n       dterm (ts' ! i) = C ?nm \\<bullet>\\<bullet> ts' \\<and>\n       (length (C\\<^sub>U_args (ts ! i)) =\n        length (C\\<^sub>U_args (ts' ! i)) \\<and>\n        (\\<forall>ia<length (C\\<^sub>U_args (ts ! i)).\n            C\\<^sub>U_args (ts ! i) ! ia \\<Rightarrow>*\n            C\\<^sub>U_args (ts' ! i) ! ia)) \\<and>\n       ts' = map dterm (C\\<^sub>U_args (ts' ! i))))\n  \\<lbrakk>dterm (ts ! i) = C ?nm \\<bullet>\\<bullet> ?ts;\n   ?s \\<in> set (C\\<^sub>U_args (ts ! i))\\<rbrakk>\n  \\<Longrightarrow> C_normal ?s\n  dterm (ts ! i) = C ?nm \\<bullet>\\<bullet> ?ts \\<Longrightarrow>\n  ?ts = map dterm (C\\<^sub>U_args (ts ! i))\n  dterm (ts ! i) = C nm' \\<bullet>\\<bullet> os'\n\ngoal (1 subgoal):\n 1. (\\<And>rs ss' rs'.\n        \\<lbrakk>\\<forall>t\\<in>set rs. C_normal t;\n         dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> ss';\n         length rs = length rs';\n         \\<forall>i<length rs. rs ! i \\<Rightarrow>* rs' ! i;\n         ss' = map dterm rs'; os' = map dterm rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set rs. C_normal t\n  dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> ss'\n  length rs = length rs'\n  \\<forall>i<length rs. rs ! i \\<Rightarrow>* rs' ! i\n  ss' = map dterm rs'\n  os' = map dterm rs\n\ngoal (1 subgoal):\n 1. \\<And>ps ts tsa ts'.\n       \\<lbrakk>\\<And>x xa xb xc xd tsa ts'.\n                   \\<lbrakk>x < min (length ts) (length ps);\n                    ps ! x = C xa \\<bullet>\\<bullet> xc;\n                    ts ! x = C xb \\<bullet>\\<bullet> xd; xa = xb;\n                    Ball (set tsa) C_normal;\n                    length tsa = length ts' \\<and>\n                    (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n                    no_match xc xd; xd = map dterm tsa\\<rbrakk>\n                   \\<Longrightarrow> no_match xc (map dterm ts');\n        Ball (set tsa) C_normal;\n        length tsa = length ts' \\<and>\n        (\\<forall>i<length tsa. tsa ! i \\<Rightarrow>* ts' ! i);\n        no_match ps ts; ts = map dterm tsa\\<rbrakk>\n       \\<Longrightarrow> no_match ps (map dterm ts')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match ps (map dterm ts')", "apply(subst no_match.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<min (length (map dterm ts')) (length ps).\n       \\<exists>nm nm' rs rs'.\n          ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n          map dterm ts' ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n          (nm = nm' \\<longrightarrow> no_match rs rs')", "apply(rule_tac x=i in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < min (length (map dterm ts')) (length ps) \\<and>\n    (\\<exists>nm nm' rs rs'.\n        ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n        map dterm ts' ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n        (nm = nm' \\<longrightarrow> no_match rs rs'))", "using 1(2-5) a b"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set ts. C_normal a\n  length ts = length ts' \\<and>\n  (\\<forall>i<length ts. ts ! i \\<Rightarrow>* ts' ! i)\n  no_match ps os\n  os = map dterm ts\n  ps ! i = C nm \\<bullet>\\<bullet> ps'\n  i < length ps\n  i < length os\n  os ! i = C nm' \\<bullet>\\<bullet> os'\n  nm = nm' \\<longrightarrow> no_match ps' os'\n  \\<forall>t\\<in>set rs. C_normal t\n  dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> ss'\n  length rs = length rs'\n  \\<forall>i<length rs. rs ! i \\<Rightarrow>* rs' ! i\n  ss' = map dterm rs'\n  os' = map dterm rs\n\ngoal (1 subgoal):\n 1. i < min (length (map dterm ts')) (length ps) \\<and>\n    (\\<exists>nm nm' rs rs'.\n        ps ! i = C nm \\<bullet>\\<bullet> rs \\<and>\n        map dterm ts' ! i = C nm' \\<bullet>\\<bullet> rs' \\<and>\n        (nm = nm' \\<longrightarrow> no_match rs rs'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> no_match ps' (map dterm rs')", "apply(rule 1(1)[of i nm' _ nm' \"map dterm rs\" rs])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> i < min (length os) (length ps)\n 2. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> ps ! i = C nm' \\<bullet>\\<bullet> ps'\n 3. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> os ! i = C nm' \\<bullet>\\<bullet> map dterm rs\n 4. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> nm' = nm'\n 5. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a\\<in>set rs. C_normal a\n 6. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> length rs = length rs' \\<and>\n                      (\\<forall>i<length rs. rs ! i \\<Rightarrow>* rs' ! i)\n 7. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> no_match ps' (map dterm rs)\n 8. \\<lbrakk>\\<forall>a\\<in>set ts. C_normal a; no_match ps (map dterm ts);\n     ps ! i = C nm' \\<bullet>\\<bullet> ps'; i < length ps; i < length ts';\n     dterm (ts ! i) = C nm' \\<bullet>\\<bullet> map dterm rs;\n     no_match ps' (map dterm rs); \\<forall>x\\<in>set rs. C_normal x;\n     dterm (ts' ! i) = C nm' \\<bullet>\\<bullet> map dterm rs';\n     length rs = length rs';\n     \\<forall>i<length rs'. rs ! i \\<Rightarrow>* rs' ! i;\n     ss' = map dterm rs'; os' = map dterm rs; length ts = length ts';\n     \\<forall>i<length ts'. ts ! i \\<Rightarrow>* ts' ! i; nm = nm'\\<rbrakk>\n    \\<Longrightarrow> map dterm rs = map dterm rs", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  no_match ps (map dterm ts')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lam_Red_term_itE:\n  \"(\\<Lambda> t, t') : Red_term^^i \\<Longrightarrow> \\<exists>t''. t' = \\<Lambda> t'' \\<and> (t,t'') : Red_term^^i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n    \\<exists>t''. t' = \\<Lambda> t'' \\<and> (t, t'') \\<in> Red_term ^^ i", "apply(induct i arbitrary: t')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t'.\n       (\\<Lambda> t, t') \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>t''. t' = \\<Lambda> t'' \\<and> (t, t'') \\<in> Red_term ^^ 0\n 2. \\<And>i t'.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, t') \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i t'.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, t') \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i", "apply(erule relpow_Suc_E)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i t' y.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i", "apply(erule Red_term.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i t' y nm vs.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = term (C\\<^sub>U nm vs);\n        t' = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i\n 2. \\<And>i t' y x vs.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = term (V\\<^sub>U x vs);\n        t' = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i\n 3. \\<And>i t' y vf vs n.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = term (Clo vf vs n);\n        t' =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i\n 4. \\<And>i t' y ta t'a.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = \\<Lambda> ta;\n        t' = \\<Lambda> t'a; ta \\<Rightarrow> t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i\n 5. \\<And>i t' y s s' ta.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = s \\<bullet> ta;\n        t' = s' \\<bullet> ta; s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i\n 6. \\<And>i t' y ta t'a s.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = s \\<bullet> ta;\n        t' = s \\<bullet> t'a; ta \\<Rightarrow> t'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i\n 7. \\<And>i t' y v v'.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, y) \\<in> Red_term ^^ i; y = term v; t' = term v';\n        v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t''.\n                            t' = \\<Lambda> t'' \\<and>\n                            (t, t'') \\<in> Red_term ^^ Suc i", "apply (simp_all)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i t' y nm vs.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, term (C\\<^sub>U nm vs)) \\<in> Red_term ^^ i;\n        y = term (C\\<^sub>U nm vs);\n        t' = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i t' y x vs.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, term (V\\<^sub>U x vs)) \\<in> Red_term ^^ i;\n        y = term (V\\<^sub>U x vs);\n        t' = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>i t' y vf vs n.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, term (Clo vf vs n)) \\<in> Red_term ^^ i;\n        y = term (Clo vf vs n);\n        t' =\n        \\<Lambda>\n         (term\n           (apply (Clo (lift 0 vf) (map (lift 0) vs) n)\n             (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> (t, term\n                              (apply (Clo (lift 0 vf) (map (lift 0) vs) n)\n                                (V\\<^sub>U 0 [])))\n                         \\<in> Red_term ^^ i O Red_term\n 4. \\<And>i t' y ta t'a.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, \\<Lambda> ta) \\<in> Red_term ^^ i; y = \\<Lambda> ta;\n        t' = \\<Lambda> t'a; ta \\<Rightarrow> t'a\\<rbrakk>\n       \\<Longrightarrow> (t, t'a) \\<in> Red_term ^^ i O Red_term\n 5. \\<And>i t' y s s' ta.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, s \\<bullet> ta) \\<in> Red_term ^^ i;\n        y = s \\<bullet> ta; t' = s' \\<bullet> ta;\n        s \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>i t' y ta t'a s.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, s \\<bullet> ta) \\<in> Red_term ^^ i;\n        y = s \\<bullet> ta; t' = s \\<bullet> t'a;\n        ta \\<Rightarrow> t'a\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>i t' y v v'.\n       \\<lbrakk>\\<And>t'.\n                   (\\<Lambda> t, t') \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>t''.\n                      t' = \\<Lambda> t'' \\<and>\n                      (t, t'') \\<in> Red_term ^^ i;\n        (\\<Lambda> t, term v) \\<in> Red_term ^^ i; y = term v; t' = term v';\n        v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> False", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Red_term_it: \"(V x \\<bullet>\\<bullet> rs, r) : Red_term^^i\n  \\<Longrightarrow> \\<exists>ts is. r = V x \\<bullet>\\<bullet> ts \\<and> size ts = size rs & size is = size rs \\<and>\n       (\\<forall>j<size ts. (rs!j, ts!j) : Red_term^^(is!j) \\<and> is!j <= i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ i \\<Longrightarrow>\n    \\<exists>ts is.\n       r = V x \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> i)", "proof(induct i arbitrary:rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = V x \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "case 0"], ["proof (state)\nthis:\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = V x \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "moreover"], ["proof (state)\nthis:\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = V x \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "have \"\\<exists>is. length is = length rs \\<and>\n   (\\<forall>j<size rs. (rs!j, rs!j) \\<in> Red_term ^^ is!j \\<and> is!j = 0)\" (is \"\\<exists>is. ?P is\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>is.\n       length is = length rs \\<and>\n       (\\<forall>j<length rs.\n           (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. length ?is = length rs \\<and>\n    (\\<forall>j<length rs.\n        (rs ! j, rs ! j) \\<in> Red_term ^^ ?is ! j \\<and> ?is ! j = 0)", "show \"?P(replicate (size rs) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate (length rs) 0) = length rs \\<and>\n    (\\<forall>j<length rs.\n        (rs ! j, rs ! j)\n        \\<in> Red_term ^^ replicate (length rs) 0 ! j \\<and>\n        replicate (length rs) 0 ! j = 0)", "by simp"], ["proof (state)\nthis:\n  length (replicate (length rs) 0) = length rs \\<and>\n  (\\<forall>j<length rs.\n      (rs ! j, rs ! j) \\<in> Red_term ^^ replicate (length rs) 0 ! j \\<and>\n      replicate (length rs) 0 ! j = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>is.\n     length is = length rs \\<and>\n     (\\<forall>j<length rs.\n         (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = V x \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "ultimately"], ["proof (chain)\npicking this:\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n  \\<exists>is.\n     length is = length rs \\<and>\n     (\\<forall>j<length rs.\n         (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)", "show ?case"], ["proof (prove)\nusing this:\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n  \\<exists>is.\n     length is = length rs \\<and>\n     (\\<forall>j<length rs.\n         (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>ts is.\n       r = V x \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ts is.\n     r = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length rs \\<and>\n     length is = length rs \\<and>\n     (\\<forall>j<length ts.\n         (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "case (Suc i rs)"], ["proof (state)\nthis:\n  (V x \\<bullet>\\<bullet> ?rs, r) \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length ?rs \\<and>\n     length is = length ?rs \\<and>\n     (\\<forall>j<length ts.\n         (?rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> i)\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "from \\<open>(V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<close>"], ["proof (chain)\npicking this:\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i", "obtain r' where r': \"V x \\<bullet>\\<bullet> rs \\<Rightarrow> r'\" and \"(r',r) \\<in> Red_term ^^ i\""], ["proof (prove)\nusing this:\n  (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>V x \\<bullet>\\<bullet> rs \\<Rightarrow> r';\n         (r', r) \\<in> Red_term ^^ i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis relpow_Suc_D2)"], ["proof (state)\nthis:\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> r'\n  (r', r) \\<in> Red_term ^^ i\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "from r'"], ["proof (chain)\npicking this:\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> r'", "have \"\\<exists>k<size rs. \\<exists>s. rs!k \\<Rightarrow> s \\<and> r' = V x \\<bullet>\\<bullet> rs[k:=s]\""], ["proof (prove)\nusing this:\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<exists>k<length rs.\n       \\<exists>s.\n          rs ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> rs[k := s]", "proof(induct rs arbitrary: r' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r'.\n       V x \\<bullet>\\<bullet> [] \\<Rightarrow> r' \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>s.\n             [] ! k \\<Rightarrow> s \\<and>\n             r' = V x \\<bullet>\\<bullet> [][k := s]\n 2. \\<And>xa xs r'.\n       \\<lbrakk>\\<And>r'.\n                   V x \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = V x \\<bullet>\\<bullet> xs[k := s];\n        V x \\<bullet>\\<bullet> (xs @ [xa]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [xa]).\n                            \\<exists>s.\n                               (xs @ [xa]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (xs @ [xa])[k := s]", "case Nil"], ["proof (state)\nthis:\n  V x \\<bullet>\\<bullet> [] \\<Rightarrow> r'\n\ngoal (2 subgoals):\n 1. \\<And>r'.\n       V x \\<bullet>\\<bullet> [] \\<Rightarrow> r' \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>s.\n             [] ! k \\<Rightarrow> s \\<and>\n             r' = V x \\<bullet>\\<bullet> [][k := s]\n 2. \\<And>xa xs r'.\n       \\<lbrakk>\\<And>r'.\n                   V x \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = V x \\<bullet>\\<bullet> xs[k := s];\n        V x \\<bullet>\\<bullet> (xs @ [xa]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [xa]).\n                            \\<exists>s.\n                               (xs @ [xa]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (xs @ [xa])[k := s]", "thus ?case"], ["proof (prove)\nusing this:\n  V x \\<bullet>\\<bullet> [] \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<exists>k<length [].\n       \\<exists>s.\n          [] ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> [][k := s]", "by(fastforce elim: Red_term.cases)"], ["proof (state)\nthis:\n  \\<exists>k<length [].\n     \\<exists>s.\n        [] ! k \\<Rightarrow> s \\<and> r' = V x \\<bullet>\\<bullet> [][k := s]\n\ngoal (1 subgoal):\n 1. \\<And>xa xs r'.\n       \\<lbrakk>\\<And>r'.\n                   V x \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = V x \\<bullet>\\<bullet> xs[k := s];\n        V x \\<bullet>\\<bullet> (xs @ [xa]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [xa]).\n                            \\<exists>s.\n                               (xs @ [xa]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (xs @ [xa])[k := s]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs r'.\n       \\<lbrakk>\\<And>r'.\n                   V x \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = V x \\<bullet>\\<bullet> xs[k := s];\n        V x \\<bullet>\\<bullet> (xs @ [xa]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [xa]).\n                            \\<exists>s.\n                               (xs @ [xa]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (xs @ [xa])[k := s]", "case (snoc r rs)"], ["proof (state)\nthis:\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> ?r' \\<Longrightarrow>\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        ?r' = V x \\<bullet>\\<bullet> rs[k := s]\n  V x \\<bullet>\\<bullet> (rs @ [r]) \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<And>xa xs r'.\n       \\<lbrakk>\\<And>r'.\n                   V x \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = V x \\<bullet>\\<bullet> xs[k := s];\n        V x \\<bullet>\\<bullet> (xs @ [xa]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [xa]).\n                            \\<exists>s.\n                               (xs @ [xa]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (xs @ [xa])[k := s]", "hence \"(V x \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'\""], ["proof (prove)\nusing this:\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> ?r' \\<Longrightarrow>\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        ?r' = V x \\<bullet>\\<bullet> rs[k := s]\n  V x \\<bullet>\\<bullet> (rs @ [r]) \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. (V x \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'", "by simp"], ["proof (state)\nthis:\n  (V x \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<And>xa xs r'.\n       \\<lbrakk>\\<And>r'.\n                   V x \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = V x \\<bullet>\\<bullet> xs[k := s];\n        V x \\<bullet>\\<bullet> (xs @ [xa]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [xa]).\n                            \\<exists>s.\n                               (xs @ [xa]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (xs @ [xa])[k := s]", "thus ?case"], ["proof (prove)\nusing this:\n  (V x \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "proof(cases rule:Red_term.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>r' = s' \\<bullet> r;\n        V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n 2. \\<And>t'.\n       \\<lbrakk>r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "case (ctxt_At1 s')"], ["proof (state)\nthis:\n  r' = s' \\<bullet> r\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>r' = s' \\<bullet> r;\n        V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n 2. \\<And>t'.\n       \\<lbrakk>r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "then"], ["proof (chain)\npicking this:\n  r' = s' \\<bullet> r\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'", "obtain k s'' where aux: \"k<length rs\" \"rs ! k \\<Rightarrow> s''\" \"s' = V x \\<bullet>\\<bullet> rs[k := s'']\""], ["proof (prove)\nusing this:\n  r' = s' \\<bullet> r\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n\ngoal (1 subgoal):\n 1. (\\<And>k s''.\n        \\<lbrakk>k < length rs; rs ! k \\<Rightarrow> s'';\n         s' = V x \\<bullet>\\<bullet> rs[k := s'']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc(1)"], ["proof (prove)\nusing this:\n  r' = s' \\<bullet> r\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> ?r' \\<Longrightarrow>\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        ?r' = V x \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. (\\<And>k s''.\n        \\<lbrakk>k < length rs; rs ! k \\<Rightarrow> s'';\n         s' = V x \\<bullet>\\<bullet> rs[k := s'']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  k < length rs\n  rs ! k \\<Rightarrow> s''\n  s' = V x \\<bullet>\\<bullet> rs[k := s'']\n\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>r' = s' \\<bullet> r;\n        V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n 2. \\<And>t'.\n       \\<lbrakk>r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "show ?thesis (is \"\\<exists>k < ?n. \\<exists>s. ?P k s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "have \"k<?n \\<and> ?P k s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n    r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s'']", "using ctxt_At1 aux"], ["proof (prove)\nusing this:\n  r' = s' \\<bullet> r\n  V x \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n  k < length rs\n  rs ! k \\<Rightarrow> s''\n  s' = V x \\<bullet>\\<bullet> rs[k := s'']\n\ngoal (1 subgoal):\n 1. k < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n    r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s'']", "by (simp add:nth_append) (metis last_snoc butlast_snoc list_update_append1)"], ["proof (state)\nthis:\n  k < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n  r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s'']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n  r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s'']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "by blast"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "case (ctxt_At2 t')"], ["proof (state)\nthis:\n  r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t'\n  r \\<Rightarrow> t'\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "show ?thesis (is \"\\<exists>k < ?n. \\<exists>s. ?P k s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "have \"size rs<?n \\<and> ?P (size rs) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rs < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n    r' = V x \\<bullet>\\<bullet> (rs @ [r])[length rs := t']", "using ctxt_At2"], ["proof (prove)\nusing this:\n  r' = (V x \\<bullet>\\<bullet> rs) \\<bullet> t'\n  r \\<Rightarrow> t'\n\ngoal (1 subgoal):\n 1. length rs < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n    r' = V x \\<bullet>\\<bullet> (rs @ [r])[length rs := t']", "by simp"], ["proof (state)\nthis:\n  length rs < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n  r' = V x \\<bullet>\\<bullet> (rs @ [r])[length rs := t']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "thus ?thesis"], ["proof (prove)\nusing this:\n  length rs < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n  r' = V x \\<bullet>\\<bullet> (rs @ [r])[length rs := t']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]", "by blast"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = V x \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and> r' = V x \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and> r' = V x \\<bullet>\\<bullet> rs[k := s]", "obtain k s where \"k<size rs\" \"rs!k \\<Rightarrow> s\" and [simp]: \"r' = V x \\<bullet>\\<bullet> rs[k:=s]\""], ["proof (prove)\nusing this:\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and> r' = V x \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>k < length rs; rs ! k \\<Rightarrow> s;\n         r' = V x \\<bullet>\\<bullet> rs[k := s]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  k < length rs\n  rs ! k \\<Rightarrow> s\n  r' = V x \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (V x \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = V x \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (V x \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = V x \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "from Suc(1)[of \"rs[k:=s]\"] \\<open>(r',r) \\<in> Red_term ^^ i\\<close>"], ["proof (chain)\npicking this:\n  (V x \\<bullet>\\<bullet> rs[k := s], r)\n  \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (rs[k := s]) \\<and>\n     length is = length (rs[k := s]) \\<and>\n     (\\<forall>j<length ts.\n         (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i)\n  (r', r) \\<in> Red_term ^^ i", "show ?case"], ["proof (prove)\nusing this:\n  (V x \\<bullet>\\<bullet> rs[k := s], r)\n  \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (rs[k := s]) \\<and>\n     length is = length (rs[k := s]) \\<and>\n     (\\<forall>j<length ts.\n         (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i)\n  (r', r) \\<in> Red_term ^^ i\n\ngoal (1 subgoal):\n 1. \\<exists>ts is.\n       r = V x \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> Suc i)", "using \\<open>k<size rs\\<close> \\<open>rs!k \\<Rightarrow> s\\<close>"], ["proof (prove)\nusing this:\n  (V x \\<bullet>\\<bullet> rs[k := s], r)\n  \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (rs[k := s]) \\<and>\n     length is = length (rs[k := s]) \\<and>\n     (\\<forall>j<length ts.\n         (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i)\n  (r', r) \\<in> Red_term ^^ i\n  k < length rs\n  rs ! k \\<Rightarrow> s\n\ngoal (1 subgoal):\n 1. \\<exists>ts is.\n       r = V x \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> Suc i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(V x \\<bullet>\\<bullet> rs[k := s],\n                 V x \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = V x \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        \\<forall>j<length rs.\n           (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>is.\n                            length is = length rs \\<and>\n                            (\\<forall>j<length rs.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "apply(rule_tac x=\"is[k := Suc(is!k)]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(V x \\<bullet>\\<bullet> rs[k := s],\n                 V x \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = V x \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        \\<forall>j<length rs.\n           (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> length (is[k := Suc (is ! k)]) = length rs \\<and>\n                         (\\<forall>j<length rs.\n                             (rs ! j, ts ! j)\n                             \\<in> Red_term ^^\n                                   is[k := Suc (is ! k)] ! j \\<and>\n                             is[k := Suc (is ! k)] ! j \\<le> Suc i)", "apply (auto simp:nth_list_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(V x \\<bullet>\\<bullet> rs[k := s],\n                 V x \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = V x \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        \\<forall>j<length rs.\n           (if k = j then s else rs ! j, ts ! j)\n           \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> (rs ! k, ts ! k)\n                         \\<in> Red_term ^^ is ! k O Red_term", "apply(erule_tac x=k in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(V x \\<bullet>\\<bullet> rs[k := s],\n                 V x \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = V x \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        k < length rs \\<longrightarrow>\n        (if k = k then s else rs ! k, ts ! k)\n        \\<in> Red_term ^^ is ! k \\<and>\n        is ! k \\<le> i\\<rbrakk>\n       \\<Longrightarrow> (rs ! k, ts ! k)\n                         \\<in> Red_term ^^ is ! k O Red_term", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(V x \\<bullet>\\<bullet> rs[k := s],\n                 V x \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = V x \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs; (s, ts ! k) \\<in> Red_term ^^ is ! k;\n        is ! k \\<le> i\\<rbrakk>\n       \\<Longrightarrow> (rs ! k, ts ! k)\n                         \\<in> Red_term ^^ is ! k O Red_term", "apply (metis relpow_Suc_I2 relpow.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ts is.\n     r = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length rs \\<and>\n     length is = length rs \\<and>\n     (\\<forall>j<length ts.\n         (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_Red_term_it:  \"(C nm \\<bullet>\\<bullet> rs, r) : Red_term^^i\n  \\<Longrightarrow> \\<exists>ts is. r = C nm \\<bullet>\\<bullet> ts \\<and> size ts = size rs \\<and> size is = size rs \\<and>\n        (\\<forall>j<size ts. (rs!j, ts!j) \\<in> Red_term^^(is!j) \\<and> is!j \\<le> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ i \\<Longrightarrow>\n    \\<exists>ts is.\n       r = C nm \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> i)", "proof(induct i arbitrary:rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = C nm \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "case 0"], ["proof (state)\nthis:\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = C nm \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "moreover"], ["proof (state)\nthis:\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = C nm \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "have \"\\<exists>is. length is = length rs \\<and>\n   (\\<forall>j<size rs. (rs!j, rs!j) \\<in> Red_term ^^ is!j \\<and> is!j = 0)\" (is \"\\<exists>is. ?P is\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>is.\n       length is = length rs \\<and>\n       (\\<forall>j<length rs.\n           (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. length ?is = length rs \\<and>\n    (\\<forall>j<length rs.\n        (rs ! j, rs ! j) \\<in> Red_term ^^ ?is ! j \\<and> ?is ! j = 0)", "show \"?P(replicate (size rs) 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate (length rs) 0) = length rs \\<and>\n    (\\<forall>j<length rs.\n        (rs ! j, rs ! j)\n        \\<in> Red_term ^^ replicate (length rs) 0 ! j \\<and>\n        replicate (length rs) 0 ! j = 0)", "by simp"], ["proof (state)\nthis:\n  length (replicate (length rs) 0) = length rs \\<and>\n  (\\<forall>j<length rs.\n      (rs ! j, rs ! j) \\<in> Red_term ^^ replicate (length rs) 0 ! j \\<and>\n      replicate (length rs) 0 ! j = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>is.\n     length is = length rs \\<and>\n     (\\<forall>j<length rs.\n         (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)\n\ngoal (2 subgoals):\n 1. \\<And>rs.\n       (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0 \\<Longrightarrow>\n       \\<exists>ts is.\n          r = C nm \\<bullet>\\<bullet> ts \\<and>\n          length ts = length rs \\<and>\n          length is = length rs \\<and>\n          (\\<forall>j<length ts.\n              (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n              is ! j \\<le> 0)\n 2. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "ultimately"], ["proof (chain)\npicking this:\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n  \\<exists>is.\n     length is = length rs \\<and>\n     (\\<forall>j<length rs.\n         (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)", "show ?case"], ["proof (prove)\nusing this:\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ 0\n  \\<exists>is.\n     length is = length rs \\<and>\n     (\\<forall>j<length rs.\n         (rs ! j, rs ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>ts is.\n       r = C nm \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>ts is.\n     r = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length rs \\<and>\n     length is = length rs \\<and>\n     (\\<forall>j<length ts.\n         (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "case (Suc i rs)"], ["proof (state)\nthis:\n  (C nm \\<bullet>\\<bullet> ?rs, r) \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length ?rs \\<and>\n     length is = length ?rs \\<and>\n     (\\<forall>j<length ts.\n         (?rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> i)\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "from \\<open>(C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<close>"], ["proof (chain)\npicking this:\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i", "obtain r' where r': \"C nm \\<bullet>\\<bullet> rs \\<Rightarrow> r'\" and \"(r',r) \\<in> Red_term ^^ i\""], ["proof (prove)\nusing this:\n  (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        \\<lbrakk>C nm \\<bullet>\\<bullet> rs \\<Rightarrow> r';\n         (r', r) \\<in> Red_term ^^ i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis relpow_Suc_D2)"], ["proof (state)\nthis:\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> r'\n  (r', r) \\<in> Red_term ^^ i\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "from r'"], ["proof (chain)\npicking this:\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> r'", "have \"\\<exists>k<size rs. \\<exists>s. rs!k \\<Rightarrow> s \\<and> r' = C nm \\<bullet>\\<bullet> rs[k:=s]\""], ["proof (prove)\nusing this:\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<exists>k<length rs.\n       \\<exists>s.\n          rs ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> rs[k := s]", "proof(induct rs arbitrary: r' rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r'.\n       C nm \\<bullet>\\<bullet> [] \\<Rightarrow> r' \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>s.\n             [] ! k \\<Rightarrow> s \\<and>\n             r' = C nm \\<bullet>\\<bullet> [][k := s]\n 2. \\<And>x xs r'.\n       \\<lbrakk>\\<And>r'.\n                   C nm \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = C nm \\<bullet>\\<bullet> xs[k := s];\n        C nm \\<bullet>\\<bullet> (xs @ [x]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [x]).\n                            \\<exists>s.\n                               (xs @ [x]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (xs @ [x])[k := s]", "case Nil"], ["proof (state)\nthis:\n  C nm \\<bullet>\\<bullet> [] \\<Rightarrow> r'\n\ngoal (2 subgoals):\n 1. \\<And>r'.\n       C nm \\<bullet>\\<bullet> [] \\<Rightarrow> r' \\<Longrightarrow>\n       \\<exists>k<length [].\n          \\<exists>s.\n             [] ! k \\<Rightarrow> s \\<and>\n             r' = C nm \\<bullet>\\<bullet> [][k := s]\n 2. \\<And>x xs r'.\n       \\<lbrakk>\\<And>r'.\n                   C nm \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = C nm \\<bullet>\\<bullet> xs[k := s];\n        C nm \\<bullet>\\<bullet> (xs @ [x]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [x]).\n                            \\<exists>s.\n                               (xs @ [x]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (xs @ [x])[k := s]", "thus ?case"], ["proof (prove)\nusing this:\n  C nm \\<bullet>\\<bullet> [] \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<exists>k<length [].\n       \\<exists>s.\n          [] ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> [][k := s]", "by(fastforce elim: Red_term.cases)"], ["proof (state)\nthis:\n  \\<exists>k<length [].\n     \\<exists>s.\n        [] ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> [][k := s]\n\ngoal (1 subgoal):\n 1. \\<And>x xs r'.\n       \\<lbrakk>\\<And>r'.\n                   C nm \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = C nm \\<bullet>\\<bullet> xs[k := s];\n        C nm \\<bullet>\\<bullet> (xs @ [x]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [x]).\n                            \\<exists>s.\n                               (xs @ [x]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (xs @ [x])[k := s]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs r'.\n       \\<lbrakk>\\<And>r'.\n                   C nm \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = C nm \\<bullet>\\<bullet> xs[k := s];\n        C nm \\<bullet>\\<bullet> (xs @ [x]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [x]).\n                            \\<exists>s.\n                               (xs @ [x]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (xs @ [x])[k := s]", "case (snoc r rs)"], ["proof (state)\nthis:\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> ?r' \\<Longrightarrow>\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        ?r' = C nm \\<bullet>\\<bullet> rs[k := s]\n  C nm \\<bullet>\\<bullet> (rs @ [r]) \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<And>x xs r'.\n       \\<lbrakk>\\<And>r'.\n                   C nm \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = C nm \\<bullet>\\<bullet> xs[k := s];\n        C nm \\<bullet>\\<bullet> (xs @ [x]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [x]).\n                            \\<exists>s.\n                               (xs @ [x]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (xs @ [x])[k := s]", "hence \"(C nm \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'\""], ["proof (prove)\nusing this:\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> ?r' \\<Longrightarrow>\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        ?r' = C nm \\<bullet>\\<bullet> rs[k := s]\n  C nm \\<bullet>\\<bullet> (rs @ [r]) \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. (C nm \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'", "by simp"], ["proof (state)\nthis:\n  (C nm \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<And>x xs r'.\n       \\<lbrakk>\\<And>r'.\n                   C nm \\<bullet>\\<bullet> xs \\<Rightarrow>\n                   r' \\<Longrightarrow>\n                   \\<exists>k<length xs.\n                      \\<exists>s.\n                         xs ! k \\<Rightarrow> s \\<and>\n                         r' = C nm \\<bullet>\\<bullet> xs[k := s];\n        C nm \\<bullet>\\<bullet> (xs @ [x]) \\<Rightarrow> r'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (xs @ [x]).\n                            \\<exists>s.\n                               (xs @ [x]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (xs @ [x])[k := s]", "thus ?case"], ["proof (prove)\nusing this:\n  (C nm \\<bullet>\\<bullet> rs) \\<bullet> r \\<Rightarrow> r'\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "proof(cases rule:Red_term.cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>r' = s' \\<bullet> r;\n        C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n 2. \\<And>t'.\n       \\<lbrakk>r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "case (ctxt_At1 s')"], ["proof (state)\nthis:\n  r' = s' \\<bullet> r\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>r' = s' \\<bullet> r;\n        C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n 2. \\<And>t'.\n       \\<lbrakk>r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "then"], ["proof (chain)\npicking this:\n  r' = s' \\<bullet> r\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'", "obtain k s'' where aux: \"k<length rs\" \"rs ! k \\<Rightarrow> s''\" \"s' = C nm \\<bullet>\\<bullet> rs[k := s'']\""], ["proof (prove)\nusing this:\n  r' = s' \\<bullet> r\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n\ngoal (1 subgoal):\n 1. (\\<And>k s''.\n        \\<lbrakk>k < length rs; rs ! k \\<Rightarrow> s'';\n         s' = C nm \\<bullet>\\<bullet> rs[k := s'']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using snoc(1)"], ["proof (prove)\nusing this:\n  r' = s' \\<bullet> r\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> ?r' \\<Longrightarrow>\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        ?r' = C nm \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. (\\<And>k s''.\n        \\<lbrakk>k < length rs; rs ! k \\<Rightarrow> s'';\n         s' = C nm \\<bullet>\\<bullet> rs[k := s'']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  k < length rs\n  rs ! k \\<Rightarrow> s''\n  s' = C nm \\<bullet>\\<bullet> rs[k := s'']\n\ngoal (2 subgoals):\n 1. \\<And>s'.\n       \\<lbrakk>r' = s' \\<bullet> r;\n        C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n 2. \\<And>t'.\n       \\<lbrakk>r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "show ?thesis (is \"\\<exists>k < ?n. \\<exists>s. ?P k s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "have \"k<?n \\<and> ?P k s''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n    r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s'']", "using ctxt_At1 aux"], ["proof (prove)\nusing this:\n  r' = s' \\<bullet> r\n  C nm \\<bullet>\\<bullet> rs \\<Rightarrow> s'\n  k < length rs\n  rs ! k \\<Rightarrow> s''\n  s' = C nm \\<bullet>\\<bullet> rs[k := s'']\n\ngoal (1 subgoal):\n 1. k < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n    r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s'']", "by (simp add:nth_append) (metis last_snoc butlast_snoc list_update_append1)"], ["proof (state)\nthis:\n  k < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n  r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s'']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! k \\<Rightarrow> s'' \\<and>\n  r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s'']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "by blast"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "case (ctxt_At2 t')"], ["proof (state)\nthis:\n  r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t'\n  r \\<Rightarrow> t'\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t';\n        r \\<Rightarrow> t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k<length (rs @ [r]).\n                            \\<exists>s.\n                               (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n                               r' =\n                               C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "show ?thesis (is \"\\<exists>k < ?n. \\<exists>s. ?P k s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "have \"size rs<?n \\<and> ?P (size rs) t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length rs < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n    r' = C nm \\<bullet>\\<bullet> (rs @ [r])[length rs := t']", "using ctxt_At2"], ["proof (prove)\nusing this:\n  r' = (C nm \\<bullet>\\<bullet> rs) \\<bullet> t'\n  r \\<Rightarrow> t'\n\ngoal (1 subgoal):\n 1. length rs < length (rs @ [r]) \\<and>\n    (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n    r' = C nm \\<bullet>\\<bullet> (rs @ [r])[length rs := t']", "by simp"], ["proof (state)\nthis:\n  length rs < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n  r' = C nm \\<bullet>\\<bullet> (rs @ [r])[length rs := t']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "thus ?thesis"], ["proof (prove)\nusing this:\n  length rs < length (rs @ [r]) \\<and>\n  (rs @ [r]) ! length rs \\<Rightarrow> t' \\<and>\n  r' = C nm \\<bullet>\\<bullet> (rs @ [r])[length rs := t']\n\ngoal (1 subgoal):\n 1. \\<exists>k<length (rs @ [r]).\n       \\<exists>s.\n          (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n          r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]", "by blast"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length (rs @ [r]).\n     \\<exists>s.\n        (rs @ [r]) ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> (rs @ [r])[k := s]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> rs[k := s]", "obtain k s where \"k<size rs\" \"rs!k \\<Rightarrow> s\" and [simp]: \"r' = C nm \\<bullet>\\<bullet> rs[k:=s]\""], ["proof (prove)\nusing this:\n  \\<exists>k<length rs.\n     \\<exists>s.\n        rs ! k \\<Rightarrow> s \\<and>\n        r' = C nm \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. (\\<And>k s.\n        \\<lbrakk>k < length rs; rs ! k \\<Rightarrow> s;\n         r' = C nm \\<bullet>\\<bullet> rs[k := s]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  k < length rs\n  rs ! k \\<Rightarrow> s\n  r' = C nm \\<bullet>\\<bullet> rs[k := s]\n\ngoal (1 subgoal):\n 1. \\<And>i rs.\n       \\<lbrakk>\\<And>rs.\n                   (C nm \\<bullet>\\<bullet> rs, r)\n                   \\<in> Red_term ^^ i \\<Longrightarrow>\n                   \\<exists>ts is.\n                      r = C nm \\<bullet>\\<bullet> ts \\<and>\n                      length ts = length rs \\<and>\n                      length is = length rs \\<and>\n                      (\\<forall>j<length ts.\n                          (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n                          is ! j \\<le> i);\n        (C nm \\<bullet>\\<bullet> rs, r) \\<in> Red_term ^^ Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ts is.\n                            r = C nm \\<bullet>\\<bullet> ts \\<and>\n                            length ts = length rs \\<and>\n                            length is = length rs \\<and>\n                            (\\<forall>j<length ts.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "from Suc(1)[of \"rs[k:=s]\"] \\<open>(r',r) \\<in> Red_term ^^ i\\<close>"], ["proof (chain)\npicking this:\n  (C nm \\<bullet>\\<bullet> rs[k := s], r)\n  \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (rs[k := s]) \\<and>\n     length is = length (rs[k := s]) \\<and>\n     (\\<forall>j<length ts.\n         (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i)\n  (r', r) \\<in> Red_term ^^ i", "show ?case"], ["proof (prove)\nusing this:\n  (C nm \\<bullet>\\<bullet> rs[k := s], r)\n  \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (rs[k := s]) \\<and>\n     length is = length (rs[k := s]) \\<and>\n     (\\<forall>j<length ts.\n         (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i)\n  (r', r) \\<in> Red_term ^^ i\n\ngoal (1 subgoal):\n 1. \\<exists>ts is.\n       r = C nm \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> Suc i)", "using \\<open>k<size rs\\<close> \\<open>rs!k \\<Rightarrow> s\\<close>"], ["proof (prove)\nusing this:\n  (C nm \\<bullet>\\<bullet> rs[k := s], r)\n  \\<in> Red_term ^^ i \\<Longrightarrow>\n  \\<exists>ts is.\n     r = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (rs[k := s]) \\<and>\n     length is = length (rs[k := s]) \\<and>\n     (\\<forall>j<length ts.\n         (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i)\n  (r', r) \\<in> Red_term ^^ i\n  k < length rs\n  rs ! k \\<Rightarrow> s\n\ngoal (1 subgoal):\n 1. \\<exists>ts is.\n       r = C nm \\<bullet>\\<bullet> ts \\<and>\n       length ts = length rs \\<and>\n       length is = length rs \\<and>\n       (\\<forall>j<length ts.\n           (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> Suc i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(C nm \\<bullet>\\<bullet> rs[k := s],\n                 C nm \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = C nm \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        \\<forall>j<length rs.\n           (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>is.\n                            length is = length rs \\<and>\n                            (\\<forall>j<length rs.\n                                (rs ! j, ts ! j)\n                                \\<in> Red_term ^^ is ! j \\<and>\n                                is ! j \\<le> Suc i)", "apply(rule_tac x=\"is[k := Suc(is!k)]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(C nm \\<bullet>\\<bullet> rs[k := s],\n                 C nm \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = C nm \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        \\<forall>j<length rs.\n           (rs[k := s] ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> length (is[k := Suc (is ! k)]) = length rs \\<and>\n                         (\\<forall>j<length rs.\n                             (rs ! j, ts ! j)\n                             \\<in> Red_term ^^\n                                   is[k := Suc (is ! k)] ! j \\<and>\n                             is[k := Suc (is ! k)] ! j \\<le> Suc i)", "apply (auto simp:nth_list_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(C nm \\<bullet>\\<bullet> rs[k := s],\n                 C nm \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = C nm \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        \\<forall>j<length rs.\n           (if k = j then s else rs ! j, ts ! j)\n           \\<in> Red_term ^^ is ! j \\<and>\n           is ! j \\<le> i\\<rbrakk>\n       \\<Longrightarrow> (rs ! k, ts ! k)\n                         \\<in> Red_term ^^ is ! k O Red_term", "apply(erule_tac x=k in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(C nm \\<bullet>\\<bullet> rs[k := s],\n                 C nm \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = C nm \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs;\n        k < length rs \\<longrightarrow>\n        (if k = k then s else rs ! k, ts ! k)\n        \\<in> Red_term ^^ is ! k \\<and>\n        is ! k \\<le> i\\<rbrakk>\n       \\<Longrightarrow> (rs ! k, ts ! k)\n                         \\<in> Red_term ^^ is ! k O Red_term", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts is.\n       \\<lbrakk>(C nm \\<bullet>\\<bullet> rs[k := s],\n                 C nm \\<bullet>\\<bullet> ts)\n                \\<in> Red_term ^^ i;\n        k < length rs; rs ! k \\<Rightarrow> s;\n        r = C nm \\<bullet>\\<bullet> ts; length ts = length rs;\n        length is = length rs; (s, ts ! k) \\<in> Red_term ^^ is ! k;\n        is ! k \\<le> i\\<rbrakk>\n       \\<Longrightarrow> (rs ! k, ts ! k)\n                         \\<in> Red_term ^^ is ! k O Red_term", "apply (metis relpow_Suc_I2 relpow.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ts is.\n     r = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length rs \\<and>\n     length is = length rs \\<and>\n     (\\<forall>j<length ts.\n         (rs ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> Suc i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pure_At[simp]: \"pure(s \\<bullet> t) \\<longleftrightarrow> pure s \\<and> pure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (s \\<bullet> t) = (pure s \\<and> pure t)", "by(fastforce elim: pure.cases)"], ["", "lemma pure_foldl_At[simp]: \"pure(s \\<bullet>\\<bullet> ts) \\<longleftrightarrow> pure s \\<and> (\\<forall>t\\<in>set ts. pure t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (s \\<bullet>\\<bullet> ts) =\n    (pure s \\<and> (\\<forall>t\\<in>set ts. pure t))", "by(induct ts arbitrary: s) auto"], ["", "lemma nbe_C_normal_ML:\n  assumes \"term v \\<Rightarrow>* t'\" \"C_normal\\<^sub>M\\<^sub>L v\" \"pure t'\" shows \"normal t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal t'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. normal t'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. normal t'", "fix t t' i v"], ["proof (state)\ngoal (1 subgoal):\n 1. normal t'", "assume \"(t,t') : Red_term^^i\""], ["proof (state)\nthis:\n  (t, t') \\<in> Red_term ^^ i\n\ngoal (1 subgoal):\n 1. normal t'", "hence \"t = term v \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L v \\<Longrightarrow> pure t' \\<Longrightarrow> normal t'\""], ["proof (prove)\nusing this:\n  (t, t') \\<in> Red_term ^^ i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t'\\<rbrakk>\n    \\<Longrightarrow> normal t'", "proof(induct i arbitrary: t t' v rule:less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x t t' v.\n       \\<lbrakk>\\<And>y t t' v.\n                   \\<lbrakk>y < x; t = term v; C_normal\\<^sub>M\\<^sub>L v;\n                    pure t'; (t, t') \\<in> Red_term ^^ y\\<rbrakk>\n                   \\<Longrightarrow> normal t';\n        t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t';\n        (t, t') \\<in> Red_term ^^ x\\<rbrakk>\n       \\<Longrightarrow> normal t'", "case (less k)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n\ngoal (1 subgoal):\n 1. \\<And>x t t' v.\n       \\<lbrakk>\\<And>y t t' v.\n                   \\<lbrakk>y < x; t = term v; C_normal\\<^sub>M\\<^sub>L v;\n                    pure t'; (t, t') \\<in> Red_term ^^ y\\<rbrakk>\n                   \\<Longrightarrow> normal t';\n        t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t';\n        (t, t') \\<in> Red_term ^^ x\\<rbrakk>\n       \\<Longrightarrow> normal t'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. normal t'", "proof (cases k)"], ["proof (state)\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> normal t'\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "case 0"], ["proof (state)\nthis:\n  k = 0\n\ngoal (2 subgoals):\n 1. k = 0 \\<Longrightarrow> normal t'\n 2. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  k = 0\n\ngoal (1 subgoal):\n 1. normal t'", "using less"], ["proof (prove)\nusing this:\n  k = 0\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n\ngoal (1 subgoal):\n 1. normal t'", "by auto"], ["proof (state)\nthis:\n  normal t'\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "case (Suc i)"], ["proof (state)\nthis:\n  k = Suc i\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "then"], ["proof (chain)\npicking this:\n  k = Suc i", "obtain i' s where \"t \\<Rightarrow> s\" and red: \"(s,t') : Red_term^^i'\" and [arith]: \"i' <= i\""], ["proof (prove)\nusing this:\n  k = Suc i\n\ngoal (1 subgoal):\n 1. (\\<And>s i'.\n        \\<lbrakk>t \\<Rightarrow> s; (s, t') \\<in> Red_term ^^ i';\n         i' \\<le> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis eq_imp_le less(5) Suc relpow_Suc_D2)"], ["proof (state)\nthis:\n  t \\<Rightarrow> s\n  (s, t') \\<in> Red_term ^^ i'\n  i' \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "hence \"term v \\<Rightarrow> s\""], ["proof (prove)\nusing this:\n  t \\<Rightarrow> s\n  (s, t') \\<in> Red_term ^^ i'\n  i' \\<le> i\n\ngoal (1 subgoal):\n 1. term v \\<Rightarrow> s", "using Suc less"], ["proof (prove)\nusing this:\n  t \\<Rightarrow> s\n  (s, t') \\<in> Red_term ^^ i'\n  i' \\<le> i\n  k = Suc i\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n\ngoal (1 subgoal):\n 1. term v \\<Rightarrow> s", "by simp"], ["proof (state)\nthis:\n  term v \\<Rightarrow> s\n\ngoal (1 subgoal):\n 1. \\<And>nat. k = Suc nat \\<Longrightarrow> normal t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  term v \\<Rightarrow> s\n\ngoal (1 subgoal):\n 1. normal t'", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "case (term_C nm vs)"], ["proof (state)\nthis:\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "with less"], ["proof (chain)\npicking this:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)", "have 0:\"no_match_compR nm vs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (1 subgoal):\n 1. no_match_compR nm vs", "by auto"], ["proof (state)\nthis:\n  no_match_compR nm vs\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "let ?n = \"size vs\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have 1: \"(C nm \\<bullet>\\<bullet> map term (rev vs),t') : Red_term^^i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "using term_C \\<open>(s,t') : Red_term^^i'\\<close>"], ["proof (prove)\nusing this:\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)\n  (s, t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "by simp"], ["proof (state)\nthis:\n  (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "with C_Red_term_it[OF 1]"], ["proof (chain)\npicking this:\n  \\<exists>ts is.\n     t' = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')\n  (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "obtain ts ks where [simp]: \"t' = C nm \\<bullet>\\<bullet> ts\"\n          and sz: \"size ts = ?n \\<and> size ks = ?n \\<and>\n          (\\<forall>i<?n. (term((rev vs)!i), ts!i) : Red_term^^(ks!i) \\<and> ks ! i \\<le> i')\""], ["proof (prove)\nusing this:\n  \\<exists>ts is.\n     t' = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')\n  (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. (\\<And>ts ks.\n        \\<lbrakk>t' = C nm \\<bullet>\\<bullet> ts;\n         length ts = length vs \\<and>\n         length ks = length vs \\<and>\n         (\\<forall>i<length vs.\n             (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i \\<and>\n             ks ! i \\<le> i')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto cong:conj_cong)"], ["proof (state)\nthis:\n  t' = C nm \\<bullet>\\<bullet> ts\n  length ts = length vs \\<and>\n  length ks = length vs \\<and>\n  (\\<forall>i<length vs.\n      (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i \\<and>\n      ks ! i \\<le> i')\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have pure_ts: \"\\<forall>t\\<in>set ts. pure t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts. pure t", "using \\<open>pure t'\\<close>"], ["proof (prove)\nusing this:\n  pure t'\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts. pure t", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ts. pure t\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "{"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ts. pure t\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "fix i"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "assume \"i<size vs\""], ["proof (state)\nthis:\n  i < length vs\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "moreover"], ["proof (state)\nthis:\n  i < length vs\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "hence \"(term((rev vs)!i), ts!i) : Red_term^^(ks!i)\""], ["proof (prove)\nusing this:\n  i < length vs\n\ngoal (1 subgoal):\n 1. (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i", "by(metis sz)"], ["proof (state)\nthis:\n  (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "ultimately"], ["proof (chain)\npicking this:\n  i < length vs\n  (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i", "have \"normal (ts!i)\""], ["proof (prove)\nusing this:\n  i < length vs\n  (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\n\ngoal (1 subgoal):\n 1. normal (ts ! i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> normal (ts ! i)", "apply(rule less(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> ?y2 < k\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> ?t2 = term ?v2\n 3. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L ?v2\n 4. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)\n 5. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> (?t2, ts ! i) \\<in> Red_term ^^ ?y2", "prefer 5"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> (?t2, ts ! i) \\<in> Red_term ^^ ?y2\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> ?y2 < k\n 3. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> ?t2 = term ?v2\n 4. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L ?v2\n 5. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> ks ! i < k\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> term (rev vs ! i) = term ?v2\n 3. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L ?v2\n 4. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "using sz Suc"], ["proof (prove)\nusing this:\n  length ts = length vs \\<and>\n  length ks = length vs \\<and>\n  (\\<forall>i<length vs.\n      (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i \\<and>\n      ks ! i \\<le> i')\n  k = Suc ia__\n\ngoal (4 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> ks ! i < k\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> term (rev vs ! i) = term ?v2\n 3. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L ?v2\n 4. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> term (rev vs ! i) = term ?v2\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L ?v2\n 3. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "apply(rule refl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (rev vs ! i)\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "using less term_C"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (rev vs ! i)\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "apply(auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i;\n     \\<And>y t v t'.\n        \\<lbrakk>y < k; t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t';\n         (term v, t') \\<in> Red_term ^^ y\\<rbrakk>\n        \\<Longrightarrow> normal t';\n     t = term (C\\<^sub>U nm vs); \\<forall>x\\<in>set ts. pure x;\n     (term (C\\<^sub>U nm vs), C nm \\<bullet>\\<bullet> ts)\n     \\<in> Red_term ^^ k;\n     v = C\\<^sub>U nm vs; s = C nm \\<bullet>\\<bullet> map term (rev vs);\n     \\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x;\n     no_match_compR nm vs\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (rev vs ! i)\n 2. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i;\n     \\<And>y t v t'.\n        \\<lbrakk>y < k; t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t';\n         (term v, t') \\<in> Red_term ^^ y\\<rbrakk>\n        \\<Longrightarrow> normal t';\n     t = term (C\\<^sub>U nm vs); \\<forall>x\\<in>set ts. pure x;\n     (term (C\\<^sub>U nm vs), C nm \\<bullet>\\<bullet> ts)\n     \\<in> Red_term ^^ k;\n     v = C\\<^sub>U nm vs; s = C nm \\<bullet>\\<bullet> map term (rev vs);\n     \\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x;\n     no_match_compR nm vs\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "apply (metis in_set_conv_nth length_rev set_rev)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length vs;\n     (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i;\n     \\<And>y t v t'.\n        \\<lbrakk>y < k; t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t';\n         (term v, t') \\<in> Red_term ^^ y\\<rbrakk>\n        \\<Longrightarrow> normal t';\n     t = term (C\\<^sub>U nm vs); \\<forall>x\\<in>set ts. pure x;\n     (term (C\\<^sub>U nm vs), C nm \\<bullet>\\<bullet> ts)\n     \\<in> Red_term ^^ k;\n     v = C\\<^sub>U nm vs; s = C nm \\<bullet>\\<bullet> map term (rev vs);\n     \\<forall>x\\<in>set vs. C_normal\\<^sub>M\\<^sub>L x;\n     no_match_compR nm vs\\<rbrakk>\n    \\<Longrightarrow> pure (ts ! i)", "apply (metis in_set_conv_nth pure_ts sz)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  normal (ts ! i)\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "}"], ["proof (state)\nthis:\n  ?ib2 < length vs \\<Longrightarrow> normal (ts ! ?ib2)\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "note 2 = this"], ["proof (state)\nthis:\n  ?ib2 < length vs \\<Longrightarrow> normal (ts ! ?ib2)\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have 3: \"no_match_R nm (map dterm (map term (rev vs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_R nm (map dterm (map term (rev vs)))", "apply(subst map_dterm_term)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_R nm (map dterm\\<^sub>M\\<^sub>L (rev vs))", "apply(rule no_match_R_coincide)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_compR nm (rev (rev vs))", "using 0"], ["proof (prove)\nusing this:\n  no_match_compR nm vs\n\ngoal (1 subgoal):\n 1. no_match_compR nm (rev (rev vs))", "by simp"], ["proof (state)\nthis:\n  no_match_R nm (map dterm (map term (rev vs)))\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have 4: \"map term (rev vs) [\\<Rightarrow>*] ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "have \"(C nm \\<bullet>\\<bullet> map term (rev vs),t'): Red_term^^i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "using red term_C"], ["proof (prove)\nusing this:\n  (s, t') \\<in> Red_term ^^ i'\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (1 subgoal):\n 1. (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "by auto"], ["proof (state)\nthis:\n  (C nm \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "from C_Red_term_it[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>ts is.\n     t' = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')", "obtain ts' \"is\" where \"t' = C nm  \\<bullet>\\<bullet> ts'\"\n            and \"length ts' = ?n \\<and> length is =?n \\<and>\n              (\\<forall>j< ?n. (map term (rev vs) ! j, ts' ! j) \\<in> Red_term ^^ is ! j \\<and> is ! j \\<le> i')\""], ["proof (prove)\nusing this:\n  \\<exists>ts is.\n     t' = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')\n\ngoal (1 subgoal):\n 1. (\\<And>ts' is.\n        \\<lbrakk>t' = C nm \\<bullet>\\<bullet> ts';\n         length ts' = length vs \\<and>\n         length is = length vs \\<and>\n         (\\<forall>j<length vs.\n             (map term (rev vs) ! j, ts' ! j)\n             \\<in> Red_term ^^ is ! j \\<and>\n             is ! j \\<le> i')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using sz"], ["proof (prove)\nusing this:\n  \\<exists>ts is.\n     t' = C nm \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')\n  length ts = length vs \\<and>\n  length ks = length vs \\<and>\n  (\\<forall>i<length vs.\n      (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i \\<and>\n      ks ! i \\<le> i')\n\ngoal (1 subgoal):\n 1. (\\<And>ts' is.\n        \\<lbrakk>t' = C nm \\<bullet>\\<bullet> ts';\n         length ts' = length vs \\<and>\n         length is = length vs \\<and>\n         (\\<forall>j<length vs.\n             (map term (rev vs) ! j, ts' ! j)\n             \\<in> Red_term ^^ is ! j \\<and>\n             is ! j \\<le> i')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' = C nm \\<bullet>\\<bullet> ts'\n  length ts' = length vs \\<and>\n  length is = length vs \\<and>\n  (\\<forall>j<length vs.\n      (map term (rev vs) ! j, ts' ! j) \\<in> Red_term ^^ is ! j \\<and>\n      is ! j \\<le> i')\n\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "from \\<open>t' = C nm \\<bullet>\\<bullet> ts'\\<close> \\<open>t' = C nm \\<bullet>\\<bullet> ts\\<close>"], ["proof (chain)\npicking this:\n  t' = C nm \\<bullet>\\<bullet> ts'\n  t' = C nm \\<bullet>\\<bullet> ts", "have \"ts = ts'\""], ["proof (prove)\nusing this:\n  t' = C nm \\<bullet>\\<bullet> ts'\n  t' = C nm \\<bullet>\\<bullet> ts\n\ngoal (1 subgoal):\n 1. ts = ts'", "by simp"], ["proof (state)\nthis:\n  ts = ts'\n\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "using sz"], ["proof (prove)\nusing this:\n  length ts = length vs \\<and>\n  length ks = length vs \\<and>\n  (\\<forall>i<length vs.\n      (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i \\<and>\n      ks ! i \\<le> i')\n\ngoal (1 subgoal):\n 1. length (map term (rev vs)) = length ts \\<and>\n    (\\<forall>i<length (map term (rev vs)).\n        map term (rev vs) ! i \\<Rightarrow>* ts ! i)", "by (auto  simp: rtrancl_is_UN_relpow)"], ["proof (state)\nthis:\n  length (map term (rev vs)) = length ts \\<and>\n  (\\<forall>i<length (map term (rev vs)).\n      map term (rev vs) ! i \\<Rightarrow>* ts ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (map term (rev vs)) = length ts \\<and>\n  (\\<forall>i<length (map term (rev vs)).\n      map term (rev vs) ! i \\<Rightarrow>* ts ! i)\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have 5: \"\\<forall>t\\<in>set(map term vs). C_normal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (map term vs). C_normal t", "using less term_C"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n  v = C\\<^sub>U nm vs\n  s = C nm \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (map term vs). C_normal t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (map term vs). C_normal t\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"no_match_R nm (map dterm ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_R nm (map dterm ts)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow> no_match aa (map dterm ts)", "apply(subgoal_tac \"no_match aa (map dterm (map term (rev vs)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match aa (map dterm (map term (rev vs)))\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm ts)\n 2. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow>\n       no_match aa (map dterm (map term (rev vs)))", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow>\n       no_match aa (map dterm (map term (rev vs)))\n 2. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match aa (map dterm (map term (rev vs)))\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm ts)", "using 3"], ["proof (prove)\nusing this:\n  no_match_R nm (map dterm (map term (rev vs)))\n\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       (nm, aa, b) \\<in> R \\<Longrightarrow>\n       no_match aa (map dterm (map term (rev vs)))\n 2. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match aa (map dterm (map term (rev vs)))\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm ts)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match aa (map dterm (map term (rev vs)))\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm ts)", "using 4 5 no_match_preserved[OF _ _ _ refl, of \"map term (rev vs)\" \"ts\"]"], ["proof (prove)\nusing this:\n  length (map term (rev vs)) = length ts \\<and>\n  (\\<forall>i<length (map term (rev vs)).\n      map term (rev vs) ! i \\<Rightarrow>* ts ! i)\n  \\<forall>t\\<in>set (map term vs). C_normal t\n  \\<lbrakk>\\<forall>t\\<in>set (map term (rev vs)). C_normal t;\n   length (map term (rev vs)) = length ts \\<and>\n   (\\<forall>i<length (map term (rev vs)).\n       map term (rev vs) ! i \\<Rightarrow>* ts ! i);\n   no_match ?ps (map dterm (map term (rev vs)))\\<rbrakk>\n  \\<Longrightarrow> no_match ?ps (map dterm ts)\n\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>(nm, aa, b) \\<in> R;\n        no_match aa (map dterm (map term (rev vs)))\\<rbrakk>\n       \\<Longrightarrow> no_match aa (map dterm ts)", "by simp"], ["proof (state)\nthis:\n  no_match_R nm (map dterm ts)\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "hence 6: \"no_match_R nm ts\""], ["proof (prove)\nusing this:\n  no_match_R nm (map dterm ts)\n\ngoal (1 subgoal):\n 1. no_match_R nm ts", "by(metis map_dterm_pure[OF pure_ts])"], ["proof (state)\nthis:\n  no_match_R nm ts\n\ngoal (4 subgoals):\n 1. \\<And>nm vs.\n       \\<lbrakk>v = C\\<^sub>U nm vs;\n        s = C nm \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 4. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "then"], ["proof (chain)\npicking this:\n  no_match_R nm ts", "show \"normal t'\""], ["proof (prove)\nusing this:\n  no_match_R nm ts\n\ngoal (1 subgoal):\n 1. normal t'", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_R nm ts \\<Longrightarrow> normal (C nm \\<bullet>\\<bullet> ts)", "apply(rule normal.intros(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_match_R nm ts \\<Longrightarrow> \\<forall>t\\<in>set ts. normal t\n 2. no_match_R nm ts \\<Longrightarrow>\n    \\<forall>\\<sigma>.\n       \\<forall>(nm', ls, r)\\<in>R.\n          \\<not> (nm = nm' \\<and>\n                  take (length ls) ts = map (subst \\<sigma>) ls)", "using 2 sz"], ["proof (prove)\nusing this:\n  ?ib2 < length vs \\<Longrightarrow> normal (ts ! ?ib2)\n  length ts = length vs \\<and>\n  length ks = length vs \\<and>\n  (\\<forall>i<length vs.\n      (term (rev vs ! i), ts ! i) \\<in> Red_term ^^ ks ! i \\<and>\n      ks ! i \\<le> i')\n\ngoal (2 subgoals):\n 1. no_match_R nm ts \\<Longrightarrow> \\<forall>t\\<in>set ts. normal t\n 2. no_match_R nm ts \\<Longrightarrow>\n    \\<forall>\\<sigma>.\n       \\<forall>(nm', ls, r)\\<in>R.\n          \\<not> (nm = nm' \\<and>\n                  take (length ls) ts = map (subst \\<sigma>) ls)", "apply(fastforce simp:set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_match_R nm ts \\<Longrightarrow>\n    \\<forall>\\<sigma>.\n       \\<forall>(nm', ls, r)\\<in>R.\n          \\<not> (nm = nm' \\<and>\n                  take (length ls) ts = map (subst \\<sigma>) ls)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> aa b.\n       \\<lbrakk>no_match_R nm ts; (nm, aa, b) \\<in> R;\n        take (length aa) ts = map (subst \\<sigma>) aa\\<rbrakk>\n       \\<Longrightarrow> False", "apply(subgoal_tac \"no_match aa (take (size aa) ts)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> aa b.\n       \\<lbrakk>no_match_R nm ts; (nm, aa, b) \\<in> R;\n        take (length aa) ts = map (subst \\<sigma>) aa;\n        no_match aa (take (length aa) ts)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>\\<sigma> aa b.\n       \\<lbrakk>no_match_R nm ts; (nm, aa, b) \\<in> R;\n        take (length aa) ts = map (subst \\<sigma>) aa\\<rbrakk>\n       \\<Longrightarrow> no_match aa (take (length aa) ts)", "apply (metis no_match)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> aa b.\n       \\<lbrakk>no_match_R nm ts; (nm, aa, b) \\<in> R;\n        take (length aa) ts = map (subst \\<sigma>) aa\\<rbrakk>\n       \\<Longrightarrow> no_match aa (take (length aa) ts)", "apply(fastforce intro:no_match_take)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  normal t'\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "case (term_V x vs)"], ["proof (state)\nthis:\n  v = V\\<^sub>U x vs\n  s = V x \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "let ?n = \"size vs\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have 1: \"(V x \\<bullet>\\<bullet> map term (rev vs),t') : Red_term^^i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V x \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "using term_V \\<open>(s,t') : Red_term^^i'\\<close>"], ["proof (prove)\nusing this:\n  v = V\\<^sub>U x vs\n  s = V x \\<bullet>\\<bullet> map term (rev vs)\n  (s, t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. (V x \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "by simp"], ["proof (state)\nthis:\n  (V x \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "with Red_term_it[OF 1]"], ["proof (chain)\npicking this:\n  \\<exists>ts is.\n     t' = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')\n  (V x \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'", "obtain ts \"is\" where [simp]: \"t' = V x \\<bullet>\\<bullet> ts\"\n          and 2: \"length ts = ?n \\<and>\n            length is = ?n \\<and> (\\<forall>j<?n. (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n            is ! j \\<le> i')\""], ["proof (prove)\nusing this:\n  \\<exists>ts is.\n     t' = V x \\<bullet>\\<bullet> ts \\<and>\n     length ts = length (map term (rev vs)) \\<and>\n     length is = length (map term (rev vs)) \\<and>\n     (\\<forall>j<length ts.\n         (map term (rev vs) ! j, ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n         is ! j \\<le> i')\n  (V x \\<bullet>\\<bullet> map term (rev vs), t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. (\\<And>ts is.\n        \\<lbrakk>t' = V x \\<bullet>\\<bullet> ts;\n         length ts = length vs \\<and>\n         length is = length vs \\<and>\n         (\\<forall>j<length vs.\n             (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n             is ! j \\<le> i')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto cong:conj_cong)"], ["proof (state)\nthis:\n  t' = V x \\<bullet>\\<bullet> ts\n  length ts = length vs \\<and>\n  length is = length vs \\<and>\n  (\\<forall>j<length vs.\n      (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n      is ! j \\<le> i')\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"\\<forall>j<?n. normal(ts!j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<length vs. normal (ts ! j)", "proof(clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "assume 0: \"j < ?n\""], ["proof (state)\nthis:\n  j < length vs\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "then"], ["proof (chain)\npicking this:\n  j < length vs", "have \"is!j < k\""], ["proof (prove)\nusing this:\n  j < length vs\n\ngoal (1 subgoal):\n 1. is ! j < k", "using \\<open>k=Suc i\\<close> 2"], ["proof (prove)\nusing this:\n  j < length vs\n  k = Suc i\n  length ts = length vs \\<and>\n  length is = length vs \\<and>\n  (\\<forall>j<length vs.\n      (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n      is ! j \\<le> i')\n\ngoal (1 subgoal):\n 1. is ! j < k", "by auto"], ["proof (state)\nthis:\n  is ! j < k\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "have red: \"(term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j", "using \\<open>j < ?n\\<close> 2"], ["proof (prove)\nusing this:\n  j < length vs\n  length ts = length vs \\<and>\n  length is = length vs \\<and>\n  (\\<forall>j<length vs.\n      (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n      is ! j \\<le> i')\n\ngoal (1 subgoal):\n 1. (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j", "by auto"], ["proof (state)\nthis:\n  (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "have pure: \"pure (ts ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (ts ! j)", "using \\<open>pure t'\\<close> 0 2"], ["proof (prove)\nusing this:\n  pure t'\n  j < length vs\n  length ts = length vs \\<and>\n  length is = length vs \\<and>\n  (\\<forall>j<length vs.\n      (term (rev vs ! j), ts ! j) \\<in> Red_term ^^ is ! j \\<and>\n      is ! j \\<le> i')\n\ngoal (1 subgoal):\n 1. pure (ts ! j)", "by auto"], ["proof (state)\nthis:\n  pure (ts ! j)\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "have Cnm: \"C_normal\\<^sub>M\\<^sub>L (rev vs ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L (rev vs ! j)", "using less term_V"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n  v = V\\<^sub>U x vs\n  s = V x \\<bullet>\\<bullet> map term (rev vs)\n\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L (rev vs ! j)", "by simp (metis 0 in_set_conv_nth length_rev set_rev)"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L (rev vs ! j)\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length vs \\<Longrightarrow> normal (ts ! j)", "from less(1)[OF \\<open>is!j < k\\<close> refl Cnm pure red]"], ["proof (chain)\npicking this:\n  normal (ts ! j)", "show \"normal(ts!j)\""], ["proof (prove)\nusing this:\n  normal (ts ! j)\n\ngoal (1 subgoal):\n 1. normal (ts ! j)", "."], ["proof (state)\nthis:\n  normal (ts ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>j<length vs. normal (ts ! j)\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "note 3=this"], ["proof (state)\nthis:\n  \\<forall>j<length vs. normal (ts ! j)\n\ngoal (3 subgoals):\n 1. \\<And>x vs.\n       \\<lbrakk>v = V\\<^sub>U x vs;\n        s = V x \\<bullet>\\<bullet> map term (rev vs)\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 3. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. normal t'", "by simp (metis normal.intros(1) in_set_conv_nth 2 3)"], ["proof (state)\nthis:\n  normal t'\n\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "case (term_Clo f vs n)"], ["proof (state)\nthis:\n  v = Clo f vs n\n  s = \\<Lambda> (term (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])))\n\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "let ?u = \"apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "from term_Clo \\<open>(s,t') : Red_term^^i'\\<close>"], ["proof (chain)\npicking this:\n  v = Clo f vs n\n  s = \\<Lambda> (term (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])))\n  (s, t') \\<in> Red_term ^^ i'", "obtain t'' where [simp]: \"t' = \\<Lambda> t''\" and 1: \"(term ?u, t'') : Red_term^^i'\""], ["proof (prove)\nusing this:\n  v = Clo f vs n\n  s = \\<Lambda> (term (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])))\n  (s, t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. (\\<And>t''.\n        \\<lbrakk>t' = \\<Lambda> t'';\n         (term (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])), t'')\n         \\<in> Red_term ^^ i'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(metis Lam_Red_term_itE)"], ["proof (state)\nthis:\n  t' = \\<Lambda> t''\n  (term (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])), t'')\n  \\<in> Red_term ^^ i'\n\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"i' < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < k", "using \\<open>k = Suc i\\<close>"], ["proof (prove)\nusing this:\n  k = Suc i\n\ngoal (1 subgoal):\n 1. i' < k", "by arith"], ["proof (state)\nthis:\n  i' < k\n\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"pure t''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure t''", "using \\<open>pure t'\\<close>"], ["proof (prove)\nusing this:\n  pure t'\n\ngoal (1 subgoal):\n 1. pure t''", "by simp"], ["proof (state)\nthis:\n  pure t''\n\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"C_normal\\<^sub>M\\<^sub>L ?u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 []))", "using less term_Clo"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y < k; ?t = term ?v; C_normal\\<^sub>M\\<^sub>L ?v; pure ?t';\n   (?t, ?t') \\<in> Red_term ^^ ?y\\<rbrakk>\n  \\<Longrightarrow> normal ?t'\n  t = term v\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  (t, t') \\<in> Red_term ^^ k\n  v = Clo f vs n\n  s = \\<Lambda> (term (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 [])))\n\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 []))", "by(simp)"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L (apply (lift 0 (Clo f vs n)) (V\\<^sub>U 0 []))\n\ngoal (2 subgoals):\n 1. \\<And>vf vs n.\n       \\<lbrakk>v = Clo vf vs n;\n        s =\n        \\<Lambda>\n         (term (apply (lift 0 (Clo vf vs n)) (V\\<^sub>U 0 [])))\\<rbrakk>\n       \\<Longrightarrow> normal t'\n 2. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "from less(1)[OF \\<open>i' < k\\<close> refl \\<open>C_normal\\<^sub>M\\<^sub>L ?u\\<close> \\<open>pure t''\\<close> 1]"], ["proof (chain)\npicking this:\n  normal t''", "show ?thesis"], ["proof (prove)\nusing this:\n  normal t''\n\ngoal (1 subgoal):\n 1. normal t'", "by(simp add:normal.intros)"], ["proof (state)\nthis:\n  normal t'\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "case (ctxt_term u')"], ["proof (state)\nthis:\n  s = term u'\n  v \\<Rightarrow> u'\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"i' < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i' < k", "using \\<open>k = Suc i\\<close>"], ["proof (prove)\nusing this:\n  k = Suc i\n\ngoal (1 subgoal):\n 1. i' < k", "by arith"], ["proof (state)\nthis:\n  i' < k\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"C_normal\\<^sub>M\\<^sub>L u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C_normal\\<^sub>M\\<^sub>L u'", "by (rule C_normal_ML_inv) (insert less ctxt_term, simp_all)"], ["proof (state)\nthis:\n  C_normal\\<^sub>M\\<^sub>L u'\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "have \"(term u', t') \\<in> Red_term ^^ i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (term u', t') \\<in> Red_term ^^ i'", "using red ctxt_term"], ["proof (prove)\nusing this:\n  (s, t') \\<in> Red_term ^^ i'\n  s = term u'\n  v \\<Rightarrow> u'\n\ngoal (1 subgoal):\n 1. (term u', t') \\<in> Red_term ^^ i'", "by auto"], ["proof (state)\nthis:\n  (term u', t') \\<in> Red_term ^^ i'\n\ngoal (1 subgoal):\n 1. \\<And>v'.\n       \\<lbrakk>s = term v'; v \\<Rightarrow> v'\\<rbrakk>\n       \\<Longrightarrow> normal t'", "from less(1)[OF \\<open>i' < k\\<close> refl \\<open>C_normal\\<^sub>M\\<^sub>L u'\\<close> \\<open>pure t'\\<close> this]"], ["proof (chain)\npicking this:\n  normal t'", "show ?thesis"], ["proof (prove)\nusing this:\n  normal t'\n\ngoal (1 subgoal):\n 1. normal t'", "."], ["proof (state)\nthis:\n  normal t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normal t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  normal t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>t = term v; C_normal\\<^sub>M\\<^sub>L v; pure t'\\<rbrakk>\n  \\<Longrightarrow> normal t'\n\ngoal (1 subgoal):\n 1. normal t'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?t2, ?t'a2) \\<in> Red_term ^^ ?i2; ?t2 = term ?va2;\n   C_normal\\<^sub>M\\<^sub>L ?va2; pure ?t'a2\\<rbrakk>\n  \\<Longrightarrow> normal ?t'a2\n\ngoal (1 subgoal):\n 1. normal t'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?t2, ?t'a2) \\<in> Red_term ^^ ?i2; ?t2 = term ?va2;\n   C_normal\\<^sub>M\\<^sub>L ?va2; pure ?t'a2\\<rbrakk>\n  \\<Longrightarrow> normal ?t'a2\n\ngoal (1 subgoal):\n 1. normal t'", "using assms(2-) rtrancl_imp_relpow[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?t2, ?t'a2) \\<in> Red_term ^^ ?i2; ?t2 = term ?va2;\n   C_normal\\<^sub>M\\<^sub>L ?va2; pure ?t'a2\\<rbrakk>\n  \\<Longrightarrow> normal ?t'a2\n  C_normal\\<^sub>M\\<^sub>L v\n  pure t'\n  \\<exists>n. (term v, t') \\<in> Red_term ^^ n\n\ngoal (1 subgoal):\n 1. normal t'", "by blast"], ["proof (state)\nthis:\n  normal t'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma C_normal_ML_compile:\n  \"pure t \\<Longrightarrow> \\<forall>i. C_normal\\<^sub>M\\<^sub>L(\\<sigma> i) \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (compile t \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t;\n     \\<forall>i. C_normal\\<^sub>M\\<^sub>L (\\<sigma> i)\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (compile t \\<sigma>)", "by(induct t arbitrary: \\<sigma>) (simp_all add: C_normal_ML_lift_ML)"], ["", "corollary nbe_normal:\n  \"pure t \\<Longrightarrow> term(comp_fixed t) \\<Rightarrow>* t' \\<Longrightarrow> pure t' \\<Longrightarrow> normal t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; term (comp_fixed t) \\<Rightarrow>* t'; pure t'\\<rbrakk>\n    \\<Longrightarrow> normal t'", "apply(erule nbe_C_normal_ML)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pure t; pure t'\\<rbrakk>\n    \\<Longrightarrow> C_normal\\<^sub>M\\<^sub>L (comp_fixed t)\n 2. \\<lbrakk>pure t; pure t'\\<rbrakk> \\<Longrightarrow> pure t'", "apply(simp add: C_normal_ML_compile)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure t; pure t'\\<rbrakk> \\<Longrightarrow> pure t'", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section\\<open>Refinements\\<close>"], ["", "text\\<open>We ensure that all occurrences of @{term \"C\\<^sub>U nm vs\"} satisfy\nthe invariant @{prop\"size vs = arity nm\"}.\\<close>"], ["", "text\\<open>A constructor value:\\<close>"], ["", "fun C\\<^sub>Us :: \"ml \\<Rightarrow> bool\" where\n\"C\\<^sub>Us(C\\<^sub>U nm vs) = (size vs = arity nm \\<and> (\\<forall>v\\<in>set vs. C\\<^sub>Us v))\" |\n\"C\\<^sub>Us _ = False\""], ["", "lemma size_foldl_At: \"size(C nm \\<bullet>\\<bullet> ts) = size ts + sum_list(map size ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (C nm \\<bullet>\\<bullet> ts) = length ts + sum_list (map size ts)", "by(induct ts rule:rev_induct) auto"], ["", "lemma termination_linpats:\n  \"i < length ts \\<Longrightarrow> ts!i = C nm \\<bullet>\\<bullet> ts'\n   \\<Longrightarrow> length ts' + sum_list (map size ts') < length ts + sum_list (map size ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts'\\<rbrakk>\n    \\<Longrightarrow> length ts' + sum_list (map size ts')\n                      < length ts + sum_list (map size ts)", "apply(subgoal_tac \"C nm \\<bullet>\\<bullet> ts' : set ts\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts';\n     C nm \\<bullet>\\<bullet> ts' \\<in> set ts\\<rbrakk>\n    \\<Longrightarrow> length ts' + sum_list (map size ts')\n                      < length ts + sum_list (map size ts)\n 2. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts'\\<rbrakk>\n    \\<Longrightarrow> C nm \\<bullet>\\<bullet> ts' \\<in> set ts", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts'\\<rbrakk>\n    \\<Longrightarrow> C nm \\<bullet>\\<bullet> ts' \\<in> set ts\n 2. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts';\n     C nm \\<bullet>\\<bullet> ts' \\<in> set ts\\<rbrakk>\n    \\<Longrightarrow> length ts' + sum_list (map size ts')\n                      < length ts + sum_list (map size ts)", "apply (metis in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts';\n     C nm \\<bullet>\\<bullet> ts' \\<in> set ts\\<rbrakk>\n    \\<Longrightarrow> length ts' + sum_list (map size ts')\n                      < length ts + sum_list (map size ts)", "apply(drule sum_list_map_remove1[of _ _ size])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts';\n     sum_list (map size ts) =\n     size (C nm \\<bullet>\\<bullet> ts') +\n     sum_list (map size (remove1 (C nm \\<bullet>\\<bullet> ts') ts))\\<rbrakk>\n    \\<Longrightarrow> length ts' + sum_list (map size ts')\n                      < length ts + sum_list (map size ts)", "apply(simp add:size_foldl_At)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ts; ts ! i = C nm \\<bullet>\\<bullet> ts';\n     sum_list (map size ts) =\n     length ts' + sum_list (map size ts') +\n     sum_list (map size (remove1 (C nm \\<bullet>\\<bullet> ts') ts))\\<rbrakk>\n    \\<Longrightarrow> ts \\<noteq> []", "apply (metis gr_implies_not0 length_0_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Linear patterns:\\<close>"], ["", "function linpats :: \"tm list \\<Rightarrow> bool\" where\n\"linpats ts \\<longleftrightarrow>\n (\\<forall>i<size ts. (\\<exists>x. ts!i = V x) \\<or>\n    (\\<exists>nm ts'. ts!i = C nm \\<bullet>\\<bullet> ts' \\<and> arity nm = size ts' \\<and> linpats ts')) \\<and>\n (\\<forall>i<size ts. \\<forall>j<size ts. i\\<noteq>j \\<longrightarrow> fv(ts!i) \\<inter> fv(ts!j) = {})\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>ts. x = ts \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>ts tsa.\n       ts = tsa \\<Longrightarrow>\n       ((\\<forall>i<length ts.\n            (\\<exists>x. ts ! i = V x) \\<or>\n            (\\<exists>nm ts'.\n                ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n                arity nm = length ts' \\<and> linpats_sumC ts')) \\<and>\n        (\\<forall>i<length ts.\n            \\<forall>j<length ts.\n               i \\<noteq> j \\<longrightarrow>\n               fv (ts ! i) \\<inter> fv (ts ! j) = {})) =\n       ((\\<forall>i<length tsa.\n            (\\<exists>x. tsa ! i = V x) \\<or>\n            (\\<exists>nm ts'.\n                tsa ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n                arity nm = length ts' \\<and> linpats_sumC ts')) \\<and>\n        (\\<forall>i<length tsa.\n            \\<forall>j<length tsa.\n               i \\<noteq> j \\<longrightarrow>\n               fv (tsa ! i) \\<inter> fv (tsa ! j) = {}))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All linpats_dom", "apply(relation \"measure(%ts. size ts + (SUM t<-ts. size t))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure (\\<lambda>ts. length ts + sum_list (map size ts)))\n 2. \\<And>ts x xa xb.\n       \\<lbrakk>x < length ts; ts ! x = C xa \\<bullet>\\<bullet> xb;\n        arity xa = length xb\\<rbrakk>\n       \\<Longrightarrow> (xb, ts)\n                         \\<in> measure\n                                (\\<lambda>ts.\n                                    length ts + sum_list (map size ts))", "apply (auto simp:termination_linpats)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare linpats.simps[simp del]"], ["", "(* FIXME move *)"], ["", "lemma eq_lists_iff_eq_nth:\n  \"size xs = size ys \\<Longrightarrow> (xs=ys) = (\\<forall>i<size xs. xs!i = ys!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    (xs = ys) = (\\<forall>i<length xs. xs ! i = ys ! i)", "by (metis nth_equalityI)"], ["", "lemma pattern_subst_ML_coincidence:\n \"pattern t \\<Longrightarrow> \\<forall>i\\<in>fv t. \\<sigma> i = \\<sigma>' i\n  \\<Longrightarrow> subst_ML \\<sigma> (comp_pat t) = subst_ML \\<sigma>' (comp_pat t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pattern t;\n     \\<forall>i\\<in>fv t. \\<sigma> i = \\<sigma>' i\\<rbrakk>\n    \\<Longrightarrow> subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat t) =\n                      subst\\<^sub>M\\<^sub>L \\<sigma>' (comp_pat t)", "by(induct pred:pattern) auto"], ["", "lemma linpats_pattern: \"linpats ts \\<Longrightarrow> patterns ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linpats ts \\<Longrightarrow> patterns ts", "proof(induct ts rule:linpats.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>x < length ts;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length xb; linpats xb\\<rbrakk>\n                   \\<Longrightarrow> patterns xb;\n        linpats ts\\<rbrakk>\n       \\<Longrightarrow> patterns ts", "case (1 ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x < length ts; ts ! ?x = C ?xa \\<bullet>\\<bullet> ?xb;\n   arity ?xa = length ?xb; linpats ?xb\\<rbrakk>\n  \\<Longrightarrow> patterns ?xb\n  linpats ts\n\ngoal (1 subgoal):\n 1. \\<And>ts.\n       \\<lbrakk>\\<And>x xa xb.\n                   \\<lbrakk>x < length ts;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length xb; linpats xb\\<rbrakk>\n                   \\<Longrightarrow> patterns xb;\n        linpats ts\\<rbrakk>\n       \\<Longrightarrow> patterns ts", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. patterns ts", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ts \\<Longrightarrow> pattern x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ts \\<Longrightarrow> pattern x", "assume \"t : set ts\""], ["proof (state)\nthis:\n  t \\<in> set ts\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ts \\<Longrightarrow> pattern x", "then"], ["proof (chain)\npicking this:\n  t \\<in> set ts", "obtain i where \"i < size ts\" and [simp]: \"t = ts!i\""], ["proof (prove)\nusing this:\n  t \\<in> set ts\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ts; t = ts ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length ts\n  t = ts ! i\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ts \\<Longrightarrow> pattern x", "hence \"(\\<exists>x. t = V x) \\<or> (\\<exists>nm ts'. t = C nm \\<bullet>\\<bullet> ts' \\<and> arity nm = size ts' & linpats ts')\"\n      (is \"?V | ?C\")"], ["proof (prove)\nusing this:\n  i < length ts\n  t = ts ! i\n\ngoal (1 subgoal):\n 1. (\\<exists>x. t = V x) \\<or>\n    (\\<exists>nm ts'.\n        t = C nm \\<bullet>\\<bullet> ts' \\<and>\n        arity nm = length ts' \\<and> linpats ts')", "using 1(2)"], ["proof (prove)\nusing this:\n  i < length ts\n  t = ts ! i\n  linpats ts\n\ngoal (1 subgoal):\n 1. (\\<exists>x. t = V x) \\<or>\n    (\\<exists>nm ts'.\n        t = C nm \\<bullet>\\<bullet> ts' \\<and>\n        arity nm = length ts' \\<and> linpats ts')", "by(simp add:linpats.simps[of ts])"], ["proof (state)\nthis:\n  (\\<exists>x. t = V x) \\<or>\n  (\\<exists>nm ts'.\n      t = C nm \\<bullet>\\<bullet> ts' \\<and>\n      arity nm = length ts' \\<and> linpats ts')\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set ts \\<Longrightarrow> pattern x", "thus \"pattern t\""], ["proof (prove)\nusing this:\n  (\\<exists>x. t = V x) \\<or>\n  (\\<exists>nm ts'.\n      t = C nm \\<bullet>\\<bullet> ts' \\<and>\n      arity nm = length ts' \\<and> linpats ts')\n\ngoal (1 subgoal):\n 1. pattern t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. t = V x \\<Longrightarrow> pattern t\n 2. \\<exists>nm ts'.\n       t = C nm \\<bullet>\\<bullet> ts' \\<and>\n       arity nm = length ts' \\<and> linpats ts' \\<Longrightarrow>\n    pattern t", "assume \"?V\""], ["proof (state)\nthis:\n  \\<exists>x. t = V x\n\ngoal (2 subgoals):\n 1. \\<exists>x. t = V x \\<Longrightarrow> pattern t\n 2. \\<exists>nm ts'.\n       t = C nm \\<bullet>\\<bullet> ts' \\<and>\n       arity nm = length ts' \\<and> linpats ts' \\<Longrightarrow>\n    pattern t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. t = V x\n\ngoal (1 subgoal):\n 1. pattern t", "by(auto simp:pat_V)"], ["proof (state)\nthis:\n  pattern t\n\ngoal (1 subgoal):\n 1. \\<exists>nm ts'.\n       t = C nm \\<bullet>\\<bullet> ts' \\<and>\n       arity nm = length ts' \\<and> linpats ts' \\<Longrightarrow>\n    pattern t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>nm ts'.\n       t = C nm \\<bullet>\\<bullet> ts' \\<and>\n       arity nm = length ts' \\<and> linpats ts' \\<Longrightarrow>\n    pattern t", "assume \"?C\""], ["proof (state)\nthis:\n  \\<exists>nm ts'.\n     t = C nm \\<bullet>\\<bullet> ts' \\<and>\n     arity nm = length ts' \\<and> linpats ts'\n\ngoal (1 subgoal):\n 1. \\<exists>nm ts'.\n       t = C nm \\<bullet>\\<bullet> ts' \\<and>\n       arity nm = length ts' \\<and> linpats ts' \\<Longrightarrow>\n    pattern t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>nm ts'.\n     t = C nm \\<bullet>\\<bullet> ts' \\<and>\n     arity nm = length ts' \\<and> linpats ts'\n\ngoal (1 subgoal):\n 1. pattern t", "using 1(1) \\<open>i < size ts\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>nm ts'.\n     t = C nm \\<bullet>\\<bullet> ts' \\<and>\n     arity nm = length ts' \\<and> linpats ts'\n  \\<lbrakk>?x < length ts; ts ! ?x = C ?xa \\<bullet>\\<bullet> ?xb;\n   arity ?xa = length ?xb; linpats ?xb\\<rbrakk>\n  \\<Longrightarrow> patterns ?xb\n  i < length ts\n\ngoal (1 subgoal):\n 1. pattern t", "by auto (metis pat_C)"], ["proof (state)\nthis:\n  pattern t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pattern t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  patterns ts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_match_ML_swap_rev:\n  \"length ps = length vs \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L ps (rev vs) \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev ps) vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ps = length vs;\n     no_match\\<^sub>M\\<^sub>L ps (rev vs)\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev ps) vs", "apply(clarsimp simp: no_match_ML.simps[of ps] no_match_ML.simps[of _ vs])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' vsa vs'.\n       \\<lbrakk>length ps = length vs; i < length vs;\n        rev ps ! i = C\\<^sub>U nm vsa; vs ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vsa vs'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length vs.\n                            \\<exists>nm nm' vsa.\n                               ps ! i = C\\<^sub>U nm vsa \\<and>\n                               (\\<exists>vs'.\n                                   rev vs ! i = C\\<^sub>U nm' vs' \\<and>\n                                   (nm = nm' \\<longrightarrow>\n                                    no_match\\<^sub>M\\<^sub>L vsa vs'))", "apply(rule_tac x=\"size ps - i - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i nm nm' vsa vs'.\n       \\<lbrakk>length ps = length vs; i < length vs;\n        rev ps ! i = C\\<^sub>U nm vsa; vs ! i = C\\<^sub>U nm' vs';\n        nm = nm' \\<longrightarrow> no_match\\<^sub>M\\<^sub>L vsa vs'\\<rbrakk>\n       \\<Longrightarrow> length ps - i - 1 < length vs \\<and>\n                         (\\<exists>nm nm' vsa.\n                             ps ! (length ps - i - 1) =\n                             C\\<^sub>U nm vsa \\<and>\n                             (\\<exists>vs'.\n                                 rev vs ! (length ps - i - 1) =\n                                 C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vsa vs')))", "apply (fastforce simp:rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_match_ML_aux:\n  \"\\<forall>v \\<in> set cvs. C\\<^sub>Us v \\<Longrightarrow> linpats ps \\<Longrightarrow> size ps = size cvs \\<Longrightarrow>\n  \\<forall>\\<sigma>. map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ps) \\<noteq> cvs \\<Longrightarrow>\n  no_match\\<^sub>M\\<^sub>L (map comp_pat ps) cvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>set cvs. C\\<^sub>Us v; linpats ps;\n     length ps = length cvs;\n     \\<forall>\\<sigma>.\n        map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ps) \\<noteq>\n        cvs\\<rbrakk>\n    \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ps) cvs", "apply(induct ps arbitrary: cvs rule:linpats.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvs.\n                   \\<lbrakk>x < length ts;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length xb; Ball (set cvs) C\\<^sub>Us;\n                    linpats xb; length xb = length cvs;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                        (map comp_pat xb) \\<noteq>\n                       cvs\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvs;\n        Ball (set cvs) C\\<^sub>Us; linpats ts; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ts) \\<noteq>\n           cvs\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(frule linpats_pattern)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvs.\n                   \\<lbrakk>x < length ts;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length xb; Ball (set cvs) C\\<^sub>Us;\n                    linpats xb; length xb = length cvs;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                        (map comp_pat xb) \\<noteq>\n                       cvs\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvs;\n        Ball (set cvs) C\\<^sub>Us; linpats ts; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ts) \\<noteq>\n           cvs;\n        patterns ts\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(subst (asm) linpats.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvs.\n                   \\<lbrakk>x < length ts;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length xb; Ball (set cvs) C\\<^sub>Us;\n                    (\\<forall>i<length xb.\n                        (\\<exists>x. xb ! i = V x) \\<or>\n                        (\\<exists>nm ts'.\n                            xb ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n                            arity nm = length ts' \\<and>\n                            linpats ts')) \\<and>\n                    (\\<forall>i<length xb.\n                        \\<forall>j<length xb.\n                           i \\<noteq> j \\<longrightarrow>\n                           fv (xb ! i) \\<inter> fv (xb ! j) = {});\n                    length xb = length cvs;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                        (map comp_pat xb) \\<noteq>\n                       cvs\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvs;\n        Ball (set cvs) C\\<^sub>Us; linpats ts; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ts) \\<noteq>\n           cvs;\n        patterns ts\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "back"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvs.\n                   \\<lbrakk>x < length ts;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length xb; Ball (set cvs) C\\<^sub>Us;\n                    linpats xb; length xb = length cvs;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma>)\n                        (map comp_pat xb) \\<noteq>\n                       cvs\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvs;\n        Ball (set cvs) C\\<^sub>Us;\n        (\\<forall>i<length ts.\n            (\\<exists>x. ts ! i = V x) \\<or>\n            (\\<exists>nm ts'.\n                ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n                arity nm = length ts' \\<and> linpats ts')) \\<and>\n        (\\<forall>i<length ts.\n            \\<forall>j<length ts.\n               i \\<noteq> j \\<longrightarrow>\n               fv (ts ! i) \\<inter> fv (ts ! j) = {});\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma>) (map comp_pat ts) \\<noteq>\n           cvs;\n        patterns ts\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {}\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(case_tac \"\\<forall>i<size ts. \\<exists>\\<sigma>. subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts!i)) = cvs!i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<forall>i<length ts.\n           \\<exists>\\<sigma>.\n              subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n              cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(clarsimp simp:Skolem_list_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs xs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length xs = length cvs;\n        \\<forall>i<length cvs.\n           subst\\<^sub>M\\<^sub>L (xs ! i) (comp_pat (ts ! i)) =\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(rename_tac \"\\<sigma>s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        \\<forall>i<length cvs.\n           subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i)) =\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(erule_tac x=\"%x. (\\<sigma>s!(THE i. i<size ts & x : fv(ts!i)))x\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        \\<forall>i<length cvs.\n           subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i)) =\n           cvs ! i;\n        map (subst\\<^sub>M\\<^sub>L\n              (\\<lambda>x.\n                  (\\<sigma>s !\n                   (THE i. i < length ts \\<and> x \\<in> fv (ts ! i)))\n                   x) \\<circ>\n             comp_pat)\n         ts \\<noteq>\n        cvs\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(clarsimp simp:eq_lists_iff_eq_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       \\<exists>i<length cvsa.\n                          subst\\<^sub>M\\<^sub>L \\<sigma>\n                           (comp_pat (xb ! i)) \\<noteq>\n                          cvsa ! i\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        \\<forall>i<length cvs.\n           subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i)) =\n           cvs ! i;\n        i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(rotate_tac -3)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>\\<forall>i<length cvs.\n                   subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i)\n                    (comp_pat (ts ! i)) =\n                   cvs ! i;\n        i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        cvs ! i;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(erule_tac x=i in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        cvs ! i;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        i < length cvs \\<longrightarrow>\n        subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i)) =\n        cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        cvs ! i;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i)) =\n        cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(rotate_tac -1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i)) =\n                cvs ! i;\n        i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        cvs ! i;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(drule sym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        cvs ! i;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i =\n        subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i))\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        subst\\<^sub>M\\<^sub>L\n         (\\<lambda>x.\n             (\\<sigma>s !\n              (THE i. i < length cvs \\<and> x \\<in> fv (ts ! i)))\n              x)\n         (comp_pat (ts ! i)) \\<noteq>\n        subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i =\n        subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i))\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(erule contrapos_np)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\\<rbrakk>\n       \\<Longrightarrow> subst\\<^sub>M\\<^sub>L\n                          (\\<lambda>x.\n                              (\\<sigma>s !\n                               (THE i.\n                                   i < length cvs \\<and>\n                                   x \\<in> fv (ts ! i)))\n                               x)\n                          (comp_pat (ts ! i)) =\n                         subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i)\n                          (comp_pat (ts ! i))\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(rule pattern_subst_ML_coincidence)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\\<rbrakk>\n       \\<Longrightarrow> pattern (ts ! i)\n 2. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia\\<in>fv (ts ! i).\n                            (\\<sigma>s !\n                             (THE i.\n                                 i < length cvs \\<and>\n                                 ia \\<in> fv (ts ! i)))\n                             ia =\n                            (\\<sigma>s ! i) ia\n 3. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply (metis in_set_conv_nth)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ia\\<in>fv (ts ! i).\n                            (\\<sigma>s !\n                             (THE i.\n                                 i < length cvs \\<and>\n                                 ia \\<in> fv (ts ! i)))\n                             ia =\n                            (\\<sigma>s ! i) ia\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i ia.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i)\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>s !\n                          (THE i.\n                              i < length cvs \\<and> ia \\<in> fv (ts ! i)))\n                          ia =\n                         (\\<sigma>s ! i) ia\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(rule_tac a=i in theI2)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i ia.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i)\\<rbrakk>\n       \\<Longrightarrow> i < length cvs \\<and> ia \\<in> fv (ts ! i)\n 2. \\<And>ts cvs \\<sigma>s i ia x.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i);\n        x < length cvs \\<and> ia \\<in> fv (ts ! x)\\<rbrakk>\n       \\<Longrightarrow> x = i\n 3. \\<And>ts cvs \\<sigma>s i ia x.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i);\n        x < length cvs \\<and> ia \\<in> fv (ts ! x)\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>s ! x) ia = (\\<sigma>s ! i) ia\n 4. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i ia x.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i);\n        x < length cvs \\<and> ia \\<in> fv (ts ! x)\\<rbrakk>\n       \\<Longrightarrow> x = i\n 2. \\<And>ts cvs \\<sigma>s i ia x.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i);\n        x < length cvs \\<and> ia \\<in> fv (ts ! x)\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>s ! x) ia = (\\<sigma>s ! i) ia\n 3. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply (metis disjoint_iff_not_equal)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs \\<sigma>s i ia x.\n       \\<lbrakk>i < length cvs;\n        \\<And>x xa xb cvsa.\n           \\<lbrakk>x < length cvs; ts ! x = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               \\<exists>i<length cvsa.\n                  subst\\<^sub>M\\<^sub>L \\<sigma>\n                   (comp_pat (xb ! i)) \\<noteq>\n                  cvsa ! i\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        length \\<sigma>s = length cvs;\n        cvs ! i = subst\\<^sub>M\\<^sub>L (\\<sigma>s ! i) (comp_pat (ts ! i));\n        \\<not> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs;\n        ia \\<in> fv (ts ! i);\n        x < length cvs \\<and> ia \\<in> fv (ts ! x)\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma>s ! x) ia = (\\<sigma>s ! i) ia\n 2. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply (metis disjoint_iff_not_equal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        \\<not> (\\<forall>i<length ts.\n                   \\<exists>\\<sigma>.\n                      subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) =\n                      cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts) cvs", "apply(subst no_match_ML.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<min (length cvs)\n                                     (length (map comp_pat ts)).\n                            \\<exists>nm nm' vs vs'.\n                               rev (map comp_pat ts) ! i =\n                               C\\<^sub>U nm vs \\<and>\n                               rev cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                               (nm = nm' \\<longrightarrow>\n                                no_match\\<^sub>M\\<^sub>L vs vs')", "apply(rule_tac x=\"size ts - i - 1\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> length ts - i - 1\n                         < min (length cvs)\n                            (length (map comp_pat ts)) \\<and>\n                         (\\<exists>nm nm' vs vs'.\n                             rev (map comp_pat ts) ! (length ts - i - 1) =\n                             C\\<^sub>U nm vs \\<and>\n                             rev cvs ! (length ts - i - 1) =\n                             C\\<^sub>U nm' vs' \\<and>\n                             (nm = nm' \\<longrightarrow>\n                              no_match\\<^sub>M\\<^sub>L vs vs'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> length cvs - Suc i < length cvs \\<and>\n                         (\\<exists>nm nm' vs.\n                             rev (map comp_pat ts) ! (length cvs - Suc i) =\n                             C\\<^sub>U nm vs \\<and>\n                             (\\<exists>vs'.\n                                 rev cvs ! (length cvs - Suc i) =\n                                 C\\<^sub>U nm' vs' \\<and>\n                                 (nm = nm' \\<longrightarrow>\n                                  no_match\\<^sub>M\\<^sub>L vs vs')))", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> length cvs - Suc i < length cvs\n 2. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply(subgoal_tac \"\\<not>(\\<exists>x. ts!i = V x)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))\n 2. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>x. ts ! i = V x", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>x. ts ! i = V x\n 2. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply(subgoal_tac \"\\<exists>nm ts'. ts!i = C nm \\<bullet>\\<bullet> ts' & size ts' = arity nm & linpats ts'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x;\n        \\<exists>nm ts'.\n           ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n           length ts' = arity nm \\<and> linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))\n 2. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ts'.\n                            ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n                            length ts' = arity nm \\<and> linpats ts'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm ts'.\n                            ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n                            length ts' = arity nm \\<and> linpats ts'\n 2. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x;\n        \\<exists>nm ts'.\n           ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n           length ts' = arity nm \\<and> linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           subst\\<^sub>M\\<^sub>L \\<sigma> (comp_pat (ts ! i)) \\<noteq>\n           cvs ! i;\n        \\<nexists>x. ts ! i = V x;\n        \\<exists>nm ts'.\n           ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n           length ts' = arity nm \\<and> linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply(rule_tac x=nm in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply(subgoal_tac \"\\<exists>nm' vs'. cvs!i = C\\<^sub>U nm' vs' & size vs' = arity nm' & (\\<forall>v' \\<in> set vs'. C\\<^sub>Us v')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts';\n        \\<exists>nm' vs'.\n           cvs ! i = C\\<^sub>U nm' vs' \\<and>\n           length vs' = arity nm' \\<and>\n           (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))\n 2. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 2. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts';\n        \\<exists>nm' vs'.\n           cvs ! i = C\\<^sub>U nm' vs' \\<and>\n           length vs' = arity nm' \\<and>\n           (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply(drule_tac x=\"cvs!i\" in bspec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'\\<rbrakk>\n       \\<Longrightarrow> cvs ! i \\<in> set cvs\n 2. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 3. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts';\n        \\<exists>nm' vs'.\n           cvs ! i = C\\<^sub>U nm' vs' \\<and>\n           length vs' = arity nm' \\<and>\n           (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 2. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts';\n        \\<exists>nm' vs'.\n           cvs ! i = C\\<^sub>U nm' vs' \\<and>\n           length vs' = arity nm' \\<and>\n           (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply(case_tac \"cvs!i\")"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>ts cvs i nm ts' x1.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = C\\<^sub>M\\<^sub>L x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 2. \\<And>ts cvs i nm ts' x2.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = V\\<^sub>M\\<^sub>L x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 3. \\<And>ts cvs i nm ts' x31 x32.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = A\\<^sub>M\\<^sub>L x31 x32\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 4. \\<And>ts cvs i nm ts' x4.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = Lam\\<^sub>M\\<^sub>L x4\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 5. \\<And>ts cvs i nm ts' x51 x52.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = C\\<^sub>U x51 x52\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 6. \\<And>ts cvs i nm ts' x61 x62.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = V\\<^sub>U x61 x62\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 7. \\<And>ts cvs i nm ts' x71 x72 x73.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i);\n        cvs ! i = Clo x71 x72 x73\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 8. \\<And>ts cvs i nm ts' x81 x82.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts'; C\\<^sub>Us (cvs ! i); cvs ! i = apply x81 x82\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs'.\n                            cvs ! i = C\\<^sub>U nm' vs' \\<and>\n                            length vs' = arity nm' \\<and>\n                            (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\n 9. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts';\n        \\<exists>nm' vs'.\n           cvs ! i = C\\<^sub>U nm' vs' \\<and>\n           length vs' = arity nm' \\<and>\n           (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i nm ts'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           C\\<^sub>U nm\n            (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n              (rev ts')) \\<noteq>\n           cvs ! i;\n        ts ! i = C nm \\<bullet>\\<bullet> ts'; length ts' = arity nm;\n        linpats ts';\n        \\<exists>nm' vs'.\n           cvs ! i = C\\<^sub>U nm' vs' \\<and>\n           length vs' = arity nm' \\<and>\n           (\\<forall>v'\\<in>set vs'. C\\<^sub>Us v')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>nm' vs.\n                            rev (map comp_pat ts) ! (length cvs - Suc i) =\n                            C\\<^sub>U nm vs \\<and>\n                            (\\<exists>vs'.\n                                rev cvs ! (length cvs - Suc i) =\n                                C\\<^sub>U nm' vs' \\<and>\n                                (nm = nm' \\<longrightarrow>\n                                 no_match\\<^sub>M\\<^sub>L vs vs'))", "apply (clarsimp simp:rev_nth rev_map[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<And>x xa xb cvsa.\n                   \\<lbrakk>x < length cvs;\n                    ts ! x = C xa \\<bullet>\\<bullet> xb;\n                    arity xa = length cvsa;\n                    \\<forall>x\\<in>set cvsa. C\\<^sub>Us x; linpats xb;\n                    length xb = length cvsa;\n                    \\<forall>\\<sigma>.\n                       map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                        xb \\<noteq>\n                       cvsa\\<rbrakk>\n                   \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L\n(map comp_pat xb) cvsa;\n        \\<forall>x\\<in>set cvs. C\\<^sub>Us x; length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'", "apply(erule_tac x=i in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<And>xa xb cvsa.\n           \\<lbrakk>i < length cvs; ts ! i = C xa \\<bullet>\\<bullet> xb;\n            arity xa = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                xb \\<noteq>\n               cvsa\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'", "apply(erule_tac x=nm' in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<And>xb cvsa.\n           \\<lbrakk>i < length cvs; ts ! i = C nm' \\<bullet>\\<bullet> xb;\n            arity nm' = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats xb; length xb = length cvsa;\n            \\<forall>\\<sigma>.\n               map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                xb \\<noteq>\n               cvsa\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat xb)\n                              cvsa\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'", "apply(erule_tac x=\"ts'\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<And>cvsa.\n           \\<lbrakk>i < length cvs; ts ! i = C nm' \\<bullet>\\<bullet> ts';\n            arity nm' = length cvsa; \\<forall>x\\<in>set cvsa. C\\<^sub>Us x;\n            linpats ts'; length ts' = length cvsa;\n            \\<forall>\\<sigma>.\n               map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                ts' \\<noteq>\n               cvsa\\<rbrakk>\n           \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                              cvsa\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'", "apply(erule_tac x=\"rev vs'\" in meta_allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<lbrakk>i < length cvs; ts ! i = C nm' \\<bullet>\\<bullet> ts';\n         arity nm' = length (rev vs');\n         \\<forall>x\\<in>set (rev vs'). C\\<^sub>Us x; linpats ts';\n         length ts' = length (rev vs');\n         \\<forall>\\<sigma>.\n            map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n             ts' \\<noteq>\n            rev vs'\\<rbrakk>\n        \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                           (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'", "apply(subgoal_tac \"no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs');\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (rev (map comp_pat ts'))\n                          vs'\n 2. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                          (rev vs')", "apply(rule no_match_ML_swap_rev)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs');\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> length (map comp_pat ts') = length vs'\n 2. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs');\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                          (rev vs')\n 3. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                          (rev vs')", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs');\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                          (rev vs')\n 2. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                          (rev vs')", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n            ts' \\<noteq>\n           rev vs' \\<Longrightarrow>\n        no_match\\<^sub>M\\<^sub>L (map comp_pat ts') (rev vs')\\<rbrakk>\n       \\<Longrightarrow> no_match\\<^sub>M\\<^sub>L (map comp_pat ts')\n                          (rev vs')", "apply(erule_tac meta_mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ts cvs i ts' nm' vs'.\n       \\<lbrakk>\\<forall>x\\<in>set cvs. C\\<^sub>Us x;\n        length ts = length cvs;\n        \\<forall>\\<sigma>.\n           map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat) ts \\<noteq>\n           cvs;\n        patterns ts;\n        \\<forall>i<length cvs.\n           (\\<exists>x. ts ! i = V x) \\<or>\n           (\\<exists>nm ts'.\n               ts ! i = C nm \\<bullet>\\<bullet> ts' \\<and>\n               arity nm = length ts' \\<and> linpats ts');\n        \\<forall>i<length cvs.\n           \\<forall>j<length cvs.\n              i \\<noteq> j \\<longrightarrow>\n              fv (ts ! i) \\<inter> fv (ts ! j) = {};\n        i < length cvs;\n        \\<forall>\\<sigma>.\n           rev (map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ> comp_pat)\n                 ts') \\<noteq>\n           vs';\n        ts ! i = C nm' \\<bullet>\\<bullet> ts'; length ts' = arity nm';\n        linpats ts'; cvs ! i = C\\<^sub>U nm' vs'; length vs' = arity nm';\n        \\<forall>x\\<in>set vs'. C\\<^sub>Us x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma>.\n                            map (subst\\<^sub>M\\<^sub>L \\<sigma> \\<circ>\n                                 comp_pat)\n                             ts' \\<noteq>\n                            rev vs'", "apply (metis rev_rev_ident)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}