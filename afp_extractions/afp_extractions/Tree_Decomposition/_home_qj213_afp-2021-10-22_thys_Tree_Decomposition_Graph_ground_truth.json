{"file_name": "/home/qj213/afp-2021-10-22/thys/Tree_Decomposition/Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tree_Decomposition", "problem_names": ["lemma finite_edge_set [simp]: \"finite E\"", "lemma edges_are_in_V: assumes \"v\\<rightarrow>w\" shows \"v \\<in> V\" \"w \\<in> V\"", "lemma walk_2 [simp]: \"v\\<rightarrow>w \\<Longrightarrow> walk [v,w]\"", "lemma walk_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys \\<rbrakk> \\<Longrightarrow> walk (xs @ ys)\"", "lemma walk_tl: \"walk xs \\<Longrightarrow> walk (tl xs)\"", "lemma walk_drop: \"walk xs \\<Longrightarrow> walk (drop n xs)\"", "lemma walk_take: \"walk xs \\<Longrightarrow> walk (take n xs)\"", "lemma walk_rev: \"walk xs \\<Longrightarrow> walk (rev xs)\"", "lemma walk_decomp: assumes \"walk (xs @ ys)\" shows \"walk xs\" \"walk ys\"", "lemma walk_dropWhile: \"walk xs \\<Longrightarrow> walk (dropWhile f xs)\"", "lemma walk_takeWhile: \"walk xs \\<Longrightarrow> walk (takeWhile f xs)\"", "lemma walk_in_V: \"walk xs \\<Longrightarrow> set xs \\<subseteq> V\"", "lemma walk_first_edge: \"walk (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma walk_first_edge': \"\\<lbrakk> walk (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\"", "lemma walk_middle_edge: \"walk (xs @ v # w # ys) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma walk_last_edge: \"\\<lbrakk> walk (xs @ ys); xs \\<noteq> Nil; ys \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> last xs\\<rightarrow>hd ys\"", "lemma walk_takeWhile_edge:\n  assumes \"walk (xs @ [v])\" \"xs \\<noteq> Nil\" \"hd xs \\<noteq> v\"\n  shows \"last (takeWhile (\\<lambda>x. x \\<noteq> v) xs)\\<rightarrow>v\" (is \"last ?xs\\<rightarrow>v\")", "lemma connectedI [intro]: \"\\<lbrakk> walk xs; xs \\<noteq> Nil; hd xs = v; last xs = w \\<rbrakk> \\<Longrightarrow> v \\<rightarrow>\\<^sup>* w\"", "lemma connectedE:\n  assumes \"v \\<rightarrow>\\<^sup>* w\"\n  obtains xs where \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\"", "lemma connected_in_V: assumes \"v \\<rightarrow>\\<^sup>* w\" shows \"v \\<in> V\" \"w \\<in> V\"", "lemma connected_refl: \"v \\<in> V \\<Longrightarrow> v \\<rightarrow>\\<^sup>* v\"", "lemma connected_edge: \"v\\<rightarrow>w \\<Longrightarrow> v \\<rightarrow>\\<^sup>* w\"", "lemma connected_trans:\n  assumes u_v: \"u \\<rightarrow>\\<^sup>* v\" and v_w: \"v \\<rightarrow>\\<^sup>* w\"\n  shows \"u \\<rightarrow>\\<^sup>* w\"", "lemma path_singleton [simp]: \"v \\<in> V \\<Longrightarrow> path [v]\"", "lemma path_2 [simp]: \"\\<lbrakk> v\\<rightarrow>w; v \\<noteq> w \\<rbrakk> \\<Longrightarrow> path [v,w]\"", "lemma path_cons: \"\\<lbrakk> path xs; xs \\<noteq> Nil; v\\<rightarrow>hd xs; v \\<notin> set xs \\<rbrakk> \\<Longrightarrow> path (v # xs)\"", "lemma path_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys; distinct (xs @ ys) \\<rbrakk>\n  \\<Longrightarrow> path (xs @ ys)\"", "lemma path_tl: \"path xs \\<Longrightarrow> path (tl xs)\"", "lemma path_drop: \"path xs \\<Longrightarrow> path (drop n xs)\"", "lemma path_take: \"path xs \\<Longrightarrow> path (take n xs)\"", "lemma path_rev: \"path xs \\<Longrightarrow> path (rev xs)\"", "lemma path_decomp: assumes \"path (xs @ ys)\" shows \"path xs\" \"path ys\"", "lemma path_dropWhile: \"path xs \\<Longrightarrow> path (dropWhile f xs)\"", "lemma path_takeWhile: \"path xs \\<Longrightarrow> path (takeWhile f xs)\"", "lemma path_in_V: \"path xs \\<Longrightarrow> set xs \\<subseteq> V\"", "lemma path_first_edge: \"path (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\"", "lemma path_first_edge': \"\\<lbrakk> path (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\"", "lemma path_middle_edge: \"path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w\"", "lemma path_takeWhile_edge: \"\\<lbrakk> path (xs @ [v]); xs \\<noteq> Nil; hd xs \\<noteq> v \\<rbrakk>\n  \\<Longrightarrow> last (takeWhile (\\<lambda>x. x \\<noteq> v) xs)\\<rightarrow>v\"", "lemma path_from_toI [intro]: \"\\<lbrakk> path xs; xs \\<noteq> Nil; hd xs = v; last xs = w \\<rbrakk> \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w\"\n  and path_from_toE [dest]: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> path xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\"", "lemma walk_to_path:\n  assumes \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\"\n  shows \"\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs\"", "lemma cycleI [intro]: \"\\<lbrakk> path xs; length xs > 2; last xs\\<rightarrow>hd xs \\<rbrakk> \\<Longrightarrow> cycle xs\"", "lemma cycleE: \"cycle xs \\<Longrightarrow> path xs \\<and> xs \\<noteq> Nil \\<and> length xs > 2 \\<and> last xs\\<rightarrow>hd xs\"", "lemma meeting_paths_produce_cycle:\n  assumes xs: \"path (v # xs)\" \"xs \\<noteq> Nil\"\n      and ys: \"path (v # ys)\" \"ys \\<noteq> Nil\"\n      and meet: \"last xs = last ys\"\n      and diverge: \"hd xs \\<noteq> hd ys\"\n  shows \"\\<exists>zs. cycle zs \\<and> hd zs = v\"", "lemma unique_paths_implies_no_cycles:\n  assumes unique_paths: \"\\<And>v w. v \\<rightarrow>\\<^sup>* w \\<Longrightarrow> \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w\"\n  shows \"\\<And>xs. \\<not>cycle xs\"", "lemma no_cycles_implies_unique_paths:\n  assumes no_cycles: \"\\<And>xs. \\<not>cycle xs\" and connected: \"v \\<rightarrow>\\<^sup>* w\"\n  shows \"\\<exists>!xs. v \\<leadsto>xs\\<leadsto> w\""], "translations": [["", "lemma finite_edge_set [simp]: \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "using finite_vertex_set valid_edge_set"], ["proof (prove)\nusing this:\n  finite V\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. finite E", "by (simp add: finite_subset)"], ["", "lemma edges_are_in_V: assumes \"v\\<rightarrow>w\" shows \"v \\<in> V\" \"w \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "using assms valid_edge_set"], ["proof (prove)\nusing this:\n  v \\<rightarrow> w\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "by blast+"], ["", "subsection \\<open>Walks\\<close>"], ["", "text \\<open>A walk is sequence of vertices connected by edges.\\<close>"], ["", "inductive walk :: \"'a Walk \\<Rightarrow> bool\" where\nNil [simp]: \"walk []\"\n| Singleton [simp]: \"v \\<in> V \\<Longrightarrow> walk [v]\"\n| Cons: \"v\\<rightarrow>w \\<Longrightarrow> walk (w # vs) \\<Longrightarrow> walk (v # w # vs)\""], ["", "text \\<open>\n  Show a few composition/decomposition lemmas for walks.  These will greatly simplify the proofs\n  that follow.\\<close>"], ["", "lemma walk_2 [simp]: \"v\\<rightarrow>w \\<Longrightarrow> walk [v,w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<Longrightarrow> walk [v, w]", "by (simp add: edges_are_in_V(2) walk.intros(3))"], ["", "lemma walk_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys \\<rbrakk> \\<Longrightarrow> walk (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; walk ys;\n     xs = [] \\<or> ys = [] \\<or> last xs \\<rightarrow> hd ys\\<rbrakk>\n    \\<Longrightarrow> walk (xs @ ys)", "by (induct rule: walk.induct, simp_all add: walk.intros(3))\n     (metis list.exhaust_sel walk.intros(2) walk.intros(3))"], ["", "lemma walk_tl: \"walk xs \\<Longrightarrow> walk (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (tl xs)", "by (induct rule: walk.induct) simp_all"], ["", "lemma walk_drop: \"walk xs \\<Longrightarrow> walk (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (drop n xs)", "by (induct n, simp) (metis drop_Suc tl_drop walk_tl)"], ["", "lemma walk_take: \"walk xs \\<Longrightarrow> walk (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (take n xs)", "by (induct arbitrary: n rule: walk.induct)\n     (simp, metis Graph.walk.simps Graph_axioms take_Cons' take_eq_Nil,\n      metis Graph.walk.simps Graph_axioms edges_are_in_V(1) take_Cons')"], ["", "lemma walk_rev: \"walk xs \\<Longrightarrow> walk (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (rev xs)", "by (induct rule: walk.induct, simp, simp)\n     (metis Singleton edges_are_in_V(1) last_ConsL last_appendR list.sel(1)\n      not_Cons_self2 rev.simps(2) undirected walk_comp)"], ["", "lemma walk_decomp: assumes \"walk (xs @ ys)\" shows \"walk xs\" \"walk ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs &&& walk ys", "using assms append_eq_conv_conj[of xs ys \"xs @ ys\"] walk_take walk_drop"], ["proof (prove)\nusing this:\n  walk (xs @ ys)\n  (xs @ ys = xs @ ys) =\n  (xs = take (length xs) (xs @ ys) \\<and> ys = drop (length xs) (xs @ ys))\n  walk ?xs \\<Longrightarrow> walk (take ?n ?xs)\n  walk ?xs \\<Longrightarrow> walk (drop ?n ?xs)\n\ngoal (1 subgoal):\n 1. walk xs &&& walk ys", "by metis+"], ["", "lemma walk_dropWhile: \"walk xs \\<Longrightarrow> walk (dropWhile f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (dropWhile f xs)", "by (simp add: walk_drop dropWhile_eq_drop)"], ["", "lemma walk_takeWhile: \"walk xs \\<Longrightarrow> walk (takeWhile f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (takeWhile f xs)", "using walk_take takeWhile_eq_take"], ["proof (prove)\nusing this:\n  walk ?xs \\<Longrightarrow> walk (take ?n ?xs)\n  takeWhile ?P ?xs = take (length (takeWhile ?P ?xs)) ?xs\n\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> walk (takeWhile f xs)", "by metis"], ["", "lemma walk_in_V: \"walk xs \\<Longrightarrow> set xs \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk xs \\<Longrightarrow> set xs \\<subseteq> V", "by (induct rule: walk.induct; simp add: edges_are_in_V)"], ["", "lemma walk_first_edge: \"walk (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "using walk.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk ?a; ?a = [] \\<Longrightarrow> ?P;\n   \\<And>v. \\<lbrakk>?a = [v]; v \\<in> V\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>v w vs.\n      \\<lbrakk>?a = v # w # vs; v \\<rightarrow> w; walk (w # vs)\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. walk (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "by fastforce"], ["", "lemma walk_first_edge': \"\\<lbrakk> walk (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "using walk_first_edge"], ["proof (prove)\nusing this:\n  walk (?v # ?w # ?xs) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "by (metis list.exhaust_sel)"], ["", "lemma walk_middle_edge: \"walk (xs @ v # w # ys) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w", "by (induct \"xs @ v # w # ys\" arbitrary: xs rule: walk.induct, simp, simp)\n     (metis list.sel(1,3) self_append_conv2 tl_append2)"], ["", "lemma walk_last_edge: \"\\<lbrakk> walk (xs @ ys); xs \\<noteq> Nil; ys \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> last xs\\<rightarrow>hd ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (xs @ ys); xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last xs \\<rightarrow> hd ys", "using walk_middle_edge[of \"butlast xs\" \"last xs\" \"hd ys\" \"tl ys\"]"], ["proof (prove)\nusing this:\n  walk (butlast xs @ last xs # hd ys # tl ys) \\<Longrightarrow>\n  last xs \\<rightarrow> hd ys\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk (xs @ ys); xs \\<noteq> []; ys \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last xs \\<rightarrow> hd ys", "by (metis Cons_eq_appendI append_butlast_last_id append_eq_append_conv2 list.exhaust_sel self_append_conv)"], ["", "lemma walk_takeWhile_edge:\n  assumes \"walk (xs @ [v])\" \"xs \\<noteq> Nil\" \"hd xs \\<noteq> v\"\n  shows \"last (takeWhile (\\<lambda>x. x \\<noteq> v) xs)\\<rightarrow>v\" (is \"last ?xs\\<rightarrow>v\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "obtain xs' where xs': \"xs = ?xs @ xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs'.\n        xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis takeWhile_dropWhile_id)"], ["proof (state)\nthis:\n  xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs'\n\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs'\n\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v\n 2. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "assume \"xs' = Nil\""], ["proof (state)\nthis:\n  xs' = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v\n 2. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs' = []\n\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "using xs' assms(1,2) walk_last_edge"], ["proof (prove)\nusing this:\n  xs' = []\n  xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs'\n  walk (xs @ [v])\n  xs \\<noteq> []\n  \\<lbrakk>walk (?xs @ ?ys); ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last ?xs \\<rightarrow> hd ?ys\n\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "by force"], ["proof (state)\nthis:\n  last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "assume \"xs' \\<noteq> Nil\""], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "hence \"hd xs' = v\""], ["proof (prove)\nusing this:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd xs' = v", "by (metis (full_types) hd_dropWhile same_append_eq takeWhile_dropWhile_id xs')"], ["proof (state)\nthis:\n  hd xs' = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = takeWhile (\\<lambda>x. x \\<noteq> v) xs @ xs';\n     xs' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "thus ?thesis"], ["proof (prove)\nusing this:\n  hd xs' = v\n\ngoal (1 subgoal):\n 1. last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v", "by (metis \\<open>xs' \\<noteq> []\\<close> append_Nil assms(1,3) walk_decomp(1) walk_last_edge xs')"], ["proof (state)\nthis:\n  last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (takeWhile (\\<lambda>x. x \\<noteq> v) xs) \\<rightarrow> v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Connectivity\\<close>"], ["", "definition connected :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" (infixl \"\\<rightarrow>\\<^sup>*\" 60) where\n  \"connected v w \\<equiv> \\<exists>xs. walk xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\""], ["", "lemma connectedI [intro]: \"\\<lbrakk> walk xs; xs \\<noteq> Nil; hd xs = v; last xs = w \\<rbrakk> \\<Longrightarrow> v \\<rightarrow>\\<^sup>* w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow>\\<^sup>* w", "unfolding connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         walk xs \\<and>\n                         xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w", "by blast"], ["", "lemma connectedE:\n  assumes \"v \\<rightarrow>\\<^sup>* w\"\n  obtains xs where \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms that"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^sup>* w\n  \\<lbrakk>walk ?xs; ?xs \\<noteq> []; hd ?xs = v; last ?xs = w\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding connected_def"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     walk xs \\<and> xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w\n  \\<lbrakk>walk ?xs; ?xs \\<noteq> []; hd ?xs = v; last ?xs = w\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma connected_in_V: assumes \"v \\<rightarrow>\\<^sup>* w\" shows \"v \\<in> V\" \"w \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "using assms"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^sup>* w\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "unfolding connected_def"], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     walk xs \\<and> xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "by (meson hd_in_set last_in_set subsetCE walk_in_V)+"], ["", "lemma connected_refl: \"v \\<in> V \\<Longrightarrow> v \\<rightarrow>\\<^sup>* v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> v \\<rightarrow>\\<^sup>* v", "by (rule connectedI[of \"[v]\"]) simp_all"], ["", "lemma connected_edge: \"v\\<rightarrow>w \\<Longrightarrow> v \\<rightarrow>\\<^sup>* w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<Longrightarrow> v \\<rightarrow>\\<^sup>* w", "by (rule connectedI[of \"[v,w]\"]) simp_all"], ["", "lemma connected_trans:\n  assumes u_v: \"u \\<rightarrow>\\<^sup>* v\" and v_w: \"v \\<rightarrow>\\<^sup>* w\"\n  shows \"u \\<rightarrow>\\<^sup>* w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "obtain xs where xs: \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = u\" \"last xs = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = u; last xs = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using u_v connectedE"], ["proof (prove)\nusing this:\n  u \\<rightarrow>\\<^sup>* v\n  \\<lbrakk>?v \\<rightarrow>\\<^sup>* ?w;\n   \\<And>xs.\n      \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = ?v; last xs = ?w\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = u; last xs = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  walk xs\n  xs \\<noteq> []\n  hd xs = u\n  last xs = v\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "obtain ys where ys: \"walk ys\" \"ys \\<noteq> Nil\" \"hd ys = v\" \"last ys = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>walk ys; ys \\<noteq> []; hd ys = v; last ys = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using v_w connectedE"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^sup>* w\n  \\<lbrakk>?v \\<rightarrow>\\<^sup>* ?w;\n   \\<And>xs.\n      \\<lbrakk>walk xs; xs \\<noteq> []; hd xs = ?v; last xs = ?w\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>walk ys; ys \\<noteq> []; hd ys = v; last ys = w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  walk ys\n  ys \\<noteq> []\n  hd ys = v\n  last ys = w\n\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "let ?R = \"xs @ tl ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<rightarrow>\\<^sup>* w", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. walk ?xs\n 2. ?xs \\<noteq> []\n 3. hd ?xs = u\n 4. last ?xs = w", "show \"walk ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (xs @ tl ys)", "using walk_comp[OF xs(1)]"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk ?ys;\n   xs = [] \\<or> ?ys = [] \\<or> last xs \\<rightarrow> hd ?ys\\<rbrakk>\n  \\<Longrightarrow> walk (xs @ ?ys)\n\ngoal (1 subgoal):\n 1. walk (xs @ tl ys)", "by (metis xs(4) ys(1,2,3) list.sel(1,3) walk.simps)"], ["proof (state)\nthis:\n  walk (xs @ tl ys)\n\ngoal (3 subgoals):\n 1. xs @ tl ys \\<noteq> []\n 2. hd (xs @ tl ys) = u\n 3. last (xs @ tl ys) = w", "show \"?R \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ tl ys \\<noteq> []", "by (simp add: xs(2))"], ["proof (state)\nthis:\n  xs @ tl ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. hd (xs @ tl ys) = u\n 2. last (xs @ tl ys) = w", "show \"hd ?R = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (xs @ tl ys) = u", "by (simp add: xs(2,3))"], ["proof (state)\nthis:\n  hd (xs @ tl ys) = u\n\ngoal (1 subgoal):\n 1. last (xs @ tl ys) = w", "show \"last ?R = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (xs @ tl ys) = w", "using xs(2,4) ys(2,3,4)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  last xs = v\n  ys \\<noteq> []\n  hd ys = v\n  last ys = w\n\ngoal (1 subgoal):\n 1. last (xs @ tl ys) = w", "by (metis append_butlast_last_id last_append last_tl list.exhaust_sel)"], ["proof (state)\nthis:\n  last (xs @ tl ys) = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<rightarrow>\\<^sup>* w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Paths\\<close>"], ["", "text \\<open>A path is a walk without repeated vertices.  This is simple enough, so most of the above\n  lemmas transfer directly to paths.\\<close>"], ["", "abbreviation path :: \"'a Walk \\<Rightarrow> bool\" where \"path xs \\<equiv> walk xs \\<and> distinct xs\""], ["", "lemma path_singleton [simp]: \"v \\<in> V \\<Longrightarrow> path [v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> path [v]", "by simp"], ["", "lemma path_2 [simp]: \"\\<lbrakk> v\\<rightarrow>w; v \\<noteq> w \\<rbrakk> \\<Longrightarrow> path [v,w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<rightarrow> w; v \\<noteq> w\\<rbrakk>\n    \\<Longrightarrow> path [v, w]", "by simp"], ["", "lemma path_cons: \"\\<lbrakk> path xs; xs \\<noteq> Nil; v\\<rightarrow>hd xs; v \\<notin> set xs \\<rbrakk> \\<Longrightarrow> path (v # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path xs; xs \\<noteq> []; v \\<rightarrow> hd xs;\n     v \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> path (v # xs)", "by (metis distinct.simps(2) list.exhaust_sel walk.Cons)"], ["", "lemma path_comp: \"\\<lbrakk> walk xs; walk ys; xs = Nil \\<or> ys = Nil \\<or> last xs\\<rightarrow>hd ys; distinct (xs @ ys) \\<rbrakk>\n  \\<Longrightarrow> path (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; walk ys;\n     xs = [] \\<or> ys = [] \\<or> last xs \\<rightarrow> hd ys;\n     distinct (xs @ ys)\\<rbrakk>\n    \\<Longrightarrow> path (xs @ ys)", "using walk_comp"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk ?xs; walk ?ys;\n   ?xs = [] \\<or> ?ys = [] \\<or> last ?xs \\<rightarrow> hd ?ys\\<rbrakk>\n  \\<Longrightarrow> walk (?xs @ ?ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>walk xs; walk ys;\n     xs = [] \\<or> ys = [] \\<or> last xs \\<rightarrow> hd ys;\n     distinct (xs @ ys)\\<rbrakk>\n    \\<Longrightarrow> path (xs @ ys)", "by blast"], ["", "lemma path_tl: \"path xs \\<Longrightarrow> path (tl xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (tl xs)", "by (simp add: distinct_tl walk_tl)"], ["", "lemma path_drop: \"path xs \\<Longrightarrow> path (drop n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (drop n xs)", "by (simp add: walk_drop)"], ["", "lemma path_take: \"path xs \\<Longrightarrow> path (take n xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (take n xs)", "by (simp add: walk_take)"], ["", "lemma path_rev: \"path xs \\<Longrightarrow> path (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (rev xs)", "by (simp add: walk_rev)"], ["", "lemma path_decomp: assumes \"path (xs @ ys)\" shows \"path xs\" \"path ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs &&& path ys", "using walk_decomp assms distinct_append"], ["proof (prove)\nusing this:\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?xs\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?ys\n  path (xs @ ys)\n  distinct (?xs @ ?ys) =\n  (distinct ?xs \\<and> distinct ?ys \\<and> set ?xs \\<inter> set ?ys = {})\n\ngoal (1 subgoal):\n 1. path xs &&& path ys", "by blast+"], ["", "lemma path_dropWhile: \"path xs \\<Longrightarrow> path (dropWhile f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (dropWhile f xs)", "by (simp add: walk_dropWhile)"], ["", "lemma path_takeWhile: \"path xs \\<Longrightarrow> path (takeWhile f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> path (takeWhile f xs)", "by (simp add: walk_takeWhile)"], ["", "lemma path_in_V: \"path xs \\<Longrightarrow> set xs \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<Longrightarrow> set xs \\<subseteq> V", "by (simp add: walk_in_V)"], ["", "lemma path_first_edge: \"path (v # w # xs) \\<Longrightarrow> v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "using walk_first_edge"], ["proof (prove)\nusing this:\n  walk (?v # ?w # ?xs) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. path (v # w # xs) \\<Longrightarrow> v \\<rightarrow> w", "by blast"], ["", "lemma path_first_edge': \"\\<lbrakk> path (v # xs); xs \\<noteq> Nil \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "using walk_first_edge'"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk (?v # ?xs); ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow> hd ?xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path (v # xs); xs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd xs", "by blast"], ["", "lemma path_middle_edge: \"path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w", "using walk_middle_edge"], ["proof (prove)\nusing this:\n  walk (?xs @ ?v # ?w # ?ys) \\<Longrightarrow> ?v \\<rightarrow> ?w\n\ngoal (1 subgoal):\n 1. path (xs @ v # w # ys) \\<Longrightarrow> v \\<rightarrow> w", "by blast"], ["", "lemma path_takeWhile_edge: \"\\<lbrakk> path (xs @ [v]); xs \\<noteq> Nil; hd xs \\<noteq> v \\<rbrakk>\n  \\<Longrightarrow> last (takeWhile (\\<lambda>x. x \\<noteq> v) xs)\\<rightarrow>v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path (xs @ [v]); xs \\<noteq> []; hd xs \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "using walk_takeWhile_edge"], ["proof (prove)\nusing this:\n  \\<lbrakk>walk (?xs @ [?v]); ?xs \\<noteq> []; hd ?xs \\<noteq> ?v\\<rbrakk>\n  \\<Longrightarrow> last\n                     (takeWhile (\\<lambda>x. x \\<noteq> ?v)\n                       ?xs) \\<rightarrow>\n                    ?v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path (xs @ [v]); xs \\<noteq> []; hd xs \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> last\n                       (takeWhile (\\<lambda>x. x \\<noteq> v)\n                         xs) \\<rightarrow>\n                      v", "by blast"], ["", "end"], ["", "text \\<open>We introduce shorthand notation for a path connecting two vertices.\\<close>"], ["", "definition path_from_to :: \"('a, 'b) Graph_scheme \\<Rightarrow> 'a \\<Rightarrow> 'a Walk \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  (\"_ \\<leadsto>_\\<leadsto>\\<index> _\" [71, 71, 71] 70) where\n  \"path_from_to G v xs w \\<equiv> Graph.path G xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\""], ["", "context Graph begin"], ["", "lemma path_from_toI [intro]: \"\\<lbrakk> path xs; xs \\<noteq> Nil; hd xs = v; last xs = w \\<rbrakk> \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w\"\n  and path_from_toE [dest]: \"v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow> path xs \\<and> xs \\<noteq> Nil \\<and> hd xs = v \\<and> last xs = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n     \\<Longrightarrow> v \\<leadsto>xs\\<leadsto> w) &&&\n    (v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n     path xs \\<and> xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w)", "unfolding path_from_to_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>path xs; xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n     \\<Longrightarrow> path xs \\<and>\n                       xs \\<noteq> [] \\<and>\n                       hd xs = v \\<and> last xs = w) &&&\n    (path xs \\<and>\n     xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w \\<Longrightarrow>\n     path xs \\<and> xs \\<noteq> [] \\<and> hd xs = v \\<and> last xs = w)", "by blast+"], ["", "text \\<open>Every walk contains a path connecting the same vertices.\\<close>"], ["", "lemma walk_to_path:\n  assumes \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\"\n  shows \"\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "text \\<open>We prove this by removing loops from @{term xs} until @{term xs} is a path.\n    We want to perform induction over @{term \"length xs\"}, but @{term xs} in\n    @{term \"set ys \\<subseteq> set xs\"} should not be part of the induction hypothesis. To accomplish this,\n    we hide @{term \"set xs\"} behind a definition for this specific part of the goal.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "define target_set where \"target_set = set xs\""], ["proof (state)\nthis:\n  target_set = set xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "hence \"set xs \\<subseteq> target_set\""], ["proof (prove)\nusing this:\n  target_set = set xs\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> target_set", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> set xs", "thus \"\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\""], ["proof (prove)\nusing this:\n  set xs \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> target_set\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n\ngoal (1 subgoal):\n 1. \\<exists>ys.\n       v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set", "proof (induct \"length xs\" arbitrary: xs rule: infinite_descent0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "case (smaller n)"], ["proof (state)\nthis:\n  0 < n\n  \\<not> (\\<forall>x.\n             n = length x \\<longrightarrow>\n             set x \\<subseteq> target_set \\<longrightarrow>\n             walk x \\<longrightarrow>\n             x \\<noteq> [] \\<longrightarrow>\n             hd x = v \\<longrightarrow>\n             last x = w \\<longrightarrow>\n             (\\<exists>ys.\n                 v \\<leadsto>ys\\<leadsto> w \\<and>\n                 set ys \\<subseteq> target_set))\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "then"], ["proof (chain)\npicking this:\n  0 < n\n  \\<not> (\\<forall>x.\n             n = length x \\<longrightarrow>\n             set x \\<subseteq> target_set \\<longrightarrow>\n             walk x \\<longrightarrow>\n             x \\<noteq> [] \\<longrightarrow>\n             hd x = v \\<longrightarrow>\n             last x = w \\<longrightarrow>\n             (\\<exists>ys.\n                 v \\<leadsto>ys\\<leadsto> w \\<and>\n                 set ys \\<subseteq> target_set))", "obtain xs where\n      xs: \"n = length xs\" \"walk xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\" \"set xs \\<subseteq> target_set\" and\n      hyp: \"\\<not>(\\<exists>ys. v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set)\""], ["proof (prove)\nusing this:\n  0 < n\n  \\<not> (\\<forall>x.\n             n = length x \\<longrightarrow>\n             set x \\<subseteq> target_set \\<longrightarrow>\n             walk x \\<longrightarrow>\n             x \\<noteq> [] \\<longrightarrow>\n             hd x = v \\<longrightarrow>\n             last x = w \\<longrightarrow>\n             (\\<exists>ys.\n                 v \\<leadsto>ys\\<leadsto> w \\<and>\n                 set ys \\<subseteq> target_set))\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>n = length xs; walk xs; xs \\<noteq> []; hd xs = v;\n         last xs = w; set xs \\<subseteq> target_set;\n         \\<nexists>ys.\n            v \\<leadsto>ys\\<leadsto> w \\<and>\n            set ys \\<subseteq> target_set\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "text \\<open>If @{term xs} is not a path, then @{term xs} is not distinct and we can decompose it.\\<close>"], ["proof (state)\nthis:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "then"], ["proof (chain)\npicking this:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set", "obtain ys zs u\n      where xs_decomp: \"u \\<in> set ys\" \"distinct ys\" \"xs = ys @ u # zs\""], ["proof (prove)\nusing this:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. (\\<And>u ys zs.\n        \\<lbrakk>u \\<in> set ys; distinct ys; xs = ys @ u # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_distinct_conv_prefix"], ["proof (prove)\nusing this:\n  n = length xs\n  walk xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  set xs \\<subseteq> target_set\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n  (\\<not> distinct ?as) =\n  (\\<exists>xs y ys.\n      y \\<in> set xs \\<and> distinct xs \\<and> ?as = xs @ y # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>u ys zs.\n        \\<lbrakk>u \\<in> set ys; distinct ys; xs = ys @ u # zs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis path_from_toI)"], ["proof (state)\nthis:\n  u \\<in> set ys\n  distinct ys\n  xs = ys @ u # zs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "text \\<open>@{term u} appears in @{term xs}, so we have a loop in @{term xs} starting from an\n      occurrence of @{term u} in @{term xs} ending in the vertex @{term u} in @{term \"u # ys\"}.\n      We define @{term zs} as @{term xs} without this loop.\\<close>"], ["proof (state)\nthis:\n  u \\<in> set ys\n  distinct ys\n  xs = ys @ u # zs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "obtain ys' ys_suffix where\n      ys_decomp: \"ys = ys' @ u # ys_suffix\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys' ys_suffix.\n        ys = ys' @ u # ys_suffix \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list xs_decomp(1))"], ["proof (state)\nthis:\n  ys = ys' @ u # ys_suffix\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "define zs' where \"zs' = ys' @ u # zs\""], ["proof (state)\nthis:\n  zs' = ys' @ u # zs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"walk zs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk zs'", "unfolding zs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (ys' @ u # zs)", "using xs(2) xs_decomp(3) ys_decomp"], ["proof (prove)\nusing this:\n  walk xs\n  xs = ys @ u # zs\n  ys = ys' @ u # ys_suffix\n\ngoal (1 subgoal):\n 1. walk (ys' @ u # zs)", "by (metis walk_decomp list.sel(1) list.simps(3) walk_comp walk_last_edge)"], ["proof (state)\nthis:\n  walk zs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  walk zs'\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"length zs' < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length zs' < n", "unfolding zs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (ys' @ u # zs) < n", "by (simp add: xs(1) xs_decomp(3) ys_decomp)"], ["proof (state)\nthis:\n  length zs' < n\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  length zs' < n\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"hd zs' = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd zs' = v", "unfolding zs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (ys' @ u # zs) = v", "by (metis append_is_Nil_conv hd_append list.sel(1) xs(4) xs_decomp(3) ys_decomp)"], ["proof (state)\nthis:\n  hd zs' = v\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  hd zs' = v\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"last zs' = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last zs' = w", "unfolding zs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (ys' @ u # zs) = w", "using xs(5) xs_decomp(3)"], ["proof (prove)\nusing this:\n  last xs = w\n  xs = ys @ u # zs\n\ngoal (1 subgoal):\n 1. last (ys' @ u # zs) = w", "by auto"], ["proof (state)\nthis:\n  last zs' = w\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "moreover"], ["proof (state)\nthis:\n  last zs' = w\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "have \"set zs' \\<subseteq> target_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set zs' \\<subseteq> target_set", "unfolding zs'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (ys' @ u # zs) \\<subseteq> target_set", "using xs(6) xs_decomp(3) ys_decomp"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> target_set\n  xs = ys @ u # zs\n  ys = ys' @ u # ys_suffix\n\ngoal (1 subgoal):\n 1. set (ys' @ u # zs) \\<subseteq> target_set", "by auto"], ["proof (state)\nthis:\n  set zs' \\<subseteq> target_set\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set\n 2. \\<And>n.\n       \\<lbrakk>0 < n;\n        \\<not> (\\<forall>x.\n                   n = length x \\<longrightarrow>\n                   set x \\<subseteq> target_set \\<longrightarrow>\n                   walk x \\<longrightarrow>\n                   x \\<noteq> [] \\<longrightarrow>\n                   hd x = v \\<longrightarrow>\n                   last x = w \\<longrightarrow>\n                   (\\<exists>ys.\n                       v \\<leadsto>ys\\<leadsto> w \\<and>\n                       set ys \\<subseteq> target_set))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m<n.\n                            \\<not> (\\<forall>x.\n m = length x \\<longrightarrow>\n set x \\<subseteq> target_set \\<longrightarrow>\n walk x \\<longrightarrow>\n x \\<noteq> [] \\<longrightarrow>\n hd x = v \\<longrightarrow>\n last x = w \\<longrightarrow>\n (\\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set))", "ultimately"], ["proof (chain)\npicking this:\n  walk zs'\n  length zs' < n\n  hd zs' = v\n  last zs' = w\n  set zs' \\<subseteq> target_set", "show ?case"], ["proof (prove)\nusing this:\n  walk zs'\n  length zs' < n\n  hd zs' = v\n  last zs' = w\n  set zs' \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       \\<not> (\\<forall>x.\n                  m = length x \\<longrightarrow>\n                  set x \\<subseteq> target_set \\<longrightarrow>\n                  walk x \\<longrightarrow>\n                  x \\<noteq> [] \\<longrightarrow>\n                  hd x = v \\<longrightarrow>\n                  last x = w \\<longrightarrow>\n                  (\\<exists>ys.\n                      v \\<leadsto>ys\\<leadsto> w \\<and>\n                      set ys \\<subseteq> target_set))", "using zs'_def hyp"], ["proof (prove)\nusing this:\n  walk zs'\n  length zs' < n\n  hd zs' = v\n  last zs' = w\n  set zs' \\<subseteq> target_set\n  zs' = ys' @ u # zs\n  \\<nexists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal (1 subgoal):\n 1. \\<exists>m<n.\n       \\<not> (\\<forall>x.\n                  m = length x \\<longrightarrow>\n                  set x \\<subseteq> target_set \\<longrightarrow>\n                  walk x \\<longrightarrow>\n                  x \\<noteq> [] \\<longrightarrow>\n                  hd x = v \\<longrightarrow>\n                  last x = w \\<longrightarrow>\n                  (\\<exists>ys.\n                      v \\<leadsto>ys\\<leadsto> w \\<and>\n                      set ys \\<subseteq> target_set))", "by blast"], ["proof (state)\nthis:\n  \\<exists>m<n.\n     \\<not> (\\<forall>x.\n                m = length x \\<longrightarrow>\n                set x \\<subseteq> target_set \\<longrightarrow>\n                walk x \\<longrightarrow>\n                x \\<noteq> [] \\<longrightarrow>\n                hd x = v \\<longrightarrow>\n                last x = w \\<longrightarrow>\n                (\\<exists>ys.\n                    v \\<leadsto>ys\\<leadsto> w \\<and>\n                    set ys \\<subseteq> target_set))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs; set xs \\<subseteq> target_set; walk xs;\n        xs \\<noteq> []; hd xs = v; last xs = w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys.\n                            v \\<leadsto>ys\\<leadsto> w \\<and>\n                            set ys \\<subseteq> target_set", "qed simp"], ["proof (state)\nthis:\n  \\<exists>ys.\n     v \\<leadsto>ys\\<leadsto> w \\<and> set ys \\<subseteq> target_set\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary connected_by_path:\n  assumes \"v \\<rightarrow>\\<^sup>* w\"\n  obtains xs where \"v \\<leadsto>xs\\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms connected_def walk_to_path"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^sup>* w\n  ?v \\<rightarrow>\\<^sup>* ?w \\<equiv>\n  \\<exists>xs.\n     walk xs \\<and> xs \\<noteq> [] \\<and> hd xs = ?v \\<and> last xs = ?w\n  \\<lbrakk>walk ?xs; ?xs \\<noteq> []; hd ?xs = ?v; last ?xs = ?w\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ys.\n                       ?v \\<leadsto>ys\\<leadsto> ?w \\<and>\n                       set ys \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        v \\<leadsto>xs\\<leadsto> w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "subsection \\<open>Cycles\\<close>"], ["", "text \\<open>A cycle in an undirected graph is a closed path with at least 3 different vertices.\n  Closed paths with 0 or 1 vertex do not exist (graphs are loop-free), and paths with 2 vertices\n  are not considered loops in undirected graphs.\\<close>"], ["", "definition cycle :: \"'a Walk \\<Rightarrow> bool\" where\n  \"cycle xs \\<equiv> path xs \\<and> length xs > 2 \\<and> last xs \\<rightarrow> hd xs\""], ["", "lemma cycleI [intro]: \"\\<lbrakk> path xs; length xs > 2; last xs\\<rightarrow>hd xs \\<rbrakk> \\<Longrightarrow> cycle xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path xs; 2 < length xs; last xs \\<rightarrow> hd xs\\<rbrakk>\n    \\<Longrightarrow> cycle xs", "unfolding cycle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path xs; 2 < length xs; last xs \\<rightarrow> hd xs\\<rbrakk>\n    \\<Longrightarrow> path xs \\<and>\n                      2 < length xs \\<and> last xs \\<rightarrow> hd xs", "by blast"], ["", "lemma cycleE: \"cycle xs \\<Longrightarrow> path xs \\<and> xs \\<noteq> Nil \\<and> length xs > 2 \\<and> last xs\\<rightarrow>hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle xs \\<Longrightarrow>\n    path xs \\<and>\n    xs \\<noteq> [] \\<and> 2 < length xs \\<and> last xs \\<rightarrow> hd xs", "unfolding cycle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. path xs \\<and>\n    2 < length xs \\<and> last xs \\<rightarrow> hd xs \\<Longrightarrow>\n    path xs \\<and>\n    xs \\<noteq> [] \\<and> 2 < length xs \\<and> last xs \\<rightarrow> hd xs", "by auto"], ["", "text \\<open>We can now show a lemma that explains how to construct cycles from certain paths.\n  If two paths both starting from @{term v} diverge immediately and meet again on their\n  last vertices, then the graph contains a cycle with @{term v} on it.\n\n  Note that if two paths do not diverge immediately but only eventually, then\n  @{prop maximal_common_prefix} can be used to remove the common prefix.\\<close>"], ["", "lemma meeting_paths_produce_cycle:\n  assumes xs: \"path (v # xs)\" \"xs \\<noteq> Nil\"\n      and ys: \"path (v # ys)\" \"ys \\<noteq> Nil\"\n      and meet: \"last xs = last ys\"\n      and diverge: \"hd xs \\<noteq> hd ys\"\n  shows \"\\<exists>zs. cycle zs \\<and> hd zs = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "have \"set xs \\<inter> set ys \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys \\<noteq> {}", "using meet xs(2) ys(2) last_in_set"], ["proof (prove)\nusing this:\n  last xs = last ys\n  xs \\<noteq> []\n  ys \\<noteq> []\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys \\<noteq> {}", "by fastforce"], ["proof (state)\nthis:\n  set xs \\<inter> set ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "then"], ["proof (chain)\npicking this:\n  set xs \\<inter> set ys \\<noteq> {}", "obtain xs' x xs'' where xs': \"xs = xs' @ x # xs''\" \"set xs' \\<inter> set ys = {}\" \"x \\<in> set ys\""], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>xs' x xs''.\n        \\<lbrakk>xs = xs' @ x # xs''; set xs' \\<inter> set ys = {};\n         x \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_first_prop[of xs \"\\<lambda>x. x \\<in> set ys\"]"], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys \\<noteq> {}\n  \\<exists>x\\<in>set xs. x \\<in> set ys \\<Longrightarrow>\n  \\<exists>ysa x zs.\n     xs = ysa @ x # zs \\<and>\n     x \\<in> set ys \\<and> (\\<forall>y\\<in>set ysa. y \\<notin> set ys)\n\ngoal (1 subgoal):\n 1. (\\<And>xs' x xs''.\n        \\<lbrakk>xs = xs' @ x # xs''; set xs' \\<inter> set ys = {};\n         x \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis disjoint_iff_not_equal)"], ["proof (state)\nthis:\n  xs = xs' @ x # xs''\n  set xs' \\<inter> set ys = {}\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "then"], ["proof (chain)\npicking this:\n  xs = xs' @ x # xs''\n  set xs' \\<inter> set ys = {}\n  x \\<in> set ys", "obtain ys' ys'' where ys': \"ys = ys' @ x # ys''\" \"x \\<notin> set ys'\""], ["proof (prove)\nusing this:\n  xs = xs' @ x # xs''\n  set xs' \\<inter> set ys = {}\n  x \\<in> set ys\n\ngoal (1 subgoal):\n 1. (\\<And>ys' ys''.\n        \\<lbrakk>ys = ys' @ x # ys''; x \\<notin> set ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list_first_prop[of ys \"\\<lambda>y. y = x\"]"], ["proof (prove)\nusing this:\n  xs = xs' @ x # xs''\n  set xs' \\<inter> set ys = {}\n  x \\<in> set ys\n  \\<exists>xa\\<in>set ys. xa = x \\<Longrightarrow>\n  \\<exists>ysa xa zs.\n     ys = ysa @ xa # zs \\<and>\n     xa = x \\<and> (\\<forall>y\\<in>set ysa. y \\<noteq> x)\n\ngoal (1 subgoal):\n 1. (\\<And>ys' ys''.\n        \\<lbrakk>ys = ys' @ x # ys''; x \\<notin> set ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ys = ys' @ x # ys''\n  x \\<notin> set ys'\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "let ?zs = \"v # xs' @ x # (rev ys')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "have \"last ?zs\\<rightarrow>hd ?zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')", "using undirected walk_first_edge walk_first_edge' ys'(1) ys(1) last_rev"], ["proof (prove)\nusing this:\n  ?v \\<rightarrow> ?w = ?w \\<rightarrow> ?v\n  walk (?v # ?w # ?xs) \\<Longrightarrow> ?v \\<rightarrow> ?w\n  \\<lbrakk>walk (?v # ?xs); ?xs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow> hd ?xs\n  ys = ys' @ x # ys''\n  path (v # ys)\n  ?xs \\<noteq> [] \\<Longrightarrow> last (rev ?xs) = hd ?xs\n\ngoal (1 subgoal):\n 1. last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')", "by fastforce"], ["proof (state)\nthis:\n  last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "moreover"], ["proof (state)\nthis:\n  last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "have \"path ?zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (v # xs' @ x # rev ys')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. walk (v # xs' @ x # rev ys')\n 2. distinct (v # xs' @ x # rev ys')", "have \"walk (x # rev ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (x # rev ys')", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> walk (x # rev ys')\n 2. \\<not> ?P \\<Longrightarrow> walk (x # rev ys')", "assume \"ys' = Nil\""], ["proof (state)\nthis:\n  ys' = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> walk (x # rev ys')\n 2. \\<not> ?P \\<Longrightarrow> walk (x # rev ys')", "thus ?thesis"], ["proof (prove)\nusing this:\n  ys' = []\n\ngoal (1 subgoal):\n 1. walk (x # rev ys')", "using \\<open>last ?zs\\<rightarrow>hd ?zs\\<close> edges_are_in_V(1)"], ["proof (prove)\nusing this:\n  ys' = []\n  last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?v \\<in> V\n\ngoal (1 subgoal):\n 1. walk (x # rev ys')", "by auto"], ["proof (state)\nthis:\n  walk (x # rev ys')\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "assume \"ys' \\<noteq> Nil\""], ["proof (state)\nthis:\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "moreover"], ["proof (state)\nthis:\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "hence \"last ys'\\<rightarrow>x\""], ["proof (prove)\nusing this:\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last ys' \\<rightarrow> x", "using walk_last_edge walk_tl ys'(1) ys(1)"], ["proof (prove)\nusing this:\n  ys' \\<noteq> []\n  \\<lbrakk>walk (?xs @ ?ys); ?xs \\<noteq> []; ?ys \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> last ?xs \\<rightarrow> hd ?ys\n  walk ?xs \\<Longrightarrow> walk (tl ?xs)\n  ys = ys' @ x # ys''\n  path (v # ys)\n\ngoal (1 subgoal):\n 1. last ys' \\<rightarrow> x", "by fastforce"], ["proof (state)\nthis:\n  last ys' \\<rightarrow> x\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "moreover"], ["proof (state)\nthis:\n  last ys' \\<rightarrow> x\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "have \"hd (rev ys') = last ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (rev ys') = last ys'", "by (simp add: \\<open>ys' \\<noteq> []\\<close> hd_rev)"], ["proof (state)\nthis:\n  hd (rev ys') = last ys'\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "moreover"], ["proof (state)\nthis:\n  hd (rev ys') = last ys'\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "have \"walk (rev ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. walk (rev ys')", "by (metis list.sel(3) walk_decomp(1) walk_rev walk_tl ys'(1) ys(1))"], ["proof (state)\nthis:\n  walk (rev ys')\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> [] \\<Longrightarrow> walk (x # rev ys')", "ultimately"], ["proof (chain)\npicking this:\n  ys' \\<noteq> []\n  last ys' \\<rightarrow> x\n  hd (rev ys') = last ys'\n  walk (rev ys')", "show \"walk (x # rev ys')\""], ["proof (prove)\nusing this:\n  ys' \\<noteq> []\n  last ys' \\<rightarrow> x\n  hd (rev ys') = last ys'\n  walk (rev ys')\n\ngoal (1 subgoal):\n 1. walk (x # rev ys')", "using path_cons undirected ys'(1) ys(1)"], ["proof (prove)\nusing this:\n  ys' \\<noteq> []\n  last ys' \\<rightarrow> x\n  hd (rev ys') = last ys'\n  walk (rev ys')\n  \\<lbrakk>path ?xs; ?xs \\<noteq> []; ?v \\<rightarrow> hd ?xs;\n   ?v \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> path (?v # ?xs)\n  ?v \\<rightarrow> ?w = ?w \\<rightarrow> ?v\n  ys = ys' @ x # ys''\n  path (v # ys)\n\ngoal (1 subgoal):\n 1. walk (x # rev ys')", "by auto"], ["proof (state)\nthis:\n  walk (x # rev ys')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  walk (x # rev ys')\n\ngoal (2 subgoals):\n 1. walk (v # xs' @ x # rev ys')\n 2. distinct (v # xs' @ x # rev ys')", "thus \"walk (v # xs' @ x # rev ys')\""], ["proof (prove)\nusing this:\n  walk (x # rev ys')\n\ngoal (1 subgoal):\n 1. walk (v # xs' @ x # rev ys')", "using xs'(1) xs(1)"], ["proof (prove)\nusing this:\n  walk (x # rev ys')\n  xs = xs' @ x # xs''\n  path (v # xs)\n\ngoal (1 subgoal):\n 1. walk (v # xs' @ x # rev ys')", "by (metis append_Cons list.sel(1) list.simps(3) walk_comp walk_decomp(1) walk_last_edge)"], ["proof (state)\nthis:\n  walk (v # xs' @ x # rev ys')\n\ngoal (1 subgoal):\n 1. distinct (v # xs' @ x # rev ys')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (v # xs' @ x # rev ys')", "show \"distinct (v # xs' @ x # rev ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (v # xs' @ x # rev ys')", "unfolding distinct_append distinct.simps(2) set_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set xs' \\<union> set (x # rev ys') \\<and>\n    distinct xs' \\<and>\n    (x \\<notin> set (rev ys') \\<and> distinct (rev ys')) \\<and>\n    set xs' \\<inter> set (x # rev ys') = {}", "using xs'(1,2) xs(1) ys'(1) ys(1)"], ["proof (prove)\nusing this:\n  xs = xs' @ x # xs''\n  set xs' \\<inter> set ys = {}\n  path (v # xs)\n  ys = ys' @ x # ys''\n  path (v # ys)\n\ngoal (1 subgoal):\n 1. v \\<notin> set xs' \\<union> set (x # rev ys') \\<and>\n    distinct xs' \\<and>\n    (x \\<notin> set (rev ys') \\<and> distinct (rev ys')) \\<and>\n    set xs' \\<inter> set (x # rev ys') = {}", "by auto"], ["proof (state)\nthis:\n  distinct (v # xs' @ x # rev ys')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path (v # xs' @ x # rev ys')\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "moreover"], ["proof (state)\nthis:\n  path (v # xs' @ x # rev ys')\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "have \"length ?zs \\<noteq> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (v # xs' @ x # rev ys') \\<noteq> 2", "using diverge xs'(1) ys'(1)"], ["proof (prove)\nusing this:\n  hd xs \\<noteq> hd ys\n  xs = xs' @ x # xs''\n  ys = ys' @ x # ys''\n\ngoal (1 subgoal):\n 1. length (v # xs' @ x # rev ys') \\<noteq> 2", "by auto"], ["proof (state)\nthis:\n  length (v # xs' @ x # rev ys') \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "ultimately"], ["proof (chain)\npicking this:\n  last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')\n  path (v # xs' @ x # rev ys')\n  length (v # xs' @ x # rev ys') \\<noteq> 2", "show ?thesis"], ["proof (prove)\nusing this:\n  last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')\n  path (v # xs' @ x # rev ys')\n  length (v # xs' @ x # rev ys') \\<noteq> 2\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "using cycleI[of ?zs]"], ["proof (prove)\nusing this:\n  last (v # xs' @ x # rev ys') \\<rightarrow> hd (v # xs' @ x # rev ys')\n  path (v # xs' @ x # rev ys')\n  length (v # xs' @ x # rev ys') \\<noteq> 2\n  \\<lbrakk>path (v # xs' @ x # rev ys'); 2 < length (v # xs' @ x # rev ys');\n   last (v # xs' @ x # rev ys') \\<rightarrow>\n   hd (v # xs' @ x # rev ys')\\<rbrakk>\n  \\<Longrightarrow> cycle (v # xs' @ x # rev ys')\n\ngoal (1 subgoal):\n 1. \\<exists>zs. cycle zs \\<and> hd zs = v", "by auto"], ["proof (state)\nthis:\n  \\<exists>zs. cycle zs \\<and> hd zs = v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A graph with unique paths between every pair of connected vertices has no cycles.\\<close>"], ["", "lemma unique_paths_implies_no_cycles:\n  assumes unique_paths: \"\\<And>v w. v \\<rightarrow>\\<^sup>* w \\<Longrightarrow> \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w\"\n  shows \"\\<And>xs. \\<not>cycle xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. \\<not> cycle xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "assume \"cycle xs\""], ["proof (state)\nthis:\n  cycle xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "let ?v = \"hd xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "let ?w = \"last xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "let ?ys = \"[?v,?w]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "define good where \"good xs \\<longleftrightarrow> ?v \\<leadsto>xs\\<leadsto> ?w\" for xs"], ["proof (state)\nthis:\n  good ?xs = hd xs \\<leadsto>?xs\\<leadsto> last xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "have \"path ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path [hd xs, last xs]", "using \\<open>cycle xs\\<close> cycle_def no_loops undirected"], ["proof (prove)\nusing this:\n  cycle xs\n  cycle ?xs \\<equiv>\n  path ?xs \\<and> 2 < length ?xs \\<and> last ?xs \\<rightarrow> hd ?xs\n  (?v, ?v) \\<notin> E\n  ?v \\<rightarrow> ?w = ?w \\<rightarrow> ?v\n\ngoal (1 subgoal):\n 1. path [hd xs, last xs]", "by auto"], ["proof (state)\nthis:\n  path [hd xs, last xs]\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "hence \"good ?ys\""], ["proof (prove)\nusing this:\n  path [hd xs, last xs]\n\ngoal (1 subgoal):\n 1. good [hd xs, last xs]", "unfolding good_def"], ["proof (prove)\nusing this:\n  path [hd xs, last xs]\n\ngoal (1 subgoal):\n 1. hd xs \\<leadsto>[hd xs, last xs]\\<leadsto> last xs", "by (simp add: path_from_toI)"], ["proof (state)\nthis:\n  good [hd xs, last xs]\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  good [hd xs, last xs]\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "have \"good xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. good xs", "unfolding good_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<leadsto>xs\\<leadsto> last xs", "by (simp add: path_from_toI \\<open>cycle xs\\<close> cycleE)"], ["proof (state)\nthis:\n  good xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  good xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "have \"?ys \\<noteq> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [hd xs, last xs] \\<noteq> xs", "using \\<open>cycle xs\\<close>"], ["proof (prove)\nusing this:\n  cycle xs\n\ngoal (1 subgoal):\n 1. [hd xs, last xs] \\<noteq> xs", "by (metis One_nat_def Suc_1 cycleE length_Cons less_not_refl list.size(3))"], ["proof (state)\nthis:\n  [hd xs, last xs] \\<noteq> xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  good [hd xs, last xs]\n  good xs\n  [hd xs, last xs] \\<noteq> xs", "have \"\\<not>(\\<exists>!xs. good xs)\""], ["proof (prove)\nusing this:\n  good [hd xs, last xs]\n  good xs\n  [hd xs, last xs] \\<noteq> xs\n\ngoal (1 subgoal):\n 1. \\<nexists>!xs. good xs", "by blast"], ["proof (state)\nthis:\n  \\<nexists>!xs. good xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<nexists>!xs. good xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "have \"connected ?v ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<rightarrow>\\<^sup>* last xs", "using \\<open>cycle xs\\<close> cycleE"], ["proof (prove)\nusing this:\n  cycle xs\n  cycle ?xs \\<Longrightarrow>\n  path ?xs \\<and>\n  ?xs \\<noteq> [] \\<and> 2 < length ?xs \\<and> last ?xs \\<rightarrow> hd ?xs\n\ngoal (1 subgoal):\n 1. hd xs \\<rightarrow>\\<^sup>* last xs", "by blast"], ["proof (state)\nthis:\n  hd xs \\<rightarrow>\\<^sup>* last xs\n\ngoal (1 subgoal):\n 1. \\<And>xs. cycle xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<nexists>!xs. good xs\n  hd xs \\<rightarrow>\\<^sup>* last xs", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>!xs. good xs\n  hd xs \\<rightarrow>\\<^sup>* last xs\n\ngoal (1 subgoal):\n 1. False", "unfolding good_def"], ["proof (prove)\nusing this:\n  \\<nexists>!xsa. hd xs \\<leadsto>xsa\\<leadsto> last xs\n  hd xs \\<rightarrow>\\<^sup>* last xs\n\ngoal (1 subgoal):\n 1. False", "using unique_paths"], ["proof (prove)\nusing this:\n  \\<nexists>!xsa. hd xs \\<leadsto>xsa\\<leadsto> last xs\n  hd xs \\<rightarrow>\\<^sup>* last xs\n  ?v \\<rightarrow>\\<^sup>* ?w \\<Longrightarrow>\n  \\<exists>!xs. ?v \\<leadsto>xs\\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A graph without cycles (also called a forest) has a unique path between every pair of connected\n  vertices.\n\\<close>"], ["", "lemma no_cycles_implies_unique_paths:\n  assumes no_cycles: \"\\<And>xs. \\<not>cycle xs\" and connected: \"v \\<rightarrow>\\<^sup>* w\"\n  shows \"\\<exists>!xs. v \\<leadsto>xs\\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>xs. v \\<leadsto>xs\\<leadsto> w\n 2. \\<And>xs y.\n       \\<lbrakk>v \\<leadsto>xs\\<leadsto> w;\n        v \\<leadsto>y\\<leadsto> w\\<rbrakk>\n       \\<Longrightarrow> xs = y", "show \"\\<exists>xs. v \\<leadsto>xs\\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs. v \\<leadsto>xs\\<leadsto> w", "using connected connected_by_path"], ["proof (prove)\nusing this:\n  v \\<rightarrow>\\<^sup>* w\n  \\<lbrakk>?v \\<rightarrow>\\<^sup>* ?w;\n   \\<And>xs. ?v \\<leadsto>xs\\<leadsto> ?w \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>xs. v \\<leadsto>xs\\<leadsto> w", "by blast"], ["proof (state)\nthis:\n  \\<exists>xs. v \\<leadsto>xs\\<leadsto> w\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>v \\<leadsto>xs\\<leadsto> w;\n        v \\<leadsto>y\\<leadsto> w\\<rbrakk>\n       \\<Longrightarrow> xs = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>v \\<leadsto>xs\\<leadsto> w;\n        v \\<leadsto>y\\<leadsto> w\\<rbrakk>\n       \\<Longrightarrow> xs = y", "fix xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>v \\<leadsto>xs\\<leadsto> w;\n        v \\<leadsto>y\\<leadsto> w\\<rbrakk>\n       \\<Longrightarrow> xs = y", "assume \"v \\<leadsto>xs\\<leadsto> w\" \"v \\<leadsto>ys\\<leadsto> w\""], ["proof (state)\nthis:\n  v \\<leadsto>xs\\<leadsto> w\n  v \\<leadsto>ys\\<leadsto> w\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>v \\<leadsto>xs\\<leadsto> w;\n        v \\<leadsto>y\\<leadsto> w\\<rbrakk>\n       \\<Longrightarrow> xs = y", "hence xs_valid: \"path xs\" \"xs \\<noteq> Nil\" \"hd xs = v\" \"last xs = w\"\n    and ys_valid: \"path ys\" \"ys \\<noteq> Nil\" \"hd ys = v\" \"last ys = w\""], ["proof (prove)\nusing this:\n  v \\<leadsto>xs\\<leadsto> w\n  v \\<leadsto>ys\\<leadsto> w\n\ngoal (1 subgoal):\n 1. ((path xs &&& xs \\<noteq> []) &&& hd xs = v &&& last xs = w) &&&\n    (path ys &&& ys \\<noteq> []) &&& hd ys = v &&& last ys = w", "by blast+"], ["proof (state)\nthis:\n  path xs\n  xs \\<noteq> []\n  hd xs = v\n  last xs = w\n  path ys\n  ys \\<noteq> []\n  hd ys = v\n  last ys = w\n\ngoal (1 subgoal):\n 1. \\<And>xs y.\n       \\<lbrakk>v \\<leadsto>xs\\<leadsto> w;\n        v \\<leadsto>y\\<leadsto> w\\<rbrakk>\n       \\<Longrightarrow> xs = y", "show \"xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "assume \"xs \\<noteq> ys\""], ["proof (state)\nthis:\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "hence \"\\<exists>ps xs' ys'. xs = ps @ xs' \\<and> ys = ps @ ys' \\<and> (xs' = Nil \\<or> ys' = Nil \\<or> hd xs' \\<noteq> hd ys')\""], ["proof (prove)\nusing this:\n  xs \\<noteq> ys\n\ngoal (1 subgoal):\n 1. \\<exists>ps xs' ys'.\n       xs = ps @ xs' \\<and>\n       ys = ps @ ys' \\<and>\n       (xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys')", "by (induct xs ys rule: list_induct2', blast, blast, blast)\n         (metis (no_types, hide_lams) append_Cons append_Nil list.sel(1))"], ["proof (state)\nthis:\n  \\<exists>ps xs' ys'.\n     xs = ps @ xs' \\<and>\n     ys = ps @ ys' \\<and>\n     (xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys')\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>ps xs' ys'.\n     xs = ps @ xs' \\<and>\n     ys = ps @ ys' \\<and>\n     (xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys')", "obtain ps xs' ys' where\n      ps: \"xs = ps @ xs'\" \"ys = ps @ ys'\" \"xs' = Nil \\<or> ys' = Nil \\<or> hd xs' \\<noteq> hd ys'\""], ["proof (prove)\nusing this:\n  \\<exists>ps xs' ys'.\n     xs = ps @ xs' \\<and>\n     ys = ps @ ys' \\<and>\n     (xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys')\n\ngoal (1 subgoal):\n 1. (\\<And>ps xs' ys'.\n        \\<lbrakk>xs = ps @ xs'; ys = ps @ ys';\n         xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = ps @ xs'\n  ys = ps @ ys'\n  xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys'\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "have \"last xs \\<in> set ps\" if \"xs' = Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs \\<in> set ps", "using xs_valid(2) ps(1)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  xs = ps @ xs'\n\ngoal (1 subgoal):\n 1. last xs \\<in> set ps", "by (simp add: that)"], ["proof (state)\nthis:\n  xs' = [] \\<Longrightarrow> last xs \\<in> set ps\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "hence xs_not_nil: \"xs' \\<noteq> Nil\""], ["proof (prove)\nusing this:\n  xs' = [] \\<Longrightarrow> last xs \\<in> set ps\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "using \\<open>xs \\<noteq> ys\\<close> ys_valid(1,4) ps(1,2) xs_valid(4)"], ["proof (prove)\nusing this:\n  xs' = [] \\<Longrightarrow> last xs \\<in> set ps\n  xs \\<noteq> ys\n  path ys\n  last ys = w\n  xs = ps @ xs'\n  ys = ps @ ys'\n  last xs = w\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "have \"last ys \\<in> set ps\" if \"ys' = Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last ys \\<in> set ps", "using ys_valid(2) ps(2)"], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  ys = ps @ ys'\n\ngoal (1 subgoal):\n 1. last ys \\<in> set ps", "by (simp add: that)"], ["proof (state)\nthis:\n  ys' = [] \\<Longrightarrow> last ys \\<in> set ps\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "hence ys_not_nil: \"ys' \\<noteq> Nil\""], ["proof (prove)\nusing this:\n  ys' = [] \\<Longrightarrow> last ys \\<in> set ps\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> []", "using \\<open>xs \\<noteq> ys\\<close> xs_valid(1,4) ps(1,2) ys_valid(4)"], ["proof (prove)\nusing this:\n  ys' = [] \\<Longrightarrow> last ys \\<in> set ps\n  xs \\<noteq> ys\n  path xs\n  last xs = w\n  xs = ps @ xs'\n  ys = ps @ ys'\n  last ys = w\n\ngoal (1 subgoal):\n 1. ys' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "have \"\\<exists>zs. cycle zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex cycle", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex cycle", "let ?v = \"last ps\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex cycle", "have *: \"ps \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<noteq> []", "using xs_valid(2,3) ys_valid(2,3) ps(1,2,3)"], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n  hd xs = v\n  ys \\<noteq> []\n  hd ys = v\n  xs = ps @ xs'\n  ys = ps @ ys'\n  xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys'\n\ngoal (1 subgoal):\n 1. ps \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ex cycle", "have \"path (?v # xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (last ps # xs')", "using xs_valid(1) ps(1) * walk_decomp(2)"], ["proof (prove)\nusing this:\n  path xs\n  xs = ps @ xs'\n  ps \\<noteq> []\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?ys\n\ngoal (1 subgoal):\n 1. path (last ps # xs')", "by (metis append_Cons append_assoc append_butlast_last_id distinct_append self_append_conv2)"], ["proof (state)\nthis:\n  path (last ps # xs')\n\ngoal (1 subgoal):\n 1. Ex cycle", "moreover"], ["proof (state)\nthis:\n  path (last ps # xs')\n\ngoal (1 subgoal):\n 1. Ex cycle", "have \"path (?v # ys')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (last ps # ys')", "using ys_valid(1) ps(2) * walk_decomp(2)"], ["proof (prove)\nusing this:\n  path ys\n  ys = ps @ ys'\n  ps \\<noteq> []\n  walk (?xs @ ?ys) \\<Longrightarrow> walk ?ys\n\ngoal (1 subgoal):\n 1. path (last ps # ys')", "by (metis append_Cons append_assoc append_butlast_last_id distinct_append self_append_conv2)"], ["proof (state)\nthis:\n  path (last ps # ys')\n\ngoal (1 subgoal):\n 1. Ex cycle", "moreover"], ["proof (state)\nthis:\n  path (last ps # ys')\n\ngoal (1 subgoal):\n 1. Ex cycle", "have \"last xs' = last ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs' = last ys'", "using xs_valid(4) ys_valid(4) xs_not_nil ys_not_nil ps(1,2)"], ["proof (prove)\nusing this:\n  last xs = w\n  last ys = w\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n  xs = ps @ xs'\n  ys = ps @ ys'\n\ngoal (1 subgoal):\n 1. last xs' = last ys'", "by auto"], ["proof (state)\nthis:\n  last xs' = last ys'\n\ngoal (1 subgoal):\n 1. Ex cycle", "ultimately"], ["proof (chain)\npicking this:\n  path (last ps # xs')\n  path (last ps # ys')\n  last xs' = last ys'", "show ?thesis"], ["proof (prove)\nusing this:\n  path (last ps # xs')\n  path (last ps # ys')\n  last xs' = last ys'\n\ngoal (1 subgoal):\n 1. Ex cycle", "using ps(3) meeting_paths_produce_cycle xs_not_nil ys_not_nil"], ["proof (prove)\nusing this:\n  path (last ps # xs')\n  path (last ps # ys')\n  last xs' = last ys'\n  xs' = [] \\<or> ys' = [] \\<or> hd xs' \\<noteq> hd ys'\n  \\<lbrakk>path (?v # ?xs); ?xs \\<noteq> []; path (?v # ?ys);\n   ?ys \\<noteq> []; last ?xs = last ?ys; hd ?xs \\<noteq> hd ?ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>zs. cycle zs \\<and> hd zs = ?v\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ex cycle", "by blast"], ["proof (state)\nthis:\n  Ex cycle\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ex cycle\n\ngoal (1 subgoal):\n 1. xs \\<noteq> ys \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Ex cycle\n\ngoal (1 subgoal):\n 1. False", "using no_cycles"], ["proof (prove)\nusing this:\n  Ex cycle\n  \\<not> cycle ?xs\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>locale Graph\\<close>"], ["", "end"]]}