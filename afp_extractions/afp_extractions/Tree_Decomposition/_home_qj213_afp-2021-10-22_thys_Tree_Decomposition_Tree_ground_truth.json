{"file_name": "/home/qj213/afp-2021-10-22/thys/Tree_Decomposition/Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tree_Decomposition", "problem_names": ["lemma unique_connecting_path: \"\\<lbrakk> v \\<in> V; w \\<in> V \\<rbrakk> \\<Longrightarrow> \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w\"", "lemma unique_connecting_path_set:\n  assumes \"v \\<in> V\" \"w \\<in> V\"\n  shows \"v \\<in> set (v \\<leadsto> w)\" \"w \\<in> set (v \\<leadsto> w)\"", "lemma unique_connecting_path_properties:\n  assumes \"v \\<in> V\" \"w \\<in> V\"\n  shows \"path (v \\<leadsto> w)\" \"v \\<leadsto> w \\<noteq> Nil\" \"hd (v \\<leadsto> w) = v\" \"last (v \\<leadsto> w) = w\"", "lemma unique_connecting_path_unique:\n  assumes \"v \\<leadsto>xs\\<leadsto> w\"\n  shows \"xs = v \\<leadsto> w\"", "lemma unique_connecting_path_rev:\n  assumes \"v \\<in> V\" \"w \\<in> V\"\n  shows \"v \\<leadsto> w = rev (w \\<leadsto> v)\"", "lemma unique_connecting_path_decomp:\n  assumes \"v \\<in> V\" \"w \\<in> V\" \"v \\<leadsto> w = ps @ u # ps'\"\n  shows \"ps @ [u] = v \\<leadsto> u\" \"u # ps' = u \\<leadsto> w\"", "lemma unique_connecting_path_tl:\n  assumes \"v \\<in> V\" \"u \\<in> set (w \\<leadsto> v)\" \"u\\<rightarrow>w\"\n  shows \"tl (w \\<leadsto> v) = u \\<leadsto> v\"", "lemma tree_has_edge:\n  assumes \"card V > 1\"\n  shows \"\\<exists>v w. v\\<rightarrow>w\"", "lemma left_treeI [intro]: \"\\<lbrakk> u \\<in> V; s \\<in> set (u \\<leadsto> t) \\<rbrakk> \\<Longrightarrow> u \\<in> left_tree s t\"", "lemma left_treeE: \"u \\<in> left_tree s t \\<Longrightarrow> u \\<in> V \\<and> s \\<in> set (u \\<leadsto> t)\"", "lemma left_tree_in_V: \"left_tree s t \\<subseteq> V\"", "lemma left_tree_initial: \"\\<lbrakk> s \\<in> V; t \\<in> V \\<rbrakk> \\<Longrightarrow> s \\<in> left_tree s t\"", "lemma left_tree_initial': \"\\<lbrakk> s \\<in> V; t \\<in> V; s \\<noteq> t \\<rbrakk> \\<Longrightarrow> t \\<notin> left_tree s t\"", "lemma left_tree_initial_edge: \"s\\<rightarrow>t \\<Longrightarrow> t \\<notin> left_tree s t\"", "lemma left_tree_union_V:\n  assumes \"s\\<rightarrow>t\"\n  shows \"left_tree s t \\<union> left_tree t s = V\"", "lemma left_tree_disjoint:\n  assumes \"s\\<rightarrow>t\"\n  shows \"left_tree s t \\<inter> left_tree t s = {}\"", "theorem left_tree_separates:\n  assumes st: \"s\\<rightarrow>t\" and u: \"u \\<in> left_tree s t\" and u': \"u' \\<in> left_tree t s\"\n  shows \"s \\<in> set (u \\<leadsto> u')\"", "lemma parent_edge: \"\\<lbrakk> v \\<in> V; v \\<noteq> root \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>parent v\"", "lemma parent_edge_root: \"v\\<rightarrow>root \\<Longrightarrow> parent v = root\"", "lemma parent_in_V: \"\\<lbrakk> v \\<in> V; v \\<noteq> root \\<rbrakk> \\<Longrightarrow> parent v \\<in> V\"", "lemma parent_edge_cases: \"v\\<rightarrow>w \\<Longrightarrow> w = parent v \\<or> v = parent w\"", "lemma sibling_path:\n    assumes v: \"v \\<in> V\" \"v \\<noteq> root\" and w: \"w \\<in> V\" \"w \\<noteq> root\" and vw: \"v \\<noteq> w\" \"parent v = parent w\"\n    shows \"v\\<leadsto>w = [v,parent v,w]\" (is \"_ = ?xs\")"], "translations": [["", "lemma unique_connecting_path: \"\\<lbrakk> v \\<in> V; w \\<in> V \\<rbrakk> \\<Longrightarrow> \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; w \\<in> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w", "using connected no_cycles no_cycles_implies_unique_paths"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow>\\<^sup>* ?w\n  \\<not> cycle ?xs\n  \\<lbrakk>\\<And>xs. \\<not> cycle xs; ?v \\<rightarrow>\\<^sup>* ?w\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!xs. ?v \\<leadsto>xs\\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; w \\<in> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!xs. v \\<leadsto>xs\\<leadsto> w", "by blast"], ["", "text \\<open>Let us define a function mapping pair of vertices to their unique connecting path.\\<close>"], ["", "end \\<comment> \\<open>locale Tree\\<close>"], ["", "definition unique_connecting_path :: \"('a, 'b) Graph_scheme \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a Walk\"\n  (infix \"\\<leadsto>\\<index>\" 71) where \"unique_connecting_path G v w \\<equiv> THE xs. v \\<leadsto>xs\\<leadsto>\\<^bsub>G\\<^esub> w\""], ["", "text \\<open>We defined this outside the locale in order to be able to use the index in the shorthand\n  syntax @{term \"v \\<leadsto>\\<index> w\"}.\\<close>"], ["", "context Tree begin"], ["", "lemma unique_connecting_path_set:\n  assumes \"v \\<in> V\" \"w \\<in> V\"\n  shows \"v \\<in> set (v \\<leadsto> w)\" \"w \\<in> set (v \\<leadsto> w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (v \\<leadsto> w) &&& w \\<in> set (v \\<leadsto> w)", "using theI'[OF unique_connecting_path[OF assms], folded unique_connecting_path_def]\n    hd_in_set last_in_set"], ["proof (prove)\nusing this:\n  v \\<leadsto>v \\<leadsto> w\\<leadsto> w\n  ?xs \\<noteq> [] \\<Longrightarrow> hd ?xs \\<in> set ?xs\n  ?as \\<noteq> [] \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. v \\<in> set (v \\<leadsto> w) &&& w \\<in> set (v \\<leadsto> w)", "by fastforce+"], ["", "lemma unique_connecting_path_properties:\n  assumes \"v \\<in> V\" \"w \\<in> V\"\n  shows \"path (v \\<leadsto> w)\" \"v \\<leadsto> w \\<noteq> Nil\" \"hd (v \\<leadsto> w) = v\" \"last (v \\<leadsto> w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (path (v \\<leadsto> w) &&& v \\<leadsto> w \\<noteq> []) &&&\n    hd (v \\<leadsto> w) = v &&& last (v \\<leadsto> w) = w", "using theI'[OF unique_connecting_path[OF assms], folded unique_connecting_path_def]"], ["proof (prove)\nusing this:\n  v \\<leadsto>v \\<leadsto> w\\<leadsto> w\n\ngoal (1 subgoal):\n 1. (path (v \\<leadsto> w) &&& v \\<leadsto> w \\<noteq> []) &&&\n    hd (v \\<leadsto> w) = v &&& last (v \\<leadsto> w) = w", "by blast+"], ["", "lemma unique_connecting_path_unique:\n  assumes \"v \\<leadsto>xs\\<leadsto> w\"\n  shows \"xs = v \\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = v \\<leadsto> w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. xs = v \\<leadsto> w", "have \"v \\<in> V\" \"w \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "using assms connected_in_V"], ["proof (prove)\nusing this:\n  v \\<leadsto>xs\\<leadsto> w\n  ?v \\<rightarrow>\\<^sup>* ?w \\<Longrightarrow> ?v \\<in> V\n  ?v \\<rightarrow>\\<^sup>* ?w \\<Longrightarrow> ?w \\<in> V\n\ngoal (1 subgoal):\n 1. v \\<in> V &&& w \\<in> V", "by blast+"], ["proof (state)\nthis:\n  v \\<in> V\n  w \\<in> V\n\ngoal (1 subgoal):\n 1. xs = v \\<leadsto> w", "with unique_connecting_path_properties[OF this]"], ["proof (chain)\npicking this:\n  path (v \\<leadsto> w)\n  v \\<leadsto> w \\<noteq> []\n  hd (v \\<leadsto> w) = v\n  last (v \\<leadsto> w) = w\n  v \\<in> V\n  w \\<in> V", "show ?thesis"], ["proof (prove)\nusing this:\n  path (v \\<leadsto> w)\n  v \\<leadsto> w \\<noteq> []\n  hd (v \\<leadsto> w) = v\n  last (v \\<leadsto> w) = w\n  v \\<in> V\n  w \\<in> V\n\ngoal (1 subgoal):\n 1. xs = v \\<leadsto> w", "using assms unique_connecting_path"], ["proof (prove)\nusing this:\n  path (v \\<leadsto> w)\n  v \\<leadsto> w \\<noteq> []\n  hd (v \\<leadsto> w) = v\n  last (v \\<leadsto> w) = w\n  v \\<in> V\n  w \\<in> V\n  v \\<leadsto>xs\\<leadsto> w\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!xs. ?v \\<leadsto>xs\\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. xs = v \\<leadsto> w", "by blast"], ["proof (state)\nthis:\n  xs = v \\<leadsto> w\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary unique_connecting_path_connects: \"\\<lbrakk> v \\<in> V; w \\<in> V \\<rbrakk> \\<Longrightarrow> v \\<leadsto>(v\\<leadsto>w) \\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; w \\<in> V\\<rbrakk>\n    \\<Longrightarrow> v \\<leadsto>v \\<leadsto> w\\<leadsto> w", "using unique_connecting_path unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!xs. ?v \\<leadsto>xs\\<leadsto> ?w\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; w \\<in> V\\<rbrakk>\n    \\<Longrightarrow> v \\<leadsto>v \\<leadsto> w\\<leadsto> w", "by blast"], ["", "lemma unique_connecting_path_rev:\n  assumes \"v \\<in> V\" \"w \\<in> V\"\n  shows \"v \\<leadsto> w = rev (w \\<leadsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto> w = rev (w \\<leadsto> v)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<leadsto> w = rev (w \\<leadsto> v)", "have \"v \\<leadsto>(rev (w \\<leadsto> v))\\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto>rev (w \\<leadsto> v)\\<leadsto> w", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> V\n  w \\<in> V\n\ngoal (1 subgoal):\n 1. v \\<leadsto>rev (w \\<leadsto> v)\\<leadsto> w", "by (simp add: unique_connecting_path_properties walk_rev hd_rev last_rev path_from_toI)"], ["proof (state)\nthis:\n  v \\<leadsto>rev (w \\<leadsto> v)\\<leadsto> w\n\ngoal (1 subgoal):\n 1. v \\<leadsto> w = rev (w \\<leadsto> v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<leadsto>rev (w \\<leadsto> v)\\<leadsto> w\n\ngoal (1 subgoal):\n 1. v \\<leadsto> w = rev (w \\<leadsto> v)", "using unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  v \\<leadsto>rev (w \\<leadsto> v)\\<leadsto> w\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. v \\<leadsto> w = rev (w \\<leadsto> v)", "by simp"], ["proof (state)\nthis:\n  v \\<leadsto> w = rev (w \\<leadsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_connecting_path_decomp:\n  assumes \"v \\<in> V\" \"w \\<in> V\" \"v \\<leadsto> w = ps @ u # ps'\"\n  shows \"ps @ [u] = v \\<leadsto> u\" \"u # ps' = u \\<leadsto> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps @ [u] = v \\<leadsto> u &&& u # ps' = u \\<leadsto> w", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. ps @ [u] = v \\<leadsto> u\n 2. u # ps' = u \\<leadsto> w", "have \"hd (ps @ [u]) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (ps @ [u]) = v", "by (metis append_Nil assms hd_append2 list.sel(1) unique_connecting_path_properties(3))"], ["proof (state)\nthis:\n  hd (ps @ [u]) = v\n\ngoal (2 subgoals):\n 1. ps @ [u] = v \\<leadsto> u\n 2. u # ps' = u \\<leadsto> w", "moreover"], ["proof (state)\nthis:\n  hd (ps @ [u]) = v\n\ngoal (2 subgoals):\n 1. ps @ [u] = v \\<leadsto> u\n 2. u # ps' = u \\<leadsto> w", "have \"path (ps @ [u])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (ps @ [u])", "using unique_connecting_path_properties(1)[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  path (v \\<leadsto> w)\n\ngoal (1 subgoal):\n 1. path (ps @ [u])", "unfolding assms(3)"], ["proof (prove)\nusing this:\n  path (ps @ u # ps')\n\ngoal (1 subgoal):\n 1. path (ps @ [u])", "by (metis distinct.simps(2) distinct1_rotate list.sel(1) list.simps(3) not_distinct_conv_prefix\n        path_decomp(1) rev.simps(2) rotate1.simps(2) walk_comp walk_decomp(2) walk_last_edge walk_rev)"], ["proof (state)\nthis:\n  path (ps @ [u])\n\ngoal (2 subgoals):\n 1. ps @ [u] = v \\<leadsto> u\n 2. u # ps' = u \\<leadsto> w", "moreover"], ["proof (state)\nthis:\n  path (ps @ [u])\n\ngoal (2 subgoals):\n 1. ps @ [u] = v \\<leadsto> u\n 2. u # ps' = u \\<leadsto> w", "have \"last (ps @ [u]) = u\" \"ps @ [u] \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (ps @ [u]) = u &&& ps @ [u] \\<noteq> []", "by simp_all"], ["proof (state)\nthis:\n  last (ps @ [u]) = u\n  ps @ [u] \\<noteq> []\n\ngoal (2 subgoals):\n 1. ps @ [u] = v \\<leadsto> u\n 2. u # ps' = u \\<leadsto> w", "ultimately"], ["proof (chain)\npicking this:\n  hd (ps @ [u]) = v\n  path (ps @ [u])\n  last (ps @ [u]) = u\n  ps @ [u] \\<noteq> []", "show \"ps @ [u] = v \\<leadsto> u\""], ["proof (prove)\nusing this:\n  hd (ps @ [u]) = v\n  path (ps @ [u])\n  last (ps @ [u]) = u\n  ps @ [u] \\<noteq> []\n\ngoal (1 subgoal):\n 1. ps @ [u] = v \\<leadsto> u", "using unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  hd (ps @ [u]) = v\n  path (ps @ [u])\n  last (ps @ [u]) = u\n  ps @ [u] \\<noteq> []\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. ps @ [u] = v \\<leadsto> u", "by blast"], ["proof (state)\nthis:\n  ps @ [u] = v \\<leadsto> u\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "have \"last (u # ps') = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (u # ps') = w", "using assms unique_connecting_path_properties(4)"], ["proof (prove)\nusing this:\n  v \\<in> V\n  w \\<in> V\n  v \\<leadsto> w = ps @ u # ps'\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> last (?v \\<leadsto> ?w) = ?w\n\ngoal (1 subgoal):\n 1. last (u # ps') = w", "by fastforce"], ["proof (state)\nthis:\n  last (u # ps') = w\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "moreover"], ["proof (state)\nthis:\n  last (u # ps') = w\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "have \"path (u # ps')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (u # ps')", "using unique_connecting_path_properties(1)[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  path (v \\<leadsto> w)\n\ngoal (1 subgoal):\n 1. path (u # ps')", "unfolding assms(3)"], ["proof (prove)\nusing this:\n  path (ps @ u # ps')\n\ngoal (1 subgoal):\n 1. path (u # ps')", "using path_decomp(2)"], ["proof (prove)\nusing this:\n  path (ps @ u # ps')\n  path (?xs @ ?ys) \\<Longrightarrow> path ?ys\n\ngoal (1 subgoal):\n 1. path (u # ps')", "by blast"], ["proof (state)\nthis:\n  path (u # ps')\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "moreover"], ["proof (state)\nthis:\n  path (u # ps')\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "have \"hd (u # ps') = u\" \"u # ps' \\<noteq> Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (u # ps') = u &&& u # ps' \\<noteq> []", "by simp_all"], ["proof (state)\nthis:\n  hd (u # ps') = u\n  u # ps' \\<noteq> []\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "ultimately"], ["proof (chain)\npicking this:\n  last (u # ps') = w\n  path (u # ps')\n  hd (u # ps') = u\n  u # ps' \\<noteq> []", "show \"u # ps' = u \\<leadsto> w\""], ["proof (prove)\nusing this:\n  last (u # ps') = w\n  path (u # ps')\n  hd (u # ps') = u\n  u # ps' \\<noteq> []\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "using unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  last (u # ps') = w\n  path (u # ps')\n  hd (u # ps') = u\n  u # ps' \\<noteq> []\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> w", "by blast"], ["proof (state)\nthis:\n  u # ps' = u \\<leadsto> w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unique_connecting_path_tl:\n  assumes \"v \\<in> V\" \"u \\<in> set (w \\<leadsto> v)\" \"u\\<rightarrow>w\"\n  shows \"tl (w \\<leadsto> v) = u \\<leadsto> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (w \\<leadsto> v) = u \\<leadsto> v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. tl (w \\<leadsto> v) \\<noteq> u \\<leadsto> v \\<Longrightarrow> False", "assume contra: \"\\<not>?thesis\""], ["proof (state)\nthis:\n  tl (w \\<leadsto> v) \\<noteq> u \\<leadsto> v\n\ngoal (1 subgoal):\n 1. tl (w \\<leadsto> v) \\<noteq> u \\<leadsto> v \\<Longrightarrow> False", "from assms(2)"], ["proof (chain)\npicking this:\n  u \\<in> set (w \\<leadsto> v)", "obtain ps ps' where\n    ps: \"w \\<leadsto> v = ps @ u # ps'\""], ["proof (prove)\nusing this:\n  u \\<in> set (w \\<leadsto> v)\n\ngoal (1 subgoal):\n 1. (\\<And>ps ps'.\n        w \\<leadsto> v = ps @ u # ps' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  w \\<leadsto> v = ps @ u # ps'\n\ngoal (1 subgoal):\n 1. tl (w \\<leadsto> v) \\<noteq> u \\<leadsto> v \\<Longrightarrow> False", "have \"cycle (ps @ [u])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle (ps @ [u])", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. path (ps @ [u])\n 2. 2 < length (ps @ [u])\n 3. last (ps @ [u]) \\<rightarrow> hd (ps @ [u])", "show \"path (ps @ [u])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (ps @ [u])", "using unique_connecting_path_decomp assms(1,3) ps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?ps @ [?u] = ?v \\<leadsto> ?u\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?u # ?ps' = ?u \\<leadsto> ?w\n  v \\<in> V\n  u \\<rightarrow> w\n  w \\<leadsto> v = ps @ u # ps'\n\ngoal (1 subgoal):\n 1. path (ps @ [u])", "by (metis edges_are_in_V unique_connecting_path_properties(1))"], ["proof (state)\nthis:\n  path (ps @ [u])\n\ngoal (2 subgoals):\n 1. 2 < length (ps @ [u])\n 2. last (ps @ [u]) \\<rightarrow> hd (ps @ [u])", "show \"length (ps @ [u]) > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < length (ps @ [u])", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> 2 < length (ps @ [u])\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> 2 < length (ps @ [u])\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "have \"u \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<noteq> w", "using assms(3) no_loops"], ["proof (prove)\nusing this:\n  u \\<rightarrow> w\n  (?v, ?v) \\<notin> E\n\ngoal (1 subgoal):\n 1. u \\<noteq> w", "by blast"], ["proof (state)\nthis:\n  u \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> 2 < length (ps @ [u])\n  u \\<noteq> w", "have \"length (ps @ [u]) = 2\""], ["proof (prove)\nusing this:\n  \\<not> 2 < length (ps @ [u])\n  u \\<noteq> w\n\ngoal (1 subgoal):\n 1. length (ps @ [u]) = 2", "by (metis edges_are_in_V(2) assms(1,3) hd_append length_0_conv length_append_singleton\n            less_2_cases linorder_neqE_nat list.sel(1) nat.simps(1) ps snoc_eq_iff_butlast\n            unique_connecting_path_properties(3))"], ["proof (state)\nthis:\n  length (ps @ [u]) = 2\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "hence \"tl (w \\<leadsto> v) = u # ps'\""], ["proof (prove)\nusing this:\n  length (ps @ [u]) = 2\n\ngoal (1 subgoal):\n 1. tl (w \\<leadsto> v) = u # ps'", "by (metis One_nat_def Suc_1 append_Nil diff_Suc_1 length_0_conv length_Cons\n            length_append_singleton list.collapse nat.simps(3) ps tl_append2)"], ["proof (state)\nthis:\n  tl (w \\<leadsto> v) = u # ps'\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  tl (w \\<leadsto> v) = u # ps'\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "have \"u # ps' = u \\<leadsto> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> v", "using unique_connecting_path_decomp assms(1,3) edges_are_in_V(2) ps"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?ps @ [?u] = ?v \\<leadsto> ?u\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?u # ?ps' = ?u \\<leadsto> ?w\n  v \\<in> V\n  u \\<rightarrow> w\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?w \\<in> V\n  w \\<leadsto> v = ps @ u # ps'\n\ngoal (1 subgoal):\n 1. u # ps' = u \\<leadsto> v", "by blast"], ["proof (state)\nthis:\n  u # ps' = u \\<leadsto> v\n\ngoal (1 subgoal):\n 1. \\<not> 2 < length (ps @ [u]) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  tl (w \\<leadsto> v) = u # ps'\n  u # ps' = u \\<leadsto> v", "show False"], ["proof (prove)\nusing this:\n  tl (w \\<leadsto> v) = u # ps'\n  u # ps' = u \\<leadsto> v\n\ngoal (1 subgoal):\n 1. False", "using contra"], ["proof (prove)\nusing this:\n  tl (w \\<leadsto> v) = u # ps'\n  u # ps' = u \\<leadsto> v\n  tl (w \\<leadsto> v) \\<noteq> u \\<leadsto> v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 < length (ps @ [u])\n\ngoal (1 subgoal):\n 1. last (ps @ [u]) \\<rightarrow> hd (ps @ [u])", "show \"last (ps @ [u]) \\<rightarrow> hd (ps @ [u])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (ps @ [u]) \\<rightarrow> hd (ps @ [u])", "using assms(3)"], ["proof (prove)\nusing this:\n  u \\<rightarrow> w\n\ngoal (1 subgoal):\n 1. last (ps @ [u]) \\<rightarrow> hd (ps @ [u])", "by (metis edges_are_in_V(2) unique_connecting_path_properties(3)\n          assms(1) hd_append list.sel(1) ps snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  last (ps @ [u]) \\<rightarrow> hd (ps @ [u])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cycle (ps @ [u])\n\ngoal (1 subgoal):\n 1. tl (w \\<leadsto> v) \\<noteq> u \\<leadsto> v \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  cycle (ps @ [u])\n\ngoal (1 subgoal):\n 1. False", "using no_cycles"], ["proof (prove)\nusing this:\n  cycle (ps @ [u])\n  \\<not> cycle ?xs\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Every tree with at least two vertices contains an edge.\\<close>"], ["", "lemma tree_has_edge:\n  assumes \"card V > 1\"\n  shows \"\\<exists>v w. v\\<rightarrow>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v w. v \\<rightarrow> w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v w. v \\<rightarrow> w", "obtain v where v: \"v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> V \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  1 < card V\n\ngoal (1 subgoal):\n 1. (\\<And>v. v \\<in> V \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis List.finite_set One_nat_def card.empty card_mono empty_set less_le_trans linear\n        not_less subsetI zero_less_Suc)"], ["proof (state)\nthis:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. \\<exists>v w. v \\<rightarrow> w", "then"], ["proof (chain)\npicking this:\n  v \\<in> V", "obtain w where \"w \\<in> V\" \"v \\<noteq> w\""], ["proof (prove)\nusing this:\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> V; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> V\n  1 < card V\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>w \\<in> V; v \\<noteq> w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, lifting) One_nat_def card.empty card.insert distinct.simps(2) empty_set\n      finite.intros(1) finite_distinct_list finite_vertex_set hd_in_set last.simps last_in_set\n      less_or_eq_imp_le list.exhaust_sel list.simps(15) not_less path_singleton)"], ["proof (state)\nthis:\n  w \\<in> V\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<exists>v w. v \\<rightarrow> w", "hence \"v \\<rightarrow> hd (tl (v\\<leadsto>w))\""], ["proof (prove)\nusing this:\n  w \\<in> V\n  v \\<noteq> w\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> hd (tl (v \\<leadsto> w))", "using v"], ["proof (prove)\nusing this:\n  w \\<in> V\n  v \\<noteq> w\n  v \\<in> V\n\ngoal (1 subgoal):\n 1. v \\<rightarrow> hd (tl (v \\<leadsto> w))", "by (metis unique_connecting_path_properties last.simps list.exhaust_sel walk_first_edge')"], ["proof (state)\nthis:\n  v \\<rightarrow> hd (tl (v \\<leadsto> w))\n\ngoal (1 subgoal):\n 1. \\<exists>v w. v \\<rightarrow> w", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<rightarrow> hd (tl (v \\<leadsto> w))\n\ngoal (1 subgoal):\n 1. \\<exists>v w. v \\<rightarrow> w", "by blast"], ["proof (state)\nthis:\n  \\<exists>v w. v \\<rightarrow> w\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Separations\\<close>"], ["", "text \\<open>\n  Removing a single edge always splits a tree into two subtrees.  Here we define the set of vertices\n  of the left subtree.  The definition may not be obvious at first glance, but we will soon prove\n  that it behaves as expected.  We say that a vertex @{term u} is in the left subtree if and only\n  if the unique path from @{term u} to @{term t} visits @{term s}.\n\\<close>"], ["", "definition left_tree :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a set\" where\n  \"left_tree s t \\<equiv> { u \\<in> V. s \\<in> set (u \\<leadsto> t) }\""], ["", "lemma left_treeI [intro]: \"\\<lbrakk> u \\<in> V; s \\<in> set (u \\<leadsto> t) \\<rbrakk> \\<Longrightarrow> u \\<in> left_tree s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; s \\<in> set (u \\<leadsto> t)\\<rbrakk>\n    \\<Longrightarrow> u \\<in> left_tree s t", "unfolding left_tree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; s \\<in> set (u \\<leadsto> t)\\<rbrakk>\n    \\<Longrightarrow> u \\<in> {u \\<in> V. s \\<in> set (u \\<leadsto> t)}", "by blast"], ["", "lemma left_treeE: \"u \\<in> left_tree s t \\<Longrightarrow> u \\<in> V \\<and> s \\<in> set (u \\<leadsto> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> left_tree s t \\<Longrightarrow>\n    u \\<in> V \\<and> s \\<in> set (u \\<leadsto> t)", "unfolding left_tree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> {u \\<in> V. s \\<in> set (u \\<leadsto> t)} \\<Longrightarrow>\n    u \\<in> V \\<and> s \\<in> set (u \\<leadsto> t)", "by blast"], ["", "lemma left_tree_in_V: \"left_tree s t \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_tree s t \\<subseteq> V", "unfolding left_tree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u \\<in> V. s \\<in> set (u \\<leadsto> t)} \\<subseteq> V", "by blast"], ["", "lemma left_tree_initial: \"\\<lbrakk> s \\<in> V; t \\<in> V \\<rbrakk> \\<Longrightarrow> s \\<in> left_tree s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> V; t \\<in> V\\<rbrakk>\n    \\<Longrightarrow> s \\<in> left_tree s t", "unfolding left_tree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> V; t \\<in> V\\<rbrakk>\n    \\<Longrightarrow> s \\<in> {u \\<in> V. s \\<in> set (u \\<leadsto> t)}", "by (simp add: unique_connecting_path_set(1))"], ["", "lemma left_tree_initial': \"\\<lbrakk> s \\<in> V; t \\<in> V; s \\<noteq> t \\<rbrakk> \\<Longrightarrow> t \\<notin> left_tree s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<in> V; t \\<in> V; s \\<noteq> t\\<rbrakk>\n    \\<Longrightarrow> t \\<notin> left_tree s t", "by (metis distinct.simps(2) last.simps left_treeE list.discI list.sel(1) path_from_toI\n      path_singleton set_ConsD unique_connecting_path_unique)"], ["", "lemma left_tree_initial_edge: \"s\\<rightarrow>t \\<Longrightarrow> t \\<notin> left_tree s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<rightarrow> t \\<Longrightarrow> t \\<notin> left_tree s t", "using edges_are_in_V(1) left_tree_initial' no_loops undirected"], ["proof (prove)\nusing this:\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?v \\<in> V\n  \\<lbrakk>?s \\<in> V; ?t \\<in> V; ?s \\<noteq> ?t\\<rbrakk>\n  \\<Longrightarrow> ?t \\<notin> left_tree ?s ?t\n  (?v, ?v) \\<notin> E\n  ?v \\<rightarrow> ?w = ?w \\<rightarrow> ?v\n\ngoal (1 subgoal):\n 1. s \\<rightarrow> t \\<Longrightarrow> t \\<notin> left_tree s t", "by blast"], ["", "text \\<open>The union of the left and right subtree is @{term V}.\\<close>"], ["", "lemma left_tree_union_V:\n  assumes \"s\\<rightarrow>t\"\n  shows \"left_tree s t \\<union> left_tree t s = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_tree s t \\<union> left_tree t s = V", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. left_tree s t \\<union> left_tree t s \\<subseteq> V\n 2. V \\<subseteq> left_tree s t \\<union> left_tree t s", "show \"left_tree s t \\<union> left_tree t s \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_tree s t \\<union> left_tree t s \\<subseteq> V", "using left_tree_in_V"], ["proof (prove)\nusing this:\n  left_tree ?s ?t \\<subseteq> V\n\ngoal (1 subgoal):\n 1. left_tree s t \\<union> left_tree t s \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  left_tree s t \\<union> left_tree t s \\<subseteq> V\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "{"], ["proof (state)\nthis:\n  left_tree s t \\<union> left_tree t s \\<subseteq> V\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have s: \"s \\<in> V\" and t: \"t \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> V &&& t \\<in> V", "using assms"], ["proof (prove)\nusing this:\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. s \\<in> V &&& t \\<in> V", "using edges_are_in_V"], ["proof (prove)\nusing this:\n  s \\<rightarrow> t\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?v \\<in> V\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?w \\<in> V\n\ngoal (1 subgoal):\n 1. s \\<in> V &&& t \\<in> V", "by blast+"], ["proof (state)\nthis:\n  s \\<in> V\n  t \\<in> V\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "text \\<open>Assume to the contrary that @{term \"u \\<in> V\"} is in neither part.\\<close>"], ["proof (state)\nthis:\n  s \\<in> V\n  t \\<in> V\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "assume u: \"u \\<in> V\" \"u \\<notin> left_tree s t\" \"u \\<notin> left_tree t s\""], ["proof (state)\nthis:\n  u \\<in> V\n  u \\<notin> left_tree s t\n  u \\<notin> left_tree t s\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "text \\<open>Then we can construct two different paths from @{term s} to @{term u}, which, in a\n      tree, is a contradiction.  First, we get paths from @{term s} to @{term u} and from\n      @{term t} to @{term u}.\\<close>"], ["proof (state)\nthis:\n  u \\<in> V\n  u \\<notin> left_tree s t\n  u \\<notin> left_tree t s\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "let ?xs = \"s \\<leadsto> u\""], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "let ?ys = \"t \\<leadsto> u\""], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have \"t \\<notin> set ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> set (s \\<leadsto> u)", "using u(1,3)"], ["proof (prove)\nusing this:\n  u \\<in> V\n  u \\<notin> left_tree t s\n\ngoal (1 subgoal):\n 1. t \\<notin> set (s \\<leadsto> u)", "unfolding left_tree_def"], ["proof (prove)\nusing this:\n  u \\<in> V\n  u \\<notin> {u \\<in> V. t \\<in> set (u \\<leadsto> s)}\n\ngoal (1 subgoal):\n 1. t \\<notin> set (s \\<leadsto> u)", "by (metis (no_types, lifting) unique_connecting_path_rev mem_Collect_eq s set_rev)"], ["proof (state)\nthis:\n  t \\<notin> set (s \\<leadsto> u)\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have \"s \\<notin> set ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<notin> set (t \\<leadsto> u)", "using u(1,2)"], ["proof (prove)\nusing this:\n  u \\<in> V\n  u \\<notin> left_tree s t\n\ngoal (1 subgoal):\n 1. s \\<notin> set (t \\<leadsto> u)", "unfolding left_tree_def"], ["proof (prove)\nusing this:\n  u \\<in> V\n  u \\<notin> {u \\<in> V. s \\<in> set (u \\<leadsto> t)}\n\ngoal (1 subgoal):\n 1. s \\<notin> set (t \\<leadsto> u)", "by (metis (no_types, lifting) unique_connecting_path_rev mem_Collect_eq set_rev t)"], ["proof (state)\nthis:\n  s \\<notin> set (t \\<leadsto> u)\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "text \\<open>Now we can define two different paths from @{term s} to @{term u}.\\<close>"], ["proof (state)\nthis:\n  s \\<notin> set (t \\<leadsto> u)\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "define xs' where [simp]: \"xs' = ?xs\""], ["proof (state)\nthis:\n  xs' = s \\<leadsto> u\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "define ys' where [simp]: \"ys' = s # ?ys\""], ["proof (state)\nthis:\n  ys' = s # t \\<leadsto> u\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have \"path ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path ys'", "using path_cons \\<open>s \\<notin> set ?ys\\<close> assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>path ?xs; ?xs \\<noteq> []; ?v \\<rightarrow> hd ?xs;\n   ?v \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> path (?v # ?xs)\n  s \\<notin> set (t \\<leadsto> u)\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. path ys'", "by (simp add: unique_connecting_path_properties(1-3) t u(1))"], ["proof (state)\nthis:\n  path ys'\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "moreover"], ["proof (state)\nthis:\n  path ys'\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have \"path xs'\" \"xs' \\<noteq> []\" \"ys' \\<noteq> []\"  \"hd xs' = s\" \"last xs' = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (path xs' &&& xs' \\<noteq> []) &&&\n    ys' \\<noteq> [] &&& hd xs' = s &&& last xs' = u", "by (simp_all add: unique_connecting_path_properties s u(1))"], ["proof (state)\nthis:\n  path xs'\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n  hd xs' = s\n  last xs' = u\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "moreover"], ["proof (state)\nthis:\n  path xs'\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n  hd xs' = s\n  last xs' = u\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have \"hd ys' = s\" \"last ys' = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd ys' = s &&& last ys' = u", "by simp (simp add: unique_connecting_path_properties(2,4) t u(1))"], ["proof (state)\nthis:\n  hd ys' = s\n  last ys' = u\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "moreover"], ["proof (state)\nthis:\n  hd ys' = s\n  last ys' = u\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "have \"xs' \\<noteq> ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs' \\<noteq> ys'", "using unique_connecting_path_set(1) \\<open>t \\<notin> set ?xs\\<close> t u(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> set (?v \\<leadsto> ?w)\n  t \\<notin> set (s \\<leadsto> u)\n  t \\<in> V\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. xs' \\<noteq> ys'", "by auto"], ["proof (state)\nthis:\n  xs' \\<noteq> ys'\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "text \\<open>The existence of two different paths is a contradiction.\\<close>"], ["proof (state)\nthis:\n  xs' \\<noteq> ys'\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "ultimately"], ["proof (chain)\npicking this:\n  path ys'\n  path xs'\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n  hd xs' = s\n  last xs' = u\n  hd ys' = s\n  last ys' = u\n  xs' \\<noteq> ys'", "have False"], ["proof (prove)\nusing this:\n  path ys'\n  path xs'\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n  hd xs' = s\n  last xs' = u\n  hd ys' = s\n  last ys' = u\n  xs' \\<noteq> ys'\n\ngoal (1 subgoal):\n 1. False", "using unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  path ys'\n  path xs'\n  xs' \\<noteq> []\n  ys' \\<noteq> []\n  hd xs' = s\n  last xs' = u\n  hd ys' = s\n  last ys' = u\n  xs' \\<noteq> ys'\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?u2 \\<in> V; ?u2 \\<notin> left_tree s t;\n   ?u2 \\<notin> left_tree t s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "thus \"V \\<subseteq> left_tree s t \\<union> left_tree t s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?u2 \\<in> V; ?u2 \\<notin> left_tree s t;\n   ?u2 \\<notin> left_tree t s\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. V \\<subseteq> left_tree s t \\<union> left_tree t s", "by blast"], ["proof (state)\nthis:\n  V \\<subseteq> left_tree s t \\<union> left_tree t s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The left and right subtrees are disjoint.\\<close>"], ["", "lemma left_tree_disjoint:\n  assumes \"s\\<rightarrow>t\"\n  shows \"left_tree s t \\<inter> left_tree t s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  left_tree s t \\<inter> left_tree t s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  left_tree s t \\<inter> left_tree t s \\<noteq> {}", "obtain u where u: \"u \\<in> V\" \"s \\<in> set (u \\<leadsto> t)\" \"t \\<in> set (u \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  left_tree s t \\<inter> left_tree t s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> V; s \\<in> set (u \\<leadsto> t);\n         t \\<in> set (u \\<leadsto> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using left_treeE"], ["proof (prove)\nusing this:\n  left_tree s t \\<inter> left_tree t s \\<noteq> {}\n  ?u \\<in> left_tree ?s ?t \\<Longrightarrow>\n  ?u \\<in> V \\<and> ?s \\<in> set (?u \\<leadsto> ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> V; s \\<in> set (u \\<leadsto> t);\n         t \\<in> set (u \\<leadsto> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<in> V\n  s \\<in> set (u \\<leadsto> t)\n  t \\<in> set (u \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "have s: \"s \\<in> V\" and t: \"t \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> V &&& t \\<in> V", "using assms edges_are_in_V"], ["proof (prove)\nusing this:\n  s \\<rightarrow> t\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?v \\<in> V\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?w \\<in> V\n\ngoal (1 subgoal):\n 1. s \\<in> V &&& t \\<in> V", "by blast+"], ["proof (state)\nthis:\n  s \\<in> V\n  t \\<in> V\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "obtain ps ps' where ps: \"u \\<leadsto> t = ps @ s # ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps ps'.\n        u \\<leadsto> t = ps @ s # ps' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list u(2))"], ["proof (state)\nthis:\n  u \\<leadsto> t = ps @ s # ps'\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "hence \"ps' \\<noteq> Nil\""], ["proof (prove)\nusing this:\n  u \\<leadsto> t = ps @ s # ps'\n\ngoal (1 subgoal):\n 1. ps' \\<noteq> []", "using assms last_snoc no_loops unique_connecting_path_properties(4)[OF u(1) t]"], ["proof (prove)\nusing this:\n  u \\<leadsto> t = ps @ s # ps'\n  s \\<rightarrow> t\n  last (?xs @ [?x]) = ?x\n  (?v, ?v) \\<notin> E\n  last (u \\<leadsto> t) = t\n\ngoal (1 subgoal):\n 1. ps' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ps' \\<noteq> []\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "hence *: \"length (ps @ [s]) < length (u \\<leadsto> t)\""], ["proof (prove)\nusing this:\n  ps' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (ps @ [s]) < length (u \\<leadsto> t)", "by (simp add: ps)"], ["proof (state)\nthis:\n  length (ps @ [s]) < length (u \\<leadsto> t)\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "have ps': \"ps @ [s] = u \\<leadsto> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ps @ [s] = u \\<leadsto> s", "using ps unique_connecting_path_decomp t u(1)"], ["proof (prove)\nusing this:\n  u \\<leadsto> t = ps @ s # ps'\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?ps @ [?u] = ?v \\<leadsto> ?u\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?u # ?ps' = ?u \\<leadsto> ?w\n  t \\<in> V\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. ps @ [s] = u \\<leadsto> s", "by blast"], ["proof (state)\nthis:\n  ps @ [s] = u \\<leadsto> s\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ps @ [s] = u \\<leadsto> s", "obtain qs qs' where qs: \"ps @ [s] = qs @ t # qs'\""], ["proof (prove)\nusing this:\n  ps @ [s] = u \\<leadsto> s\n\ngoal (1 subgoal):\n 1. (\\<And>qs qs'.\n        ps @ [s] = qs @ t # qs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_list[OF u(3)]"], ["proof (prove)\nusing this:\n  ps @ [s] = u \\<leadsto> s\n  \\<exists>ys zs. u \\<leadsto> s = ys @ t # zs\n\ngoal (1 subgoal):\n 1. (\\<And>qs qs'.\n        ps @ [s] = qs @ t # qs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ps @ [s] = qs @ t # qs'\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "hence \"qs' \\<noteq> Nil\""], ["proof (prove)\nusing this:\n  ps @ [s] = qs @ t # qs'\n\ngoal (1 subgoal):\n 1. qs' \\<noteq> []", "using assms last_snoc no_loops"], ["proof (prove)\nusing this:\n  ps @ [s] = qs @ t # qs'\n  s \\<rightarrow> t\n  last (?xs @ [?x]) = ?x\n  (?v, ?v) \\<notin> E\n\ngoal (1 subgoal):\n 1. qs' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  qs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "hence **: \"length (qs @ [t]) < length (ps @ [s])\""], ["proof (prove)\nusing this:\n  qs' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (qs @ [t]) < length (ps @ [s])", "by (simp add: qs)"], ["proof (state)\nthis:\n  length (qs @ [t]) < length (ps @ [s])\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "have \"qs @ [t] = u \\<leadsto> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. qs @ [t] = u \\<leadsto> t", "using qs ps' unique_connecting_path_decomp s u(1)"], ["proof (prove)\nusing this:\n  ps @ [s] = qs @ t # qs'\n  ps @ [s] = u \\<leadsto> s\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?ps @ [?u] = ?v \\<leadsto> ?u\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V;\n   ?v \\<leadsto> ?w = ?ps @ ?u # ?ps'\\<rbrakk>\n  \\<Longrightarrow> ?u # ?ps' = ?u \\<leadsto> ?w\n  s \\<in> V\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. qs @ [t] = u \\<leadsto> t", "by metis"], ["proof (state)\nthis:\n  qs @ [t] = u \\<leadsto> t\n\ngoal (1 subgoal):\n 1. left_tree s t \\<inter> left_tree t s \\<noteq> {} \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  qs @ [t] = u \\<leadsto> t\n\ngoal (1 subgoal):\n 1. False", "using less_trans[OF ** *]"], ["proof (prove)\nusing this:\n  qs @ [t] = u \\<leadsto> t\n  length (qs @ [t]) < length (u \\<leadsto> t)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The path from a vertex in the left subtree to a vertex in the right subtree goes through @{term s}.\n  In other words, an edge @{term \"s\\<rightarrow>t\"} is a separator in a tree.\n\\<close>"], ["", "theorem left_tree_separates:\n  assumes st: \"s\\<rightarrow>t\" and u: \"u \\<in> left_tree s t\" and u': \"u' \\<in> left_tree t s\"\n  shows \"s \\<in> set (u \\<leadsto> u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> set (u \\<leadsto> u')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<notin> set (u \\<leadsto> u') \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  s \\<notin> set (u \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. s \\<notin> set (u \\<leadsto> u') \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<notin> set (u \\<leadsto> u')", "have \"set (u \\<leadsto> u') \\<subseteq> left_tree s t\""], ["proof (prove)\nusing this:\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<notin> set (u \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. set (u \\<leadsto> u') \\<subseteq> left_tree s t", "proof(induct \"u \\<leadsto> u'\" arbitrary: u u')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u u'.\n       \\<lbrakk>[] = u \\<leadsto> u'; s \\<rightarrow> t;\n        u \\<in> left_tree s t; u' \\<in> left_tree t s;\n        s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t\n 2. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "case Nil"], ["proof (state)\nthis:\n  [] = u \\<leadsto> u'\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<notin> set (u \\<leadsto> u')\n\ngoal (2 subgoals):\n 1. \\<And>u u'.\n       \\<lbrakk>[] = u \\<leadsto> u'; s \\<rightarrow> t;\n        u \\<in> left_tree s t; u' \\<in> left_tree t s;\n        s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t\n 2. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "thus ?case"], ["proof (prove)\nusing this:\n  [] = u \\<leadsto> u'\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<notin> set (u \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. set (u \\<leadsto> u') \\<subseteq> left_tree s t", "using unique_connecting_path_properties(2)"], ["proof (prove)\nusing this:\n  [] = u \\<leadsto> u'\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<notin> set (u \\<leadsto> u')\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> ?v \\<leadsto> ?w \\<noteq> []\n\ngoal (1 subgoal):\n 1. set (u \\<leadsto> u') \\<subseteq> left_tree s t", "by auto"], ["proof (state)\nthis:\n  set (u \\<leadsto> u') \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "case (Cons x xs u u')"], ["proof (state)\nthis:\n  \\<lbrakk>xs = ?u \\<leadsto> ?u'; s \\<rightarrow> t;\n   ?u \\<in> left_tree s t; ?u' \\<in> left_tree t s;\n   s \\<notin> set (?u \\<leadsto> ?u')\\<rbrakk>\n  \\<Longrightarrow> set (?u \\<leadsto> ?u') \\<subseteq> left_tree s t\n  x # xs = u \\<leadsto> u'\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<notin> set (u \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "have \"x = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = u", "using Cons.hyps(2) Cons.prems(2,3)"], ["proof (prove)\nusing this:\n  x # xs = u \\<leadsto> u'\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n\ngoal (1 subgoal):\n 1. x = u", "by (metis left_treeE list.sel(1) unique_connecting_path_properties(3))"], ["proof (state)\nthis:\n  x = u\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "hence \"u\\<rightarrow>hd xs\""], ["proof (prove)\nusing this:\n  x = u\n\ngoal (1 subgoal):\n 1. u \\<rightarrow> hd xs", "using Cons.hyps(2) Cons.prems(2,3) st"], ["proof (prove)\nusing this:\n  x = u\n  x # xs = u \\<leadsto> u'\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. u \\<rightarrow> hd xs", "by (metis IntI left_tree_disjoint distinct.simps(2) last.simps left_treeE list.set(1)\n          unique_connecting_path_properties(1,4) walk_first_edge')"], ["proof (state)\nthis:\n  u \\<rightarrow> hd xs\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "hence \"u \\<in> V\" \"hd xs \\<in> V\""], ["proof (prove)\nusing this:\n  u \\<rightarrow> hd xs\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& hd xs \\<in> V", "using edges_are_in_V"], ["proof (prove)\nusing this:\n  u \\<rightarrow> hd xs\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?v \\<in> V\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?w \\<in> V\n\ngoal (1 subgoal):\n 1. u \\<in> V &&& hd xs \\<in> V", "by blast+"], ["proof (state)\nthis:\n  u \\<in> V\n  hd xs \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "have *: \"xs = hd xs \\<leadsto> u'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = hd xs \\<leadsto> u'", "by (metis Cons.hyps(2) Cons.prems(2,3) IntI left_tree_disjoint distinct.simps(2) last.simps\n          left_treeE list.sel(1,3) list.set(1) path_from_toI st\n          unique_connecting_path_properties(1,3,4) unique_connecting_path_unique walk_tl)"], ["proof (state)\nthis:\n  xs = hd xs \\<leadsto> u'\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "moreover"], ["proof (state)\nthis:\n  xs = hd xs \\<leadsto> u'\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "hence \"s \\<notin> set (hd xs \\<leadsto> u')\""], ["proof (prove)\nusing this:\n  xs = hd xs \\<leadsto> u'\n\ngoal (1 subgoal):\n 1. s \\<notin> set (hd xs \\<leadsto> u')", "using Cons.hyps(2) Cons.prems(4)"], ["proof (prove)\nusing this:\n  xs = hd xs \\<leadsto> u'\n  x # xs = u \\<leadsto> u'\n  s \\<notin> set (u \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. s \\<notin> set (hd xs \\<leadsto> u')", "by (metis list.set_intros(2))"], ["proof (state)\nthis:\n  s \\<notin> set (hd xs \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "moreover"], ["proof (state)\nthis:\n  s \\<notin> set (hd xs \\<leadsto> u')\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "have \"hd xs \\<in> left_tree s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd xs \\<in> left_tree s t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  hd xs \\<notin> left_tree s t\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "hence \"hd xs \\<in> left_tree t s\""], ["proof (prove)\nusing this:\n  hd xs \\<notin> left_tree s t\n\ngoal (1 subgoal):\n 1. hd xs \\<in> left_tree t s", "using \\<open>hd xs \\<in> V\\<close> st left_tree_union_V"], ["proof (prove)\nusing this:\n  hd xs \\<notin> left_tree s t\n  hd xs \\<in> V\n  s \\<rightarrow> t\n  ?s \\<rightarrow> ?t \\<Longrightarrow>\n  left_tree ?s ?t \\<union> left_tree ?t ?s = V\n\ngoal (1 subgoal):\n 1. hd xs \\<in> left_tree t s", "by fastforce"], ["proof (state)\nthis:\n  hd xs \\<in> left_tree t s\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "hence \"t \\<in> set (hd xs \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  hd xs \\<in> left_tree t s\n\ngoal (1 subgoal):\n 1. t \\<in> set (hd xs \\<leadsto> s)", "using left_treeE"], ["proof (prove)\nusing this:\n  hd xs \\<in> left_tree t s\n  ?u \\<in> left_tree ?s ?t \\<Longrightarrow>\n  ?u \\<in> V \\<and> ?s \\<in> set (?u \\<leadsto> ?t)\n\ngoal (1 subgoal):\n 1. t \\<in> set (hd xs \\<leadsto> s)", "by blast"], ["proof (state)\nthis:\n  t \\<in> set (hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "let ?ys' = \"hd xs \\<leadsto> s\""], ["proof (state)\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "let ?ys = \"u # ?ys'\""], ["proof (state)\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "have \"u \\<notin> set ?ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<notin> set (hd xs \\<leadsto> s)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> set (hd xs \\<leadsto> s) \\<Longrightarrow> False", "assume \"u \\<in> set ?ys'\""], ["proof (state)\nthis:\n  u \\<in> set (hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. u \\<in> set (hd xs \\<leadsto> s) \\<Longrightarrow> False", "hence \"tl ?ys' = u \\<leadsto> s\""], ["proof (prove)\nusing this:\n  u \\<in> set (hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. tl (hd xs \\<leadsto> s) = u \\<leadsto> s", "using unique_connecting_path_tl \\<open>u\\<rightarrow>hd xs\\<close> edges_are_in_V(1) st"], ["proof (prove)\nusing this:\n  u \\<in> set (hd xs \\<leadsto> s)\n  \\<lbrakk>?v \\<in> V; ?u \\<in> set (?w \\<leadsto> ?v);\n   ?u \\<rightarrow> ?w\\<rbrakk>\n  \\<Longrightarrow> tl (?w \\<leadsto> ?v) = ?u \\<leadsto> ?v\n  u \\<rightarrow> hd xs\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?v \\<in> V\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. tl (hd xs \\<leadsto> s) = u \\<leadsto> s", "by auto"], ["proof (state)\nthis:\n  tl (hd xs \\<leadsto> s) = u \\<leadsto> s\n\ngoal (1 subgoal):\n 1. u \\<in> set (hd xs \\<leadsto> s) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  tl (hd xs \\<leadsto> s) = u \\<leadsto> s\n\ngoal (1 subgoal):\n 1. u \\<in> set (hd xs \\<leadsto> s) \\<Longrightarrow> False", "have \"t \\<noteq> hd xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> hd xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t = hd xs \\<Longrightarrow> False", "let ?ys = \"[u, hd xs]\""], ["proof (state)\ngoal (1 subgoal):\n 1. t = hd xs \\<Longrightarrow> False", "have \"t \\<noteq> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> u", "using Cons.prems(2) left_tree_initial_edge st"], ["proof (prove)\nusing this:\n  u \\<in> left_tree s t\n  ?s \\<rightarrow> ?t \\<Longrightarrow> ?t \\<notin> left_tree ?s ?t\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. t \\<noteq> u", "by blast"], ["proof (state)\nthis:\n  t \\<noteq> u\n\ngoal (1 subgoal):\n 1. t = hd xs \\<Longrightarrow> False", "assume \"t = hd xs\""], ["proof (state)\nthis:\n  t = hd xs\n\ngoal (1 subgoal):\n 1. t = hd xs \\<Longrightarrow> False", "hence \"?ys = u \\<leadsto> t\""], ["proof (prove)\nusing this:\n  t = hd xs\n\ngoal (1 subgoal):\n 1. [u, hd xs] = u \\<leadsto> t", "using unique_connecting_path_unique[of u ?ys \"hd xs\"] \\<open>u\\<rightarrow>hd xs\\<close> \\<open>t \\<noteq> u\\<close>"], ["proof (prove)\nusing this:\n  t = hd xs\n  u \\<leadsto>[u, hd xs]\\<leadsto> hd xs \\<Longrightarrow>\n  [u, hd xs] = u \\<leadsto> hd xs\n  u \\<rightarrow> hd xs\n  t \\<noteq> u\n\ngoal (1 subgoal):\n 1. [u, hd xs] = u \\<leadsto> t", "by (simp add: path_from_toI)"], ["proof (state)\nthis:\n  [u, hd xs] = u \\<leadsto> t\n\ngoal (1 subgoal):\n 1. t = hd xs \\<Longrightarrow> False", "hence \"s \\<notin> set (u \\<leadsto> t)\""], ["proof (prove)\nusing this:\n  [u, hd xs] = u \\<leadsto> t\n\ngoal (1 subgoal):\n 1. s \\<notin> set (u \\<leadsto> t)", "by (metis Cons.hyps(2) Cons.prems(4) \\<open>t = hd xs\\<close> \\<open>x = u\\<close> distinct.simps(2)\n                distinct_singleton list.set_intros(1) no_loops set_ConsD st)"], ["proof (state)\nthis:\n  s \\<notin> set (u \\<leadsto> t)\n\ngoal (1 subgoal):\n 1. t = hd xs \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  s \\<notin> set (u \\<leadsto> t)\n\ngoal (1 subgoal):\n 1. False", "using Cons.prems(2) left_treeE"], ["proof (prove)\nusing this:\n  s \\<notin> set (u \\<leadsto> t)\n  u \\<in> left_tree s t\n  ?u \\<in> left_tree ?s ?t \\<Longrightarrow>\n  ?u \\<in> V \\<and> ?s \\<in> set (?u \\<leadsto> ?t)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<noteq> hd xs\n\ngoal (1 subgoal):\n 1. u \\<in> set (hd xs \\<leadsto> s) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  tl (hd xs \\<leadsto> s) = u \\<leadsto> s\n  t \\<noteq> hd xs", "have \"t \\<in> set (u \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  tl (hd xs \\<leadsto> s) = u \\<leadsto> s\n  t \\<noteq> hd xs\n\ngoal (1 subgoal):\n 1. t \\<in> set (u \\<leadsto> s)", "using \\<open>t \\<in> set ?ys'\\<close> \\<open>hd xs \\<in> V\\<close> st"], ["proof (prove)\nusing this:\n  tl (hd xs \\<leadsto> s) = u \\<leadsto> s\n  t \\<noteq> hd xs\n  t \\<in> set (hd xs \\<leadsto> s)\n  hd xs \\<in> V\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. t \\<in> set (u \\<leadsto> s)", "by (metis edges_are_in_V(1) unique_connecting_path_properties(2,3) list.collapse set_ConsD)"], ["proof (state)\nthis:\n  t \\<in> set (u \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. u \\<in> set (hd xs \\<leadsto> s) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  t \\<in> set (u \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. False", "using Cons.prems(2) st \\<open>u \\<in> V\\<close>"], ["proof (prove)\nusing this:\n  t \\<in> set (u \\<leadsto> s)\n  u \\<in> left_tree s t\n  s \\<rightarrow> t\n  u \\<in> V\n\ngoal (1 subgoal):\n 1. False", "by (meson left_tree_disjoint disjoint_iff_not_equal left_treeI)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<notin> set (hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "hence \"path ?ys\""], ["proof (prove)\nusing this:\n  u \\<notin> set (hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. path (u # hd xs \\<leadsto> s)", "using path_cons \\<open>u\\<rightarrow>hd xs\\<close>"], ["proof (prove)\nusing this:\n  u \\<notin> set (hd xs \\<leadsto> s)\n  \\<lbrakk>path ?xs; ?xs \\<noteq> []; ?v \\<rightarrow> hd ?xs;\n   ?v \\<notin> set ?xs\\<rbrakk>\n  \\<Longrightarrow> path (?v # ?xs)\n  u \\<rightarrow> hd xs\n\ngoal (1 subgoal):\n 1. path (u # hd xs \\<leadsto> s)", "by (metis unique_connecting_path_properties(1-3) edges_are_in_V st)"], ["proof (state)\nthis:\n  path (u # hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  path (u # hd xs \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "have \"?ys \\<noteq> Nil\" \"hd ?ys = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u # hd xs \\<leadsto> s \\<noteq> [] &&& hd (u # hd xs \\<leadsto> s) = u", "by simp_all"], ["proof (state)\nthis:\n  u # hd xs \\<leadsto> s \\<noteq> []\n  hd (u # hd xs \\<leadsto> s) = u\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u # hd xs \\<leadsto> s \\<noteq> []\n  hd (u # hd xs \\<leadsto> s) = u\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "have \"last ?ys = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (u # hd xs \\<leadsto> s) = s", "using st unique_connecting_path_properties(2,4) \\<open>hd xs \\<in> V\\<close>"], ["proof (prove)\nusing this:\n  s \\<rightarrow> t\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> ?v \\<leadsto> ?w \\<noteq> []\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> last (?v \\<leadsto> ?w) = ?w\n  hd xs \\<in> V\n\ngoal (1 subgoal):\n 1. last (u # hd xs \\<leadsto> s) = s", "by (simp add: edges_are_in_V(1))"], ["proof (state)\nthis:\n  last (u # hd xs \\<leadsto> s) = s\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  path (u # hd xs \\<leadsto> s)\n  u # hd xs \\<leadsto> s \\<noteq> []\n  hd (u # hd xs \\<leadsto> s) = u\n  last (u # hd xs \\<leadsto> s) = s", "have \"?ys = u \\<leadsto> s\""], ["proof (prove)\nusing this:\n  path (u # hd xs \\<leadsto> s)\n  u # hd xs \\<leadsto> s \\<noteq> []\n  hd (u # hd xs \\<leadsto> s) = u\n  last (u # hd xs \\<leadsto> s) = s\n\ngoal (1 subgoal):\n 1. u # hd xs \\<leadsto> s = u \\<leadsto> s", "using unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  path (u # hd xs \\<leadsto> s)\n  u # hd xs \\<leadsto> s \\<noteq> []\n  hd (u # hd xs \\<leadsto> s) = u\n  last (u # hd xs \\<leadsto> s) = s\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. u # hd xs \\<leadsto> s = u \\<leadsto> s", "by blast"], ["proof (state)\nthis:\n  u # hd xs \\<leadsto> s = u \\<leadsto> s\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "hence \"t \\<in> set (u \\<leadsto> s)\""], ["proof (prove)\nusing this:\n  u # hd xs \\<leadsto> s = u \\<leadsto> s\n\ngoal (1 subgoal):\n 1. t \\<in> set (u \\<leadsto> s)", "by (metis \\<open>t \\<in> set ?ys'\\<close> list.set_intros(2))"], ["proof (state)\nthis:\n  t \\<in> set (u \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. hd xs \\<notin> left_tree s t \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  t \\<in> set (u \\<leadsto> s)\n\ngoal (1 subgoal):\n 1. False", "using Cons.prems(2) \\<open>u \\<in> V\\<close> st"], ["proof (prove)\nusing this:\n  t \\<in> set (u \\<leadsto> s)\n  u \\<in> left_tree s t\n  u \\<in> V\n  s \\<rightarrow> t\n\ngoal (1 subgoal):\n 1. False", "by (meson left_tree_disjoint disjoint_iff_not_equal left_treeI)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hd xs \\<in> left_tree s t\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "ultimately"], ["proof (chain)\npicking this:\n  xs = hd xs \\<leadsto> u'\n  s \\<notin> set (hd xs \\<leadsto> u')\n  hd xs \\<in> left_tree s t", "have \"set (hd xs \\<leadsto> u') \\<subseteq> left_tree s t\""], ["proof (prove)\nusing this:\n  xs = hd xs \\<leadsto> u'\n  s \\<notin> set (hd xs \\<leadsto> u')\n  hd xs \\<in> left_tree s t\n\ngoal (1 subgoal):\n 1. set (hd xs \\<leadsto> u') \\<subseteq> left_tree s t", "using Cons.hyps(1) st Cons.prems(3)"], ["proof (prove)\nusing this:\n  xs = hd xs \\<leadsto> u'\n  s \\<notin> set (hd xs \\<leadsto> u')\n  hd xs \\<in> left_tree s t\n  \\<lbrakk>xs = ?u \\<leadsto> ?u'; s \\<rightarrow> t;\n   ?u \\<in> left_tree s t; ?u' \\<in> left_tree t s;\n   s \\<notin> set (?u \\<leadsto> ?u')\\<rbrakk>\n  \\<Longrightarrow> set (?u \\<leadsto> ?u') \\<subseteq> left_tree s t\n  s \\<rightarrow> t\n  u' \\<in> left_tree t s\n\ngoal (1 subgoal):\n 1. set (hd xs \\<leadsto> u') \\<subseteq> left_tree s t", "by blast"], ["proof (state)\nthis:\n  set (hd xs \\<leadsto> u') \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "hence \"set xs \\<subseteq> left_tree s t\""], ["proof (prove)\nusing this:\n  set (hd xs \\<leadsto> u') \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> left_tree s t", "using *"], ["proof (prove)\nusing this:\n  set (hd xs \\<leadsto> u') \\<subseteq> left_tree s t\n  xs = hd xs \\<leadsto> u'\n\ngoal (1 subgoal):\n 1. set xs \\<subseteq> left_tree s t", "by simp"], ["proof (state)\nthis:\n  set xs \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. \\<And>a x u u'.\n       \\<lbrakk>\\<And>u u'.\n                   \\<lbrakk>x = u \\<leadsto> u'; s \\<rightarrow> t;\n                    u \\<in> left_tree s t; u' \\<in> left_tree t s;\n                    s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n                   \\<Longrightarrow> set (u \\<leadsto> u')\n                                     \\<subseteq> left_tree s t;\n        a # x = u \\<leadsto> u'; s \\<rightarrow> t; u \\<in> left_tree s t;\n        u' \\<in> left_tree t s; s \\<notin> set (u \\<leadsto> u')\\<rbrakk>\n       \\<Longrightarrow> set (u \\<leadsto> u') \\<subseteq> left_tree s t", "thus ?case"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. set (u \\<leadsto> u') \\<subseteq> left_tree s t", "using Cons.hyps(2) Cons.prems(2,3)"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> left_tree s t\n  x # xs = u \\<leadsto> u'\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n\ngoal (1 subgoal):\n 1. set (u \\<leadsto> u') \\<subseteq> left_tree s t", "by (metis insert_subset left_treeE list.sel(1) list.set(2) unique_connecting_path_properties(3))"], ["proof (state)\nthis:\n  set (u \\<leadsto> u') \\<subseteq> left_tree s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (u \\<leadsto> u') \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. s \\<notin> set (u \\<leadsto> u') \\<Longrightarrow> False", "hence \"u' \\<in> left_tree s t\""], ["proof (prove)\nusing this:\n  set (u \\<leadsto> u') \\<subseteq> left_tree s t\n\ngoal (1 subgoal):\n 1. u' \\<in> left_tree s t", "using left_treeE u u' unique_connecting_path_set(2)"], ["proof (prove)\nusing this:\n  set (u \\<leadsto> u') \\<subseteq> left_tree s t\n  ?u \\<in> left_tree ?s ?t \\<Longrightarrow>\n  ?u \\<in> V \\<and> ?s \\<in> set (?u \\<leadsto> ?t)\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  \\<lbrakk>?v \\<in> V; ?w \\<in> V\\<rbrakk>\n  \\<Longrightarrow> ?w \\<in> set (?v \\<leadsto> ?w)\n\ngoal (1 subgoal):\n 1. u' \\<in> left_tree s t", "by auto"], ["proof (state)\nthis:\n  u' \\<in> left_tree s t\n\ngoal (1 subgoal):\n 1. s \\<notin> set (u \\<leadsto> u') \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  u' \\<in> left_tree s t\n\ngoal (1 subgoal):\n 1. False", "by (meson left_tree_disjoint disjoint_iff_not_equal st u')"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>By symmetry, the path also visits @{term t}.\\<close>"], ["", "corollary left_tree_separates':\n  assumes \"s\\<rightarrow>t\" \"u \\<in> left_tree s t\" \"u' \\<in> left_tree t s\"\n  shows \"t \\<in> set (u \\<leadsto> u')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> set (u \\<leadsto> u')", "using assms left_tree_separates"], ["proof (prove)\nusing this:\n  s \\<rightarrow> t\n  u \\<in> left_tree s t\n  u' \\<in> left_tree t s\n  \\<lbrakk>?s \\<rightarrow> ?t; ?u \\<in> left_tree ?s ?t;\n   ?u' \\<in> left_tree ?t ?s\\<rbrakk>\n  \\<Longrightarrow> ?s \\<in> set (?u \\<leadsto> ?u')\n\ngoal (1 subgoal):\n 1. t \\<in> set (u \\<leadsto> u')", "by (metis left_treeE set_rev undirected unique_connecting_path_rev)"], ["", "end \\<comment> \\<open>locale Tree\\<close>"], ["", "subsection \\<open>Rooted Trees\\<close>"], ["", "text \\<open>A rooted tree is a tree with a distinguished vertex called root.\\<close>"], ["", "locale RootedTree = Tree +\n  fixes root :: 'a\n  assumes root_in_V: \"root \\<in> V\"\nbegin"], ["", "text \\<open>In a rooted tree, we can define the parent relation.\\<close>"], ["", "definition parent :: \"'a \\<Rightarrow> 'a\" where\n    \"parent v \\<equiv> hd (tl (v \\<leadsto> root))\""], ["", "lemma parent_edge: \"\\<lbrakk> v \\<in> V; v \\<noteq> root \\<rbrakk> \\<Longrightarrow> v\\<rightarrow>parent v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; v \\<noteq> root\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> parent v", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; v \\<noteq> root\\<rbrakk>\n    \\<Longrightarrow> v \\<rightarrow> hd (tl (v \\<leadsto> root))", "by (metis last.simps list.exhaust_sel root_in_V unique_connecting_path_properties walk_first_edge')"], ["", "lemma parent_edge_root: \"v\\<rightarrow>root \\<Longrightarrow> parent v = root\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> root \\<Longrightarrow> parent v = root", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> root \\<Longrightarrow>\n    hd (tl (v \\<leadsto> root)) = root", "by (metis edges_are_in_V(1) path_from_toE undirected unique_connecting_path\n        unique_connecting_path_set(2) unique_connecting_path_tl unique_connecting_path_unique)"], ["", "lemma parent_in_V: \"\\<lbrakk> v \\<in> V; v \\<noteq> root \\<rbrakk> \\<Longrightarrow> parent v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; v \\<noteq> root\\<rbrakk>\n    \\<Longrightarrow> parent v \\<in> V", "using parent_edge edges_are_in_V(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; ?v \\<noteq> root\\<rbrakk>\n  \\<Longrightarrow> ?v \\<rightarrow> parent ?v\n  ?v \\<rightarrow> ?w \\<Longrightarrow> ?w \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> V; v \\<noteq> root\\<rbrakk>\n    \\<Longrightarrow> parent v \\<in> V", "by blast"], ["", "lemma parent_edge_cases: \"v\\<rightarrow>w \\<Longrightarrow> w = parent v \\<or> v = parent w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<Longrightarrow> w = parent v \\<or> v = parent w", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<rightarrow> w \\<Longrightarrow>\n    w = hd (tl (v \\<leadsto> root)) \\<or> v = hd (tl (w \\<leadsto> root))", "by (metis Un_iff edges_are_in_V(1) left_tree_initial left_tree_separates' left_tree_union_V\n        root_in_V undirected unique_connecting_path_properties(3) unique_connecting_path_tl)"], ["", "lemma sibling_path:\n    assumes v: \"v \\<in> V\" \"v \\<noteq> root\" and w: \"w \\<in> V\" \"w \\<noteq> root\" and vw: \"v \\<noteq> w\" \"parent v = parent w\"\n    shows \"v\\<leadsto>w = [v,parent v,w]\" (is \"_ = ?xs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<leadsto> w = [v, parent v, w]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<leadsto> w = [v, parent v, w]", "have \"path ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path [v, parent v, w]", "using v w vw"], ["proof (prove)\nusing this:\n  v \\<in> V\n  v \\<noteq> root\n  w \\<in> V\n  w \\<noteq> root\n  v \\<noteq> w\n  parent v = parent w\n\ngoal (1 subgoal):\n 1. path [v, parent v, w]", "by (metis distinct_length_2_or_more distinct_singleton no_loops parent_edge undirected\n          walk.Cons walk_2)"], ["proof (state)\nthis:\n  path [v, parent v, w]\n\ngoal (1 subgoal):\n 1. v \\<leadsto> w = [v, parent v, w]", "thus ?thesis"], ["proof (prove)\nusing this:\n  path [v, parent v, w]\n\ngoal (1 subgoal):\n 1. v \\<leadsto> w = [v, parent v, w]", "using unique_connecting_path_unique"], ["proof (prove)\nusing this:\n  path [v, parent v, w]\n  ?v \\<leadsto>?xs\\<leadsto> ?w \\<Longrightarrow> ?xs = ?v \\<leadsto> ?w\n\ngoal (1 subgoal):\n 1. v \\<leadsto> w = [v, parent v, w]", "by fastforce"], ["proof (state)\nthis:\n  v \\<leadsto> w = [v, parent v, w]\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>locale RootedTree\\<close>"], ["", "end"]]}