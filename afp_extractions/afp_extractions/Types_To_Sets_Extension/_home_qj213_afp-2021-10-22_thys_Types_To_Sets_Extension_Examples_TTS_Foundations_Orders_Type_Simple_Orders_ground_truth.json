{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/TTS_Foundations/Orders/Type_Simple_Orders.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma eq_refl: \n  assumes \"x = y\"\n  shows \"x \\<le>\\<^sub>a y\"", "lemma less_irrefl[iff]: \"\\<not> x <\\<^sub>a x\"", "lemma less_imp_le: \n  assumes \"x <\\<^sub>a y\"\n  shows \"x \\<le>\\<^sub>a y\"", "lemma strict_implies_not_eq: \n  assumes \"a <\\<^sub>a b\"\n  shows \"a \\<noteq> b\"", "lemma less_not_sym: \n  assumes \"x <\\<^sub>a y\"\n  shows \"\\<not> (y <\\<^sub>a x)\"", "lemma asym: \n  assumes \"a <\\<^sub>a b\" and \"b <\\<^sub>a a\" \n  shows False", "lemma less_asym: \n  assumes \"x <\\<^sub>a y\" and \"(\\<not> P \\<Longrightarrow> y <\\<^sub>a x)\" \n  shows P", "lemma less_trans: \n  assumes \"x <\\<^sub>a y\" and \"y <\\<^sub>a z\" \n  shows \"x <\\<^sub>a z\"", "lemma le_less_trans: \n  assumes \"x \\<le>\\<^sub>a y\" and \"y <\\<^sub>a z\" \n  shows \"x <\\<^sub>a z\"", "lemma less_le_trans: \n  assumes \"x <\\<^sub>a y\" and \"y \\<le>\\<^sub>a z\" \n  shows \"x <\\<^sub>a z\"", "lemma less_imp_not_less: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(\\<not> y <\\<^sub>a x) \\<longleftrightarrow> True\"", "lemma less_imp_triv: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(y <\\<^sub>a x \\<longrightarrow> P) \\<longleftrightarrow> True\"", "lemma less_asym': \n  assumes \"a <\\<^sub>a b\" and \"b <\\<^sub>a a\" \n  shows P", "lemma less_le: \"x <\\<^sub>a y \\<longleftrightarrow> x \\<le>\\<^sub>a y \\<and> x \\<noteq> y\"", "lemma le_less: \"x \\<le>\\<^sub>a y \\<longleftrightarrow> x <\\<^sub>a y \\<or> x = y\"", "lemma le_imp_less_or_eq: \n  assumes \"x \\<le>\\<^sub>a y\"\n  shows \"x <\\<^sub>a y \\<or> x = y\"", "lemma less_imp_not_eq: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(x = y) \\<longleftrightarrow> False\"", "lemma less_imp_not_eq2: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(y = x) \\<longleftrightarrow> False\"", "lemma neq_le_trans: \n  assumes \"a \\<noteq> b\" and \"a \\<le>\\<^sub>a b\" \n  shows \"a <\\<^sub>a b\"", "lemma le_neq_trans: \n  assumes \"a \\<le>\\<^sub>a b\" and \"a \\<noteq> b\" \n  shows \"a <\\<^sub>a b\"", "lemma eq_iff: \"x = y \\<longleftrightarrow> x \\<le>\\<^sub>a y \\<and> y \\<le>\\<^sub>a x\"", "lemma antisym_conv: \n  assumes \"y \\<le>\\<^sub>a x\"\n  shows \"x \\<le>\\<^sub>a y \\<longleftrightarrow> x = y\"", "lemma antisym_conv1: \n  assumes \"\\<not> x <\\<^sub>a y\"\n  shows \"x \\<le>\\<^sub>a y \\<longleftrightarrow> x = y\"", "lemma antisym_conv2: \n  assumes \"x \\<le>\\<^sub>a y\"\n  shows \"\\<not> x <\\<^sub>a y \\<longleftrightarrow> x = y\"", "lemma leD: \n  assumes \"y \\<le>\\<^sub>a x\"\n  shows \"\\<not> x <\\<^sub>a y\"", "lemma extremum_uniqueI: \n  assumes \"extremum \\<le>\\<^sub>a a\"\n  shows \"a = extremum\"", "lemma extremum_unique: \"extremum \\<le>\\<^sub>a a \\<longleftrightarrow> a = extremum\"", "lemma extremum_strict[simp]: \"\\<not> (extremum <\\<^sub>a a)\"", "lemma not_eq_extremum: \"a \\<noteq> extremum \\<longleftrightarrow> a <\\<^sub>a extremum\"", "lemmas Least_def = Least_def[of UNIV \\<open>(\\<le>\\<^sub>a)\\<close>]", "lemma Least_equality:\n  assumes \"P x\" and \"\\<And>y. P y \\<Longrightarrow> x \\<le>\\<^sub>a y\"\n  shows \"Least P = Some x\"", "lemma LeastI2_order:\n  assumes \"P x\" \n    and \"\\<And>y. P y \\<Longrightarrow> x \\<le>\\<^sub>a y\"\n    and \"\\<And>x. P x \\<Longrightarrow> \\<forall>y. P y \\<longrightarrow> x \\<le>\\<^sub>a y \\<Longrightarrow> Q x\"\n  obtains z where \"Least P = Some z\" and \"Q z\"", "lemma Least_ex1:\n  assumes \"\\<exists>!x. P x \\<and> (\\<forall>y. P y \\<longrightarrow> x \\<le>\\<^sub>a y)\"\n  obtains x where \"Least P = Some x\" and \"P x\" and \"P z \\<Longrightarrow> x \\<le>\\<^sub>a z\"", "lemma min_absorb1: \"x \\<le>\\<^sub>a y \\<Longrightarrow> min x y = x\"", "lemma min_absorb2: \n  assumes \"y \\<le>\\<^sub>a x\"\n  shows \"min x y = y\"", "lemma max_top[simp]: \"max extremum x = extremum\"", "lemma max_top2[simp]: \"max x extremum = extremum\"", "lemma min_top[simp]: \"min extremum x = x\"", "lemma min_top2[simp]: \"min x extremum = x\"", "lemma monoI[intro?]: \n  assumes \"\\<And>x y. x \\<le>\\<^sub>a y \\<Longrightarrow> f x \\<le>\\<^sub>b f y\" \n  shows \"mono\\<^sub>a\\<^sub>b f\"", "lemma monoD[dest?]:\n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"x \\<le>\\<^sub>a y\" \n  shows \"f x \\<le>\\<^sub>b f y\"", "lemma monoE:\n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"x \\<le>\\<^sub>a y\"\n  obtains \"f x \\<le>\\<^sub>b f y\"", "lemma strict_monoI[intro?]: \n  assumes \"\\<And>x y. x <\\<^sub>a y \\<Longrightarrow> f x <\\<^sub>b f y\" \n  shows \"strict_mono\\<^sub>a\\<^sub>b f\"", "lemma strict_monoD[dest?]:\n  assumes \"strict_mono\\<^sub>a\\<^sub>b f\" and \"x <\\<^sub>a y\" \n  shows \"f x <\\<^sub>b f y\"", "lemma strict_monoE:\n  assumes \"strict_mono\\<^sub>a\\<^sub>b f\" and \"x <\\<^sub>a y\"\n  obtains \"f x <\\<^sub>b f y\"", "lemma strict_mono_mono[dest?]: \n  assumes \"strict_mono\\<^sub>a\\<^sub>b f\"\n  shows \"mono\\<^sub>a\\<^sub>b f\"", "lemma ray_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\"\n  shows \"(rel_set A ===> (A ===> A ===> (=)) ===> A ===> rel_set A) ray ray\"", "lemma interval_ge_le:\n  \"(on UNIV with (\\<lambda>x y. le\\<^sub>a y x) (\\<lambda>x y. le\\<^sub>b y x) : {l\\<sqsubset>..\\<sqsubset>h}) = \n    (on UNIV with le\\<^sub>b le\\<^sub>a : {h\\<sqsubset>..\\<sqsubset>l})\"", "lemma lessThan_iff[iff]: \"(i \\<in> {..<\\<^sub>ak}) = (i <\\<^sub>a k)\"", "lemma atLeast_iff[iff]: \"(i \\<in> {k\\<le>\\<^sub>a..}) = (k \\<le>\\<^sub>a i)\"", "lemma greaterThanLessThan_iff[simp]: \"(i \\<in> {l<\\<^sub>a..<\\<^sub>au}) = (l <\\<^sub>a i \\<and> i <\\<^sub>a u)\"", "lemma atLeastLessThan_iff[simp]: \"(i \\<in> {l\\<le>\\<^sub>a..<\\<^sub>au}) = (l \\<le>\\<^sub>a i \\<and> i <\\<^sub>a u)\"", "lemma greaterThanAtMost_iff[simp]: \"(i \\<in> {l<\\<^sub>a..\\<le>\\<^sub>au}) = (l <\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)\"", "lemma atLeastAtMost_iff[simp]: \"(i \\<in> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au}) = (l \\<le>\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)\"", "lemma greaterThanLessThan_eq: \"{a<\\<^sub>a..<\\<^sub>ab} = {a<\\<^sub>a..} \\<inter> {..<\\<^sub>ab}\"", "lemma Ioi_le_Ico: \"{a<\\<^sub>a..} \\<subseteq> {a\\<le>\\<^sub>a..}\"", "lemma single_Diff_lessThan[simp]: \"{k} - {..<\\<^sub>ak} = {k}\"", "lemma atLeast_subset_iff[iff]: \"({x\\<le>\\<^sub>a..} \\<subseteq> {y\\<le>\\<^sub>a..}) = (y \\<le>\\<^sub>a x)\"", "lemma atLeastatMost_empty[simp]: \n  assumes \"b <\\<^sub>a a\"\n  shows \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {}\"", "lemma atLeastatMost_empty_iff[simp]: \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {} \\<longleftrightarrow> (\\<not> a \\<le>\\<^sub>a b)\"", "lemma atLeastatMost_empty_iff2[simp]: \"{} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} \\<longleftrightarrow> (\\<not> a \\<le>\\<^sub>a b)\"", "lemma atLeastLessThan_empty[simp]: \n  assumes \"b \\<le>\\<^sub>a a\" \n  shows \"{a\\<le>\\<^sub>a..<\\<^sub>ab} = {}\"", "lemma atLeastLessThan_empty_iff[simp]: \"{a\\<le>\\<^sub>a..<\\<^sub>ab} = {} \\<longleftrightarrow> (\\<not> a <\\<^sub>a b)\"", "lemma atLeastLessThan_empty_iff2[simp]: \"{} = {a\\<le>\\<^sub>a..<\\<^sub>ab} \\<longleftrightarrow> (\\<not> a <\\<^sub>a b)\"", "lemma greaterThanAtMost_empty[simp]: \n  assumes \"l \\<le>\\<^sub>a k\" \n  shows \"{k<\\<^sub>a..\\<le>\\<^sub>al} = {}\"", "lemma greaterThanAtMost_empty_iff[simp]: \"{k<\\<^sub>a..\\<le>\\<^sub>al} = {} \\<longleftrightarrow> \\<not> k <\\<^sub>a l\"", "lemma greaterThanAtMost_empty_iff2[simp]: \"{} = {k<\\<^sub>a..\\<le>\\<^sub>al} \\<longleftrightarrow> \\<not> k <\\<^sub>a l\"", "lemma greaterThanLessThan_empty[simp]: \n  assumes \"l \\<le>\\<^sub>a k\" \n  shows \"{k<\\<^sub>a..<\\<^sub>al} = {}\"", "lemma atLeastatMost_subset_iff[simp]:\n  \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} \\<le> {c\\<le>\\<^sub>a..\\<le>\\<^sub>ad} \\<longleftrightarrow> (\\<not> a \\<le>\\<^sub>a b) \\<or> c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a d\"", "lemma atLeastatMost_psubset_iff:\n  \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} < {c\\<le>\\<^sub>a..\\<le>\\<^sub>ad} \\<longleftrightarrow>\n    ((\\<not> a \\<le>\\<^sub>a b) \\<or> c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a d \\<and> (c <\\<^sub>a a \\<or> b <\\<^sub>a d)) \\<and> c \\<le>\\<^sub>a d\"", "lemma Icc_subset_Ici_iff[simp]: \n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<subseteq> {l'\\<le>\\<^sub>a..} = (\\<not> l \\<le>\\<^sub>a h \\<or> l \\<ge>\\<^sub>a l')\"", "lemma Icc_subset_Iic_iff[simp]: \n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<subseteq> {..\\<le>\\<^sub>ah'} = (\\<not> l \\<le>\\<^sub>a h \\<or> h \\<le>\\<^sub>a h')\"", "lemma not_Ici_eq_empty[simp]: \"{l\\<le>\\<^sub>a..} \\<noteq> {}\"", "lemmas not_empty_eq_Ici_eq_empty[simp] = not_Ici_eq_empty[symmetric]", "lemma Iio_Int_singleton: \"{..<\\<^sub>ak} \\<inter> {x} = (if x <\\<^sub>a k then {x} else {})\"", "lemma ivl_disj_int_one:\n  \"{..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {}\"\n  \"{l<\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}\"\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {}\"\n  \"{l\\<le>\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}\"", "lemma ivl_disj_int_two:\n  \"{l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} = {}\"", "lemma atMost_Int_atLeast: \"{..\\<le>\\<^sub>an} \\<inter> {n\\<le>\\<^sub>a..} = {n}\"", "lemma atLeast_eq_iff[iff]: \"({x\\<le>\\<^sub>a..} = {y\\<le>\\<^sub>a..}) = (x = y)\"", "lemma atLeastLessThan_eq_atLeastAtMost_diff: \"{a\\<le>\\<^sub>a..<\\<^sub>ab} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} - {b}\"", "lemma greaterThanAtMost_eq_atLeastAtMost_diff: \"{a<\\<^sub>a..\\<le>\\<^sub>ab} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} - {a}\"", "lemma atLeastAtMost_singleton[simp]: \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>aa} = {a}\"", "lemma atLeastAtMost_singleton': \n  assumes \"a = b\"\n  shows \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {a}\"", "lemma Icc_eq_Icc[simp]:\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} = {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'} = (l = l' \\<and> h = h' \\<or> \\<not> l \\<le>\\<^sub>a h \\<and> \\<not> l' \\<le>\\<^sub>a h')\"", "lemma atLeastAtMost_singleton_iff[simp]: \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c} \\<longleftrightarrow> a = b \\<and> b = c\"", "lemma atMost_eq_UNIV_iff: \"{..\\<le>\\<^sub>ax} = UNIV \\<longleftrightarrow> x = extremum\"", "lemma not_UNIV_le_Icc[simp]: \"\\<not> UNIV \\<subseteq> {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah}\"", "lemma not_UNIV_le_Iic[simp]: \"\\<not> UNIV \\<subseteq> {..\\<le>\\<^sub>ah}\"", "lemma not_Ici_le_Icc[simp]: \"\\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}\"", "lemma not_Ici_le_Iic[simp]: \"\\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}\"", "lemma not_UNIV_eq_Icc[simp]: \"UNIV \\<noteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}\"", "lemmas not_Icc_eq_UNIV[simp] = not_UNIV_eq_Icc[symmetric]", "lemma not_UNIV_eq_Iic[simp]: \"UNIV \\<noteq> {..\\<le>\\<^sub>ah'}\"", "lemmas not_Iic_eq_UNIV[simp] = not_UNIV_eq_Iic[symmetric]", "lemma not_Icc_eq_Ici[simp]: \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}\"", "lemmas not_Ici_eq_Icc[simp] = not_Icc_eq_Ici[symmetric]", "lemma not_Iic_eq_Ici[simp]: \"{..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}\"", "lemmas not_Ici_eq_Iic[simp] = not_Iic_eq_Ici[symmetric]", "lemma greaterThan_non_empty[simp]: \"{x<\\<^sub>a..} \\<noteq> {}\"", "lemma mono_image_least:\n  assumes f_mono: \"mono\\<^sub>a\\<^sub>b f\" \n    and f_img: \"f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}\" \n    and \"m <\\<^sub>a n\"\n  shows \"f m = m'\"", "lemma bdd_aboveI[intro]: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le>\\<^sub>a M\"\n  shows \"bdd_above A\"", "lemma bdd_belowI[intro]: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a x\"\n  shows \"bdd_below A\"", "lemma bdd_aboveI2: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<le>\\<^sub>a M\"\n  shows \"bdd_above (f ` A)\"", "lemma bdd_belowI2: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a f x\"\n  shows \"bdd_below (f ` A)\"", "lemma bdd_above_empty[simp, intro]: \"bdd_above {}\"", "lemma bdd_below_empty[simp, intro]: \"bdd_below {}\"", "lemma bdd_above_mono: \n  assumes \"bdd_above B\" and \"A \\<subseteq> B\" \n  shows \"bdd_above A\"", "lemma bdd_below_mono: \n  assumes \"bdd_below B\" and \"A \\<subseteq> B\"\n  shows \"bdd_below A\"", "lemma bdd_above_Int1[simp]: \n  assumes \"bdd_above A\"\n  shows \"bdd_above (A \\<inter> B)\"", "lemma bdd_above_Int2[simp]: \n  assumes \"bdd_above B\"\n  shows \"bdd_above (A \\<inter> B)\"", "lemma bdd_below_Int1[simp]: \n  assumes \"bdd_below A\"\n  shows \"bdd_below (A \\<inter> B)\"", "lemma bdd_below_Int2[simp]: \n  assumes \"bdd_below B\"\n  shows \"bdd_below (A \\<inter> B)\"", "lemma bdd_above_Ioo[simp, intro]: \"bdd_above {a<\\<^sub>a..<\\<^sub>ab}\"", "lemma bdd_above_Ico[simp, intro]: \"bdd_above {a\\<le>\\<^sub>a..<\\<^sub>ab}\"", "lemma bdd_above_Iio[simp, intro]: \"bdd_above {..<\\<^sub>ab}\"", "lemma bdd_above_Ioc[simp, intro]: \"bdd_above {a<\\<^sub>a..\\<le>\\<^sub>ab}\"", "lemma bdd_above_Icc[simp, intro]: \"bdd_above {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}\"", "lemma bdd_above_Iic[simp, intro]: \"bdd_above {..\\<le>\\<^sub>ab}\"", "lemma bdd_below_Ioo[simp, intro]: \"bdd_below {a<\\<^sub>a..<\\<^sub>ab}\"", "lemma bdd_below_Ioc[simp, intro]: \"bdd_below {a<\\<^sub>a..\\<le>\\<^sub>ab}\"", "lemma bdd_below_Ioi[simp, intro]: \"bdd_below {a<\\<^sub>a..}\"", "lemma bdd_below_Ico[simp, intro]: \"bdd_below {a\\<le>\\<^sub>a..<\\<^sub>ab}\"", "lemma bdd_below_Icc[simp, intro]: \"bdd_below {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}\"", "lemma bdd_below_Ici[simp, intro]: \"bdd_below {a\\<le>\\<^sub>a..}\"", "lemma bdd_above_image_mono: \n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_above A\"\n  shows \"ord\\<^sub>b.bdd_above (f ` A)\"", "lemma bdd_below_image_mono: \n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_below A\" \n  shows \"ord\\<^sub>b.bdd_below (f ` A)\"", "lemma bdd_above_image_antimono:\n  assumes \"antimono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_below A\" \n  shows \"ord\\<^sub>b.bdd_above (f ` A)\"", "lemma bdd_below_image_antimono: \n  assumes \"antimono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_above A\"   \n  shows \"ord\\<^sub>b.bdd_below (f ` A)\"", "lemma bdd_above_top[simp, intro!]: \"bdd_above A\""], "translations": [["", "lemma eq_refl: \n  assumes \"x = y\"\n  shows \"x \\<le>\\<^sub>a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le>\\<^sub>a y", "using assms"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<le>\\<^sub>a y", "by (rule ssubst) (rule order_refl)"], ["", "lemma less_irrefl[iff]: \"\\<not> x <\\<^sub>a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x <\\<^sub>a x", "by (simp add: less_le_not_le)"], ["", "lemma less_imp_le: \n  assumes \"x <\\<^sub>a y\"\n  shows \"x \\<le>\\<^sub>a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le>\\<^sub>a y", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. x \\<le>\\<^sub>a y", "by (simp add: less_le_not_le)"], ["", "lemma strict_implies_not_eq: \n  assumes \"a <\\<^sub>a b\"\n  shows \"a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b", "using assms"], ["proof (prove)\nusing this:\n  a <\\<^sub>a b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b", "by blast"], ["", "text\\<open>Asymmetry.\\<close>"], ["", "lemma less_not_sym: \n  assumes \"x <\\<^sub>a y\"\n  shows \"\\<not> (y <\\<^sub>a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> y <\\<^sub>a x", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. \\<not> y <\\<^sub>a x", "by (simp add: less_le_not_le)"], ["", "lemma asym: \n  assumes \"a <\\<^sub>a b\" and \"b <\\<^sub>a a\" \n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  a <\\<^sub>a b\n  b <\\<^sub>a a\n\ngoal (1 subgoal):\n 1. False", "by (simp add: less_not_sym)"], ["", "lemma less_asym: \n  assumes \"x <\\<^sub>a y\" and \"(\\<not> P \\<Longrightarrow> y <\\<^sub>a x)\" \n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n  \\<not> P \\<Longrightarrow> y <\\<^sub>a x\n\ngoal (1 subgoal):\n 1. P", "by (auto dest: asym)"], ["", "text\\<open>Transitivity.\\<close>"], ["", "lemma less_trans: \n  assumes \"x <\\<^sub>a y\" and \"y <\\<^sub>a z\" \n  shows \"x <\\<^sub>a z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x <\\<^sub>a z", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n  y <\\<^sub>a z\n\ngoal (1 subgoal):\n 1. x <\\<^sub>a z", "by (auto simp: less_le_not_le intro: order_trans)"], ["", "lemma le_less_trans: \n  assumes \"x \\<le>\\<^sub>a y\" and \"y <\\<^sub>a z\" \n  shows \"x <\\<^sub>a z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x <\\<^sub>a z", "using assms"], ["proof (prove)\nusing this:\n  x \\<le>\\<^sub>a y\n  y <\\<^sub>a z\n\ngoal (1 subgoal):\n 1. x <\\<^sub>a z", "by (auto simp: less_le_not_le intro: order_trans)"], ["", "lemma less_le_trans: \n  assumes \"x <\\<^sub>a y\" and \"y \\<le>\\<^sub>a z\" \n  shows \"x <\\<^sub>a z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x <\\<^sub>a z", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n  y \\<le>\\<^sub>a z\n\ngoal (1 subgoal):\n 1. x <\\<^sub>a z", "by (auto simp: less_le_not_le intro: order_trans)"], ["", "lemma less_imp_not_less: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(\\<not> y <\\<^sub>a x) \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> y <\\<^sub>a x) = True", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (\\<not> y <\\<^sub>a x) = True", "by (elim less_asym) simp"], ["", "lemma less_imp_triv: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(y <\\<^sub>a x \\<longrightarrow> P) \\<longleftrightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y <\\<^sub>a x \\<longrightarrow> P) = True", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (y <\\<^sub>a x \\<longrightarrow> P) = True", "by (elim less_asym) simp"], ["", "lemma less_asym': \n  assumes \"a <\\<^sub>a b\" and \"b <\\<^sub>a a\" \n  shows P"], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  a <\\<^sub>a b\n  b <\\<^sub>a a\n\ngoal (1 subgoal):\n 1. P", "by (rule less_asym)"], ["", "end"], ["", "subsection\\<open>Partial orders\\<close>"], ["", "subsubsection\\<open>Definitions\\<close>"], ["", "text\\<open>Abstract partial orders.\\<close>"], ["", "locale order = preorder le ls for le ls :: \"['a, 'a] \\<Rightarrow> bool\" +\n  assumes antisym: \"le x y \\<Longrightarrow> le y x \\<Longrightarrow> x = y\""], ["", "locale order_dual = order le ls for le ls :: \"['a, 'a] \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale preorder_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", ".."], ["", "sublocale dual: order ge gt"], ["proof (prove)\ngoal (1 subgoal):\n 1. order (\\<lambda>x y. y \\<le>\\<^sub>a x) (\\<lambda>x y. y <\\<^sub>a x)", "unfolding order_def order_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) \\<and>\n    (\\<forall>x y.\n        y \\<le>\\<^sub>a x \\<longrightarrow>\n        x \\<le>\\<^sub>a y \\<longrightarrow> x = y)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) \\<and>\n    (\\<forall>x y.\n        y \\<le>\\<^sub>a x \\<longrightarrow>\n        x \\<le>\\<^sub>a y \\<longrightarrow> x = y)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. preorder (\\<lambda>x y. y \\<le>\\<^sub>a x) (\\<lambda>x y. y <\\<^sub>a x)\n 2. \\<forall>x y.\n       y \\<le>\\<^sub>a x \\<longrightarrow>\n       x \\<le>\\<^sub>a y \\<longrightarrow> x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder (\\<lambda>x y. y \\<le>\\<^sub>a x) (\\<lambda>x y. y <\\<^sub>a x)", "by (rule dual.preorder_axioms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       y \\<le>\\<^sub>a x \\<longrightarrow>\n       x \\<le>\\<^sub>a y \\<longrightarrow> x = y", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       y \\<le>\\<^sub>a x \\<longrightarrow>\n       x \\<le>\\<^sub>a y \\<longrightarrow> x = y", "by (simp add: antisym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "text\\<open>Pairs.\\<close>"], ["", "locale ord_order = ord_preorder le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>b: order le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["", "locale ord_order_dual = ord_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ord_preorder_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_preorder_dual (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: ord_order \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_order (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", "by unfold_locales (simp add: ord\\<^sub>b.antisym)"], ["", "sublocale dual_ord: ord_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_order (\\<le>\\<^sub>b) (<\\<^sub>b)", "by (rule ord_order_axioms)"], ["", "sublocale dual_dual: ord_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_order (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", "by (rule ord_dual.ord_order_axioms)"], ["", "end"], ["", "locale preorder_order = ord_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>a: preorder le\\<^sub>a ls\\<^sub>a\n  for le\\<^sub>a ls\\<^sub>a :: \"['a, 'a] \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"['b, 'b] \\<Rightarrow> bool\"\nbegin"], ["", "sublocale preorder_pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_pair le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b", ".."], ["", "end"], ["", "locale preorder_order_dual = preorder_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"['a, 'a] \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"['b, 'b] \\<Rightarrow> bool\" \nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ord_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_order_dual (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale preorder_pair_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_pair_dual (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>b)\n     (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: preorder_order \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_order (\\<le>\\<^sub>a) (<\\<^sub>a)\n     (\\<lambda>x y. y \\<le>\\<^sub>b x) (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "sublocale dual_ord: preorder_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale dual_dual: preorder_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "end"], ["", "locale order_pair = preorder_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>a: order le\\<^sub>a ls\\<^sub>a\n  for le\\<^sub>a ls\\<^sub>a :: \"['a, 'a] \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"['b, 'b] \\<Rightarrow> bool\" \nbegin"], ["", "sublocale rev: order_pair le\\<^sub>b ls\\<^sub>b le\\<^sub>a ls\\<^sub>a"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair le\\<^sub>b ls\\<^sub>b le\\<^sub>a ls\\<^sub>a", ".."], ["", "end"], ["", "locale order_pair_dual = order_pair le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"['a, 'a] \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"['b, 'b] \\<Rightarrow> bool\" \nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale preorder_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_order_dual (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>b)\n     (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: order_pair \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "sublocale dual_ord: order_pair \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<le>\\<^sub>b) (<\\<^sub>b)", "by unfold_locales (simp add: ord\\<^sub>a.antisym)"], ["", "sublocale dual_dual: order_pair \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "end"], ["", "subsubsection\\<open>Results\\<close>"], ["", "context order\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text\\<open>Reflexivity.\\<close>"], ["", "lemma less_le: \"x <\\<^sub>a y \\<longleftrightarrow> x \\<le>\\<^sub>a y \\<and> x \\<noteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x <\\<^sub>a y) = (x \\<le>\\<^sub>a y \\<and> x \\<noteq> y)", "by (auto simp: less_le_not_le intro: antisym)"], ["", "lemma le_less: \"x \\<le>\\<^sub>a y \\<longleftrightarrow> x <\\<^sub>a y \\<or> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le>\\<^sub>a y) = (x <\\<^sub>a y \\<or> x = y)", "by (auto simp: less_le)"], ["", "lemma le_imp_less_or_eq: \n  assumes \"x \\<le>\\<^sub>a y\"\n  shows \"x <\\<^sub>a y \\<or> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x <\\<^sub>a y \\<or> x = y", "using assms"], ["proof (prove)\nusing this:\n  x \\<le>\\<^sub>a y\n\ngoal (1 subgoal):\n 1. x <\\<^sub>a y \\<or> x = y", "by (simp add: le_less)"], ["", "lemma less_imp_not_eq: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(x = y) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = False", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (x = y) = False", "by auto"], ["", "lemma less_imp_not_eq2: \n  assumes \"x <\\<^sub>a y\"\n  shows \"(y = x) \\<longleftrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y = x) = False", "using assms"], ["proof (prove)\nusing this:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (y = x) = False", "by auto"], ["", "text\\<open>Transitivity.\\<close>"], ["", "lemma neq_le_trans: \n  assumes \"a \\<noteq> b\" and \"a \\<le>\\<^sub>a b\" \n  shows \"a <\\<^sub>a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a <\\<^sub>a b", "using assms"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  a \\<le>\\<^sub>a b\n\ngoal (1 subgoal):\n 1. a <\\<^sub>a b", "by (simp add: less_le)"], ["", "lemma le_neq_trans: \n  assumes \"a \\<le>\\<^sub>a b\" and \"a \\<noteq> b\" \n  shows \"a <\\<^sub>a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a <\\<^sub>a b", "using assms"], ["proof (prove)\nusing this:\n  a \\<le>\\<^sub>a b\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a <\\<^sub>a b", "by (simp add: less_le)"], ["", "text\\<open>Asymmetry.\\<close>"], ["", "lemma eq_iff: \"x = y \\<longleftrightarrow> x \\<le>\\<^sub>a y \\<and> y \\<le>\\<^sub>a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = y) = (x \\<le>\\<^sub>a y \\<and> y \\<le>\\<^sub>a x)", "by (blast intro: antisym)"], ["", "lemma antisym_conv: \n  assumes \"y \\<le>\\<^sub>a x\"\n  shows \"x \\<le>\\<^sub>a y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le>\\<^sub>a y) = (x = y)", "using assms"], ["proof (prove)\nusing this:\n  y \\<le>\\<^sub>a x\n\ngoal (1 subgoal):\n 1. (x \\<le>\\<^sub>a y) = (x = y)", "by (blast intro: antisym)"], ["", "text\\<open>Other results.\\<close>"], ["", "lemma antisym_conv1: \n  assumes \"\\<not> x <\\<^sub>a y\"\n  shows \"x \\<le>\\<^sub>a y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le>\\<^sub>a y) = (x = y)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (x \\<le>\\<^sub>a y) = (x = y)", "by (simp add: le_less)"], ["", "lemma antisym_conv2: \n  assumes \"x \\<le>\\<^sub>a y\"\n  shows \"\\<not> x <\\<^sub>a y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> x <\\<^sub>a y) = (x = y)", "using assms le_less"], ["proof (prove)\nusing this:\n  x \\<le>\\<^sub>a y\n  (?x \\<le>\\<^sub>a ?y) = (?x <\\<^sub>a ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. (\\<not> x <\\<^sub>a y) = (x = y)", "by auto"], ["", "lemma leD: \n  assumes \"y \\<le>\\<^sub>a x\"\n  shows \"\\<not> x <\\<^sub>a y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x <\\<^sub>a y", "using assms"], ["proof (prove)\nusing this:\n  y \\<le>\\<^sub>a x\n\ngoal (1 subgoal):\n 1. \\<not> x <\\<^sub>a y", "by (simp add: less_le_not_le)"], ["", "end"], ["", "subsection\\<open>Dense orders\\<close>"], ["", "text\\<open>Abstract dense orders.\\<close>"], ["", "locale dense_order = order le ls for le ls :: \"['a, 'a] \\<Rightarrow> bool\" +\n  assumes dense: \"ls x y \\<Longrightarrow> (\\<exists>z. ls x z \\<and> ls z y)\""], ["", "locale dense_order_dual = dense_order le ls for le ls :: \"['a, 'a] \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", ".."], ["", "sublocale dual: dense_order ge gt"], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x)", "using dense"], ["proof (prove)\nusing this:\n  ?x <\\<^sub>a ?y \\<Longrightarrow>\n  \\<exists>z. ?x <\\<^sub>a z \\<and> z <\\<^sub>a ?y\n\ngoal (1 subgoal):\n 1. dense_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x)", "by unfold_locales auto"], ["", "end"], ["", "text\\<open>Pairs.\\<close>"], ["", "locale ord_dense_order = ord_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>b: dense_order le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["", "locale ord_dense_order_dual = ord_dense_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ord_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_order_dual (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: ord_dense_order \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_dense_order (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", "using ord\\<^sub>b.dense"], ["proof (prove)\nusing this:\n  ?x <\\<^sub>b ?y \\<Longrightarrow>\n  \\<exists>z. ?x <\\<^sub>b z \\<and> z <\\<^sub>b ?y\n\ngoal (1 subgoal):\n 1. ord_dense_order (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", "by unfold_locales blast"], ["", "sublocale dual_ord: ord_dense_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_dense_order (\\<le>\\<^sub>b) (<\\<^sub>b)", "by (rule ord_dense_order_axioms)"], ["", "sublocale dual_dual: ord_dense_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_dense_order (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", "by (rule ord_dual.ord_dense_order_axioms)"], ["", "end"], ["", "locale preorder_dense_order = \n  ord_dense_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>a: preorder le\\<^sub>a ls\\<^sub>a\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "sublocale preorder_order"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b", ".."], ["", "end"], ["", "locale preorder_dense_order_dual = preorder_dense_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale ord_dense_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. ord_dense_order_dual (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale preorder_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_order_dual (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>b)\n     (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: preorder_dense_order \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dense_order (\\<le>\\<^sub>a) (<\\<^sub>a)\n     (\\<lambda>x y. y \\<le>\\<^sub>b x) (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "sublocale dual_ord: preorder_dense_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dense_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale dual_dual: preorder_dense_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dense_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "end"], ["", "locale order_dense_order = \n  preorder_dense_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>a: order le\\<^sub>a ls\\<^sub>a\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "sublocale order_pair"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b", ".."], ["", "end"], ["", "locale order_dense_order_dual = order_dense_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale preorder_dense_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dense_order_dual (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>b)\n     (<\\<^sub>b)", ".."], ["", "sublocale order_pair_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair_dual (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: order_dense_order \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dense_order (\\<le>\\<^sub>a) (<\\<^sub>a)\n     (\\<lambda>x y. y \\<le>\\<^sub>b x) (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "sublocale dual_ord: order_dense_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dense_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<le>\\<^sub>b) (<\\<^sub>b)", ".."], ["", "sublocale dual_dual: order_dense_order \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dense_order (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "end"], ["", "locale dense_order_pair = \n  order_dense_order le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b + ord\\<^sub>a: dense_order le\\<^sub>a ls\\<^sub>a\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["", "locale dense_order_pair_dual = dense_order_pair le\\<^sub>a ls\\<^sub>a le\\<^sub>b ls\\<^sub>b\n  for le\\<^sub>a ls\\<^sub>a :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and le\\<^sub>b ls\\<^sub>b :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\"\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "sublocale order_dense_order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dense_order_dual (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>b)\n     (<\\<^sub>b)", ".."], ["", "sublocale ord_dual: dense_order_pair \\<open>(\\<le>\\<^sub>a)\\<close> \\<open>(<\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_order_pair (\\<le>\\<^sub>a) (<\\<^sub>a)\n     (\\<lambda>x y. y \\<le>\\<^sub>b x) (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "sublocale dual_ord: dense_order_pair \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<le>\\<^sub>b)\\<close> \\<open>(<\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_order_pair (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<le>\\<^sub>b) (<\\<^sub>b)", "using ord\\<^sub>a.dense"], ["proof (prove)\nusing this:\n  ?x <\\<^sub>a ?y \\<Longrightarrow>\n  \\<exists>z. ?x <\\<^sub>a z \\<and> z <\\<^sub>a ?y\n\ngoal (1 subgoal):\n 1. dense_order_pair (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<le>\\<^sub>b) (<\\<^sub>b)", "by unfold_locales auto"], ["", "sublocale dual_dual: dense_order_pair \\<open>(\\<ge>\\<^sub>a)\\<close> \\<open>(>\\<^sub>a)\\<close> \\<open>(\\<ge>\\<^sub>b)\\<close> \\<open>(>\\<^sub>b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_order_pair (\\<lambda>x y. y \\<le>\\<^sub>a x)\n     (\\<lambda>x y. y <\\<^sub>a x) (\\<lambda>x y. y \\<le>\\<^sub>b x)\n     (\\<lambda>x y. y <\\<^sub>b x)", ".."], ["", "end"], ["", "subsection\\<open>(Unique) top and bottom elements\\<close>"], ["", "text\\<open>Abstract extremum.\\<close>"], ["", "locale extremum =\n  fixes extremum :: 'a"], ["", "locale ord_extremum = ord le ls + extremum extremum \n  for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and extremum :: 'a"], ["", "text\\<open>Concrete syntax.\\<close>"], ["", "locale bot = extremum bot for bot :: 'a\nbegin"], ["", "notation bot (\"\\<bottom>\")"], ["", "end"], ["", "locale top = extremum top for top :: 'a\nbegin"], ["", "notation top (\"\\<top>\")"], ["", "end"], ["", "subsection\\<open>(Unique) top and bottom elements for partial orders\\<close>"], ["", "subsubsection\\<open>Definitions\\<close>"], ["", "text\\<open>Abstract partial order with extremum.\\<close>"], ["", "locale order_extremum = ord_extremum le ls extremum + order le ls\n  for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  and extremum :: 'a  +\n  assumes extremum[simp]: \"le a extremum\""], ["", "text\\<open>Concrete syntax.\\<close>"], ["", "locale order_bot = \n  order_dual le ls + \n  dual: order_extremum \\<open>\\<lambda>x y. le y x\\<close> \\<open>\\<lambda>x y. ls y x\\<close> bot + \n  bot bot \n  for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and bot :: 'a"], ["", "locale order_top = order_dual le ls + order_extremum le ls top + top top\n  for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" and top :: 'a"], ["", "subsubsection\\<open>Results\\<close>"], ["", "context order_extremum\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma extremum_uniqueI: \n  assumes \"extremum \\<le>\\<^sub>a a\"\n  shows \"a = extremum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = extremum", "using assms"], ["proof (prove)\nusing this:\n  extremum \\<le>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. a = extremum", "by (simp add: antisym)"], ["", "lemma extremum_unique: \"extremum \\<le>\\<^sub>a a \\<longleftrightarrow> a = extremum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (extremum \\<le>\\<^sub>a a) = (a = extremum)", "by (auto intro: antisym)"], ["", "lemma extremum_strict[simp]: \"\\<not> (extremum <\\<^sub>a a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> extremum <\\<^sub>a a", "by (fastforce simp: less_le_not_le)"], ["", "lemma not_eq_extremum: \"a \\<noteq> extremum \\<longleftrightarrow> a <\\<^sub>a extremum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<noteq> extremum) = (a <\\<^sub>a extremum)", "using le_imp_less_or_eq"], ["proof (prove)\nusing this:\n  ?x \\<le>\\<^sub>a ?y \\<Longrightarrow> ?x <\\<^sub>a ?y \\<or> ?x = ?y\n\ngoal (1 subgoal):\n 1. (a \\<noteq> extremum) = (a <\\<^sub>a extremum)", "by (auto intro: extremum)"], ["", "end"], ["", "subsection\\<open>Partial orders without top or bottom elements\\<close>"], ["", "text\\<open>Abstract partial orders without top or bottom elements.\\<close>"], ["", "locale no_extremum = order le ls for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" +\n  assumes gt_ex: \"\\<exists>y. ls x y\""], ["", "text\\<open>Concrete syntax.\\<close>"], ["", "locale no_top = order_dual le ls + no_extremum le ls \n  for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\""], ["", "locale no_bot = \n  order_dual le ls + \n  dual: no_extremum \\<open>\\<lambda>x y. le y x\\<close> \\<open>\\<lambda>x y. ls y x\\<close> \n  for le ls :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\""], ["", "subsection\\<open>Least and greatest operators\\<close>"], ["", "definition Least :: \"['a set, ['a, 'a] \\<Rightarrow> bool, 'a \\<Rightarrow> bool] \\<Rightarrow> 'a option\" \n  (\\<open>(on _ with _ : \\<guillemotleft>Least\\<guillemotright> _)\\<close> [1000, 1000, 1000] 10) \n  where \n    \"on U with op : \\<guillemotleft>Least\\<guillemotright> P \\<equiv> (THE x on U. P x \\<and> (\\<forall>y\\<in>U. P y \\<longrightarrow> op x y))\""], ["", "ctr relativization\n  synthesis ctr_simps\n  assumes [transfer_domain_rule, transfer_rule]: \"Domainp A = (\\<lambda>x. x \\<in> U)\"\n    and [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  trp (?'a A)\n  in Least_def"], ["", "context ord_syntax\nbegin"], ["", "abbreviation Least where \"Least \\<equiv> Type_Simple_Orders.Least UNIV (\\<le>\\<^sub>a)\""], ["", "abbreviation Greatest where \"Greatest \\<equiv> Type_Simple_Orders.Least UNIV (\\<ge>\\<^sub>a)\""], ["", "lemmas Least_def = Least_def[of UNIV \\<open>(\\<le>\\<^sub>a)\\<close>]"], ["", "end"], ["", "context order\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Least_equality:\n  assumes \"P x\" and \"\\<And>y. P y \\<Longrightarrow> x \\<le>\\<^sub>a y\"\n  shows \"Least P = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Least P = Some x", "unfolding Least_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE x on UNIV.\n     P x \\<and>\n     (\\<forall>y\\<in>UNIV. P y \\<longrightarrow> x \\<le>\\<^sub>a y)) =\n    Some x", "by (rule The_on_Some_equality) (auto simp: assms antisym)"], ["", "lemma LeastI2_order:\n  assumes \"P x\" \n    and \"\\<And>y. P y \\<Longrightarrow> x \\<le>\\<^sub>a y\"\n    and \"\\<And>x. P x \\<Longrightarrow> \\<forall>y. P y \\<longrightarrow> x \\<le>\\<^sub>a y \\<Longrightarrow> Q x\"\n  obtains z where \"Least P = Some z\" and \"Q z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>local.Least P = Some z; Q z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Least_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(THE x on UNIV.\n                  P x \\<and>\n                  (\\<forall>y\\<in>UNIV.\n                      P y \\<longrightarrow> x \\<le>\\<^sub>a y)) =\n                 Some z;\n         Q z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  P x\n  P ?y \\<Longrightarrow> x \\<le>\\<^sub>a ?y\n  \\<lbrakk>P ?x;\n   \\<forall>y. P y \\<longrightarrow> ?x \\<le>\\<^sub>a y\\<rbrakk>\n  \\<Longrightarrow> Q ?x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(THE x on UNIV.\n                  P x \\<and>\n                  (\\<forall>y\\<in>UNIV.\n                      P y \\<longrightarrow> x \\<le>\\<^sub>a y)) =\n                 Some z;\n         Q z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: that Least_equality)"], ["", "lemma Least_ex1:\n  assumes \"\\<exists>!x. P x \\<and> (\\<forall>y. P y \\<longrightarrow> x \\<le>\\<^sub>a y)\"\n  obtains x where \"Least P = Some x\" and \"P x\" and \"P z \\<Longrightarrow> x \\<le>\\<^sub>a z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>local.Least P = Some x; P x;\n         P z \\<Longrightarrow> x \\<le>\\<^sub>a z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     P x \\<and> (\\<forall>y. P y \\<longrightarrow> x \\<le>\\<^sub>a y)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>local.Least P = Some x; P x;\n         P z \\<Longrightarrow> x \\<le>\\<^sub>a z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding Least_def"], ["proof (prove)\nusing this:\n  \\<exists>!x.\n     P x \\<and> (\\<forall>y. P y \\<longrightarrow> x \\<le>\\<^sub>a y)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>(THE x on UNIV.\n                  P x \\<and>\n                  (\\<forall>y\\<in>UNIV.\n                      P y \\<longrightarrow> x \\<le>\\<^sub>a y)) =\n                 Some x;\n         P x; P z \\<Longrightarrow> x \\<le>\\<^sub>a z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (clarsimp simp: that Least_equality)"], ["", "end"], ["", "subsection\\<open>min and max\\<close>"], ["", "definition min :: \"[['a, 'a] \\<Rightarrow> bool, 'a, 'a] \\<Rightarrow> 'a\" where\n  \"min le a b = (if le a b then a else b)\""], ["", "ctr parametricity\n  in min_def"], ["", "context ord_syntax\nbegin"], ["", "abbreviation min where \"min \\<equiv> Type_Simple_Orders.min (\\<le>\\<^sub>a)\""], ["", "abbreviation max where \"max \\<equiv> Type_Simple_Orders.min (\\<ge>\\<^sub>a)\""], ["", "end"], ["", "context ord\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma min_absorb1: \"x \\<le>\\<^sub>a y \\<Longrightarrow> min x y = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le>\\<^sub>a y \\<Longrightarrow> local.min x y = x", "unfolding min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le>\\<^sub>a y \\<Longrightarrow>\n    (if x \\<le>\\<^sub>a y then x else y) = x", "by simp"], ["", "end"], ["", "context order\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma min_absorb2: \n  assumes \"y \\<le>\\<^sub>a x\"\n  shows \"min x y = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min x y = y", "using assms"], ["proof (prove)\nusing this:\n  y \\<le>\\<^sub>a x\n\ngoal (1 subgoal):\n 1. local.min x y = y", "unfolding min_def"], ["proof (prove)\nusing this:\n  y \\<le>\\<^sub>a x\n\ngoal (1 subgoal):\n 1. (if x \\<le>\\<^sub>a y then x else y) = y", "by (simp add: eq_iff)"], ["", "end"], ["", "context order_extremum\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma max_top[simp]: \"max extremum x = extremum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.max extremum x = extremum", "by (simp add: ord.min_absorb1)"], ["", "lemma max_top2[simp]: \"max x extremum = extremum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.max x extremum = extremum", "unfolding min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if extremum \\<le>\\<^sub>a x then x else extremum) = extremum", "by (simp add: extremum_uniqueI)"], ["", "lemma min_top[simp]: \"min extremum x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min extremum x = x", "by (simp add: min_absorb2)"], ["", "lemma min_top2[simp]: \"min x extremum = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.min x extremum = x", "by (simp add: min_def top_unique)"], ["", "end"], ["", "subsection\\<open>Monotonicity\\<close>"], ["", "definition mono :: \n  \"['a set, ['a, 'a] \\<Rightarrow> bool, ['b, 'b] \\<Rightarrow> bool, 'a \\<Rightarrow> 'b] \\<Rightarrow> bool\" \n  (\\<open>(on _ with _ _ : \\<guillemotleft>mono\\<guillemotright> _)\\<close> [1000, 1000, 999, 1000] 10) \n  where\n    \"on U\\<^sub>a with op\\<^sub>1 op\\<^sub>2 : \\<guillemotleft>mono\\<guillemotright> f \\<equiv> \\<forall>x\\<in>U\\<^sub>a. \\<forall>y\\<in>U\\<^sub>a. op\\<^sub>1 x y \\<longrightarrow> op\\<^sub>2 (f x) (f y)\""], ["", "ctr parametricity\n  in mono_def"], ["", "context ord_pair_syntax\nbegin"], ["", "abbreviation mono\\<^sub>a\\<^sub>b \n  where \"mono\\<^sub>a\\<^sub>b \\<equiv> Type_Simple_Orders.mono UNIV (\\<le>\\<^sub>a) (\\<le>\\<^sub>b)\""], ["", "abbreviation mono\\<^sub>b\\<^sub>a \n  where \"mono\\<^sub>b\\<^sub>a \\<equiv> Type_Simple_Orders.mono UNIV (\\<le>\\<^sub>b) (\\<le>\\<^sub>a)\""], ["", "abbreviation antimono\\<^sub>a\\<^sub>b \n  where \"antimono\\<^sub>a\\<^sub>b \\<equiv> Type_Simple_Orders.mono UNIV (\\<le>\\<^sub>a) (\\<ge>\\<^sub>b)\""], ["", "abbreviation antimono\\<^sub>b\\<^sub>a \n  where \"antimono\\<^sub>b\\<^sub>a \\<equiv> Type_Simple_Orders.mono UNIV (\\<le>\\<^sub>b) (\\<ge>\\<^sub>a)\""], ["", "abbreviation strict_mono\\<^sub>a\\<^sub>b \n  where \"strict_mono\\<^sub>a\\<^sub>b \\<equiv> Type_Simple_Orders.mono UNIV (<\\<^sub>a) (<\\<^sub>b)\""], ["", "abbreviation strict_mono\\<^sub>b\\<^sub>a \n  where \"strict_mono\\<^sub>b\\<^sub>a \\<equiv> Type_Simple_Orders.mono UNIV (<\\<^sub>b) (<\\<^sub>a)\""], ["", "abbreviation strict_antimono\\<^sub>a\\<^sub>b \n  where \"strict_antimono\\<^sub>a\\<^sub>b \\<equiv> Type_Simple_Orders.mono UNIV (<\\<^sub>a) (>\\<^sub>b)\""], ["", "abbreviation strict_antimono\\<^sub>b\\<^sub>a \n  where \"strict_antimono\\<^sub>b\\<^sub>a \\<equiv> Type_Simple_Orders.mono UNIV (<\\<^sub>b) (>\\<^sub>a)\""], ["", "end"], ["", "context ord_pair\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma monoI[intro?]: \n  assumes \"\\<And>x y. x \\<le>\\<^sub>a y \\<Longrightarrow> f x \\<le>\\<^sub>b f y\" \n  shows \"mono\\<^sub>a\\<^sub>b f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\\<^sub>a\\<^sub>b f", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          x \\<le>\\<^sub>a y \\<longrightarrow> f x \\<le>\\<^sub>b f y", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<le>\\<^sub>a ?y \\<Longrightarrow> f ?x \\<le>\\<^sub>b f ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          x \\<le>\\<^sub>a y \\<longrightarrow> f x \\<le>\\<^sub>b f y", "by simp"], ["", "lemma monoD[dest?]:\n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"x \\<le>\\<^sub>a y\" \n  shows \"f x \\<le>\\<^sub>b f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>b f y", "using assms"], ["proof (prove)\nusing this:\n  mono\\<^sub>a\\<^sub>b f\n  x \\<le>\\<^sub>a y\n\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>b f y", "unfolding mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        x \\<le>\\<^sub>a y \\<longrightarrow> f x \\<le>\\<^sub>b f y\n  x \\<le>\\<^sub>a y\n\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>b f y", "by simp"], ["", "lemma monoE:\n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"x \\<le>\\<^sub>a y\"\n  obtains \"f x \\<le>\\<^sub>b f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x \\<le>\\<^sub>b f y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  mono\\<^sub>a\\<^sub>b f\n  x \\<le>\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (f x \\<le>\\<^sub>b f y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        x \\<le>\\<^sub>a y \\<longrightarrow> f x \\<le>\\<^sub>b f y\n  x \\<le>\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (f x \\<le>\\<^sub>b f y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["", "lemma strict_monoI[intro?]: \n  assumes \"\\<And>x y. x <\\<^sub>a y \\<Longrightarrow> f x <\\<^sub>b f y\" \n  shows \"strict_mono\\<^sub>a\\<^sub>b f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono\\<^sub>a\\<^sub>b f", "unfolding mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          x <\\<^sub>a y \\<longrightarrow> f x <\\<^sub>b f y", "using assms"], ["proof (prove)\nusing this:\n  ?x <\\<^sub>a ?y \\<Longrightarrow> f ?x <\\<^sub>b f ?y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          x <\\<^sub>a y \\<longrightarrow> f x <\\<^sub>b f y", "by simp"], ["", "lemma strict_monoD[dest?]:\n  assumes \"strict_mono\\<^sub>a\\<^sub>b f\" and \"x <\\<^sub>a y\" \n  shows \"f x <\\<^sub>b f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x <\\<^sub>b f y", "using assms"], ["proof (prove)\nusing this:\n  strict_mono\\<^sub>a\\<^sub>b f\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. f x <\\<^sub>b f y", "unfolding mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. x <\\<^sub>a y \\<longrightarrow> f x <\\<^sub>b f y\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. f x <\\<^sub>b f y", "by simp"], ["", "lemma strict_monoE:\n  assumes \"strict_mono\\<^sub>a\\<^sub>b f\" and \"x <\\<^sub>a y\"\n  obtains \"f x <\\<^sub>b f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f x <\\<^sub>b f y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  strict_mono\\<^sub>a\\<^sub>b f\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (f x <\\<^sub>b f y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding mono_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV. x <\\<^sub>a y \\<longrightarrow> f x <\\<^sub>b f y\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (f x <\\<^sub>b f y \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["", "end"], ["", "context order_pair\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma strict_mono_mono[dest?]: \n  assumes \"strict_mono\\<^sub>a\\<^sub>b f\"\n  shows \"mono\\<^sub>a\\<^sub>b f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono\\<^sub>a\\<^sub>b f", "proof(rule monoI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le>\\<^sub>a y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le>\\<^sub>a y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "assume \"x \\<le>\\<^sub>a y\""], ["proof (state)\nthis:\n  x \\<le>\\<^sub>a y\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le>\\<^sub>a y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "show \"f x \\<le>\\<^sub>b f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>b f y", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> f x \\<le>\\<^sub>b f y\n 2. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> f x \\<le>\\<^sub>b f y\n 2. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "then"], ["proof (chain)\npicking this:\n  x = y", "show ?thesis"], ["proof (prove)\nusing this:\n  x = y\n\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>b f y", "by simp"], ["proof (state)\nthis:\n  f x \\<le>\\<^sub>b f y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "with \\<open>x \\<le>\\<^sub>a y\\<close>"], ["proof (chain)\npicking this:\n  x \\<le>\\<^sub>a y\n  x \\<noteq> y", "have \"x <\\<^sub>a y\""], ["proof (prove)\nusing this:\n  x \\<le>\\<^sub>a y\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x <\\<^sub>a y", "by (simp add: ord\\<^sub>a.neq_le_trans)"], ["proof (state)\nthis:\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "with assms strict_monoD"], ["proof (chain)\npicking this:\n  strict_mono\\<^sub>a\\<^sub>b f\n  \\<lbrakk>strict_mono\\<^sub>a\\<^sub>b ?f; ?x <\\<^sub>a ?y\\<rbrakk>\n  \\<Longrightarrow> ?f ?x <\\<^sub>b ?f ?y\n  x <\\<^sub>a y", "have \"f x <\\<^sub>b f y\""], ["proof (prove)\nusing this:\n  strict_mono\\<^sub>a\\<^sub>b f\n  \\<lbrakk>strict_mono\\<^sub>a\\<^sub>b ?f; ?x <\\<^sub>a ?y\\<rbrakk>\n  \\<Longrightarrow> ?f ?x <\\<^sub>b ?f ?y\n  x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. f x <\\<^sub>b f y", "by simp"], ["proof (state)\nthis:\n  f x <\\<^sub>b f y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> f x \\<le>\\<^sub>b f y", "then"], ["proof (chain)\npicking this:\n  f x <\\<^sub>b f y", "show ?thesis"], ["proof (prove)\nusing this:\n  f x <\\<^sub>b f y\n\ngoal (1 subgoal):\n 1. f x \\<le>\\<^sub>b f y", "by (simp add: ord\\<^sub>b.le_less)"], ["proof (state)\nthis:\n  f x \\<le>\\<^sub>b f y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f x \\<le>\\<^sub>b f y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Set intervals\\<close>"], ["", "definition ray :: \"['a set, ['a, 'a] \\<Rightarrow> bool, 'a] \\<Rightarrow> 'a set\" \n  (\\<open>(on _ with _ : {..\\<sqsubset>_})\\<close> [1000, 1000, 1000] 10) \n  where \"on U with op : {..\\<sqsubset>u} \\<equiv> {x \\<in> U. op x u}\""], ["", "definition interval :: \n  \"['a set, ['a, 'a] \\<Rightarrow> bool, ['a, 'a] \\<Rightarrow> bool, 'a, 'a] \\<Rightarrow> 'a set\"\n  (\\<open>(on _ with _ _ : {_\\<sqsubset>..\\<sqsubset>_})\\<close> [1000, 1000, 999, 1000, 1000] 10) \n  where \"on U with op\\<^sub>1 op\\<^sub>2 : {l\\<sqsubset>..\\<sqsubset>u} \\<equiv> \n    (on U with (\\<lambda>x y. op\\<^sub>1 y x) : {..\\<sqsubset>l}) \\<inter> (on U with op\\<^sub>2 : {..\\<sqsubset>u})\""], ["", "lemma ray_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\"\n  shows \"(rel_set A ===> (A ===> A ===> (=)) ===> A ===> rel_set A) ray ray\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> A ===> (=)) ===> A ===> rel_set A) ray ray", "unfolding ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set A ===> (A ===> A ===> (=)) ===> A ===> rel_set A)\n     (\\<lambda>U op u. {x \\<in> U. op x u})\n     (\\<lambda>U op u. {x \\<in> U. op x u})", "proof(intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set A x y; (A ===> A ===> (=)) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A {xc \\<in> x. xa xc xb}\n                          {x \\<in> y. ya x yb}", "fix S :: \"'a set\" and S' :: \"'b set\" \n    and le :: \"['a, 'a] \\<Rightarrow> bool\" and le' :: \"['b, 'b] \\<Rightarrow> bool\" \n    and u u'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set A x y; (A ===> A ===> (=)) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A {xc \\<in> x. xa xc xb}\n                          {x \\<in> y. ya x yb}", "assume [transfer_rule]: \"rel_set A S S'\"\n    and [transfer_rule]: \"(A ===> A ===> (=)) le le'\"\n    and [transfer_rule]: \"A u u'\""], ["proof (state)\nthis:\n  rel_set A S S'\n  (A ===> A ===> (=)) le le'\n  A u u'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set A x y; (A ===> A ===> (=)) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A {xc \\<in> x. xa xc xb}\n                          {x \\<in> y. ya x yb}", "show \"rel_set A {xc \\<in> S. le xc u} {x \\<in> S'. le' x u'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set A {xc \\<in> S. le xc u} {x \\<in> S'. le' x u'}", "proof(intro rel_setI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n       \\<exists>y\\<in>{x \\<in> S'. le' x u'}. A x y\n 2. \\<And>y.\n       y \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n       \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x y", "show \"x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow> \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'", "assume x: \"x \\<in> {xc \\<in> S. le xc u}\""], ["proof (state)\nthis:\n  x \\<in> {xc \\<in> S. le xc u}\n\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'", "then"], ["proof (chain)\npicking this:\n  x \\<in> {xc \\<in> S. le xc u}", "obtain x' where [transfer_rule]: \"A x x'\""], ["proof (prove)\nusing this:\n  x \\<in> {xc \\<in> S. le xc u}\n\ngoal (1 subgoal):\n 1. (\\<And>x'. A x x' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>rel_set A S S'\\<close> rel_setD1"], ["proof (prove)\nusing this:\n  x \\<in> {xc \\<in> S. le xc u}\n  rel_set A S S'\n  \\<lbrakk>rel_set ?R ?A ?B; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y\\<in>?B. ?R ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>x'. A x x' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  A x x'\n\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'", "from x"], ["proof (chain)\npicking this:\n  x \\<in> {xc \\<in> S. le xc u}", "have \"x' \\<in> {x \\<in> S'. le' x u'}\""], ["proof (prove)\nusing this:\n  x \\<in> {xc \\<in> S. le xc u}\n\ngoal (1 subgoal):\n 1. x' \\<in> {x \\<in> S'. le' x u'}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    x \\<in> {x. (x \\<in> S \\<and> le x u) \\<and> Domainp A x}", "using \\<open>A x x'\\<close>"], ["proof (prove)\nusing this:\n  A x x'\n\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    x \\<in> {x. (x \\<in> S \\<and> le x u) \\<and> Domainp A x}", "by auto"], ["proof (state)\nthis:\n  x' \\<in> {x \\<in> S'. le' x u'}\n\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n    \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'", "then"], ["proof (chain)\npicking this:\n  x' \\<in> {x \\<in> S'. le' x u'}", "show ?thesis"], ["proof (prove)\nusing this:\n  x' \\<in> {x \\<in> S'. le' x u'}\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'", "by (auto simp: \\<open>A x x'\\<close>)"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A x x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> {xc \\<in> S. le xc u} \\<Longrightarrow>\n  \\<exists>x'\\<in>{x \\<in> S'. le' x u'}. A ?x x'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n       \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x y", "show \"x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow> \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'\" for x'"], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n    \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n    \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'", "assume x': \"x' \\<in> {x \\<in> S'. le' x u'}\""], ["proof (state)\nthis:\n  x' \\<in> {x \\<in> S'. le' x u'}\n\ngoal (1 subgoal):\n 1. x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n    \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'", "then"], ["proof (chain)\npicking this:\n  x' \\<in> {x \\<in> S'. le' x u'}", "obtain x where [transfer_rule]: \"A x x'\""], ["proof (prove)\nusing this:\n  x' \\<in> {x \\<in> S'. le' x u'}\n\ngoal (1 subgoal):\n 1. (\\<And>x. A x x' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  x' \\<in> {x \\<in> S'. le' x u'}\n  right_total A\n\ngoal (1 subgoal):\n 1. (\\<And>x. A x x' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto elim: right_totalE)"], ["proof (state)\nthis:\n  A x x'\n\ngoal (1 subgoal):\n 1. x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n    \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'", "from x'"], ["proof (chain)\npicking this:\n  x' \\<in> {x \\<in> S'. le' x u'}", "have \"x \\<in> {xc \\<in> S. le xc u}\""], ["proof (prove)\nusing this:\n  x' \\<in> {x \\<in> S'. le' x u'}\n\ngoal (1 subgoal):\n 1. x \\<in> {xc \\<in> S. le xc u}", "by transfer auto"], ["proof (state)\nthis:\n  x \\<in> {xc \\<in> S. le xc u}\n\ngoal (1 subgoal):\n 1. x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n    \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'", "then"], ["proof (chain)\npicking this:\n  x \\<in> {xc \\<in> S. le xc u}", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {xc \\<in> S. le xc u}\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'", "by (auto simp: \\<open>A x x'\\<close>)"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x' \\<in> {x \\<in> S'. le' x u'} \\<Longrightarrow>\n  \\<exists>x\\<in>{xc \\<in> S. le xc u}. A x ?x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_set A {xc \\<in> S. le xc u} {x \\<in> S'. le' x u'}\n\ngoal:\nNo subgoals!", "qed"], ["", "ctr relativization\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  trp (?'a A)\n  in interval_def"], ["", "lemma interval_ge_le:\n  \"(on UNIV with (\\<lambda>x y. le\\<^sub>a y x) (\\<lambda>x y. le\\<^sub>b y x) : {l\\<sqsubset>..\\<sqsubset>h}) = \n    (on UNIV with le\\<^sub>b le\\<^sub>a : {h\\<sqsubset>..\\<sqsubset>l})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (on UNIV with (\\<lambda>x y.\n                      le\\<^sub>a y\n                       x) (\\<lambda>x y.\n                              le\\<^sub>b y\n                               x) : {l\\<sqsubset>..\\<sqsubset>h}) =\n    (on UNIV with le\\<^sub>b le\\<^sub>a : {h\\<sqsubset>..\\<sqsubset>l})", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (on UNIV with le\\<^sub>a : {..\\<sqsubset>l}) \\<inter>\n    (on UNIV with (\\<lambda>x y. le\\<^sub>b y x) : {..\\<sqsubset>h}) =\n    (on UNIV with (\\<lambda>x y.\n                      le\\<^sub>b y x) : {..\\<sqsubset>h}) \\<inter>\n    (on UNIV with le\\<^sub>a : {..\\<sqsubset>l})", "by auto"], ["", "context ord_syntax  \nbegin"], ["", "abbreviation lessThan (\\<open>{..<\\<^sub>a_}\\<close>) \n  where \"{..<\\<^sub>au} \\<equiv> on UNIV with (<\\<^sub>a) : {..\\<sqsubset>u}\""], ["", "abbreviation atMost (\\<open>{..\\<le>\\<^sub>a_}\\<close>) \n  where \"{..\\<le>\\<^sub>au} \\<equiv> on UNIV with (\\<le>\\<^sub>a) : {..\\<sqsubset>u}\""], ["", "abbreviation greaterThan (\\<open>{_<\\<^sub>a..}\\<close>) \n  where \"{l<\\<^sub>a..} \\<equiv> on UNIV with (>\\<^sub>a) : {..\\<sqsubset>l}\""], ["", "abbreviation atLeast (\\<open>{_\\<le>\\<^sub>a..}\\<close>) \n  where \"{l\\<le>\\<^sub>a..} \\<equiv> on UNIV with (\\<ge>\\<^sub>a) : {..\\<sqsubset>l}\""], ["", "abbreviation greaterThanLessThan (\\<open>{_<\\<^sub>a..<\\<^sub>a_}\\<close>) \n  where \"{l<\\<^sub>a..<\\<^sub>au} \\<equiv> on UNIV with (<\\<^sub>a) (<\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation atLeastLessThan (\\<open>{_\\<le>\\<^sub>a..<\\<^sub>a_}\\<close>) \n  where \"{l\\<le>\\<^sub>a..<\\<^sub>au} \\<equiv> on UNIV with (\\<le>\\<^sub>a) (<\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation greaterThanAtMost (\\<open>{_<\\<^sub>a..\\<le>\\<^sub>a_}\\<close>) \n  where \"{l<\\<^sub>a..\\<le>\\<^sub>au} \\<equiv> on UNIV with (<\\<^sub>a) (\\<le>\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation atLeastAtMost (\\<open>{_\\<le>\\<^sub>a..\\<le>\\<^sub>a_}\\<close>) \n  where \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>au} \\<equiv> on UNIV with (\\<le>\\<^sub>a) (\\<le>\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation lessThanGreaterThan (\\<open>{_>\\<^sub>a..>\\<^sub>a_}\\<close>) \n  where \"{l>\\<^sub>a..>\\<^sub>au} \\<equiv> on UNIV with (>\\<^sub>a) (>\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation lessThanAtLeast (\\<open>{_\\<ge>\\<^sub>a..>\\<^sub>a_}\\<close>) \n  where \"{l\\<ge>\\<^sub>a..>\\<^sub>au} \\<equiv> on UNIV with (\\<ge>\\<^sub>a) (>\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation atMostGreaterThan (\\<open>{_>\\<^sub>a..\\<ge>\\<^sub>a_}\\<close>) \n  where \"{l>\\<^sub>a..\\<ge>\\<^sub>au} \\<equiv> on UNIV with (>\\<^sub>a) (\\<ge>\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "abbreviation atMostAtLeast (\\<open>{_\\<ge>\\<^sub>a..\\<ge>\\<^sub>a_}\\<close>) \n  where \"{l\\<ge>\\<^sub>a..\\<ge>\\<^sub>au} \\<equiv> on UNIV with (\\<ge>\\<^sub>a) (\\<ge>\\<^sub>a) : {l\\<sqsubset>..\\<sqsubset>u}\""], ["", "end"], ["", "context ord\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lessThan_iff[iff]: \"(i \\<in> {..<\\<^sub>ak}) = (i <\\<^sub>a k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {..<\\<^sub>ak}) = (i <\\<^sub>a k)", "unfolding ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {x \\<in> UNIV. x <\\<^sub>a k}) = (i <\\<^sub>a k)", "by simp"], ["", "lemma atLeast_iff[iff]: \"(i \\<in> {k\\<le>\\<^sub>a..}) = (k \\<le>\\<^sub>a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {k\\<le>\\<^sub>a..}) = (k \\<le>\\<^sub>a i)", "unfolding ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {x \\<in> UNIV. k \\<le>\\<^sub>a x}) = (k \\<le>\\<^sub>a i)", "by simp"], ["", "lemma greaterThanLessThan_iff[simp]: \"(i \\<in> {l<\\<^sub>a..<\\<^sub>au}) = (l <\\<^sub>a i \\<and> i <\\<^sub>a u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {l<\\<^sub>a..<\\<^sub>au}) =\n    (l <\\<^sub>a i \\<and> i <\\<^sub>a u)", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {x \\<in> UNIV. l <\\<^sub>a x} \\<inter>\n             {x \\<in> UNIV. x <\\<^sub>a u}) =\n    (l <\\<^sub>a i \\<and> i <\\<^sub>a u)", "by simp"], ["", "lemma atLeastLessThan_iff[simp]: \"(i \\<in> {l\\<le>\\<^sub>a..<\\<^sub>au}) = (l \\<le>\\<^sub>a i \\<and> i <\\<^sub>a u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {l\\<le>\\<^sub>a..<\\<^sub>au}) =\n    (l \\<le>\\<^sub>a i \\<and> i <\\<^sub>a u)", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {x \\<in> UNIV. l \\<le>\\<^sub>a x} \\<inter>\n             {x \\<in> UNIV. x <\\<^sub>a u}) =\n    (l \\<le>\\<^sub>a i \\<and> i <\\<^sub>a u)", "by simp"], ["", "lemma greaterThanAtMost_iff[simp]: \"(i \\<in> {l<\\<^sub>a..\\<le>\\<^sub>au}) = (l <\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {l<\\<^sub>a..\\<le>\\<^sub>au}) =\n    (l <\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {x \\<in> UNIV. l <\\<^sub>a x} \\<inter>\n             {x \\<in> UNIV. x \\<le>\\<^sub>a u}) =\n    (l <\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)", "by simp"], ["", "lemma atLeastAtMost_iff[simp]: \"(i \\<in> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au}) = (l \\<le>\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au}) =\n    (l \\<le>\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<in> {x \\<in> UNIV. l \\<le>\\<^sub>a x} \\<inter>\n             {x \\<in> UNIV. x \\<le>\\<^sub>a u}) =\n    (l \\<le>\\<^sub>a i \\<and> i \\<le>\\<^sub>a u)", "by simp"], ["", "lemma greaterThanLessThan_eq: \"{a<\\<^sub>a..<\\<^sub>ab} = {a<\\<^sub>a..} \\<inter> {..<\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a<\\<^sub>a..<\\<^sub>ab} = {a<\\<^sub>a..} \\<inter> {..<\\<^sub>ab}", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> UNIV. a <\\<^sub>a x} \\<inter> {x \\<in> UNIV. x <\\<^sub>a b} =\n    {x \\<in> UNIV. a <\\<^sub>a x} \\<inter> {x \\<in> UNIV. x <\\<^sub>a b}", "by simp"], ["", "end"], ["", "context ord_pair_syntax\nbegin"], ["", "notation ord\\<^sub>a.lessThan (\\<open>{..<\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.atMost (\\<open>{..\\<le>\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.greaterThan (\\<open>{_<\\<^sub>a..}\\<close>) \n  and ord\\<^sub>a.atLeast (\\<open>{_\\<le>\\<^sub>a..}\\<close>) \n  and ord\\<^sub>a.greaterThanLessThan (\\<open>{_<\\<^sub>a..<\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.atLeastLessThan (\\<open>{_\\<le>\\<^sub>a..<\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.greaterThanAtMost (\\<open>{_<\\<^sub>a..\\<le>\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.atLeastAtMost (\\<open>{_\\<le>\\<^sub>a..\\<le>\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.lessThanGreaterThan (\\<open>{_>\\<^sub>a..>\\<^sub>a_}\\<close>)\n  and ord\\<^sub>a.lessThanAtLeast (\\<open>{_\\<ge>\\<^sub>a..>\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.atMostGreaterThan (\\<open>{_>\\<^sub>a..\\<ge>\\<^sub>a_}\\<close>) \n  and ord\\<^sub>a.atMostAtLeast (\\<open>{_\\<ge>\\<^sub>a..\\<ge>\\<^sub>a_}\\<close>) \n  and ord\\<^sub>b.lessThan (\\<open>{..<\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.atMost (\\<open>{..\\<le>\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.greaterThan (\\<open>{_<\\<^sub>b..}\\<close>) \n  and ord\\<^sub>b.atLeast (\\<open>{_\\<le>\\<^sub>b..}\\<close>) \n  and ord\\<^sub>b.greaterThanLessThan (\\<open>{_<\\<^sub>b..<\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.atLeastLessThan (\\<open>{_\\<le>\\<^sub>b..<\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.greaterThanAtMost (\\<open>{_<\\<^sub>b..\\<le>\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.atLeastAtMost (\\<open>{_\\<le>\\<^sub>b..\\<le>\\<^sub>b_}\\<close>)\n  and ord\\<^sub>b.lessThanGreaterThan (\\<open>{_>\\<^sub>b..>\\<^sub>b_}\\<close>)\n  and ord\\<^sub>b.lessThanAtLeast (\\<open>{_\\<ge>\\<^sub>b..>\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.atMostGreaterThan (\\<open>{_>\\<^sub>b..\\<ge>\\<^sub>b_}\\<close>) \n  and ord\\<^sub>b.atMostAtLeast (\\<open>{_\\<ge>\\<^sub>b..\\<ge>\\<^sub>b_}\\<close>)"], ["", "end"], ["", "context preorder\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma Ioi_le_Ico: \"{a<\\<^sub>a..} \\<subseteq> {a\\<le>\\<^sub>a..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a<\\<^sub>a..} \\<subseteq> {a\\<le>\\<^sub>a..}", "unfolding ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> UNIV. a <\\<^sub>a x}\n    \\<subseteq> {x \\<in> UNIV. a \\<le>\\<^sub>a x}", "by (fastforce simp: less_le_not_le)"], ["", "end"], ["", "context preorder\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation preorder_dual le ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", "by (rule preorder_dual.intro[OF preorder_axioms])"], ["", "lemma single_Diff_lessThan[simp]: \"{k} - {..<\\<^sub>ak} = {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k} - {..<\\<^sub>ak} = {k}", "by auto"], ["", "lemma atLeast_subset_iff[iff]: \"({x\\<le>\\<^sub>a..} \\<subseteq> {y\\<le>\\<^sub>a..}) = (y \\<le>\\<^sub>a x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x\\<le>\\<^sub>a..} \\<subseteq> {y\\<le>\\<^sub>a..}) =\n    (y \\<le>\\<^sub>a x)", "by (auto intro: order_trans)"], ["", "lemma atLeastatMost_empty[simp]: \n  assumes \"b <\\<^sub>a a\"\n  shows \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {}", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..} \\<inter> {..\\<le>\\<^sub>ab} = {}", "using less_le_not_le assms"], ["proof (prove)\nusing this:\n  (?x <\\<^sub>a ?y) =\n  (?x \\<le>\\<^sub>a ?y \\<and> \\<not> ?y \\<le>\\<^sub>a ?x)\n  b <\\<^sub>a a\n\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..} \\<inter> {..\\<le>\\<^sub>ab} = {}", "by (metis Int_emptyI ord.lessThan_iff atLeast_iff order_trans)"], ["", "lemma atLeastatMost_empty_iff[simp]: \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {} \\<longleftrightarrow> (\\<not> a \\<le>\\<^sub>a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {}) = (\\<not> a \\<le>\\<^sub>a b)", "by auto (blast intro: order_trans)"], ["", "lemma atLeastatMost_empty_iff2[simp]: \"{} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} \\<longleftrightarrow> (\\<not> a \\<le>\\<^sub>a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}) = (\\<not> a \\<le>\\<^sub>a b)", "by auto (blast intro: order_trans)"], ["", "lemma atLeastLessThan_empty[simp]: \n  assumes \"b \\<le>\\<^sub>a a\" \n  shows \"{a\\<le>\\<^sub>a..<\\<^sub>ab} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..<\\<^sub>ab} = {}", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..} \\<inter> {..<\\<^sub>ab} = {}", "using assms less_le_not_le"], ["proof (prove)\nusing this:\n  b \\<le>\\<^sub>a a\n  (?x <\\<^sub>a ?y) =\n  (?x \\<le>\\<^sub>a ?y \\<and> \\<not> ?y \\<le>\\<^sub>a ?x)\n\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..} \\<inter> {..<\\<^sub>ab} = {}", "by (blast intro: order_trans)"], ["", "lemma atLeastLessThan_empty_iff[simp]: \"{a\\<le>\\<^sub>a..<\\<^sub>ab} = {} \\<longleftrightarrow> (\\<not> a <\\<^sub>a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a\\<le>\\<^sub>a..<\\<^sub>ab} = {}) = (\\<not> a <\\<^sub>a b)", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a\\<le>\\<^sub>a..} \\<inter> {..<\\<^sub>ab} = {}) =\n    (\\<not> a <\\<^sub>a b)", "by (auto simp: le_less_trans ord.lessThan_iff)"], ["", "lemma atLeastLessThan_empty_iff2[simp]: \"{} = {a\\<le>\\<^sub>a..<\\<^sub>ab} \\<longleftrightarrow> (\\<not> a <\\<^sub>a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} = {a\\<le>\\<^sub>a..<\\<^sub>ab}) = (\\<not> a <\\<^sub>a b)", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} = {a\\<le>\\<^sub>a..} \\<inter> {..<\\<^sub>ab}) =\n    (\\<not> a <\\<^sub>a b)", "by (auto simp: le_less_trans ord.lessThan_iff)"], ["", "lemma greaterThanAtMost_empty[simp]: \n  assumes \"l \\<le>\\<^sub>a k\" \n  shows \"{k<\\<^sub>a..\\<le>\\<^sub>al} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k<\\<^sub>a..\\<le>\\<^sub>al} = {}", "using assms atLeastLessThan_empty[OF assms]"], ["proof (prove)\nusing this:\n  l \\<le>\\<^sub>a k\n  {k\\<le>\\<^sub>a..<\\<^sub>al} = {}\n\ngoal (1 subgoal):\n 1. {k<\\<^sub>a..\\<le>\\<^sub>al} = {}", "unfolding \n    greaterThanAtMost_eq_atLeastAtMost_diff \n    atLeastLessThan_eq_atLeastAtMost_diff"], ["proof (prove)\nusing this:\n  l \\<le>\\<^sub>a k\n  {k\\<le>\\<^sub>a..<\\<^sub>al} = {}\n\ngoal (1 subgoal):\n 1. {k<\\<^sub>a..\\<le>\\<^sub>al} = {}", "using le_less_trans"], ["proof (prove)\nusing this:\n  l \\<le>\\<^sub>a k\n  {k\\<le>\\<^sub>a..<\\<^sub>al} = {}\n  \\<lbrakk>?x \\<le>\\<^sub>a ?y; ?y <\\<^sub>a ?z\\<rbrakk>\n  \\<Longrightarrow> ?x <\\<^sub>a ?z\n\ngoal (1 subgoal):\n 1. {k<\\<^sub>a..\\<le>\\<^sub>al} = {}", "by auto blast"], ["", "lemma greaterThanAtMost_empty_iff[simp]: \"{k<\\<^sub>a..\\<le>\\<^sub>al} = {} \\<longleftrightarrow> \\<not> k <\\<^sub>a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({k<\\<^sub>a..\\<le>\\<^sub>al} = {}) = (\\<not> k <\\<^sub>a l)", "by (auto simp: dual.le_less_trans)"], ["", "lemma greaterThanAtMost_empty_iff2[simp]: \"{} = {k<\\<^sub>a..\\<le>\\<^sub>al} \\<longleftrightarrow> \\<not> k <\\<^sub>a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} = {k<\\<^sub>a..\\<le>\\<^sub>al}) = (\\<not> k <\\<^sub>a l)", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({} =\n     {x \\<in> UNIV. k <\\<^sub>a x} \\<inter>\n     {x \\<in> UNIV. x \\<le>\\<^sub>a l}) =\n    (\\<not> k <\\<^sub>a l)", "by (blast intro: less_le_trans)"], ["", "lemma greaterThanLessThan_empty[simp]: \n  assumes \"l \\<le>\\<^sub>a k\" \n  shows \"{k<\\<^sub>a..<\\<^sub>al} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {k<\\<^sub>a..<\\<^sub>al} = {}", "using assms"], ["proof (prove)\nusing this:\n  l \\<le>\\<^sub>a k\n\ngoal (1 subgoal):\n 1. {k<\\<^sub>a..<\\<^sub>al} = {}", "by auto (blast intro: le_less_trans asym equals0I)"], ["", "lemma atLeastatMost_subset_iff[simp]:\n  \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} \\<le> {c\\<le>\\<^sub>a..\\<le>\\<^sub>ad} \\<longleftrightarrow> (\\<not> a \\<le>\\<^sub>a b) \\<or> c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}\n     \\<subseteq> {c\\<le>\\<^sub>a..\\<le>\\<^sub>ad}) =\n    (\\<not> a \\<le>\\<^sub>a b \\<or>\n     c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a d)", "by auto (blast intro: order_trans)+"], ["", "lemma atLeastatMost_psubset_iff:\n  \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} < {c\\<le>\\<^sub>a..\\<le>\\<^sub>ad} \\<longleftrightarrow>\n    ((\\<not> a \\<le>\\<^sub>a b) \\<or> c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a d \\<and> (c <\\<^sub>a a \\<or> b <\\<^sub>a d)) \\<and> c \\<le>\\<^sub>a d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}\n     \\<subset> {c\\<le>\\<^sub>a..\\<le>\\<^sub>ad}) =\n    ((\\<not> a \\<le>\\<^sub>a b \\<or>\n      c \\<le>\\<^sub>a a \\<and>\n      b \\<le>\\<^sub>a d \\<and> (c <\\<^sub>a a \\<or> b <\\<^sub>a d)) \\<and>\n     c \\<le>\\<^sub>a d)", "by (simp add: psubset_eq set_eq_iff less_le_not_le) \n    (blast intro: order_trans)"], ["", "lemma Icc_subset_Ici_iff[simp]: \n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<subseteq> {l'\\<le>\\<^sub>a..} = (\\<not> l \\<le>\\<^sub>a h \\<or> l \\<ge>\\<^sub>a l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<subseteq> {l'\\<le>\\<^sub>a..}) =\n    (\\<not> l \\<le>\\<^sub>a h \\<or> l' \\<le>\\<^sub>a l)", "by (auto simp: subset_eq intro: order_trans)"], ["", "lemma Icc_subset_Iic_iff[simp]: \n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<subseteq> {..\\<le>\\<^sub>ah'} = (\\<not> l \\<le>\\<^sub>a h \\<or> h \\<le>\\<^sub>a h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<subseteq> {..\\<le>\\<^sub>ah'}) =\n    (\\<not> l \\<le>\\<^sub>a h \\<or> h \\<le>\\<^sub>a h')", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x \\<in> UNIV. l \\<le>\\<^sub>a x} \\<inter>\n     {x \\<in> UNIV. x \\<le>\\<^sub>a h}\n     \\<subseteq> {x \\<in> UNIV. x \\<le>\\<^sub>a h'}) =\n    (\\<not> l \\<le>\\<^sub>a h \\<or> h \\<le>\\<^sub>a h')", "by (blast intro: order_trans)+"], ["", "lemma not_Ici_eq_empty[simp]: \"{l\\<le>\\<^sub>a..} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..} \\<noteq> {}", "by (auto simp: set_eq_iff)"], ["", "lemmas not_empty_eq_Ici_eq_empty[simp] = not_Ici_eq_empty[symmetric]"], ["", "lemma Iio_Int_singleton: \"{..<\\<^sub>ak} \\<inter> {x} = (if x <\\<^sub>a k then {x} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..<\\<^sub>ak} \\<inter> {x} = (if x <\\<^sub>a k then {x} else {})", "by simp"], ["", "lemma ivl_disj_int_one:\n  \"{..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {}\"\n  \"{l<\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}\"\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {}\"\n  \"{l\\<le>\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (({..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..<\\<^sub>au} = {} &&&\n      {..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..<\\<^sub>au} = {}) &&&\n     {..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..\\<le>\\<^sub>au} = {} &&&\n     {..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}) &&&\n    ({l<\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {} &&&\n     {l<\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}) &&&\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {} &&&\n    {l\\<le>\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}", "using lessThan_iff dual.lessThan_iff"], ["proof (prove)\nusing this:\n  (?i \\<in> {..<\\<^sub>a?k}) = (?i <\\<^sub>a ?k)\n  (?i \\<in> {?k<\\<^sub>a..}) = (?k <\\<^sub>a ?i)\n\ngoal (1 subgoal):\n 1. (({..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..<\\<^sub>au} = {} &&&\n      {..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..<\\<^sub>au} = {}) &&&\n     {..\\<le>\\<^sub>al} \\<inter> {l<\\<^sub>a..\\<le>\\<^sub>au} = {} &&&\n     {..<\\<^sub>al} \\<inter> {l\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}) &&&\n    ({l<\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {} &&&\n     {l<\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}) &&&\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>au} \\<inter> {u<\\<^sub>a..} = {} &&&\n    {l\\<le>\\<^sub>a..<\\<^sub>au} \\<inter> {u\\<le>\\<^sub>a..} = {}", "by (auto simp: less_le_not_le)"], ["", "lemma ivl_disj_int_two:\n  \"{l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} = {}\"\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (({l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} =\n      {} &&&\n      {l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} =\n      {}) &&&\n     {l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} =\n     {} &&&\n     {l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} =\n     {}) &&&\n    ({l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} =\n     {} &&&\n     {l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} =\n     {}) &&&\n    {l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} =\n    {} &&&\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} =\n    {}", "using lessThan_iff"], ["proof (prove)\nusing this:\n  (?i \\<in> {..<\\<^sub>a?k}) = (?i <\\<^sub>a ?k)\n\ngoal (1 subgoal):\n 1. (({l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} =\n      {} &&&\n      {l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} =\n      {}) &&&\n     {l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..<\\<^sub>au} =\n     {} &&&\n     {l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..<\\<^sub>au} =\n     {}) &&&\n    ({l<\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} =\n     {} &&&\n     {l<\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} =\n     {}) &&&\n    {l\\<le>\\<^sub>a..<\\<^sub>am} \\<inter> {m\\<le>\\<^sub>a..\\<le>\\<^sub>au} =\n    {} &&&\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>am} \\<inter> {m<\\<^sub>a..\\<le>\\<^sub>au} =\n    {}", "by (auto simp: less_le_not_le)"], ["", "end"], ["", "context order\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation order_dual le ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", "by (rule order_dual.intro[OF order_axioms])"], ["", "lemma atMost_Int_atLeast: \"{..\\<le>\\<^sub>an} \\<inter> {n\\<le>\\<^sub>a..} = {n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..\\<le>\\<^sub>an} \\<inter> {n\\<le>\\<^sub>a..} = {n}", "unfolding ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> UNIV. x \\<le>\\<^sub>a n} \\<inter>\n    {x \\<in> UNIV. n \\<le>\\<^sub>a x} =\n    {n}", "by (auto simp: eq_iff)"], ["", "lemma atLeast_eq_iff[iff]: \"({x\\<le>\\<^sub>a..} = {y\\<le>\\<^sub>a..}) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x\\<le>\\<^sub>a..} = {y\\<le>\\<^sub>a..}) = (x = y)", "unfolding ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({xa \\<in> UNIV. x \\<le>\\<^sub>a xa} =\n     {x \\<in> UNIV. y \\<le>\\<^sub>a x}) =\n    (x = y)", "using antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le>\\<^sub>a ?y; ?y \\<le>\\<^sub>a ?x\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. ({xa \\<in> UNIV. x \\<le>\\<^sub>a xa} =\n     {x \\<in> UNIV. y \\<le>\\<^sub>a x}) =\n    (x = y)", "by auto"], ["", "lemma atLeastLessThan_eq_atLeastAtMost_diff: \"{a\\<le>\\<^sub>a..<\\<^sub>ab} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} - {b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..<\\<^sub>ab} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} - {b}", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> UNIV. a \\<le>\\<^sub>a x} \\<inter>\n    {x \\<in> UNIV. x <\\<^sub>a b} =\n    {x \\<in> UNIV. a \\<le>\\<^sub>a x} \\<inter>\n    {x \\<in> UNIV. x \\<le>\\<^sub>a b} -\n    {b}", "by (auto simp: less_imp_le le_less)"], ["", "lemma greaterThanAtMost_eq_atLeastAtMost_diff: \"{a<\\<^sub>a..\\<le>\\<^sub>ab} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} - {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a<\\<^sub>a..\\<le>\\<^sub>ab} = {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} - {a}", "unfolding interval_def ray_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> UNIV. a <\\<^sub>a x} \\<inter>\n    {x \\<in> UNIV. x \\<le>\\<^sub>a b} =\n    {x \\<in> UNIV. a \\<le>\\<^sub>a x} \\<inter>\n    {x \\<in> UNIV. x \\<le>\\<^sub>a b} -\n    {a}", "by (auto simp: less_imp_le le_less)"], ["", "lemma atLeastAtMost_singleton[simp]: \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>aa} = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>aa} = {a}", "using atMost_Int_atLeast"], ["proof (prove)\nusing this:\n  {..\\<le>\\<^sub>a?n} \\<inter> {?n\\<le>\\<^sub>a..} = {?n}\n\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>aa} = {a}", "by (fastforce simp: ray_def)"], ["", "lemma atLeastAtMost_singleton': \n  assumes \"a = b\"\n  shows \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {a}", "using assms"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {a}", "by simp"], ["", "lemma Icc_eq_Icc[simp]:\n  \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} = {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'} = (l = l' \\<and> h = h' \\<or> \\<not> l \\<le>\\<^sub>a h \\<and> \\<not> l' \\<le>\\<^sub>a h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} =\n     {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}) =\n    (l = l' \\<and> h = h' \\<or>\n     \\<not> l \\<le>\\<^sub>a h \\<and> \\<not> l' \\<le>\\<^sub>a h')", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} =\n    {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'} \\<Longrightarrow>\n    l = l' \\<and> h = h' \\<or>\n    \\<not> l \\<le>\\<^sub>a h \\<and> \\<not> l' \\<le>\\<^sub>a h'\n 2. l = l' \\<and> h = h' \\<or>\n    \\<not> l \\<le>\\<^sub>a h \\<and>\n    \\<not> l' \\<le>\\<^sub>a h' \\<Longrightarrow>\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} = {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} =\n    {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'} \\<Longrightarrow>\n    l = l' \\<and> h = h' \\<or>\n    \\<not> l \\<le>\\<^sub>a h \\<and> \\<not> l' \\<le>\\<^sub>a h'", "by (metis antisym atLeastatMost_subset_iff eq_refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = l' \\<and> h = h' \\<or>\n    \\<not> l \\<le>\\<^sub>a h \\<and>\n    \\<not> l' \\<le>\\<^sub>a h' \\<Longrightarrow>\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} = {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. l = l' \\<and> h = h' \\<or>\n    \\<not> l \\<le>\\<^sub>a h \\<and>\n    \\<not> l' \\<le>\\<^sub>a h' \\<Longrightarrow>\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} = {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "using atLeastatMost_empty_iff"], ["proof (prove)\nusing this:\n  ({?a\\<le>\\<^sub>a..\\<le>\\<^sub>a?b} = {}) = (\\<not> ?a \\<le>\\<^sub>a ?b)\n\ngoal (1 subgoal):\n 1. l = l' \\<and> h = h' \\<or>\n    \\<not> l \\<le>\\<^sub>a h \\<and>\n    \\<not> l' \\<le>\\<^sub>a h' \\<Longrightarrow>\n    {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} = {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma atLeastAtMost_singleton_iff[simp]: \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c} \\<longleftrightarrow> a = b \\<and> b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}) = (a = b \\<and> b = c)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c} \\<Longrightarrow>\n    a = b \\<and> b = c\n 2. a = b \\<and> b = c \\<Longrightarrow>\n    {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}", "assume \"{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\""], ["proof (state)\nthis:\n  {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\n\ngoal (2 subgoals):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c} \\<Longrightarrow>\n    a = b \\<and> b = c\n 2. a = b \\<and> b = c \\<Longrightarrow>\n    {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}", "hence *: \"\\<not> (\\<not> a \\<le>\\<^sub>a b)\""], ["proof (prove)\nusing this:\n  {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> a \\<le>\\<^sub>a b", "unfolding atLeastatMost_empty_iff[symmetric]"], ["proof (prove)\nusing this:\n  {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\n\ngoal (1 subgoal):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  \\<not> \\<not> a \\<le>\\<^sub>a b\n\ngoal (2 subgoals):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c} \\<Longrightarrow>\n    a = b \\<and> b = c\n 2. a = b \\<and> b = c \\<Longrightarrow>\n    {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}", "with \\<open>{a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\\<close>"], ["proof (chain)\npicking this:\n  {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\n  \\<not> \\<not> a \\<le>\\<^sub>a b", "have \"c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a c\""], ["proof (prove)\nusing this:\n  {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}\n  \\<not> \\<not> a \\<le>\\<^sub>a b\n\ngoal (1 subgoal):\n 1. c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a c", "by auto"], ["proof (state)\nthis:\n  c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a c\n\ngoal (2 subgoals):\n 1. {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c} \\<Longrightarrow>\n    a = b \\<and> b = c\n 2. a = b \\<and> b = c \\<Longrightarrow>\n    {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}", "with *"], ["proof (chain)\npicking this:\n  \\<not> \\<not> a \\<le>\\<^sub>a b\n  c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a c", "show \"a = b \\<and> b = c\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> a \\<le>\\<^sub>a b\n  c \\<le>\\<^sub>a a \\<and> b \\<le>\\<^sub>a c\n\ngoal (1 subgoal):\n 1. a = b \\<and> b = c", "by (auto intro: antisym order_trans)"], ["proof (state)\nthis:\n  a = b \\<and> b = c\n\ngoal (1 subgoal):\n 1. a = b \\<and> b = c \\<Longrightarrow>\n    {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab} = {c}", "qed simp"], ["", "end"], ["", "context order_extremum\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma atMost_eq_UNIV_iff: \"{..\\<le>\\<^sub>ax} = UNIV \\<longleftrightarrow> x = extremum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({..\\<le>\\<^sub>ax} = UNIV) = (x = extremum)", "by (metis ord.lessThan_iff eq_iff UNIV_I UNIV_eq_I extremum)"], ["", "end"], ["", "context no_extremum\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation order_dual le ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", "by (rule order_dual.intro[OF order_axioms])"], ["", "lemma not_UNIV_le_Icc[simp]: \"\\<not> UNIV \\<subseteq> {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> UNIV \\<subseteq> {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah}", "using gt_ex[of h]"], ["proof (prove)\nusing this:\n  \\<exists>y. h <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. \\<not> UNIV \\<subseteq> {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah}", "by (auto simp: subset_eq less_le_not_le)"], ["", "lemma not_UNIV_le_Iic[simp]: \"\\<not> UNIV \\<subseteq> {..\\<le>\\<^sub>ah}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> UNIV \\<subseteq> {..\\<le>\\<^sub>ah}", "using gt_ex[of h]"], ["proof (prove)\nusing this:\n  \\<exists>y. h <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. \\<not> UNIV \\<subseteq> {..\\<le>\\<^sub>ah}", "by (auto simp: less_le_not_le)"], ["", "lemma not_Ici_le_Icc[simp]: \"\\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "using gt_ex[of h']"], ["proof (prove)\nusing this:\n  \\<exists>y. h' <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. \\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "by (auto simp: subset_eq less_le) \n    (blast dest: antisym_conv intro: order_trans)"], ["", "lemma not_Ici_le_Iic[simp]: \"\\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'} \\<Longrightarrow>\n    False", "assume \"{l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}\""], ["proof (state)\nthis:\n  {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}\n\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}", "have x: \"l \\<le>\\<^sub>a x \\<Longrightarrow> x \\<le>\\<^sub>a h'\" for x"], ["proof (prove)\nusing this:\n  {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'}\n\ngoal (1 subgoal):\n 1. l \\<le>\\<^sub>a x \\<Longrightarrow> x \\<le>\\<^sub>a h'", "by auto"], ["proof (state)\nthis:\n  l \\<le>\\<^sub>a ?x \\<Longrightarrow> ?x \\<le>\\<^sub>a h'\n\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'} \\<Longrightarrow>\n    False", "from gt_ex"], ["proof (chain)\npicking this:\n  \\<exists>y. ?x <\\<^sub>a y", "obtain x where \"h' <\\<^sub>a x\""], ["proof (prove)\nusing this:\n  \\<exists>y. ?x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. (\\<And>x. h' <\\<^sub>a x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  h' <\\<^sub>a x\n\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah'} \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \\<open>l \\<le>\\<^sub>a x\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. l \\<le>\\<^sub>a x \\<Longrightarrow> False\n 2. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  l \\<le>\\<^sub>a x\n\ngoal (2 subgoals):\n 1. l \\<le>\\<^sub>a x \\<Longrightarrow> False\n 2. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using x[OF True] less_le_not_le"], ["proof (prove)\nusing this:\n  x \\<le>\\<^sub>a h'\n  (?x <\\<^sub>a ?y) =\n  (?x \\<le>\\<^sub>a ?y \\<and> \\<not> ?y \\<le>\\<^sub>a ?x)\n\ngoal (1 subgoal):\n 1. False", "by (force simp: \\<open>h' <\\<^sub>a x\\<close>)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> l \\<le>\\<^sub>a x\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "obtain y where \"x \\<le>\\<^sub>a y\" and \"y <\\<^sub>a l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x \\<le>\\<^sub>a y; y <\\<^sub>a l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>h' <\\<^sub>a x\\<close> dual.less_le_trans"], ["proof (prove)\nusing this:\n  h' <\\<^sub>a x\n  \\<lbrakk>?y <\\<^sub>a ?x; ?z \\<le>\\<^sub>a ?y\\<rbrakk>\n  \\<Longrightarrow> ?z <\\<^sub>a ?x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x \\<le>\\<^sub>a y; y <\\<^sub>a l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast intro: x less_imp_le)"], ["proof (state)\nthis:\n  x \\<le>\\<^sub>a y\n  y <\\<^sub>a l\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<le>\\<^sub>a y\n  y <\\<^sub>a l", "have \"x <\\<^sub>a l\""], ["proof (prove)\nusing this:\n  x \\<le>\\<^sub>a y\n  y <\\<^sub>a l\n\ngoal (1 subgoal):\n 1. x <\\<^sub>a l", "by (rule le_less_trans)"], ["proof (state)\nthis:\n  x <\\<^sub>a l\n\ngoal (1 subgoal):\n 1. \\<not> l \\<le>\\<^sub>a x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x <\\<^sub>a l", "show ?thesis"], ["proof (prove)\nusing this:\n  x <\\<^sub>a l\n\ngoal (1 subgoal):\n 1. False", "using \\<open>h' <\\<^sub>a x\\<close> less_le_not_le"], ["proof (prove)\nusing this:\n  x <\\<^sub>a l\n  h' <\\<^sub>a x\n  (?x <\\<^sub>a ?y) =\n  (?x \\<le>\\<^sub>a ?y \\<and> \\<not> ?y \\<le>\\<^sub>a ?x)\n\ngoal (1 subgoal):\n 1. False", "by (blast intro: x dual.less_trans)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_UNIV_eq_Icc[simp]: \"UNIV \\<noteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "using gt_ex"], ["proof (prove)\nusing this:\n  \\<exists>y. ?x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {l'\\<le>\\<^sub>a..\\<le>\\<^sub>ah'}", "by (auto simp: set_eq_iff less_le_not_le)"], ["", "lemmas not_Icc_eq_UNIV[simp] = not_UNIV_eq_Icc[symmetric]"], ["", "lemma not_UNIV_eq_Iic[simp]: \"UNIV \\<noteq> {..\\<le>\\<^sub>ah'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {..\\<le>\\<^sub>ah'}", "using gt_ex[of h'] not_UNIV_le_Iic"], ["proof (prove)\nusing this:\n  \\<exists>y. h' <\\<^sub>a y\n  \\<not> UNIV \\<subseteq> {..\\<le>\\<^sub>a?h}\n\ngoal (1 subgoal):\n 1. UNIV \\<noteq> {..\\<le>\\<^sub>ah'}", "by blast"], ["", "lemmas not_Iic_eq_UNIV[simp] = not_UNIV_eq_Iic[symmetric]"], ["", "lemma not_Icc_eq_Ici[simp]: \"{l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}", "using not_Ici_le_Icc"], ["proof (prove)\nusing this:\n  \\<not> {?l\\<le>\\<^sub>a..}\n         \\<subseteq> {?l'\\<le>\\<^sub>a..\\<le>\\<^sub>a?h'}\n\ngoal (1 subgoal):\n 1. {l\\<le>\\<^sub>a..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}", "by blast"], ["", "lemmas not_Ici_eq_Icc[simp] = not_Icc_eq_Ici[symmetric]"], ["", "lemma not_Iic_eq_Ici[simp]: \"{..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}", "using not_Ici_le_Iic[of l' h]"], ["proof (prove)\nusing this:\n  \\<not> {l'\\<le>\\<^sub>a..} \\<subseteq> {..\\<le>\\<^sub>ah}\n\ngoal (1 subgoal):\n 1. {..\\<le>\\<^sub>ah} \\<noteq> {l'\\<le>\\<^sub>a..}", "by blast"], ["", "lemmas not_Ici_eq_Iic[simp] = not_Iic_eq_Ici[symmetric]"], ["", "lemma greaterThan_non_empty[simp]: \"{x<\\<^sub>a..} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x<\\<^sub>a..} \\<noteq> {}", "using gt_ex[of x]"], ["proof (prove)\nusing this:\n  \\<exists>y. x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. {x<\\<^sub>a..} \\<noteq> {}", "unfolding ray_def"], ["proof (prove)\nusing this:\n  \\<exists>y. x <\\<^sub>a y\n\ngoal (1 subgoal):\n 1. {xa \\<in> UNIV. x <\\<^sub>a xa} \\<noteq> {}", "by simp"], ["", "end"], ["", "context order\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation order_pair le ls le ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_pair (\\<le>\\<^sub>a) (<\\<^sub>a) (\\<le>\\<^sub>a) (<\\<^sub>a)", ".."], ["", "interpretation ord_pair_syntax le ls le ls"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma mono_image_least:\n  assumes f_mono: \"mono\\<^sub>a\\<^sub>b f\" \n    and f_img: \"f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}\" \n    and \"m <\\<^sub>a n\"\n  shows \"f m = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f m = m'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f m = m'", "from f_img"], ["proof (chain)\npicking this:\n  f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}", "have \"{m'\\<le>\\<^sub>a..<\\<^sub>an'} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}\n\ngoal (1 subgoal):\n 1. {m'\\<le>\\<^sub>a..<\\<^sub>an'} \\<noteq> {}", "by (force simp: assms(3))"], ["proof (state)\nthis:\n  {m'\\<le>\\<^sub>a..<\\<^sub>an'} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. f m = m'", "with f_img"], ["proof (chain)\npicking this:\n  f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}\n  {m'\\<le>\\<^sub>a..<\\<^sub>an'} \\<noteq> {}", "have \"m' \\<in> f ` {m\\<le>\\<^sub>a..<\\<^sub>an}\""], ["proof (prove)\nusing this:\n  f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}\n  {m'\\<le>\\<^sub>a..<\\<^sub>an'} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. m' \\<in> f ` {m\\<le>\\<^sub>a..<\\<^sub>an}", "by auto"], ["proof (state)\nthis:\n  m' \\<in> f ` {m\\<le>\\<^sub>a..<\\<^sub>an}\n\ngoal (1 subgoal):\n 1. f m = m'", "then"], ["proof (chain)\npicking this:\n  m' \\<in> f ` {m\\<le>\\<^sub>a..<\\<^sub>an}", "obtain k where \"f k = m'\" \"m \\<le>\\<^sub>a k\""], ["proof (prove)\nusing this:\n  m' \\<in> f ` {m\\<le>\\<^sub>a..<\\<^sub>an}\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>f k = m'; m \\<le>\\<^sub>a k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f k = m'\n  m \\<le>\\<^sub>a k\n\ngoal (1 subgoal):\n 1. f m = m'", "moreover"], ["proof (state)\nthis:\n  f k = m'\n  m \\<le>\\<^sub>a k\n\ngoal (1 subgoal):\n 1. f m = m'", "have \"m' \\<le>\\<^sub>a f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<le>\\<^sub>a f m", "unfolding interval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m' \\<le>\\<^sub>a f m", "using f_img"], ["proof (prove)\nusing this:\n  f ` {m\\<le>\\<^sub>a..<\\<^sub>an} = {m'\\<le>\\<^sub>a..<\\<^sub>an'}\n\ngoal (1 subgoal):\n 1. m' \\<le>\\<^sub>a f m", "by (auto simp: assms(3))"], ["proof (state)\nthis:\n  m' \\<le>\\<^sub>a f m\n\ngoal (1 subgoal):\n 1. f m = m'", "ultimately"], ["proof (chain)\npicking this:\n  f k = m'\n  m \\<le>\\<^sub>a k\n  m' \\<le>\\<^sub>a f m", "show \"f m = m'\""], ["proof (prove)\nusing this:\n  f k = m'\n  m \\<le>\\<^sub>a k\n  m' \\<le>\\<^sub>a f m\n\ngoal (1 subgoal):\n 1. f m = m'", "using f_mono"], ["proof (prove)\nusing this:\n  f k = m'\n  m \\<le>\\<^sub>a k\n  m' \\<le>\\<^sub>a f m\n  mono\\<^sub>b\\<^sub>a f\n\ngoal (1 subgoal):\n 1. f m = m'", "by (auto dest: monoD intro: antisym)"], ["proof (state)\nthis:\n  f m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Bounded sets\\<close>"], ["", "definition bdd :: \"['a set, ['a, 'a] \\<Rightarrow> bool, 'a set] \\<Rightarrow> bool\"\n  (\\<open>(on _ with _ : \\<guillemotleft>bdd\\<guillemotright> _)\\<close> [1000, 1000, 1000] 10) \n  where \"bdd U op A \\<longleftrightarrow> (\\<exists>M\\<in>U. \\<forall>x \\<in> A. op x M)\""], ["", "ctr parametricity\n  in bdd_def"], ["", "context ord_syntax  \nbegin"], ["", "abbreviation bdd_above where \"bdd_above \\<equiv> bdd UNIV (\\<le>\\<^sub>a)\""], ["", "abbreviation bdd_below where \"bdd_below \\<equiv> bdd UNIV (\\<ge>\\<^sub>a)\""], ["", "end"], ["", "context preorder\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation preorder_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", ".."], ["", "lemma bdd_aboveI[intro]: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> x \\<le>\\<^sub>a M\"\n  shows \"bdd_above A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above A", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le>\\<^sub>a M\n\ngoal (1 subgoal):\n 1. local.bdd_above A", "unfolding bdd_def"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x \\<le>\\<^sub>a M\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>UNIV. \\<forall>x\\<in>A. x \\<le>\\<^sub>a M", "by auto"], ["", "lemma bdd_belowI[intro]: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a x\"\n  shows \"bdd_below A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below A", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a ?x\n\ngoal (1 subgoal):\n 1. local.bdd_below A", "unfolding bdd_def"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a ?x\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>UNIV. \\<forall>x\\<in>A. M \\<le>\\<^sub>a x", "by auto"], ["", "lemma bdd_aboveI2: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<le>\\<^sub>a M\"\n  shows \"bdd_above (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> f ?x \\<le>\\<^sub>a M\n\ngoal (1 subgoal):\n 1. local.bdd_above (f ` A)", "by force"], ["", "lemma bdd_belowI2: \n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a f x\"\n  shows \"bdd_below (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> m \\<le>\\<^sub>a f ?x\n\ngoal (1 subgoal):\n 1. local.bdd_below (f ` A)", "by force"], ["", "lemma bdd_above_empty[simp, intro]: \"bdd_above {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {}", "unfolding bdd_above_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {}", "by auto"], ["", "lemma bdd_below_empty[simp, intro]: \"bdd_below {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {}", "unfolding bdd_below_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {}", "by auto"], ["", "lemma bdd_above_mono: \n  assumes \"bdd_above B\" and \"A \\<subseteq> B\" \n  shows \"bdd_above A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above A", "using assms"], ["proof (prove)\nusing this:\n  local.bdd_above B\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.bdd_above A", "unfolding bdd_def"], ["proof (prove)\nusing this:\n  \\<exists>M\\<in>UNIV. \\<forall>x\\<in>B. x \\<le>\\<^sub>a M\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>UNIV. \\<forall>x\\<in>A. x \\<le>\\<^sub>a M", "by auto"], ["", "lemma bdd_below_mono: \n  assumes \"bdd_below B\" and \"A \\<subseteq> B\"\n  shows \"bdd_below A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below A", "using assms"], ["proof (prove)\nusing this:\n  local.bdd_below B\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. local.bdd_below A", "unfolding bdd_def"], ["proof (prove)\nusing this:\n  \\<exists>M\\<in>UNIV. \\<forall>x\\<in>B. M \\<le>\\<^sub>a x\n  A \\<subseteq> B\n\ngoal (1 subgoal):\n 1. \\<exists>M\\<in>UNIV. \\<forall>x\\<in>A. M \\<le>\\<^sub>a x", "by auto"], ["", "lemma bdd_above_Int1[simp]: \n  assumes \"bdd_above A\"\n  shows \"bdd_above (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above (A \\<inter> B)", "using assms"], ["proof (prove)\nusing this:\n  local.bdd_above A\n\ngoal (1 subgoal):\n 1. local.bdd_above (A \\<inter> B)", "by (auto simp: bdd_above_mono)"], ["", "lemma bdd_above_Int2[simp]: \n  assumes \"bdd_above B\"\n  shows \"bdd_above (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above (A \\<inter> B)", "using assms"], ["proof (prove)\nusing this:\n  local.bdd_above B\n\ngoal (1 subgoal):\n 1. local.bdd_above (A \\<inter> B)", "by (auto simp: bdd_above_mono)"], ["", "lemma bdd_below_Int1[simp]: \n  assumes \"bdd_below A\"\n  shows \"bdd_below (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below (A \\<inter> B)", "using assms"], ["proof (prove)\nusing this:\n  local.bdd_below A\n\ngoal (1 subgoal):\n 1. local.bdd_below (A \\<inter> B)", "by (auto simp: bdd_below_mono)"], ["", "lemma bdd_below_Int2[simp]: \n  assumes \"bdd_below B\"\n  shows \"bdd_below (A \\<inter> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below (A \\<inter> B)", "using assms"], ["proof (prove)\nusing this:\n  local.bdd_below B\n\ngoal (1 subgoal):\n 1. local.bdd_below (A \\<inter> B)", "by (auto simp: bdd_below_mono)"], ["", "lemma bdd_above_Ioo[simp, intro]: \"bdd_above {a<\\<^sub>a..<\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {a<\\<^sub>a..<\\<^sub>ab}", "by (auto intro!: less_imp_le)"], ["", "lemma bdd_above_Ico[simp, intro]: \"bdd_above {a\\<le>\\<^sub>a..<\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {a\\<le>\\<^sub>a..<\\<^sub>ab}", "by (auto intro!: less_imp_le)"], ["", "lemma bdd_above_Iio[simp, intro]: \"bdd_above {..<\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {..<\\<^sub>ab}", "by (auto intro: less_imp_le)"], ["", "lemma bdd_above_Ioc[simp, intro]: \"bdd_above {a<\\<^sub>a..\\<le>\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {a<\\<^sub>a..\\<le>\\<^sub>ab}", "by auto"], ["", "lemma bdd_above_Icc[simp, intro]: \"bdd_above {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}", "by (auto intro: less_imp_le)"], ["", "lemma bdd_above_Iic[simp, intro]: \"bdd_above {..\\<le>\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above {..\\<le>\\<^sub>ab}", "by (auto intro: less_imp_le)"], ["", "lemma bdd_below_Ioo[simp, intro]: \"bdd_below {a<\\<^sub>a..<\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {a<\\<^sub>a..<\\<^sub>ab}", "by (auto intro!: less_imp_le)"], ["", "lemma bdd_below_Ioc[simp, intro]: \"bdd_below {a<\\<^sub>a..\\<le>\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {a<\\<^sub>a..\\<le>\\<^sub>ab}", "by (auto intro!: less_imp_le)"], ["", "lemma bdd_below_Ioi[simp, intro]: \"bdd_below {a<\\<^sub>a..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {a<\\<^sub>a..}", "by (auto intro: less_imp_le)"], ["", "lemma bdd_below_Ico[simp, intro]: \"bdd_below {a\\<le>\\<^sub>a..<\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {a\\<le>\\<^sub>a..<\\<^sub>ab}", "by auto"], ["", "lemma bdd_below_Icc[simp, intro]: \"bdd_below {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {a\\<le>\\<^sub>a..\\<le>\\<^sub>ab}", "by auto"], ["", "lemma bdd_below_Ici[simp, intro]: \"bdd_below {a\\<le>\\<^sub>a..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_below {a\\<le>\\<^sub>a..}", "by (auto intro: less_imp_le)"], ["", "end"], ["", "context order_pair\nbegin"], ["", "interpretation ord_pair_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma bdd_above_image_mono: \n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_above A\"\n  shows \"ord\\<^sub>b.bdd_above (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_above (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  mono\\<^sub>a\\<^sub>b f\n  ord\\<^sub>a.bdd_above A\n\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_above (f ` A)", "by (auto simp: bdd_def mono_def)"], ["", "lemma bdd_below_image_mono: \n  assumes \"mono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_below A\" \n  shows \"ord\\<^sub>b.bdd_below (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_below (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  mono\\<^sub>a\\<^sub>b f\n  ord\\<^sub>a.bdd_below A\n\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_below (f ` A)", "by (auto simp: bdd_def mono_def)"], ["", "lemma bdd_above_image_antimono:\n  assumes \"antimono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_below A\" \n  shows \"ord\\<^sub>b.bdd_above (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_above (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  antimono\\<^sub>a\\<^sub>b f\n  ord\\<^sub>a.bdd_below A\n\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_above (f ` A)", "by (auto simp: bdd_def mono_def)"], ["", "lemma bdd_below_image_antimono: \n  assumes \"antimono\\<^sub>a\\<^sub>b f\" and \"ord\\<^sub>a.bdd_above A\"   \n  shows \"ord\\<^sub>b.bdd_below (f ` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_below (f ` A)", "using assms"], ["proof (prove)\nusing this:\n  antimono\\<^sub>a\\<^sub>b f\n  ord\\<^sub>a.bdd_above A\n\ngoal (1 subgoal):\n 1. ord\\<^sub>b.bdd_below (f ` A)", "by (auto simp: bdd_def mono_def)"], ["", "end"], ["", "context order_extremum\nbegin"], ["", "interpretation ord_syntax"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation order_dual"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_dual (\\<le>\\<^sub>a) (<\\<^sub>a)", ".."], ["", "lemma bdd_above_top[simp, intro!]: \"bdd_above A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bdd_above A", "by (rule bdd_aboveI[of _ extremum]) simp"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}