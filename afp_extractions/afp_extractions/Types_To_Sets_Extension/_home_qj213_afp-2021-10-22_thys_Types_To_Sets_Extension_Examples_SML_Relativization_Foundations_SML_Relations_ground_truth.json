{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/SML_Relativization/Foundations/SML_Relations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemmas tranclp_on_def = trancl_onp_def", "lemma trancl_on_eq_tranclp_on:\n  \"on P (\\<lambda>x y. (x, y) \\<in> r)\\<^sup>+\\<^sup>+ x y = ((x, y) \\<in> on (Collect P) r\\<^sup>+)\"", "lemma trancl_on_imp_U: \"(x, y) \\<in> on U r\\<^sup>+  \\<Longrightarrow> (x, y) \\<in> U \\<times> U\"", "lemmas tranclp_on_imp_P = trancl_on_imp_U[to_pred, simplified]", "lemma trancl_on_imp_trancl: \"(x, y) \\<in> on U r\\<^sup>+ \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+\"", "lemmas tranclp_on_imp_tranclp = trancl_on_imp_trancl[to_pred]", "lemma tranclp_eq_tranclp_on: \"r\\<^sup>+\\<^sup>+ = on (\\<lambda>x. True) r\\<^sup>+\\<^sup>+\"", "lemma trancl_eq_trancl_on: \"r\\<^sup>+ = on UNIV r\\<^sup>+\"", "lemma transp_on_empty[simp]: \"transp_on {} r\"", "lemma transp_eq_transp_on: \"transp = transp_on UNIV\"", "lemma acyclic_on_empty[simp]: \"acyclic_on {} r\"", "lemma acyclic_eq_acyclic_on: \"acyclic = acyclic_on UNIV\"", "lemma Inf_transfer[transfer_rule]: \n  \"(rel_set (A ===> (=)) ===> A ===> (=)) Inf Inf\"", "lemma less_eq_pred_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\" \n  shows \n    \"((A ===> (=)) ===> (A ===> (=)) ===> (=)) \n      (\\<lambda>f g. \\<forall>x\\<in>Collect(Domainp A). f x \\<le> g x) (\\<le>)\"", "lemma lfp_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  defines \"R \\<equiv> (((A ===> (=)) ===> (A ===> (=))) ===> (A ===> (=)))\"\n  shows \"R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot)) lfp\"", "lemma Inf2_transfer[transfer_rule]:\n  \"(rel_set (T ===> T ===> (=)) ===> T ===> T ===> (=)) Inf Inf\"", "lemma less_eq2_pred_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"right_total T\" \n  shows \n    \"((T ===> T ===> (=)) ===> (T ===> T ===> (=)) ===> (=)) \n      (\\<lambda>f g. \\<forall>x\\<in>Collect(Domainp T). \\<forall>y\\<in>Collect(Domainp T). f x y \\<le> g x y) (\\<le>)\"", "lemma lfp2_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  defines \n    \"R \\<equiv> \n      (((A ===> A ===> (=)) ===> (A ===> A ===> (=))) ===> (A ===> A ===> (=)))\"\n  shows \n    \"R \n      (\n        \\<lambda>f. lfp \n          (\n            \\<lambda>u x y. \n              if Domainp A x \n              then if Domainp A y then (f u) x y else bot \n              else bot\n          )\n      ) \n      lfp\"", "lemma transp_rt_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"right_total A\" \n  shows \n    \"((A ===> A ===> (=)) ===> (=)) (transp_on (Collect (Domainp A))) transp\"", "lemma tranclp_rt_bu_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> (=)) ===> (A ===> A ===> (=))) \n      (tranclp_on (Domainp A)) tranclp\"", "lemma trancl_rt_bu_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(rel_set (rel_prod A A) ===> rel_set (rel_prod A A)) \n      (trancl_on (Collect (Domainp A))) trancl\"", "lemma acyclic_rt_bu_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((rel_set (rel_prod A A)) ===> (=)) \n      (acyclic_on (Collect (Domainp A))) acyclic\""], "translations": [["", "lemmas tranclp_on_def = trancl_onp_def"], ["", "end"], ["", "definition transp_on :: \"['a set, ['a, 'a] \\<Rightarrow> bool] \\<Rightarrow> bool\"\n  where \"transp_on U = (\\<lambda>r. (\\<forall>x\\<in>U. \\<forall>y\\<in>U. \\<forall>z\\<in>U. r x y \\<longrightarrow> r y z \\<longrightarrow> r x z))\""], ["", "definition acyclic_on :: \"['a set, ('a \\<times> 'a) set] \\<Rightarrow> bool\"\n  where \"acyclic_on U = (\\<lambda>r. (\\<forall>x\\<in>U. (x, x) \\<notin> on U r\\<^sup>+))\""], ["", "lemma trancl_on_eq_tranclp_on:\n  \"on P (\\<lambda>x y. (x, y) \\<in> r)\\<^sup>+\\<^sup>+ x y = ((x, y) \\<in> on (Collect P) r\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. on P (\\<lambda>x y. (x, y) \\<in> r)\\<^sup>+\\<^sup>+ x y =\n    ((x, y) \\<in> on (Collect P) r\\<^sup>+)", "unfolding trancl_on_def tranclp_on_def Set.mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>p x1 x2.\n            (\\<exists>a b.\n                x1 = a \\<and>\n                x2 = b \\<and> P a \\<and> P b \\<and> (a, b) \\<in> r) \\<or>\n            (\\<exists>a b c.\n                x1 = a \\<and>\n                x2 = c \\<and>\n                P a \\<and>\n                P b \\<and> P c \\<and> p a b \\<and> (b, c) \\<in> r))\n     x y =\n    (case (x, y) of\n     (x, xa) \\<Rightarrow>\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>a b.\n                   x1 = a \\<and>\n                   x2 = b \\<and> P a \\<and> P b \\<and> (a, b) \\<in> r) \\<or>\n               (\\<exists>a b c.\n                   x1 = a \\<and>\n                   x2 = c \\<and>\n                   P a \\<and>\n                   P b \\<and> P c \\<and> p a b \\<and> (b, c) \\<in> r))\n        x xa)", "by simp"], ["", "lemma trancl_on_imp_U: \"(x, y) \\<in> on U r\\<^sup>+  \\<Longrightarrow> (x, y) \\<in> U \\<times> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> on U r\\<^sup>+ \\<Longrightarrow> (x, y) \\<in> U \\<times> U", "by (auto dest: trancl_on.cases)"], ["", "lemmas tranclp_on_imp_P = trancl_on_imp_U[to_pred, simplified]"], ["", "lemma trancl_on_imp_trancl: \"(x, y) \\<in> on U r\\<^sup>+ \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> on U r\\<^sup>+ \\<Longrightarrow> (x, y) \\<in> r\\<^sup>+", "by (induction rule: trancl_on.induct) auto"], ["", "lemmas tranclp_on_imp_tranclp = trancl_on_imp_trancl[to_pred]"], ["", "lemma tranclp_eq_tranclp_on: \"r\\<^sup>+\\<^sup>+ = on (\\<lambda>x. True) r\\<^sup>+\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>+\\<^sup>+ = on (\\<lambda>x. True) r\\<^sup>+\\<^sup>+", "unfolding tranclp_def tranclp_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp (\\<lambda>p x1 x2.\n            (\\<exists>a b. x1 = a \\<and> x2 = b \\<and> r a b) \\<or>\n            (\\<exists>a b c.\n                x1 = a \\<and> x2 = c \\<and> p a b \\<and> r b c)) =\n    lfp (\\<lambda>p x1 x2.\n            (\\<exists>a b.\n                x1 = a \\<and>\n                x2 = b \\<and> True \\<and> True \\<and> r a b) \\<or>\n            (\\<exists>a b c.\n                x1 = a \\<and>\n                x2 = c \\<and>\n                True \\<and> True \\<and> True \\<and> p a b \\<and> r b c))", "by simp"], ["", "lemma trancl_eq_trancl_on: \"r\\<^sup>+ = on UNIV r\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r\\<^sup>+ = on UNIV r\\<^sup>+", "unfolding trancl_def trancl_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ x y} =\n    {(x, y).\n     on (\\<lambda>x. x \\<in> UNIV)\n      (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ x y}", "by (simp add: tranclp_eq_tranclp_on)"], ["", "lemma transp_on_empty[simp]: \"transp_on {} r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp_on {} r", "unfolding transp_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{}.\n       \\<forall>y\\<in>{}.\n          \\<forall>z\\<in>{}.\n             r x y \\<longrightarrow> r y z \\<longrightarrow> r x z", "by simp"], ["", "lemma transp_eq_transp_on: \"transp = transp_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp = transp_on UNIV", "unfolding transp_def transp_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r.\n        \\<forall>x y z.\n           r x y \\<longrightarrow> r y z \\<longrightarrow> r x z) =\n    (\\<lambda>r.\n        \\<forall>x\\<in>UNIV.\n           \\<forall>y\\<in>UNIV.\n              \\<forall>z\\<in>UNIV.\n                 r x y \\<longrightarrow> r y z \\<longrightarrow> r x z)", "by simp"], ["", "lemma acyclic_on_empty[simp]: \"acyclic_on {} r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_on {} r", "unfolding acyclic_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{}. (x, x) \\<notin> on {} r\\<^sup>+", "by simp"], ["", "lemma acyclic_eq_acyclic_on: \"acyclic = acyclic_on UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic = acyclic_on UNIV", "unfolding acyclic_def acyclic_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r. \\<forall>x. (x, x) \\<notin> r\\<^sup>+) =\n    (\\<lambda>r. \\<forall>x\\<in>UNIV. (x, x) \\<notin> on UNIV r\\<^sup>+)", "unfolding trancl_def tranclp_def trancl_on_def tranclp_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r.\n        \\<forall>x.\n           (x, x)\n           \\<notin> {(x, y).\n                     lfp (\\<lambda>p x1 x2.\n                             (\\<exists>a b.\n                                 x1 = a \\<and>\n                                 x2 = b \\<and> (a, b) \\<in> r) \\<or>\n                             (\\<exists>a b c.\n                                 x1 = a \\<and>\n                                 x2 = c \\<and> p a b \\<and> (b, c) \\<in> r))\n                      x y}) =\n    (\\<lambda>r.\n        \\<forall>x\\<in>UNIV.\n           (x, x)\n           \\<notin> {(x, y).\n                     lfp (\\<lambda>p x1 x2.\n                             (\\<exists>a b.\n                                 x1 = a \\<and>\n                                 x2 = b \\<and>\n                                 a \\<in> UNIV \\<and>\n                                 b \\<in> UNIV \\<and> (a, b) \\<in> r) \\<or>\n                             (\\<exists>a b c.\n                                 x1 = a \\<and>\n                                 x2 = c \\<and>\n                                 a \\<in> UNIV \\<and>\n                                 b \\<in> UNIV \\<and>\n                                 c \\<in> UNIV \\<and>\n                                 p a b \\<and> (b, c) \\<in> r))\n                      x y})", "by simp"], ["", "subsection\\<open>Transfer rules I: \\<^const>\\<open>lfp\\<close> transfer\\<close>"], ["", "text\\<open>\nThe following context contains code from \\cite{immler_re_2019}.\n\\<close>"], ["", "context\n  includes lifting_syntax \nbegin"], ["", "lemma Inf_transfer[transfer_rule]: \n  \"(rel_set (A ===> (=)) ===> A ===> (=)) Inf Inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (A ===> (=)) ===> A ===> (=)) Inf Inf", "unfolding Inf_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (A ===> (=)) ===> A ===> (=)) (\\<lambda>A x. INF f\\<in>A. f x)\n     (\\<lambda>A x. INF f\\<in>A. f x)", "by transfer_prover"], ["", "lemma less_eq_pred_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"right_total A\" \n  shows \n    \"((A ===> (=)) ===> (A ===> (=)) ===> (=)) \n      (\\<lambda>f g. \\<forall>x\\<in>Collect(Domainp A). f x \\<le> g x) (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> (A ===> (=)) ===> (=))\n     (\\<lambda>f g. \\<forall>x\\<in>Collect (Domainp A). f x \\<le> g x)\n     (\\<le>)", "unfolding le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (=)) ===> (A ===> (=)) ===> (=))\n     (\\<lambda>f g. \\<forall>x\\<in>Collect (Domainp A). f x \\<le> g x)\n     (\\<lambda>f g. \\<forall>x. f x \\<le> g x)", "by transfer_prover"], ["", "lemma lfp_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  defines \"R \\<equiv> (((A ===> (=)) ===> (A ===> (=))) ===> (A ===> (=)))\"\n  shows \"R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot)) lfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot))\n     lfp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot))\n     lfp", "have \"R (\\<lambda>f. Inf {u. \\<forall>x\\<in>Collect (Domainp A). f u x \\<le> u x}) lfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<lambda>f.\n          Inf {u. \\<forall>x\\<in>Collect (Domainp A). f u x \\<le> u x})\n     lfp", "unfolding R_def lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((A ===> (=)) ===> A ===> (=)) ===> A ===> (=))\n     (\\<lambda>f.\n         Inf {u. \\<forall>x\\<in>Collect (Domainp A). f u x \\<le> u x})\n     (\\<lambda>f. Inf {u. f u \\<le> u})", "by transfer_prover"], ["proof (state)\nthis:\n  R (\\<lambda>f.\n        Inf {u. \\<forall>x\\<in>Collect (Domainp A). f u x \\<le> u x})\n   lfp\n\ngoal (1 subgoal):\n 1. R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot))\n     lfp", "thus ?thesis"], ["proof (prove)\nusing this:\n  R (\\<lambda>f.\n        Inf {u. \\<forall>x\\<in>Collect (Domainp A). f u x \\<le> u x})\n   lfp\n\ngoal (1 subgoal):\n 1. R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot))\n     lfp", "by (auto simp: le_fun_def lfp_def)"], ["proof (state)\nthis:\n  R (\\<lambda>f. lfp (\\<lambda>u x. if Domainp A x then f u x else bot)) lfp\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Inf2_transfer[transfer_rule]:\n  \"(rel_set (T ===> T ===> (=)) ===> T ===> T ===> (=)) Inf Inf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (T ===> T ===> (=)) ===> T ===> T ===> (=)) Inf Inf", "unfolding Inf_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (T ===> T ===> (=)) ===> T ===> T ===> (=))\n     (\\<lambda>A x xa. INF f\\<in>(\\<lambda>f. f x) ` A. f xa)\n     (\\<lambda>A x xa. INF f\\<in>(\\<lambda>f. f x) ` A. f xa)", "by transfer_prover"], ["", "lemma less_eq2_pred_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"right_total T\" \n  shows \n    \"((T ===> T ===> (=)) ===> (T ===> T ===> (=)) ===> (=)) \n      (\\<lambda>f g. \\<forall>x\\<in>Collect(Domainp T). \\<forall>y\\<in>Collect(Domainp T). f x y \\<le> g x y) (\\<le>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((T ===> T ===> (=)) ===> (T ===> T ===> (=)) ===> (=))\n     (\\<lambda>f g.\n         \\<forall>x\\<in>Collect (Domainp T).\n            \\<forall>y\\<in>Collect (Domainp T). f x y \\<le> g x y)\n     (\\<le>)", "unfolding le_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((T ===> T ===> (=)) ===> (T ===> T ===> (=)) ===> (=))\n     (\\<lambda>f g.\n         \\<forall>x\\<in>Collect (Domainp T).\n            \\<forall>y\\<in>Collect (Domainp T). f x y \\<le> g x y)\n     (\\<lambda>f g. \\<forall>x xa. f x xa \\<le> g x xa)", "by transfer_prover"], ["", "lemma lfp2_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  defines \n    \"R \\<equiv> \n      (((A ===> A ===> (=)) ===> (A ===> A ===> (=))) ===> (A ===> A ===> (=)))\"\n  shows \n    \"R \n      (\n        \\<lambda>f. lfp \n          (\n            \\<lambda>u x y. \n              if Domainp A x \n              then if Domainp A y then (f u) x y else bot \n              else bot\n          )\n      ) \n      lfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<lambda>f.\n          lfp (\\<lambda>u x y.\n                  if Domainp A x then if Domainp A y then f u x y else bot\n                  else bot))\n     lfp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R (\\<lambda>f.\n          lfp (\\<lambda>u x y.\n                  if Domainp A x then if Domainp A y then f u x y else bot\n                  else bot))\n     lfp", "have \n    \"R \n      (\n        \\<lambda>f. \n          Inf \n            {\n              u. \n                \\<forall>x\\<in>Collect (Domainp A). \\<forall>y\\<in>Collect (Domainp A). \n                  (f u) x y \\<le> u x y\n            }\n      ) \n      lfp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (\\<lambda>f.\n          Inf {u. \\<forall>x\\<in>Collect (Domainp A).\n                     \\<forall>y\\<in>Collect (Domainp A).\n                        f u x y \\<le> u x y})\n     lfp", "unfolding R_def lfp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((A ===> A ===> (=)) ===> A ===> A ===> (=)) ===> A ===> A ===> (=))\n     (\\<lambda>f.\n         Inf {u. \\<forall>x\\<in>Collect (Domainp A).\n                    \\<forall>y\\<in>Collect (Domainp A).\n                       f u x y \\<le> u x y})\n     (\\<lambda>f. Inf {u. f u \\<le> u})", "by transfer_prover"], ["proof (state)\nthis:\n  R (\\<lambda>f.\n        Inf {u. \\<forall>x\\<in>Collect (Domainp A).\n                   \\<forall>y\\<in>Collect (Domainp A). f u x y \\<le> u x y})\n   lfp\n\ngoal (1 subgoal):\n 1. R (\\<lambda>f.\n          lfp (\\<lambda>u x y.\n                  if Domainp A x then if Domainp A y then f u x y else bot\n                  else bot))\n     lfp", "thus ?thesis"], ["proof (prove)\nusing this:\n  R (\\<lambda>f.\n        Inf {u. \\<forall>x\\<in>Collect (Domainp A).\n                   \\<forall>y\\<in>Collect (Domainp A). f u x y \\<le> u x y})\n   lfp\n\ngoal (1 subgoal):\n 1. R (\\<lambda>f.\n          lfp (\\<lambda>u x y.\n                  if Domainp A x then if Domainp A y then f u x y else bot\n                  else bot))\n     lfp", "by (auto simp: le_fun_def lfp_def)"], ["proof (state)\nthis:\n  R (\\<lambda>f.\n        lfp (\\<lambda>u x y.\n                if Domainp A x then if Domainp A y then f u x y else bot\n                else bot))\n   lfp\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Transfer rules II: application-specific rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma transp_rt_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"right_total A\" \n  shows \n    \"((A ===> A ===> (=)) ===> (=)) (transp_on (Collect (Domainp A))) transp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> (=)) (transp_on (Collect (Domainp A))) transp", "unfolding transp_def transp_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> (=))\n     (\\<lambda>r.\n         \\<forall>x\\<in>Collect (Domainp A).\n            \\<forall>y\\<in>Collect (Domainp A).\n               \\<forall>z\\<in>Collect (Domainp A).\n                  r x y \\<longrightarrow> r y z \\<longrightarrow> r x z)\n     (\\<lambda>r.\n         \\<forall>x y z.\n            r x y \\<longrightarrow> r y z \\<longrightarrow> r x z)", "by transfer_prover"], ["", "lemma tranclp_rt_bu_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> (=)) ===> (A ===> A ===> (=))) \n      (tranclp_on (Domainp A)) tranclp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> A ===> A ===> (=)) (tranclp_on (Domainp A))\n     tranclp", "unfolding tranclp_on_def tranclp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===> A ===> A ===> (=))\n     (\\<lambda>r.\n         lfp (\\<lambda>p x1 x2.\n                 (\\<exists>a b.\n                     x1 = a \\<and>\n                     x2 = b \\<and>\n                     Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n                 (\\<exists>a b c.\n                     x1 = a \\<and>\n                     x2 = c \\<and>\n                     Domainp A a \\<and>\n                     Domainp A b \\<and>\n                     Domainp A c \\<and> p a b \\<and> r b c)))\n     (\\<lambda>r.\n         lfp (\\<lambda>p x1 x2.\n                 (\\<exists>a b. x1 = a \\<and> x2 = b \\<and> r a b) \\<or>\n                 (\\<exists>a b c.\n                     x1 = a \\<and> x2 = c \\<and> p a b \\<and> r b c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (17 subgoals):\n 1. Transfer.Rel (?Rg35 ===> (=) ===> ?Ry35) ?ao35 (\\<and>)\n 2. Transfer.Rel (?Ri35 ===> A ===> ?Rx35) ?an35 (=)\n 3. Transfer.Rel (?Rx35 ===> ?Ry35 ===> ?Rw35) ?am35 (\\<and>)\n 4. Transfer.Rel (?Rh35 ===> ?Rf35 ===> ?Rv35) ?al35 (=)\n 5. Transfer.Rel (?Rv35 ===> ?Rw35 ===> ?Ru35) ?ak35 (\\<and>)\n 6. Transfer.Rel ((A ===> ?Ru35) ===> ?Rt35) ?aj35 Ex\n 7. Transfer.Rel ((A ===> ?Rt35) ===> ?Rs35) ?ai35 Ex\n 8. Transfer.Rel ((?Rf35 ===> ?Rs35) ===> ?Rm35) ?ah35 Ex\n 9. Transfer.Rel (?Ri35 ===> A ===> ?Rr35) ?ag35 (=)\n 10. Transfer.Rel (?Rr35 ===> (=) ===> ?Rq35) ?af35 (\\<and>)\nA total of 17 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r.\n        lfp (\\<lambda>p x1 x2.\n                (\\<exists>a b.\n                    x1 = a \\<and>\n                    x2 = b \\<and>\n                    Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n                (\\<exists>a b c.\n                    x1 = a \\<and>\n                    x2 = c \\<and>\n                    Domainp A a \\<and>\n                    Domainp A b \\<and>\n                    Domainp A c \\<and> p a b \\<and> r b c))) =\n    (\\<lambda>r.\n        lfp (\\<lambda>u x y.\n                if Domainp A x\n                then if Domainp A y\n                     then (\\<exists>a\\<in>Collect (Domainp A).\n                              \\<exists>b\\<in>Collect (Domainp A).\n                                 x = a \\<and> y = b \\<and> r a b) \\<or>\n                          (\\<exists>a\\<in>Collect (Domainp A).\n                              \\<exists>b\\<in>Collect (Domainp A).\n                                 \\<exists>c\\<in>Collect (Domainp A).\n                                    x = a \\<and>\n                                    y = c \\<and> u a b \\<and> r b c)\n                     else bot\n                else bot))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>a b.\n                   x1 = a \\<and>\n                   x2 = b \\<and>\n                   Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n               (\\<exists>a b c.\n                   x1 = a \\<and>\n                   x2 = c \\<and>\n                   Domainp A a \\<and>\n                   Domainp A b \\<and>\n                   Domainp A c \\<and> p a b \\<and> r b c)) =\n       lfp (\\<lambda>u x y.\n               if Domainp A x\n               then if Domainp A y\n                    then (\\<exists>a\\<in>Collect (Domainp A).\n                             \\<exists>b\\<in>Collect (Domainp A).\n                                x = a \\<and> y = b \\<and> r a b) \\<or>\n                         (\\<exists>a\\<in>Collect (Domainp A).\n                             \\<exists>b\\<in>Collect (Domainp A).\n                                \\<exists>c\\<in>Collect (Domainp A).\n                                   x = a \\<and>\n                                   y = c \\<and> u a b \\<and> r b c)\n                    else bot\n               else bot)", "fix r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>a b.\n                   x1 = a \\<and>\n                   x2 = b \\<and>\n                   Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n               (\\<exists>a b c.\n                   x1 = a \\<and>\n                   x2 = c \\<and>\n                   Domainp A a \\<and>\n                   Domainp A b \\<and>\n                   Domainp A c \\<and> p a b \\<and> r b c)) =\n       lfp (\\<lambda>u x y.\n               if Domainp A x\n               then if Domainp A y\n                    then (\\<exists>a\\<in>Collect (Domainp A).\n                             \\<exists>b\\<in>Collect (Domainp A).\n                                x = a \\<and> y = b \\<and> r a b) \\<or>\n                         (\\<exists>a\\<in>Collect (Domainp A).\n                             \\<exists>b\\<in>Collect (Domainp A).\n                                \\<exists>c\\<in>Collect (Domainp A).\n                                   x = a \\<and>\n                                   y = c \\<and> u a b \\<and> r b c)\n                    else bot\n               else bot)", "have \n    \"(\n      \\<lambda>p x y.\n        (\\<exists>a b. x = a \\<and> y = b \\<and> Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or> \n        (\n          \\<exists>a b c. \n            x = a \\<and> y = c \\<and> \n            Domainp A a \\<and> Domainp A b \\<and> Domainp A c \\<and> \n            p a b \\<and> r b c\n        ) \n    ) = \n      (\n        \\<lambda>p x y.\n          if Domainp A x\n          then if Domainp A y\n            then \n              (\n                \\<exists>a\\<in>Collect (Domainp A). \\<exists>b\\<in>Collect (Domainp A). \n                  x = a \\<and> y = b \\<and> r a b) \\<or>\n                  (\n                    \\<exists>a\\<in>Collect (Domainp A). \n                    \\<exists>b\\<in>Collect (Domainp A). \n                    \\<exists>c\\<in>Collect (Domainp A). \n                      x = a \\<and> y = c \\<and> p a b \\<and> r b c\n                  )\n           else bot\n         else bot\n      )\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p x y.\n        (\\<exists>a b.\n            x = a \\<and>\n            y = b \\<and> Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n        (\\<exists>a b c.\n            x = a \\<and>\n            y = c \\<and>\n            Domainp A a \\<and>\n            Domainp A b \\<and> Domainp A c \\<and> p a b \\<and> r b c)) =\n    (\\<lambda>p x y.\n        if Domainp A x\n        then if Domainp A y\n             then (\\<exists>a\\<in>Collect (Domainp A).\n                      \\<exists>b\\<in>Collect (Domainp A).\n                         x = a \\<and> y = b \\<and> r a b) \\<or>\n                  (\\<exists>a\\<in>Collect (Domainp A).\n                      \\<exists>b\\<in>Collect (Domainp A).\n                         \\<exists>c\\<in>Collect (Domainp A).\n                            x = a \\<and> y = c \\<and> p a b \\<and> r b c)\n             else bot\n        else bot)", "by (intro ext) simp"], ["proof (state)\nthis:\n  (\\<lambda>p x y.\n      (\\<exists>a b.\n          x = a \\<and>\n          y = b \\<and> Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n      (\\<exists>a b c.\n          x = a \\<and>\n          y = c \\<and>\n          Domainp A a \\<and>\n          Domainp A b \\<and> Domainp A c \\<and> p a b \\<and> r b c)) =\n  (\\<lambda>p x y.\n      if Domainp A x\n      then if Domainp A y\n           then (\\<exists>a\\<in>Collect (Domainp A).\n                    \\<exists>b\\<in>Collect (Domainp A).\n                       x = a \\<and> y = b \\<and> r a b) \\<or>\n                (\\<exists>a\\<in>Collect (Domainp A).\n                    \\<exists>b\\<in>Collect (Domainp A).\n                       \\<exists>c\\<in>Collect (Domainp A).\n                          x = a \\<and> y = c \\<and> p a b \\<and> r b c)\n           else bot\n      else bot)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       lfp (\\<lambda>p x1 x2.\n               (\\<exists>a b.\n                   x1 = a \\<and>\n                   x2 = b \\<and>\n                   Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n               (\\<exists>a b c.\n                   x1 = a \\<and>\n                   x2 = c \\<and>\n                   Domainp A a \\<and>\n                   Domainp A b \\<and>\n                   Domainp A c \\<and> p a b \\<and> r b c)) =\n       lfp (\\<lambda>u x y.\n               if Domainp A x\n               then if Domainp A y\n                    then (\\<exists>a\\<in>Collect (Domainp A).\n                             \\<exists>b\\<in>Collect (Domainp A).\n                                x = a \\<and> y = b \\<and> r a b) \\<or>\n                         (\\<exists>a\\<in>Collect (Domainp A).\n                             \\<exists>b\\<in>Collect (Domainp A).\n                                \\<exists>c\\<in>Collect (Domainp A).\n                                   x = a \\<and>\n                                   y = c \\<and> u a b \\<and> r b c)\n                    else bot\n               else bot)", "thus \"lfp ?lhs = lfp ?rhs\""], ["proof (prove)\nusing this:\n  (\\<lambda>p x y.\n      (\\<exists>a b.\n          x = a \\<and>\n          y = b \\<and> Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n      (\\<exists>a b c.\n          x = a \\<and>\n          y = c \\<and>\n          Domainp A a \\<and>\n          Domainp A b \\<and> Domainp A c \\<and> p a b \\<and> r b c)) =\n  (\\<lambda>p x y.\n      if Domainp A x\n      then if Domainp A y\n           then (\\<exists>a\\<in>Collect (Domainp A).\n                    \\<exists>b\\<in>Collect (Domainp A).\n                       x = a \\<and> y = b \\<and> r a b) \\<or>\n                (\\<exists>a\\<in>Collect (Domainp A).\n                    \\<exists>b\\<in>Collect (Domainp A).\n                       \\<exists>c\\<in>Collect (Domainp A).\n                          x = a \\<and> y = c \\<and> p a b \\<and> r b c)\n           else bot\n      else bot)\n\ngoal (1 subgoal):\n 1. lfp (\\<lambda>p x y.\n            (\\<exists>a b.\n                x = a \\<and>\n                y = b \\<and>\n                Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n            (\\<exists>a b c.\n                x = a \\<and>\n                y = c \\<and>\n                Domainp A a \\<and>\n                Domainp A b \\<and> Domainp A c \\<and> p a b \\<and> r b c)) =\n    lfp (\\<lambda>p x y.\n            if Domainp A x\n            then if Domainp A y\n                 then (\\<exists>a\\<in>Collect (Domainp A).\n                          \\<exists>b\\<in>Collect (Domainp A).\n                             x = a \\<and> y = b \\<and> r a b) \\<or>\n                      (\\<exists>a\\<in>Collect (Domainp A).\n                          \\<exists>b\\<in>Collect (Domainp A).\n                             \\<exists>c\\<in>Collect (Domainp A).\n                                x = a \\<and>\n                                y = c \\<and> p a b \\<and> r b c)\n                 else bot\n            else bot)", "by clarsimp"], ["proof (state)\nthis:\n  lfp (\\<lambda>p x y.\n          (\\<exists>a b.\n              x = a \\<and>\n              y = b \\<and>\n              Domainp A a \\<and> Domainp A b \\<and> r a b) \\<or>\n          (\\<exists>a b c.\n              x = a \\<and>\n              y = c \\<and>\n              Domainp A a \\<and>\n              Domainp A b \\<and> Domainp A c \\<and> p a b \\<and> r b c)) =\n  lfp (\\<lambda>p x y.\n          if Domainp A x\n          then if Domainp A y\n               then (\\<exists>a\\<in>Collect (Domainp A).\n                        \\<exists>b\\<in>Collect (Domainp A).\n                           x = a \\<and> y = b \\<and> r a b) \\<or>\n                    (\\<exists>a\\<in>Collect (Domainp A).\n                        \\<exists>b\\<in>Collect (Domainp A).\n                           \\<exists>c\\<in>Collect (Domainp A).\n                              x = a \\<and> y = c \\<and> p a b \\<and> r b c)\n               else bot\n          else bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trancl_rt_bu_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(rel_set (rel_prod A A) ===> rel_set (rel_prod A A)) \n      (trancl_on (Collect (Domainp A))) trancl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_prod A A) ===> rel_set (rel_prod A A))\n     (trancl_on (Collect (Domainp A))) trancl", "unfolding trancl_on_def trancl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_prod A A) ===> rel_set (rel_prod A A))\n     (\\<lambda>r.\n         {(x, y).\n          on (\\<lambda>x. x \\<in> Collect (Domainp A))\n           (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ x y})\n     (\\<lambda>r.\n         {(xa, x). (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ xa x})", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (?Ri12 ===> ?Rj12 ===> ?Rl12) ?ad12 Pair\n 2. Transfer.Rel (?Rl12 ===> rel_set (rel_prod A A) ===> ?Rk12) ?ac12\n     (\\<in>)\n 3. Transfer.Rel\n     ((?Ri12 ===> ?Rj12 ===> ?Rk12) ===> ?Rf12 ===> ?Rg12 ===> ?Rh12) ?ab12\n     tranclp\n 4. Transfer.Rel ((?Rf12 ===> ?Rg12 ===> ?Rh12) ===> ?Rd12) ?aa12 case_prod\n 5. Transfer.Rel (?Rd12 ===> rel_set (rel_prod A A)) ?a12 Collect\n 6. (\\<lambda>r.\n        {(x, y).\n         on (\\<lambda>x. x \\<in> Collect (Domainp A))\n          (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ x y}) =\n    (\\<lambda>r. ?a12 (?aa12 (?ab12 (\\<lambda>x xa. ?ac12 (?ad12 x xa) r))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>r.\n        {(x, y).\n         on (\\<lambda>x. x \\<in> Collect (Domainp A))\n          (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ x y}) =\n    (\\<lambda>r.\n        {x. (case x of\n             (x, xa) \\<Rightarrow>\n               on (Domainp A)\n                (\\<lambda>x xa. (x, xa) \\<in> r)\\<^sup>+\\<^sup>+ x\n                xa) \\<and>\n            pred_prod (Domainp A) (Domainp A) x})", "by (auto simp: tranclp_on_imp_P[where U=\"Domainp A\"])"], ["", "lemma acyclic_rt_bu_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((rel_set (rel_prod A A)) ===> (=)) \n      (acyclic_on (Collect (Domainp A))) acyclic\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_prod A A) ===> (=)) (acyclic_on (Collect (Domainp A)))\n     acyclic", "unfolding acyclic_on_def acyclic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_set (rel_prod A A) ===> (=))\n     (\\<lambda>r.\n         \\<forall>x\\<in>Collect (Domainp A).\n            (x, x) \\<notin> on (Collect (Domainp A)) r\\<^sup>+)\n     (\\<lambda>r. \\<forall>x. (x, x) \\<notin> r\\<^sup>+)", "by transfer_prover"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}