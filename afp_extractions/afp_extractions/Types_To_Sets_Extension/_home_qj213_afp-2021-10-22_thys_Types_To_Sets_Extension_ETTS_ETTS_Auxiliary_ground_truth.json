{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/ETTS/ETTS_Auxiliary.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma Domainp_eq[transfer_domain_rule, transfer_rule]: \n  \"Domainp (=) = (\\<lambda>x. x \\<in> UNIV)\"", "lemma Domainp_rel_prod[transfer_domain_rule, transfer_rule]:\n  assumes \"Domainp cr\\<^sub>1 = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1)\" and \"Domainp cr\\<^sub>2 = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>2)\"\n  shows \"Domainp (rel_prod cr\\<^sub>1 cr\\<^sub>2) = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1 \\<times> \\<UU>\\<^sub>2)\"", "lemma const_fun_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" and \"\\<forall>x \\<in> \\<UU>A. f x = c\" and \"B c c'\"\n  shows \"(A ===> B) f (const_fun c')\"", "lemma Domainp_eq_Collect: \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>) = (\\<UU> = Collect (Domainp A))\"", "lemma tts_rel_set_transfer:\n  fixes A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n  assumes \"S \\<subseteq> Collect (Domainp A)\" \n  shows \"\\<exists>S'. rel_set A S S'\"", "lemma tts_AB_transfer:\n  fixes f :: \"'al \\<Rightarrow> 'bl\"\n    and A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n  assumes closed: \"f ` \\<UU>A \\<subseteq> \\<UU>B\"\n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"\\<exists>rcdt. (A ===> B) f rcdt\"", "lemma tts_AB_transfer':\n  fixes f' :: \"'ar \\<Rightarrow> 'br\"\n    and A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"\\<exists>f. (A ===> B) f f'\"", "lemma tts_AB_C_transfer: \n  fixes f :: \"'al \\<Rightarrow> 'bl \\<Rightarrow> 'cl\" \n    and A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n    and C :: \"'cl \\<Rightarrow> 'cr \\<Rightarrow> bool\" \n  assumes closed: \"\\<And>a b. \\<lbrakk> a \\<in> \\<UU>A; b \\<in> \\<UU>B \\<rbrakk> \\<Longrightarrow> f a b \\<in> \\<UU>C\"\n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n    \"Domainp C = (\\<lambda>x. x \\<in> \\<UU>C)\" \"bi_unique C\" \"right_total C\"\n  shows \"\\<exists>rcdt. (A ===> B ===> C) f rcdt\"", "lemma tts_AA_A_transfer: \n  fixes A :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" and f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes closed: \"\\<And>a b. \\<lbrakk> a \\<in> \\<UU>; b \\<in> \\<UU> \\<rbrakk> \\<Longrightarrow> f a b \\<in> \\<UU>\"\n  assumes \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>)\" \"bi_unique A\" \"right_total A\" \n  shows \"\\<exists>rcdt. (A ===> A ===> A) f rcdt\"", "lemma tts_AA_eq_transfer: \n  fixes A :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" and f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>)\" \"bi_unique A\" \"right_total A\" \n  shows \"\\<exists>rcdt. (A ===> A ===> (=)) f rcdt\"", "lemma Dom_fun_eq_set:\n  assumes\n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"{f. f ` \\<UU>A \\<subseteq> \\<UU>B} = Collect (Domainp (A ===> B))\"", "lemma Dom_AB_eq_pred: \n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"(Domainp (A ===> B) f) = (f ` \\<UU>A \\<subseteq> \\<UU>B)\""], "translations": [["", "lemma Domainp_eq[transfer_domain_rule, transfer_rule]: \n  \"Domainp (=) = (\\<lambda>x. x \\<in> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (=) = (\\<lambda>x. x \\<in> UNIV)", "by auto"], ["", "lemma Domainp_rel_prod[transfer_domain_rule, transfer_rule]:\n  assumes \"Domainp cr\\<^sub>1 = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1)\" and \"Domainp cr\\<^sub>2 = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>2)\"\n  shows \"Domainp (rel_prod cr\\<^sub>1 cr\\<^sub>2) = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1 \\<times> \\<UU>\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (rel_prod cr\\<^sub>1 cr\\<^sub>2) =\n    (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1 \\<times> \\<UU>\\<^sub>2)", "using assms"], ["proof (prove)\nusing this:\n  Domainp cr\\<^sub>1 = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1)\n  Domainp cr\\<^sub>2 = (\\<lambda>x. x \\<in> \\<UU>\\<^sub>2)\n\ngoal (1 subgoal):\n 1. Domainp (rel_prod cr\\<^sub>1 cr\\<^sub>2) =\n    (\\<lambda>x. x \\<in> \\<UU>\\<^sub>1 \\<times> \\<UU>\\<^sub>2)", "by (simp add: ctr_simps_pred_prod_eq_cart prod.Domainp_rel)"], ["", "subsection\\<open>Constant function\\<close>"], ["", "definition const_fun :: \"['b, 'a] \\<Rightarrow> 'b\" where \"const_fun c = (\\<lambda>x. c)\""], ["", "lemma const_fun_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" and \"\\<forall>x \\<in> \\<UU>A. f x = c\" and \"B c c'\"\n  shows \"(A ===> B) f (const_fun c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B) f (const_fun c')", "proof(intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. A x y \\<Longrightarrow> B (f x) (const_fun c' y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. A x y \\<Longrightarrow> B (f x) (const_fun c' y)", "assume \"A x y\""], ["proof (state)\nthis:\n  A x y\n\ngoal (1 subgoal):\n 1. \\<And>x y. A x y \\<Longrightarrow> B (f x) (const_fun c' y)", "then"], ["proof (chain)\npicking this:\n  A x y", "have \"x \\<in> \\<UU>A\""], ["proof (prove)\nusing this:\n  A x y\n\ngoal (1 subgoal):\n 1. x \\<in> \\<UU>A", "by (meson Domainp.DomainI assms(1))"], ["proof (state)\nthis:\n  x \\<in> \\<UU>A\n\ngoal (1 subgoal):\n 1. \\<And>x y. A x y \\<Longrightarrow> B (f x) (const_fun c' y)", "then"], ["proof (chain)\npicking this:\n  x \\<in> \\<UU>A", "have \"f x = c\""], ["proof (prove)\nusing this:\n  x \\<in> \\<UU>A\n\ngoal (1 subgoal):\n 1. f x = c", "by (rule assms(2)[rule_format])"], ["proof (state)\nthis:\n  f x = c\n\ngoal (1 subgoal):\n 1. \\<And>x y. A x y \\<Longrightarrow> B (f x) (const_fun c' y)", "show \"B (f x) (const_fun c' y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B (f x) (const_fun c' y)", "unfolding \\<open>f x = c\\<close> const_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. B c c'", "by (rule assms(3))"], ["proof (state)\nthis:\n  B (f x) (const_fun c' y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Transfer rules suitable for instantiation\\<close>"], ["", "lemma Domainp_eq_Collect: \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>) = (\\<UU> = Collect (Domainp A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Domainp A = (\\<lambda>x. x \\<in> \\<UU>)) =\n    (\\<UU> = Collect (Domainp A))", "by (metis mem_Collect_eq pred_equals_eq)"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma tts_rel_set_transfer:\n  fixes A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n  assumes \"S \\<subseteq> Collect (Domainp A)\" \n  shows \"\\<exists>S'. rel_set A S S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S'. rel_set A S S'", "by (metis assms(1)[folded Ball_Collect] DomainpE Domainp_set)"], ["", "lemma tts_AB_transfer:\n  fixes f :: \"'al \\<Rightarrow> 'bl\"\n    and A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n  assumes closed: \"f ` \\<UU>A \\<subseteq> \\<UU>B\"\n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"\\<exists>rcdt. (A ===> B) f rcdt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "from closed"], ["proof (chain)\npicking this:\n  f ` \\<UU>A \\<subseteq> \\<UU>B", "have closed': \"x \\<in> \\<UU>A \\<Longrightarrow> f x \\<in> \\<UU>B\" for x"], ["proof (prove)\nusing this:\n  f ` \\<UU>A \\<subseteq> \\<UU>B\n\ngoal (1 subgoal):\n 1. x \\<in> \\<UU>A \\<Longrightarrow> f x \\<in> \\<UU>B", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> \\<UU>A \\<Longrightarrow> f ?x \\<in> \\<UU>B\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "from assms(3,4)"], ["proof (chain)\npicking this:\n  bi_unique A\n  right_total A", "obtain Rep_a :: \"'ar \\<Rightarrow> 'al\" and Abs_a :: \"'al \\<Rightarrow> 'ar\" \n    where td_a: \"type_definition Rep_a Abs_a (Collect (Domainp A))\"\n      and A_Rep: \"A b b' = (b = Rep_a b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique A\n  right_total A\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_a Abs_a.\n        \\<lbrakk>type_definition Rep_a Abs_a (Collect (Domainp A));\n         \\<And>b b'. A b b' = (b = Rep_a b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n  A ?b ?b' = (?b = Rep_a ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "from assms(6,7)"], ["proof (chain)\npicking this:\n  bi_unique B\n  right_total B", "obtain Rep_b :: \"'br \\<Rightarrow> 'bl\" and Abs_b :: \"'bl \\<Rightarrow> 'br\" \n    where td_b: \"type_definition Rep_b Abs_b (Collect (Domainp B))\"\n      and B_Rep: \"B b b' = (b = Rep_b b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique B\n  right_total B\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_b Abs_b.\n        \\<lbrakk>type_definition Rep_b Abs_b (Collect (Domainp B));\n         \\<And>b b'. B b b' = (b = Rep_b b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n  B ?b ?b' = (?b = Rep_b ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "define f' where f': \"f' = (Rep_a ---> Abs_b) f\""], ["proof (state)\nthis:\n  f' = (Rep_a ---> Abs_b) f\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "have f_closed: \"f (Rep_a a) \\<in> \\<UU>B\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (Rep_a a) \\<in> \\<UU>B", "using td_a td_b"], ["proof (prove)\nusing this:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. f (Rep_a a) \\<in> \\<UU>B", "by (intro closed') (simp add: assms(2,5))+"], ["proof (state)\nthis:\n  f (Rep_a ?a) \\<in> \\<UU>B\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "have rep_abs_b: \"y \\<in> \\<UU>B \\<Longrightarrow> y = Rep_b (Abs_b y)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> \\<UU>B \\<Longrightarrow> y = Rep_b (Abs_b y)", "using td_b"], ["proof (prove)\nusing this:\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n\ngoal (1 subgoal):\n 1. y \\<in> \\<UU>B \\<Longrightarrow> y = Rep_b (Abs_b y)", "unfolding type_definition_def"], ["proof (prove)\nusing this:\n  (\\<forall>x. Rep_b x \\<in> Collect (Domainp B)) \\<and>\n  (\\<forall>x. Abs_b (Rep_b x) = x) \\<and>\n  (\\<forall>y.\n      y \\<in> Collect (Domainp B) \\<longrightarrow> Rep_b (Abs_b y) = y)\n\ngoal (1 subgoal):\n 1. y \\<in> \\<UU>B \\<Longrightarrow> y = Rep_b (Abs_b y)", "by (simp add: assms(5))"], ["proof (state)\nthis:\n  ?y \\<in> \\<UU>B \\<Longrightarrow> ?y = Rep_b (Abs_b ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "have \"(A ===> B) f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B) f f'", "unfolding f' map_fun_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B) f (\\<lambda>x. Abs_b (f (Rep_a x)))", "by \n      (\n        intro rel_funI, \n        unfold A_Rep B_Rep,\n        elim ssubst, \n        intro rep_abs_b f_closed\n      )"], ["proof (state)\nthis:\n  (A ===> B) f f'\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "then"], ["proof (chain)\npicking this:\n  (A ===> B) f f'", "show ?thesis"], ["proof (prove)\nusing this:\n  (A ===> B) f f'\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B) f rcdt", "by auto"], ["proof (state)\nthis:\n  \\<exists>rcdt. (A ===> B) f rcdt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tts_AB_transfer':\n  fixes f' :: \"'ar \\<Rightarrow> 'br\"\n    and A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"\\<exists>f. (A ===> B) f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "from assms(2,3)"], ["proof (chain)\npicking this:\n  bi_unique A\n  right_total A", "obtain Rep_a :: \"'ar \\<Rightarrow> 'al\" and Abs_a :: \"'al \\<Rightarrow> 'ar\" \n    where td_a: \"type_definition Rep_a Abs_a (Collect (Domainp A))\"\n      and A_Rep: \"A b b' = (b = Rep_a b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique A\n  right_total A\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_a Abs_a.\n        \\<lbrakk>type_definition Rep_a Abs_a (Collect (Domainp A));\n         \\<And>b b'. A b b' = (b = Rep_a b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n  A ?b ?b' = (?b = Rep_a ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "from assms(5,6)"], ["proof (chain)\npicking this:\n  bi_unique B\n  right_total B", "obtain Rep_b :: \"'br \\<Rightarrow> 'bl\" and Abs_b :: \"'bl \\<Rightarrow> 'br\" \n    where td_b: \"type_definition Rep_b Abs_b (Collect (Domainp B))\"\n      and B_Rep: \"B b b' = (b = Rep_b b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique B\n  right_total B\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_b Abs_b.\n        \\<lbrakk>type_definition Rep_b Abs_b (Collect (Domainp B));\n         \\<And>b b'. B b b' = (b = Rep_b b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n  B ?b ?b' = (?b = Rep_b ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "define f where f: \"f = (Abs_a ---> Rep_b) f'\""], ["proof (state)\nthis:\n  f = (Abs_a ---> Rep_b) f'\n\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "have abs_rep_a: \"y = Abs_a (Rep_a y)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y = Abs_a (Rep_a y)", "using td_a"], ["proof (prove)\nusing this:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n\ngoal (1 subgoal):\n 1. y = Abs_a (Rep_a y)", "unfolding type_definition_def"], ["proof (prove)\nusing this:\n  (\\<forall>x. Rep_a x \\<in> Collect (Domainp A)) \\<and>\n  (\\<forall>x. Abs_a (Rep_a x) = x) \\<and>\n  (\\<forall>y.\n      y \\<in> Collect (Domainp A) \\<longrightarrow> Rep_a (Abs_a y) = y)\n\ngoal (1 subgoal):\n 1. y = Abs_a (Rep_a y)", "by simp"], ["proof (state)\nthis:\n  ?y = Abs_a (Rep_a ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "have \"(A ===> B) f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B) f f'", "unfolding f map_fun_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B) (\\<lambda>x. Rep_b (f' (Abs_a x))) f'", "by \n      (\n        intro rel_funI, \n        unfold A_Rep B_Rep,\n        elim ssubst, \n        fold abs_rep_a, \n        intro refl\n      )"], ["proof (state)\nthis:\n  (A ===> B) f f'\n\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "then"], ["proof (chain)\npicking this:\n  (A ===> B) f f'", "show ?thesis"], ["proof (prove)\nusing this:\n  (A ===> B) f f'\n\ngoal (1 subgoal):\n 1. \\<exists>f. (A ===> B) f f'", "by auto"], ["proof (state)\nthis:\n  \\<exists>f. (A ===> B) f f'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tts_AB_C_transfer: \n  fixes f :: \"'al \\<Rightarrow> 'bl \\<Rightarrow> 'cl\" \n    and A :: \"'al \\<Rightarrow> 'ar \\<Rightarrow> bool\"\n    and B :: \"'bl \\<Rightarrow> 'br \\<Rightarrow> bool\"\n    and C :: \"'cl \\<Rightarrow> 'cr \\<Rightarrow> bool\" \n  assumes closed: \"\\<And>a b. \\<lbrakk> a \\<in> \\<UU>A; b \\<in> \\<UU>B \\<rbrakk> \\<Longrightarrow> f a b \\<in> \\<UU>C\"\n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n    \"Domainp C = (\\<lambda>x. x \\<in> \\<UU>C)\" \"bi_unique C\" \"right_total C\"\n  shows \"\\<exists>rcdt. (A ===> B ===> C) f rcdt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "from assms(3,4)"], ["proof (chain)\npicking this:\n  bi_unique A\n  right_total A", "obtain Rep_a :: \"'ar \\<Rightarrow> 'al\" and Abs_a :: \"'al \\<Rightarrow> 'ar\" \n    where td_a: \"type_definition Rep_a Abs_a (Collect (Domainp A))\"\n      and A_Rep: \"A b b' = (b = Rep_a b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique A\n  right_total A\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_a Abs_a.\n        \\<lbrakk>type_definition Rep_a Abs_a (Collect (Domainp A));\n         \\<And>b b'. A b b' = (b = Rep_a b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n  A ?b ?b' = (?b = Rep_a ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "from assms(6,7)"], ["proof (chain)\npicking this:\n  bi_unique B\n  right_total B", "obtain Rep_b :: \"'br \\<Rightarrow> 'bl\" and Abs_b :: \"'bl \\<Rightarrow> 'br\" \n    where td_b: \"type_definition Rep_b Abs_b (Collect (Domainp B))\"\n      and B_Rep: \"B b b' = (b = Rep_b b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique B\n  right_total B\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_b Abs_b.\n        \\<lbrakk>type_definition Rep_b Abs_b (Collect (Domainp B));\n         \\<And>b b'. B b b' = (b = Rep_b b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n  B ?b ?b' = (?b = Rep_b ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "from assms(9,10)"], ["proof (chain)\npicking this:\n  bi_unique C\n  right_total C", "obtain Rep_c :: \"'cr \\<Rightarrow> 'cl\" and Abs_c :: \"'cl \\<Rightarrow> 'cr\" \n    where td_c: \"type_definition Rep_c Abs_c (Collect (Domainp C))\"\n      and C_Rep: \"C b b' = (b = Rep_c b')\" for b b'"], ["proof (prove)\nusing this:\n  bi_unique C\n  right_total C\n\ngoal (1 subgoal):\n 1. (\\<And>Rep_c Abs_c.\n        \\<lbrakk>type_definition Rep_c Abs_c (Collect (Domainp C));\n         \\<And>b b'. C b b' = (b = Rep_c b')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: ex_type_definition)"], ["proof (state)\nthis:\n  type_definition Rep_c Abs_c (Collect (Domainp C))\n  C ?b ?b' = (?b = Rep_c ?b')\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "define f' where f': \"f' = (Rep_a ---> Rep_b ---> Abs_c) f\""], ["proof (state)\nthis:\n  f' = (Rep_a ---> Rep_b ---> Abs_c) f\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "from td_a td_b td_c"], ["proof (chain)\npicking this:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n  type_definition Rep_c Abs_c (Collect (Domainp C))", "have f_closed: \"f (Rep_a a) (Rep_b b) \\<in> \\<UU>C\" for a b"], ["proof (prove)\nusing this:\n  type_definition Rep_a Abs_a (Collect (Domainp A))\n  type_definition Rep_b Abs_b (Collect (Domainp B))\n  type_definition Rep_c Abs_c (Collect (Domainp C))\n\ngoal (1 subgoal):\n 1. f (Rep_a a) (Rep_b b) \\<in> \\<UU>C", "by (intro closed; simp_all add: assms(2,5,8))+"], ["proof (state)\nthis:\n  f (Rep_a ?a) (Rep_b ?b) \\<in> \\<UU>C\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "have rep_abs_c: \"y \\<in> \\<UU>C \\<Longrightarrow> y = Rep_c (Abs_c y)\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> \\<UU>C \\<Longrightarrow> y = Rep_c (Abs_c y)", "using td_c"], ["proof (prove)\nusing this:\n  type_definition Rep_c Abs_c (Collect (Domainp C))\n\ngoal (1 subgoal):\n 1. y \\<in> \\<UU>C \\<Longrightarrow> y = Rep_c (Abs_c y)", "unfolding type_definition_def"], ["proof (prove)\nusing this:\n  (\\<forall>x. Rep_c x \\<in> Collect (Domainp C)) \\<and>\n  (\\<forall>x. Abs_c (Rep_c x) = x) \\<and>\n  (\\<forall>y.\n      y \\<in> Collect (Domainp C) \\<longrightarrow> Rep_c (Abs_c y) = y)\n\ngoal (1 subgoal):\n 1. y \\<in> \\<UU>C \\<Longrightarrow> y = Rep_c (Abs_c y)", "by (simp add: assms(8))"], ["proof (state)\nthis:\n  ?y \\<in> \\<UU>C \\<Longrightarrow> ?y = Rep_c (Abs_c ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "have \"(A ===> B ===> C) f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B ===> C) f f'", "unfolding f' map_fun_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> B ===> C) f (\\<lambda>x xa. Abs_c (f (Rep_a x) (Rep_b xa)))", "by \n      (\n        intro rel_funI, \n        unfold A_Rep B_Rep C_Rep,\n        elim ssubst, \n        intro rep_abs_c f_closed\n      )"], ["proof (state)\nthis:\n  (A ===> B ===> C) f f'\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "then"], ["proof (chain)\npicking this:\n  (A ===> B ===> C) f f'", "show ?thesis"], ["proof (prove)\nusing this:\n  (A ===> B ===> C) f f'\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> B ===> C) f rcdt", "by auto"], ["proof (state)\nthis:\n  \\<exists>rcdt. (A ===> B ===> C) f rcdt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tts_AA_A_transfer: \n  fixes A :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" and f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  assumes closed: \"\\<And>a b. \\<lbrakk> a \\<in> \\<UU>; b \\<in> \\<UU> \\<rbrakk> \\<Longrightarrow> f a b \\<in> \\<UU>\"\n  assumes \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>)\" \"bi_unique A\" \"right_total A\" \n  shows \"\\<exists>rcdt. (A ===> A ===> A) f rcdt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> A) f rcdt", "using closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> \\<UU>; ?b \\<in> \\<UU>\\<rbrakk>\n  \\<Longrightarrow> f ?a ?b \\<in> \\<UU>\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> A) f rcdt", "by (rule tts_AB_C_transfer[OF _ assms(2-4) assms(2-4) assms(2-4)])"], ["", "lemma tts_AA_eq_transfer: \n  fixes A :: \"'a \\<Rightarrow> 'b \\<Rightarrow> bool\" and f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\"\n  assumes \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>)\" \"bi_unique A\" \"right_total A\" \n  shows \"\\<exists>rcdt. (A ===> A ===> (=)) f rcdt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> (=)) f rcdt", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> (=)) f rcdt", "have closed: \"f x y \\<in> UNIV\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  f ?x ?y \\<in> UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> (=)) f rcdt", "have dom_eq: \"Domainp (=) = (\\<lambda>x. x \\<in> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (=) = (\\<lambda>x. x \\<in> UNIV)", "by auto"], ["proof (state)\nthis:\n  Domainp (=) = (\\<lambda>x. x \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> (=)) f rcdt", "from tts_AB_C_transfer[\n      OF _ assms(1-3) assms(1-3) dom_eq bi_unique_eq right_total_eq\n      ]"], ["proof (chain)\npicking this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> \\<UU>; b \\<in> \\<UU>\\<rbrakk>\n      \\<Longrightarrow> ?f a b \\<in> UNIV) \\<Longrightarrow>\n  \\<exists>rcdt. (A ===> A ===> (=)) ?f rcdt", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> \\<UU>; b \\<in> \\<UU>\\<rbrakk>\n      \\<Longrightarrow> ?f a b \\<in> UNIV) \\<Longrightarrow>\n  \\<exists>rcdt. (A ===> A ===> (=)) ?f rcdt\n\ngoal (1 subgoal):\n 1. \\<exists>rcdt. (A ===> A ===> (=)) f rcdt", "by auto"], ["proof (state)\nthis:\n  \\<exists>rcdt. (A ===> A ===> (=)) f rcdt\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Dom_fun_eq_set:\n  assumes\n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"{f. f ` \\<UU>A \\<subseteq> \\<UU>B} = Collect (Domainp (A ===> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f. f ` \\<UU>A \\<subseteq> \\<UU>B} = Collect (Domainp (A ===> B))", "proof(standard; (standard, intro CollectI, elim CollectE DomainpE))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x ` \\<UU>A \\<subseteq> \\<UU>B \\<Longrightarrow> Domainp (A ===> B) x\n 2. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x ` \\<UU>A \\<subseteq> \\<UU>B \\<Longrightarrow> Domainp (A ===> B) x\n 2. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "assume \"x ` \\<UU>A \\<subseteq> \\<UU>B\""], ["proof (state)\nthis:\n  x ` \\<UU>A \\<subseteq> \\<UU>B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x ` \\<UU>A \\<subseteq> \\<UU>B \\<Longrightarrow> Domainp (A ===> B) x\n 2. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "from tts_AB_transfer[OF this assms]"], ["proof (chain)\npicking this:\n  \\<exists>rcdt. (A ===> B) x rcdt", "obtain x' where xx': \n    \"(A ===> B) x x'\""], ["proof (prove)\nusing this:\n  \\<exists>rcdt. (A ===> B) x rcdt\n\ngoal (1 subgoal):\n 1. (\\<And>x'. (A ===> B) x x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  (A ===> B) x x'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x ` \\<UU>A \\<subseteq> \\<UU>B \\<Longrightarrow> Domainp (A ===> B) x\n 2. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "show \"Domainp (A ===> B) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (A ===> B) x", "by standard (rule xx')"], ["proof (state)\nthis:\n  Domainp (A ===> B) x\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "fix x b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "assume \"(A ===> B) x b\""], ["proof (state)\nthis:\n  (A ===> B) x b\n\ngoal (1 subgoal):\n 1. \\<And>x b.\n       (A ===> B) x b \\<Longrightarrow> x ` \\<UU>A \\<subseteq> \\<UU>B", "then"], ["proof (chain)\npicking this:\n  (A ===> B) x b", "show \"x ` \\<UU>A \\<subseteq> \\<UU>B\""], ["proof (prove)\nusing this:\n  (A ===> B) x b\n\ngoal (1 subgoal):\n 1. x ` \\<UU>A \\<subseteq> \\<UU>B", "unfolding \n      rel_fun_def \n      Domainp_eq_Collect[THEN iffD1, OF assms(1)] \n      Domainp_eq_Collect[THEN iffD1, OF assms(4)]"], ["proof (prove)\nusing this:\n  \\<forall>xa y. A xa y \\<longrightarrow> B (x xa) (b y)\n\ngoal (1 subgoal):\n 1. x ` Collect (Domainp A) \\<subseteq> Collect (Domainp B)", "by auto"], ["proof (state)\nthis:\n  x ` \\<UU>A \\<subseteq> \\<UU>B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Dom_AB_eq_pred: \n  assumes \n    \"Domainp A = (\\<lambda>x. x \\<in> \\<UU>A)\" \"bi_unique A\" \"right_total A\" \n    \"Domainp B = (\\<lambda>x. x \\<in> \\<UU>B)\" \"bi_unique B\" \"right_total B\" \n  shows \"(Domainp (A ===> B) f) = (f ` \\<UU>A \\<subseteq> \\<UU>B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp (A ===> B) f = (f ` \\<UU>A \\<subseteq> \\<UU>B)", "using Dom_fun_eq_set[OF assms]"], ["proof (prove)\nusing this:\n  {f. f ` \\<UU>A \\<subseteq> \\<UU>B} = Collect (Domainp (A ===> B))\n\ngoal (1 subgoal):\n 1. Domainp (A ===> B) f = (f ` \\<UU>A \\<subseteq> \\<UU>B)", "by blast"], ["", "end"], ["", "end"]]}