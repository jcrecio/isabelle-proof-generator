{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/SML_Relativization/Algebra/SML_Semirings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma semiring_ow: \"class.semiring = semiring_ow UNIV\"", "lemma semiring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=)) \n      (semiring_ow (Collect (Domainp A))) class.semiring\"", "lemma comm_semiring_ow: \"class.comm_semiring = comm_semiring_ow UNIV\"", "lemma comm_semiring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=)) \n      (comm_semiring_ow (Collect (Domainp A))) class.comm_semiring\"\n    (is \"?PR (comm_semiring_ow (Collect (Domainp A))) class.comm_semiring\")", "lemma mult_zero_ow: \"class.mult_zero = mult_zero_ow UNIV\"", "lemma semiring_0_ow: \"class.semiring_0 = semiring_0_ow UNIV\"", "lemma semiring_0_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=)) \n      (semiring_0_ow (Collect (Domainp A))) class.semiring_0\"\n    (is \"?PR (semiring_0_ow (Collect (Domainp A))) class.semiring_0\")", "lemma comm_semiring_0_ow: \"class.comm_semiring_0 = comm_semiring_0_ow UNIV\"", "lemma comm_semiring_0_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=)) \n      (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0\"\n    (is \"?PR (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0\")", "lemma semiring_0_cancel_ow: \n  \"class.semiring_0_cancel = semiring_0_cancel_ow UNIV\"", "lemma semiring_0_cancel_transfer[transfer_rule]: \n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) (semiring_0_cancel_ow (Collect (Domainp A))) class.semiring_0_cancel\"", "lemma comm_semiring_0_cancel_ow: \n  \"class.comm_semiring_0_cancel = comm_semiring_0_cancel_ow UNIV\"", "lemma comm_semiring_0_cancel_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) \n    (comm_semiring_0_cancel_ow (Collect (Domainp A))) \n    class.comm_semiring_0_cancel\"", "lemma zero_neq_one_ow: \"class.zero_neq_one = zero_neq_one_ow UNIV\"", "lemma zero_neq_one_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\"  \n  shows \n    \"(A ===> A ===> (=)) \n      (zero_neq_one_ow (Collect (Domainp A))) class.zero_neq_one\" \n    (is \"?PR (zero_neq_one_ow (Collect (Domainp A))) class.zero_neq_one\")", "lemma semiring_1_ow: \"class.semiring_1 = semiring_1_ow UNIV\"", "lemma Nat_ss_UNIV: \"\\<nat> \\<subseteq> UNIV\"", "lemma semiring_1_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(A ===> (A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=)) \n      (semiring_1_ow (Collect (Domainp A))) class.semiring_1\"", "lemma Nat_closed[simp, intro]: \"a \\<in> \\<guillemotleft>\\<nat>\\<guillemotright> \\<Longrightarrow> a \\<in> U\"", "lemma comm_semiring_1_ow: \"class.comm_semiring_1 = comm_semiring_1_ow UNIV\"", "lemma comm_semiring_1_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> A ===> (=)) \n      (comm_semiring_1_ow (Collect (Domainp A))) class.comm_semiring_1\"", "lemma semiring_1_cancel_ow: \n  \"class.semiring_1_cancel = semiring_1_cancel_ow UNIV\"", "lemma semiring_1_cancel_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) (semiring_1_cancel_ow (Collect (Domainp A))) class.semiring_1_cancel\"", "lemma comm_semiring_1_cancel_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (=)\n    ) \n    (comm_semiring_1_cancel_ow (Collect (Domainp A))) \n    class.comm_semiring_1_cancel\""], "translations": [["", "lemma semiring_ow: \"class.semiring = semiring_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring = semiring_ow UNIV", "unfolding \n    class.semiring_def semiring_ow_def\n    class.semiring_axioms_def semiring_ow_axioms_def\n    ab_semigroup_add_ow semigroup_mult_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus times.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a b c.\n            times (plus a b) c = plus (times a c) (times b c)) \\<and>\n        (\\<forall>a b c.\n            times a (plus b c) = plus (times a b) (times a c))) =\n    (\\<lambda>plus times.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            times (plus a b) c = plus (times a c) (times b c)) \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            times a (plus b c) = plus (times a b) (times a c)))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma semiring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=)) \n      (semiring_ow (Collect (Domainp A))) class.semiring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (semiring_ow (Collect (Domainp A))) class.semiring", "unfolding \n    semiring_ow_def class.semiring_def\n    semiring_ow_axioms_def class.semiring_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus times.\n         ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             times (plus a b) c = plus (times a c) (times b c)) \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             times a (plus b c) = plus (times a b) (times a c)))\n     (\\<lambda>plus times.\n         class.ab_semigroup_add plus \\<and>\n         class.semigroup_mult times \\<and>\n         (\\<forall>a b c.\n             times (plus a b) c = plus (times a c) (times b c)) \\<and>\n         (\\<forall>a b c.\n             times a (plus b c) = plus (times a b) (times a c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (14 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rp41) ?al41 (=)\n 2. Transfer.Rel ((A ===> ?Rp41) ===> ?Ro41) ?ak41 All\n 3. Transfer.Rel ((A ===> ?Ro41) ===> ?Rn41) ?aj41 All\n 4. Transfer.Rel ((A ===> ?Rn41) ===> ?Rj41) ?ai41 All\n 5. Transfer.Rel (A ===> A ===> ?Rm41) ?ah41 (=)\n 6. Transfer.Rel ((A ===> ?Rm41) ===> ?Rl41) ?ag41 All\n 7. Transfer.Rel ((A ===> ?Rl41) ===> ?Rk41) ?af41 All\n 8. Transfer.Rel ((A ===> ?Rk41) ===> ?Ri41) ?ae41 All\n 9. Transfer.Rel (?Ri41 ===> ?Rj41 ===> ?Rh41) ?ad41 (\\<and>)\n 10. Transfer.Rel ((A ===> A ===> A) ===> ?Rg41) ?ac41 class.semigroup_mult\nA total of 14 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus times.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            times (plus a b) c = plus (times a c) (times b c)) \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            times a (plus b c) = plus (times a b) (times a c))) =\n    (\\<lambda>plus times.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  times (plus a b) c = plus (times a c) (times b c)) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  times a (plus b c) = plus (times a b) (times a c)))", "by simp"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context semiring_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  substituting semiring_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma combine_common_factor:\n  assumes \"a \\<in> U\" and \"e \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \"a *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w (b *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w c) = (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w c\"\n    is semiring_class.combine_common_factor"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Commutative semirings\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_semiring_ow = \n  ab_semigroup_add_ow U plus + ab_semigroup_mult_ow U times\n  for U :: \"'ag set\" and plus times +\n  assumes distrib: \n    \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\"\nbegin"], ["", "sublocale semiring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_ow U (+\\<^sub>o\\<^sub>w) (*\\<^sub>o\\<^sub>w)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c =\n                         a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w\n                         b *\\<^sub>o\\<^sub>w c\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n                         a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w\n                         a *\\<^sub>o\\<^sub>w c", "fix a b c :: 'ag"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c =\n                         a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w\n                         b *\\<^sub>o\\<^sub>w c\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n                         a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w\n                         a *\\<^sub>o\\<^sub>w c", "assume \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\""], ["proof (state)\nthis:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c =\n                         a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w\n                         b *\\<^sub>o\\<^sub>w c\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n                         a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w\n                         a *\\<^sub>o\\<^sub>w c", "then"], ["proof (chain)\npicking this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U", "show \"(a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\""], ["proof (prove)\nusing this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n\ngoal (1 subgoal):\n 1. (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c =\n    a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c", "by (simp only: distrib)"], ["proof (state)\nthis:\n  (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c =\n  a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk>\n       \\<Longrightarrow> a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n                         a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w\n                         a *\\<^sub>o\\<^sub>w c", "show \"a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) = a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c", "from \\<open>a \\<in> U\\<close> \\<open>b \\<in> U\\<close> \\<open>c \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U", "have \"a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) = (b +\\<^sub>o\\<^sub>w c) *\\<^sub>o\\<^sub>w a\""], ["proof (prove)\nusing this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    (b +\\<^sub>o\\<^sub>w c) *\\<^sub>o\\<^sub>w a", "by (simp add: mult_commute)"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  (b +\\<^sub>o\\<^sub>w c) *\\<^sub>o\\<^sub>w a\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c", "with \\<open>a \\<in> U\\<close> \\<open>b \\<in> U\\<close> \\<open>c \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  (b +\\<^sub>o\\<^sub>w c) *\\<^sub>o\\<^sub>w a", "have \"a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) = b *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a\""], ["proof (prove)\nusing this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  (b +\\<^sub>o\\<^sub>w c) *\\<^sub>o\\<^sub>w a\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    b *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a", "by (simp only: distrib)"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  b *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c", "with \\<open>a \\<in> U\\<close> \\<open>b \\<in> U\\<close> \\<open>c \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  b *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> U\n  b \\<in> U\n  c \\<in> U\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  b *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n    a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c", "by (simp only: mult_commute)"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) =\n  a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma comm_semiring_ow: \"class.comm_semiring = comm_semiring_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_semiring = comm_semiring_ow UNIV", "unfolding \n    class.comm_semiring_def comm_semiring_ow_def\n    class.comm_semiring_axioms_def comm_semiring_ow_axioms_def\n    ab_semigroup_add_ow ab_semigroup_mult_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus times.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        ab_semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a b c.\n            times (plus a b) c = plus (times a c) (times b c))) =\n    (\\<lambda>plus times.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        ab_semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            times (plus a b) c = plus (times a c) (times b c)))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma comm_semiring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=)) \n      (comm_semiring_ow (Collect (Domainp A))) class.comm_semiring\"\n    (is \"?PR (comm_semiring_ow (Collect (Domainp A))) class.comm_semiring\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_ow (Collect (Domainp A))) class.comm_semiring", "unfolding \n    comm_semiring_ow_def class.comm_semiring_def\n    comm_semiring_ow_axioms_def class.comm_semiring_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus times.\n         ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             times (plus a b) c = plus (times a c) (times b c)))\n     (\\<lambda>plus times.\n         class.ab_semigroup_add plus \\<and>\n         class.ab_semigroup_mult times \\<and>\n         (\\<forall>a b c.\n             times (plus a b) c = plus (times a c) (times b c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (9 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rl24) ?ag24 (=)\n 2. Transfer.Rel ((A ===> ?Rl24) ===> ?Rk24) ?af24 All\n 3. Transfer.Rel ((A ===> ?Rk24) ===> ?Rj24) ?ae24 All\n 4. Transfer.Rel ((A ===> ?Rj24) ===> ?Ri24) ?ad24 All\n 5. Transfer.Rel ((A ===> A ===> A) ===> ?Rh24) ?ac24\n     class.ab_semigroup_mult\n 6. Transfer.Rel (?Rh24 ===> ?Ri24 ===> ?Rf24) ?ab24 (\\<and>)\n 7. Transfer.Rel ((A ===> A ===> A) ===> ?Re24) ?aa24 class.ab_semigroup_add\n 8. Transfer.Rel (?Re24 ===> ?Rf24 ===> (=)) ?a24 (\\<and>)\n 9. (\\<lambda>plus times.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            times (plus a b) c = plus (times a c) (times b c))) =\n    (\\<lambda>plus times.\n        ?a24 (?aa24 plus)\n         (?ab24 (?ac24 times)\n           (?ad24\n             (\\<lambda>a.\n                 ?ae24\n                  (\\<lambda>b.\n                      ?af24\n                       (\\<lambda>c.\n                           ?ag24 (times (plus a b) c)\n                            (plus (times a c) (times b c))))))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus times.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            times (plus a b) c = plus (times a c) (times b c))) =\n    (\\<lambda>plus times.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  times (plus a b) c = plus (times a c) (times b c)))", "by simp"], ["", "end"], ["", "subsection\\<open>Semirings with zero\\<close>"], ["", "subsubsection\\<open>Definitions and further results\\<close>"], ["", "locale mult_zero_ow = times_ow U times + zero_ow U zero\n  for U :: \"'ag set\" and times zero +\n  assumes mult_zero_left[simp]: \"a \\<in> U \\<Longrightarrow> 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\"\n  assumes mult_zero_right[simp]: \"a \\<in> U \\<Longrightarrow> a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w\""], ["", "lemma mult_zero_ow: \"class.mult_zero = mult_zero_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.mult_zero = mult_zero_ow UNIV", "unfolding \n    class.mult_zero_def mult_zero_ow_def mult_zero_ow_axioms_def\n    times_ow_def zero_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times zero.\n        (\\<forall>a. times zero a = zero) \\<and>\n        (\\<forall>a. times a zero = zero)) =\n    (\\<lambda>times zero.\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> times a b \\<in> UNIV) \\<and>\n        zero \\<in> UNIV \\<and>\n        (\\<forall>a.\n            a \\<in> UNIV \\<longrightarrow> times zero a = zero) \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> times a zero = zero))", "by simp"], ["", "locale semiring_0_ow = \n  semiring_ow U plus times + \n  comm_monoid_add_ow U plus zero + \n  mult_zero_ow U times zero\n  for U :: \"'ag set\" and plus zero times"], ["", "lemma semiring_0_ow: \"class.semiring_0 = semiring_0_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_0 = semiring_0_ow UNIV", "unfolding \n    class.semiring_0_def semiring_0_ow_def  \n    mult_zero_ow comm_monoid_add_ow semiring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero times.\n        comm_monoid_add_ow UNIV plus zero \\<and>\n        mult_zero_ow UNIV times zero \\<and> semiring_ow UNIV plus times) =\n    (\\<lambda>plus zero times.\n        semiring_ow UNIV plus times \\<and>\n        comm_monoid_add_ow UNIV plus zero \\<and>\n        mult_zero_ow UNIV times zero)", "by (auto simp: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma semiring_0_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=)) \n      (semiring_0_ow (Collect (Domainp A))) class.semiring_0\"\n    (is \"?PR (semiring_0_ow (Collect (Domainp A))) class.semiring_0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_ow (Collect (Domainp A))) class.semiring_0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_ow (Collect (Domainp A))) class.semiring_0", "let ?semiring_0 =\n    \"(\n      \\<lambda>plus zero times. \n        class.semiring_0 plus zero times \\<and>\n        (\\<forall>a b. a \\<in> UNIV \\<longrightarrow> b \\<in> UNIV \\<longrightarrow> times a b \\<in> UNIV) \\<and> zero \\<in> UNIV\n    )\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_ow (Collect (Domainp A))) class.semiring_0", "have \"?PR (semiring_0_ow (Collect (Domainp A))) ?semiring_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_ow (Collect (Domainp A)))\n     (\\<lambda>a b c.\n         class.semiring_0 a b c \\<and>\n         (\\<forall>a b.\n             a \\<in> UNIV \\<longrightarrow>\n             b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n         b \\<in> UNIV)", "unfolding\n      semiring_0_ow_def  class.semiring_0_def\n      mult_zero_ow_def class.mult_zero_def\n      mult_zero_ow_axioms_def\n      times_ow_def zero_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>a b c.\n         semiring_ow (Collect (Domainp A)) a c \\<and>\n         comm_monoid_add_ow (Collect (Domainp A)) a b \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c a b \\<in> Collect (Domainp A)) \\<and>\n         b \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> c b a = b) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> c a b = b))\n     (\\<lambda>a b c.\n         (class.comm_monoid_add a b \\<and>\n          ((\\<forall>a. c b a = b) \\<and> (\\<forall>a. c a b = b)) \\<and>\n          class.semiring a c) \\<and>\n         (\\<forall>a b.\n             a \\<in> UNIV \\<longrightarrow>\n             b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n         b \\<in> UNIV)", "apply transfer_prover_start"], ["proof (prove)\ngoal (24 subgoals):\n 1. Transfer.Rel ?Rab43 ?av43 UNIV\n 2. Transfer.Rel (A ===> ?Rab43 ===> ?Rr43) ?au43 (\\<in>)\n 3. Transfer.Rel ?Raa43 ?at43 UNIV\n 4. Transfer.Rel (A ===> ?Raa43 ===> ?Ry43) ?as43 (\\<in>)\n 5. Transfer.Rel ?Rz43 ?ar43 UNIV\n 6. Transfer.Rel (A ===> ?Rz43 ===> ?Rx43) ?aq43 (\\<in>)\n 7. Transfer.Rel (?Rx43 ===> ?Ry43 ===> ?Rv43) ?ap43 (\\<longrightarrow>)\n 8. Transfer.Rel ?Rw43 ?ao43 UNIV\n 9. Transfer.Rel (A ===> ?Rw43 ===> ?Ru43) ?an43 (\\<in>)\n 10. Transfer.Rel (?Ru43 ===> ?Rv43 ===> ?Rt43) ?am43 (\\<longrightarrow>)\nA total of 24 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b c.\n        semiring_ow (Collect (Domainp A)) a c \\<and>\n        comm_monoid_add_ow (Collect (Domainp A)) a b \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c a b \\<in> Collect (Domainp A)) \\<and>\n        b \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> c b a = b) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> c a b = b)) =\n    (\\<lambda>a b c.\n        (comm_monoid_add_ow (Collect (Domainp A)) a b \\<and>\n         ((\\<forall>a\\<in>Collect (Domainp A). c b a = b) \\<and>\n          (\\<forall>a\\<in>Collect (Domainp A). c a b = b)) \\<and>\n         semiring_ow (Collect (Domainp A)) a c) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               a \\<in> Collect (Domainp A) \\<longrightarrow>\n               b \\<in> Collect (Domainp A) \\<longrightarrow>\n               c a b \\<in> Collect (Domainp A)) \\<and>\n        b \\<in> Collect (Domainp A))", "by blast"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n   (semiring_0_ow (Collect (Domainp A)))\n   (\\<lambda>a b c.\n       class.semiring_0 a b c \\<and>\n       (\\<forall>a b.\n           a \\<in> UNIV \\<longrightarrow>\n           b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n       b \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_ow (Collect (Domainp A))) class.semiring_0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n   (semiring_0_ow (Collect (Domainp A)))\n   (\\<lambda>a b c.\n       class.semiring_0 a b c \\<and>\n       (\\<forall>a b.\n           a \\<in> UNIV \\<longrightarrow>\n           b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n       b \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_ow (Collect (Domainp A))) class.semiring_0", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n   (semiring_0_ow (Collect (Domainp A))) class.semiring_0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Commutative semirings with zero\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_semiring_0_ow = \n  comm_semiring_ow U plus times +  \n  comm_monoid_add_ow U plus zero + \n  mult_zero_ow U times zero\n  for U :: \"'ag set\" and plus zero times \nbegin"], ["", "sublocale semiring_0_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_0_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w\n     (*\\<^sub>o\\<^sub>w)", "by unfold_locales"], ["", "end"], ["", "lemma comm_semiring_0_ow: \"class.comm_semiring_0 = comm_semiring_0_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_semiring_0 = comm_semiring_0_ow UNIV", "unfolding \n    class.comm_semiring_0_def comm_semiring_0_ow_def\n    comm_monoid_add_ow comm_semiring_ow mult_zero_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero times.\n        comm_monoid_add_ow UNIV plus zero \\<and>\n        comm_semiring_ow UNIV plus times \\<and>\n        mult_zero_ow UNIV times zero) =\n    (\\<lambda>plus zero times.\n        comm_semiring_ow UNIV plus times \\<and>\n        comm_monoid_add_ow UNIV plus zero \\<and>\n        mult_zero_ow UNIV times zero)", "by (auto simp: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma comm_semiring_0_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=)) \n      (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0\"\n    (is \"?PR (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0", "let ?comm_semiring_0 =\n    \"(\n      \\<lambda>plus zero times. \n        class.comm_semiring_0 plus zero times \\<and>\n        (\\<forall>a b. a \\<in> UNIV \\<longrightarrow> b \\<in> UNIV \\<longrightarrow> times a b \\<in> UNIV) \\<and> zero \\<in> UNIV\n    )\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0", "have \"?PR (comm_semiring_0_ow (Collect (Domainp A))) ?comm_semiring_0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_ow (Collect (Domainp A)))\n     (\\<lambda>a b c.\n         class.comm_semiring_0 a b c \\<and>\n         (\\<forall>a b.\n             a \\<in> UNIV \\<longrightarrow>\n             b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n         b \\<in> UNIV)", "unfolding\n      comm_semiring_0_ow_def class.comm_semiring_0_def\n      mult_zero_ow_def class.mult_zero_def\n      mult_zero_ow_axioms_def\n      times_ow_def zero_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>a b c.\n         comm_semiring_ow (Collect (Domainp A)) a c \\<and>\n         comm_monoid_add_ow (Collect (Domainp A)) a b \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c a b \\<in> Collect (Domainp A)) \\<and>\n         b \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> c b a = b) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> c a b = b))\n     (\\<lambda>a b c.\n         (class.comm_monoid_add a b \\<and>\n          class.comm_semiring a c \\<and>\n          (\\<forall>a. c b a = b) \\<and> (\\<forall>a. c a b = b)) \\<and>\n         (\\<forall>a b.\n             a \\<in> UNIV \\<longrightarrow>\n             b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n         b \\<in> UNIV)", "apply transfer_prover_start"], ["proof (prove)\ngoal (24 subgoals):\n 1. Transfer.Rel ?Rab43 ?av43 UNIV\n 2. Transfer.Rel (A ===> ?Rab43 ===> ?Rr43) ?au43 (\\<in>)\n 3. Transfer.Rel ?Raa43 ?at43 UNIV\n 4. Transfer.Rel (A ===> ?Raa43 ===> ?Ry43) ?as43 (\\<in>)\n 5. Transfer.Rel ?Rz43 ?ar43 UNIV\n 6. Transfer.Rel (A ===> ?Rz43 ===> ?Rx43) ?aq43 (\\<in>)\n 7. Transfer.Rel (?Rx43 ===> ?Ry43 ===> ?Rv43) ?ap43 (\\<longrightarrow>)\n 8. Transfer.Rel ?Rw43 ?ao43 UNIV\n 9. Transfer.Rel (A ===> ?Rw43 ===> ?Ru43) ?an43 (\\<in>)\n 10. Transfer.Rel (?Ru43 ===> ?Rv43 ===> ?Rt43) ?am43 (\\<longrightarrow>)\nA total of 24 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b c.\n        comm_semiring_ow (Collect (Domainp A)) a c \\<and>\n        comm_monoid_add_ow (Collect (Domainp A)) a b \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c a b \\<in> Collect (Domainp A)) \\<and>\n        b \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> c b a = b) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> c a b = b)) =\n    (\\<lambda>a b c.\n        (comm_monoid_add_ow (Collect (Domainp A)) a b \\<and>\n         comm_semiring_ow (Collect (Domainp A)) a c \\<and>\n         (\\<forall>a\\<in>Collect (Domainp A). c b a = b) \\<and>\n         (\\<forall>a\\<in>Collect (Domainp A). c a b = b)) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               a \\<in> Collect (Domainp A) \\<longrightarrow>\n               b \\<in> Collect (Domainp A) \\<longrightarrow>\n               c a b \\<in> Collect (Domainp A)) \\<and>\n        b \\<in> Collect (Domainp A))", "by blast"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n   (comm_semiring_0_ow (Collect (Domainp A)))\n   (\\<lambda>a b c.\n       class.comm_semiring_0 a b c \\<and>\n       (\\<forall>a b.\n           a \\<in> UNIV \\<longrightarrow>\n           b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n       b \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n   (comm_semiring_0_ow (Collect (Domainp A)))\n   (\\<lambda>a b c.\n       class.comm_semiring_0 a b c \\<and>\n       (\\<forall>a b.\n           a \\<in> UNIV \\<longrightarrow>\n           b \\<in> UNIV \\<longrightarrow> c a b \\<in> UNIV) \\<and>\n       b \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n   (comm_semiring_0_ow (Collect (Domainp A))) class.comm_semiring_0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Cancellative semirings with zero\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale semiring_0_cancel_ow =\n  semiring_ow U plus times + cancel_comm_monoid_add_ow U plus minus zero\n  for U :: \"'ag set\" and plus minus zero times\nbegin"], ["", "sublocale semiring_0_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_0_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w\n     (*\\<^sub>o\\<^sub>w)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\n 2. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\n 2. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "show \"a \\<in> U \\<Longrightarrow> 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "assume \"a \\<in> U\""], ["proof (state)\nthis:\n  a \\<in> U\n\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "have \"0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a \\<in> U", "by (simp add: \\<open>a \\<in> U\\<close> times_closed')"], ["proof (state)\nthis:\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a \\<in> U\n\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "have \"0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a =\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w\n    0\\<^sub>o\\<^sub>w", "by (simp add: \\<open>a \\<in> U\\<close> \\<open>0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a \\<in> U\\<close> distrib_right[symmetric])"], ["proof (state)\nthis:\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a =\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "then"], ["proof (chain)\npicking this:\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a =\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w", "show ?thesis"], ["proof (prove)\nusing this:\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a =\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "unfolding add_left_cancel[OF \\<open>0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a \\<in> U\\<close> \\<open>0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a \\<in> U\\<close> zero_closed]"], ["proof (prove)\nusing this:\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w", "by assumption"], ["proof (state)\nthis:\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> U \\<Longrightarrow>\n  0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "show \"a \\<in> U \\<Longrightarrow> a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "assume \"a \\<in> U\""], ["proof (state)\nthis:\n  a \\<in> U\n\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "have \"a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w \\<in> U", "by (simp add: \\<open>a \\<in> U\\<close> times_closed')"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w \\<in> U\n\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "have \"a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w =\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w\n    0\\<^sub>o\\<^sub>w", "by (simp add: \\<open>a \\<in> U\\<close> \\<open>a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w \\<in> U\\<close> distrib_left[symmetric])"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w =\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. a \\<in> U \\<Longrightarrow>\n    a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "then"], ["proof (chain)\npicking this:\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w =\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w", "show ?thesis"], ["proof (prove)\nusing this:\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w =\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "unfolding add_left_cancel[OF \\<open>a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w \\<in> U\\<close> \\<open>a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w \\<in> U\\<close> zero_closed]"], ["proof (prove)\nusing this:\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w\n\ngoal (1 subgoal):\n 1. a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w", "by assumption"], ["proof (state)\nthis:\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<in> U \\<Longrightarrow>\n  a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma semiring_0_cancel_ow: \n  \"class.semiring_0_cancel = semiring_0_cancel_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_0_cancel = semiring_0_cancel_ow UNIV", "unfolding \n    class.semiring_0_cancel_def \n    semiring_0_cancel_ow_def\n    cancel_comm_monoid_add_ow semiring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero times.\n        cancel_comm_monoid_add_ow UNIV plus minus zero \\<and>\n        semiring_ow UNIV plus times) =\n    (\\<lambda>plus minus zero times.\n        semiring_ow UNIV plus times \\<and>\n        cancel_comm_monoid_add_ow UNIV plus minus zero)", "by (simp add: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma semiring_0_cancel_transfer[transfer_rule]: \n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) (semiring_0_cancel_ow (Collect (Domainp A))) class.semiring_0_cancel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_0_cancel_ow (Collect (Domainp A))) class.semiring_0_cancel", "unfolding semiring_0_cancel_ow_def class.semiring_0_cancel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus minus zero times.\n         semiring_ow (Collect (Domainp A)) plus times \\<and>\n         cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus zero)\n     (\\<lambda>plus minus zero times.\n         class.cancel_comm_monoid_add plus minus zero \\<and>\n         class.semiring plus times)", "apply transfer_prover_start"], ["proof (prove)\ngoal (4 subgoals):\n 1. Transfer.Rel ((A ===> A ===> A) ===> (A ===> A ===> A) ===> ?Rh10) ?ab10\n     class.semiring\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> ?Rg10) ?aa10\n     class.cancel_comm_monoid_add\n 3. Transfer.Rel (?Rg10 ===> ?Rh10 ===> (=)) ?a10 (\\<and>)\n 4. (\\<lambda>plus minus zero times.\n        semiring_ow (Collect (Domainp A)) plus times \\<and>\n        cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus zero) =\n    (\\<lambda>plus minus zero times.\n        ?a10 (?aa10 plus minus zero) (?ab10 plus times))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero times.\n        semiring_ow (Collect (Domainp A)) plus times \\<and>\n        cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus zero) =\n    (\\<lambda>plus minus zero times.\n        cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n         zero \\<and>\n        semiring_ow (Collect (Domainp A)) plus times)", "by auto"], ["", "end"], ["", "subsection\\<open>Commutative cancellative semirings with zero\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_semiring_0_cancel_ow = \n  comm_semiring_ow U plus times + \n  cancel_comm_monoid_add_ow U plus minus zero\n  for U :: \"'ag set\" and plus  minus zero times \nbegin"], ["", "sublocale semiring_0_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_0_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", "by unfold_locales"], ["", "sublocale comm_semiring_0_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_0_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w\n     (*\\<^sub>o\\<^sub>w)", "by unfold_locales"], ["", "end"], ["", "lemma comm_semiring_0_cancel_ow: \n  \"class.comm_semiring_0_cancel = comm_semiring_0_cancel_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_semiring_0_cancel = comm_semiring_0_cancel_ow UNIV", "unfolding \n    class.comm_semiring_0_cancel_def comm_semiring_0_cancel_ow_def\n    cancel_comm_monoid_add_ow comm_semiring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero times.\n        cancel_comm_monoid_add_ow UNIV plus minus zero \\<and>\n        comm_semiring_ow UNIV plus times) =\n    (\\<lambda>plus minus zero times.\n        comm_semiring_ow UNIV plus times \\<and>\n        cancel_comm_monoid_add_ow UNIV plus minus zero)", "by (simp add: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma comm_semiring_0_cancel_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) \n    (comm_semiring_0_cancel_ow (Collect (Domainp A))) \n    class.comm_semiring_0_cancel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (comm_semiring_0_cancel_ow (Collect (Domainp A)))\n     class.comm_semiring_0_cancel", "unfolding comm_semiring_0_cancel_ow_def class.comm_semiring_0_cancel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus minus zero times.\n         comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n         cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus zero)\n     (\\<lambda>plus minus zero times.\n         class.cancel_comm_monoid_add plus minus zero \\<and>\n         class.comm_semiring plus times)", "apply transfer_prover_start"], ["proof (prove)\ngoal (4 subgoals):\n 1. Transfer.Rel ((A ===> A ===> A) ===> (A ===> A ===> A) ===> ?Rh10) ?ab10\n     class.comm_semiring\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> ?Rg10) ?aa10\n     class.cancel_comm_monoid_add\n 3. Transfer.Rel (?Rg10 ===> ?Rh10 ===> (=)) ?a10 (\\<and>)\n 4. (\\<lambda>plus minus zero times.\n        comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n        cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus zero) =\n    (\\<lambda>plus minus zero times.\n        ?a10 (?aa10 plus minus zero) (?ab10 plus times))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero times.\n        comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n        cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus zero) =\n    (\\<lambda>plus minus zero times.\n        cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n         zero \\<and>\n        comm_semiring_ow (Collect (Domainp A)) plus times)", "by auto"], ["", "end"], ["", "subsection\\<open>Class \\<^class>\\<open>zero_neq_one\\<close>\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale zero_neq_one_ow = \n  zero_ow U zero + one_ow U one\n  for U :: \"'ag set\" and one (\\<open>1\\<^sub>o\\<^sub>w\\<close>) and zero (\\<open>0\\<^sub>o\\<^sub>w\\<close>)  +\n  assumes zero_neq_one[simp]: \"0\\<^sub>o\\<^sub>w \\<noteq> 1\\<^sub>o\\<^sub>w\""], ["", "lemma zero_neq_one_ow: \"class.zero_neq_one = zero_neq_one_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.zero_neq_one = zero_neq_one_ow UNIV", "unfolding \n    class.zero_neq_one_def zero_neq_one_ow_def\n    zero_neq_one_ow_axioms_def\n    one_ow_def zero_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one zero. zero \\<noteq> one) =\n    (\\<lambda>one zero.\n        zero \\<in> UNIV \\<and> one \\<in> UNIV \\<and> zero \\<noteq> one)", "by simp"], ["", "ud \\<open>zero_neq_one.of_bool\\<close> (\\<open>(with _ _ : \\<guillemotleft>of'_bool\\<guillemotright> _)\\<close> [1000, 999, 1000] 10)"], ["", "ud of_bool' \\<open>of_bool\\<close>"], ["", "ctr parametricity\n  in of_bool.with_def"], ["", "context zero_neq_one_ow\nbegin"], ["", "abbreviation of_bool where \"of_bool \\<equiv> of_bool.with 1\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w\""], ["", "end"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma zero_neq_one_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\"  \n  shows \n    \"(A ===> A ===> (=)) \n      (zero_neq_one_ow (Collect (Domainp A))) class.zero_neq_one\" \n    (is \"?PR (zero_neq_one_ow (Collect (Domainp A))) class.zero_neq_one\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n     class.zero_neq_one", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n     class.zero_neq_one", "let ?zero_neq_one = \n    \"(\\<lambda>one zero. class.zero_neq_one one zero \\<and> one \\<in> UNIV \\<and> zero \\<in> UNIV)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n     class.zero_neq_one", "have \"?PR (zero_neq_one_ow (Collect (Domainp A))) ?zero_neq_one\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n     (\\<lambda>a b.\n         class.zero_neq_one a b \\<and> a \\<in> UNIV \\<and> b \\<in> UNIV)", "unfolding \n      zero_neq_one_ow_def class.zero_neq_one_def\n      zero_neq_one_ow_axioms_def\n      zero_ow_def one_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> A ===> (=))\n     (\\<lambda>a b.\n         b \\<in> Collect (Domainp A) \\<and>\n         a \\<in> Collect (Domainp A) \\<and> b \\<noteq> a)\n     (\\<lambda>a b. b \\<noteq> a \\<and> a \\<in> UNIV \\<and> b \\<in> UNIV)", "apply transfer_prover_start"], ["proof (prove)\ngoal (9 subgoals):\n 1. Transfer.Rel ?Rl14 ?ag14 UNIV\n 2. Transfer.Rel (A ===> ?Rl14 ===> ?Rj14) ?af14 (\\<in>)\n 3. Transfer.Rel ?Rk14 ?ae14 UNIV\n 4. Transfer.Rel (A ===> ?Rk14 ===> ?Ri14) ?ad14 (\\<in>)\n 5. Transfer.Rel (?Ri14 ===> ?Rj14 ===> ?Rf14) ?ac14 (\\<and>)\n 6. Transfer.Rel (A ===> A ===> ?Rh14) ?ab14 (=)\n 7. Transfer.Rel (?Rh14 ===> ?Re14) ?aa14 Not\n 8. Transfer.Rel (?Re14 ===> ?Rf14 ===> (=)) ?a14 (\\<and>)\n 9. (\\<lambda>a b.\n        b \\<in> Collect (Domainp A) \\<and>\n        a \\<in> Collect (Domainp A) \\<and> b \\<noteq> a) =\n    (\\<lambda>a b.\n        ?a14 (?aa14 (?ab14 b a)) (?ac14 (?ad14 a ?ae14) (?af14 b ?ag14)))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b.\n        b \\<in> Collect (Domainp A) \\<and>\n        a \\<in> Collect (Domainp A) \\<and> b \\<noteq> a) =\n    (\\<lambda>a b.\n        b \\<noteq> a \\<and>\n        a \\<in> Collect (Domainp A) \\<and> b \\<in> Collect (Domainp A))", "by auto"], ["proof (state)\nthis:\n  (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n   (\\<lambda>a b.\n       class.zero_neq_one a b \\<and> a \\<in> UNIV \\<and> b \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n     class.zero_neq_one", "thus ?thesis"], ["proof (prove)\nusing this:\n  (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n   (\\<lambda>a b.\n       class.zero_neq_one a b \\<and> a \\<in> UNIV \\<and> b \\<in> UNIV)\n\ngoal (1 subgoal):\n 1. (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n     class.zero_neq_one", "by simp"], ["proof (state)\nthis:\n  (A ===> A ===> (=)) (zero_neq_one_ow (Collect (Domainp A)))\n   class.zero_neq_one\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context zero_neq_one_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting zero_neq_one_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma split_of_bool_asm:\n  shows \"P (of_bool p) = (\\<not> (p \\<and> \\<not> P 1\\<^sub>o\\<^sub>w \\<or> \\<not> p \\<and> \\<not> P 0\\<^sub>o\\<^sub>w))\"\n    is zero_neq_one_class.split_of_bool_asm"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_bool_eq_iff:\n  shows \"(of_bool p = local.of_bool q) = (p = q)\"\n    is zero_neq_one_class.of_bool_eq_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma split_of_bool:\n  shows \"P (of_bool p) = ((p \\<longrightarrow> P 1\\<^sub>o\\<^sub>w) \\<and> (\\<not> p \\<longrightarrow> P 0\\<^sub>o\\<^sub>w))\"\n    is zero_neq_one_class.split_of_bool"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma one_neq_zero: \"1\\<^sub>o\\<^sub>w \\<noteq> 0\\<^sub>o\\<^sub>w\"\n  is zero_neq_one_class.one_neq_zero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_bool_eq:\n  shows \"of_bool False = 0\\<^sub>o\\<^sub>w\" \n    is zero_neq_one_class.of_bool_eq(1)\n    and \"of_bool True = 1\\<^sub>o\\<^sub>w\"\n    is zero_neq_one_class.of_bool_eq(2)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Semirings with zero and one (rigs)\\<close>"], ["", "subsubsection\\<open>Definitions and commmon properties\\<close>"], ["", "locale semiring_1_ow =\n  zero_neq_one_ow U one zero +\n  semiring_0_ow U plus zero times + \n  monoid_mult_ow U one times\n  for U :: \"'ag set\" and one times plus zero"], ["", "lemma semiring_1_ow: \"class.semiring_1 = semiring_1_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_1 = semiring_1_ow UNIV", "unfolding \n    class.semiring_1_def semiring_1_ow_def\n    monoid_mult_ow semiring_0_ow zero_neq_one_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times plus zero.\n        monoid_mult_ow UNIV one times \\<and>\n        semiring_0_ow UNIV plus zero times \\<and>\n        zero_neq_one_ow UNIV one zero) =\n    (\\<lambda>one times plus zero.\n        zero_neq_one_ow UNIV one zero \\<and>\n        semiring_0_ow UNIV plus zero times \\<and>\n        monoid_mult_ow UNIV one times)", "by (auto simp: conj_commute)"], ["", "ud \\<open>semiring_1.of_nat\\<close> (\\<open>(with _ _ _ : \\<guillemotleft>of'_nat\\<guillemotright> _)\\<close> [1000, 999, 998, 1000] 10)"], ["", "ud of_nat' \\<open>of_nat\\<close>"], ["", "ud \\<open>semiring_1.Nats\\<close> (\\<open>(with _ _ _ : \\<nat>)\\<close> [1000, 999, 998] 10)"], ["", "ud Nats' \\<open>Nats\\<close>"], ["", "ctr parametricity\n  in of_nat_ow: of_nat.with_def\n    and Nats_ow: Nats.with_def"], ["", "context semiring_1_ow\nbegin"], ["", "abbreviation of_nat where \"of_nat \\<equiv> of_nat.with 1\\<^sub>o\\<^sub>w (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w\""], ["", "abbreviation Nats (\\<open>\\<guillemotleft>\\<nat>\\<guillemotright>\\<close>) where \"\\<guillemotleft>\\<nat>\\<guillemotright> \\<equiv> Nats.with 1\\<^sub>o\\<^sub>w (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w\""], ["", "notation Nats (\\<open>\\<guillemotleft>\\<nat>\\<guillemotright>\\<close>)"], ["", "end"], ["", "context semiring_1\nbegin"], ["", "lemma Nat_ss_UNIV: \"\\<nat> \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nat> \\<subseteq> UNIV", "by simp"], ["", "end"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma semiring_1_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(A ===> (A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=)) \n      (semiring_1_ow (Collect (Domainp A))) class.semiring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=))\n     (semiring_1_ow (Collect (Domainp A))) class.semiring_1", "unfolding semiring_1_ow_def class.semiring_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>one times plus zero.\n         zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n         semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n         monoid_mult_ow (Collect (Domainp A)) one times)\n     (\\<lambda>one times plus zero.\n         class.monoid_mult one times \\<and>\n         class.semiring_0 plus zero times \\<and>\n         class.zero_neq_one one zero)", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rk14) ?ad14 class.zero_neq_one\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> ?Rj14) ?ac14\n     class.semiring_0\n 3. Transfer.Rel (?Rj14 ===> ?Rk14 ===> ?Rh14) ?ab14 (\\<and>)\n 4. Transfer.Rel (A ===> (A ===> A ===> A) ===> ?Rg14) ?aa14\n     class.monoid_mult\n 5. Transfer.Rel (?Rg14 ===> ?Rh14 ===> (=)) ?a14 (\\<and>)\n 6. (\\<lambda>one times plus zero.\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n        monoid_mult_ow (Collect (Domainp A)) one times) =\n    (\\<lambda>one times plus zero.\n        ?a14 (?aa14 one times)\n         (?ab14 (?ac14 plus zero times) (?ad14 one zero)))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times plus zero.\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n        monoid_mult_ow (Collect (Domainp A)) one times) =\n    (\\<lambda>one times plus zero.\n        monoid_mult_ow (Collect (Domainp A)) one times \\<and>\n        semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero)", "by auto"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context semiring_1_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting semiring_1_ow_axioms and zero.not_empty \n  eliminating through simp\nbegin"], ["", "tts_lemma Nat_ss_UNIV[simp]:\n  shows \"\\<guillemotleft>\\<nat>\\<guillemotright> \\<subseteq> U\"\n    is Nat_ss_UNIV"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "lemma Nat_closed[simp, intro]: \"a \\<in> \\<guillemotleft>\\<nat>\\<guillemotright> \\<Longrightarrow> a \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<guillemotleft>\\<nat>\\<guillemotright> \\<Longrightarrow>\n    a \\<in> U", "using Nat_ss_UNIV"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<nat>\\<guillemotright> \\<subseteq> U\n\ngoal (1 subgoal):\n 1. a \\<in> \\<guillemotleft>\\<nat>\\<guillemotright> \\<Longrightarrow>\n    a \\<in> U", "by blast"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting semiring_1_ow_axioms and zero.not_empty\n  eliminating through auto\nbegin"], ["", "tts_lemma mult_of_nat_commute:\n  assumes \"y \\<in> U\"\n  shows \"of_nat x *\\<^sub>o\\<^sub>w y = y *\\<^sub>o\\<^sub>w of_nat x\"\n    is semiring_1_class.mult_of_nat_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_bool_conj: \"of_bool (P \\<and> Q) = of_bool P *\\<^sub>o\\<^sub>w of_bool Q\"\n  is semiring_1_class.of_bool_conj"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_0_left: \"0\\<^sub>o\\<^sub>w ^\\<^sub>o\\<^sub>w n = (if n = 0 then 1\\<^sub>o\\<^sub>w else 0\\<^sub>o\\<^sub>w)\"\n  is semiring_1_class.power_0_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_power: \"of_nat ((with 1 (*) : m ^\\<^sub>o\\<^sub>w n)) = of_nat m ^\\<^sub>o\\<^sub>w n\"\n  is semiring_1_class.of_nat_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_of_bool: \"of_nat (with 1 0 : \\<guillemotleft>of_bool\\<guillemotright> P) = of_bool P\"\n  is semiring_1_class.of_nat_of_bool"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_in_Nats: \"of_nat n \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n  is semiring_1_class.of_nat_in_Nats"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma zero_power2: \"0\\<^sub>o\\<^sub>w ^\\<^sub>o\\<^sub>w 2 = 0\\<^sub>o\\<^sub>w\"\n  is semiring_1_class.zero_power2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_0_Suc: \"0\\<^sub>o\\<^sub>w ^\\<^sub>o\\<^sub>w Suc n = 0\\<^sub>o\\<^sub>w\"\n  is semiring_1_class.power_0_Suc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma zero_power:\n  assumes \"0 < n\"\n  shows \"0\\<^sub>o\\<^sub>w ^\\<^sub>o\\<^sub>w n = 0\\<^sub>o\\<^sub>w\"\n    is semiring_1_class.zero_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma one_power2: \"1\\<^sub>o\\<^sub>w ^\\<^sub>o\\<^sub>w 2 = 1\\<^sub>o\\<^sub>w\"\n  is semiring_1_class.one_power2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_simps:\n  shows \"of_nat 0 = 0\\<^sub>o\\<^sub>w\" \n    is semiring_1_class.of_nat_simps(1)\n    and \"of_nat (Suc m) = 1\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w of_nat m\"\n    is semiring_1_class.of_nat_simps(2)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_mult: \"of_nat (m * n) = of_nat m *\\<^sub>o\\<^sub>w of_nat n\"\n  is semiring_1_class.of_nat_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_induct:\n  assumes \"x \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\" and \"\\<And>n. P (of_nat n)\"\n  shows \"P x\"\n    is semiring_1_class.Nats_induct"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_add: \"of_nat (m + n) = of_nat m +\\<^sub>o\\<^sub>w of_nat n\"\n  is semiring_1_class.of_nat_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_Suc: \"of_nat (Suc m) = 1\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w of_nat m\"\n  is semiring_1_class.of_nat_Suc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_cases:\n  assumes \"x \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\" \n  obtains (of_nat) n where \"x = of_nat n\"\n    given semiring_1_class.Nats_cases"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>;\n     \\<And>n. x = local.of_nat n \\<Longrightarrow> thesis;\n     \\<And>n. x = local.of_nat n \\<Longrightarrow> thesis;\n     \\<And>x thesis.\n        \\<lbrakk>x \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>;\n         \\<And>n. x = local.of_nat n \\<Longrightarrow> thesis\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "tts_lemma Nats_mult:\n  assumes \"a \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\" and \"b \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n  shows \"a *\\<^sub>o\\<^sub>w b \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n    is semiring_1_class.Nats_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_1: \"of_nat 1 = 1\\<^sub>o\\<^sub>w\"\n  is semiring_1_class.of_nat_1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_0: \"of_nat 0 = 0\\<^sub>o\\<^sub>w\"\n  is semiring_1_class.of_nat_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_add:\n  assumes \"a \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\" and \"b \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n  shows \"a +\\<^sub>o\\<^sub>w b \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n    is semiring_1_class.Nats_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_1: \"1\\<^sub>o\\<^sub>w \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n  is semiring_1_class.Nats_1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_0: \"0\\<^sub>o\\<^sub>w \\<in> \\<guillemotleft>\\<nat>\\<guillemotright>\"\n  is semiring_1_class.Nats_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Commutative rigs\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_semiring_1_ow = \n  zero_neq_one_ow U one zero +\n  comm_semiring_0_ow U plus zero times +\n  comm_monoid_mult_ow U times one\n  for U :: \"'ag set\" and times one plus zero  \nbegin"], ["", "sublocale semiring_1_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_1_ow U 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)\n     (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", "by unfold_locales"], ["", "end"], ["", "lemma comm_semiring_1_ow: \"class.comm_semiring_1 = comm_semiring_1_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_semiring_1 = comm_semiring_1_ow UNIV", "unfolding \n    class.comm_semiring_1_def comm_semiring_1_ow_def\n    comm_monoid_mult_ow comm_semiring_0_ow zero_neq_one_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times one plus zero.\n        comm_monoid_mult_ow UNIV times one \\<and>\n        comm_semiring_0_ow UNIV plus zero times \\<and>\n        zero_neq_one_ow UNIV one zero) =\n    (\\<lambda>times one plus zero.\n        zero_neq_one_ow UNIV one zero \\<and>\n        comm_semiring_0_ow UNIV plus zero times \\<and>\n        comm_monoid_mult_ow UNIV times one)", "by (auto simp: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma comm_semiring_1_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> A ===> (=)) \n      (comm_semiring_1_ow (Collect (Domainp A))) class.comm_semiring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> A ===> (=))\n     (comm_semiring_1_ow (Collect (Domainp A))) class.comm_semiring_1", "unfolding comm_semiring_1_ow_def class.comm_semiring_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>times one plus zero.\n         zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n         comm_semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n         comm_monoid_mult_ow (Collect (Domainp A)) times one)\n     (\\<lambda>times one plus zero.\n         class.comm_monoid_mult times one \\<and>\n         class.comm_semiring_0 plus zero times \\<and>\n         class.zero_neq_one one zero)", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rk14) ?ad14 class.zero_neq_one\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> ?Rj14) ?ac14\n     class.comm_semiring_0\n 3. Transfer.Rel (?Rj14 ===> ?Rk14 ===> ?Rh14) ?ab14 (\\<and>)\n 4. Transfer.Rel ((A ===> A ===> A) ===> A ===> ?Rg14) ?aa14\n     class.comm_monoid_mult\n 5. Transfer.Rel (?Rg14 ===> ?Rh14 ===> (=)) ?a14 (\\<and>)\n 6. (\\<lambda>times one plus zero.\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        comm_semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n        comm_monoid_mult_ow (Collect (Domainp A)) times one) =\n    (\\<lambda>times one plus zero.\n        ?a14 (?aa14 times one)\n         (?ab14 (?ac14 plus zero times) (?ad14 one zero)))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times one plus zero.\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        comm_semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n        comm_monoid_mult_ow (Collect (Domainp A)) times one) =\n    (\\<lambda>times one plus zero.\n        comm_monoid_mult_ow (Collect (Domainp A)) times one \\<and>\n        comm_semiring_0_ow (Collect (Domainp A)) plus zero times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero)", "by auto"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context comm_semiring_1_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting comm_semiring_1_ow_axioms and zero.not_empty\n  applying [OF times_closed' one_closed plus_closed' zero_closed]\nbegin"], ["", "tts_lemma semiring_normalization_rules:\n  shows \n    \"\\<lbrakk>a \\<in> U; m \\<in> U; b \\<in> U\\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w m +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w m = (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w m\"\n    \"\\<lbrakk>a \\<in> U; m \\<in> U\\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w m +\\<^sub>o\\<^sub>w m = (a +\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) *\\<^sub>o\\<^sub>w m\"\n    \"\\<lbrakk>m \\<in> U; a \\<in> U\\<rbrakk> \\<Longrightarrow> m +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w m = (a +\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) *\\<^sub>o\\<^sub>w m\"\n    \"m \\<in> U \\<Longrightarrow> m +\\<^sub>o\\<^sub>w m = (1\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) *\\<^sub>o\\<^sub>w m\"\n    \"a \\<in> U \\<Longrightarrow> 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w a = a\"\n    \"a \\<in> U \\<Longrightarrow> a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = a\"\n    \"\\<lbrakk>a \\<in> U; b \\<in> U\\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w b = b *\\<^sub>o\\<^sub>w a\"\n    \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\"\n    \"a \\<in> U \\<Longrightarrow> 0\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\"\n    \"a \\<in> U \\<Longrightarrow> a *\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = 0\\<^sub>o\\<^sub>w\"\n    \"a \\<in> U \\<Longrightarrow> 1\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = a\"\n    \"a \\<in> U \\<Longrightarrow> a *\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w = a\"\n    \"\\<lbrakk>lx \\<in> U; ly \\<in> U; rx \\<in> U; ry \\<in> U\\<rbrakk> \\<Longrightarrow> \n      lx *\\<^sub>o\\<^sub>w ly *\\<^sub>o\\<^sub>w (rx *\\<^sub>o\\<^sub>w ry) = lx *\\<^sub>o\\<^sub>w rx *\\<^sub>o\\<^sub>w (ly *\\<^sub>o\\<^sub>w ry)\"\n    \"\\<lbrakk>lx \\<in> U; ly \\<in> U; rx \\<in> U; ry \\<in> U\\<rbrakk> \\<Longrightarrow> \n      lx *\\<^sub>o\\<^sub>w ly *\\<^sub>o\\<^sub>w (rx *\\<^sub>o\\<^sub>w ry) = lx *\\<^sub>o\\<^sub>w (ly *\\<^sub>o\\<^sub>w (rx *\\<^sub>o\\<^sub>w ry))\"\n    \"\\<lbrakk>lx \\<in> U; ly \\<in> U; rx \\<in> U; ry \\<in> U\\<rbrakk> \\<Longrightarrow> \n      lx *\\<^sub>o\\<^sub>w ly *\\<^sub>o\\<^sub>w (rx *\\<^sub>o\\<^sub>w ry) = rx *\\<^sub>o\\<^sub>w (lx *\\<^sub>o\\<^sub>w ly *\\<^sub>o\\<^sub>w ry)\"\n    \"\\<lbrakk>lx \\<in> U; ly \\<in> U; rx \\<in> U\\<rbrakk> \\<Longrightarrow> lx *\\<^sub>o\\<^sub>w ly *\\<^sub>o\\<^sub>w rx = lx *\\<^sub>o\\<^sub>w rx *\\<^sub>o\\<^sub>w ly\"\n    \"\\<lbrakk>lx \\<in> U; ly \\<in> U; rx \\<in> U\\<rbrakk> \\<Longrightarrow> lx *\\<^sub>o\\<^sub>w ly *\\<^sub>o\\<^sub>w rx = lx *\\<^sub>o\\<^sub>w (ly *\\<^sub>o\\<^sub>w rx)\"\n    \"\\<lbrakk>lx \\<in> U; rx \\<in> U; ry \\<in> U\\<rbrakk> \\<Longrightarrow> lx *\\<^sub>o\\<^sub>w (rx *\\<^sub>o\\<^sub>w ry) = lx *\\<^sub>o\\<^sub>w rx *\\<^sub>o\\<^sub>w ry\"\n    \"\\<lbrakk>lx \\<in> U; rx \\<in> U; ry \\<in> U\\<rbrakk> \\<Longrightarrow> lx *\\<^sub>o\\<^sub>w (rx *\\<^sub>o\\<^sub>w ry) = rx *\\<^sub>o\\<^sub>w (lx *\\<^sub>o\\<^sub>w ry)\"\n    \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U; d \\<in> U\\<rbrakk> \\<Longrightarrow> \n      a +\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w (c +\\<^sub>o\\<^sub>w d) = a +\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w d)\"\n    \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w c = a +\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c)\"\n    \"\\<lbrakk>a \\<in> U; c \\<in> U; d \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w (c +\\<^sub>o\\<^sub>w d) = c +\\<^sub>o\\<^sub>w (a +\\<^sub>o\\<^sub>w d)\"\n    \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w c = a +\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b\"\n    \"\\<lbrakk>a \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w c = c +\\<^sub>o\\<^sub>w a\"\n    \"\\<lbrakk>a \\<in> U; c \\<in> U; d \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w (c +\\<^sub>o\\<^sub>w d) = a +\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w d\"\n    \"x \\<in> U \\<Longrightarrow> x ^\\<^sub>o\\<^sub>w p *\\<^sub>o\\<^sub>w x ^\\<^sub>o\\<^sub>w q = x ^\\<^sub>o\\<^sub>w (p + q)\"\n    \"x \\<in> U \\<Longrightarrow> x *\\<^sub>o\\<^sub>w x ^\\<^sub>o\\<^sub>w q = x ^\\<^sub>o\\<^sub>w Suc q\"\n    \"x \\<in> U \\<Longrightarrow> x ^\\<^sub>o\\<^sub>w q *\\<^sub>o\\<^sub>w x = x ^\\<^sub>o\\<^sub>w Suc q\"\n    \"x \\<in> U \\<Longrightarrow> x *\\<^sub>o\\<^sub>w x = x ^\\<^sub>o\\<^sub>w 2\"\n    \"\\<lbrakk>x \\<in> U; y \\<in> U\\<rbrakk> \\<Longrightarrow> (x *\\<^sub>o\\<^sub>w y) ^\\<^sub>o\\<^sub>w q = x ^\\<^sub>o\\<^sub>w q *\\<^sub>o\\<^sub>w y ^\\<^sub>o\\<^sub>w q\"\n    \"x \\<in> U \\<Longrightarrow> (x ^\\<^sub>o\\<^sub>w p) ^\\<^sub>o\\<^sub>w q = x ^\\<^sub>o\\<^sub>w (p * q)\"\n    \"x \\<in> U \\<Longrightarrow> x ^\\<^sub>o\\<^sub>w 0 = 1\\<^sub>o\\<^sub>w\"\n    \"x \\<in> U \\<Longrightarrow> x ^\\<^sub>o\\<^sub>w 1 = x\"\n    \"\\<lbrakk>x \\<in> U; y \\<in> U; z \\<in> U\\<rbrakk> \\<Longrightarrow> x *\\<^sub>o\\<^sub>w (y +\\<^sub>o\\<^sub>w z) = x *\\<^sub>o\\<^sub>w y +\\<^sub>o\\<^sub>w x *\\<^sub>o\\<^sub>w z\"\n    \"x \\<in> U \\<Longrightarrow> x ^\\<^sub>o\\<^sub>w Suc q = x *\\<^sub>o\\<^sub>w x ^\\<^sub>o\\<^sub>w q\"\n    \"x \\<in> U \\<Longrightarrow> x ^\\<^sub>o\\<^sub>w (2 * n) = x ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w x ^\\<^sub>o\\<^sub>w n\"\n    is comm_semiring_1_class.semiring_normalization_rules"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma le_imp_power_dvd:\n  assumes \"a \\<in> U\" and \"m \\<le> n\"\n  shows \"a ^\\<^sub>o\\<^sub>w m \\<guillemotleft>dvd\\<guillemotright> a ^\\<^sub>o\\<^sub>w n\"\n    is comm_semiring_1_class.le_imp_power_dvd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_0_left_iff:\n  assumes \"a \\<in> U\"\n  shows \"(0\\<^sub>o\\<^sub>w \\<guillemotleft>dvd\\<guillemotright> a) = (a = 0\\<^sub>o\\<^sub>w)\"\n    is comm_semiring_1_class.dvd_0_left_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_power_same:\n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"x \\<guillemotleft>dvd\\<guillemotright> y\"\n  shows \"x ^\\<^sub>o\\<^sub>w n \\<guillemotleft>dvd\\<guillemotright> y ^\\<^sub>o\\<^sub>w n\"\n    is comm_semiring_1_class.dvd_power_same"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_le_dvd:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"a ^\\<^sub>o\\<^sub>w n \\<guillemotleft>dvd\\<guillemotright> b\" and \"m \\<le> n\"\n  shows \"a ^\\<^sub>o\\<^sub>w m \\<guillemotleft>dvd\\<guillemotright> b\"\n    is comm_semiring_1_class.power_le_dvd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_0_right:\n  assumes \"a \\<in> U\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> 0\\<^sub>o\\<^sub>w\"\n    is comm_semiring_1_class.dvd_0_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_0_left:\n  assumes \"a \\<in> U\" and \"0\\<^sub>o\\<^sub>w \\<guillemotleft>dvd\\<guillemotright> a\"\n  shows \"a = 0\\<^sub>o\\<^sub>w\"\n    is comm_semiring_1_class.dvd_0_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_power:\n  assumes \"x \\<in> U\" and \"0 < n \\<or> x = 1\\<^sub>o\\<^sub>w\"\n  shows \"x \\<guillemotleft>dvd\\<guillemotright> x ^\\<^sub>o\\<^sub>w n\"\n    is comm_semiring_1_class.dvd_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_add:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\" and \"a \\<guillemotleft>dvd\\<guillemotright> b\" and \"a \\<guillemotleft>dvd\\<guillemotright> c\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> b +\\<^sub>o\\<^sub>w c\"\n    is comm_semiring_1_class.dvd_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Cancellative rigs\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale semiring_1_cancel_ow =\n  semiring_ow U plus times +\n  cancel_comm_monoid_add_ow U plus minus zero +\n  zero_neq_one_ow U one zero +\n  monoid_mult_ow U one times\n  for U :: \"'ag set\" and plus minus zero one times\nbegin"], ["", "sublocale semiring_0_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_0_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", ".."], ["", "sublocale semiring_1_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_1_ow U 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)\n     (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", ".."], ["", "end"], ["", "lemma semiring_1_cancel_ow: \n  \"class.semiring_1_cancel = semiring_1_cancel_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_1_cancel = semiring_1_cancel_ow UNIV", "unfolding \n    class.semiring_1_cancel_def semiring_1_cancel_ow_def\n    cancel_comm_monoid_add_ow monoid_mult_ow semiring_ow zero_neq_one_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero one times.\n        (cancel_comm_monoid_add_ow UNIV plus minus zero \\<and>\n         monoid_mult_ow UNIV one times) \\<and>\n        semiring_ow UNIV plus times \\<and> zero_neq_one_ow UNIV one zero) =\n    (\\<lambda>plus minus zero one times.\n        (semiring_ow UNIV plus times \\<and>\n         cancel_comm_monoid_add_ow UNIV plus minus zero) \\<and>\n        zero_neq_one_ow UNIV one zero \\<and> monoid_mult_ow UNIV one times)", "by (force simp: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma semiring_1_cancel_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) (semiring_1_cancel_ow (Collect (Domainp A))) class.semiring_1_cancel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> A ===> (A ===> A ===> A) ===> (=))\n     (semiring_1_cancel_ow (Collect (Domainp A))) class.semiring_1_cancel", "unfolding semiring_1_cancel_ow_def class.semiring_1_cancel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> A ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus minus zero one times.\n         (semiring_ow (Collect (Domainp A)) plus times \\<and>\n          cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n           zero) \\<and>\n         zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n         monoid_mult_ow (Collect (Domainp A)) one times)\n     (\\<lambda>plus minus zero one times.\n         (class.cancel_comm_monoid_add plus minus zero \\<and>\n          class.monoid_mult one times) \\<and>\n         class.semiring plus times \\<and> class.zero_neq_one one zero)", "apply transfer_prover_start"], ["proof (prove)\ngoal (8 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rn18) ?af18 class.zero_neq_one\n 2. Transfer.Rel ((A ===> A ===> A) ===> (A ===> A ===> A) ===> ?Rm18) ?ae18\n     class.semiring\n 3. Transfer.Rel (?Rm18 ===> ?Rn18 ===> ?Ri18) ?ad18 (\\<and>)\n 4. Transfer.Rel (A ===> (A ===> A ===> A) ===> ?Rl18) ?ac18\n     class.monoid_mult\n 5. Transfer.Rel\n     ((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> ?Rk18) ?ab18\n     class.cancel_comm_monoid_add\n 6. Transfer.Rel (?Rk18 ===> ?Rl18 ===> ?Rh18) ?aa18 (\\<and>)\n 7. Transfer.Rel (?Rh18 ===> ?Ri18 ===> (=)) ?a18 (\\<and>)\n 8. (\\<lambda>plus minus zero one times.\n        (semiring_ow (Collect (Domainp A)) plus times \\<and>\n         cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n          zero) \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        monoid_mult_ow (Collect (Domainp A)) one times) =\n    (\\<lambda>plus minus zero one times.\n        ?a18 (?aa18 (?ab18 plus minus zero) (?ac18 one times))\n         (?ad18 (?ae18 plus times) (?af18 one zero)))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero one times.\n        (semiring_ow (Collect (Domainp A)) plus times \\<and>\n         cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n          zero) \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        monoid_mult_ow (Collect (Domainp A)) one times) =\n    (\\<lambda>plus minus zero one times.\n        (cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n          zero \\<and>\n         monoid_mult_ow (Collect (Domainp A)) one times) \\<and>\n        semiring_ow (Collect (Domainp A)) plus times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero)", "by blast"], ["", "end"], ["", "subsection\\<open>Commutative cancellative rigs\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_semiring_1_cancel_ow =\n  comm_semiring_ow U plus times + \n  cancel_comm_monoid_add_ow U plus minus zero + \n  zero_neq_one_ow U one zero +  \n  comm_monoid_mult_ow U times one \n  for U :: \"'ag set\" and plus minus zero times one + \n  assumes right_diff_distrib'[algebra_simps]: \n    \"\\<lbrakk> a \\<in> U; b \\<in> U; c \\<in> U \\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w (b -\\<^sub>o\\<^sub>w c) = a *\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\" \nbegin"], ["", "sublocale semiring_1_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_1_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", ".."], ["", "sublocale comm_semiring_0_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_0_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", ".."], ["", "sublocale comm_semiring_1_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_1_ow U (*\\<^sub>o\\<^sub>w) 1\\<^sub>o\\<^sub>w\n     (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", ".."], ["", "end"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context \n  includes lifting_syntax\nbegin"], ["", "lemma comm_semiring_1_cancel_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      A ===> \n      (=)\n    ) \n    (comm_semiring_1_cancel_ow (Collect (Domainp A))) \n    class.comm_semiring_1_cancel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> A ===> (=))\n     (comm_semiring_1_cancel_ow (Collect (Domainp A)))\n     class.comm_semiring_1_cancel", "unfolding \n    comm_semiring_1_cancel_ow_def class.comm_semiring_1_cancel_def\n    comm_semiring_1_cancel_ow_axioms_def \n    class.comm_semiring_1_cancel_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     (A ===> A ===> A) ===> A ===> (A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>plus minus zero times one.\n         (comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n          cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n           zero) \\<and>\n         zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n         comm_monoid_mult_ow (Collect (Domainp A)) times one \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             times a (minus b c) = minus (times a b) (times a c)))\n     (\\<lambda>plus minus zero times one.\n         (class.cancel_comm_monoid_add plus minus zero \\<and>\n          class.comm_monoid_mult times one) \\<and>\n         class.comm_semiring plus times \\<and>\n         class.zero_neq_one one zero \\<and>\n         (\\<forall>a b c.\n             times a (minus b c) = minus (times a b) (times a c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (13 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rs35) ?ak35 (=)\n 2. Transfer.Rel ((A ===> ?Rs35) ===> ?Rr35) ?aj35 All\n 3. Transfer.Rel ((A ===> ?Rr35) ===> ?Rq35) ?ai35 All\n 4. Transfer.Rel ((A ===> ?Rq35) ===> ?Rp35) ?ah35 All\n 5. Transfer.Rel (A ===> A ===> ?Ro35) ?ag35 class.zero_neq_one\n 6. Transfer.Rel (?Ro35 ===> ?Rp35 ===> ?Rn35) ?af35 (\\<and>)\n 7. Transfer.Rel ((A ===> A ===> A) ===> (A ===> A ===> A) ===> ?Rm35) ?ae35\n     class.comm_semiring\n 8. Transfer.Rel (?Rm35 ===> ?Rn35 ===> ?Ri35) ?ad35 (\\<and>)\n 9. Transfer.Rel ((A ===> A ===> A) ===> A ===> ?Rl35) ?ac35\n     class.comm_monoid_mult\n 10. Transfer.Rel\n      ((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> ?Rk35) ?ab35\n      class.cancel_comm_monoid_add\nA total of 13 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero times one.\n        (comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n         cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n          zero) \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        comm_monoid_mult_ow (Collect (Domainp A)) times one \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            times a (minus b c) = minus (times a b) (times a c))) =\n    (\\<lambda>plus minus zero times one.\n        (cancel_comm_monoid_add_ow (Collect (Domainp A)) plus minus\n          zero \\<and>\n         comm_monoid_mult_ow (Collect (Domainp A)) times one) \\<and>\n        comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  times a (minus b c) = minus (times a b) (times a c)))", "by blast"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context comm_semiring_1_cancel_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting comm_semiring_1_cancel_ow_axioms and zero.not_empty\n  applying [OF plus_closed' minus_closed' zero_closed times_closed' one_closed]\nbegin"], ["", "tts_lemma dvd_add_times_triv_right_iff:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \"(a \\<guillemotleft>dvd\\<guillemotright> b +\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a) = (a \\<guillemotleft>dvd\\<guillemotright> b)\"\n  is comm_semiring_1_cancel_class.dvd_add_times_triv_right_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_add_times_triv_left_iff:\n  assumes \"a \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\"\n  shows \"(a \\<guillemotleft>dvd\\<guillemotright> c *\\<^sub>o\\<^sub>w a +\\<^sub>o\\<^sub>w b) = (a \\<guillemotleft>dvd\\<guillemotright> b)\"\n    is comm_semiring_1_cancel_class.dvd_add_times_triv_left_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_add_triv_right_iff:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"(a \\<guillemotleft>dvd\\<guillemotright> b +\\<^sub>o\\<^sub>w a) = (a \\<guillemotleft>dvd\\<guillemotright> b)\"\n    is comm_semiring_1_cancel_class.dvd_add_triv_right_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_add_triv_left_iff:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"(a \\<guillemotleft>dvd\\<guillemotright> a +\\<^sub>o\\<^sub>w b) = (a \\<guillemotleft>dvd\\<guillemotright> b)\"\n    is comm_semiring_1_cancel_class.dvd_add_triv_left_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma left_diff_distrib':\n  assumes \"b \\<in> U\" and \"c \\<in> U\" and \"a \\<in> U\"\n  shows \"(b -\\<^sub>o\\<^sub>w c) *\\<^sub>o\\<^sub>w a = b *\\<^sub>o\\<^sub>w a -\\<^sub>o\\<^sub>w c *\\<^sub>o\\<^sub>w a\"\n    is comm_semiring_1_cancel_class.left_diff_distrib'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_add_right_iff:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\" and \"a \\<guillemotleft>dvd\\<guillemotright> b\"\n  shows \"(a \\<guillemotleft>dvd\\<guillemotright> b +\\<^sub>o\\<^sub>w c) = (a \\<guillemotleft>dvd\\<guillemotright> c)\"\n    is comm_semiring_1_cancel_class.dvd_add_right_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_add_left_iff:\n  assumes \"a \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\" and \"a \\<guillemotleft>dvd\\<guillemotright> c\"\n  shows \"(a \\<guillemotleft>dvd\\<guillemotright> b +\\<^sub>o\\<^sub>w c) = (a \\<guillemotleft>dvd\\<guillemotright> b)\"\n    is comm_semiring_1_cancel_class.dvd_add_left_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}