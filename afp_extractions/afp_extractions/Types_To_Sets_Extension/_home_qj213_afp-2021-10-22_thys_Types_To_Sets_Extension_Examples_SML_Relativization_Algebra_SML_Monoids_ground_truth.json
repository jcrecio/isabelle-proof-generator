{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/SML_Relativization/Algebra/SML_Monoids.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma not_empty[simp]: \"U \\<noteq> {}\"", "lemma neutral_map: \"(\\<lambda>y. \\<^bold>1\\<^sub>o\\<^sub>w) ` A \\<subseteq> U\"", "lemma zero_closed: \"0\\<^sub>o\\<^sub>w \\<in> U\"", "lemma monoid_ow: \"monoid = monoid_ow UNIV\"", "lemma one_closed: \"1\\<^sub>o\\<^sub>w \\<in> U\"", "lemma power_with[ud_with]: \"power = power_with 1 (*)\"", "lemma monoid_add_ow: \"class.monoid_add = monoid_add_ow UNIV\"", "lemma monoid_mult_ow: \"class.monoid_mult = monoid_mult_ow UNIV\"", "lemma monoid_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (monoid_ow (Collect (Domainp A))) monoid\"", "lemma monoid_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (monoid_add_ow (Collect (Domainp A))) class.monoid_add\"", "lemma monoid_mult_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(A ===> (A ===> A ===> A) ===> (=)) \n      (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult\"", "lemma power_with_transfer[transfer_rule]:  \n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(A ===> (A ===> A ===> A) ===> A ===> (=) ===> A) power_with power_with\"", "lemma comm_monoid_ow: \"comm_monoid = comm_monoid_ow UNIV\"", "lemma comm_monoid_set_ow: \"comm_monoid_set = comm_monoid_set_ow UNIV\"", "lemma comm_monoid_add_ow: \"class.comm_monoid_add = comm_monoid_add_ow UNIV\"", "lemma comm_monoid_mult_ow: \"class.comm_monoid_mult = comm_monoid_mult_ow UNIV\"", "lemma bij_betw_transfer[transfer_rule]:\n  assumes [transfer_rule]:\n    \"bi_unique A\" \"right_total A\" \"bi_unique B\" \"right_total B\" \n  shows \n    \"((A ===> B) ===> rel_set A ===> rel_set B ===> (=)) bij_betw bij_betw\"", "lemma comm_monoid_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\"\n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_ow (Collect (Domainp A))) comm_monoid\"", "lemma comm_monoid_set_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_set_ow (Collect (Domainp A))) comm_monoid_set\"", "lemma comm_monoid_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add\"", "lemma comm_monoid_mult_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult\"", "lemma dvd_with_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> A ===> (=)) \n      (dvd_ow' (Collect (Domainp A))) dvd.with\"", "lemma cancel_comm_monoid_add_ow: \n  \"class.cancel_comm_monoid_add = cancel_comm_monoid_add_ow UNIV\"", "lemma cancel_comm_monoid_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=)) \n      (cancel_comm_monoid_add_ow (Collect (Domainp A))) \n      class.cancel_comm_monoid_add\""], "translations": [["", "lemma not_empty[simp]: \"U \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "using z_closed"], ["proof (prove)\nusing this:\n  \\<^bold>1\\<^sub>o\\<^sub>w \\<in> U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {}", "by blast"], ["", "lemma neutral_map: \"(\\<lambda>y. \\<^bold>1\\<^sub>o\\<^sub>w) ` A \\<subseteq> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y. \\<^bold>1\\<^sub>o\\<^sub>w) ` A \\<subseteq> U", "using z_closed"], ["proof (prove)\nusing this:\n  \\<^bold>1\\<^sub>o\\<^sub>w \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<lambda>y. \\<^bold>1\\<^sub>o\\<^sub>w) ` A \\<subseteq> U", "by auto"], ["", "end"], ["", "locale monoid_ow = semigroup_ow U f + neutral_ow U z\n  for U :: \"'ag set\" and f z +\n  assumes left_neutral_mow[simp]: \"a \\<in> U \\<Longrightarrow> (\\<^bold>1\\<^sub>o\\<^sub>w \\<^bold>*\\<^sub>o\\<^sub>w a) = a\"\n    and right_neutral_mow[simp]: \"a \\<in> U \\<Longrightarrow> (a \\<^bold>*\\<^sub>o\\<^sub>w \\<^bold>1\\<^sub>o\\<^sub>w) = a\""], ["", "locale zero_ow = zero: neutral_ow U zero\n  for U :: \"'ag set\" and zero :: \"'ag\" (\\<open>0\\<^sub>o\\<^sub>w\\<close>)\nbegin"], ["", "notation zero (\\<open>0\\<^sub>o\\<^sub>w\\<close>)"], ["", "lemma zero_closed: \"0\\<^sub>o\\<^sub>w \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0\\<^sub>o\\<^sub>w \\<in> U", "by (rule zero.z_closed)"], ["", "end"], ["", "lemma monoid_ow: \"monoid = monoid_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid = monoid_ow UNIV", "unfolding \n    monoid_def monoid_ow_def monoid_axioms_def monoid_ow_axioms_def\n    neutral_ow_def\n    semigroup_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f z.\n        semigroup_ow UNIV f \\<and>\n        (\\<forall>a. f z a = a) \\<and> (\\<forall>a. f a z = a)) =\n    (\\<lambda>f z.\n        semigroup_ow UNIV f \\<and>\n        z \\<in> UNIV \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> f z a = a) \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> f a z = a))", "by simp"], ["", "locale one_ow = one: neutral_ow U one\n  for U :: \"'ag set\" and one :: \"'ag\" (\\<open>1\\<^sub>o\\<^sub>w\\<close>)\nbegin"], ["", "notation one (\\<open>1\\<^sub>o\\<^sub>w\\<close>)"], ["", "lemma one_closed: \"1\\<^sub>o\\<^sub>w \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sub>o\\<^sub>w \\<in> U", "by (rule one.z_closed)"], ["", "end"], ["", "locale power_ow = one_ow U one + times_ow U times\n  for U :: \"'ag set\" and one :: \"'ag\" (\\<open>1\\<^sub>o\\<^sub>w\\<close>) and times (infixl \\<open>*\\<^sub>o\\<^sub>w\\<close> 70)"], ["", "primrec power_with :: \"['a, ['a, 'a] \\<Rightarrow> 'a, 'a, nat] \\<Rightarrow> 'a\"\n  (\\<open>'(/with _ _ : _ ^\\<^sub>o\\<^sub>w _/')\\<close> [1000, 999, 1000, 1000] 10)\n  where\n    power_0: \"power_with one times a 0 = one\" for one times\n  | power_Suc: \"power_with one times a (Suc n) = \n      times a (power_with one times a n)\" for one times"], ["", "lemma power_with[ud_with]: \"power = power_with 1 (*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (^) = power_with (1::'a) (*)", "apply(intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. x ^ xa = ((with (1::'a) (*) : x ^\\<^sub>o\\<^sub>w xa))", "subgoal for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. x ^ n = ((with (1::'a) (*) : x ^\\<^sub>o\\<^sub>w n))", "by (induction n) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context power_ow\nbegin"], ["", "abbreviation power (\\<open>(_ ^\\<^sub>o\\<^sub>w _)\\<close> [81, 80] 80) where \n  \"power \\<equiv> power_with 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)\""], ["", "end"], ["", "locale monoid_add_ow =\n  semigroup_add_ow U plus + zero_ow U zero for U :: \"'ag set\" and plus zero +\n  assumes add_0_left: \"a \\<in> U \\<Longrightarrow> (0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w a) = a\"\n  assumes add_0_right: \"a \\<in> U \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w) = a\"\nbegin"], ["", "sublocale add: monoid_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close> \\<open>0\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", "by unfold_locales (simp add: add_0_left add_0_right)+"], ["", "end"], ["", "lemma monoid_add_ow: \"class.monoid_add = monoid_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_add = monoid_add_ow UNIV", "unfolding \n    class.monoid_add_def monoid_add_ow_def\n    class.monoid_add_axioms_def monoid_add_ow_axioms_def\n    zero_ow_def neutral_ow_def\n    semigroup_add_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero.\n        semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a. plus zero a = a) \\<and>\n        (\\<forall>a. plus a zero = a)) =\n    (\\<lambda>plus zero.\n        semigroup_add_ow UNIV plus \\<and>\n        zero \\<in> UNIV \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> plus zero a = a) \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> plus a zero = a))", "by simp"], ["", "locale monoid_mult_ow = semigroup_mult_ow U times + one_ow U one \n  for U :: \"'ag set\" and one times  +\n  assumes mult_1_left: \"a \\<in> U \\<Longrightarrow> (1\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a) = a\"\n  assumes mult_1_right: \"a \\<in> U \\<Longrightarrow> (a *\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) = a\"\nbegin"], ["", "sublocale mult: monoid_ow U \\<open>(*\\<^sub>o\\<^sub>w)\\<close> \\<open>1\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_ow U (*\\<^sub>o\\<^sub>w) 1\\<^sub>o\\<^sub>w", "by unfold_locales (simp add: mult_1_left mult_1_right)+"], ["", "sublocale power_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. power_ow U 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", ".."], ["", "end"], ["", "lemma monoid_mult_ow: \"class.monoid_mult = monoid_mult_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_mult = monoid_mult_ow UNIV", "unfolding \n    class.monoid_mult_def monoid_mult_ow_def\n    class.monoid_mult_axioms_def monoid_mult_ow_axioms_def\n    one_ow_def neutral_ow_def\n    semigroup_mult_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times.\n        semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a. times one a = a) \\<and>\n        (\\<forall>a. times a one = a)) =\n    (\\<lambda>one times.\n        semigroup_mult_ow UNIV times \\<and>\n        one \\<in> UNIV \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> times one a = a) \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> times a one = a))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma monoid_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (monoid_ow (Collect (Domainp A))) monoid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     monoid", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     monoid", "let ?P = \"((A ===> A ===> A) ===> A ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     monoid", "let ?monoid_ow = \"monoid_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     monoid", "have \"?P ?monoid_ow (\\<lambda>f z. z \\<in> UNIV \\<and> monoid f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     (\\<lambda>f z. z \\<in> UNIV \\<and> monoid f z)", "unfolding \n      monoid_def monoid_ow_def \n      monoid_axioms_def monoid_ow_axioms_def \n      neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>f z.\n         semigroup_ow (Collect (Domainp A)) f \\<and>\n         z \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> f z a = a) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> f a z = a))\n     (\\<lambda>f z.\n         z \\<in> UNIV \\<and>\n         semigroup f \\<and>\n         (\\<forall>a. f z a = a) \\<and> (\\<forall>a. f a z = a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (11 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rn22) ?ai22 (=)\n 2. Transfer.Rel ((A ===> ?Rn22) ===> ?Rl22) ?ah22 All\n 3. Transfer.Rel (A ===> A ===> ?Rm22) ?ag22 (=)\n 4. Transfer.Rel ((A ===> ?Rm22) ===> ?Rk22) ?af22 All\n 5. Transfer.Rel (?Rk22 ===> ?Rl22 ===> ?Rj22) ?ae22 (\\<and>)\n 6. Transfer.Rel ((A ===> A ===> A) ===> ?Ri22) ?ad22 semigroup\n 7. Transfer.Rel (?Ri22 ===> ?Rj22 ===> ?Rf22) ?ac22 (\\<and>)\n 8. Transfer.Rel ?Rh22 ?ab22 UNIV\n 9. Transfer.Rel (A ===> ?Rh22 ===> ?Re22) ?aa22 (\\<in>)\n 10. Transfer.Rel (?Re22 ===> ?Rf22 ===> (=)) ?a22 (\\<and>)\nA total of 11 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f z.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        z \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> f z a = a) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> f a z = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f z a = a) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f a z = a))", "unfolding Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f z.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        z \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> f z a = a) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> f a z = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow> f z x = x) \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow> f x z = x))", "by blast"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> monoid f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     monoid", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> monoid f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n     monoid", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=)) (monoid_ow (Collect (Domainp A)))\n   monoid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monoid_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (monoid_add_ow (Collect (Domainp A))) class.monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A))) class.monoid_add", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A))) class.monoid_add", "let ?P = \"((A ===> A ===> A) ===> A ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A))) class.monoid_add", "let ?monoid_add_ow = \"monoid_add_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A))) class.monoid_add", "have \"?P ?monoid_add_ow (\\<lambda>f z. z \\<in> UNIV \\<and> class.monoid_add f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A)))\n     (\\<lambda>f z. z \\<in> UNIV \\<and> class.monoid_add f z)", "unfolding \n      class.monoid_add_def monoid_add_ow_def \n      class.monoid_add_axioms_def monoid_add_ow_axioms_def\n      zero_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>plus zero.\n         semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         zero \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             plus zero a = a) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> plus a zero = a))\n     (\\<lambda>f z.\n         z \\<in> UNIV \\<and>\n         class.semigroup_add f \\<and>\n         (\\<forall>a. f z a = a) \\<and> (\\<forall>a. f a z = a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (11 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rn22) ?ai22 (=)\n 2. Transfer.Rel ((A ===> ?Rn22) ===> ?Rl22) ?ah22 All\n 3. Transfer.Rel (A ===> A ===> ?Rm22) ?ag22 (=)\n 4. Transfer.Rel ((A ===> ?Rm22) ===> ?Rk22) ?af22 All\n 5. Transfer.Rel (?Rk22 ===> ?Rl22 ===> ?Rj22) ?ae22 (\\<and>)\n 6. Transfer.Rel ((A ===> A ===> A) ===> ?Ri22) ?ad22 class.semigroup_add\n 7. Transfer.Rel (?Ri22 ===> ?Rj22 ===> ?Rf22) ?ac22 (\\<and>)\n 8. Transfer.Rel ?Rh22 ?ab22 UNIV\n 9. Transfer.Rel (A ===> ?Rh22 ===> ?Re22) ?aa22 (\\<in>)\n 10. Transfer.Rel (?Re22 ===> ?Rf22 ===> (=)) ?a22 (\\<and>)\nA total of 11 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        zero \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus zero a = a) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus a zero = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        semigroup_add_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f z a = a) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f a z = a))", "unfolding Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        zero \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus zero a = a) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus a zero = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        semigroup_add_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow> f z x = x) \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow> f x z = x))", "by blast"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=)) (monoid_add_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> class.monoid_add f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A))) class.monoid_add", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (=)) (monoid_add_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> class.monoid_add f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (monoid_add_ow (Collect (Domainp A))) class.monoid_add", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=)) (monoid_add_ow (Collect (Domainp A)))\n   class.monoid_add\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monoid_mult_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(A ===> (A ===> A ===> A) ===> (=)) \n      (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult", "let ?P = \"(A ===> (A ===> A ===> A) ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult", "let ?monoid_mult_ow = \"monoid_mult_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult", "have \"?P ?monoid_mult_ow (\\<lambda>z f. z \\<in> UNIV \\<and> class.monoid_mult z f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A)))\n     (\\<lambda>z f. z \\<in> UNIV \\<and> class.monoid_mult z f)", "unfolding \n      class.monoid_mult_def monoid_mult_ow_def \n      class.monoid_mult_axioms_def monoid_mult_ow_axioms_def\n      one_ow_def neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>one times.\n         semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n         one \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             times one a = a) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> times a one = a))\n     (\\<lambda>z f.\n         z \\<in> UNIV \\<and>\n         class.semigroup_mult f \\<and>\n         (\\<forall>a. f z a = a) \\<and> (\\<forall>a. f a z = a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (11 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rn22) ?ai22 (=)\n 2. Transfer.Rel ((A ===> ?Rn22) ===> ?Rl22) ?ah22 All\n 3. Transfer.Rel (A ===> A ===> ?Rm22) ?ag22 (=)\n 4. Transfer.Rel ((A ===> ?Rm22) ===> ?Rk22) ?af22 All\n 5. Transfer.Rel (?Rk22 ===> ?Rl22 ===> ?Rj22) ?ae22 (\\<and>)\n 6. Transfer.Rel ((A ===> A ===> A) ===> ?Ri22) ?ad22 class.semigroup_mult\n 7. Transfer.Rel (?Ri22 ===> ?Rj22 ===> ?Rf22) ?ac22 (\\<and>)\n 8. Transfer.Rel ?Rh22 ?ab22 UNIV\n 9. Transfer.Rel (A ===> ?Rh22 ===> ?Re22) ?aa22 (\\<in>)\n 10. Transfer.Rel (?Re22 ===> ?Rf22 ===> (=)) ?a22 (\\<and>)\nA total of 11 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times.\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        one \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            times one a = a) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            times a one = a)) =\n    (\\<lambda>z f.\n        z \\<in> Collect (Domainp A) \\<and>\n        semigroup_mult_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f z a = a) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f a z = a))", "unfolding Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times.\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        one \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            times one a = a) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            times a one = a)) =\n    (\\<lambda>z f.\n        z \\<in> Collect (Domainp A) \\<and>\n        semigroup_mult_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow> f z x = x) \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow> f x z = x))", "by blast"], ["proof (state)\nthis:\n  (A ===> (A ===> A ===> A) ===> (=)) (monoid_mult_ow (Collect (Domainp A)))\n   (\\<lambda>z f. z \\<in> UNIV \\<and> class.monoid_mult z f)\n\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult", "thus ?thesis"], ["proof (prove)\nusing this:\n  (A ===> (A ===> A ===> A) ===> (=)) (monoid_mult_ow (Collect (Domainp A)))\n   (\\<lambda>z f. z \\<in> UNIV \\<and> class.monoid_mult z f)\n\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> (=))\n     (monoid_mult_ow (Collect (Domainp A))) class.monoid_mult", "by simp"], ["proof (state)\nthis:\n  (A ===> (A ===> A ===> A) ===> (=)) (monoid_mult_ow (Collect (Domainp A)))\n   class.monoid_mult\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_with_transfer[transfer_rule]:  \n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(A ===> (A ===> A ===> A) ===> A ===> (=) ===> A) power_with power_with\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> (A ===> A ===> A) ===> A ===> (=) ===> A) power_with power_with", "proof(intro rel_funI, elim subst)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> A ((with x xa : xb ^\\<^sub>o\\<^sub>w xc))\n                          ((with y ya : yb ^\\<^sub>o\\<^sub>w xc))", "fix i i' m m' a a' n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> A ((with x xa : xb ^\\<^sub>o\\<^sub>w xc))\n                          ((with y ya : yb ^\\<^sub>o\\<^sub>w xc))", "assume ii': \"A i i'\" and mm': \"(A ===> A ===> A) m m'\" and aa': \"A a a'\""], ["proof (state)\nthis:\n  A i i'\n  (A ===> A ===> A) m m'\n  A a a'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; A xb yb\\<rbrakk>\n       \\<Longrightarrow> A ((with x xa : xb ^\\<^sub>o\\<^sub>w xc))\n                          ((with y ya : yb ^\\<^sub>o\\<^sub>w xc))", "show \"A (power_with i m a n) (power_with i' m' a' n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ((with i m : a ^\\<^sub>o\\<^sub>w n))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w n))", "apply(induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. A ((with i m : a ^\\<^sub>o\\<^sub>w 0))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w 0))\n 2. \\<And>n.\n       A ((with i m : a ^\\<^sub>o\\<^sub>w n))\n        ((with i' m' : a' ^\\<^sub>o\\<^sub>w n)) \\<Longrightarrow>\n       A ((with i m : a ^\\<^sub>o\\<^sub>w (Suc n)))\n        ((with i' m' : a' ^\\<^sub>o\\<^sub>w (Suc n)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ((with i m : a ^\\<^sub>o\\<^sub>w 0))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w 0))", "by (simp add: ii')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       A ((with i m : a ^\\<^sub>o\\<^sub>w n))\n        ((with i' m' : a' ^\\<^sub>o\\<^sub>w n)) \\<Longrightarrow>\n       A ((with i m : a ^\\<^sub>o\\<^sub>w (Suc n)))\n        ((with i' m' : a' ^\\<^sub>o\\<^sub>w (Suc n)))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. A ((with i m : a ^\\<^sub>o\\<^sub>w n_))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w n_)) \\<Longrightarrow>\n    A ((with i m : a ^\\<^sub>o\\<^sub>w (Suc n_)))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w (Suc n_)))", "using mm' aa'"], ["proof (prove)\nusing this:\n  (A ===> A ===> A) m m'\n  A a a'\n\ngoal (1 subgoal):\n 1. A ((with i m : a ^\\<^sub>o\\<^sub>w n_))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w n_)) \\<Longrightarrow>\n    A ((with i m : a ^\\<^sub>o\\<^sub>w (Suc n_)))\n     ((with i' m' : a' ^\\<^sub>o\\<^sub>w (Suc n_)))", "by (auto elim: rel_funE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  A ((with i m : a ^\\<^sub>o\\<^sub>w n))\n   ((with i' m' : a' ^\\<^sub>o\\<^sub>w n))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context power_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  sbterms: (\\<open>(*)::[?'a::power,?'a::power] \\<Rightarrow> ?'a::power\\<close> to \\<open>(*\\<^sub>o\\<^sub>w)\\<close>) \n    and (\\<open>1::?'a::power\\<close> to \\<open>1\\<^sub>o\\<^sub>w\\<close>)\n  rewriting ctr_simps\n  substituting power_ow_axioms and one.not_empty\nbegin"], ["", "tts_lemma power_Suc:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w Suc n = a *\\<^sub>o\\<^sub>w a ^\\<^sub>o\\<^sub>w n\"\n    is power_class.power.power_Suc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_0:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w 0 = 1\\<^sub>o\\<^sub>w\"\n  is power_class.power.power_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_eq_if:\n  assumes \"p \\<in> U\"\n  shows \"p ^\\<^sub>o\\<^sub>w m = (if m = 0 then 1\\<^sub>o\\<^sub>w else p *\\<^sub>o\\<^sub>w p ^\\<^sub>o\\<^sub>w (m - 1))\"\n    is power_class.power_eq_if"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma simps:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w 0 = 1\\<^sub>o\\<^sub>w\" \n    is power_class.power.simps(1)\n    and \"a ^\\<^sub>o\\<^sub>w Suc n = a *\\<^sub>o\\<^sub>w a ^\\<^sub>o\\<^sub>w n\" \n    is power_class.power.simps(2)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "context monoid_mult_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting monoid_mult_ow_axioms and one.not_empty\n  applying [OF one_closed mult.f_closed']\nbegin"], ["", "tts_lemma power_commuting_commutes:\n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"x *\\<^sub>o\\<^sub>w y = y *\\<^sub>o\\<^sub>w x\"\n  shows \"x ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w y = y *\\<^sub>o\\<^sub>w x ^\\<^sub>o\\<^sub>w n\"\n    is monoid_mult_class.power_commuting_commutes"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma left_right_inverse_power:\n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"x *\\<^sub>o\\<^sub>w y = 1\\<^sub>o\\<^sub>w\"\n  shows \"x ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w y ^\\<^sub>o\\<^sub>w n = 1\\<^sub>o\\<^sub>w\"\n    is monoid_mult_class.left_right_inverse_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_numeral_even:\n  assumes \"z \\<in> U\"\n  shows \"z ^\\<^sub>o\\<^sub>w numeral (num.Bit0 w) = (let w = z ^\\<^sub>o\\<^sub>w numeral w in w *\\<^sub>o\\<^sub>w w)\"\n    is monoid_mult_class.power_numeral_even"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_numeral_odd:\n  assumes \"z \\<in> U\"\n  shows \"z ^\\<^sub>o\\<^sub>w numeral (num.Bit1 w) = (let w = z ^\\<^sub>o\\<^sub>w numeral w in z *\\<^sub>o\\<^sub>w w *\\<^sub>o\\<^sub>w w)\"\n    is monoid_mult_class.power_numeral_odd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus_mult:\n  assumes \"a \\<in> U\" and \"0 < n\"\n  shows \"a ^\\<^sub>o\\<^sub>w (n - 1) *\\<^sub>o\\<^sub>w a = a ^\\<^sub>o\\<^sub>w n\"\n    is monoid_mult_class.power_minus_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_Suc0_right:\n  assumes \"a \\<in> U\" \n  shows \"a ^\\<^sub>o\\<^sub>w Suc 0 = a\"\n    is monoid_mult_class.power_Suc0_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power2_eq_square:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w 2 = a *\\<^sub>o\\<^sub>w a\"\n    is monoid_mult_class.power2_eq_square"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_one_right:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w 1 = a\"\n    is monoid_mult_class.power_one_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_commutes:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w a = a *\\<^sub>o\\<^sub>w a ^\\<^sub>o\\<^sub>w n\"\n    is monoid_mult_class.power_commutes"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power3_eq_cube:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w 3 = a *\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w a\"\n    is monoid_mult_class.power3_eq_cube"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_even_eq:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w (2 * n) = (a ^\\<^sub>o\\<^sub>w n) ^\\<^sub>o\\<^sub>w 2\"\n    is monoid_mult_class.power_even_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_odd_eq:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w Suc (2 * n) = a *\\<^sub>o\\<^sub>w (a ^\\<^sub>o\\<^sub>w n) ^\\<^sub>o\\<^sub>w 2\"\n    is monoid_mult_class.power_odd_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_mult:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w (m * n) = (a ^\\<^sub>o\\<^sub>w m) ^\\<^sub>o\\<^sub>w n\"\n    is monoid_mult_class.power_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_Suc2:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w Suc n = a ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w a\"\n    is monoid_mult_class.power_Suc2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_one: \"1\\<^sub>o\\<^sub>w ^\\<^sub>o\\<^sub>w n = 1\\<^sub>o\\<^sub>w\"\n  is monoid_mult_class.power_one"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_add:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w (m + n) = a ^\\<^sub>o\\<^sub>w m *\\<^sub>o\\<^sub>w a ^\\<^sub>o\\<^sub>w n\"\n    is monoid_mult_class.power_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_mult_numeral:\n  assumes \"a \\<in> U\"\n  shows \"(a ^\\<^sub>o\\<^sub>w numeral m) ^\\<^sub>o\\<^sub>w numeral n = a ^\\<^sub>o\\<^sub>w numeral (m * n)\"\n    is Power.power_mult_numeral"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_add_numeral2:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \n    \"a ^\\<^sub>o\\<^sub>w numeral m *\\<^sub>o\\<^sub>w (a ^\\<^sub>o\\<^sub>w numeral n *\\<^sub>o\\<^sub>w b) = a ^\\<^sub>o\\<^sub>w numeral (m + n) *\\<^sub>o\\<^sub>w b\"\n    is Power.power_add_numeral2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_add_numeral:\n  assumes \"a \\<in> U\"\n  shows \"a ^\\<^sub>o\\<^sub>w numeral m *\\<^sub>o\\<^sub>w a ^\\<^sub>o\\<^sub>w numeral n = a ^\\<^sub>o\\<^sub>w numeral (m + n)\"\n    is Power.power_add_numeral"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Commutative monoids\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_monoid_ow = \n  abel_semigroup_ow U f + neutral_ow U z for U :: \"'ag set\" and f z +\n  assumes comm_neutral: \"a \\<in> U \\<Longrightarrow> (a \\<^bold>*\\<^sub>o\\<^sub>w \\<^bold>1\\<^sub>o\\<^sub>w) = a\"\nbegin"], ["", "sublocale monoid_ow U \\<open>(\\<^bold>*\\<^sub>o\\<^sub>w)\\<close> \\<open>\\<^bold>1\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_ow U (\\<^bold>*\\<^sub>o\\<^sub>w) \\<^bold>1\\<^sub>o\\<^sub>w", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       \\<^bold>1\\<^sub>o\\<^sub>w \\<^bold>*\\<^sub>o\\<^sub>w a = a\n 2. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       a \\<^bold>*\\<^sub>o\\<^sub>w \\<^bold>1\\<^sub>o\\<^sub>w = a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<in> U \\<Longrightarrow>\n    \\<^bold>1\\<^sub>o\\<^sub>w \\<^bold>*\\<^sub>o\\<^sub>w a_ = a_", "by (simp add: comm_neutral commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> U \\<Longrightarrow>\n       a \\<^bold>*\\<^sub>o\\<^sub>w \\<^bold>1\\<^sub>o\\<^sub>w = a", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. a_ \\<in> U \\<Longrightarrow>\n    a_ \\<^bold>*\\<^sub>o\\<^sub>w \\<^bold>1\\<^sub>o\\<^sub>w = a_", "using commute"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> U; ?b \\<in> U\\<rbrakk>\n  \\<Longrightarrow> ?a \\<^bold>*\\<^sub>o\\<^sub>w ?b =\n                    ?b \\<^bold>*\\<^sub>o\\<^sub>w ?a\n\ngoal (1 subgoal):\n 1. a_ \\<in> U \\<Longrightarrow>\n    a_ \\<^bold>*\\<^sub>o\\<^sub>w \\<^bold>1\\<^sub>o\\<^sub>w = a_", "by (simp add: comm_neutral)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma comm_monoid_ow: \"comm_monoid = comm_monoid_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid = comm_monoid_ow UNIV", "unfolding \n    comm_monoid_def comm_monoid_ow_def\n    comm_monoid_axioms_def comm_monoid_ow_axioms_def\n    neutral_ow_def\n    abel_semigroup_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f z.\n        abel_semigroup_ow UNIV f \\<and> (\\<forall>a. f a z = a)) =\n    (\\<lambda>f z.\n        abel_semigroup_ow UNIV f \\<and>\n        z \\<in> UNIV \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> f a z = a))", "by simp"], ["", "locale comm_monoid_set_ow = comm_monoid_ow U f z for U :: \"'ag set\" and f z\nbegin"], ["", "tts_register_sbts \\<open>(\\<^bold>*\\<^sub>o\\<^sub>w)\\<close> | U"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp AGA = (\\<lambda>x. x \\<in> U); bi_unique AGA;\n     right_total AGA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun AGA (rel_fun AGA AGA)\n                          (\\<^bold>*\\<^sub>o\\<^sub>w) rcdt", "by (rule tts_AA_A_transfer[OF f_closed])"], ["", "end"], ["", "lemma comm_monoid_set_ow: \"comm_monoid_set = comm_monoid_set_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_set = comm_monoid_set_ow UNIV", "unfolding comm_monoid_set_def comm_monoid_set_ow_def comm_monoid_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_ow UNIV = comm_monoid_ow UNIV", "by simp"], ["", "locale comm_monoid_add_ow =\n  ab_semigroup_add_ow U plus + zero_ow U zero   \n  for U :: \"'ag set\" and plus zero +\n  assumes add_0[simp]: \"a \\<in> U \\<Longrightarrow> 0\\<^sub>o\\<^sub>w +\\<^sub>o\\<^sub>w a = a\"\nbegin"], ["", "sublocale add: comm_monoid_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close> \\<open>0\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", "by unfold_locales (use add.commute in force)"], ["", "sublocale monoid_add_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close> \\<open>0\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_add_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", "by unfold_locales simp+"], ["", "sublocale sum: comm_monoid_set_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close> \\<open>0\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_set_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w", ".."], ["", "notation sum.F (\\<open>\\<guillemotleft>sum\\<guillemotright>\\<close>)"], ["", "abbreviation Sum (\\<open>\\<Sum>\\<^sub>o\\<^sub>w/ _\\<close> [1000] 1000)\n  where \"\\<Sum>\\<^sub>o\\<^sub>w A \\<equiv> (\\<guillemotleft>sum\\<guillemotright> (\\<lambda>x. x) A)\""], ["", "notation Sum (\\<open>\\<Sum>\\<^sub>o\\<^sub>w/ _\\<close> [1000] 1000)"], ["", "end"], ["", "lemma comm_monoid_add_ow: \"class.comm_monoid_add = comm_monoid_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_add = comm_monoid_add_ow UNIV", "unfolding \n    class.comm_monoid_add_def comm_monoid_add_ow_def\n    class.comm_monoid_add_axioms_def comm_monoid_add_ow_axioms_def\n    zero_ow_def neutral_ow_def\n    ab_semigroup_add_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a. plus zero a = a)) =\n    (\\<lambda>plus zero.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        zero \\<in> UNIV \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> plus zero a = a))", "by simp"], ["", "locale dvd_ow = times_ow U times \n  for U :: \"'ag set\" and times"], ["", "ud \\<open>dvd.dvd\\<close>"], ["", "ud dvd' \\<open>dvd_class.dvd\\<close>"], ["", "ctr relativization\n  synthesis ctr_simps\n  assumes [transfer_domain_rule, transfer_rule]: \"Domainp A = (\\<lambda>x. x \\<in> U)\"\n    and [transfer_rule]: \"bi_unique A\" \"right_total A\"\n  trp (?'a A)\n  in dvd_ow': dvd.with_def \n    (\\<open>(on _ with _: _ \\<guillemotleft>dvd\\<guillemotright> _)\\<close> [1000, 1000, 1000, 1000] 50)"], ["", "ctr parametricity\n  in dvd_ow'': dvd_ow'_def"], ["", "context dvd_ow\nbegin"], ["", "abbreviation dvd (infixr \\<open>\\<guillemotleft>dvd\\<guillemotright>\\<close> 50) where \"a \\<guillemotleft>dvd\\<guillemotright> b \\<equiv> dvd_ow' U (*\\<^sub>o\\<^sub>w) a b\""], ["", "notation dvd (infixr \\<open>\\<guillemotleft>dvd\\<guillemotright>\\<close> 50)"], ["", "end"], ["", "locale comm_monoid_mult_ow =\n  ab_semigroup_mult_ow U times + one_ow U one \n  for U :: \"'ag set\" and times one +\n  assumes mult_1[simp]: \"a \\<in> U \\<Longrightarrow> 1\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w a = a\"\nbegin"], ["", "sublocale dvd_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. dvd_ow U (*\\<^sub>o\\<^sub>w)", ".."], ["", "sublocale mult: comm_monoid_ow U \\<open>(*\\<^sub>o\\<^sub>w)\\<close> \\<open>1\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_ow U (*\\<^sub>o\\<^sub>w) 1\\<^sub>o\\<^sub>w", "by unfold_locales (use mult.commute in force)"], ["", "sublocale monoid_mult_ow U \\<open>1\\<^sub>o\\<^sub>w\\<close> \\<open>(*\\<^sub>o\\<^sub>w)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. monoid_mult_ow U 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", "by unfold_locales simp+"], ["", "sublocale prod: comm_monoid_set_ow U \\<open>(*\\<^sub>o\\<^sub>w)\\<close> \\<open>1\\<^sub>o\\<^sub>w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_set_ow U (*\\<^sub>o\\<^sub>w) 1\\<^sub>o\\<^sub>w", ".."], ["", "notation prod.F (\\<open>\\<guillemotleft>prod\\<guillemotright>\\<close>)"], ["", "abbreviation Prod (\\<open>\\<Prod>\\<^sub>o\\<^sub>w _\\<close> [1000] 1000)\n  where \"\\<Prod>\\<^sub>o\\<^sub>w A \\<equiv> (\\<guillemotleft>prod\\<guillemotright> (\\<lambda>x. x) A)\""], ["", "notation Prod (\\<open>\\<Prod>\\<^sub>o\\<^sub>w _\\<close> [1000] 1000)"], ["", "end"], ["", "lemma comm_monoid_mult_ow: \"class.comm_monoid_mult = comm_monoid_mult_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_monoid_mult = comm_monoid_mult_ow UNIV", "unfolding \n    class.comm_monoid_mult_def comm_monoid_mult_ow_def\n    class.comm_monoid_mult_axioms_def comm_monoid_mult_ow_axioms_def  \n    one_ow_def neutral_ow_def\n    ab_semigroup_mult_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times one.\n        ab_semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a. times one a = a)) =\n    (\\<lambda>times one.\n        ab_semigroup_mult_ow UNIV times \\<and>\n        one \\<in> UNIV \\<and>\n        (\\<forall>a. a \\<in> UNIV \\<longrightarrow> times one a = a))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma bij_betw_transfer[transfer_rule]:\n  assumes [transfer_rule]:\n    \"bi_unique A\" \"right_total A\" \"bi_unique B\" \"right_total B\" \n  shows \n    \"((A ===> B) ===> rel_set A ===> rel_set B ===> (=)) bij_betw bij_betw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> rel_set A ===> rel_set B ===> (=)) bij_betw bij_betw", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> B) ===> rel_set A ===> rel_set B ===> (=))\n     (\\<lambda>f A B.\n         (\\<forall>x\\<in>A.\n             \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y) \\<and>\n         f ` A = B)\n     (\\<lambda>f A B.\n         (\\<forall>x\\<in>A.\n             \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y) \\<and>\n         f ` A = B)", "apply transfer_prover_start"], ["proof (prove)\ngoal (9 subgoals):\n 1. Transfer.Rel ((A ===> B) ===> rel_set A ===> ?Rp21) ?ag21 (`)\n 2. Transfer.Rel (?Rp21 ===> rel_set B ===> ?Rj21) ?af21 (=)\n 3. Transfer.Rel (A ===> A ===> ?Ro21) ?ae21 (=)\n 4. Transfer.Rel (B ===> B ===> ?Rn21) ?ad21 (=)\n 5. Transfer.Rel (?Rn21 ===> ?Ro21 ===> ?Rm21) ?ac21 (\\<longrightarrow>)\n 6. Transfer.Rel (rel_set A ===> (A ===> ?Rm21) ===> ?Rl21) ?ab21 Ball\n 7. Transfer.Rel (rel_set A ===> (A ===> ?Rl21) ===> ?Ri21) ?aa21 Ball\n 8. Transfer.Rel (?Ri21 ===> ?Rj21 ===> (=)) ?a21 (\\<and>)\n 9. (\\<lambda>f A B.\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y) \\<and>\n        f ` A = B) =\n    (\\<lambda>f A B.\n        ?a21\n         (?aa21 A\n           (\\<lambda>x.\n               ?ab21 A (\\<lambda>y. ?ac21 (?ad21 (f x) (f y)) (?ae21 x y))))\n         (?af21 (?ag21 f A) B))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f A B.\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y) \\<and>\n        f ` A = B) =\n    (\\<lambda>f A B.\n        (\\<forall>x\\<in>A.\n            \\<forall>y\\<in>A. f x = f y \\<longrightarrow> x = y) \\<and>\n        f ` A = B)", "by simp"], ["", "lemma comm_monoid_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\"\n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_ow (Collect (Domainp A))) comm_monoid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "let ?P = \"((A ===> A ===> A) ===> A ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "let ?comm_monoid_ow = \"comm_monoid_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "have \"?P ?comm_monoid_ow \n    (\\<lambda>f z. z \\<in> UNIV \\<and> comm_monoid f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A)))\n     (\\<lambda>f z. z \\<in> UNIV \\<and> comm_monoid f z)", "unfolding \n      comm_monoid_ow_def comm_monoid_def  \n      comm_monoid_ow_axioms_def comm_monoid_axioms_def \n      neutral_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>f z.\n         abel_semigroup_ow (Collect (Domainp A)) f \\<and>\n         z \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> f a z = a))\n     (\\<lambda>f z.\n         z \\<in> UNIV \\<and>\n         abel_semigroup f \\<and> (\\<forall>a. f a z = a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (8 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rl15) ?af15 (=)\n 2. Transfer.Rel ((A ===> ?Rl15) ===> ?Rk15) ?ae15 All\n 3. Transfer.Rel ((A ===> A ===> A) ===> ?Rj15) ?ad15 abel_semigroup\n 4. Transfer.Rel (?Rj15 ===> ?Rk15 ===> ?Rg15) ?ac15 (\\<and>)\n 5. Transfer.Rel ?Ri15 ?ab15 UNIV\n 6. Transfer.Rel (A ===> ?Ri15 ===> ?Rf15) ?aa15 (\\<in>)\n 7. Transfer.Rel (?Rf15 ===> ?Rg15 ===> (=)) ?a15 (\\<and>)\n 8. (\\<lambda>f z.\n        abel_semigroup_ow (Collect (Domainp A)) f \\<and>\n        z \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> f a z = a)) =\n    (\\<lambda>f z.\n        ?a15 (?aa15 z ?ab15)\n         (?ac15 (?ad15 f) (?ae15 (\\<lambda>a. ?af15 (f a z) a))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f z.\n        abel_semigroup_ow (Collect (Domainp A)) f \\<and>\n        z \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow> f a z = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        abel_semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f a z = a))", "by auto"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=)) (comm_monoid_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> comm_monoid f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (=)) (comm_monoid_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> comm_monoid f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=)) (comm_monoid_ow (Collect (Domainp A)))\n   comm_monoid\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comm_monoid_set_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_set_ow (Collect (Domainp A))) comm_monoid_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_set_ow (Collect (Domainp A))) comm_monoid_set", "unfolding comm_monoid_set_ow_def comm_monoid_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_ow (Collect (Domainp A))) comm_monoid", "apply transfer_prover_start"], ["proof (prove)\ngoal (2 subgoals):\n 1. Transfer.Rel ((A ===> A ===> A) ===> A ===> (=)) ?x' comm_monoid\n 2. comm_monoid_ow (Collect (Domainp A)) = ?x'", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_monoid_ow (Collect (Domainp A)) =\n    comm_monoid_ow (Collect (Domainp A))", "by simp"], ["", "lemma comm_monoid_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add", "let ?P = \"((A ===> A ===> A) ===> A ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add", "let ?comm_monoid_add_ow = \"comm_monoid_add_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add", "have \"?P ?comm_monoid_add_ow (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_add f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A)))\n     (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_add f z)", "unfolding \n      comm_monoid_add_ow_def class.comm_monoid_add_def \n      zero_ow_def neutral_ow_def \n      comm_monoid_add_ow_axioms_def class.comm_monoid_add_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>plus zero.\n         ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         zero \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> plus zero a = a))\n     (\\<lambda>f z.\n         z \\<in> UNIV \\<and>\n         class.ab_semigroup_add f \\<and> (\\<forall>a. f z a = a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (8 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rl15) ?af15 (=)\n 2. Transfer.Rel ((A ===> ?Rl15) ===> ?Rk15) ?ae15 All\n 3. Transfer.Rel ((A ===> A ===> A) ===> ?Rj15) ?ad15 class.ab_semigroup_add\n 4. Transfer.Rel (?Rj15 ===> ?Rk15 ===> ?Rg15) ?ac15 (\\<and>)\n 5. Transfer.Rel ?Ri15 ?ab15 UNIV\n 6. Transfer.Rel (A ===> ?Ri15 ===> ?Rf15) ?aa15 (\\<in>)\n 7. Transfer.Rel (?Rf15 ===> ?Rg15 ===> (=)) ?a15 (\\<and>)\n 8. (\\<lambda>plus zero.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        zero \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus zero a = a)) =\n    (\\<lambda>f z.\n        ?a15 (?aa15 z ?ab15)\n         (?ac15 (?ad15 f) (?ae15 (\\<lambda>a. ?af15 (f z a) a))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        zero \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus zero a = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        ab_semigroup_add_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f z a = a))", "by auto"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=))\n   (comm_monoid_add_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_add f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (=))\n   (comm_monoid_add_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_add f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=))\n   (comm_monoid_add_ow (Collect (Domainp A))) class.comm_monoid_add\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comm_monoid_mult_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> (=)) \n      (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult", "let ?P = \"((A ===> A ===> A) ===> A ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult", "let ?comm_monoid_mult_ow = \"comm_monoid_mult_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult", "have \"?P ?comm_monoid_mult_ow (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_mult f z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A)))\n     (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_mult f z)", "unfolding \n      comm_monoid_mult_ow_def class.comm_monoid_mult_def \n      one_ow_def neutral_ow_def \n      comm_monoid_mult_ow_axioms_def class.comm_monoid_mult_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>times one.\n         ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n         one \\<in> Collect (Domainp A) \\<and>\n         (\\<forall>a.\n             a \\<in> Collect (Domainp A) \\<longrightarrow> times one a = a))\n     (\\<lambda>f z.\n         z \\<in> UNIV \\<and>\n         class.ab_semigroup_mult f \\<and> (\\<forall>a. f z a = a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (8 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rl15) ?af15 (=)\n 2. Transfer.Rel ((A ===> ?Rl15) ===> ?Rk15) ?ae15 All\n 3. Transfer.Rel ((A ===> A ===> A) ===> ?Rj15) ?ad15\n     class.ab_semigroup_mult\n 4. Transfer.Rel (?Rj15 ===> ?Rk15 ===> ?Rg15) ?ac15 (\\<and>)\n 5. Transfer.Rel ?Ri15 ?ab15 UNIV\n 6. Transfer.Rel (A ===> ?Ri15 ===> ?Rf15) ?aa15 (\\<in>)\n 7. Transfer.Rel (?Rf15 ===> ?Rg15 ===> (=)) ?a15 (\\<and>)\n 8. (\\<lambda>times one.\n        ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        one \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            times one a = a)) =\n    (\\<lambda>f z.\n        ?a15 (?aa15 z ?ab15)\n         (?ac15 (?ad15 f) (?ae15 (\\<lambda>a. ?af15 (f z a) a))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times one.\n        ab_semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        one \\<in> Collect (Domainp A) \\<and>\n        (\\<forall>a.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            times one a = a)) =\n    (\\<lambda>f z.\n        z \\<in> Collect (Domainp A) \\<and>\n        ab_semigroup_mult_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A). f z a = a))", "by auto"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=))\n   (comm_monoid_mult_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_mult f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> A ===> (=))\n   (comm_monoid_mult_ow (Collect (Domainp A)))\n   (\\<lambda>f z. z \\<in> UNIV \\<and> class.comm_monoid_mult f z)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> (=))\n     (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> A ===> (=))\n   (comm_monoid_mult_ow (Collect (Domainp A))) class.comm_monoid_mult\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dvd_with_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> A ===> A ===> (=)) \n      (dvd_ow' (Collect (Domainp A))) dvd.with\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> A ===> (=))\n     (dvd_ow' (Collect (Domainp A))) dvd.with", "unfolding dvd_ow'_def dvd.with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> A ===> A ===> (=))\n     (\\<lambda>times b a. \\<exists>k\\<in>Collect (Domainp A). a = times b k)\n     (\\<lambda>times b a. \\<exists>k. a = times b k)", "by transfer_prover"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context dvd_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  sbterms: (\\<open>(*)::[?'a::times, ?'a::times] \\<Rightarrow> ?'a::times\\<close> to \\<open>(*\\<^sub>o\\<^sub>w)\\<close>)\n  rewriting ctr_simps\n  substituting dvd_ow_axioms \n  eliminating through simp\nbegin"], ["", "tts_lemma dvdI:\n  assumes \"b \\<in> U\" and \"k \\<in> U\" and \"a = b *\\<^sub>o\\<^sub>w k\"\n  shows \"b \\<guillemotleft>dvd\\<guillemotright> a\"\n    is dvd_class.dvdI"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvdE:\n  assumes \"b \\<in> U\" \n    and \"a \\<in> U\" \n    and \"b \\<guillemotleft>dvd\\<guillemotright> a\" \n    and \"\\<And>k. \\<lbrakk>k \\<in> U; a = b *\\<^sub>o\\<^sub>w k\\<rbrakk> \\<Longrightarrow> P\"\n  shows P\n    is dvd_class.dvdE"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "context comm_monoid_mult_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting comm_monoid_mult_ow_axioms and one.not_empty\n  applying [OF mult.f_closed' one_closed]\nbegin"], ["", "tts_lemma strict_subset_divisors_dvd:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \n    \"({x \\<in> U. x \\<guillemotleft>dvd\\<guillemotright> a} \\<subset> {x \\<in> U. x \\<guillemotleft>dvd\\<guillemotright> b}) = (a \\<guillemotleft>dvd\\<guillemotright> b \\<and> \\<not> b \\<guillemotleft>dvd\\<guillemotright> a)\"\n    is comm_monoid_mult_class.strict_subset_divisors_dvd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subset_divisors_dvd:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"({x \\<in> U. x \\<guillemotleft>dvd\\<guillemotright> a} \\<subseteq> {x \\<in> U. x \\<guillemotleft>dvd\\<guillemotright> b}) = (a \\<guillemotleft>dvd\\<guillemotright> b)\"\n    is comm_monoid_mult_class.subset_divisors_dvd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_mult_distrib:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"(a *\\<^sub>o\\<^sub>w b) ^\\<^sub>o\\<^sub>w n = a ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w b ^\\<^sub>o\\<^sub>w n\"\n    is Power.comm_monoid_mult_class.power_mult_distrib"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_triv_right:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> b *\\<^sub>o\\<^sub>w a\"\n    is comm_monoid_mult_class.dvd_triv_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_mult_right:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\" and \"a *\\<^sub>o\\<^sub>w b \\<guillemotleft>dvd\\<guillemotright> c\"\n  shows \"b \\<guillemotleft>dvd\\<guillemotright> c\"\n    is comm_monoid_mult_class.dvd_mult_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_dvd_mono:\n  assumes \"a \\<in> U\" \n    and \"b \\<in> U\" \n    and \"c \\<in> U\" \n    and \"d \\<in> U\"\n    and \"a \\<guillemotleft>dvd\\<guillemotright> b\"\n    and \"c \\<guillemotleft>dvd\\<guillemotright> d\"\n  shows \"a *\\<^sub>o\\<^sub>w c \\<guillemotleft>dvd\\<guillemotright> b *\\<^sub>o\\<^sub>w d\"\n    is comm_monoid_mult_class.mult_dvd_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_triv_left:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> a *\\<^sub>o\\<^sub>w b\"\n    is comm_monoid_mult_class.dvd_triv_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_mult_left:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\" and \"a *\\<^sub>o\\<^sub>w b \\<guillemotleft>dvd\\<guillemotright> c\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> c\"\n    is comm_monoid_mult_class.dvd_mult_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_trans:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\" and \"a \\<guillemotleft>dvd\\<guillemotright> b\" and \"b \\<guillemotleft>dvd\\<guillemotright> c\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> c\"\n    is comm_monoid_mult_class.dvd_trans"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_mult2:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\" and \"a \\<guillemotleft>dvd\\<guillemotright> b\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> b *\\<^sub>o\\<^sub>w c\"\n    is comm_monoid_mult_class.dvd_mult2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_refl:\n  assumes \"a \\<in> U\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> a\"\n    is comm_monoid_mult_class.dvd_refl"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_mult:\n  assumes \"a \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\" and \"a \\<guillemotleft>dvd\\<guillemotright> c\"\n  shows \"a \\<guillemotleft>dvd\\<guillemotright> b *\\<^sub>o\\<^sub>w c\"\n    is comm_monoid_mult_class.dvd_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma one_dvd:\n  assumes \"a \\<in> U\"\n  shows \"1\\<^sub>o\\<^sub>w \\<guillemotleft>dvd\\<guillemotright> a\"\n    is comm_monoid_mult_class.one_dvd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Cancellative commutative monoids\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale cancel_comm_monoid_add_ow =\n  cancel_ab_semigroup_add_ow U plus minus +\n  comm_monoid_add_ow U plus zero\n  for U :: \"'ag set\" and plus minus zero"], ["", "lemma cancel_comm_monoid_add_ow: \n  \"class.cancel_comm_monoid_add = cancel_comm_monoid_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.cancel_comm_monoid_add = cancel_comm_monoid_add_ow UNIV", "unfolding \n    class.cancel_comm_monoid_add_def cancel_comm_monoid_add_ow_def\n    cancel_ab_semigroup_add_ow comm_monoid_add_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus zero.\n        cancel_ab_semigroup_add_ow UNIV plus minus \\<and>\n        comm_monoid_add_ow UNIV plus zero) =\n    (\\<lambda>plus minus zero.\n        cancel_ab_semigroup_add_ow UNIV plus minus \\<and>\n        comm_monoid_add_ow UNIV plus zero)", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma cancel_comm_monoid_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=)) \n      (cancel_comm_monoid_add_ow (Collect (Domainp A))) \n      class.cancel_comm_monoid_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=))\n     (cancel_comm_monoid_add_ow (Collect (Domainp A)))\n     class.cancel_comm_monoid_add", "unfolding cancel_comm_monoid_add_ow_def class.cancel_comm_monoid_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> A ===> (=))\n     (\\<lambda>plus minus zero.\n         cancel_ab_semigroup_add_ow (Collect (Domainp A)) plus minus \\<and>\n         comm_monoid_add_ow (Collect (Domainp A)) plus zero)\n     (\\<lambda>plus minus zero.\n         class.cancel_ab_semigroup_add plus minus \\<and>\n         class.comm_monoid_add plus zero)", "by transfer_prover"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context cancel_comm_monoid_add_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting cancel_comm_monoid_add_ow_axioms and zero.not_empty\n  applying [OF add.f_closed' minus_closed' zero_closed]\nbegin"], ["", "tts_lemma add_cancel_right_right:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"(a = a +\\<^sub>o\\<^sub>w b) = (b = 0\\<^sub>o\\<^sub>w)\"\n    is cancel_comm_monoid_add_class.add_cancel_right_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_cancel_right_left:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"(a = b +\\<^sub>o\\<^sub>w a) = (b = 0\\<^sub>o\\<^sub>w)\"\n    is cancel_comm_monoid_add_class.add_cancel_right_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_cancel_left_right:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"(a +\\<^sub>o\\<^sub>w b = a) = (b = 0\\<^sub>o\\<^sub>w)\"\n    is cancel_comm_monoid_add_class.add_cancel_left_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_cancel_left_left:\n  assumes \"b \\<in> U\" and \"a \\<in> U\"\n  shows \"(b +\\<^sub>o\\<^sub>w a = a) = (b = 0\\<^sub>o\\<^sub>w)\"\n    is cancel_comm_monoid_add_class.add_cancel_left_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_implies_diff:\n  assumes \"c \\<in> U\" and \"b \\<in> U\" and \"a \\<in> U\" and \"c +\\<^sub>o\\<^sub>w b = a\"\n  shows \"c = a -\\<^sub>o\\<^sub>w b\"\n    is cancel_comm_monoid_add_class.add_implies_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma diff_cancel:\n  assumes \"a \\<in> U\"\n  shows \"a -\\<^sub>o\\<^sub>w a = 0\\<^sub>o\\<^sub>w\"\n    is cancel_comm_monoid_add_class.diff_cancel"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma diff_zero:\n  assumes \"a \\<in> U\"\n  shows \"a -\\<^sub>o\\<^sub>w 0\\<^sub>o\\<^sub>w = a\"\n    is cancel_comm_monoid_add_class.diff_zero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}