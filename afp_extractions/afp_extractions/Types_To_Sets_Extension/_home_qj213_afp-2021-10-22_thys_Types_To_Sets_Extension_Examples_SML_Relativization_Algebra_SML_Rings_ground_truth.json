{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/SML_Relativization/Algebra/SML_Rings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma ring_ow: \"class.ring = ring_ow UNIV\"", "lemma ring_ow_UNIV_axioms: \"ring_ow (UNIV::'a::ring set) (+) 0 (-) uminus (*)\"", "lemma ring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (A ===> A) ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) \n    (ring_ow (Collect (Domainp A))) class.ring\"", "lemma comm_ring_ow: \"class.comm_ring = comm_ring_ow UNIV\"", "lemma comm_ring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (A ===> A) ===>\n      (A ===> A ===> A) ===>\n      (=)\n    ) \n    (comm_ring_ow (Collect (Domainp A))) class.comm_ring\"", "lemma ring_1_ow: \"class.ring_1 = ring_1_ow UNIV\"", "lemma ring_1_ow_UNIV_axioms: \n  \"ring_1_ow (UNIV::'a::ring_1 set) 1 (*) (+) 0 (-) uminus\"", "lemma Int_ss_UNIV: \"\\<int> \\<subseteq> UNIV\"", "lemma ring_1_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      A ===> \n      (A ===> A ===> A) ===>\n      (A ===> A ===> A) ===>\n      A ===>\n      (A ===> A ===> A) ===> \n      (A ===> A) ===>\n      (=)\n    ) \n      (ring_1_ow (Collect (Domainp A))) class.ring_1\"", "lemma Int_closed[simp,intro]: \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright> \\<Longrightarrow> a \\<in> U\"", "lemmas [ud_with] = dvd.with dvd'.with", "lemma comm_ring_1_ow: \"class.comm_ring_1 = comm_ring_1_ow UNIV\"", "lemma comm_ring_1_ow_UNIV_axioms:\n  \"comm_ring_1_ow (UNIV::'a::comm_ring_1 set) (*) 1 (+) 0 (-) uminus\"", "lemma comm_ring_1_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===>\n      A ===> \n      (A ===> A ===> A) ===>\n      A ===>\n      (A ===> A ===> A) ===> \n      (A ===> A) ===>\n      (=)\n    ) (comm_ring_1_ow (Collect (Domainp A))) class.comm_ring_1\""], "translations": [["", "lemma ring_ow: \"class.ring = ring_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ring = ring_ow UNIV", "unfolding class.ring_def ring_ow_def ab_group_add_ow semiring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero minus uminus times.\n        ab_group_add_ow UNIV plus zero minus uminus \\<and>\n        semiring_ow UNIV plus times) =\n    (\\<lambda>plus zero minus uminus times.\n        semiring_ow UNIV plus times \\<and>\n        ab_group_add_ow UNIV plus zero minus uminus)", "by (simp add: conj_commute)"], ["", "lemma ring_ow_UNIV_axioms: \"ring_ow (UNIV::'a::ring set) (+) 0 (-) uminus (*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ow UNIV (+) (0::'a) (-) uminus (*)", "by (fold ring_ow) (rule ring_class.ring_axioms)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma ring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (A ===> A) ===> \n      (A ===> A ===> A) ===> \n      (=)\n    ) \n    (ring_ow (Collect (Domainp A))) class.ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     A ===>\n     (A ===> A ===> A) ===> (A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (ring_ow (Collect (Domainp A))) class.ring", "unfolding ring_ow_def class.ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     A ===>\n     (A ===> A ===> A) ===> (A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus zero minus uminus times.\n         semiring_ow (Collect (Domainp A)) plus times \\<and>\n         ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus)\n     (\\<lambda>plus zero minus uminus times.\n         class.ab_group_add plus zero minus uminus \\<and>\n         class.semiring plus times)", "apply transfer_prover_start"], ["proof (prove)\ngoal (4 subgoals):\n 1. Transfer.Rel ((A ===> A ===> A) ===> (A ===> A ===> A) ===> ?Ri11) ?ab11\n     class.semiring\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===>\n      A ===> (A ===> A ===> A) ===> (A ===> A) ===> ?Rh11)\n     ?aa11 class.ab_group_add\n 3. Transfer.Rel (?Rh11 ===> ?Ri11 ===> (=)) ?a11 (\\<and>)\n 4. (\\<lambda>plus zero minus uminus times.\n        semiring_ow (Collect (Domainp A)) plus times \\<and>\n        ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus) =\n    (\\<lambda>plus zero minus uminus times.\n        ?a11 (?aa11 plus zero minus uminus) (?ab11 plus times))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero minus uminus times.\n        semiring_ow (Collect (Domainp A)) plus times \\<and>\n        ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus) =\n    (\\<lambda>plus zero minus uminus times.\n        ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus \\<and>\n        semiring_ow (Collect (Domainp A)) plus times)", "by blast"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context ring_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting ring_ow_axioms and zero.not_empty\n  applying \n    [\n      OF \n        plus_closed' \n        zero_closed \n        minus_closed' \n        add.inverse_closed'' \n        times_closed'\n    ] \nbegin"], ["", "tts_lemma right_diff_distrib:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \"a *\\<^sub>o\\<^sub>w (b -\\<^sub>o\\<^sub>w c) = a *\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\"\n    is Rings.ring_class.right_diff_distrib"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_mult_commute:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w b = a *\\<^sub>o\\<^sub>w -\\<^sub>o\\<^sub>w b\"\n    is Rings.ring_class.minus_mult_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma left_diff_distrib:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \"(a -\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w c -\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\"\n    is Rings.ring_class.left_diff_distrib"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_minus_right:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"a *\\<^sub>o\\<^sub>w -\\<^sub>o\\<^sub>w b = -\\<^sub>o\\<^sub>w (a *\\<^sub>o\\<^sub>w b)\"\n    is Rings.ring_class.mult_minus_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_mult_right:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w (a *\\<^sub>o\\<^sub>w b) = a *\\<^sub>o\\<^sub>w -\\<^sub>o\\<^sub>w b\"\n    is Rings.ring_class.minus_mult_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_mult_minus:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w -\\<^sub>o\\<^sub>w b = a *\\<^sub>o\\<^sub>w b\"\n    is Rings.ring_class.minus_mult_minus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_minus_left:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w b = -\\<^sub>o\\<^sub>w (a *\\<^sub>o\\<^sub>w b)\"\n    is Rings.ring_class.mult_minus_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_mult_left:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w (a *\\<^sub>o\\<^sub>w b) = -\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w b\"\n    is Rings.ring_class.minus_mult_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma ring_distribs:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \n    \"a *\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) = a *\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\"\n    \"(a +\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w c +\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\"\n    \"(a -\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w c -\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c\"\n    \"a *\\<^sub>o\\<^sub>w (b -\\<^sub>o\\<^sub>w c) = a *\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w c\"\n    is Rings.ring_class.ring_distribs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma eq_add_iff2:\n  assumes \"a \\<in> U\" and \"e \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\" and \"d \\<in> U\"\n  shows \"(a *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w c = b *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w d) = (c = (b -\\<^sub>o\\<^sub>w a) *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w d)\"\n    is Rings.ring_class.eq_add_iff2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma eq_add_iff1:\n  assumes \"a \\<in> U\" and \"e \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\" and \"d \\<in> U\"\n  shows \"(a *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w c = b *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w d) = ((a -\\<^sub>o\\<^sub>w b) *\\<^sub>o\\<^sub>w e +\\<^sub>o\\<^sub>w c = d)\"\n    is Rings.ring_class.eq_add_iff1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_diff_mult:\n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"x *\\<^sub>o\\<^sub>w y -\\<^sub>o\\<^sub>w a *\\<^sub>o\\<^sub>w b = x *\\<^sub>o\\<^sub>w (y -\\<^sub>o\\<^sub>w b) +\\<^sub>o\\<^sub>w (x -\\<^sub>o\\<^sub>w a) *\\<^sub>o\\<^sub>w b\"\n    is Real.mult_diff_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Commutative rings\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_ring_ow =\n  comm_semiring_ow U plus times + ab_group_add_ow U plus zero minus uminus\n  for U :: \"'ag set\" and plus zero minus uminus times\nbegin"], ["", "sublocale ring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_ow U (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w (-\\<^sub>o\\<^sub>w)\n     uminus (*\\<^sub>o\\<^sub>w)", ".."], ["", "sublocale comm_semiring_0_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_0_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", ".."], ["", "end"], ["", "lemma comm_ring_ow: \"class.comm_ring = comm_ring_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_ring = comm_ring_ow UNIV", "unfolding \n    class.comm_ring_def comm_ring_ow_def \n    ab_group_add_ow comm_semiring_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero minus uminus times.\n        ab_group_add_ow UNIV plus zero minus uminus \\<and>\n        comm_semiring_ow UNIV plus times) =\n    (\\<lambda>plus zero minus uminus times.\n        comm_semiring_ow UNIV plus times \\<and>\n        ab_group_add_ow UNIV plus zero minus uminus)", "by (simp add: conj_commute)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma comm_ring_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===> \n      A ===> \n      (A ===> A ===> A) ===> \n      (A ===> A) ===>\n      (A ===> A ===> A) ===>\n      (=)\n    ) \n    (comm_ring_ow (Collect (Domainp A))) class.comm_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     A ===>\n     (A ===> A ===> A) ===> (A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (comm_ring_ow (Collect (Domainp A))) class.comm_ring", "unfolding comm_ring_ow_def class.comm_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     A ===>\n     (A ===> A ===> A) ===> (A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus zero minus uminus times.\n         comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n         ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus)\n     (\\<lambda>plus zero minus uminus times.\n         class.ab_group_add plus zero minus uminus \\<and>\n         class.comm_semiring plus times)", "apply transfer_prover_start"], ["proof (prove)\ngoal (4 subgoals):\n 1. Transfer.Rel ((A ===> A ===> A) ===> (A ===> A ===> A) ===> ?Ri11) ?ab11\n     class.comm_semiring\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===>\n      A ===> (A ===> A ===> A) ===> (A ===> A) ===> ?Rh11)\n     ?aa11 class.ab_group_add\n 3. Transfer.Rel (?Rh11 ===> ?Ri11 ===> (=)) ?a11 (\\<and>)\n 4. (\\<lambda>plus zero minus uminus times.\n        comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n        ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus) =\n    (\\<lambda>plus zero minus uminus times.\n        ?a11 (?aa11 plus zero minus uminus) (?ab11 plus times))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus zero minus uminus times.\n        comm_semiring_ow (Collect (Domainp A)) plus times \\<and>\n        ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus) =\n    (\\<lambda>plus zero minus uminus times.\n        ab_group_add_ow (Collect (Domainp A)) plus zero minus uminus \\<and>\n        comm_semiring_ow (Collect (Domainp A)) plus times)", "by blast"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context comm_ring_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting comm_ring_ow_axioms and zero.not_empty\n  applying \n    [\n      OF \n        plus_closed' \n        zero_closed \n        minus_closed' \n        add.inverse_closed'' \n        times_closed'\n    ] \nbegin"], ["", "tts_lemma square_diff_square_factored:\n  assumes \"x \\<in> U\" and \"y \\<in> U\"\n  shows \"x *\\<^sub>o\\<^sub>w x -\\<^sub>o\\<^sub>w y *\\<^sub>o\\<^sub>w y = (x +\\<^sub>o\\<^sub>w y) *\\<^sub>o\\<^sub>w (x -\\<^sub>o\\<^sub>w y)\"\n    is comm_ring_class.square_diff_square_factored"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Rings with identity\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale ring_1_ow =\n  ring_ow U plus zero minus uminus times + \n  zero_neq_one_ow U one zero + \n  monoid_mult_ow U one times \n  for U :: \"'ag set\" and one times plus zero minus uminus\nbegin"], ["", "sublocale semiring_1_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring_1_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w)", ".."], ["", "end"], ["", "lemma ring_1_ow: \"class.ring_1 = ring_1_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ring_1 = ring_1_ow UNIV", "unfolding \n    class.ring_1_def ring_1_ow_def monoid_mult_ow ring_ow zero_neq_one_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times plus zero minus uminus.\n        monoid_mult_ow UNIV one times \\<and>\n        ring_ow UNIV plus zero minus uminus times \\<and>\n        zero_neq_one_ow UNIV one zero) =\n    (\\<lambda>one times plus zero minus uminus.\n        ring_ow UNIV plus zero minus uminus times \\<and>\n        zero_neq_one_ow UNIV one zero \\<and> monoid_mult_ow UNIV one times)", "by (force simp: conj_commute)"], ["", "lemma ring_1_ow_UNIV_axioms: \n  \"ring_1_ow (UNIV::'a::ring_1 set) 1 (*) (+) 0 (-) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_1_ow UNIV (1::'a) (*) (+) (0::'a) (-) uminus", "by (fold ring_1_ow) (rule ring_1_class.ring_1_axioms)"], ["", "ud \\<open>ring_1.iszero\\<close> (\\<open>(with _ : \\<guillemotleft>iszero\\<guillemotright> _)\\<close> [1000, 1000] 10)"], ["", "ud iszero' \\<open>iszero\\<close>"], ["", "ud \\<open>ring_1.of_int\\<close>\n  (\\<open>(with _ _ _ _ : \\<guillemotleft>of'_int\\<guillemotright> _)\\<close> [1000, 999, 998, 997, 1000] 10)"], ["", "ud of_int' \\<open>of_int\\<close>"], ["", "ud \\<open>ring_1.Ints\\<close> (\\<open>(with _ _ _ _ : \\<int>)\\<close> [1000, 999, 998, 997] 10)"], ["", "ud Ints' \\<open>Ints\\<close>"], ["", "ud \\<open>diffs\\<close> (\\<open>(with _ _ _ _ : \\<guillemotleft>diffs\\<guillemotright> _)\\<close> [1000, 999, 998, 997, 1000] 10)"], ["", "ctr parametricity  \n  in iszero_ow: iszero.with_def \n    and of_int_ow: of_int.with_def\n    and Ints_ow: Ints.with_def\n    and diffs_ow: diffs.with_def"], ["", "context ring_1_ow\nbegin"], ["", "abbreviation iszero where \"iszero \\<equiv> iszero.with 0\\<^sub>o\\<^sub>w\""], ["", "abbreviation of_int where \"of_int \\<equiv> of_int.with 1\\<^sub>o\\<^sub>w (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w (-\\<^sub>o\\<^sub>w)\""], ["", "abbreviation Ints (\\<open>\\<guillemotleft>\\<int>\\<guillemotright>\\<close>) where \"\\<guillemotleft>\\<int>\\<guillemotright> \\<equiv> Ints.with 1\\<^sub>o\\<^sub>w (+\\<^sub>o\\<^sub>w) 0\\<^sub>o\\<^sub>w (-\\<^sub>o\\<^sub>w)\""], ["", "notation Ints (\\<open>\\<guillemotleft>\\<int>\\<guillemotright>\\<close>)"], ["", "end"], ["", "context ring_1\nbegin"], ["", "lemma Int_ss_UNIV: \"\\<int> \\<subseteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<int> \\<subseteq> UNIV", "by simp"], ["", "end"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma ring_1_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      A ===> \n      (A ===> A ===> A) ===>\n      (A ===> A ===> A) ===>\n      A ===>\n      (A ===> A ===> A) ===> \n      (A ===> A) ===>\n      (=)\n    ) \n      (ring_1_ow (Collect (Domainp A))) class.ring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===>\n     (A ===> A ===> A) ===>\n     (A ===> A ===> A) ===>\n     A ===> (A ===> A ===> A) ===> (A ===> A) ===> (=))\n     (ring_1_ow (Collect (Domainp A))) class.ring_1", "unfolding ring_1_ow_def class.ring_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===>\n     (A ===> A ===> A) ===>\n     (A ===> A ===> A) ===>\n     A ===> (A ===> A ===> A) ===> (A ===> A) ===> (=))\n     (\\<lambda>one times plus zero minus uminus.\n         ring_ow (Collect (Domainp A)) plus zero minus uminus times \\<and>\n         zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n         monoid_mult_ow (Collect (Domainp A)) one times)\n     (\\<lambda>one times plus zero minus uminus.\n         class.monoid_mult one times \\<and>\n         class.ring plus zero minus uminus times \\<and>\n         class.zero_neq_one one zero)", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rm16) ?ad16 class.zero_neq_one\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===>\n      A ===>\n      (A ===> A ===> A) ===> (A ===> A) ===> (A ===> A ===> A) ===> ?Rl16)\n     ?ac16 class.ring\n 3. Transfer.Rel (?Rl16 ===> ?Rm16 ===> ?Rj16) ?ab16 (\\<and>)\n 4. Transfer.Rel (A ===> (A ===> A ===> A) ===> ?Ri16) ?aa16\n     class.monoid_mult\n 5. Transfer.Rel (?Ri16 ===> ?Rj16 ===> (=)) ?a16 (\\<and>)\n 6. (\\<lambda>one times plus zero minus uminus.\n        ring_ow (Collect (Domainp A)) plus zero minus uminus times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        monoid_mult_ow (Collect (Domainp A)) one times) =\n    (\\<lambda>one times plus zero minus uminus.\n        ?a16 (?aa16 one times)\n         (?ab16 (?ac16 plus zero minus uminus times) (?ad16 one zero)))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>one times plus zero minus uminus.\n        ring_ow (Collect (Domainp A)) plus zero minus uminus times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        monoid_mult_ow (Collect (Domainp A)) one times) =\n    (\\<lambda>one times plus zero minus uminus.\n        monoid_mult_ow (Collect (Domainp A)) one times \\<and>\n        ring_ow (Collect (Domainp A)) plus zero minus uminus times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero)", "by blast"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "declare dvd.with[ud_with del]"], ["", "declare dvd'.with[ud_with del]"], ["", "context ring_1_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  substituting ring_1_ow_axioms and zero.not_empty\n  eliminating through simp\nbegin"], ["", "tts_lemma Int_ss_UNIV[simp]: \"\\<guillemotleft>\\<int>\\<guillemotright> \\<subseteq> U\"\n  is Int_ss_UNIV"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "lemma Int_closed[simp,intro]: \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright> \\<Longrightarrow> a \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> \\<guillemotleft>\\<int>\\<guillemotright> \\<Longrightarrow>\n    a \\<in> U", "using Int_ss_UNIV"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<int>\\<guillemotright> \\<subseteq> U\n\ngoal (1 subgoal):\n 1. a \\<in> \\<guillemotleft>\\<int>\\<guillemotright> \\<Longrightarrow>\n    a \\<in> U", "by blast"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting ring_1_ow_axioms and zero.not_empty\n  eliminating through auto\nbegin"], ["", "tts_lemma iszero_0: \"iszero 0\\<^sub>o\\<^sub>w\"\n  is ring_1_class.iszero_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma not_iszero_1: \"\\<not> iszero 1\\<^sub>o\\<^sub>w\"\n  is ring_1_class.not_iszero_1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_subset_Ints: \"\\<guillemotleft>\\<nat>\\<guillemotright> \\<subseteq> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  is Int.ring_1_class.Nats_subset_Ints"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_1: \"1\\<^sub>o\\<^sub>w \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  is Int.ring_1_class.Ints_1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_0: \"0\\<^sub>o\\<^sub>w \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  is Int.ring_1_class.Ints_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma not_iszero_neg_1: \"\\<not> iszero (-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w)\"\n  is Num.ring_1_class.not_iszero_neg_1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_1: \"of_int 1 = 1\\<^sub>o\\<^sub>w\"\n  is Int.ring_1_class.of_int_1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_0: \"of_int 0 = 0\\<^sub>o\\<^sub>w\"\n  is Int.ring_1_class.of_int_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_of_int: \"of_int z \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  is Int.ring_1_class.Ints_of_int"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_of_nat: \"of_nat n \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  is Int.ring_1_class.Ints_of_nat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_of_nat_eq:\n  shows \"local.of_int (with 1 (+) 0 : \\<guillemotleft>of_nat\\<guillemotright> n) = local.of_nat n\"\n    is Int.ring_1_class.of_int_of_nat_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_of_bool:\n  \"of_int (with 1 0 : \\<guillemotleft>of_bool\\<guillemotright> P) = of_bool P\"\n  is Int.ring_1_class.of_int_of_bool"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_minus: \"of_int (- z) = -\\<^sub>o\\<^sub>w of_int z\"\n  is Int.ring_1_class.of_int_minus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_minus1_right:\n  assumes \"z \\<in> U\"\n  shows \"z *\\<^sub>o\\<^sub>w -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w = -\\<^sub>o\\<^sub>w z\"\n    is Num.ring_1_class.mult_minus1_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_minus1:\n  assumes \"z \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w z = -\\<^sub>o\\<^sub>w z\"\n    is Num.ring_1_class.mult_minus1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma eq_iff_iszero_diff:\n  assumes \"x \\<in> U\" and \"y \\<in> U\"\n  shows \"(x = y) = iszero (x -\\<^sub>o\\<^sub>w y)\"\n    is Num.ring_1_class.eq_iff_iszero_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_in_Ints_iff:\n  assumes \"x \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w x \\<in> \\<guillemotleft>\\<int>\\<guillemotright>) = (x \\<in> \\<guillemotleft>\\<int>\\<guillemotright>)\"\n    is Int.ring_1_class.minus_in_Ints_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma mult_of_int_commute:\n  assumes \"y \\<in> U\"\n  shows \"of_int x *\\<^sub>o\\<^sub>w y = y *\\<^sub>o\\<^sub>w of_int x\"\n    is Int.ring_1_class.mult_of_int_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_power:\n  \"of_int ((with 1 (*) : z ^\\<^sub>o\\<^sub>w n)) = of_int z ^\\<^sub>o\\<^sub>w n\"\n    is Int.ring_1_class.of_int_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_minus:\n  assumes \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  shows \"-\\<^sub>o\\<^sub>w a \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n    is Int.ring_1_class.Ints_minus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_diff: \"of_int (w - z) = of_int w -\\<^sub>o\\<^sub>w of_int z\"\n  is Int.ring_1_class.of_int_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_add: \"of_int (w + z) = of_int w +\\<^sub>o\\<^sub>w of_int z\"\n  is Int.ring_1_class.of_int_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_mult: \"of_int (w * z) = of_int w *\\<^sub>o\\<^sub>w of_int z\"\n  is Int.ring_1_class.of_int_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus1_even: \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w (2 * n) = 1\\<^sub>o\\<^sub>w\"\n  is Power.ring_1_class.power_minus1_even"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_power:\n  assumes \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  shows \"a ^\\<^sub>o\\<^sub>w n \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n    is Int.ring_1_class.Ints_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_nat_nat:\n  assumes \"0 \\<le> z\"\n  shows \"of_nat (nat z) = of_int z\"\n    is Int.ring_1_class.of_nat_nat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power2_minus:\n  assumes \"a \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w 2 = a ^\\<^sub>o\\<^sub>w 2\"\n    is Power.ring_1_class.power2_minus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus1_odd:\n  shows \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w Suc (2 * n) = -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w\"\n    is Power.ring_1_class.power_minus1_odd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus:\n  assumes \"a \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w n = (-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w a ^\\<^sub>o\\<^sub>w n\"\n    is Power.ring_1_class.power_minus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma square_diff_one_factored:\n  assumes \"x \\<in> U\"\n  shows \"x *\\<^sub>o\\<^sub>w x -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w = (x +\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) *\\<^sub>o\\<^sub>w (x -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w)\"\n    is Rings.ring_1_class.square_diff_one_factored"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma neg_one_even_power:\n  assumes \"even n\"\n  shows \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n = 1\\<^sub>o\\<^sub>w\"\n    is Parity.ring_1_class.neg_one_even_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_one_power_iff:\n  \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n = (if even n then 1\\<^sub>o\\<^sub>w else -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w)\"\n    is Parity.ring_1_class.minus_one_power_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Nats_altdef1: \"\\<guillemotleft>\\<nat>\\<guillemotright> = {x \\<in> U. \\<exists>y\\<ge>0. x = of_int y}\"\n    is Int.ring_1_class.Nats_altdef1"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_induct:\n  assumes \"q \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\" and \"\\<And>z. P (of_int z)\"\n  shows \"P q\"\n    is Int.ring_1_class.Ints_induct"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma of_int_of_nat:\n  shows \n    \"of_int k = (if k < 0 then -\\<^sub>o\\<^sub>w of_nat (nat (- k)) else of_nat (nat k))\"\n    is Int.ring_1_class.of_int_of_nat"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_diff:\n  assumes \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\" and \"b \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  shows \"a -\\<^sub>o\\<^sub>w b \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n    is Int.ring_1_class.Ints_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_add:\n  assumes \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\" and \"b \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  shows \"a +\\<^sub>o\\<^sub>w b \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n    is Int.ring_1_class.Ints_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_mult:\n  assumes \"a \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\" and \"b \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n  shows \"a *\\<^sub>o\\<^sub>w b \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\"\n    is Int.ring_1_class.Ints_mult"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus_even':\n  assumes \"a \\<in> U\" and \"even n\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w n = a ^\\<^sub>o\\<^sub>w n\"\n    is Parity.ring_1_class.power_minus_even"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus_even:\n  assumes \"a \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w (2 * n) = a ^\\<^sub>o\\<^sub>w (2 * n)\"\n    is Power.ring_1_class.power_minus_even"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power_minus_odd:\n  assumes \"a \\<in> U\" and \"odd n\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w n = -\\<^sub>o\\<^sub>w (a ^\\<^sub>o\\<^sub>w n)\"\n    is Parity.ring_1_class.power_minus_odd"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma uminus_power_if:\n  assumes \"a \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w n = (if even n then a ^\\<^sub>o\\<^sub>w n else -\\<^sub>o\\<^sub>w (a ^\\<^sub>o\\<^sub>w n))\"\n    is Parity.ring_1_class.uminus_power_if"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma neg_one_power_add_eq_neg_one_power_diff:\n  assumes \"k \\<le> n\"\n  shows \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w (n + k) = (-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w (n - k)\"\n    is Parity.ring_1_class.neg_one_power_add_eq_neg_one_power_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma neg_one_odd_power:\n  assumes \"odd n\"\n  shows \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n = -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w\"\n    is Parity.ring_1_class.neg_one_odd_power"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma Ints_cases:\n  assumes \"q \\<in> \\<guillemotleft>\\<int>\\<guillemotright>\" and \"\\<And>z. q = of_int z \\<Longrightarrow> thesis\"\n  shows thesis\n    is Int.ring_1_class.Ints_cases"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "lemmas [ud_with] = dvd.with dvd'.with"], ["", "subsection\\<open>Commutative rings with identity\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale comm_ring_1_ow =\n  comm_ring_ow U plus zero minus uminus times + \n  zero_neq_one_ow U one zero + \n  comm_monoid_mult_ow U times one \n  for U :: \"'ag set\" and times one plus zero minus uminus\nbegin"], ["", "sublocale ring_1_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_1_ow U 1\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w) (+\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w (-\\<^sub>o\\<^sub>w) uminus", ".."], ["", "sublocale comm_semiring_1_cancel_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_semiring_1_cancel_ow U (+\\<^sub>o\\<^sub>w) (-\\<^sub>o\\<^sub>w)\n     0\\<^sub>o\\<^sub>w (*\\<^sub>o\\<^sub>w) 1\\<^sub>o\\<^sub>w", "by unfold_locales (blast intro: right_diff_distrib)"], ["", "end"], ["", "lemma comm_ring_1_ow: \"class.comm_ring_1 = comm_ring_1_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.comm_ring_1 = comm_ring_1_ow UNIV", "unfolding \n    class.comm_ring_1_def comm_ring_1_ow_def\n    comm_monoid_mult_ow comm_ring_ow zero_neq_one_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times one plus zero minus uminus.\n        comm_monoid_mult_ow UNIV times one \\<and>\n        comm_ring_ow UNIV plus zero minus uminus times \\<and>\n        zero_neq_one_ow UNIV one zero) =\n    (\\<lambda>times one plus zero minus uminus.\n        comm_ring_ow UNIV plus zero minus uminus times \\<and>\n        zero_neq_one_ow UNIV one zero \\<and>\n        comm_monoid_mult_ow UNIV times one)", "by (force simp: conj_commute)"], ["", "lemma comm_ring_1_ow_UNIV_axioms:\n  \"comm_ring_1_ow (UNIV::'a::comm_ring_1 set) (*) 1 (+) 0 (-) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_1_ow UNIV (*) (1::'a) (+) (0::'a) (-) uminus", "by (fold comm_ring_1_ow) (rule comm_ring_1_class.comm_ring_1_axioms)"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma comm_ring_1_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> A) ===>\n      A ===> \n      (A ===> A ===> A) ===>\n      A ===>\n      (A ===> A ===> A) ===> \n      (A ===> A) ===>\n      (=)\n    ) (comm_ring_1_ow (Collect (Domainp A))) class.comm_ring_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     A ===>\n     (A ===> A ===> A) ===>\n     A ===> (A ===> A ===> A) ===> (A ===> A) ===> (=))\n     (comm_ring_1_ow (Collect (Domainp A))) class.comm_ring_1", "unfolding comm_ring_1_ow_def class.comm_ring_1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===>\n     A ===>\n     (A ===> A ===> A) ===>\n     A ===> (A ===> A ===> A) ===> (A ===> A) ===> (=))\n     (\\<lambda>times one plus zero minus uminus.\n         comm_ring_ow (Collect (Domainp A)) plus zero minus uminus\n          times \\<and>\n         zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n         comm_monoid_mult_ow (Collect (Domainp A)) times one)\n     (\\<lambda>times one plus zero minus uminus.\n         class.comm_monoid_mult times one \\<and>\n         class.comm_ring plus zero minus uminus times \\<and>\n         class.zero_neq_one one zero)", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rm16) ?ad16 class.zero_neq_one\n 2. Transfer.Rel\n     ((A ===> A ===> A) ===>\n      A ===>\n      (A ===> A ===> A) ===> (A ===> A) ===> (A ===> A ===> A) ===> ?Rl16)\n     ?ac16 class.comm_ring\n 3. Transfer.Rel (?Rl16 ===> ?Rm16 ===> ?Rj16) ?ab16 (\\<and>)\n 4. Transfer.Rel ((A ===> A ===> A) ===> A ===> ?Ri16) ?aa16\n     class.comm_monoid_mult\n 5. Transfer.Rel (?Ri16 ===> ?Rj16 ===> (=)) ?a16 (\\<and>)\n 6. (\\<lambda>times one plus zero minus uminus.\n        comm_ring_ow (Collect (Domainp A)) plus zero minus uminus\n         times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        comm_monoid_mult_ow (Collect (Domainp A)) times one) =\n    (\\<lambda>times one plus zero minus uminus.\n        ?a16 (?aa16 times one)\n         (?ab16 (?ac16 plus zero minus uminus times) (?ad16 one zero)))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times one plus zero minus uminus.\n        comm_ring_ow (Collect (Domainp A)) plus zero minus uminus\n         times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero \\<and>\n        comm_monoid_mult_ow (Collect (Domainp A)) times one) =\n    (\\<lambda>times one plus zero minus uminus.\n        comm_monoid_mult_ow (Collect (Domainp A)) times one \\<and>\n        comm_ring_ow (Collect (Domainp A)) plus zero minus uminus\n         times \\<and>\n        zero_neq_one_ow (Collect (Domainp A)) one zero)", "by blast"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context comm_ring_1_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting comm_ring_1_ow_axioms and zero.not_empty\n  applying \n    [\n      OF \n        times_closed' \n        one_closed \n        plus_closed'\n        zero_closed \n        minus_closed'\n        add.inverse_closed''\n    ]\nbegin"], ["", "tts_lemma ring_normalization_rules:\n  assumes \"x \\<in> U\"\n  shows \"-\\<^sub>o\\<^sub>w x = -\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w *\\<^sub>o\\<^sub>w x\" \"y \\<in> U \\<Longrightarrow> x -\\<^sub>o\\<^sub>w y = x +\\<^sub>o\\<^sub>w -\\<^sub>o\\<^sub>w y\"\n    is comm_ring_1_class.ring_normalization_rules"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma left_minus_one_mult_self:\n  assumes \"a \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w ((-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w a) = a\"\n    is Power.comm_ring_1_class.left_minus_one_mult_self"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_power_mult_self:\n  assumes \"a \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w (-\\<^sub>o\\<^sub>w a) ^\\<^sub>o\\<^sub>w n = a ^\\<^sub>o\\<^sub>w (2 * n)\"\n    is Power.comm_ring_1_class.minus_power_mult_self"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_one_mult_self: \"(-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n *\\<^sub>o\\<^sub>w (-\\<^sub>o\\<^sub>w 1\\<^sub>o\\<^sub>w) ^\\<^sub>o\\<^sub>w n = 1\\<^sub>o\\<^sub>w\"\n  is comm_ring_1_class.minus_one_mult_self"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma power2_commute:\n  assumes \"x \\<in> U\" and \"y \\<in> U\"\n  shows \"(x -\\<^sub>o\\<^sub>w y) ^\\<^sub>o\\<^sub>w 2 = (y -\\<^sub>o\\<^sub>w x) ^\\<^sub>o\\<^sub>w 2\"\n    is comm_ring_1_class.power2_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma minus_dvd_iff:\n  assumes \"x \\<in> U\" and \"y \\<in> U\"\n  shows \"(-\\<^sub>o\\<^sub>w x \\<guillemotleft>dvd\\<guillemotright> y) = (x \\<guillemotleft>dvd\\<guillemotright> y)\"\n    is comm_ring_1_class.minus_dvd_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_minus_iff:\n  assumes \"x \\<in> U\" and \"y \\<in> U\"\n  shows \"(x \\<guillemotleft>dvd\\<guillemotright> -\\<^sub>o\\<^sub>w y) = (x \\<guillemotleft>dvd\\<guillemotright> y)\"\n    is comm_ring_1_class.dvd_minus_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dvd_diff:\n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"z \\<in> U\" and \"x \\<guillemotleft>dvd\\<guillemotright> y\" and \"x \\<guillemotleft>dvd\\<guillemotright> z\"\n  shows \"x \\<guillemotleft>dvd\\<guillemotright> y -\\<^sub>o\\<^sub>w z\"\n    is comm_ring_1_class.dvd_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}