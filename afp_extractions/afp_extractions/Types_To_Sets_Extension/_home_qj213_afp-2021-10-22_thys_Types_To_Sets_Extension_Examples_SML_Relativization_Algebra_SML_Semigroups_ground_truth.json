{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/SML_Relativization/Algebra/SML_Semigroups.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma f_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x \\<^bold>*\\<^sub>o\\<^sub>w y \\<in> U\"", "lemma semigroup_ow: \"semigroup = semigroup_ow UNIV\"", "lemma plus_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x +\\<^sub>o\\<^sub>w y \\<in> U\"", "lemma times_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x *\\<^sub>o\\<^sub>w y \\<in> U\"", "lemma semigroup_add_ow: \"class.semigroup_add = semigroup_add_ow UNIV\"", "lemma semigroup_mult_ow: \"class.semigroup_mult = semigroup_mult_ow UNIV\"", "lemma semigroup_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (semigroup_ow (Collect (Domainp A))) semigroup\"", "lemma semigroup_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (semigroup_add_ow (Collect (Domainp A))) class.semigroup_add\"", "lemma semigroup_mult_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (semigroup_mult_ow (Collect (Domainp A))) class.semigroup_mult\"", "lemma cancel_semigroup_add_ow: \n  \"class.cancel_semigroup_add = cancel_semigroup_add_ow UNIV\"", "lemma cancel_semigroup_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (cancel_semigroup_add_ow (Collect (Domainp A)))  \n      class.cancel_semigroup_add\"", "lemma fun_left_comm: \n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"z \\<in> U\" \n  shows \"y \\<^bold>*\\<^sub>o\\<^sub>w (x \\<^bold>*\\<^sub>o\\<^sub>w z) = x \\<^bold>*\\<^sub>o\\<^sub>w (y \\<^bold>*\\<^sub>o\\<^sub>w z)\"", "lemma abel_semigroup_ow: \"abel_semigroup = abel_semigroup_ow UNIV\"", "lemma ab_semigroup_add_ow: \"class.ab_semigroup_add = ab_semigroup_add_ow UNIV\"", "lemma ab_semigroup_mult_ow: \n  \"class.ab_semigroup_mult = ab_semigroup_mult_ow UNIV\"", "lemma abel_semigroup_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (abel_semigroup_ow (Collect (Domainp A))) abel_semigroup\"", "lemma ab_semigroup_add_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (ab_semigroup_add_ow (Collect (Domainp A))) class.ab_semigroup_add\"", "lemma ab_semigroup_mult_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (ab_semigroup_mult_ow (Collect (Domainp A))) class.ab_semigroup_mult\"", "lemma minus_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x -\\<^sub>o\\<^sub>w y \\<in> U\"", "lemma cancel_ab_semigroup_add_ow: \n  \"class.cancel_ab_semigroup_add = cancel_ab_semigroup_add_ow UNIV\"", "lemma cancel_ab_semigroup_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=)) \n      (cancel_ab_semigroup_add_ow (Collect (Domainp A))) \n      class.cancel_ab_semigroup_add\""], "translations": [["", "lemma f_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x \\<^bold>*\\<^sub>o\\<^sub>w y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U.\n       \\<forall>y\\<in>U. x \\<^bold>*\\<^sub>o\\<^sub>w y \\<in> U", "by (simp add: f_closed)"], ["", "tts_register_sbts \\<open>(\\<^bold>*\\<^sub>o\\<^sub>w)\\<close> | U"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp AGA = (\\<lambda>x. x \\<in> U); bi_unique AGA;\n     right_total AGA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun AGA (rel_fun AGA AGA)\n                          (\\<^bold>*\\<^sub>o\\<^sub>w) rcdt", "by (rule tts_AA_A_transfer[OF f_closed])"], ["", "end"], ["", "lemma semigroup_ow: \"semigroup = semigroup_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semigroup = semigroup_ow UNIV", "unfolding semigroup_def semigroup_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. \\<forall>a b c. f (f a b) c = f a (f b c)) =\n    (\\<lambda>f.\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> f a b \\<in> UNIV) \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow> f (f a b) c = f a (f b c)))", "by simp"], ["", "locale plus_ow =\n  fixes U :: \"'ag set\" and plus :: \"['ag, 'ag] \\<Rightarrow> 'ag\" (infixl \\<open>+\\<^sub>o\\<^sub>w\\<close> 65)\n  assumes plus_closed[simp, intro]: \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b \\<in> U\"\nbegin"], ["", "notation plus (infixl \\<open>+\\<^sub>o\\<^sub>w\\<close> 65)"], ["", "lemma plus_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x +\\<^sub>o\\<^sub>w y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U. \\<forall>y\\<in>U. x +\\<^sub>o\\<^sub>w y \\<in> U", "by simp"], ["", "tts_register_sbts \\<open>(+\\<^sub>o\\<^sub>w)\\<close> | U"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp AGA = (\\<lambda>x. x \\<in> U); bi_unique AGA;\n     right_total AGA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun AGA (rel_fun AGA AGA) (+\\<^sub>o\\<^sub>w)\n                          rcdt", "by (rule tts_AA_A_transfer[OF plus_closed])"], ["", "end"], ["", "locale times_ow =\n  fixes U :: \"'ag set\" and times :: \"['ag, 'ag] \\<Rightarrow> 'ag\" (infixl \\<open>*\\<^sub>o\\<^sub>w\\<close> 70)\n  assumes times_closed[simp, intro]: \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w b \\<in> U\"\nbegin"], ["", "notation times (infixl \\<open>*\\<^sub>o\\<^sub>w\\<close> 70)"], ["", "lemma times_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x *\\<^sub>o\\<^sub>w y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U. \\<forall>y\\<in>U. x *\\<^sub>o\\<^sub>w y \\<in> U", "by simp"], ["", "tts_register_sbts \\<open>(*\\<^sub>o\\<^sub>w)\\<close> | U"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp AGA = (\\<lambda>x. x \\<in> U); bi_unique AGA;\n     right_total AGA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun AGA (rel_fun AGA AGA) (*\\<^sub>o\\<^sub>w)\n                          rcdt", "by (rule tts_AA_A_transfer[OF times_closed])"], ["", "end"], ["", "locale semigroup_add_ow = plus_ow U plus \n  for U :: \"'ag set\" and plus +\n  assumes plus_assoc: \n    \"\\<lbrakk> a \\<in> U; b \\<in> U; c \\<in> U \\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w c = a +\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c)\"\nbegin"], ["", "sublocale add: semigroup_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. semigroup_ow U (+\\<^sub>o\\<^sub>w)", "by unfold_locales (auto simp: plus_assoc)"], ["", "end"], ["", "lemma semigroup_add_ow: \"class.semigroup_add = semigroup_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semigroup_add = semigroup_add_ow UNIV", "unfolding \n    class.semigroup_add_def semigroup_add_ow_def\n    semigroup_add_ow_axioms_def plus_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus. \\<forall>a b c. plus (plus a b) c = plus a (plus b c)) =\n    (\\<lambda>plus.\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> plus a b \\<in> UNIV) \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            plus (plus a b) c = plus a (plus b c)))", "by simp"], ["", "locale semigroup_mult_ow = times_ow U times \n  for U :: \"'ag set\" and times +\n  assumes mult_assoc: \n    \"\\<lbrakk> a \\<in> U; b \\<in> U; c \\<in> U \\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w (b *\\<^sub>o\\<^sub>w c)\"\nbegin"], ["", "sublocale mult: semigroup_ow U \\<open>(*\\<^sub>o\\<^sub>w)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. semigroup_ow U (*\\<^sub>o\\<^sub>w)", "by unfold_locales (auto simp: times_closed' mult_assoc)"], ["", "end"], ["", "lemma semigroup_mult_ow: \"class.semigroup_mult = semigroup_mult_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semigroup_mult = semigroup_mult_ow UNIV", "unfolding \n    class.semigroup_mult_def semigroup_mult_ow_def\n    semigroup_mult_ow_axioms_def times_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times.\n        \\<forall>a b c. times (times a b) c = times a (times b c)) =\n    (\\<lambda>times.\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> times a b \\<in> UNIV) \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            times (times a b) c = times a (times b c)))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma semigroup_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (semigroup_ow (Collect (Domainp A))) semigroup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "let ?P = \"((A ===> A ===> A) ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "let ?semigroup_ow = \"semigroup_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "let ?rf_UNIV = \n    \"(\\<lambda>f::['b, 'b] \\<Rightarrow> 'b. (\\<forall>x y. x \\<in> UNIV \\<longrightarrow> y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "have \"?P ?semigroup_ow (\\<lambda>f. ?rf_UNIV f \\<and> semigroup f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     (\\<lambda>f.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n         semigroup f)", "unfolding semigroup_ow_def semigroup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>f.\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             f a b \\<in> Collect (Domainp A)) \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             f (f a b) c = f a (f b c)))\n     (\\<lambda>f.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n         (\\<forall>a b c. f (f a b) c = f a (f b c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (16 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rr32) ?an32 (=)\n 2. Transfer.Rel ((A ===> ?Rr32) ===> ?Rq32) ?am32 All\n 3. Transfer.Rel ((A ===> ?Rq32) ===> ?Rp32) ?al32 All\n 4. Transfer.Rel ((A ===> ?Rp32) ===> ?Re32) ?ak32 All\n 5. Transfer.Rel ?Ro32 ?aj32 UNIV\n 6. Transfer.Rel (A ===> ?Ro32 ===> ?Rm32) ?ai32 (\\<in>)\n 7. Transfer.Rel ?Rn32 ?ah32 UNIV\n 8. Transfer.Rel (A ===> ?Rn32 ===> ?Rl32) ?ag32 (\\<in>)\n 9. Transfer.Rel (?Rl32 ===> ?Rm32 ===> ?Rj32) ?af32 (\\<longrightarrow>)\n 10. Transfer.Rel ?Rk32 ?ae32 UNIV\nA total of 16 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            f a b \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            f (f a b) c = f a (f b c))) =\n    (\\<lambda>f.\n        (\\<forall>x\\<in>Collect (Domainp A).\n            \\<forall>y\\<in>Collect (Domainp A).\n               x \\<in> Collect (Domainp A) \\<longrightarrow>\n               y \\<in> Collect (Domainp A) \\<longrightarrow>\n               f x y \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  f (f a b) c = f a (f b c)))", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n   (\\<lambda>f.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n       semigroup f)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n   (\\<lambda>f.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n       semigroup f)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n     semigroup", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (=)) (semigroup_ow (Collect (Domainp A)))\n   semigroup\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma semigroup_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (semigroup_add_ow (Collect (Domainp A))) class.semigroup_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "let ?P = \"((A ===> A ===> A) ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "let ?semigroup_add_ow = \"(\\<lambda>f. semigroup_add_ow (Collect (Domainp A)) f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "let ?rf_UNIV = \n    \"(\\<lambda>f::['b, 'b] \\<Rightarrow> 'b. (\\<forall>x y. x \\<in> UNIV \\<longrightarrow> y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "have \"?P ?semigroup_add_ow (\\<lambda>f. ?rf_UNIV f \\<and> class.semigroup_add f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     (\\<lambda>f.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n         class.semigroup_add f)", "unfolding \n      semigroup_add_ow_def class.semigroup_add_def\n      semigroup_add_ow_axioms_def plus_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>f.\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             f a b \\<in> Collect (Domainp A)) \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             f (f a b) c = f a (f b c)))\n     (\\<lambda>f.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n         (\\<forall>a b c. f (f a b) c = f a (f b c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (16 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rr32) ?an32 (=)\n 2. Transfer.Rel ((A ===> ?Rr32) ===> ?Rq32) ?am32 All\n 3. Transfer.Rel ((A ===> ?Rq32) ===> ?Rp32) ?al32 All\n 4. Transfer.Rel ((A ===> ?Rp32) ===> ?Re32) ?ak32 All\n 5. Transfer.Rel ?Ro32 ?aj32 UNIV\n 6. Transfer.Rel (A ===> ?Ro32 ===> ?Rm32) ?ai32 (\\<in>)\n 7. Transfer.Rel ?Rn32 ?ah32 UNIV\n 8. Transfer.Rel (A ===> ?Rn32 ===> ?Rl32) ?ag32 (\\<in>)\n 9. Transfer.Rel (?Rl32 ===> ?Rm32 ===> ?Rj32) ?af32 (\\<longrightarrow>)\n 10. Transfer.Rel ?Rk32 ?ae32 UNIV\nA total of 16 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            f a b \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            f (f a b) c = f a (f b c))) =\n    (\\<lambda>f.\n        (\\<forall>x\\<in>Collect (Domainp A).\n            \\<forall>y\\<in>Collect (Domainp A).\n               x \\<in> Collect (Domainp A) \\<longrightarrow>\n               y \\<in> Collect (Domainp A) \\<longrightarrow>\n               f x y \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  f (f a b) c = f a (f b c)))", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n   (\\<lambda>f.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n       class.semigroup_add f)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n   (\\<lambda>f.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n       class.semigroup_add f)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n     class.semigroup_add", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (=)) (semigroup_add_ow (Collect (Domainp A)))\n   class.semigroup_add\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma semigroup_mult_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (semigroup_mult_ow (Collect (Domainp A))) class.semigroup_mult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "let ?P = \"((A ===> A ===> A) ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "let ?semigroup_mult_ow = \"(\\<lambda>f. semigroup_mult_ow (Collect (Domainp A)) f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "let ?rf_UNIV = \n    \"(\\<lambda>f::['b, 'b] \\<Rightarrow> 'b. (\\<forall>x y. x \\<in> UNIV \\<longrightarrow> y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "have \"?P ?semigroup_mult_ow (\\<lambda>f. ?rf_UNIV f \\<and> class.semigroup_mult f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     (\\<lambda>f.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n         class.semigroup_mult f)", "unfolding \n      semigroup_mult_ow_def class.semigroup_mult_def\n      semigroup_mult_ow_axioms_def times_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>f.\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             f a b \\<in> Collect (Domainp A)) \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             f (f a b) c = f a (f b c)))\n     (\\<lambda>f.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n         (\\<forall>a b c. f (f a b) c = f a (f b c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (16 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rr32) ?an32 (=)\n 2. Transfer.Rel ((A ===> ?Rr32) ===> ?Rq32) ?am32 All\n 3. Transfer.Rel ((A ===> ?Rq32) ===> ?Rp32) ?al32 All\n 4. Transfer.Rel ((A ===> ?Rp32) ===> ?Re32) ?ak32 All\n 5. Transfer.Rel ?Ro32 ?aj32 UNIV\n 6. Transfer.Rel (A ===> ?Ro32 ===> ?Rm32) ?ai32 (\\<in>)\n 7. Transfer.Rel ?Rn32 ?ah32 UNIV\n 8. Transfer.Rel (A ===> ?Rn32 ===> ?Rl32) ?ag32 (\\<in>)\n 9. Transfer.Rel (?Rl32 ===> ?Rm32 ===> ?Rj32) ?af32 (\\<longrightarrow>)\n 10. Transfer.Rel ?Rk32 ?ae32 UNIV\nA total of 16 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            f a b \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            f (f a b) c = f a (f b c))) =\n    (\\<lambda>f.\n        (\\<forall>x\\<in>Collect (Domainp A).\n            \\<forall>y\\<in>Collect (Domainp A).\n               x \\<in> Collect (Domainp A) \\<longrightarrow>\n               y \\<in> Collect (Domainp A) \\<longrightarrow>\n               f x y \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  f (f a b) c = f a (f b c)))", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n   (\\<lambda>f.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n       class.semigroup_mult f)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n   (\\<lambda>f.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV) \\<and>\n       class.semigroup_mult f)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n     class.semigroup_mult", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (=)) (semigroup_mult_ow (Collect (Domainp A)))\n   class.semigroup_mult\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>Cancellative semigroups\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale cancel_semigroup_add_ow = semigroup_add_ow U plus\n  for U :: \"'ag set\" and plus +\n  assumes add_left_imp_eq: \n    \"\\<lbrakk> a \\<in> U; b \\<in> U; c \\<in> U; a +\\<^sub>o\\<^sub>w b = a +\\<^sub>o\\<^sub>w c \\<rbrakk> \\<Longrightarrow> b = c\"\n  assumes add_right_imp_eq: \n    \"\\<lbrakk> b \\<in> U; a \\<in> U; c \\<in> U; b +\\<^sub>o\\<^sub>w a = c +\\<^sub>o\\<^sub>w a \\<rbrakk> \\<Longrightarrow> b = c\""], ["", "lemma cancel_semigroup_add_ow: \n  \"class.cancel_semigroup_add = cancel_semigroup_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.cancel_semigroup_add = cancel_semigroup_add_ow UNIV", "unfolding \n    class.cancel_semigroup_add_def cancel_semigroup_add_ow_def\n    cancel_semigroup_add_ow_axioms_def class.cancel_semigroup_add_axioms_def\n    semigroup_add_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus.\n        semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a b c. plus a b = plus a c \\<longrightarrow> b = c) \\<and>\n        (\\<forall>b a c. plus b a = plus c a \\<longrightarrow> b = c)) =\n    (\\<lambda>plus.\n        semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            plus a b = plus a c \\<longrightarrow> b = c) \\<and>\n        (\\<forall>b a c.\n            b \\<in> UNIV \\<longrightarrow>\n            a \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            plus b a = plus c a \\<longrightarrow> b = c))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma cancel_semigroup_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (cancel_semigroup_add_ow (Collect (Domainp A)))  \n      class.cancel_semigroup_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (cancel_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_semigroup_add", "unfolding cancel_semigroup_add_ow_def class.cancel_semigroup_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>plus.\n         semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         cancel_semigroup_add_ow_axioms (Collect (Domainp A)) plus)\n     (\\<lambda>plus.\n         class.semigroup_add plus \\<and>\n         class.cancel_semigroup_add_axioms plus)", "unfolding \n    cancel_semigroup_add_ow_axioms_def class.cancel_semigroup_add_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>plus.\n         semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             plus a b = plus a c \\<longrightarrow> b = c) \\<and>\n         (\\<forall>b a c.\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             plus b a = plus c a \\<longrightarrow> b = c))\n     (\\<lambda>plus.\n         class.semigroup_add plus \\<and>\n         (\\<forall>a b c.\n             plus a b = plus a c \\<longrightarrow> b = c) \\<and>\n         (\\<forall>b a c. plus b a = plus c a \\<longrightarrow> b = c))", "apply transfer_prover_start"], ["proof (prove)\ngoal (16 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rt34) ?an34 (=)\n 2. Transfer.Rel (A ===> A ===> ?Rs34) ?am34 (=)\n 3. Transfer.Rel (?Rs34 ===> ?Rt34 ===> ?Rr34) ?al34 (\\<longrightarrow>)\n 4. Transfer.Rel ((A ===> ?Rr34) ===> ?Rq34) ?ak34 All\n 5. Transfer.Rel ((A ===> ?Rq34) ===> ?Rp34) ?aj34 All\n 6. Transfer.Rel ((A ===> ?Rp34) ===> ?Rj34) ?ai34 All\n 7. Transfer.Rel (A ===> A ===> ?Ro34) ?ah34 (=)\n 8. Transfer.Rel (A ===> A ===> ?Rn34) ?ag34 (=)\n 9. Transfer.Rel (?Rn34 ===> ?Ro34 ===> ?Rm34) ?af34 (\\<longrightarrow>)\n 10. Transfer.Rel ((A ===> ?Rm34) ===> ?Rl34) ?ae34 All\nA total of 16 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus a b = plus a c \\<longrightarrow> b = c) \\<and>\n        (\\<forall>b a c.\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus b a = plus c a \\<longrightarrow> b = c)) =\n    (\\<lambda>plus.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  plus a b = plus a c \\<longrightarrow> b = c) \\<and>\n        (\\<forall>b\\<in>Collect (Domainp A).\n            \\<forall>a\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  plus b a = plus c a \\<longrightarrow> b = c))", "by simp"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context cancel_semigroup_add_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting cancel_semigroup_add_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma add_right_cancel:\n  assumes \"b \\<in> U\" and \"a \\<in> U\" and \"c \\<in> U\"\n  shows \"(b +\\<^sub>o\\<^sub>w a = c +\\<^sub>o\\<^sub>w a) = (b = c)\"\n  is cancel_semigroup_add_class.add_right_cancel"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_left_cancel:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \"(a +\\<^sub>o\\<^sub>w b = a +\\<^sub>o\\<^sub>w c) = (b = c)\"\n  is cancel_semigroup_add_class.add_left_cancel"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma bij_betw_add:\n  assumes \"a \\<in> U\" and \"A \\<subseteq> U\" and \"B \\<subseteq> U\"\n  shows \"bij_betw ((+\\<^sub>o\\<^sub>w) a) A B = ((+\\<^sub>o\\<^sub>w) a ` A = B)\"\n    is cancel_semigroup_add_class.bij_betw_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma inj_on_add:\n  assumes \"a \\<in> U\" and \"A \\<subseteq> U\"\n  shows \"inj_on ((+\\<^sub>o\\<^sub>w) a) A\"\n    is cancel_semigroup_add_class.inj_on_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma inj_add_left:\n  assumes \"a \\<in> U\"\n  shows \"inj_on ((+\\<^sub>o\\<^sub>w) a) U\"\n    is cancel_semigroup_add_class.inj_add_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma inj_on_add':\n  assumes \"a \\<in> U\" and \"A \\<subseteq> U\"\n  shows \"inj_on (\\<lambda>b. b +\\<^sub>o\\<^sub>w a) A\"\n    is cancel_semigroup_add_class.inj_on_add'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Commutative semigroups\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale abel_semigroup_ow =\n  semigroup_ow U f for U :: \"'ag set\" and f +\n  assumes commute: \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> a \\<^bold>*\\<^sub>o\\<^sub>w b = b \\<^bold>*\\<^sub>o\\<^sub>w a\"\nbegin"], ["", "lemma fun_left_comm: \n  assumes \"x \\<in> U\" and \"y \\<in> U\" and \"z \\<in> U\" \n  shows \"y \\<^bold>*\\<^sub>o\\<^sub>w (x \\<^bold>*\\<^sub>o\\<^sub>w z) = x \\<^bold>*\\<^sub>o\\<^sub>w (y \\<^bold>*\\<^sub>o\\<^sub>w z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<^bold>*\\<^sub>o\\<^sub>w (x \\<^bold>*\\<^sub>o\\<^sub>w z) =\n    x \\<^bold>*\\<^sub>o\\<^sub>w (y \\<^bold>*\\<^sub>o\\<^sub>w z)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> U\n  y \\<in> U\n  z \\<in> U\n\ngoal (1 subgoal):\n 1. y \\<^bold>*\\<^sub>o\\<^sub>w (x \\<^bold>*\\<^sub>o\\<^sub>w z) =\n    x \\<^bold>*\\<^sub>o\\<^sub>w (y \\<^bold>*\\<^sub>o\\<^sub>w z)", "by (metis assoc commute)"], ["", "end"], ["", "lemma abel_semigroup_ow: \"abel_semigroup = abel_semigroup_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abel_semigroup = abel_semigroup_ow UNIV", "unfolding \n    abel_semigroup_def abel_semigroup_ow_def\n    abel_semigroup_axioms_def abel_semigroup_ow_axioms_def\n    semigroup_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. semigroup_ow UNIV f \\<and> (\\<forall>a b. f a b = f b a)) =\n    (\\<lambda>f.\n        semigroup_ow UNIV f \\<and>\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> f a b = f b a))", "by simp"], ["", "locale ab_semigroup_add_ow =\n  semigroup_add_ow U plus for U :: \"'ag set\" and plus +\n  assumes add_commute: \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b = b +\\<^sub>o\\<^sub>w a\"\nbegin"], ["", "sublocale add: abel_semigroup_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. abel_semigroup_ow U (+\\<^sub>o\\<^sub>w)", "by unfold_locales (rule add_commute)"], ["", "end"], ["", "lemma ab_semigroup_add_ow: \"class.ab_semigroup_add = ab_semigroup_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ab_semigroup_add = ab_semigroup_add_ow UNIV", "unfolding \n    class.ab_semigroup_add_def ab_semigroup_add_ow_def\n    class.ab_semigroup_add_axioms_def ab_semigroup_add_ow_axioms_def\n    semigroup_add_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus.\n        semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a b. plus a b = plus b a)) =\n    (\\<lambda>plus.\n        semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> plus a b = plus b a))", "by simp"], ["", "locale ab_semigroup_mult_ow = \n  semigroup_mult_ow U times for U :: \"'ag set\" and times+\n  assumes mult_commute: \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w b = b *\\<^sub>o\\<^sub>w a\"\nbegin"], ["", "sublocale mult: abel_semigroup_ow U \\<open>(*\\<^sub>o\\<^sub>w)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. abel_semigroup_ow U (*\\<^sub>o\\<^sub>w)", "by unfold_locales (rule mult_commute)"], ["", "end"], ["", "lemma ab_semigroup_mult_ow: \n  \"class.ab_semigroup_mult = ab_semigroup_mult_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ab_semigroup_mult = ab_semigroup_mult_ow UNIV", "unfolding \n    class.ab_semigroup_mult_def ab_semigroup_mult_ow_def\n    class.ab_semigroup_mult_axioms_def ab_semigroup_mult_ow_axioms_def\n    semigroup_mult_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times.\n        semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a b. times a b = times b a)) =\n    (\\<lambda>times.\n        semigroup_mult_ow UNIV times \\<and>\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> times a b = times b a))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma abel_semigroup_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (abel_semigroup_ow (Collect (Domainp A))) abel_semigroup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (abel_semigroup_ow (Collect (Domainp A)))\n     abel_semigroup", "unfolding \n    abel_semigroup_ow_def abel_semigroup_def\n    abel_semigroup_ow_axioms_def abel_semigroup_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>f.\n         semigroup_ow (Collect (Domainp A)) f \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow> f a b = f b a))\n     (\\<lambda>f. semigroup f \\<and> (\\<forall>a b. f a b = f b a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Ri14) ?ad14 (=)\n 2. Transfer.Rel ((A ===> ?Ri14) ===> ?Rh14) ?ac14 All\n 3. Transfer.Rel ((A ===> ?Rh14) ===> ?Rf14) ?ab14 All\n 4. Transfer.Rel ((A ===> A ===> A) ===> ?Re14) ?aa14 semigroup\n 5. Transfer.Rel (?Re14 ===> ?Rf14 ===> (=)) ?a14 (\\<and>)\n 6. (\\<lambda>f.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow> f a b = f b a)) =\n    (\\<lambda>f.\n        ?a14 (?aa14 f)\n         (?ab14 (\\<lambda>a. ?ac14 (\\<lambda>b. ?ad14 (f a b) (f b a)))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow> f a b = f b a)) =\n    (\\<lambda>f.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A). f a b = f b a))", "unfolding Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow> f a b = f b a)) =\n    (\\<lambda>f.\n        semigroup_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow>\n            (\\<forall>xa.\n                xa \\<in> Collect (Domainp A) \\<longrightarrow>\n                f x xa = f xa x)))", "by simp"], ["", "lemma ab_semigroup_add_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (ab_semigroup_add_ow (Collect (Domainp A))) class.ab_semigroup_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=)) (ab_semigroup_add_ow (Collect (Domainp A)))\n     class.ab_semigroup_add", "unfolding \n    ab_semigroup_add_ow_def class.ab_semigroup_add_def\n    ab_semigroup_add_ow_axioms_def class.ab_semigroup_add_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>plus.\n         semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             plus a b = plus b a))\n     (\\<lambda>plus.\n         class.semigroup_add plus \\<and>\n         (\\<forall>a b. plus a b = plus b a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Ri14) ?ad14 (=)\n 2. Transfer.Rel ((A ===> ?Ri14) ===> ?Rh14) ?ac14 All\n 3. Transfer.Rel ((A ===> ?Rh14) ===> ?Rf14) ?ab14 All\n 4. Transfer.Rel ((A ===> A ===> A) ===> ?Re14) ?aa14 class.semigroup_add\n 5. Transfer.Rel (?Re14 ===> ?Rf14 ===> (=)) ?a14 (\\<and>)\n 6. (\\<lambda>plus.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus a b = plus b a)) =\n    (\\<lambda>plus.\n        ?a14 (?aa14 plus)\n         (?ab14\n           (\\<lambda>a. ?ac14 (\\<lambda>b. ?ad14 (plus a b) (plus b a)))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            plus a b = plus b a)) =\n    (\\<lambda>plus.\n        semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A). plus a b = plus b a))", "by simp"], ["", "lemma ab_semigroup_mult_transfer[transfer_rule]:\n  assumes[transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (=)) \n      (ab_semigroup_mult_ow (Collect (Domainp A))) class.ab_semigroup_mult\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (ab_semigroup_mult_ow (Collect (Domainp A))) class.ab_semigroup_mult", "unfolding ab_semigroup_mult_ow_def class.ab_semigroup_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>times.\n         semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n         ab_semigroup_mult_ow_axioms (Collect (Domainp A)) times)\n     (\\<lambda>times.\n         class.semigroup_mult times \\<and>\n         class.ab_semigroup_mult_axioms times)", "unfolding ab_semigroup_mult_ow_axioms_def class.ab_semigroup_mult_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (=))\n     (\\<lambda>times.\n         semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             times a b = times b a))\n     (\\<lambda>times.\n         class.semigroup_mult times \\<and>\n         (\\<forall>a b. times a b = times b a))", "apply transfer_prover_start"], ["proof (prove)\ngoal (6 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Ri14) ?ad14 (=)\n 2. Transfer.Rel ((A ===> ?Ri14) ===> ?Rh14) ?ac14 All\n 3. Transfer.Rel ((A ===> ?Rh14) ===> ?Rf14) ?ab14 All\n 4. Transfer.Rel ((A ===> A ===> A) ===> ?Re14) ?aa14 class.semigroup_mult\n 5. Transfer.Rel (?Re14 ===> ?Rf14 ===> (=)) ?a14 (\\<and>)\n 6. (\\<lambda>times.\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            times a b = times b a)) =\n    (\\<lambda>times.\n        ?a14 (?aa14 times)\n         (?ab14\n           (\\<lambda>a. ?ac14 (\\<lambda>b. ?ad14 (times a b) (times b a)))))", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>times.\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            times a b = times b a)) =\n    (\\<lambda>times.\n        semigroup_mult_ow (Collect (Domainp A)) times \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A). times a b = times b a))", "by simp"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context abel_semigroup_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting abel_semigroup_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma left_commute:\n  assumes \"b \\<in> U\" and \"a \\<in> U\" and \"c \\<in> U\"\n  shows \"b \\<^bold>*\\<^sub>o\\<^sub>w (a \\<^bold>*\\<^sub>o\\<^sub>w c) = a \\<^bold>*\\<^sub>o\\<^sub>w (b \\<^bold>*\\<^sub>o\\<^sub>w c)\"\n    is abel_semigroup.left_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "context ab_semigroup_add_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting ab_semigroup_add_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma add_ac:\n  shows \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b +\\<^sub>o\\<^sub>w c = a +\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c)\"\n    is ab_semigroup_add_class.add_ac(1)\n    and \"\\<lbrakk>a \\<in> U; b \\<in> U\\<rbrakk> \\<Longrightarrow> a +\\<^sub>o\\<^sub>w b = b +\\<^sub>o\\<^sub>w a\"\n    is ab_semigroup_add_class.add_ac(2)\n    and \"\\<lbrakk>b \\<in> U; a \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> b +\\<^sub>o\\<^sub>w (a +\\<^sub>o\\<^sub>w c) = a +\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c)\"\n    is ab_semigroup_add_class.add_ac(3)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "context ab_semigroup_mult_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting ab_semigroup_mult_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma mult_ac:\n  shows \"\\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w b *\\<^sub>o\\<^sub>w c = a *\\<^sub>o\\<^sub>w (b *\\<^sub>o\\<^sub>w c)\"\n    is ab_semigroup_mult_class.mult_ac(1)\n    and \"\\<lbrakk>a \\<in> U; b \\<in> U\\<rbrakk> \\<Longrightarrow> a *\\<^sub>o\\<^sub>w b = b *\\<^sub>o\\<^sub>w a\"\n    is ab_semigroup_mult_class.mult_ac(2)\n    and \"\\<lbrakk>b \\<in> U; a \\<in> U; c \\<in> U\\<rbrakk> \\<Longrightarrow> b *\\<^sub>o\\<^sub>w (a *\\<^sub>o\\<^sub>w c) = a *\\<^sub>o\\<^sub>w (b *\\<^sub>o\\<^sub>w c)\"\n    is ab_semigroup_mult_class.mult_ac(3)"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Cancellative commutative semigroups\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale minus_ow =\n  fixes U :: \"'ag set\" and minus :: \"['ag, 'ag] \\<Rightarrow> 'ag\" (infixl \\<open>-\\<^sub>o\\<^sub>w\\<close> 65)\n  assumes minus_closed[simp,intro]: \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> a -\\<^sub>o\\<^sub>w b \\<in> U\"\nbegin"], ["", "notation minus (infixl \\<open>-\\<^sub>o\\<^sub>w\\<close> 65)"], ["", "lemma minus_closed'[simp]: \"\\<forall>x\\<in>U. \\<forall>y\\<in>U. x -\\<^sub>o\\<^sub>w y \\<in> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U. \\<forall>y\\<in>U. x -\\<^sub>o\\<^sub>w y \\<in> U", "by simp"], ["", "tts_register_sbts \\<open>(-\\<^sub>o\\<^sub>w)\\<close> | U"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp AGA = (\\<lambda>x. x \\<in> U); bi_unique AGA;\n     right_total AGA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun AGA (rel_fun AGA AGA) (-\\<^sub>o\\<^sub>w)\n                          rcdt", "by (rule tts_AA_A_transfer[OF minus_closed])"], ["", "end"], ["", "locale cancel_ab_semigroup_add_ow = \n  ab_semigroup_add_ow U plus + minus_ow U minus\n  for U :: \"'ag set\" and plus minus +\n  assumes add_diff_cancel_left'[simp]: \n    \"\\<lbrakk> a \\<in> U; b \\<in> U \\<rbrakk> \\<Longrightarrow> (a +\\<^sub>o\\<^sub>w b) -\\<^sub>o\\<^sub>w a = b\"\n  assumes diff_diff_add: \n    \"\\<lbrakk> a \\<in> U; b \\<in> U; c \\<in> U \\<rbrakk> \\<Longrightarrow> a -\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w c = a -\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c)\"\nbegin"], ["", "sublocale cancel_semigroup_add_ow U \\<open>(+\\<^sub>o\\<^sub>w)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cancel_semigroup_add_ow U (+\\<^sub>o\\<^sub>w)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<in> U; b \\<in> U; c \\<in> U;\n        a +\\<^sub>o\\<^sub>w b = a +\\<^sub>o\\<^sub>w c\\<rbrakk>\n       \\<Longrightarrow> b = c\n 2. \\<And>b a c.\n       \\<lbrakk>b \\<in> U; a \\<in> U; c \\<in> U;\n        b +\\<^sub>o\\<^sub>w a = c +\\<^sub>o\\<^sub>w a\\<rbrakk>\n       \\<Longrightarrow> b = c", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<in> U; b_ \\<in> U; c_ \\<in> U;\n     a_ +\\<^sub>o\\<^sub>w b_ = a_ +\\<^sub>o\\<^sub>w c_\\<rbrakk>\n    \\<Longrightarrow> b_ = c_", "by (metis add_diff_cancel_left')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a c.\n       \\<lbrakk>b \\<in> U; a \\<in> U; c \\<in> U;\n        b +\\<^sub>o\\<^sub>w a = c +\\<^sub>o\\<^sub>w a\\<rbrakk>\n       \\<Longrightarrow> b = c", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b_ \\<in> U; a_ \\<in> U; c_ \\<in> U;\n     b_ +\\<^sub>o\\<^sub>w a_ = c_ +\\<^sub>o\\<^sub>w a_\\<rbrakk>\n    \\<Longrightarrow> b_ = c_", "by (metis add.commute add_diff_cancel_left')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma cancel_ab_semigroup_add_ow: \n  \"class.cancel_ab_semigroup_add = cancel_ab_semigroup_add_ow UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.cancel_ab_semigroup_add = cancel_ab_semigroup_add_ow UNIV", "unfolding \n    class.cancel_ab_semigroup_add_def \n    cancel_ab_semigroup_add_ow_def\n    class.cancel_ab_semigroup_add_axioms_def\n    cancel_ab_semigroup_add_ow_axioms_def\n    minus_ow_def\n    ab_semigroup_add_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a b. minus (plus a b) a = b) \\<and>\n        (\\<forall>a b c. minus (minus a b) c = minus a (plus b c))) =\n    (\\<lambda>plus minus.\n        ab_semigroup_add_ow UNIV plus \\<and>\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> minus a b \\<in> UNIV) \\<and>\n        (\\<forall>a b.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow> minus (plus a b) a = b) \\<and>\n        (\\<forall>a b c.\n            a \\<in> UNIV \\<longrightarrow>\n            b \\<in> UNIV \\<longrightarrow>\n            c \\<in> UNIV \\<longrightarrow>\n            minus (minus a b) c = minus a (plus b c)))", "by simp"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma cancel_ab_semigroup_add_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=)) \n      (cancel_ab_semigroup_add_ow (Collect (Domainp A))) \n      class.cancel_ab_semigroup_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "let ?P = \"((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "let ?cancel_ab_semigroup_add_ow = \n    \"cancel_ab_semigroup_add_ow (Collect (Domainp A))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "let ?rf_UNIV = \n    \"(\\<lambda>f::['b, 'b] \\<Rightarrow> 'b. (\\<forall>x y. x \\<in> UNIV \\<longrightarrow> y \\<in> UNIV \\<longrightarrow> f x y \\<in> UNIV))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "have \n    \"?P \n      ?cancel_ab_semigroup_add_ow \n      (\\<lambda>f fi. ?rf_UNIV fi \\<and> class.cancel_ab_semigroup_add f fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     (\\<lambda>f fi.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> fi x y \\<in> UNIV) \\<and>\n         class.cancel_ab_semigroup_add f fi)", "unfolding \n      class.cancel_ab_semigroup_add_def \n      cancel_ab_semigroup_add_ow_def\n      class.cancel_ab_semigroup_add_axioms_def \n      cancel_ab_semigroup_add_ow_axioms_def\n      minus_ow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (\\<lambda>plus minus.\n         ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             minus a b \\<in> Collect (Domainp A)) \\<and>\n         (\\<forall>a b.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             minus (plus a b) a = b) \\<and>\n         (\\<forall>a b c.\n             a \\<in> Collect (Domainp A) \\<longrightarrow>\n             b \\<in> Collect (Domainp A) \\<longrightarrow>\n             c \\<in> Collect (Domainp A) \\<longrightarrow>\n             minus (minus a b) c = minus a (plus b c)))\n     (\\<lambda>f fi.\n         (\\<forall>x y.\n             x \\<in> UNIV \\<longrightarrow>\n             y \\<in> UNIV \\<longrightarrow> fi x y \\<in> UNIV) \\<and>\n         class.ab_semigroup_add f \\<and>\n         (\\<forall>a b. fi (f a b) a = b) \\<and>\n         (\\<forall>a b c. fi (fi a b) c = fi a (f b c)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (22 subgoals):\n 1. Transfer.Rel (A ===> A ===> ?Rx45) ?at45 (=)\n 2. Transfer.Rel ((A ===> ?Rx45) ===> ?Rw45) ?as45 All\n 3. Transfer.Rel ((A ===> ?Rw45) ===> ?Rv45) ?ar45 All\n 4. Transfer.Rel ((A ===> ?Rv45) ===> ?Rs45) ?aq45 All\n 5. Transfer.Rel (A ===> A ===> ?Ru45) ?ap45 (=)\n 6. Transfer.Rel ((A ===> ?Ru45) ===> ?Rt45) ?ao45 All\n 7. Transfer.Rel ((A ===> ?Rt45) ===> ?Rr45) ?an45 All\n 8. Transfer.Rel (?Rr45 ===> ?Rs45 ===> ?Rq45) ?am45 (\\<and>)\n 9. Transfer.Rel ((A ===> A ===> A) ===> ?Rp45) ?al45 class.ab_semigroup_add\n 10. Transfer.Rel (?Rp45 ===> ?Rq45 ===> ?Re45) ?ak45 (\\<and>)\nA total of 22 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            minus a b \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            minus (plus a b) a = b) \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            minus (minus a b) c = minus a (plus b c))) =\n    (\\<lambda>f fi.\n        (\\<forall>x\\<in>Collect (Domainp A).\n            \\<forall>y\\<in>Collect (Domainp A).\n               x \\<in> Collect (Domainp A) \\<longrightarrow>\n               y \\<in> Collect (Domainp A) \\<longrightarrow>\n               fi x y \\<in> Collect (Domainp A)) \\<and>\n        ab_semigroup_add_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A). fi (f a b) a = b) \\<and>\n        (\\<forall>a\\<in>Collect (Domainp A).\n            \\<forall>b\\<in>Collect (Domainp A).\n               \\<forall>c\\<in>Collect (Domainp A).\n                  fi (fi a b) c = fi a (f b c)))", "unfolding Ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus minus.\n        ab_semigroup_add_ow (Collect (Domainp A)) plus \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            minus a b \\<in> Collect (Domainp A)) \\<and>\n        (\\<forall>a b.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            minus (plus a b) a = b) \\<and>\n        (\\<forall>a b c.\n            a \\<in> Collect (Domainp A) \\<longrightarrow>\n            b \\<in> Collect (Domainp A) \\<longrightarrow>\n            c \\<in> Collect (Domainp A) \\<longrightarrow>\n            minus (minus a b) c = minus a (plus b c))) =\n    (\\<lambda>f fi.\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow>\n            (\\<forall>xa.\n                xa \\<in> Collect (Domainp A) \\<longrightarrow>\n                x \\<in> Collect (Domainp A) \\<longrightarrow>\n                xa \\<in> Collect (Domainp A) \\<longrightarrow>\n                fi x xa \\<in> Collect (Domainp A))) \\<and>\n        ab_semigroup_add_ow (Collect (Domainp A)) f \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow>\n            (\\<forall>xa.\n                xa \\<in> Collect (Domainp A) \\<longrightarrow>\n                fi (f x xa) x = xa)) \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp A) \\<longrightarrow>\n            (\\<forall>xa.\n                xa \\<in> Collect (Domainp A) \\<longrightarrow>\n                (\\<forall>xb.\n                    xb \\<in> Collect (Domainp A) \\<longrightarrow>\n                    fi (fi x xa) xb = fi x (f xa xb)))))", "by auto"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n   (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n   (\\<lambda>f fi.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> fi x y \\<in> UNIV) \\<and>\n       class.cancel_ab_semigroup_add f fi)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n   (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n   (\\<lambda>f fi.\n       (\\<forall>x y.\n           x \\<in> UNIV \\<longrightarrow>\n           y \\<in> UNIV \\<longrightarrow> fi x y \\<in> UNIV) \\<and>\n       class.cancel_ab_semigroup_add f fi)\n\ngoal (1 subgoal):\n 1. ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n     (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n     class.cancel_ab_semigroup_add", "by simp"], ["proof (state)\nthis:\n  ((A ===> A ===> A) ===> (A ===> A ===> A) ===> (=))\n   (cancel_ab_semigroup_add_ow (Collect (Domainp A)))\n   class.cancel_ab_semigroup_add\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context cancel_ab_semigroup_add_ow\nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  rewriting ctr_simps\n  substituting cancel_ab_semigroup_add_ow_axioms\n  eliminating through simp\nbegin"], ["", "tts_lemma add_diff_cancel_right':\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"a +\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w b = a\"\n    is cancel_ab_semigroup_add_class.add_diff_cancel_right'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_diff_cancel_right:\n  assumes \"a \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\"\n  shows \"a +\\<^sub>o\\<^sub>w c -\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c) = a -\\<^sub>o\\<^sub>w b\"\n    is cancel_ab_semigroup_add_class.add_diff_cancel_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma add_diff_cancel_left:\n  assumes \"c \\<in> U\" and \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"c +\\<^sub>o\\<^sub>w a -\\<^sub>o\\<^sub>w (c +\\<^sub>o\\<^sub>w b) = a -\\<^sub>o\\<^sub>w b\"\n    is cancel_ab_semigroup_add_class.add_diff_cancel_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma diff_right_commute:\n  assumes \"a \\<in> U\" and \"c \\<in> U\" and \"b \\<in> U\"\n  shows \"a -\\<^sub>o\\<^sub>w c -\\<^sub>o\\<^sub>w b = a -\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w c\"\n    is cancel_ab_semigroup_add_class.diff_right_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma diff_diff_eq:\n  assumes \"a \\<in> U\" and \"b \\<in> U\" and \"c \\<in> U\"\n  shows \"a -\\<^sub>o\\<^sub>w b -\\<^sub>o\\<^sub>w c = a -\\<^sub>o\\<^sub>w (b +\\<^sub>o\\<^sub>w c)\"\n    is diff_diff_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}