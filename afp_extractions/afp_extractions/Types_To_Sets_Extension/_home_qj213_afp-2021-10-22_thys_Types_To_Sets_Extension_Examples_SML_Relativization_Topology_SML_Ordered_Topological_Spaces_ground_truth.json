{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/SML_Relativization/Topology/SML_Ordered_Topological_Spaces.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma order_topology_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> (=)) ===> \n      (A ===> A ===> (=)) ===> \n      (rel_set A ===> (=)) ===> \n      (=)\n    ) (order_topology_ow (Collect (Domainp A))) class.order_topology\"", "lemma linorder_topology_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> (=)) ===> \n      (A ===> A ===> (=)) ===> \n      (rel_set A ===> (=)) ===> \n      (=)\n    ) \n    (linorder_topology_ow (Collect (Domainp A))) class.linorder_topology\""], "translations": [["", "lemma order_topology_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> (=)) ===> \n      (A ===> A ===> (=)) ===> \n      (rel_set A ===> (=)) ===> \n      (=)\n    ) (order_topology_ow (Collect (Domainp A))) class.order_topology\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===>\n     (A ===> A ===> (=)) ===> (rel_set A ===> (=)) ===> (=))\n     (order_topology_ow (Collect (Domainp A))) class.order_topology", "unfolding order_topology_ow_def class.order_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===>\n     (A ===> A ===> (=)) ===> (rel_set A ===> (=)) ===> (=))\n     (\\<lambda>le ls \\<tau>.\n         order_ow (Collect (Domainp A)) le ls \\<and>\n         order_topology_ow_axioms (Collect (Domainp A)) ls \\<tau>)\n     (\\<lambda>less_eq less open.\n         class.order less_eq less \\<and>\n         class.order_topology_axioms less open)", "unfolding order_topology_ow_axioms_def class.order_topology_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===>\n     (A ===> A ===> (=)) ===> (rel_set A ===> (=)) ===> (=))\n     (\\<lambda>le ls \\<tau>.\n         order_ow (Collect (Domainp A)) le ls \\<and>\n         (\\<forall>s\\<subseteq>Collect (Domainp A).\n             \\<tau> s =\n             (in_topology_generated_by (lessThan_ow (Collect (Domainp A))\n   ls `\n  Collect (Domainp A) \\<union>\n  greaterThan_ow (Collect (Domainp A)) ls `\n  Collect\n   (Domainp\n     A)) on (Collect\n              (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)))\n     (\\<lambda>less_eq less open.\n         class.order less_eq less \\<and>\n         open =\n         generate_topology\n          (range (ord.lessThan less) \\<union> range (ord.greaterThan less)))", "proof(intro rel_funI, standard; elim conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "let ?U = \"Collect (Domainp A)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "fix le :: \"['a, 'a] \\<Rightarrow> bool\" \n    and le' :: \"['b, 'b] \\<Rightarrow> bool\"\n    and ls :: \"['a, 'a] \\<Rightarrow> bool\" \n    and ls' :: \"['b, 'b] \\<Rightarrow> bool\"\n    and \\<tau> :: \"'a set \\<Rightarrow> bool\"\n    and \\<tau>' :: \"'b set \\<Rightarrow> bool\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "assume [transfer_rule]: \"(A ===> A ===> (=)) le le'\" \n    and [transfer_rule]: \"(A ===> A ===> (=)) ls ls'\"\n    and [transfer_rule]: \"(rel_set A ===> (=)) \\<tau> \\<tau>'\"\n    and oow: \"order_ow (Collect (Domainp A)) le ls\"\n    and \\<tau>: \n      \"\\<forall>s\\<subseteq>Collect (Domainp A). \\<tau> s =\n        generate_topology_on\n          (lessThan_ow ?U ls ` ?U \\<union> greaterThan_ow ?U ls ` ?U) ?U s\""], ["proof (state)\nthis:\n  (A ===> A ===> (=)) le le'\n  (A ===> A ===> (=)) ls ls'\n  (rel_set A ===> (=)) \\<tau> \\<tau>'\n  order_ow (Collect (Domainp A)) le ls\n  \\<forall>s\\<subseteq>Collect (Domainp A).\n     \\<tau> s =\n     (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                Collect (Domainp A) \\<union>\n                                greaterThan_ow (Collect (Domainp A)) ls `\n                                Collect\n                                 (Domainp\n                                   A)) on (Collect\n      (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "have [transfer_rule]: \"Domainp A = (\\<lambda>x. x \\<in> Collect (Domainp A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp A = (\\<lambda>x. x \\<in> Collect (Domainp A))", "by auto"], ["proof (state)\nthis:\n  Domainp A = (\\<lambda>x. x \\<in> Collect (Domainp A))\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "interpret oow: order_ow ?U le ls"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_ow (Collect (Domainp A)) le ls", "by (rule oow)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "interpret co: order le' ls'"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order le' ls'", "by transfer (rule oow)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "have ineq_fold:\n    \"lessThan.with ls y \\<equiv> {x. ls x y}\" \n    \"greaterThan.with ls y \\<equiv> {x. ls y x}\"\n    for ls :: \"'c \\<Rightarrow> 'c \\<Rightarrow> bool\" and y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (with ls : {..<y} \\<equiv> {x. ls x y}) &&&\n    with ls : {y<..} \\<equiv> {x. ls y x}", "unfolding lessThan.with_def greaterThan.with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x. ls x y} \\<equiv> {x. ls x y}) &&&\n    Collect (ls y) \\<equiv> {x. ls y x}", "by auto"], ["proof (state)\nthis:\n  with ?ls2 : {..<?y2} \\<equiv> {x. ?ls2 x ?y2}\n  with ?ls2 : {?y2<..} \\<equiv> {x. ?ls2 ?y2 x}\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "have \n    \"\\<tau>' = generate_topology (\n      range (ord.lessThan ls') \\<union> range (ord.greaterThan ls')\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>' =\n    generate_topology (range co.lessThan \\<union> range co.greaterThan)", "unfolding co.lessThan_def co.greaterThan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>' =\n    generate_topology\n     (range (\\<lambda>u. {x. ls' x u}) \\<union>\n      range (\\<lambda>l. {x. ls' l x}))", "unfolding ineq_fold[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>' =\n    generate_topology\n     (range (lessThan.with ls') \\<union> range (greaterThan.with ls'))", "by (transfer, intro allI impI) (auto simp: \\<tau>)"], ["proof (state)\nthis:\n  \\<tau>' =\n  generate_topology (range co.lessThan \\<union> range co.greaterThan)\n\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; order_ow (Collect (Domainp A)) x xa;\n        \\<forall>s\\<subseteq>Collect (Domainp A).\n           xb s =\n           (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) xa `\nCollect (Domainp A) \\<union>\ngreaterThan_ow (Collect (Domainp A)) xa `\nCollect\n (Domainp\n   A)) on (Collect\n            (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\\<rbrakk>\n       \\<Longrightarrow> class.order y ya \\<and>\n                         yb =\n                         generate_topology\n                          (range (ord.lessThan ya) \\<union>\n                           range (ord.greaterThan ya))\n 2. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "from co.order_axioms this"], ["proof (chain)\npicking this:\n  class.order le' ls'\n  \\<tau>' =\n  generate_topology (range co.lessThan \\<union> range co.greaterThan)", "show\n    \"class.order le' ls' \\<and> \n      \\<tau>' = generate_topology (\n        range (ord.lessThan ls') \\<union> range (ord.greaterThan ls')\n      )\""], ["proof (prove)\nusing this:\n  class.order le' ls'\n  \\<tau>' =\n  generate_topology (range co.lessThan \\<union> range co.greaterThan)\n\ngoal (1 subgoal):\n 1. class.order le' ls' \\<and>\n    \\<tau>' =\n    generate_topology (range co.lessThan \\<union> range co.greaterThan)", "by simp"], ["proof (state)\nthis:\n  class.order le' ls' \\<and>\n  \\<tau>' =\n  generate_topology (range co.lessThan \\<union> range co.greaterThan)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "let ?U = \"Collect (Domainp A)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "fix le :: \"['a, 'a] \\<Rightarrow> bool\" \n    and le' :: \"['b, 'b] \\<Rightarrow> bool\"\n    and ls :: \"['a, 'a] \\<Rightarrow> bool\" \n    and ls' :: \"['b, 'b] \\<Rightarrow> bool\"\n    and \\<tau> :: \"'a set \\<Rightarrow> bool\"\n    and \\<tau>' :: \"'b set \\<Rightarrow> bool\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "assume [transfer_rule]: \"(A ===> A ===> (=)) le le'\" \n    and [transfer_rule]: \"(A ===> A ===> (=)) ls ls'\"\n    and [transfer_rule]: \"(rel_set A ===> (=)) \\<tau> \\<tau>'\"\n    and co: \"class.order le' ls'\"\n    and \\<tau>': \"\\<tau>' = generate_topology\n      (range (ord.lessThan ls') \\<union> range (ord.greaterThan ls'))\""], ["proof (state)\nthis:\n  (A ===> A ===> (=)) le le'\n  (A ===> A ===> (=)) ls ls'\n  (rel_set A ===> (=)) \\<tau> \\<tau>'\n  class.order le' ls'\n  \\<tau>' =\n  generate_topology\n   (range (ord.lessThan ls') \\<union> range (ord.greaterThan ls'))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "have [transfer_rule]: \"Domainp A = (\\<lambda>x. x \\<in> Collect (Domainp A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp A = (\\<lambda>x. x \\<in> Collect (Domainp A))", "by auto"], ["proof (state)\nthis:\n  Domainp A = (\\<lambda>x. x \\<in> Collect (Domainp A))\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "interpret co: order le' ls'"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.order le' ls'", "by (rule co)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "have ineq_fold:\n    \"lessThan.with ls y \\<equiv> {x. ls x y}\" \n    \"greaterThan.with ls y \\<equiv> {x. ls y x}\"\n    for ls :: \"'c \\<Rightarrow> 'c \\<Rightarrow> bool\" and y"], ["proof (prove)\ngoal (1 subgoal):\n 1. (with ls : {..<y} \\<equiv> {x. ls x y}) &&&\n    with ls : {y<..} \\<equiv> {x. ls y x}", "unfolding lessThan.with_def greaterThan.with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({x. ls x y} \\<equiv> {x. ls x y}) &&&\n    Collect (ls y) \\<equiv> {x. ls y x}", "by auto"], ["proof (state)\nthis:\n  with ?ls2 : {..<?y2} \\<equiv> {x. ?ls2 x ?y2}\n  with ?ls2 : {?y2<..} \\<equiv> {x. ?ls2 ?y2 x}\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "from co"], ["proof (chain)\npicking this:\n  class.order le' ls'", "have \"order_ow ?U le ls\""], ["proof (prove)\nusing this:\n  class.order le' ls'\n\ngoal (1 subgoal):\n 1. order_ow (Collect (Domainp A)) le ls", "by transfer"], ["proof (state)\nthis:\n  order_ow (Collect (Domainp A)) le ls\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "moreover"], ["proof (state)\nthis:\n  order_ow (Collect (Domainp A)) le ls\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "have \n    \"\\<forall>s\\<subseteq>Collect (Domainp A). \\<tau> s =\n      SML_Topological_Space.generate_topology_on\n        (lessThan_ow ?U ls ` ?U \\<union> greaterThan_ow ?U ls ` ?U) ?U s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<subseteq>Collect (Domainp A).\n       \\<tau> s =\n       (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                  Collect (Domainp A) \\<union>\n                                  greaterThan_ow (Collect (Domainp A)) ls `\n                                  Collect\n                                   (Domainp\n                                     A)) on (Collect\n        (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)", "by \n      (\n        rule \\<tau>'[\n          unfolded co.lessThan_def co.greaterThan_def,\n          folded ineq_fold,\n          untransferred\n          ]\n       )"], ["proof (state)\nthis:\n  \\<forall>s\\<subseteq>Collect (Domainp A).\n     \\<tau> s =\n     (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                Collect (Domainp A) \\<union>\n                                greaterThan_ow (Collect (Domainp A)) ls `\n                                Collect\n                                 (Domainp\n                                   A)) on (Collect\n      (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(A ===> A ===> (=)) x y; (A ===> A ===> (=)) xa ya;\n        (rel_set A ===> (=)) xb yb; class.order y ya;\n        yb =\n        generate_topology\n         (range (ord.lessThan ya) \\<union>\n          range (ord.greaterThan ya))\\<rbrakk>\n       \\<Longrightarrow> order_ow (Collect (Domainp A)) x xa \\<and>\n                         (\\<forall>s\\<subseteq>Collect (Domainp A).\n                             xb s =\n                             (in_topology_generated_by (lessThan_ow\n                   (Collect (Domainp A)) xa `\n                  Collect (Domainp A) \\<union>\n                  greaterThan_ow (Collect (Domainp A)) xa `\n                  Collect\n                   (Domainp\n                     A)) on (Collect\n                              (Domainp\n                                A)) : \\<guillemotleft>open\\<guillemotright> s))", "ultimately"], ["proof (chain)\npicking this:\n  order_ow (Collect (Domainp A)) le ls\n  \\<forall>s\\<subseteq>Collect (Domainp A).\n     \\<tau> s =\n     (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                Collect (Domainp A) \\<union>\n                                greaterThan_ow (Collect (Domainp A)) ls `\n                                Collect\n                                 (Domainp\n                                   A)) on (Collect\n      (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)", "show \n    \"order_ow ?U le ls \\<and>\n      (\n        \\<forall>s\\<subseteq>Collect (Domainp A). \\<tau> s = \n          SML_Topological_Space.generate_topology_on\n            (lessThan_ow ?U ls ` ?U \\<union> greaterThan_ow ?U ls ` ?U) ?U s\n      )\""], ["proof (prove)\nusing this:\n  order_ow (Collect (Domainp A)) le ls\n  \\<forall>s\\<subseteq>Collect (Domainp A).\n     \\<tau> s =\n     (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                Collect (Domainp A) \\<union>\n                                greaterThan_ow (Collect (Domainp A)) ls `\n                                Collect\n                                 (Domainp\n                                   A)) on (Collect\n      (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s)\n\ngoal (1 subgoal):\n 1. order_ow (Collect (Domainp A)) le ls \\<and>\n    (\\<forall>s\\<subseteq>Collect (Domainp A).\n        \\<tau> s =\n        (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                   Collect (Domainp A) \\<union>\n                                   greaterThan_ow (Collect (Domainp A)) ls `\n                                   Collect\n                                    (Domainp\nA)) on (Collect (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s))", "by simp"], ["proof (state)\nthis:\n  order_ow (Collect (Domainp A)) le ls \\<and>\n  (\\<forall>s\\<subseteq>Collect (Domainp A).\n      \\<tau> s =\n      (in_topology_generated_by (lessThan_ow (Collect (Domainp A)) ls `\n                                 Collect (Domainp A) \\<union>\n                                 greaterThan_ow (Collect (Domainp A)) ls `\n                                 Collect\n                                  (Domainp\n                                    A)) on (Collect\n       (Domainp A)) : \\<guillemotleft>open\\<guillemotright> s))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context order_topology_ow \nbegin"], ["", "tts_context\n  tts: (?'a to U)\n  substituting order_topology_ow_axioms\n  eliminating \\<open>?U \\<noteq> {}\\<close> through simp\nbegin"], ["", "tts_lemma open_greaterThan:\n  assumes \"a \\<in> U\"\n  shows \"\\<tau> {a<\\<^sub>o\\<^sub>w..}\"\n    is order_topology_class.open_greaterThan"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma open_lessThan:\n  assumes \"a \\<in> U\"\n  shows \"\\<tau> {..<\\<^sub>o\\<^sub>wa}\"\n  is order_topology_class.open_lessThan"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma open_greaterThanLessThan:\n  assumes \"a \\<in> U\" and \"b \\<in> U\"\n  shows \"\\<tau> {a<\\<^sub>o\\<^sub>w..<\\<^sub>o\\<^sub>wb}\"\n    is order_topology_class.open_greaterThanLessThan"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "subsection\\<open>Linearly ordered topological space\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale linorder_topology_ow = \n  linorder_ow U le ls + order_topology_ow U le ls \\<tau> \n  for U :: \"'at set\" and le ls \\<tau>"], ["", "locale ts_lt_ow = \n  ts: topological_space_ow U\\<^sub>1 \\<tau>\\<^sub>1 + lt: linorder_topology_ow U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2\n  for U\\<^sub>1 :: \"'at set\" and \\<tau>\\<^sub>1 and U\\<^sub>2 :: \"'bt set\" and le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2\nbegin"], ["", "sublocale ts_ot_ow U\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_ot_ow U\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2\n     \\<tau>\\<^sub>2", ".."], ["", "end"], ["", "locale ot_lt_ow = \n  ot: order_topology_ow U\\<^sub>1 le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 + lt: linorder_topology_ow U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2\n  for U\\<^sub>1 :: \"'at set\" and le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 and U\\<^sub>2 :: \"'bt set\" and le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2\nbegin"], ["", "sublocale ts_lt_ow U\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ts_lt_ow U\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2\n     \\<tau>\\<^sub>2", ".."], ["", "sublocale order_topology_pair_ow U\\<^sub>1 le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_topology_pair_ow U\\<^sub>1 le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1\n     U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2", ".."], ["", "end"], ["", "locale linorder_topology_pair_ow = \n  lt\\<^sub>1: linorder_topology_ow U\\<^sub>1 le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 + lt\\<^sub>2: linorder_topology_ow U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2\n  for U\\<^sub>1 :: \"'at set\" and le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 and U\\<^sub>2 :: \"'bt set\" and le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2\nbegin"], ["", "sublocale ot_lt_ow U\\<^sub>1 le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2 le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. ot_lt_ow U\\<^sub>1 le\\<^sub>1 ls\\<^sub>1 \\<tau>\\<^sub>1 U\\<^sub>2\n     le\\<^sub>2 ls\\<^sub>2 \\<tau>\\<^sub>2", ".."], ["", "end"], ["", "subsubsection\\<open>Transfer rules\\<close>"], ["", "context\n  includes lifting_syntax\nbegin"], ["", "lemma linorder_topology_transfer[transfer_rule]:\n  assumes [transfer_rule]: \"bi_unique A\" \"right_total A\" \n  shows \n    \"(\n      (A ===> A ===> (=)) ===> \n      (A ===> A ===> (=)) ===> \n      (rel_set A ===> (=)) ===> \n      (=)\n    ) \n    (linorder_topology_ow (Collect (Domainp A))) class.linorder_topology\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===>\n     (A ===> A ===> (=)) ===> (rel_set A ===> (=)) ===> (=))\n     (linorder_topology_ow (Collect (Domainp A))) class.linorder_topology", "unfolding linorder_topology_ow_def class.linorder_topology_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> A ===> (=)) ===>\n     (A ===> A ===> (=)) ===> (rel_set A ===> (=)) ===> (=))\n     (\\<lambda>le ls \\<tau>.\n         linorder_ow (Collect (Domainp A)) le ls \\<and>\n         order_topology_ow (Collect (Domainp A)) le ls \\<tau>)\n     (\\<lambda>less_eq less open.\n         class.linorder less_eq less \\<and>\n         class.order_topology less_eq less open)", "by transfer_prover"], ["", "end"], ["", "subsubsection\\<open>Relativization\\<close>"], ["", "context linorder_topology_ow \nbegin"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting linorder_topology_ow_axioms\n  eliminating \\<open>?U \\<noteq> {}\\<close> through clarsimp\nbegin"], ["", "tts_lemma open_right:\n  assumes \"S \\<subseteq> U\"\n    and \"x \\<in> U\"\n    and \"y \\<in> U\"\n    and \"\\<tau> S\"\n    and \"x \\<in> S\"\n    and \"x <\\<^sub>o\\<^sub>w y\"\n  shows \"\\<exists>z\\<in>U. x <\\<^sub>o\\<^sub>w z \\<and> (on U with (\\<le>\\<^sub>o\\<^sub>w) (<\\<^sub>o\\<^sub>w) : {x..<z}) \\<subseteq> S\"\n    is linorder_topology_class.open_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma open_left:\n  assumes \"S \\<subseteq> U\"\n    and \"x \\<in> U\"\n    and \"y \\<in> U\"\n    and \"\\<tau> S\"\n    and \"x \\<in> S\"\n    and \"y <\\<^sub>o\\<^sub>w x\"\n  shows \"\\<exists>z\\<in>U. z <\\<^sub>o\\<^sub>w x \\<and> {z<\\<^sub>o\\<^sub>w..x} \\<subseteq> S\"\n    is linorder_topology_class.open_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma connectedD_interval:\n  assumes \"U \\<subseteq> U\"\n    and \"x \\<in> U\"\n    and \"y \\<in> U\"\n    and \"z \\<in> U\"\n    and \"connected U\"\n    and \"x \\<in> U\"\n    and \"y \\<in> U\"\n    and \"x \\<le>\\<^sub>o\\<^sub>w z\"\n    and \"z \\<le>\\<^sub>o\\<^sub>w y\"\n  shows \"z \\<in> U\"\n    is linorder_topology_class.connectedD_interval"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma connected_contains_Icc:\n  assumes \"A \\<subseteq> U\"\n    and \"a \\<in> U\"\n    and \"b \\<in> U\"\n    and \"connected A\"\n    and \"a \\<in> A\"\n    and \"b \\<in> A\"\n  shows \"{a..\\<^sub>o\\<^sub>wb} \\<subseteq> A\"\n    is Topological_Spaces.connected_contains_Icc"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma connected_contains_Ioo:\n  assumes \"A \\<subseteq> U\"\n    and \"a \\<in> U\"\n    and \"b \\<in> U\"\n    and \"connected A\"\n    and \"a \\<in> A\"\n    and \"b \\<in> A\"\n  shows \"{a<\\<^sub>o\\<^sub>w..<\\<^sub>o\\<^sub>wb} \\<subseteq> A\"\n    is Topological_Spaces.connected_contains_Ioo"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "tts_context\n  tts: (?'a to U) \n  rewriting ctr_simps\n  substituting linorder_topology_ow_axioms\n  eliminating \\<open>?U \\<noteq> {}\\<close> through clarsimp\nbegin"], ["", "tts_lemma not_in_connected_cases:\n  assumes \"S \\<subseteq> U\"\n    and \"x \\<in> U\"\n    and \"connected S\"\n    and \"x \\<notin> S\"\n    and \"S \\<noteq> {}\"\n    and \"\\<lbrakk>bdd_above S; \\<And>y. \\<lbrakk>y \\<in> U; y \\<in> S\\<rbrakk> \\<Longrightarrow> y \\<le>\\<^sub>o\\<^sub>w x\\<rbrakk> \\<Longrightarrow> thesis\"\n    and \"\\<lbrakk>bdd_below S; \\<And>y. \\<lbrakk>y \\<in> U; y \\<in> S\\<rbrakk> \\<Longrightarrow> x \\<le>\\<^sub>o\\<^sub>w y\\<rbrakk> \\<Longrightarrow> thesis\"\n  shows thesis\n    is linorder_topology_class.not_in_connected_cases"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma compact_attains_sup:\n  assumes \"S \\<subseteq> U\"\n    and \"compact S\"\n    and \"S \\<noteq> {}\"\n  shows \"\\<exists>x\\<in>S. \\<forall>y\\<in>S. y \\<le>\\<^sub>o\\<^sub>w x\"\n    is linorder_topology_class.compact_attains_sup"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma compact_attains_inf:\n  assumes \"S \\<subseteq> U\"\n    and \"compact S\"\n    and \"S \\<noteq> {}\"\n  shows \"\\<exists>x\\<in>S. Ball S ((\\<le>\\<^sub>o\\<^sub>w) x)\"\n    is linorder_topology_class.compact_attains_inf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}