{"file_name": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension/Examples/Vector_Spaces/VS_Modules.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Types_To_Sets_Extension", "problem_names": ["lemma module_with_overloaded[ud_with]: \"module = module_with (+) 0 (-) uminus\"", "lemma module_pair_with_overloaded[ud_with]: \n  \"module_pair =\n    (\n      \\<lambda>scale\\<^sub>1 scale\\<^sub>2.\n        module_pair_with (+) 0 (-) uminus scale\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>2\n    )\"", "lemma module_hom_with_overloaded[ud_with]: \n  \"module_hom =\n    (\n      \\<lambda>scale\\<^sub>1 scale\\<^sub>2.\n        module_hom_with (+) 0 (-) uminus scale\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>2\n    )\"", "lemma span_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  shows \n    \"(\n      A ===> \n      (A ===> A ===> A) ===>\n      ((=) ===> A ===> A) ===> \n      rel_set A ===> \n      rel_set A\n    ) span.with span.with\"", "lemma dependent_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  shows \n    \"(\n      (=) ===>\n      A ===> \n      (A ===> A ===> A) ===>\n      ((=) ===> A ===> A) ===> \n      rel_set A ===> \n      (=)\n    ) dependent.with dependent.with\"", "lemma scale_closed'[simp]: \"\\<forall>a. \\<forall>x\\<in>U\\<^sub>M. a *s\\<^sub>M x \\<in> U\\<^sub>M\"", "lemma minus_closed'[simp]: \"\\<forall>x\\<in>U\\<^sub>M. \\<forall>y\\<in>U\\<^sub>M. x -\\<^sub>M y \\<in> U\\<^sub>M\"", "lemma uminus_closed'[simp]: \"\\<forall>x\\<in>U\\<^sub>M. -\\<^sub>M x \\<in> U\\<^sub>M\"", "lemma f_closed'[simp]: \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"", "lemma module_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"bi_unique B\" \"right_total B\"     \n  fixes PP lhs\n  defines\n    \"PP \\<equiv> \n      (\n        (B ===> B ===> B) ===>\n        B ===>\n        (B ===> B ===> B) ===>\n        (B ===> B) ===>\n        ((=) ===> B ===> B) ===>\n        (=)\n      )\"\n    and\n      \"lhs \\<equiv> \n        (\n          \\<lambda> plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n          module_ow (Collect (Domainp B)) plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale\n        )\"\n  shows \"PP lhs (module_with)\"", "lemma module_pair_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \n    \"bi_unique B\\<^sub>1\" \"right_total B\\<^sub>1\" \"bi_unique B\\<^sub>2\" \"right_total B\\<^sub>2\"     \n  fixes PP lhs\n  defines\n    \"PP \\<equiv> \n      (\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        B\\<^sub>1 ===>\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>1 ===> B\\<^sub>1) ===>\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        B\\<^sub>2 ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2) ===>\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (=)\n    )\"\n    and\n      \"lhs \\<equiv> \n        (\n          \\<lambda>\n            plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2.\n          module_pair_ow \n            (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n        )\"\n    shows \"PP lhs module_pair_with\"", "lemma module_hom_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \n    \"bi_unique B\\<^sub>1\" \"right_total B\\<^sub>1\" \"bi_unique B\\<^sub>2\" \"right_total B\\<^sub>2\"     \n  fixes PP lhs\n  defines\n    \"PP \\<equiv> \n      (\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        B\\<^sub>1 ===>\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>1 ===> B\\<^sub>1) ===>\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        B\\<^sub>2 ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2) ===>\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (B\\<^sub>1 ===> B\\<^sub>2) ===>\n        (=)\n      )\"\n    and\n      \"lhs \\<equiv> \n        (\n          \\<lambda>\n            plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n            f.\n          module_hom_ow \n            (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n            f\n        )\"\n    shows \"PP lhs module_hom_with\"", "lemma S_ne: \"U\\<^sub>M \\<noteq> {}\"", "lemma scale_minus_left_on: \n  assumes \"x \\<in> U\\<^sub>M\" \n  shows \"scale (- a) x = - scale a x\"", "lemma closed_uminus: \n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"-x \\<in> U\\<^sub>M\"", "lemma implicit_subspace_with[tts_implicit]: \"subspace.with (+) 0 (*s) = subspace\"", "lemma implicit_dependent_with[tts_implicit]: \n  \"dependent.with 0 0 (+) (*s) = dependent\"", "lemma implicit_span_with[tts_implicit]: \"span.with 0 (+) (*s) = span\"", "lemma implicit_module_ow[tts_implicit]:\n  \"module_ow U\\<^sub>M (+) 0 (-) uminus = module_on U\\<^sub>M\"", "lemma implicit_module_pair_ow[tts_implicit]:\n  \"module_pair_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (+) 0 (-) uminus scale\\<^sub>2 = \n    module_pair_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>1 scale\\<^sub>2\"", "lemma implicit_module_hom_ow[tts_implicit]:\n  \"module_hom_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (+) 0 (-) uminus scale\\<^sub>2 = \n    module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>1 scale\\<^sub>2\""], "translations": [["", "lemma module_with_overloaded[ud_with]: \"module = module_with (+) 0 (-) uminus\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module = module_with (+) (0::'b) (-) uminus", "unfolding module_def module_with_def module_with_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>scale.\n        ((\\<forall>a x y. scale a (x + y) = scale a x + scale a y) \\<and>\n         (\\<forall>a b x. scale (a + b) x = scale a x + scale b x)) \\<and>\n        (\\<forall>a b x. scale a (scale b x) = scale (a * b) x) \\<and>\n        (\\<forall>x. scale (1::'a) x = x)) =\n    (\\<lambda>scale.\n        class.ab_group_add (+) (0::'b) (-) uminus \\<and>\n        ((\\<forall>a x y. scale a (x + y) = scale a x + scale a y) \\<and>\n         (\\<forall>a b x. scale (a + b) x = scale a x + scale b x)) \\<and>\n        (\\<forall>a b x. scale a (scale b x) = scale (a * b) x) \\<and>\n        (\\<forall>x. scale (1::'a) x = x))", "by (simp add: comm_ring_1_axioms ab_group_add_axioms)"], ["", "locale module_pair_with =\n  M\\<^sub>1: module_with plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 +\n  M\\<^sub>2: module_with plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n  for plus\\<^sub>M\\<^sub>_\\<^sub>1 :: \"['m_1, 'm_1] \\<Rightarrow> 'm_1\" (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>1\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>1 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1 _\\<close> [81] 80)\n    and scale\\<^sub>1 (infixr \\<open>*s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>'_\\<^sub>1\\<close> 75)\n    and plus\\<^sub>M\\<^sub>_\\<^sub>2 :: \"['m_2, 'm_2] \\<Rightarrow> 'm_2\" (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>2\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>2 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2 _\\<close> [81] 80)\n    and scale\\<^sub>2 (infixr \\<open>*s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>'_\\<^sub>2\\<close> 75)"], ["", "lemma module_pair_with_overloaded[ud_with]: \n  \"module_pair =\n    (\n      \\<lambda>scale\\<^sub>1 scale\\<^sub>2.\n        module_pair_with (+) 0 (-) uminus scale\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>2\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair =\n    (\\<lambda>scale\\<^sub>1.\n        module_pair_with (+) (0::'b) (-) uminus scale\\<^sub>1 (+) (0::'c)\n         (-) uminus)", "unfolding module_pair_def module_pair_with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s1 s2. module s1 \\<and> module s2) =\n    (\\<lambda>scale\\<^sub>1 scale\\<^sub>2.\n        module_with (+) (0::'b) (-) uminus scale\\<^sub>1 \\<and>\n        module_with (+) (0::'c) (-) uminus scale\\<^sub>2)", "unfolding module_with_overloaded"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s1 s2.\n        module_with (+) (0::'b) (-) uminus s1 \\<and>\n        module_with (+) (0::'c) (-) uminus s2) =\n    (\\<lambda>scale\\<^sub>1 scale\\<^sub>2.\n        module_with (+) (0::'b) (-) uminus scale\\<^sub>1 \\<and>\n        module_with (+) (0::'c) (-) uminus scale\\<^sub>2)", ".."], ["", "locale module_hom_with = \n  M\\<^sub>1: module_with plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 +\n  M\\<^sub>2: module_with plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n  for plus\\<^sub>M\\<^sub>_\\<^sub>1 :: \"['m_1, 'm_1] \\<Rightarrow> 'm_1\" (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>1\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>1 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1 _\\<close> [81] 80)\n    and scale\\<^sub>1 (infixr \\<open>*s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>'_\\<^sub>1\\<close> 75)\n    and plus\\<^sub>M\\<^sub>_\\<^sub>2 :: \"['m_2, 'm_2] \\<Rightarrow> 'm_2\" (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>2\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>2 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2 _\\<close> [81] 80)\n    and scale\\<^sub>2 (infixr \\<open>*s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>'_\\<^sub>2\\<close> 75) +\n  fixes f :: \"'m_1 \\<Rightarrow> 'm_2\"\n  assumes add: \"f (b1 +\\<^sub>M\\<^sub>_\\<^sub>1 b2) = f b1 +\\<^sub>M\\<^sub>_\\<^sub>2 f b2\"\n    and scale: \"f (r *s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>_\\<^sub>1 b) = r *s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>_\\<^sub>2 f b\"\nbegin"], ["", "sublocale module_pair_with"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair_with (+\\<^sub>M\\<^sub>_\\<^sub>1) 0\\<^sub>M\\<^sub>_\\<^sub>1\n     (-\\<^sub>M\\<^sub>_\\<^sub>1) uminus\\<^sub>M\\<^sub>_\\<^sub>1\n     (*s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>_\\<^sub>1)\n     (+\\<^sub>M\\<^sub>_\\<^sub>2) 0\\<^sub>M\\<^sub>_\\<^sub>2\n     (-\\<^sub>M\\<^sub>_\\<^sub>2) uminus\\<^sub>M\\<^sub>_\\<^sub>2\n     (*s\\<^sub>w\\<^sub>i\\<^sub>t\\<^sub>h\\<^sub>_\\<^sub>2)", ".."], ["", "end"], ["", "lemma module_hom_with_overloaded[ud_with]: \n  \"module_hom =\n    (\n      \\<lambda>scale\\<^sub>1 scale\\<^sub>2.\n        module_hom_with (+) 0 (-) uminus scale\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>2\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_hom =\n    (\\<lambda>scale\\<^sub>1.\n        module_hom_with (+) (0::'b) (-) uminus scale\\<^sub>1 (+) (0::'c) (-)\n         uminus)", "unfolding \n    module_hom_def module_hom_axioms_def \n    module_hom_with_def module_hom_with_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s1 s2 f.\n        module s1 \\<and>\n        module s2 \\<and>\n        (\\<forall>b1 b2. f (b1 + b2) = f b1 + f b2) \\<and>\n        (\\<forall>r b. f (s1 r b) = s2 r (f b))) =\n    (\\<lambda>scale\\<^sub>1 scale\\<^sub>2 f.\n        module_with (+) (0::'b) (-) uminus scale\\<^sub>1 \\<and>\n        module_with (+) (0::'c) (-) uminus scale\\<^sub>2 \\<and>\n        (\\<forall>b1 b2. f (b1 + b2) = f b1 + f b2) \\<and>\n        (\\<forall>r b. f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b)))", "unfolding module_with_overloaded"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s1 s2 f.\n        module_with (+) (0::'b) (-) uminus s1 \\<and>\n        module_with (+) (0::'c) (-) uminus s2 \\<and>\n        (\\<forall>b1 b2. f (b1 + b2) = f b1 + f b2) \\<and>\n        (\\<forall>r b. f (s1 r b) = s2 r (f b))) =\n    (\\<lambda>scale\\<^sub>1 scale\\<^sub>2 f.\n        module_with (+) (0::'b) (-) uminus scale\\<^sub>1 \\<and>\n        module_with (+) (0::'c) (-) uminus scale\\<^sub>2 \\<and>\n        (\\<forall>b1 b2. f (b1 + b2) = f b1 + f b2) \\<and>\n        (\\<forall>r b. f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b)))", ".."], ["", "ud \\<open>module.subspace\\<close> (\\<open>(with _ _ _ : \\<guillemotleft>subspace\\<guillemotright> _)\\<close> [1000, 999, 998, 1000] 10)"], ["", "ud \\<open>module.span\\<close> (\\<open>(with _ _ _ : \\<guillemotleft>span\\<guillemotright> _)\\<close> [1000, 999, 998, 1000] 10)"], ["", "ud \\<open>module.dependent\\<close> \n  (\\<open>(with _ _ _ _ : \\<guillemotleft>dependent\\<guillemotright> _)\\<close> [1000, 999, 998, 997, 1000] 10)"], ["", "ud \\<open>module.representation\\<close> \n  (\n    \\<open>(with _ _ _ _ : \\<guillemotleft>representation\\<guillemotright> _ _)\\<close> \n    [1000, 999, 998, 997, 1000, 999] 10\n  )"], ["", "abbreviation independent_with \n  (\\<open>(with _ _ _ _ : \\<guillemotleft>independent\\<guillemotright> _)\\<close> [1000, 999, 998, 997, 1000] 10)\n  where \n    \"(with zero\\<^sub>C\\<^sub>R\\<^sub>1 zero\\<^sub>M  scale\\<^sub>M plus\\<^sub>M : \\<guillemotleft>independent\\<guillemotright> s) \\<equiv>\n      \\<not>(with zero\\<^sub>C\\<^sub>R\\<^sub>1 zero\\<^sub>M scale\\<^sub>M plus\\<^sub>M : \\<guillemotleft>dependent\\<guillemotright> s)\""], ["", "lemma span_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  shows \n    \"(\n      A ===> \n      (A ===> A ===> A) ===>\n      ((=) ===> A ===> A) ===> \n      rel_set A ===> \n      rel_set A\n    ) span.with span.with\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===>\n     (A ===> A ===> A) ===>\n     ((=) ===> A ===> A) ===> rel_set A ===> rel_set A)\n     span.with span.with", "unfolding span.with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===>\n     (A ===> A ===> A) ===>\n     ((=) ===> A ===> A) ===> rel_set A ===> rel_set A)\n     (\\<lambda>zero plus scale b.\n         {sum_with plus zero (\\<lambda>a. scale (r a) a) t |t r.\n          finite t \\<and> t \\<subseteq> b})\n     (\\<lambda>zero plus scale b.\n         {sum_with plus zero (\\<lambda>a. scale (r a) a) t |t r.\n          finite t \\<and> t \\<subseteq> b})", "proof(intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "fix p p' z z' X X' and s s'::\"'c \\<Rightarrow> _\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "assume transfer_rules[transfer_rule]:   \n    \"(A ===> A ===> A) p p'\" \n    \"A z z'\" \n    \"((=) ===> A ===> A) s s'\" \n    \"rel_set A X X'\""], ["proof (state)\nthis:\n  (A ===> A ===> A) p p'\n  A z z'\n  ((=) ===> A ===> A) s s'\n  rel_set A X X'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "have \"Domainp A z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp A z", "using \\<open>A z z'\\<close>"], ["proof (prove)\nusing this:\n  A z z'\n\ngoal (1 subgoal):\n 1. Domainp A z", "by force"], ["proof (state)\nthis:\n  Domainp A z\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "have *: \"t \\<subseteq> X \\<Longrightarrow> (\\<forall>x\\<in>t. Domainp A x)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<subseteq> X \\<Longrightarrow> \\<forall>x\\<in>t. Domainp A x", "by (meson Domainp.DomainI \\<open>rel_set A X X'\\<close> rel_setD1 subsetD)"], ["proof (state)\nthis:\n  ?t \\<subseteq> X \\<Longrightarrow> \\<forall>x\\<in>?t. Domainp A x\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "note swt = sum_with_transfer\n    [\n      OF assms(1,2,2), \n      THEN rel_funD, \n      THEN rel_funD, \n      THEN rel_funD,  \n      THEN rel_funD,  \n      OF transfer_rules(1,2)\n    ]"], ["proof (state)\nthis:\n  \\<lbrakk>(A ===> A) ?x1 ?y1; rel_set A ?x ?y\\<rbrakk>\n  \\<Longrightarrow> A (sum_with p z ?x1 ?x) (sum_with p' z' ?y1 ?y)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "have DsI: \"Domainp A (sum_with p z r t)\" \n    if \"\\<And>x. x \\<in> t \\<Longrightarrow> Domainp A (r x)\" \"t \\<subseteq> Collect (Domainp A)\" for r t"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domainp A (sum_with p z r t)", "by (metis that Domainp_sum_with transfer_rules(1,2))"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>x. x \\<in> ?t \\<Longrightarrow> Domainp A (?r x);\n   ?t \\<subseteq> Collect (Domainp A)\\<rbrakk>\n  \\<Longrightarrow> Domainp A (sum_with p z ?r ?t)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "from Domainp_apply2I[OF transfer_rules(3)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x = ?y; A ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> Domainp A (s ?x ?x')", "have Domainp_sI: \"Domainp A x \\<Longrightarrow> Domainp A (s y x)\" for x y"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x = ?y; A ?x' ?y'\\<rbrakk>\n  \\<Longrightarrow> Domainp A (s ?x ?x')\n\ngoal (1 subgoal):\n 1. Domainp A x \\<Longrightarrow> Domainp A (s y x)", "by auto"], ["proof (state)\nthis:\n  Domainp A ?x \\<Longrightarrow> Domainp A (s ?y ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc.\n       \\<lbrakk>A x y; (A ===> A ===> A) xa ya; ((=) ===> A ===> A) xb yb;\n        rel_set A xc yc\\<rbrakk>\n       \\<Longrightarrow> rel_set A\n                          {sum_with xa x (\\<lambda>a. xb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> xc}\n                          {sum_with ya y (\\<lambda>a. yb (r a) a) t |t r.\n                           finite t \\<and> t \\<subseteq> yc}", "show \"rel_set A\n    {sum_with p z (\\<lambda>a. s (r a) a) t |t r. finite t \\<and> t \\<subseteq> X}\n        {sum_with p' z' (\\<lambda>a. s' (r a) a) t |t r. finite t \\<and> t \\<subseteq> X'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set A\n     {sum_with p z (\\<lambda>a. s (r a) a) t |t r.\n      finite t \\<and> t \\<subseteq> X}\n     {sum_with p' z' (\\<lambda>a. s' (r a) a) t |t r.\n      finite t \\<and> t \\<subseteq> X'}", "apply transfer_prover_start"], ["proof (prove)\ngoal (14 subgoals):\n 1. Transfer.Rel ?Rt22 ?al22 X'\n 2. Transfer.Rel (?Rg22 ===> ?Rt22 ===> ?Rs22) ?ak22 (\\<subseteq>)\n 3. Transfer.Rel (?Rg22 ===> ?Rr22) ?aj22 finite\n 4. Transfer.Rel (?Rr22 ===> ?Rs22 ===> ?Rm22) ?ai22 (\\<and>)\n 5. Transfer.Rel (?Rj22 ===> ?Ri22 ===> ?Rq22) ?ah22 s'\n 6. Transfer.Rel ?Rp22 ?ag22 z'\n 7. Transfer.Rel ?Ro22 ?af22 p'\n 8. Transfer.Rel\n     (?Ro22 ===> ?Rp22 ===> (?Ri22 ===> ?Rq22) ===> ?Rg22 ===> ?Rn22) ?ae22\n     sum_with\n 9. Transfer.Rel (?Rd22 ===> ?Rn22 ===> ?Rl22) ?ad22 (=)\n 10. Transfer.Rel (?Rl22 ===> ?Rm22 ===> ?Rk22) ?ac22 (\\<and>)\nA total of 14 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. {sum_with p z (\\<lambda>a. s (r a) a) t |t r.\n     finite t \\<and> t \\<subseteq> X} =\n    {x. (\\<exists>t\\<in>{Aa. Ball Aa (Domainp A)}.\n            \\<exists>r.\n               x = sum_with p z (\\<lambda>a. s (r a) a) t \\<and>\n               finite t \\<and> t \\<subseteq> X) \\<and>\n        Domainp A x}", "by (insert *) (auto intro!: DsI Domainp_sI)"], ["proof (state)\nthis:\n  rel_set A\n   {sum_with p z (\\<lambda>a. s (r a) a) t |t r.\n    finite t \\<and> t \\<subseteq> X}\n   {sum_with p' z' (\\<lambda>a. s' (r a) a) t |t r.\n    finite t \\<and> t \\<subseteq> X'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dependent_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"right_total A\" \"bi_unique A\"\n  shows \n    \"(\n      (=) ===>\n      A ===> \n      (A ===> A ===> A) ===>\n      ((=) ===> A ===> A) ===> \n      rel_set A ===> \n      (=)\n    ) dependent.with dependent.with\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     A ===>\n     (A ===> A ===> A) ===> ((=) ===> A ===> A) ===> rel_set A ===> (=))\n     dependent.with dependent.with", "unfolding dependent.with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     A ===>\n     (A ===> A ===> A) ===> ((=) ===> A ===> A) ===> rel_set A ===> (=))\n     (\\<lambda>zero zeroa plus scale s.\n         \\<exists>t u.\n            finite t \\<and>\n            t \\<subseteq> s \\<and>\n            sum_with plus zeroa (\\<lambda>v. scale (u v) v) t = zeroa \\<and>\n            (\\<exists>v\\<in>t. u v \\<noteq> zero))\n     (\\<lambda>zero zeroa plus scale s.\n         \\<exists>t u.\n            finite t \\<and>\n            t \\<subseteq> s \\<and>\n            sum_with plus zeroa (\\<lambda>v. scale (u v) v) t = zeroa \\<and>\n            (\\<exists>v\\<in>t. u v \\<noteq> zero))", "proof(intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>x = y; A xa ya; (A ===> A ===> A) xb yb;\n        ((=) ===> A ===> A) xc yc; rel_set A xd yd\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> xd \\<and>\n                             sum_with xb xa (\\<lambda>v. xc (u v) v) t =\n                             xa \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> x)) =\n                         (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> yd \\<and>\n                             sum_with yb ya (\\<lambda>v. yc (u v) v) t =\n                             ya \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> y))", "fix p p' z z' X X' and zb zb' ::'c and s s'::\"'c \\<Rightarrow> _\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>x = y; A xa ya; (A ===> A ===> A) xb yb;\n        ((=) ===> A ===> A) xc yc; rel_set A xd yd\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> xd \\<and>\n                             sum_with xb xa (\\<lambda>v. xc (u v) v) t =\n                             xa \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> x)) =\n                         (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> yd \\<and>\n                             sum_with yb ya (\\<lambda>v. yc (u v) v) t =\n                             ya \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> y))", "assume [transfer_rule]: \n    \"(A ===> A ===> A) p p'\"\n    \"A z z'\"\n    \"zb = zb'\"\n    \"((=) ===> A ===> A) s s'\" \n    \"rel_set A X X'\""], ["proof (state)\nthis:\n  (A ===> A ===> A) p p'\n  A z z'\n  zb = zb'\n  ((=) ===> A ===> A) s s'\n  rel_set A X X'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>x = y; A xa ya; (A ===> A ===> A) xb yb;\n        ((=) ===> A ===> A) xc yc; rel_set A xd yd\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> xd \\<and>\n                             sum_with xb xa (\\<lambda>v. xc (u v) v) t =\n                             xa \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> x)) =\n                         (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> yd \\<and>\n                             sum_with yb ya (\\<lambda>v. yc (u v) v) t =\n                             ya \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> y))", "have *: \"t \\<subseteq> X \\<Longrightarrow> (\\<forall>x\\<in>t. Domainp A x)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<subseteq> X \\<Longrightarrow> \\<forall>x\\<in>t. Domainp A x", "by (meson Domainp.DomainI \\<open>rel_set A X X'\\<close> rel_setD1 subsetD)"], ["proof (state)\nthis:\n  ?t \\<subseteq> X \\<Longrightarrow> \\<forall>x\\<in>?t. Domainp A x\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd.\n       \\<lbrakk>x = y; A xa ya; (A ===> A ===> A) xb yb;\n        ((=) ===> A ===> A) xc yc; rel_set A xd yd\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> xd \\<and>\n                             sum_with xb xa (\\<lambda>v. xc (u v) v) t =\n                             xa \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> x)) =\n                         (\\<exists>t u.\n                             finite t \\<and>\n                             t \\<subseteq> yd \\<and>\n                             sum_with yb ya (\\<lambda>v. yc (u v) v) t =\n                             ya \\<and>\n                             (\\<exists>v\\<in>t. u v \\<noteq> y))", "show \n    \"(\n        \\<exists>t u. \n          finite t \\<and> \n          t \\<subseteq> X \\<and> \n          sum_with p z (\\<lambda>v. s (u v) v) t = z \\<and> \n          (\\<exists>v\\<in>t. u v \\<noteq> zb)\n     ) =\n      (\n        \\<exists>t u. \n          finite t \\<and> \n          t \\<subseteq> X' \\<and> \n          sum_with p' z' (\\<lambda>v. s' (u v) v) t = z' \\<and> \n          (\\<exists>v\\<in>t. u v \\<noteq> zb')\n      )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t u.\n        finite t \\<and>\n        t \\<subseteq> X \\<and>\n        sum_with p z (\\<lambda>v. s (u v) v) t = z \\<and>\n        (\\<exists>v\\<in>t. u v \\<noteq> zb)) =\n    (\\<exists>t u.\n        finite t \\<and>\n        t \\<subseteq> X' \\<and>\n        sum_with p' z' (\\<lambda>v. s' (u v) v) t = z' \\<and>\n        (\\<exists>v\\<in>t. u v \\<noteq> zb'))", "apply transfer_prover_start"], ["proof (prove)\ngoal (19 subgoals):\n 1. Transfer.Rel ?Rx29 ?aq29 zb'\n 2. Transfer.Rel (?Rh29 ===> ?Rx29 ===> ?Rw29) ?ap29 (=)\n 3. Transfer.Rel (?Rw29 ===> ?Rv29) ?ao29 Not\n 4. Transfer.Rel (?Rd29 ===> (?Rg29 ===> ?Rv29) ===> ?Rp29) ?an29 Bex\n 5. Transfer.Rel ?Rr29 ?am29 z'\n 6. Transfer.Rel (?Rh29 ===> ?Rg29 ===> ?Ru29) ?al29 s'\n 7. Transfer.Rel ?Rt29 ?ak29 z'\n 8. Transfer.Rel ?Rs29 ?aj29 p'\n 9. Transfer.Rel\n     (?Rs29 ===> ?Rt29 ===> (?Rg29 ===> ?Ru29) ===> ?Rd29 ===> ?Rq29) ?ai29\n     sum_with\n 10. Transfer.Rel (?Rq29 ===> ?Rr29 ===> ?Ro29) ?ah29 (=)\nA total of 19 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>t u.\n        finite t \\<and>\n        t \\<subseteq> X \\<and>\n        sum_with p z (\\<lambda>v. s (u v) v) t = z \\<and>\n        (\\<exists>v\\<in>t. u v \\<noteq> zb)) =\n    (\\<exists>t\\<in>{Aa. Ball Aa (Domainp A)}.\n        \\<exists>u.\n           finite t \\<and>\n           t \\<subseteq> X \\<and>\n           sum_with p z (\\<lambda>v. s (u v) v) t = z \\<and>\n           (\\<exists>v\\<in>t. u v \\<noteq> zb))", "by (insert *) (auto intro!: comm_monoid_add_ow.sum_with_closed)"], ["proof (state)\nthis:\n  (\\<exists>t u.\n      finite t \\<and>\n      t \\<subseteq> X \\<and>\n      sum_with p z (\\<lambda>v. s (u v) v) t = z \\<and>\n      (\\<exists>v\\<in>t. u v \\<noteq> zb)) =\n  (\\<exists>t u.\n      finite t \\<and>\n      t \\<subseteq> X' \\<and>\n      sum_with p' z' (\\<lambda>v. s' (u v) v) t = z' \\<and>\n      (\\<exists>v\\<in>t. u v \\<noteq> zb'))\n\ngoal:\nNo subgoals!", "qed"], ["", "ctr relativization\n  synthesis ctr_simps\n  assumes [transfer_rule]: \"is_equality A\" \"bi_unique B\"\n  trp (?'a A) and (?'b B) \n  in subspace_with: subspace.with_def"], ["", "subsection\\<open>\\<open>module_ow\\<close>\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "text\\<open>Single module.\\<close>"], ["", "locale module_ow = ab_group_add_ow U\\<^sub>M plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M\n  for U\\<^sub>M :: \"'m set\" \n    and plus\\<^sub>M (infixl \\<open>+\\<^sub>M\\<close> 65)\n    and zero\\<^sub>M (\\<open>0\\<^sub>M\\<close>)\n    and minus\\<^sub>M (infixl \\<open>-\\<^sub>M\\<close> 65)\n    and uminus\\<^sub>M (\\<open>-\\<^sub>M _\\<close> [81] 80) +\n  fixes scale :: \"['cr1::comm_ring_1, 'm] \\<Rightarrow> 'm\" (infixr \"*s\\<^sub>M\" 75)\n  assumes scale_closed[simp, intro]: \"x \\<in> U\\<^sub>M \\<Longrightarrow> a *s\\<^sub>M x \\<in> U\\<^sub>M\"\n    and scale_right_distrib[algebra_simps]: \n    \"\\<lbrakk> x \\<in> U\\<^sub>M; y \\<in> U\\<^sub>M \\<rbrakk> \\<Longrightarrow> a *s\\<^sub>M (x +\\<^sub>M y) = a *s\\<^sub>M x +\\<^sub>M a *s\\<^sub>M y\"\n    and scale_left_distrib[algebra_simps]: \n      \"x \\<in> U\\<^sub>M \\<Longrightarrow> (a + b) *s\\<^sub>M x = a *s\\<^sub>M x +\\<^sub>M b *s\\<^sub>M x\"\n    and scale_scale[simp]: \n      \"x \\<in> U\\<^sub>M \\<Longrightarrow> a *s\\<^sub>M (b *s\\<^sub>M x) = (a * b) *s\\<^sub>M x\"\n    and scale_one[simp]: \"x \\<in> U\\<^sub>M \\<Longrightarrow> 1 *s\\<^sub>M x = x\"\nbegin"], ["", "lemma scale_closed'[simp]: \"\\<forall>a. \\<forall>x\\<in>U\\<^sub>M. a *s\\<^sub>M x \\<in> U\\<^sub>M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a. \\<forall>x\\<in>U\\<^sub>M. a *s\\<^sub>M x \\<in> U\\<^sub>M", "by simp"], ["", "lemma minus_closed'[simp]: \"\\<forall>x\\<in>U\\<^sub>M. \\<forall>y\\<in>U\\<^sub>M. x -\\<^sub>M y \\<in> U\\<^sub>M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U\\<^sub>M.\n       \\<forall>y\\<in>U\\<^sub>M. x -\\<^sub>M y \\<in> U\\<^sub>M", "by (simp add: ab_diff_conv_add_uminus add_closed' uminus_closed)"], ["", "lemma uminus_closed'[simp]: \"\\<forall>x\\<in>U\\<^sub>M. -\\<^sub>M x \\<in> U\\<^sub>M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U\\<^sub>M. -\\<^sub>M x \\<in> U\\<^sub>M", "by (simp add: uminus_closed)"], ["", "tts_register_sbts \\<open>(*s\\<^sub>M)\\<close> | U\\<^sub>M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp MA = (\\<lambda>x. x \\<in> U\\<^sub>M); bi_unique MA;\n     right_total MA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun (=) (rel_fun MA MA) (*s\\<^sub>M) rcdt", "by (rule tts_AB_C_transfer[OF scale_closed])\n    (auto simp: bi_unique_eq right_total_eq)"], ["", "tts_register_sbts plus\\<^sub>M | U\\<^sub>M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp MA = (\\<lambda>x. x \\<in> U\\<^sub>M); bi_unique MA;\n     right_total MA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt.\n                         rel_fun MA (rel_fun MA MA) (+\\<^sub>M) rcdt", "by (rule tts_AB_C_transfer[OF add_closed])\n    (auto simp: bi_unique_eq right_total_eq)"], ["", "tts_register_sbts zero\\<^sub>M | U\\<^sub>M"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp MA = (\\<lambda>x. x \\<in> U\\<^sub>M); bi_unique MA;\n     right_total MA\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt. MA 0\\<^sub>M rcdt", "by (meson Domainp.cases zero_closed)"], ["", "end"], ["", "text\\<open>Pair of modules.\\<close>"], ["", "locale module_pair_ow = \n  M\\<^sub>1: module_ow U\\<^sub>M\\<^sub>_\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 +\n  M\\<^sub>2: module_ow U\\<^sub>M\\<^sub>_\\<^sub>2 plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n  for U\\<^sub>M\\<^sub>_\\<^sub>1 :: \"'m_1 set\"\n    and plus\\<^sub>M\\<^sub>_\\<^sub>1 (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>1\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>1 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1 _\\<close> [81] 80)\n    and scale\\<^sub>1 :: \"['cr1::comm_ring_1, 'm_1] \\<Rightarrow> 'm_1\" (infixr \\<open>*s\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 75)\n    and U\\<^sub>M\\<^sub>_\\<^sub>2 :: \"'m_2 set\"\n    and plus\\<^sub>M\\<^sub>_\\<^sub>2 (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>2\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>2 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2 _\\<close> [81] 80)\n    and scale\\<^sub>2 :: \"['cr1::comm_ring_1, 'm_2] \\<Rightarrow> 'm_2\" (infixr \\<open>*s\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 75)"], ["", "text\\<open>Module homomorphisms.\\<close>"], ["", "locale module_hom_ow = \n  M\\<^sub>1: module_ow U\\<^sub>M\\<^sub>_\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 +\n  M\\<^sub>2: module_ow U\\<^sub>M\\<^sub>_\\<^sub>2 plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n  for U\\<^sub>M\\<^sub>_\\<^sub>1 :: \"'m_1 set\"\n    and plus\\<^sub>M\\<^sub>_\\<^sub>1 (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>1\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>1 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>1 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>1 _\\<close> [81] 80)\n    and scale\\<^sub>1 :: \"['cr1::comm_ring_1, 'm_1] \\<Rightarrow> 'm_1\" (infixr \\<open>*s\\<^sub>M\\<^sub>'_\\<^sub>1\\<close> 75)\n    and U\\<^sub>M\\<^sub>_\\<^sub>2 :: \"'m_2 set\"\n    and plus\\<^sub>M\\<^sub>_\\<^sub>2 (infixl \\<open>+\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and zero\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>0\\<^sub>M\\<^sub>'_\\<^sub>2\\<close>)\n    and minus\\<^sub>M\\<^sub>_\\<^sub>2 (infixl \\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 65)\n    and uminus\\<^sub>M\\<^sub>_\\<^sub>2 (\\<open>-\\<^sub>M\\<^sub>'_\\<^sub>2 _\\<close> [81] 80)\n    and scale\\<^sub>2 :: \"['cr1::comm_ring_1, 'm_2] \\<Rightarrow> 'm_2\" (infixr \\<open>*s\\<^sub>M\\<^sub>'_\\<^sub>2\\<close> 75) +\n  fixes f :: \"'m_1 \\<Rightarrow> 'm_2\"\n  assumes f_closed[simp]: \"f ` U\\<^sub>M\\<^sub>_\\<^sub>1 \\<subseteq> U\\<^sub>M\\<^sub>_\\<^sub>2\" \n    and add: \"\\<lbrakk> b1 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1; b2 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<rbrakk> \\<Longrightarrow> f (b1 +\\<^sub>M\\<^sub>_\\<^sub>1 b2) = f b1 +\\<^sub>M\\<^sub>_\\<^sub>2 f b2\"\n    and scale: \"\\<lbrakk> r \\<in> U\\<^sub>C\\<^sub>R\\<^sub>1; b \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<rbrakk> \\<Longrightarrow> f (r *s\\<^sub>M\\<^sub>_\\<^sub>1 b) = r *s\\<^sub>M\\<^sub>_\\<^sub>2 f b\"\nbegin"], ["", "tts_register_sbts f | \\<open>U\\<^sub>M\\<^sub>_\\<^sub>1\\<close> and \\<open>U\\<^sub>M\\<^sub>_\\<^sub>2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Domainp AA = (\\<lambda>x. x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2);\n     bi_unique AA; right_total AA;\n     Domainp AB = (\\<lambda>x. x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1);\n     bi_unique AB; right_total AB\\<rbrakk>\n    \\<Longrightarrow> \\<exists>rcdt. rel_fun AB AA f rcdt", "by (rule tts_AB_transfer[OF f_closed])"], ["", "lemma f_closed'[simp]: \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1.\n       f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2", "using f_closed"], ["proof (prove)\nusing this:\n  f ` U\\<^sub>M\\<^sub>_\\<^sub>1 \\<subseteq> U\\<^sub>M\\<^sub>_\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1.\n       f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2", "by blast"], ["", "sublocale module_pair_ow"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+\\<^sub>M\\<^sub>_\\<^sub>1)\n     0\\<^sub>M\\<^sub>_\\<^sub>1 (-\\<^sub>M\\<^sub>_\\<^sub>1)\n     uminus\\<^sub>M\\<^sub>_\\<^sub>1 (*s\\<^sub>M\\<^sub>_\\<^sub>1)\n     U\\<^sub>M\\<^sub>_\\<^sub>2 (+\\<^sub>M\\<^sub>_\\<^sub>2)\n     0\\<^sub>M\\<^sub>_\\<^sub>2 (-\\<^sub>M\\<^sub>_\\<^sub>2)\n     uminus\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>M\\<^sub>_\\<^sub>2)", ".."], ["", "end"], ["", "subsubsection\\<open>Transfer.\\<close>"], ["", "lemma module_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \"bi_unique B\" \"right_total B\"     \n  fixes PP lhs\n  defines\n    \"PP \\<equiv> \n      (\n        (B ===> B ===> B) ===>\n        B ===>\n        (B ===> B ===> B) ===>\n        (B ===> B) ===>\n        ((=) ===> B ===> B) ===>\n        (=)\n      )\"\n    and\n      \"lhs \\<equiv> \n        (\n          \\<lambda> plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n          module_ow (Collect (Domainp B)) plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale\n        )\"\n  shows \"PP lhs (module_with)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP lhs module_with", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. PP lhs module_with", "let ?rhs = \n    \"(\n      \\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n        (\\<forall>a \\<in> UNIV. \\<forall>x \\<in> UNIV. scale a x \\<in> UNIV) \\<and>\n         module_with plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale\n    )\""], ["proof (state)\ngoal (1 subgoal):\n 1. PP lhs module_with", "have \"PP lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP lhs\n     (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n         (\\<forall>a\\<in>UNIV.\n             \\<forall>x\\<in>UNIV. scale a x \\<in> UNIV) \\<and>\n         module_with plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M\n          scale)", "unfolding \n      PP_def lhs_def\n      module_ow_def module_with_def\n      module_ow_axioms_def module_with_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B ===> B ===> B) ===>\n     B ===>\n     (B ===> B ===> B) ===> (B ===> B) ===> ((=) ===> B ===> B) ===> (=))\n     (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n         ab_group_add_ow (Collect (Domainp B)) plus\\<^sub>M zero\\<^sub>M\n          minus\\<^sub>M uminus\\<^sub>M \\<and>\n         ((\\<forall>x a.\n              x \\<in> Collect (Domainp B) \\<longrightarrow>\n              scale a x \\<in> Collect (Domainp B)) \\<and>\n          (\\<forall>x y a.\n              x \\<in> Collect (Domainp B) \\<longrightarrow>\n              y \\<in> Collect (Domainp B) \\<longrightarrow>\n              scale a (plus\\<^sub>M x y) =\n              plus\\<^sub>M (scale a x) (scale a y))) \\<and>\n         (\\<forall>x a b.\n             x \\<in> Collect (Domainp B) \\<longrightarrow>\n             scale (a + b) x = plus\\<^sub>M (scale a x) (scale b x)) \\<and>\n         (\\<forall>x a b.\n             x \\<in> Collect (Domainp B) \\<longrightarrow>\n             scale a (scale b x) = scale (a * b) x) \\<and>\n         (\\<forall>x.\n             x \\<in> Collect (Domainp B) \\<longrightarrow>\n             scale (1::'c) x = x))\n     (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n         (\\<forall>a\\<in>UNIV.\n             \\<forall>x\\<in>UNIV. scale a x \\<in> UNIV) \\<and>\n         class.ab_group_add plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M\n          uminus\\<^sub>M \\<and>\n         ((\\<forall>a x y.\n              scale a (plus\\<^sub>M x y) =\n              plus\\<^sub>M (scale a x) (scale a y)) \\<and>\n          (\\<forall>a b x.\n              scale (a + b) x =\n              plus\\<^sub>M (scale a x) (scale b x))) \\<and>\n         (\\<forall>a b x. scale a (scale b x) = scale (a * b) x) \\<and>\n         (\\<forall>x. scale (1::'c) x = x))", "apply transfer_prover_start"], ["proof (prove)\ngoal (30 subgoals):\n 1. Transfer.Rel (=) ?bb73 (1::'c)\n 2. Transfer.Rel (B ===> B ===> ?Rah73) ?ba73 (=)\n 3. Transfer.Rel ((B ===> ?Rah73) ===> ?Rad73) ?az73 All\n 4. Transfer.Rel ((=) ===> (=) ===> (=)) ?ay73 (*)\n 5. Transfer.Rel (B ===> B ===> ?Rag73) ?ax73 (=)\n 6. Transfer.Rel ((B ===> ?Rag73) ===> ?Raf73) ?aw73 All\n 7. Transfer.Rel (((=) ===> ?Raf73) ===> ?Rae73) ?av73 All\n 8. Transfer.Rel (((=) ===> ?Rae73) ===> ?Rac73) ?au73 All\n 9. Transfer.Rel (?Rac73 ===> ?Rad73 ===> ?Rt73) ?at73 (\\<and>)\n 10. Transfer.Rel ((=) ===> (=) ===> (=)) ?as73 (+)\nA total of 30 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n        ab_group_add_ow (Collect (Domainp B)) plus\\<^sub>M zero\\<^sub>M\n         minus\\<^sub>M uminus\\<^sub>M \\<and>\n        ((\\<forall>x a.\n             x \\<in> Collect (Domainp B) \\<longrightarrow>\n             scale a x \\<in> Collect (Domainp B)) \\<and>\n         (\\<forall>x y a.\n             x \\<in> Collect (Domainp B) \\<longrightarrow>\n             y \\<in> Collect (Domainp B) \\<longrightarrow>\n             scale a (plus\\<^sub>M x y) =\n             plus\\<^sub>M (scale a x) (scale a y))) \\<and>\n        (\\<forall>x a b.\n            x \\<in> Collect (Domainp B) \\<longrightarrow>\n            scale (a + b) x = plus\\<^sub>M (scale a x) (scale b x)) \\<and>\n        (\\<forall>x a b.\n            x \\<in> Collect (Domainp B) \\<longrightarrow>\n            scale a (scale b x) = scale (a * b) x) \\<and>\n        (\\<forall>x.\n            x \\<in> Collect (Domainp B) \\<longrightarrow>\n            scale (1::'c) x = x)) =\n    (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n        (\\<forall>a\\<in>{x. x \\<in> UNIV}.\n            \\<forall>x\\<in>Collect (Domainp B).\n               scale a x \\<in> Collect (Domainp B)) \\<and>\n        ab_group_add_ow (Collect (Domainp B)) plus\\<^sub>M zero\\<^sub>M\n         minus\\<^sub>M uminus\\<^sub>M \\<and>\n        ((\\<forall>a\\<in>{x. x \\<in> UNIV}.\n             \\<forall>x\\<in>Collect (Domainp B).\n                \\<forall>y\\<in>Collect (Domainp B).\n                   scale a (plus\\<^sub>M x y) =\n                   plus\\<^sub>M (scale a x) (scale a y)) \\<and>\n         (\\<forall>a\\<in>{x. x \\<in> UNIV}.\n             \\<forall>b\\<in>{x. x \\<in> UNIV}.\n                \\<forall>x\\<in>Collect (Domainp B).\n                   scale (a + b) x =\n                   plus\\<^sub>M (scale a x) (scale b x))) \\<and>\n        (\\<forall>a\\<in>{x. x \\<in> UNIV}.\n            \\<forall>b\\<in>{x. x \\<in> UNIV}.\n               \\<forall>x\\<in>Collect (Domainp B).\n                  scale a (scale b x) = scale (a * b) x) \\<and>\n        (\\<forall>x\\<in>Collect (Domainp B). scale (1::'c) x = x))", "by (intro ext) blast"], ["proof (state)\nthis:\n  PP lhs\n   (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n       (\\<forall>a\\<in>UNIV.\n           \\<forall>x\\<in>UNIV. scale a x \\<in> UNIV) \\<and>\n       module_with plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M\n        scale)\n\ngoal (1 subgoal):\n 1. PP lhs module_with", "then"], ["proof (chain)\npicking this:\n  PP lhs\n   (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n       (\\<forall>a\\<in>UNIV.\n           \\<forall>x\\<in>UNIV. scale a x \\<in> UNIV) \\<and>\n       module_with plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M\n        scale)", "show ?thesis"], ["proof (prove)\nusing this:\n  PP lhs\n   (\\<lambda>plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M scale.\n       (\\<forall>a\\<in>UNIV.\n           \\<forall>x\\<in>UNIV. scale a x \\<in> UNIV) \\<and>\n       module_with plus\\<^sub>M zero\\<^sub>M minus\\<^sub>M uminus\\<^sub>M\n        scale)\n\ngoal (1 subgoal):\n 1. PP lhs module_with", "by simp"], ["proof (state)\nthis:\n  PP lhs module_with\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma module_pair_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \n    \"bi_unique B\\<^sub>1\" \"right_total B\\<^sub>1\" \"bi_unique B\\<^sub>2\" \"right_total B\\<^sub>2\"     \n  fixes PP lhs\n  defines\n    \"PP \\<equiv> \n      (\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        B\\<^sub>1 ===>\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>1 ===> B\\<^sub>1) ===>\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        B\\<^sub>2 ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2) ===>\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (=)\n    )\"\n    and\n      \"lhs \\<equiv> \n        (\n          \\<lambda>\n            plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2.\n          module_pair_ow \n            (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n        )\"\n    shows \"PP lhs module_pair_with\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP lhs module_pair_with", "unfolding PP_def lhs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n     B\\<^sub>1 ===>\n     (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n     (B\\<^sub>1 ===> B\\<^sub>1) ===>\n     ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n     (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n     B\\<^sub>2 ===>\n     (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n     (B\\<^sub>2 ===> B\\<^sub>2) ===>\n     ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===> (=))\n     (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n         minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n         scale\\<^sub>1.\n         module_pair_ow (Collect (Domainp B\\<^sub>1))\n          plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n          minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n          scale\\<^sub>1 (Collect (Domainp B\\<^sub>2)))\n     module_pair_with", "proof(intro rel_funI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf xg yg xh yh xi yi.\n       \\<lbrakk>(B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) x y;\n        B\\<^sub>1 xa ya; (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) xb yb;\n        (B\\<^sub>1 ===> B\\<^sub>1) xc yc;\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) xd yd;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xe ye; B\\<^sub>2 xf yf;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xg yg;\n        (B\\<^sub>2 ===> B\\<^sub>2) xh yh;\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) xi yi\\<rbrakk>\n       \\<Longrightarrow> module_pair_ow (Collect (Domainp B\\<^sub>1)) x xa\n                          xb xc xd (Collect (Domainp B\\<^sub>2)) xe xf xg xh\n                          xi =\n                         module_pair_with y ya yb yc yd ye yf yg yh yi", "let ?rhs = \n    \"(\n      \\<lambda>\n        plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n        plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2.\n          (\\<forall>a \\<in> UNIV. \\<forall>x \\<in> UNIV. scale\\<^sub>1 a x \\<in> UNIV) \\<and>\n          (\\<forall>a \\<in> UNIV. \\<forall>x \\<in> UNIV. scale\\<^sub>2 a x \\<in> UNIV) \\<and>\n          module_pair_with \n            plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n    )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf xg yg xh yh xi yi.\n       \\<lbrakk>(B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) x y;\n        B\\<^sub>1 xa ya; (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) xb yb;\n        (B\\<^sub>1 ===> B\\<^sub>1) xc yc;\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) xd yd;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xe ye; B\\<^sub>2 xf yf;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xg yg;\n        (B\\<^sub>2 ===> B\\<^sub>2) xh yh;\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) xi yi\\<rbrakk>\n       \\<Longrightarrow> module_pair_ow (Collect (Domainp B\\<^sub>1)) x xa\n                          xb xc xd (Collect (Domainp B\\<^sub>2)) xe xf xg xh\n                          xi =\n                         module_pair_with y ya yb yc yd ye yf yg yh yi", "fix \n    plus\\<^sub>M\\<^sub>_\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>1' \n    zero\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1' \n    minus\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1' \n    uminus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1' \n    plus\\<^sub>M\\<^sub>_\\<^sub>2 plus\\<^sub>M\\<^sub>_\\<^sub>2' \n    zero\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2' \n    minus\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2' \n    uminus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2' \n    and scale\\<^sub>1 :: \"'f::comm_ring_1 \\<Rightarrow> 'a \\<Rightarrow> 'a\" and scale\\<^sub>1' \n    and scale\\<^sub>2 :: \"'f::comm_ring_1 \\<Rightarrow> 'c \\<Rightarrow> 'c\" and scale\\<^sub>2'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf xg yg xh yh xi yi.\n       \\<lbrakk>(B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) x y;\n        B\\<^sub>1 xa ya; (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) xb yb;\n        (B\\<^sub>1 ===> B\\<^sub>1) xc yc;\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) xd yd;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xe ye; B\\<^sub>2 xf yf;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xg yg;\n        (B\\<^sub>2 ===> B\\<^sub>2) xh yh;\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) xi yi\\<rbrakk>\n       \\<Longrightarrow> module_pair_ow (Collect (Domainp B\\<^sub>1)) x xa\n                          xb xc xd (Collect (Domainp B\\<^sub>2)) xe xf xg xh\n                          xi =\n                         module_pair_with y ya yb yc yd ye yf yg yh yi", "assume [transfer_rule]: \n    \"(B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) plus\\<^sub>M\\<^sub>_\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>1'\"\n    \"B\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1'\"\n    \"(B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) minus\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1'\"\n    \"(B\\<^sub>1 ===> B\\<^sub>1) uminus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1'\"\n    \"(B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) plus\\<^sub>M\\<^sub>_\\<^sub>2 plus\\<^sub>M\\<^sub>_\\<^sub>2'\"\n    \"B\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2'\"\n    \"(B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) minus\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2'\"\n    \"(B\\<^sub>2 ===> B\\<^sub>2) uminus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2'\"\n    \"((=) ===> B\\<^sub>1 ===> B\\<^sub>1) scale\\<^sub>1 scale\\<^sub>1'\"\n    \"((=) ===> B\\<^sub>2 ===> B\\<^sub>2) scale\\<^sub>2 scale\\<^sub>2'\""], ["proof (state)\nthis:\n  (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) plus\\<^sub>M\\<^sub>_\\<^sub>1\n   plus\\<^sub>M\\<^sub>_\\<^sub>1'\n  B\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1'\n  (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) minus\\<^sub>M\\<^sub>_\\<^sub>1\n   minus\\<^sub>M\\<^sub>_\\<^sub>1'\n  (B\\<^sub>1 ===> B\\<^sub>1) uminus\\<^sub>M\\<^sub>_\\<^sub>1\n   uminus\\<^sub>M\\<^sub>_\\<^sub>1'\n  (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) plus\\<^sub>M\\<^sub>_\\<^sub>2\n   plus\\<^sub>M\\<^sub>_\\<^sub>2'\n  B\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2'\n  (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) minus\\<^sub>M\\<^sub>_\\<^sub>2\n   minus\\<^sub>M\\<^sub>_\\<^sub>2'\n  (B\\<^sub>2 ===> B\\<^sub>2) uminus\\<^sub>M\\<^sub>_\\<^sub>2\n   uminus\\<^sub>M\\<^sub>_\\<^sub>2'\n  ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) scale\\<^sub>1 scale\\<^sub>1'\n  ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) scale\\<^sub>2 scale\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb xc yc xd yd xe ye xf yf xg yg xh yh xi yi.\n       \\<lbrakk>(B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) x y;\n        B\\<^sub>1 xa ya; (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) xb yb;\n        (B\\<^sub>1 ===> B\\<^sub>1) xc yc;\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) xd yd;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xe ye; B\\<^sub>2 xf yf;\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) xg yg;\n        (B\\<^sub>2 ===> B\\<^sub>2) xh yh;\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) xi yi\\<rbrakk>\n       \\<Longrightarrow> module_pair_ow (Collect (Domainp B\\<^sub>1)) x xa\n                          xb xc xd (Collect (Domainp B\\<^sub>2)) xe xf xg xh\n                          xi =\n                         module_pair_with y ya yb yc yd ye yf yg yh yi", "show \n    \"module_pair_ow \n      (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \n      (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n      =\n    module_pair_with\n      plus\\<^sub>M\\<^sub>_\\<^sub>1' zero\\<^sub>M\\<^sub>_\\<^sub>1' minus\\<^sub>M\\<^sub>_\\<^sub>1' uminus\\<^sub>M\\<^sub>_\\<^sub>1' scale\\<^sub>1'\n      plus\\<^sub>M\\<^sub>_\\<^sub>2' zero\\<^sub>M\\<^sub>_\\<^sub>2' minus\\<^sub>M\\<^sub>_\\<^sub>2' uminus\\<^sub>M\\<^sub>_\\<^sub>2' scale\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair_ow (Collect (Domainp B\\<^sub>1))\n     plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n     minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n     scale\\<^sub>1 (Collect (Domainp B\\<^sub>2))\n     plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2\n     minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2\n     scale\\<^sub>2 =\n    module_pair_with plus\\<^sub>M\\<^sub>_\\<^sub>1'\n     zero\\<^sub>M\\<^sub>_\\<^sub>1' minus\\<^sub>M\\<^sub>_\\<^sub>1'\n     uminus\\<^sub>M\\<^sub>_\\<^sub>1' scale\\<^sub>1'\n     plus\\<^sub>M\\<^sub>_\\<^sub>2' zero\\<^sub>M\\<^sub>_\\<^sub>2'\n     minus\\<^sub>M\\<^sub>_\\<^sub>2' uminus\\<^sub>M\\<^sub>_\\<^sub>2'\n     scale\\<^sub>2'", "unfolding module_pair_ow_def module_pair_with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (module_ow (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1\n      zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n      uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n     module_ow (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2\n      zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n      uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2) =\n    (module_with plus\\<^sub>M\\<^sub>_\\<^sub>1' zero\\<^sub>M\\<^sub>_\\<^sub>1'\n      minus\\<^sub>M\\<^sub>_\\<^sub>1' uminus\\<^sub>M\\<^sub>_\\<^sub>1'\n      scale\\<^sub>1' \\<and>\n     module_with plus\\<^sub>M\\<^sub>_\\<^sub>2' zero\\<^sub>M\\<^sub>_\\<^sub>2'\n      minus\\<^sub>M\\<^sub>_\\<^sub>2' uminus\\<^sub>M\\<^sub>_\\<^sub>2'\n      scale\\<^sub>2')", "apply transfer_prover_start"], ["proof (prove)\ngoal (14 subgoals):\n 1. Transfer.Rel ?Rs15 ?al15 scale\\<^sub>2'\n 2. Transfer.Rel ?Rr15 ?ak15 uminus\\<^sub>M\\<^sub>_\\<^sub>2'\n 3. Transfer.Rel ?Rq15 ?aj15 minus\\<^sub>M\\<^sub>_\\<^sub>2'\n 4. Transfer.Rel ?Rp15 ?ai15 zero\\<^sub>M\\<^sub>_\\<^sub>2'\n 5. Transfer.Rel ?Ro15 ?ah15 plus\\<^sub>M\\<^sub>_\\<^sub>2'\n 6. Transfer.Rel\n     (?Ro15 ===> ?Rp15 ===> ?Rq15 ===> ?Rr15 ===> ?Rs15 ===> ?Rh15) ?ag15\n     module_with\n 7. Transfer.Rel ?Rn15 ?af15 scale\\<^sub>1'\n 8. Transfer.Rel ?Rm15 ?ae15 uminus\\<^sub>M\\<^sub>_\\<^sub>1'\n 9. Transfer.Rel ?Rl15 ?ad15 minus\\<^sub>M\\<^sub>_\\<^sub>1'\n 10. Transfer.Rel ?Rk15 ?ac15 zero\\<^sub>M\\<^sub>_\\<^sub>1'\nA total of 14 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (module_ow (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1\n      zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n      uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n     module_ow (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2\n      zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n      uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2) =\n    (module_ow (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1\n      zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n      uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n     module_ow (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2\n      zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n      uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  module_pair_ow (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1\n   zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n   uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n   (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2\n   zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n   uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 =\n  module_pair_with plus\\<^sub>M\\<^sub>_\\<^sub>1'\n   zero\\<^sub>M\\<^sub>_\\<^sub>1' minus\\<^sub>M\\<^sub>_\\<^sub>1'\n   uminus\\<^sub>M\\<^sub>_\\<^sub>1' scale\\<^sub>1'\n   plus\\<^sub>M\\<^sub>_\\<^sub>2' zero\\<^sub>M\\<^sub>_\\<^sub>2'\n   minus\\<^sub>M\\<^sub>_\\<^sub>2' uminus\\<^sub>M\\<^sub>_\\<^sub>2'\n   scale\\<^sub>2'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma module_hom_with_transfer[transfer_rule]:\n  includes lifting_syntax\n  assumes [transfer_rule]: \n    \"bi_unique B\\<^sub>1\" \"right_total B\\<^sub>1\" \"bi_unique B\\<^sub>2\" \"right_total B\\<^sub>2\"     \n  fixes PP lhs\n  defines\n    \"PP \\<equiv> \n      (\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        B\\<^sub>1 ===>\n        (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>1 ===> B\\<^sub>1) ===>\n        ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        B\\<^sub>2 ===>\n        (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (B\\<^sub>2 ===> B\\<^sub>2) ===>\n        ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n        (B\\<^sub>1 ===> B\\<^sub>2) ===>\n        (=)\n      )\"\n    and\n      \"lhs \\<equiv> \n        (\n          \\<lambda>\n            plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n            f.\n          module_hom_ow \n            (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n            (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n            f\n        )\"\n    shows \"PP lhs module_hom_with\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP lhs module_hom_with", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. PP lhs module_hom_with", "let ?rhs = \n    \"(\n      \\<lambda>\n        plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n        plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n        f. \n        (\\<forall>x \\<in> UNIV. f x \\<in> UNIV) \\<and>\n        module_hom_with\n          plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n          plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n          f\n    )\""], ["proof (state)\ngoal (1 subgoal):\n 1. PP lhs module_hom_with", "have \"PP lhs ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PP lhs\n     (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n         minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n         scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n         zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n         uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n         (\\<forall>x\\<in>UNIV. f x \\<in> UNIV) \\<and>\n         module_hom_with plus\\<^sub>M\\<^sub>_\\<^sub>1\n          zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n          uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n          plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2\n          minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2\n          scale\\<^sub>2 f)", "unfolding \n      PP_def lhs_def \n      module_hom_ow_def module_hom_with_def\n      module_hom_ow_axioms_def module_hom_with_axioms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n     B\\<^sub>1 ===>\n     (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n     (B\\<^sub>1 ===> B\\<^sub>1) ===>\n     ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n     (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n     B\\<^sub>2 ===>\n     (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n     (B\\<^sub>2 ===> B\\<^sub>2) ===>\n     ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n     (B\\<^sub>1 ===> B\\<^sub>2) ===> (=))\n     (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n         minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n         scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n         zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n         uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n         module_ow (Collect (Domainp B\\<^sub>1))\n          plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n          minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n          scale\\<^sub>1 \\<and>\n         module_ow (Collect (Domainp B\\<^sub>2))\n          plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2\n          minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2\n          scale\\<^sub>2 \\<and>\n         f ` Collect (Domainp B\\<^sub>1)\n         \\<subseteq> Collect (Domainp B\\<^sub>2) \\<and>\n         (\\<forall>b1 b2.\n             b1 \\<in> Collect (Domainp B\\<^sub>1) \\<longrightarrow>\n             b2 \\<in> Collect (Domainp B\\<^sub>1) \\<longrightarrow>\n             f (plus\\<^sub>M\\<^sub>_\\<^sub>1 b1 b2) =\n             plus\\<^sub>M\\<^sub>_\\<^sub>2 (f b1) (f b2)) \\<and>\n         (\\<forall>r U\\<^sub>C\\<^sub>R\\<^sub>1 b.\n             r \\<in> U\\<^sub>C\\<^sub>R\\<^sub>1 \\<longrightarrow>\n             b \\<in> Collect (Domainp B\\<^sub>1) \\<longrightarrow>\n             f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b)))\n     (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n         minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n         scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n         zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n         uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n         (\\<forall>x\\<in>UNIV. f x \\<in> UNIV) \\<and>\n         module_with plus\\<^sub>M\\<^sub>_\\<^sub>1\n          zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n          uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n         module_with plus\\<^sub>M\\<^sub>_\\<^sub>2\n          zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n          uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 \\<and>\n         (\\<forall>b1 b2.\n             f (plus\\<^sub>M\\<^sub>_\\<^sub>1 b1 b2) =\n             plus\\<^sub>M\\<^sub>_\\<^sub>2 (f b1) (f b2)) \\<and>\n         (\\<forall>r b. f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b)))", "apply transfer_prover_start"], ["proof (prove)\ngoal (17 subgoals):\n 1. Transfer.Rel (B\\<^sub>2 ===> B\\<^sub>2 ===> ?Raf47) ?ao47 (=)\n 2. Transfer.Rel ((B\\<^sub>1 ===> ?Raf47) ===> ?Rae47) ?an47 All\n 3. Transfer.Rel (((=) ===> ?Rae47) ===> ?Rab47) ?am47 All\n 4. Transfer.Rel (B\\<^sub>2 ===> B\\<^sub>2 ===> ?Rad47) ?al47 (=)\n 5. Transfer.Rel ((B\\<^sub>1 ===> ?Rad47) ===> ?Rac47) ?ak47 All\n 6. Transfer.Rel ((B\\<^sub>1 ===> ?Rac47) ===> ?Raa47) ?aj47 All\n 7. Transfer.Rel (?Raa47 ===> ?Rab47 ===> ?Rz47) ?ai47 (\\<and>)\n 8. Transfer.Rel\n     ((B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n      B\\<^sub>2 ===>\n      (B\\<^sub>2 ===> B\\<^sub>2 ===> B\\<^sub>2) ===>\n      (B\\<^sub>2 ===> B\\<^sub>2) ===>\n      ((=) ===> B\\<^sub>2 ===> B\\<^sub>2) ===> ?Ry47)\n     ?ah47 module_with\n 9. Transfer.Rel (?Ry47 ===> ?Rz47 ===> ?Rx47) ?ag47 (\\<and>)\n 10. Transfer.Rel\n      ((B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n       B\\<^sub>1 ===>\n       (B\\<^sub>1 ===> B\\<^sub>1 ===> B\\<^sub>1) ===>\n       (B\\<^sub>1 ===> B\\<^sub>1) ===>\n       ((=) ===> B\\<^sub>1 ===> B\\<^sub>1) ===> ?Rw47)\n      ?af47 module_with\nA total of 17 subgoals...", "apply transfer_step+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n        minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n        scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n        zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n        uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n        module_ow (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1\n         zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n         uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n        module_ow (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2\n         zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n         uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 \\<and>\n        f ` Collect (Domainp B\\<^sub>1)\n        \\<subseteq> Collect (Domainp B\\<^sub>2) \\<and>\n        (\\<forall>b1 b2.\n            b1 \\<in> Collect (Domainp B\\<^sub>1) \\<longrightarrow>\n            b2 \\<in> Collect (Domainp B\\<^sub>1) \\<longrightarrow>\n            f (plus\\<^sub>M\\<^sub>_\\<^sub>1 b1 b2) =\n            plus\\<^sub>M\\<^sub>_\\<^sub>2 (f b1) (f b2)) \\<and>\n        (\\<forall>r U\\<^sub>C\\<^sub>R\\<^sub>1 b.\n            r \\<in> U\\<^sub>C\\<^sub>R\\<^sub>1 \\<longrightarrow>\n            b \\<in> Collect (Domainp B\\<^sub>1) \\<longrightarrow>\n            f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b))) =\n    (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n        minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n        scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n        zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n        uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n        (\\<forall>x\\<in>Collect (Domainp B\\<^sub>1).\n            f x \\<in> Collect (Domainp B\\<^sub>2)) \\<and>\n        module_ow (Collect (Domainp B\\<^sub>1)) plus\\<^sub>M\\<^sub>_\\<^sub>1\n         zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n         uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n        module_ow (Collect (Domainp B\\<^sub>2)) plus\\<^sub>M\\<^sub>_\\<^sub>2\n         zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n         uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 \\<and>\n        (\\<forall>b1\\<in>Collect (Domainp B\\<^sub>1).\n            \\<forall>b2\\<in>Collect (Domainp B\\<^sub>1).\n               f (plus\\<^sub>M\\<^sub>_\\<^sub>1 b1 b2) =\n               plus\\<^sub>M\\<^sub>_\\<^sub>2 (f b1) (f b2)) \\<and>\n        (\\<forall>r\\<in>{x. x \\<in> UNIV}.\n            \\<forall>b\\<in>Collect (Domainp B\\<^sub>1).\n               f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b)))", "by (intro ext) blast"], ["proof (state)\nthis:\n  PP lhs\n   (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n       minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n       scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n       zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n       uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n       (\\<forall>x\\<in>UNIV. f x \\<in> UNIV) \\<and>\n       module_hom_with plus\\<^sub>M\\<^sub>_\\<^sub>1\n        zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n        uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n        plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2\n        minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2\n        scale\\<^sub>2 f)\n\ngoal (1 subgoal):\n 1. PP lhs module_hom_with", "then"], ["proof (chain)\npicking this:\n  PP lhs\n   (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n       minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n       scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n       zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n       uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n       (\\<forall>x\\<in>UNIV. f x \\<in> UNIV) \\<and>\n       module_hom_with plus\\<^sub>M\\<^sub>_\\<^sub>1\n        zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n        uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n        plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2\n        minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2\n        scale\\<^sub>2 f)", "show ?thesis"], ["proof (prove)\nusing this:\n  PP lhs\n   (\\<lambda>plus\\<^sub>M\\<^sub>_\\<^sub>1 zero\\<^sub>M\\<^sub>_\\<^sub>1\n       minus\\<^sub>M\\<^sub>_\\<^sub>1 uminus\\<^sub>M\\<^sub>_\\<^sub>1\n       scale\\<^sub>1 plus\\<^sub>M\\<^sub>_\\<^sub>2\n       zero\\<^sub>M\\<^sub>_\\<^sub>2 minus\\<^sub>M\\<^sub>_\\<^sub>2\n       uminus\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 f.\n       (\\<forall>x\\<in>UNIV. f x \\<in> UNIV) \\<and>\n       module_hom_with plus\\<^sub>M\\<^sub>_\\<^sub>1\n        zero\\<^sub>M\\<^sub>_\\<^sub>1 minus\\<^sub>M\\<^sub>_\\<^sub>1\n        uminus\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1\n        plus\\<^sub>M\\<^sub>_\\<^sub>2 zero\\<^sub>M\\<^sub>_\\<^sub>2\n        minus\\<^sub>M\\<^sub>_\\<^sub>2 uminus\\<^sub>M\\<^sub>_\\<^sub>2\n        scale\\<^sub>2 f)\n\ngoal (1 subgoal):\n 1. PP lhs module_hom_with", "by simp"], ["proof (state)\nthis:\n  PP lhs module_hom_with\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>\\<open>module_on\\<close>\\<close>"], ["", "subsubsection\\<open>Definitions and common properties\\<close>"], ["", "locale module_on =\n  fixes U\\<^sub>M\n    and scale :: \"'a::comm_ring_1 \\<Rightarrow> 'b::ab_group_add \\<Rightarrow> 'b\" (infixr \"*s\" 75)\n  assumes scale_right_distrib_on[algebra_simps]: \n      \"\\<lbrakk> x \\<in> U\\<^sub>M; y \\<in> U\\<^sub>M \\<rbrakk> \\<Longrightarrow> a *s (x + y) = a *s x + a *s y\"\n    and scale_left_distrib_on[algebra_simps]: \n      \"x \\<in> U\\<^sub>M \\<Longrightarrow> (a + b) *s x = a *s x + b *s x\"\n    and scale_scale_on[simp]: \"x \\<in> U\\<^sub>M \\<Longrightarrow> a *s (b *s x) = (a * b) *s x\"\n    and scale_one_on[simp]: \"x \\<in> U\\<^sub>M \\<Longrightarrow> 1 *s x = x\"\n    and closed_add: \"\\<lbrakk> x \\<in> U\\<^sub>M; y \\<in> U\\<^sub>M \\<rbrakk> \\<Longrightarrow> x + y \\<in> U\\<^sub>M\"\n    and closed_zero: \"0 \\<in> U\\<^sub>M\"\n    and closed_scale: \"x \\<in> U\\<^sub>M \\<Longrightarrow> a *s x \\<in> U\\<^sub>M\"\nbegin"], ["", "lemma S_ne: \"U\\<^sub>M \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^sub>M \\<noteq> {}", "using closed_zero"], ["proof (prove)\nusing this:\n  (0::'b) \\<in> U\\<^sub>M\n\ngoal (1 subgoal):\n 1. U\\<^sub>M \\<noteq> {}", "by auto"], ["", "lemma scale_minus_left_on: \n  assumes \"x \\<in> U\\<^sub>M\" \n  shows \"scale (- a) x = - scale a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a *s x = - (a *s x)", "by \n    (\n      metis \n        add_cancel_right_right scale_left_distrib_on neg_eq_iff_add_eq_0 assms\n    )"], ["", "lemma closed_uminus: \n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"-x \\<in> U\\<^sub>M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x \\<in> U\\<^sub>M", "by (metis assms closed_scale scale_minus_left_on scale_one_on)"], ["", "sublocale implicit\\<^sub>M: ab_group_add_ow U\\<^sub>M \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. ab_group_add_ow U\\<^sub>M (+) (0::'b) (-) uminus", "by unfold_locales (simp_all add: closed_add closed_zero closed_uminus)"], ["", "sublocale implicit\\<^sub>M: module_ow U\\<^sub>M \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus \\<open>(*s)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_ow U\\<^sub>M (+) (0::'b) (-) uminus (*s)", "by unfold_locales \n    (simp_all add: closed_scale scale_right_distrib_on scale_left_distrib_on)"], ["", "definition subspace :: \"'b set \\<Rightarrow> bool\"\n  where subspace_on_def: \"subspace T \\<longleftrightarrow> \n    0 \\<in> T \\<and> (\\<forall>x\\<in>T. \\<forall>y\\<in>T. x + y \\<in> T) \\<and> (\\<forall>c. \\<forall>x\\<in>T. c *s x \\<in> T)\""], ["", "definition span :: \"'b set \\<Rightarrow> 'b set\"\n  where span_on_def: \"span b = {sum (\\<lambda>a. r a *s  a) t | t r. finite t \\<and> t \\<subseteq> b}\""], ["", "definition dependent :: \"'b set \\<Rightarrow> bool\"\n  where dependent_on_def: \"dependent s \\<longleftrightarrow> \n    (\\<exists>t u. finite t \\<and> t \\<subseteq> s \\<and> (sum (\\<lambda>v. u v *s v) t = 0 \\<and> (\\<exists>v\\<in>t. u v \\<noteq> 0)))\""], ["", "lemma implicit_subspace_with[tts_implicit]: \"subspace.with (+) 0 (*s) = subspace\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subspace.with (+) (0::'b) (*s) = local.subspace", "unfolding subspace_on_def subspace.with_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>S.\n        (0::'b) \\<in> S \\<and>\n        (\\<forall>x\\<in>S. \\<forall>y\\<in>S. x + y \\<in> S) \\<and>\n        (\\<forall>c. \\<forall>x\\<in>S. c *s x \\<in> S)) =\n    (\\<lambda>T.\n        (0::'b) \\<in> T \\<and>\n        (\\<forall>x\\<in>T. \\<forall>y\\<in>T. x + y \\<in> T) \\<and>\n        (\\<forall>c. \\<forall>x\\<in>T. c *s x \\<in> T))", ".."], ["", "lemma implicit_dependent_with[tts_implicit]: \n  \"dependent.with 0 0 (+) (*s) = dependent\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dependent.with (0::'a) (0::'b) (+) (*s) = local.dependent", "unfolding dependent_on_def dependent.with_def sum_with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        \\<exists>t u.\n           finite t \\<and>\n           t \\<subseteq> s \\<and>\n           sum_with (+) (0::'b) (\\<lambda>v. u v *s v) t = (0::'b) \\<and>\n           (\\<exists>v\\<in>t. u v \\<noteq> (0::'a))) =\n    (\\<lambda>s.\n        \\<exists>t u.\n           finite t \\<and>\n           t \\<subseteq> s \\<and>\n           sum_with (+) (0::'b) (\\<lambda>v. u v *s v) t = (0::'b) \\<and>\n           (\\<exists>v\\<in>t. u v \\<noteq> (0::'a)))", ".."], ["", "lemma implicit_span_with[tts_implicit]: \"span.with 0 (+) (*s) = span\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span.with (0::'b) (+) (*s) = local.span", "unfolding span_on_def span.with_def sum_with"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b.\n        {sum_with (+) (0::'b) (\\<lambda>a. r a *s a) t |t r.\n         finite t \\<and> t \\<subseteq> b}) =\n    (\\<lambda>b.\n        {sum_with (+) (0::'b) (\\<lambda>a. r a *s a) t |t r.\n         finite t \\<and> t \\<subseteq> b})", ".."], ["", "end"], ["", "lemma implicit_module_ow[tts_implicit]:\n  \"module_ow U\\<^sub>M (+) 0 (-) uminus = module_on U\\<^sub>M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_ow U\\<^sub>M (+) (0::'b) (-) uminus = module_on U\\<^sub>M", "proof (intro ext iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x\n 2. \\<And>x.\n       module_on U\\<^sub>M x \\<Longrightarrow>\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x", "fix s::\"'a\\<Rightarrow>'b\\<Rightarrow>'b\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x\n 2. \\<And>x.\n       module_on U\\<^sub>M x \\<Longrightarrow>\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x", "assume \"module_on U\\<^sub>M s\""], ["proof (state)\nthis:\n  module_on U\\<^sub>M s\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x\n 2. \\<And>x.\n       module_on U\\<^sub>M x \\<Longrightarrow>\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x", "then"], ["proof (chain)\npicking this:\n  module_on U\\<^sub>M s", "interpret module_on U\\<^sub>M s"], ["proof (prove)\nusing this:\n  module_on U\\<^sub>M s\n\ngoal (1 subgoal):\n 1. module_on U\\<^sub>M s", "."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x\n 2. \\<And>x.\n       module_on U\\<^sub>M x \\<Longrightarrow>\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x", "show \"module_ow U\\<^sub>M (+) 0 (-) uminus s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_ow U\\<^sub>M (+) (0::'b) (-) uminus s", "by (simp add: implicit\\<^sub>M.module_ow_axioms)"], ["proof (state)\nthis:\n  module_ow U\\<^sub>M (+) (0::'b) (-) uminus s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x", "fix s::\"'a\\<Rightarrow>'b\\<Rightarrow>'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x", "assume \"module_ow U\\<^sub>M (+) 0 (-) uminus s\""], ["proof (state)\nthis:\n  module_ow U\\<^sub>M (+) (0::'b) (-) uminus s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x", "then"], ["proof (chain)\npicking this:\n  module_ow U\\<^sub>M (+) (0::'b) (-) uminus s", "interpret module_ow U\\<^sub>M \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus s"], ["proof (prove)\nusing this:\n  module_ow U\\<^sub>M (+) (0::'b) (-) uminus s\n\ngoal (1 subgoal):\n 1. module_ow U\\<^sub>M (+) (0::'b) (-) uminus s", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       module_ow U\\<^sub>M (+) (0::'b) (-) uminus x \\<Longrightarrow>\n       module_on U\\<^sub>M x", "show \"module_on U\\<^sub>M s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_on U\\<^sub>M s", "by (simp add: scale_left_distrib scale_right_distrib module_on.intro)"], ["proof (state)\nthis:\n  module_on U\\<^sub>M s\n\ngoal:\nNo subgoals!", "qed"], ["", "locale module_pair_on = \n  M\\<^sub>1: module_on U\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 + M\\<^sub>2: module_on U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n  for U\\<^sub>M\\<^sub>_\\<^sub>1:: \"'b::ab_group_add set\" \n    and U\\<^sub>M\\<^sub>_\\<^sub>2::\"'c::ab_group_add set\"\n    and scale\\<^sub>1::\"'a::comm_ring_1 \\<Rightarrow> _ \\<Rightarrow> _\" (infixr \\<open>*s\\<^sub>1\\<close> 75)\n    and scale\\<^sub>2::\"'a::comm_ring_1 \\<Rightarrow> _ \\<Rightarrow> _\" (infixr \\<open>*s\\<^sub>2\\<close> 75)\nbegin"], ["", "sublocale implicit\\<^sub>M: module_pair_ow \n  U\\<^sub>M\\<^sub>_\\<^sub>1 \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus scale\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) (0::'b) (-) uminus\n     (*s\\<^sub>1) U\\<^sub>M\\<^sub>_\\<^sub>2 (+) (0::'c) (-) uminus\n     (*s\\<^sub>2)", "by unfold_locales"], ["", "end"], ["", "lemma implicit_module_pair_ow[tts_implicit]:\n  \"module_pair_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (+) 0 (-) uminus scale\\<^sub>2 = \n    module_pair_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>1 scale\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) (0::'a) (-) uminus\n     scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (+) (0::'c) (-) uminus\n     scale\\<^sub>2 =\n    module_pair_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2\n     scale\\<^sub>1 scale\\<^sub>2", "unfolding module_pair_ow_def implicit_module_ow module_pair_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (module_on U\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n     module_on U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2) =\n    (module_on U\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n     module_on U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2)", ".."], ["", "locale module_hom_on = M\\<^sub>1: module_on U\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 + M\\<^sub>2: module_on U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2\n  for U\\<^sub>M\\<^sub>_\\<^sub>1 :: \"'b::ab_group_add set\" and U\\<^sub>M\\<^sub>_\\<^sub>2 :: \"'c::ab_group_add set\"\n    and scale\\<^sub>1 :: \"'a::comm_ring_1 \\<Rightarrow> 'b \\<Rightarrow> 'b\" (infixr \\<open>*s\\<^sub>1\\<close> 75)\n    and scale\\<^sub>2 :: \"'a::comm_ring_1 \\<Rightarrow> 'c \\<Rightarrow> 'c\" (infixr \\<open>*s\\<^sub>2\\<close> 75) +\n  fixes f :: \"'b \\<Rightarrow> 'c\"\n  assumes hom_closed: \"f ` U\\<^sub>M\\<^sub>_\\<^sub>1 \\<subseteq> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and add: \"\\<And>b1 b2. \\<lbrakk> b1 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1; b2 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<rbrakk> \\<Longrightarrow> f (b1 + b2) = f b1 + f b2\"\n    and scale: \"\\<And>b. b \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<Longrightarrow> f (r *s\\<^sub>1 b) = r *s\\<^sub>2 f b\"\nbegin"], ["", "sublocale module_pair_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>1 scale\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_pair_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2\n     (*s\\<^sub>1) (*s\\<^sub>2)", "by unfold_locales"], ["", "sublocale implicit\\<^sub>M: module_hom_ow \n  U\\<^sub>M\\<^sub>_\\<^sub>1 \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 \\<open>(+)\\<close> 0 \\<open>(-)\\<close> uminus scale\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. module_hom_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) (0::'b) (-) uminus\n     (*s\\<^sub>1) U\\<^sub>M\\<^sub>_\\<^sub>2 (+) (0::'c) (-) uminus\n     (*s\\<^sub>2) f", "by unfold_locales (simp_all add: hom_closed add scale)"], ["", "end"], ["", "lemma implicit_module_hom_ow[tts_implicit]:\n  \"module_hom_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) 0 (-) uminus scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (+) 0 (-) uminus scale\\<^sub>2 = \n    module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>1 scale\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. module_hom_ow U\\<^sub>M\\<^sub>_\\<^sub>1 (+) (0::'a) (-) uminus\n     scale\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (+) (0::'b) (-) uminus\n     scale\\<^sub>2 =\n    module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2\n     scale\\<^sub>1 scale\\<^sub>2", "unfolding \n    module_hom_ow_def \n    module_hom_on_def \n    module_hom_ow_axioms_def\n    module_hom_on_axioms_def\n    tts_implicit"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        module_on U\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n        module_on U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 \\<and>\n        f ` U\\<^sub>M\\<^sub>_\\<^sub>1\n        \\<subseteq> U\\<^sub>M\\<^sub>_\\<^sub>2 \\<and>\n        (\\<forall>b1 b2.\n            b1 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<longrightarrow>\n            b2 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<longrightarrow>\n            f (b1 + b2) = f b1 + f b2) \\<and>\n        (\\<forall>r U\\<^sub>C\\<^sub>R\\<^sub>1 b.\n            r \\<in> U\\<^sub>C\\<^sub>R\\<^sub>1 \\<longrightarrow>\n            b \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<longrightarrow>\n            f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b))) =\n    (\\<lambda>f.\n        module_on U\\<^sub>M\\<^sub>_\\<^sub>1 scale\\<^sub>1 \\<and>\n        module_on U\\<^sub>M\\<^sub>_\\<^sub>2 scale\\<^sub>2 \\<and>\n        f ` U\\<^sub>M\\<^sub>_\\<^sub>1\n        \\<subseteq> U\\<^sub>M\\<^sub>_\\<^sub>2 \\<and>\n        (\\<forall>b1 b2.\n            b1 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<longrightarrow>\n            b2 \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<longrightarrow>\n            f (b1 + b2) = f b1 + f b2) \\<and>\n        (\\<forall>r b.\n            b \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1 \\<longrightarrow>\n            f (scale\\<^sub>1 r b) = scale\\<^sub>2 r (f b)))", "by (intro ext) auto"], ["", "subsection\\<open>Relativization.\\<close>"], ["", "context module_on\nbegin"], ["", "tts_context\n  tts: (?'b to \\<open>U\\<^sub>M::'b set\\<close>)\n  rewriting ctr_simps\n  substituting implicit\\<^sub>M.module_ow_axioms\n    and implicit\\<^sub>M.ab_group_add_ow_axioms\n  eliminating \\<open>?a \\<in> U\\<^sub>M\\<close> and \\<open>?B \\<subseteq> U\\<^sub>M\\<close> through auto\n  applying \n    [\n      OF \n        implicit\\<^sub>M.carrier_ne \n        implicit\\<^sub>M.add_closed' \n        implicit\\<^sub>M.minus_closed' \n        implicit\\<^sub>M.uminus_closed' \n        implicit\\<^sub>M.scale_closed',\n      unfolded tts_implicit\n    ]\nbegin"], ["", "tts_lemma scale_left_commute:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"a *s b *s x = b *s a *s x\"\n    is module.scale_left_commute"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_zero_left:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"0 *s x = 0\"\n    is module.scale_zero_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_minus_left:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"- a *s x = - (a *s x)\"\n    is module.scale_minus_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_left_diff_distrib:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"(a - b) *s x = a *s x - b *s x\"\n    is module.scale_left_diff_distrib"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_sum_left:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"sum f A *s x = (\\<Sum>a\\<in>A. f a *s x)\"\n    is module.scale_sum_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_zero_right: \"a *s 0 = 0\"\n    is module.scale_zero_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_minus_right:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"a *s - x = - (a *s x)\"\n    is module.scale_minus_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_right_diff_distrib:\n  assumes \"x \\<in> U\\<^sub>M\" and \"y \\<in> U\\<^sub>M\"\n  shows \"a *s (x - y) = a *s x - a *s y\"\n    is module.scale_right_diff_distrib"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma scale_sum_right:\n  assumes \"range f \\<subseteq> U\\<^sub>M\"\n  shows \"a *s sum f A = (\\<Sum>x\\<in>A. a *s f x)\"\n    is module.scale_sum_right"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma sum_constant_scale:\n  assumes \"y \\<in> U\\<^sub>M\"\n  shows \"(\\<Sum>x\\<in>A. y) = of_nat (card A) *s y\"\n    is module.sum_constant_scale"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_def:\n  assumes \"S \\<subseteq> U\\<^sub>M\"\n  shows \"subspace S =\n    (0 \\<in> S \\<and> (\\<forall>x. \\<forall>y\\<in>S. x *s y \\<in> S) \\<and> (\\<forall>x\\<in>S. \\<forall>y\\<in>S. x + y \\<in> S))\"\n    is module.subspace_def"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspaceI:\n  assumes \"S \\<subseteq> U\\<^sub>M\"\n    and \"0 \\<in> S\"\n    and \"\\<And>x y. \\<lbrakk>x \\<in> U\\<^sub>M; y \\<in> U\\<^sub>M; x \\<in> S; y \\<in> S\\<rbrakk> \\<Longrightarrow> x + y \\<in> S\"\n    and \"\\<And>c x. \\<lbrakk>x \\<in> U\\<^sub>M; x \\<in> S\\<rbrakk> \\<Longrightarrow> c *s x \\<in> S\"\n  shows \"subspace S\"\n    is module.subspaceI"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_single_0: \"subspace {0}\"\n    is module.subspace_single_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_0:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"subspace S\"\n  shows \"0 \\<in> S\"\n    is module.subspace_0"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_add:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"subspace S\" and \"x \\<in> S\" and \"y \\<in> S\"\n  shows \"x + y \\<in> S\"\n    is module.subspace_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_scale:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"subspace S\" and \"x \\<in> S\"\n  shows \"c *s x \\<in> S\"\n    is module.subspace_scale"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_neg:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"subspace S\" and \"x \\<in> S\"\n  shows \"- x \\<in> S\"\n    is module.subspace_neg"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_diff:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"subspace S\" and \"x \\<in> S\" and \"y \\<in> S\"\n  shows \"x - y \\<in> S\"\n    is module.subspace_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_sum:\n  assumes \"A \\<subseteq> U\\<^sub>M\"\n    and \"range f \\<subseteq> U\\<^sub>M\"\n    and \"subspace A\"\n    and \"\\<And>x. x \\<in> B \\<Longrightarrow> f x \\<in> A\"\n  shows \"sum f B \\<in> A\"\n    is module.subspace_sum"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_inter:\n  assumes \"A \\<subseteq> U\\<^sub>M\" and \"B \\<subseteq> U\\<^sub>M\" and \"subspace A\" and \"subspace B\"\n  shows \"subspace (A \\<inter> B)\"\n    is module.subspace_inter"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_explicit':\n  assumes \"b \\<subseteq> U\\<^sub>M\"\n  shows \"span b = \n    {\n      x \\<in> U\\<^sub>M. \\<exists>f. \n        x = (\\<Sum>v\\<in>{x \\<in> U\\<^sub>M. f x \\<noteq> 0}. f v *s v) \\<and> \n        finite {x \\<in> U\\<^sub>M. f x \\<noteq> 0} \\<and> \n        (\\<forall>x\\<in>U\\<^sub>M. f x \\<noteq> 0 \\<longrightarrow> x \\<in> b)\n    }\"\n   is module.span_explicit'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_finite:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"finite S\"\n  shows \"span S = range (\\<lambda>u. \\<Sum>v\\<in>S. u v *s v)\"\n    is module.span_finite"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_induct_alt:\n  assumes \"x \\<in> U\\<^sub>M\"\n    and \"S \\<subseteq> U\\<^sub>M\"\n    and \"x \\<in> span S\"\n    and \"h 0\"\n    and \"\\<And>c x y. \\<lbrakk>x \\<in> U\\<^sub>M; y \\<in> U\\<^sub>M; x \\<in> S; h y\\<rbrakk> \\<Longrightarrow> h (c *s x + y)\"\n  shows \"h x\"\n    is module.span_induct_alt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_mono:\n  assumes \"B \\<subseteq> U\\<^sub>M\" and \"A \\<subseteq> B\"\n  shows \"span A \\<subseteq> span B\"\n    is module.span_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_base:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"a \\<in> S\"\n  shows \"a \\<in> span S\"\n    is module.span_base"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_superset:\n  assumes \"S \\<subseteq> U\\<^sub>M\"\n  shows \"S \\<subseteq> span S\"\n    is module.span_superset"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_zero:\n  assumes \"S \\<subseteq> U\\<^sub>M\"\n  shows \"0 \\<in> span S\"\n    is module.span_zero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_add:\n  assumes \"x \\<in> U\\<^sub>M\"\n    and \"S \\<subseteq> U\\<^sub>M\"\n    and \"y \\<in> U\\<^sub>M\"\n    and \"x \\<in> span S\"\n    and \"y \\<in> span S\"\n  shows \"x + y \\<in> span S\"\n    is module.span_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_scale:\n  assumes \"x \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\" and \"x \\<in> span S\"\n  shows \"c *s x \\<in> span S\"\n    is module.span_scale"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_span:\n  assumes \"S \\<subseteq> U\\<^sub>M\"\n  shows \"subspace (span S)\"\n    is module.subspace_span"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_neg:\n  assumes \"x \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\" and \"x \\<in> span S\"\n  shows \"- x \\<in> span S\"\n    is module.span_neg"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_diff:\n  assumes \"x \\<in> U\\<^sub>M\"\n    and \"S \\<subseteq> U\\<^sub>M\"\n    and \"y \\<in> U\\<^sub>M\"\n    and \"x \\<in> span S\"\n    and \"y \\<in> span S\"\n  shows \"x - y \\<in> span S\"\n    is module.span_diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_sum:\n  assumes \"range f \\<subseteq> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> f x \\<in> span S\"\n  shows \"sum f A \\<in> span S\"\n    is module.span_sum"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_minimal:\n  assumes \"T \\<subseteq> U\\<^sub>M\" and \"S \\<subseteq> T\" and \"subspace T\"\n  shows \"span S \\<subseteq> T\"\n    is module.span_minimal"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_subspace_induct:\n  assumes \"x \\<in> U\\<^sub>M\"\n    and \"S \\<subseteq> U\\<^sub>M\"\n    and \"P \\<subseteq> U\\<^sub>M\"\n    and \"x \\<in> span S\"\n    and \"subspace P\"\n    and \"\\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> P\"\n  shows \"x \\<in> P\"\n    given module.span_subspace_induct"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> U\\<^sub>M; S \\<subseteq> U\\<^sub>M;\n     P \\<subseteq> U\\<^sub>M; x \\<in> local.span S; local.subspace P;\n     \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> P;\n     \\<And>x S P.\n        \\<lbrakk>x \\<in> U\\<^sub>M; S \\<subseteq> U\\<^sub>M;\n         P \\<subseteq> U\\<^sub>M; x \\<in> local.span S; local.subspace P;\n         \\<And>x.\n            \\<lbrakk>x \\<in> U\\<^sub>M; x \\<in> S\\<rbrakk>\n            \\<Longrightarrow> x \\<in> P\\<rbrakk>\n        \\<Longrightarrow> x \\<in> P\\<rbrakk>\n    \\<Longrightarrow> x \\<in> P", "by simp"], ["", "tts_lemma span_induct:\n  assumes \"x \\<in> U\\<^sub>M\"\n    and \"S \\<subseteq> U\\<^sub>M\"\n    and \"x \\<in> span S\"\n    and \"subspace {x. P x \\<and> x \\<in> U\\<^sub>M}\"\n    and \"\\<And>x. x \\<in> S \\<Longrightarrow> P x\"\n  shows \"P x\"\n    given module.span_induct"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> U\\<^sub>M; S \\<subseteq> U\\<^sub>M;\n     x \\<in> local.span S; local.subspace {x. P x \\<and> x \\<in> U\\<^sub>M};\n     \\<And>x. x \\<in> S \\<Longrightarrow> P x;\n     \\<And>x S P.\n        \\<lbrakk>x \\<in> U\\<^sub>M; S \\<subseteq> U\\<^sub>M;\n         x \\<in> local.span S;\n         local.subspace {x. P x \\<and> x \\<in> U\\<^sub>M};\n         \\<And>x.\n            \\<lbrakk>x \\<in> U\\<^sub>M; x \\<in> S\\<rbrakk>\n            \\<Longrightarrow> P x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "by blast"], ["", "tts_lemma span_empty: \"span {} = {0}\"\n    is module.span_empty"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_subspace:\n  assumes \"B \\<subseteq> U\\<^sub>M\" and \"A \\<subseteq> B\" and \"B \\<subseteq> span A\" and \"subspace B\"\n  shows \"span A = B\"\n    is module.span_subspace"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_span:\n  assumes \"A \\<subseteq> U\\<^sub>M\"\n  shows \"span (span A) = span A\"\n    is module.span_span"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_add_eq:\n  assumes \"x \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\" and \"y \\<in> U\\<^sub>M\" and \"x \\<in> span S\"\n  shows \"(x + y \\<in> span S) = (y \\<in> span S)\"\n    is module.span_add_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_add_eq2:\n  assumes \"y \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\" and \"x \\<in> U\\<^sub>M\" and \"y \\<in> span S\"\n  shows \"(x + y \\<in> span S) = (x \\<in> span S)\"\n    is module.span_add_eq2"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_singleton:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"span {x} = range (\\<lambda>k. k *s x)\"\n    is module.span_singleton"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_Un:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"T \\<subseteq> U\\<^sub>M\"\n  shows \"span (S \\<union> T) = \n    {x \\<in> U\\<^sub>M. \\<exists>a\\<in>U\\<^sub>M. \\<exists>b\\<in>U\\<^sub>M. x = a + b \\<and> a \\<in> span S \\<and> b \\<in> span T}\"\n    is module.span_Un"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_insert:\n  assumes \"a \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\"\n  shows \"span (insert a S) = {x \\<in> U\\<^sub>M. \\<exists>y. x - y *s a \\<in> span S}\"\n    is module.span_insert"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_breakdown:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"a \\<in> U\\<^sub>M\" and \"b \\<in> S\" and \"a \\<in> span S\"\n  shows \"\\<exists>x. a - x *s b \\<in> span (S - {b})\"\n    is module.span_breakdown"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_breakdown_eq:\n  assumes \"x \\<in> U\\<^sub>M\" and \"a \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\"\n  shows \"(x \\<in> span (insert a S)) = (\\<exists>y. x - y *s a \\<in> span S)\"\n    is module.span_breakdown_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_clauses:\n  \"\\<lbrakk>S \\<subseteq> U\\<^sub>M; a \\<in> S\\<rbrakk> \\<Longrightarrow> a \\<in> span S\"\n  \"S \\<subseteq> U\\<^sub>M \\<Longrightarrow> 0 \\<in> span S\"\n  \"\\<lbrakk>x \\<in> U\\<^sub>M; S \\<subseteq> U\\<^sub>M; y \\<in> U\\<^sub>M; x \\<in> span S; y \\<in> span S\\<rbrakk> \\<Longrightarrow> x + y \\<in> span S\"\n  \"\\<lbrakk>x \\<in> U\\<^sub>M; S \\<subseteq> U\\<^sub>M; x \\<in> span S\\<rbrakk> \\<Longrightarrow> c *s x \\<in> span S\"\n  is module.span_clauses"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_eq_iff:\n  assumes \"s \\<subseteq> U\\<^sub>M\"\n  shows \"(span s = s) = subspace s\"\n    is module.span_eq_iff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_eq:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"T \\<subseteq> U\\<^sub>M\"\n  shows \"(span S = span T) = (S \\<subseteq> span T \\<and> T \\<subseteq> span S)\"\n    is module.span_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma eq_span_insert_eq:\n  assumes \"x \\<in> U\\<^sub>M\" and \"y \\<in> U\\<^sub>M\" and \"S \\<subseteq> U\\<^sub>M\" and \"x - y \\<in> span S\"\n  shows \"span (insert x S) = span (insert y S)\"\n    is module.eq_span_insert_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dependent_mono:\n  assumes \"A \\<subseteq> U\\<^sub>M\" and \"dependent B\" and \"B \\<subseteq> A\"\n  shows \"dependent A\"\n    is module.dependent_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independent_mono:\n  assumes \"A \\<subseteq> U\\<^sub>M\" and \"\\<not> dependent A\" and \"B \\<subseteq> A\"\n  shows \"\\<not> dependent B\"\n    is module.independent_mono"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dependent_zero:\n  assumes \"A \\<subseteq> U\\<^sub>M\" and \"0 \\<in> A\"\n  shows \"dependent A\"\n    is module.dependent_zero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independent_empty: \"\\<not> dependent {}\"\n    is module.independent_empty"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independentD:\n  assumes \"s \\<subseteq> U\\<^sub>M\"\n    and \"\\<not> dependent s\"\n    and \"finite t\"\n    and \"t \\<subseteq> s\"\n    and \"(\\<Sum>v\\<in>t. u v *s v) = 0\"\n    and \"v \\<in> t\"\n  shows \"u v = 0\"\n    is module.independentD"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independent_Union_directed:\n  assumes \"C \\<subseteq> Pow U\\<^sub>M\"\n    and \"\\<And>c d. \\<lbrakk>c \\<subseteq> U\\<^sub>M; d \\<subseteq> U\\<^sub>M; c \\<in> C; d \\<in> C\\<rbrakk> \\<Longrightarrow> c \\<subseteq> d \\<or> d \\<subseteq> c\"\n    and \"\\<And>c. \\<lbrakk>c \\<subseteq> U\\<^sub>M; c \\<in> C\\<rbrakk> \\<Longrightarrow> \\<not> dependent c\"\n  shows \"\\<not> dependent (\\<Union> C)\"\n    is module.independent_Union_directed"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dependent_finite:\n  assumes \"S \\<subseteq> U\\<^sub>M\" and \"finite S\"\n  shows \"dependent S = (\\<exists>x. (\\<exists>y\\<in>S. x y \\<noteq> 0) \\<and> (\\<Sum>v\\<in>S. x v *s v) = 0)\"\n    is module.dependent_finite"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independentD_alt:\n  assumes \"B \\<subseteq> U\\<^sub>M\"\n    and \"x \\<in> U\\<^sub>M\"\n    and \"\\<not> dependent B\"\n    and \"finite {x \\<in> U\\<^sub>M. X x \\<noteq> 0}\"\n    and \"{x \\<in> U\\<^sub>M. X x \\<noteq> 0} \\<subseteq> B\"\n    and \"(\\<Sum>x | x \\<in> U\\<^sub>M \\<and> X x \\<noteq> 0. X x *s x) = 0\"\n  shows \"X x = 0\"\n    is module.independentD_alt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma spanning_subset_independent:\n  assumes \"A \\<subseteq> U\\<^sub>M\" and \"B \\<subseteq> A\" and \"\\<not> dependent A\" and \"A \\<subseteq> span B\"\n  shows \"A = B\"\n    is module.spanning_subset_independent"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma unique_representation:\n  assumes \"basis \\<subseteq> U\\<^sub>M\"\n    and \"\\<not> dependent basis\"\n    and \"\\<And>v. \\<lbrakk>v \\<in> U\\<^sub>M; f v \\<noteq> 0\\<rbrakk> \\<Longrightarrow> v \\<in> basis\"\n    and \"\\<And>v. \\<lbrakk>v \\<in> U\\<^sub>M; g v \\<noteq> 0\\<rbrakk> \\<Longrightarrow> v \\<in> basis\"\n    and \"finite {x \\<in> U\\<^sub>M. f x \\<noteq> 0}\"\n    and \"finite {x \\<in> U\\<^sub>M. g x \\<noteq> 0}\"\n    and \n      \"(\\<Sum>v\\<in>{x \\<in> U\\<^sub>M. f x \\<noteq> 0}. f v *s v) = (\\<Sum>v\\<in>{x \\<in> U\\<^sub>M. g x \\<noteq> 0}. g v *s v)\"\n  shows \"\\<forall>x\\<in>U\\<^sub>M. f x = g x\"\n    is module.unique_representation[unfolded fun_eq_iff]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independentD_unique:\n  assumes \"B \\<subseteq> U\\<^sub>M\"\n    and \"\\<not> dependent B\"\n    and \"finite {x \\<in> U\\<^sub>M. X x \\<noteq> 0}\"\n    and \"{x \\<in> U\\<^sub>M. X x \\<noteq> 0} \\<subseteq> B\"\n    and \"finite {x \\<in> U\\<^sub>M. Y x \\<noteq> 0}\"\n    and \"{x \\<in> U\\<^sub>M. Y x \\<noteq> 0} \\<subseteq> B\"\n    and \"(\\<Sum>x | x \\<in> U\\<^sub>M \\<and> X x \\<noteq> 0. X x *s x) = \n      (\\<Sum>x | x \\<in> U\\<^sub>M \\<and> Y x \\<noteq> 0. Y x *s x)\"\n  shows \"\\<forall>x\\<in>U\\<^sub>M. X x = Y x\"\n    is module.independentD_unique[unfolded fun_eq_iff]"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_UNIV: \"subspace U\\<^sub>M\"\n  is module.subspace_UNIV"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_UNIV: \"span U\\<^sub>M = U\\<^sub>M\"\n  is module.span_UNIV"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma span_alt:\n  assumes \"B \\<subseteq> U\\<^sub>M\"\n  shows \n    \"span B = \n      {\n        x \\<in> U\\<^sub>M. \\<exists>f. \n          x = (\\<Sum>x | x \\<in> U\\<^sub>M \\<and> f x \\<noteq> 0. f x *s x) \\<and> \n          finite {x \\<in> U\\<^sub>M. f x \\<noteq> 0} \\<and> \n          {x \\<in> U\\<^sub>M. f x \\<noteq> 0} \\<subseteq> B\n      }\"\n    is module.span_alt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dependent_alt:\n  assumes \"B \\<subseteq> U\\<^sub>M\"\n  shows \"dependent B = \n    (\n      \\<exists>f. \n        finite {v \\<in> U\\<^sub>M. f v \\<noteq> 0} \\<and> \n        {v \\<in> U\\<^sub>M. f v \\<noteq> 0} \\<subseteq> B \\<and> \n        (\\<exists>v\\<in>U\\<^sub>M. f v \\<noteq> 0) \\<and> \n        (\\<Sum>x | x \\<in> U\\<^sub>M \\<and> f x \\<noteq> 0. f x *s x) = 0\n    )\"\n    is module.dependent_alt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma independent_alt:\n  assumes \"B \\<subseteq> U\\<^sub>M\"\n  shows \n    \"(\\<not> dependent B) = \n      (\n        \\<forall>f. \n          finite {x \\<in> U\\<^sub>M. f x \\<noteq> 0} \\<longrightarrow> \n          {x \\<in> U\\<^sub>M. f x \\<noteq> 0} \\<subseteq> B \\<longrightarrow> \n          (\\<Sum>x | x \\<in> U\\<^sub>M \\<and> f x \\<noteq> 0. f x *s x) = 0 \\<longrightarrow> \n          (\\<forall>x\\<in>U\\<^sub>M. f x = 0)\n    )\"\n    is module.independent_alt"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_Int:\n  assumes \"range s \\<subseteq> Pow U\\<^sub>M\" and \"\\<And>i. i \\<in> I \\<Longrightarrow> subspace (s i)\"\n  shows \"subspace (\\<Inter> (s ` I) \\<inter> U\\<^sub>M)\"\n    is module.subspace_Int"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma subspace_Inter:\n  assumes \"f \\<subseteq> Pow U\\<^sub>M\" and \"Ball f subspace\"\n  shows \"subspace (\\<Inter> f \\<inter> U\\<^sub>M)\"\n    is module.subspace_Inter"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_scale_self: \"module_hom_on U\\<^sub>M U\\<^sub>M (*s) (*s) ((*s) c)\"\n  is module.module_hom_scale_self"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_scale_left:\n  assumes \"x \\<in> U\\<^sub>M\"\n  shows \"module_hom_on UNIV U\\<^sub>M (*) (*s) (\\<lambda>r. r *s x)\"\n  is module.module_hom_scale_left"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_id: \"module_hom_on U\\<^sub>M U\\<^sub>M (*s) (*s) id\"\n  is module.module_hom_id"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_ident: \"module_hom_on U\\<^sub>M U\\<^sub>M (*s) (*s) (\\<lambda>x. x)\"\n  is module.module_hom_ident"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_uminus: \"module_hom_on U\\<^sub>M U\\<^sub>M (*s) (*s) uminus\"\n  is module.module_hom_uminus"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "tts_context\n  tts: (?'b to \\<open>U\\<^sub>M::'b set\\<close>)\n  rewriting ctr_simps\n  substituting implicit\\<^sub>M.module_ow_axioms\n    and implicit\\<^sub>M.ab_group_add_ow_axioms\n  eliminating \\<open>?a \\<in> U\\<^sub>M\\<close> and \\<open>?B \\<subseteq> U\\<^sub>M\\<close> through clarsimp\n  applying \n    [\n      OF \n        implicit\\<^sub>M.carrier_ne\n        implicit\\<^sub>M.add_closed' \n        implicit\\<^sub>M.minus_closed' \n        implicit\\<^sub>M.uminus_closed' \n        implicit\\<^sub>M.scale_closed',\n      unfolded tts_implicit\n    ]\nbegin"], ["", "tts_lemma span_explicit:\n  assumes \"b \\<subseteq> U\\<^sub>M\"\n  shows \"span b = \n    {x \\<in> U\\<^sub>M. \\<exists>y\\<subseteq>U\\<^sub>M. \\<exists>f. (finite y \\<and> y \\<subseteq> b) \\<and> x = (\\<Sum>a\\<in>y. f a *s a)}\"\n  given module.span_explicit"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>b \\<subseteq> U\\<^sub>M;\n     \\<And>b.\n        b \\<subseteq> U\\<^sub>M \\<Longrightarrow>\n        local.span b =\n        {x \\<in> U\\<^sub>M.\n         \\<exists>t\\<in>Pow U\\<^sub>M.\n            \\<exists>r.\n               (finite t \\<and> t \\<subseteq> b) \\<and>\n               x = (\\<Sum>a\\<in>t. r a *s a)}\\<rbrakk>\n    \\<Longrightarrow> local.span b =\n                      {x \\<in> U\\<^sub>M.\n                       \\<exists>y\\<subseteq>U\\<^sub>M.\n                          \\<exists>f.\n                             (finite y \\<and> y \\<subseteq> b) \\<and>\n                             x = (\\<Sum>a\\<in>y. f a *s a)}", "by auto"], ["", "tts_lemma span_unique:\n  assumes \"S \\<subseteq> U\\<^sub>M\"\n    and \"T \\<subseteq> U\\<^sub>M\"\n    and \"S \\<subseteq> T\"\n    and \"subspace T\"\n    and \"\\<And>T'. \\<lbrakk>T' \\<subseteq> U\\<^sub>M; S \\<subseteq> T'; subspace T'\\<rbrakk> \\<Longrightarrow> T \\<subseteq> T'\"\n  shows \"span S = T\"\n    is module.span_unique"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma dependent_explicit:\n  assumes \"V \\<subseteq> U\\<^sub>M\"\n  shows \"dependent V = \n    (\\<exists>U\\<subseteq>U\\<^sub>M. \\<exists>f. finite U \\<and> U \\<subseteq> V \\<and> (\\<exists>v\\<in>U. f v \\<noteq> 0) \\<and> (\\<Sum>v\\<in>U. f v *s v) = 0)\"\n    given module.dependent_explicit"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<subseteq> U\\<^sub>M;\n     \\<And>s.\n        s \\<subseteq> U\\<^sub>M \\<Longrightarrow>\n        local.dependent s =\n        (\\<exists>t\\<in>Pow U\\<^sub>M.\n            \\<exists>u.\n               finite t \\<and>\n               t \\<subseteq> s \\<and>\n               (\\<exists>v\\<in>t. u v \\<noteq> (0::'a)) \\<and>\n               (\\<Sum>v\\<in>t. u v *s v) = (0::'b))\\<rbrakk>\n    \\<Longrightarrow> local.dependent V =\n                      (\\<exists>U\\<subseteq>U\\<^sub>M.\n                          \\<exists>f.\n                             finite U \\<and>\n                             U \\<subseteq> V \\<and>\n                             (\\<exists>v\\<in>U. f v \\<noteq> (0::'a)) \\<and>\n                             (\\<Sum>v\\<in>U. f v *s v) = (0::'b))", "by auto"], ["", "tts_lemma independent_explicit_module:\n  assumes \"V \\<subseteq> U\\<^sub>M\"\n  shows \"(\\<not> dependent V) = \n    (\n      \\<forall>U\\<subseteq>U\\<^sub>M. \\<forall>f. \\<forall>v\\<in>U\\<^sub>M. \n        finite U \\<longrightarrow> \n        U \\<subseteq> V \\<longrightarrow> \n        (\\<Sum>u\\<in>U. f u *s u) = 0 \\<longrightarrow> \n        v \\<in> U \\<longrightarrow> \n        f v = 0\n    )\"\n    given module.independent_explicit_module"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<subseteq> U\\<^sub>M;\n     \\<And>s.\n        s \\<subseteq> U\\<^sub>M \\<Longrightarrow>\n        (\\<not> local.dependent s) =\n        (\\<forall>t\\<in>Pow U\\<^sub>M.\n            \\<forall>u.\n               \\<forall>v\\<in>U\\<^sub>M.\n                  finite t \\<longrightarrow>\n                  t \\<subseteq> s \\<longrightarrow>\n                  (\\<Sum>v\\<in>t. u v *s v) = (0::'b) \\<longrightarrow>\n                  v \\<in> t \\<longrightarrow> u v = (0::'a))\\<rbrakk>\n    \\<Longrightarrow> (\\<not> local.dependent V) =\n                      (\\<forall>U\\<subseteq>U\\<^sub>M.\n                          \\<forall>f.\n                             \\<forall>v\\<in>U\\<^sub>M.\n                                finite U \\<longrightarrow>\n                                U \\<subseteq> V \\<longrightarrow>\n                                (\\<Sum>u\\<in>U. f u *s u) =\n                                (0::'b) \\<longrightarrow>\n                                v \\<in> U \\<longrightarrow> f v = (0::'a))", "by auto"], ["", "end"], ["", "end"], ["", "context module_pair_on \nbegin"], ["", "tts_context\n  tts: (?'b to \\<open>U\\<^sub>M\\<^sub>_\\<^sub>1::'b set\\<close>) and (?'c to \\<open>U\\<^sub>M\\<^sub>_\\<^sub>2::'c set\\<close>)\n  rewriting ctr_simps\n  substituting M\\<^sub>1.implicit\\<^sub>M.module_ow_axioms\n    and M\\<^sub>2.implicit\\<^sub>M.module_ow_axioms\n    and M\\<^sub>1.implicit\\<^sub>M.ab_group_add_ow_axioms\n    and M\\<^sub>2.implicit\\<^sub>M.ab_group_add_ow_axioms\n    and implicit\\<^sub>M.module_pair_ow_axioms\n  eliminating through auto\n  applying [unfolded tts_implicit]\nbegin"], ["", "tts_lemma module_hom_zero: \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. 0)\"\n    is module_pair.module_hom_zero"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_add:\n  assumes \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. g x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) f\"\n    and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) g\"\n  shows \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. f x + g x)\"\n    is module_pair.module_hom_add"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_sub:\n  assumes \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. g x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) f\"\n    and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) g\"\n  shows \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. f x - g x)\"\n    is module_pair.module_hom_sub"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_neg:\n  assumes \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\" and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) f\"\n  shows \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. - f x)\"\n    is module_pair.module_hom_neg"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_scale:\n  assumes \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\" and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) f\"\n  shows \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. c *s\\<^sub>2 f x)\"\n    is module_pair.module_hom_scale"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_compose_scale:\n  assumes \"c \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\" and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 UNIV (*s\\<^sub>1) (*) f\"\n  shows \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. f x *s\\<^sub>2 c)\"\n    is module_pair.module_hom_compose_scale"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_sum:\n  assumes \"\\<forall>u. \\<forall>v\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f u v \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"\\<And>i. i \\<in> I \\<Longrightarrow> module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (f i)\"\n    and \"I = {} \\<Longrightarrow> module_on U\\<^sub>M\\<^sub>_\\<^sub>1 (*s\\<^sub>1) \\<and> module_on U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>2)\"\n  shows \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) (\\<lambda>x. \\<Sum>i\\<in>I. f i x)\"\n  is module_pair.module_hom_sum"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "tts_lemma module_hom_eq_on_span:\n  assumes \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. f x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"\\<forall>x\\<in>U\\<^sub>M\\<^sub>_\\<^sub>1. g x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>2\"\n    and \"B \\<subseteq> U\\<^sub>M\\<^sub>_\\<^sub>1\"\n    and \"x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1\"\n    and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) f\"\n    and \"module_hom_on U\\<^sub>M\\<^sub>_\\<^sub>1 U\\<^sub>M\\<^sub>_\\<^sub>2 (*s\\<^sub>1) (*s\\<^sub>2) g\"\n    and \"\\<And>x. \\<lbrakk>x \\<in> U\\<^sub>M\\<^sub>_\\<^sub>1; x \\<in> B\\<rbrakk> \\<Longrightarrow> f x = g x\"\n    and \"x \\<in> M\\<^sub>1.span B\"\n  shows \"f x = g x\"\n    is module_pair.module_hom_eq_on_span"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "end"], ["", "text\\<open>\\newpage\\<close>"], ["", "end"]]}