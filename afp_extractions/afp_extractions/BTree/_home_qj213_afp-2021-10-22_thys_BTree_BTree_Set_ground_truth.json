{"file_name": "/home/qj213/afp-2021-10-22/thys/BTree/BTree_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BTree", "problem_names": ["lemma drop_not_empty: \"xs \\<noteq> [] \\<Longrightarrow> drop (length xs div 2) xs \\<noteq> []\"", "lemma split_half_not_empty: \"length xs \\<ge> 1 \\<Longrightarrow> \\<exists>ls sub sep rs. split_half xs = (ls,(sub,sep)#rs)\"", "lemmas split_conc = split_req(1)", "lemmas split_sorted = split_req(2,3)", "lemma [termination_simp]:\"(ls, (sub, sep) # rs) = split ts y \\<Longrightarrow>\n      size sub < Suc (size_list (\\<lambda>x. Suc (size (fst x))) ts  + size l)\"", "lemma split_set:\n  assumes \"split ts z = (ls,(a,b)#rs)\"\n  shows \"(a,b) \\<in> set ts\"\n    and \"(x,y) \\<in> set ls \\<Longrightarrow> (x,y) \\<in> set ts\"\n    and \"(x,y) \\<in> set rs \\<Longrightarrow> (x,y) \\<in> set ts\"\n    and \"set ls \\<union> set rs \\<union> {(a,b)} = set ts\"\n    and \"\\<exists>x \\<in> set ts. b \\<in> Basic_BNFs.snds x\"", "lemma split_length:\n  \"split ts x = (ls, rs) \\<Longrightarrow> length ls + length rs = length ts\"", "lemma sorted_ConsD: \"sorted_less (y # xs) \\<Longrightarrow> x \\<le> y \\<Longrightarrow> x \\<notin> set xs\"", "lemma sorted_snocD: \"sorted_less (xs @ [y]) \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x \\<notin> set xs\"", "lemmas isin_simps2 = sorted_lems sorted_ConsD sorted_snocD", "lemma isin_sorted: \"sorted_less (xs@a#ys) \\<Longrightarrow>\n  (x \\<in> set (xs@a#ys)) = (if x < a then x \\<in> set xs else x \\<in> set (a#ys))\"", "lemma isin_sorted_split:\n  assumes \"sorted_less (inorder (Node ts t))\"\n    and \"split ts x = (ls, rs)\"\n  shows \"x \\<in> set (inorder (Node ts t)) = (x \\<in> set (inorder_list rs @ inorder t))\"", "lemma isin_sorted_split_right:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n    and \"sep \\<noteq> x\"\n  shows \"x \\<in> set (inorder_list ((sub,sep)#rs) @ inorder t) = (x \\<in> set (inorder sub))\"", "theorem isin_set_inorder: \"sorted_less (inorder t) \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\"", "lemma node\\<^sub>i_cases: \"length xs \\<le> k \\<or> (\\<exists>ls sub sep rs. split_half xs = (ls,(sub,sep)#rs))\"", "lemma root_order_tree\\<^sub>i: \"root_order_up\\<^sub>i (Suc k) t = root_order (Suc k) (tree\\<^sub>i t)\"", "lemma node\\<^sub>i_root_order:\n  assumes \"length ts > 0\"\n    and \"length ts \\<le> 4*k+1\"\n    and \"\\<forall>x \\<in> set (subtrees ts). order k x\"\n    and \"order k t\"\n  shows \"root_order_up\\<^sub>i k (node\\<^sub>i k ts t)\"", "lemma node\\<^sub>i_order_helper:\n  assumes \"length ts \\<ge> k\"\n    and \"length ts \\<le> 4*k+1\"\n    and \"\\<forall>x \\<in> set (subtrees ts). order k x\"\n    and \"order k t\"\n  shows \"case (node\\<^sub>i k ts t) of T\\<^sub>i t \\<Rightarrow> order k t | _ \\<Rightarrow> True\"", "lemma node\\<^sub>i_order:\n  assumes \"length ts \\<ge> k\"\n    and \"length ts \\<le> 4*k+1\"\n    and \"\\<forall>x \\<in> set (subtrees ts). order k x\"\n    and \"order k t\"\n  shows \"order_up\\<^sub>i k (node\\<^sub>i k ts t)\"", "lemma ins_order:\n  \"order k t \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\"", "lemma ins_root_order:\n  assumes \"root_order k t\"\n  shows \"root_order_up\\<^sub>i k (ins k x t)\"", "lemma height_list_split: \"height_up\\<^sub>i (Up\\<^sub>i (Node ls a) b (Node rs t)) = height (Node (ls@(a,b)#rs) t) \"", "lemma node\\<^sub>i_height: \"height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\"", "lemma bal_up\\<^sub>i_tree: \"bal_up\\<^sub>i t = bal (tree\\<^sub>i t)\"", "lemma bal_list_split: \"bal (Node (ls@(a,b)#rs) t) \\<Longrightarrow> bal_up\\<^sub>i (Up\\<^sub>i (Node ls a) b (Node rs t))\"", "lemma node\\<^sub>i_bal:\n  assumes \"bal (Node ts t)\"\n  shows \"bal_up\\<^sub>i (node\\<^sub>i k ts t)\"", "lemma height_up\\<^sub>i_merge: \"height_up\\<^sub>i (Up\\<^sub>i l a r) = height t \\<Longrightarrow> height (Node (ls@(t,x)#rs) tt) = height (Node (ls@(l,a)#(r,x)#rs) tt)\"", "lemma ins_height: \"height_up\\<^sub>i (ins k x t) = height t\"", "lemma ins_bal: \"bal t \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\"", "lemma node\\<^sub>i_inorder: \"inorder_up\\<^sub>i (node\\<^sub>i k ts t) = inorder (Node ts t)\"", "lemma ins_sorted_inorder: \"sorted_less (inorder t) \\<Longrightarrow> (inorder_up\\<^sub>i (ins k (x::('a::linorder)) t)) = ins_list x (inorder t)\"", "lemma ins_list_split:\n  assumes \"split ts x = (ls, rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n  shows \"ins_list x (inorder (Node ts t)) = inorder_list ls @ ins_list x (inorder_list rs @ inorder t)\"", "lemma ins_list_split_right_general:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder_list ts)\"\n    and \"sep \\<noteq> x\"\n  shows \"ins_list x (inorder_list ((sub,sep)#rs) @ zs) = ins_list x (inorder sub) @ sep # inorder_list rs @ zs\"", "lemma ins_list_idem_eq_isin: \"sorted_less xs \\<Longrightarrow> x \\<in> set xs \\<longleftrightarrow> (ins_list x xs = xs)\"", "lemma ins_list_contains_idem: \"\\<lbrakk>sorted_less xs; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> (ins_list x xs = xs)\"", "lemma ins_inorder: \"sorted_less (inorder t) \\<Longrightarrow> (inorder_up\\<^sub>i (ins k x t)) = ins_list x (inorder t)\"", "lemma tree\\<^sub>i_bal: \"bal_up\\<^sub>i u \\<Longrightarrow> bal (tree\\<^sub>i u)\"", "lemma tree\\<^sub>i_order: \"\\<lbrakk>k > 0; root_order_up\\<^sub>i k u\\<rbrakk> \\<Longrightarrow> root_order k (tree\\<^sub>i u)\"", "lemma tree\\<^sub>i_inorder: \"inorder_up\\<^sub>i u = inorder (tree\\<^sub>i u)\"", "lemma insert_bal: \"bal t \\<Longrightarrow> bal (insert k x t)\"", "lemma insert_order: \"\\<lbrakk>k > 0; root_order k t\\<rbrakk> \\<Longrightarrow> root_order k (insert k x t)\"", "lemma insert_inorder: \"sorted_less (inorder t) \\<Longrightarrow> inorder (insert k x t) = ins_list x (inorder t)\"", "lemma rebalance_middle_tree_height:\n  assumes \"height t = height sub\"\n    and \"case rs of (rsub,rsep) # list \\<Rightarrow> height rsub = height t | [] \\<Rightarrow> True\"\n  shows \"height (rebalance_middle_tree k ls sub sep rs t) = height (Node (ls@(sub,sep)#rs) t)\"", "lemma rebalance_last_tree_height:\n  assumes \"height t = height sub\"\n    and \"ts = list@[(sub,sep)]\"\n  shows \"height (rebalance_last_tree k ts t) = height (Node ts t)\"", "lemma split_max_height:\n  assumes \"split_max k t = (sub,sep)\"\n    and \"nonempty_lasttreebal t\"\n    and \"t \\<noteq> Leaf\"\n  shows \"height sub = height t\"", "lemma order_bal_nonempty_lasttreebal: \"\\<lbrakk>k > 0; root_order k t; bal t\\<rbrakk> \\<Longrightarrow> nonempty_lasttreebal t\"", "lemma bal_sub_height: \"bal (Node (ls@a#rs) t) \\<Longrightarrow> (case rs of [] \\<Rightarrow> True | (sub,sep)#_ \\<Rightarrow> height sub = height t)\"", "lemma del_height: \"\\<lbrakk>k > 0; root_order k t; bal t\\<rbrakk> \\<Longrightarrow> height (del k x t) = height t\"", "lemma rebalance_middle_tree_inorder:\n  assumes \"height t = height sub\"\n    and \"case rs of (rsub,rsep) # list \\<Rightarrow> height rsub = height t | [] \\<Rightarrow> True\"\n  shows \"inorder (rebalance_middle_tree k ls sub sep rs t) = inorder (Node (ls@(sub,sep)#rs) t)\"", "lemma rebalance_last_tree_inorder:\n  assumes \"height t = height sub\"\n    and \"ts = list@[(sub,sep)]\"\n  shows \"inorder (rebalance_last_tree k ts t) = inorder (Node ts t)\"", "lemma butlast_inorder_app_id: \"xs = xs' @ [(sub,sep)] \\<Longrightarrow> inorder_list xs' @ inorder sub @ [sep] = inorder_list xs\"", "lemma split_max_inorder:\n  assumes \"nonempty_lasttreebal t\"\n    and \"t \\<noteq> Leaf\"\n  shows \"inorder_pair (split_max k t) = inorder t\"", "lemma height_bal_subtrees_merge: \"\\<lbrakk>height (Node as a) = height (Node bs b); bal (Node as a); bal (Node bs b)\\<rbrakk>\n \\<Longrightarrow> \\<forall>x \\<in> set (subtrees as) \\<union> {a}. height x = height b\"", "lemma bal_list_merge:\n  assumes \"bal_up\\<^sub>i (Up\\<^sub>i (Node as a) x (Node bs b))\"\n  shows \"bal (Node (as@(a,x)#bs) b)\"", "lemma node\\<^sub>i_bal_up\\<^sub>i:\n  assumes \"bal_up\\<^sub>i (node\\<^sub>i k ts t)\"\n  shows \"bal (Node ts t)\"", "lemma node\\<^sub>i_bal_simp: \"bal_up\\<^sub>i (node\\<^sub>i k ts t) = bal (Node ts t)\"", "lemma rebalance_middle_tree_bal: \"bal (Node (ls@(sub,sep)#rs) t) \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\"", "lemma rebalance_last_tree_bal: \"\\<lbrakk>bal (Node ts t); ts \\<noteq> []\\<rbrakk> \\<Longrightarrow> bal (rebalance_last_tree k ts t)\"", "lemma split_max_bal:\n  assumes \"bal t\"\n    and \"t \\<noteq> Leaf\"\n    and \"nonempty_lasttreebal t\"\n  shows \"bal (fst (split_max k t))\"", "lemma del_bal:\n  assumes \"k > 0\"\n    and \"root_order k t\"\n    and \"bal t\"\n  shows \"bal (del k x t)\"", "lemma rebalance_middle_tree_order:\n  assumes \"almost_order k sub\"\n    and \"\\<forall>s \\<in> set (subtrees (ls@rs)). order k s\" \"order k t\"\n    and \"case rs of (rsub,rsep) # list \\<Rightarrow> height rsub = height t | [] \\<Rightarrow> True\"\n    and \"length (ls@(sub,sep)#rs) \\<le> 2*k\"\n    and \"height sub = height t\"\n  shows \"almost_order k (rebalance_middle_tree k ls sub sep rs t)\"", "lemma rebalance_middle_tree_last_order:\n  assumes \"almost_order k t\"\n    and  \"\\<forall>s \\<in> set (subtrees (ls@(sub,sep)#rs)). order k s\"\n    and \"rs = []\"\n    and \"length (ls@(sub,sep)#rs) \\<le> 2*k\"\n    and \"height sub = height t\"\n  shows \"almost_order k (rebalance_middle_tree k ls sub sep rs t)\"", "lemma rebalance_last_tree_order:\n  assumes \"ts = ls@[(sub,sep)]\"\n    and \"\\<forall>s \\<in> set (subtrees (ts)). order k s\" \"almost_order k t\"\n    and \"length ts \\<le> 2*k\"\n    and \"height sub = height t\"\n  shows \"almost_order k (rebalance_last_tree k ts t)\"", "lemma split_max_order:\n  assumes \"order k t\"\n    and \"t \\<noteq> Leaf\"\n    and \"nonempty_lasttreebal t\"\n  shows \"almost_order k (fst (split_max k t))\"", "lemma del_order:\n  assumes \"k > 0\"\n    and \"root_order k t\"\n    and \"bal t\"\n  shows \"almost_order k (del k x t)\"", "lemma del_list_split:\n  assumes \"split ts x = (ls, rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n  shows \"del_list x (inorder (Node ts t)) = inorder_list ls @ del_list x (inorder_list rs @ inorder t)\"", "lemma del_list_split_right:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n    and \"sep \\<noteq> x\"\n  shows \"del_list x (inorder_list ((sub,sep)#rs) @ inorder t) = del_list x (inorder sub) @ sep # inorder_list rs @ inorder t\"", "lemma del_inorder:\n  assumes \"k > 0\"\n    and \"root_order k t\"\n    and \"bal t\"\n    and \"sorted_less (inorder t)\"\n  shows \"inorder (del k x t) = del_list x (inorder t)\"", "lemma reduce_root_order: \"\\<lbrakk>k > 0; almost_order k t\\<rbrakk> \\<Longrightarrow> root_order k (reduce_root t)\"", "lemma reduce_root_bal: \"bal (reduce_root t) = bal t\"", "lemma reduce_root_inorder: \"inorder (reduce_root t) = inorder t\"", "lemma delete_order: \"\\<lbrakk>k > 0; bal t; root_order k t\\<rbrakk> \\<Longrightarrow> root_order k (delete k x t)\"", "lemma delete_bal: \"\\<lbrakk>k > 0; bal t; root_order k t\\<rbrakk> \\<Longrightarrow> bal (delete k x t)\"", "lemma delete_inorder: \"\\<lbrakk>k > 0; bal t; root_order k t; sorted_less (inorder t)\\<rbrakk> \\<Longrightarrow> inorder (delete k x t) = del_list x (inorder t)\""], "translations": [["", "lemma drop_not_empty: \"xs \\<noteq> [] \\<Longrightarrow> drop (length xs div 2) xs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> drop (length xs div 2) xs \\<noteq> []", "apply(induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> drop (length [] div 2) [] \\<noteq> []\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow>\n                drop (length xs div 2) xs \\<noteq> [];\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> drop (length (a # xs) div 2) (a # xs) \\<noteq> []", "apply(auto split!: list.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma split_half_not_empty: \"length xs \\<ge> 1 \\<Longrightarrow> \\<exists>ls sub sep rs. split_half xs = (ls,(sub,sep)#rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs)", "using drop_not_empty"], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> drop (length ?xs div 2) ?xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. 1 \\<le> length xs \\<Longrightarrow>\n    \\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs)", "by (metis (no_types, hide_lams) drop0 drop_eq_Nil eq_snd_iff hd_Cons_tl le_trans not_one_le_zero split_half.simps)"], ["", "subsection \"The split function locale\""], ["", "text \"Here, we abstract away the inner workings of the split function\n      for B-tree operations.\""], ["", "(* TODO what if we define a function \"list_split\" that returns\n a split list for mapping arbitrary f (separators) and g (subtrees)\ns.th. f :: 'a \\<Rightarrow> ('b::linorder) and g :: 'a \\<Rightarrow> 'a btree\nthis would allow for key,pointer pairs to be inserted into the tree *)\n(* TODO what if the keys are the pointers? *)"], ["", "locale split =\n  fixes split ::  \"('a btree\\<times>'a::linorder) list \\<Rightarrow> 'a \\<Rightarrow> (('a btree\\<times>'a) list \\<times> ('a btree\\<times>'a) list)\"\n  assumes split_req:\n    \"\\<lbrakk>split xs p = (ls,rs)\\<rbrakk> \\<Longrightarrow> xs = ls @ rs\"\n    \"\\<lbrakk>split xs p = (ls@[(sub,sep)],rs); sorted_less (separators xs)\\<rbrakk> \\<Longrightarrow> sep < p\"\n    \"\\<lbrakk>split xs p = (ls,(sub,sep)#rs); sorted_less (separators xs)\\<rbrakk> \\<Longrightarrow> p \\<le> sep\"\nbegin"], ["", "lemmas split_conc = split_req(1)"], ["", "lemmas split_sorted = split_req(2,3)"], ["", "lemma [termination_simp]:\"(ls, (sub, sep) # rs) = split ts y \\<Longrightarrow>\n      size sub < Suc (size_list (\\<lambda>x. Suc (size (fst x))) ts  + size l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ls, (sub, sep) # rs) = split ts y \\<Longrightarrow>\n    size sub < Suc (size_list (\\<lambda>x. Suc (size (fst x))) ts + size l)", "using split_conc[of ts y ls \"(sub,sep)#rs\"]"], ["proof (prove)\nusing this:\n  split ts y = (ls, (sub, sep) # rs) \\<Longrightarrow>\n  ts = ls @ (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. (ls, (sub, sep) # rs) = split ts y \\<Longrightarrow>\n    size sub < Suc (size_list (\\<lambda>x. Suc (size (fst x))) ts + size l)", "by auto"], ["", "fun invar_inorder where \"invar_inorder k t = (bal t \\<and> root_order k t)\""], ["", "definition \"empty_btree = Leaf\""], ["", "subsection \"Membership\""], ["", "fun isin:: \"'a btree \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"isin (Leaf) y = False\" |\n  \"isin (Node ts t) y = (\n      case split ts y of (_,(sub,sep)#rs) \\<Rightarrow> (\n          if y = sep then\n             True\n          else\n             isin sub y\n      )\n   | (_,[]) \\<Rightarrow> isin t y\n  )\""], ["", "subsection \"Insertion\""], ["", "text \"The insert function requires an auxiliary data structure\nand auxiliary invariant functions.\""], ["", "datatype 'b up\\<^sub>i = T\\<^sub>i \"'b btree\" | Up\\<^sub>i \"'b btree\" 'b \"'b btree\""], ["", "fun order_up\\<^sub>i where\n  \"order_up\\<^sub>i k (T\\<^sub>i sub) = order k sub\" |\n  \"order_up\\<^sub>i k (Up\\<^sub>i l a r) = (order k l \\<and> order k r)\""], ["", "fun root_order_up\\<^sub>i where\n  \"root_order_up\\<^sub>i k (T\\<^sub>i sub) = root_order k sub\" |\n  \"root_order_up\\<^sub>i k (Up\\<^sub>i l a r) = (order k l \\<and> order k r)\""], ["", "fun height_up\\<^sub>i where\n  \"height_up\\<^sub>i (T\\<^sub>i t) = height t\" |\n  \"height_up\\<^sub>i (Up\\<^sub>i l a r) = max (height l) (height r)\""], ["", "fun bal_up\\<^sub>i where\n  \"bal_up\\<^sub>i (T\\<^sub>i t) = bal t\" |\n  \"bal_up\\<^sub>i (Up\\<^sub>i l a r) = (height l = height r \\<and> bal l \\<and> bal r)\""], ["", "fun inorder_up\\<^sub>i where\n  \"inorder_up\\<^sub>i (T\\<^sub>i t) = inorder t\" |\n  \"inorder_up\\<^sub>i (Up\\<^sub>i l a r) = inorder l @ [a] @ inorder r\""], ["", "text \"The following function merges two nodes and returns separately split nodes\n   if an overflow occurs\""], ["", "fun node\\<^sub>i:: \"nat \\<Rightarrow> ('a btree \\<times> 'a) list \\<Rightarrow> 'a btree \\<Rightarrow> 'a up\\<^sub>i\" where\n  \"node\\<^sub>i k ts t = (\n  if length ts \\<le> 2*k then T\\<^sub>i (Node ts t)\n  else (\n    case split_half ts of (ls, (sub,sep)#rs) \\<Rightarrow>\n      Up\\<^sub>i (Node ls sub) sep (Node rs t)\n    )\n  )\""], ["", "fun ins:: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a btree \\<Rightarrow> 'a up\\<^sub>i\" where\n  \"ins k x Leaf = (Up\\<^sub>i Leaf x Leaf)\" |\n  \"ins k x (Node ts t) = (\n  case split ts x of\n    (ls,(sub,sep)#rs) \\<Rightarrow>\n      (if sep = x then\n        T\\<^sub>i (Node ts t)\n      else\n        (case ins k x sub of\n          Up\\<^sub>i l a r \\<Rightarrow>\n             node\\<^sub>i k (ls @ (l,a)#(r,sep)#rs) t |\n          T\\<^sub>i a \\<Rightarrow>\n            T\\<^sub>i (Node (ls @ (a,sep) # rs) t))) |\n    (ls, []) \\<Rightarrow>\n      (case ins k x t of\n         Up\\<^sub>i l a r \\<Rightarrow>\n           node\\<^sub>i k (ls@[(l,a)]) r |\n         T\\<^sub>i a \\<Rightarrow>\n           T\\<^sub>i (Node ls a)\n  )\n)\""], ["", "fun tree\\<^sub>i::\"'a up\\<^sub>i \\<Rightarrow> 'a btree\" where\n  \"tree\\<^sub>i (T\\<^sub>i sub) = sub\" |\n  \"tree\\<^sub>i (Up\\<^sub>i l a r) = (Node [(l,a)] r)\""], ["", "fun insert::\"nat \\<Rightarrow> 'a \\<Rightarrow> 'a btree \\<Rightarrow> 'a btree\" where\n  \"insert k x t = tree\\<^sub>i (ins k x t)\""], ["", "subsection \"Deletion\""], ["", "text \"The following deletion method is inspired by Bayer (70) and Fielding (??).\nRather than stealing only a single node from the neighbour,\nthe neighbour is fully merged with the potentially underflowing node.\nIf the resulting node is still larger than allowed, the merged node is split\nagain, using the rules known from insertion splits.\nIf the resulting node has admissable size, it is simply kept in the tree.\""], ["", "fun rebalance_middle_tree where\n  \"rebalance_middle_tree k ls Leaf sep rs Leaf = (\n  Node (ls@(Leaf,sep)#rs) Leaf\n)\" |\n  \"rebalance_middle_tree k ls (Node mts mt) sep rs (Node tts tt) = (\n  if length mts \\<ge> k \\<and> length tts \\<ge> k then\n    Node (ls@(Node mts mt,sep)#rs) (Node tts tt)\n  else (\n    case rs of [] \\<Rightarrow> (\n      case node\\<^sub>i k (mts@(mt,sep)#tts) tt of\n       T\\<^sub>i u \\<Rightarrow>\n        Node ls u |\n       Up\\<^sub>i l a r \\<Rightarrow>\n        Node (ls@[(l,a)]) r) |\n    (Node rts rt,rsep)#rs \\<Rightarrow> (\n      case node\\<^sub>i k (mts@(mt,sep)#rts) rt of\n      T\\<^sub>i u \\<Rightarrow>\n        Node (ls@(u,rsep)#rs) (Node tts tt) |\n      Up\\<^sub>i l a r \\<Rightarrow>\n        Node (ls@(l,a)#(r,rsep)#rs) (Node tts tt))\n))\""], ["", "text \"Deletion\""], ["", "text \"All trees are merged with the right neighbour on underflow.\nObviously for the last tree this would not work since it has no right neighbour.\nTherefore this tree, as the only exception, is merged with the left neighbour.\nHowever since we it does not make a difference, we treat the situation\nas if the second to last tree underflowed.\""], ["", "fun rebalance_last_tree where\n  \"rebalance_last_tree k ts t = (\ncase last ts of (sub,sep) \\<Rightarrow>\n   rebalance_middle_tree k (butlast ts) sub sep [] t\n)\""], ["", "text \"Rather than deleting the minimal key from the right subtree,\nwe remove the maximal key of the left subtree.\nThis is due to the fact that the last tree can easily be accessed\nand the left neighbour is way easier to access than the right neighbour,\nit resides in the same pair as the separating element to be removed.\""], ["", "fun split_max where\n  \"split_max k (Node ts t) = (case t of Leaf \\<Rightarrow> (\n  let (sub,sep) = last ts in\n    (Node (butlast ts) sub, sep)\n)|\n_ \\<Rightarrow>\ncase split_max k t of (sub, sep) \\<Rightarrow>\n  (rebalance_last_tree k ts sub, sep)\n)\""], ["", "fun del where\n  \"del k x Leaf = Leaf\" |\n  \"del k x (Node ts t) = (\n  case split ts x of\n    (ls,[]) \\<Rightarrow>\n     rebalance_last_tree k ls (del k x t)\n  | (ls,(sub,sep)#rs) \\<Rightarrow> (\n      if sep \\<noteq> x then\n        rebalance_middle_tree k ls (del k x sub) sep rs t\n      else if sub = Leaf then\n        Node (ls@rs) t\n      else let (sub_s, max_s) = split_max k sub in\n        rebalance_middle_tree k ls sub_s max_s rs t\n  )\n)\""], ["", "fun reduce_root where\n  \"reduce_root Leaf = Leaf\" |\n  \"reduce_root (Node ts t) = (case ts of\n   [] \\<Rightarrow> t |\n   _ \\<Rightarrow> (Node ts t)\n)\""], ["", "fun delete where \"delete k x t = reduce_root (del k x t)\""], ["", "text \"An invariant for intermediate states at deletion.\nIn particular we allow for an underflow to 0 subtrees.\""], ["", "fun almost_order where\n  \"almost_order k Leaf = True\" |\n  \"almost_order k (Node ts t) = (\n  (length ts \\<le> 2*k) \\<and>\n  (\\<forall>s \\<in> set (subtrees ts). order k s) \\<and>\n   order k t\n)\""], ["", "text \"A recursive property of the \\\"spine\\\" we want to walk along for splitting\n    off the maximum of the left subtree.\""], ["", "fun nonempty_lasttreebal where\n  \"nonempty_lasttreebal Leaf = True\" |\n  \"nonempty_lasttreebal (Node ts t) = (\n    (\\<exists>ls tsub tsep. ts = (ls@[(tsub,tsep)]) \\<and> height tsub = height t) \\<and>\n     nonempty_lasttreebal t\n  )\""], ["", "subsection \"Proofs of functional correctness\""], ["", "lemma split_set:\n  assumes \"split ts z = (ls,(a,b)#rs)\"\n  shows \"(a,b) \\<in> set ts\"\n    and \"(x,y) \\<in> set ls \\<Longrightarrow> (x,y) \\<in> set ts\"\n    and \"(x,y) \\<in> set rs \\<Longrightarrow> (x,y) \\<in> set ts\"\n    and \"set ls \\<union> set rs \\<union> {(a,b)} = set ts\"\n    and \"\\<exists>x \\<in> set ts. b \\<in> Basic_BNFs.snds x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a, b) \\<in> set ts &&&\n     ((x, y) \\<in> set ls \\<Longrightarrow> (x, y) \\<in> set ts)) &&&\n    ((x, y) \\<in> set rs \\<Longrightarrow> (x, y) \\<in> set ts) &&&\n    set ls \\<union> set rs \\<union> {(a, b)} = set ts &&&\n    \\<exists>x\\<in>set ts. b \\<in> Basic_BNFs.snds x", "using split_conc assms"], ["proof (prove)\nusing this:\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n  split ts z = (ls, (a, b) # rs)\n\ngoal (1 subgoal):\n 1. ((a, b) \\<in> set ts &&&\n     ((x, y) \\<in> set ls \\<Longrightarrow> (x, y) \\<in> set ts)) &&&\n    ((x, y) \\<in> set rs \\<Longrightarrow> (x, y) \\<in> set ts) &&&\n    set ls \\<union> set rs \\<union> {(a, b)} = set ts &&&\n    \\<exists>x\\<in>set ts. b \\<in> Basic_BNFs.snds x", "by fastforce+"], ["", "lemma split_length:\n  \"split ts x = (ls, rs) \\<Longrightarrow> length ls + length rs = length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split ts x = (ls, rs) \\<Longrightarrow>\n    length ls + length rs = length ts", "by (auto dest: split_conc)"], ["", "text \"Isin proof\""], ["", "thm isin_simps"], ["", "(* copied from comment in List_Ins_Del *)"], ["", "lemma sorted_ConsD: \"sorted_less (y # xs) \\<Longrightarrow> x \\<le> y \\<Longrightarrow> x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (y # xs); x \\<le> y\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set xs", "by (auto simp: sorted_Cons_iff)"], ["", "lemma sorted_snocD: \"sorted_less (xs @ [y]) \\<Longrightarrow> y \\<le> x \\<Longrightarrow> x \\<notin> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (xs @ [y]); y \\<le> x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> set xs", "by (auto simp: sorted_snoc_iff)"], ["", "lemmas isin_simps2 = sorted_lems sorted_ConsD sorted_snocD"], ["", "(*-----------------------------*)"], ["", "lemma isin_sorted: \"sorted_less (xs@a#ys) \\<Longrightarrow>\n  (x \\<in> set (xs@a#ys)) = (if x < a then x \\<in> set xs else x \\<in> set (a#ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (xs @ a # ys) \\<Longrightarrow>\n    (x \\<in> set (xs @ a # ys)) =\n    (if x < a then x \\<in> set xs else x \\<in> set (a # ys))", "by (auto simp: isin_simps2)"], ["", "(* lift to split *)"], ["", "lemma isin_sorted_split:\n  assumes \"sorted_less (inorder (Node ts t))\"\n    and \"split ts x = (ls, rs)\"\n  shows \"x \\<in> set (inorder (Node ts t)) = (x \\<in> set (inorder_list rs @ inorder t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))", "proof (cases ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "case Nil"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "then"], ["proof (chain)\npicking this:\n  ls = []", "have \"ts = rs\""], ["proof (prove)\nusing this:\n  ls = []\n\ngoal (1 subgoal):\n 1. ts = rs", "using assms"], ["proof (prove)\nusing this:\n  ls = []\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ts = rs", "by (auto dest!: split_conc)"], ["proof (state)\nthis:\n  ts = rs\n\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "then"], ["proof (chain)\npicking this:\n  ts = rs", "show ?thesis"], ["proof (prove)\nusing this:\n  ts = rs\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))", "by simp"], ["proof (state)\nthis:\n  (x \\<in> set (inorder (Node ts t))) =\n  (x \\<in> set (inorder_list rs @ inorder t))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "case Cons"], ["proof (state)\nthis:\n  ls = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "then"], ["proof (chain)\npicking this:\n  ls = a_ # list_", "obtain ls' sub sep where ls_tail_split: \"ls = ls' @ [(sub,sep)]\""], ["proof (prove)\nusing this:\n  ls = a_ # list_\n\ngoal (1 subgoal):\n 1. (\\<And>ls' sub sep.\n        ls = ls' @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.simps(3) rev_exhaust surj_pair)"], ["proof (state)\nthis:\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "then"], ["proof (chain)\npicking this:\n  ls = ls' @ [(sub, sep)]", "have \"sep < x\""], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. sep < x", "using split_req(2)[of ts x ls' sub sep rs]"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n\ngoal (1 subgoal):\n 1. sep < x", "using sorted_inorder_separators[OF assms(1)]"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. sep < x", "using assms"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n  sorted_less (separators ts)\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. sep < x", "by simp"], ["proof (state)\nthis:\n  sep < x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       (x \\<in> set (inorder (Node ts t))) =\n       (x \\<in> set (inorder_list rs @ inorder t))", "then"], ["proof (chain)\npicking this:\n  sep < x", "show ?thesis"], ["proof (prove)\nusing this:\n  sep < x\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))", "using assms(1) split_conc[OF assms(2)] ls_tail_split"], ["proof (prove)\nusing this:\n  sep < x\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))", "using isin_sorted[of \"inorder_list ls' @ inorder sub\" sep \"inorder_list rs @ inorder t\" x]"], ["proof (prove)\nusing this:\n  sep < x\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n  ls = ls' @ [(sub, sep)]\n  sorted_less\n   ((inorder_list ls' @ inorder sub) @\n    sep # inorder_list rs @ inorder t) \\<Longrightarrow>\n  (x \\<in> set ((inorder_list ls' @ inorder sub) @\n                sep # inorder_list rs @ inorder t)) =\n  (if x < sep then x \\<in> set (inorder_list ls' @ inorder sub)\n   else x \\<in> set (sep # inorder_list rs @ inorder t))\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder (Node ts t))) =\n    (x \\<in> set (inorder_list rs @ inorder t))", "by auto"], ["proof (state)\nthis:\n  (x \\<in> set (inorder (Node ts t))) =\n  (x \\<in> set (inorder_list rs @ inorder t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isin_sorted_split_right:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n    and \"sep \\<noteq> x\"\n  shows \"x \\<in> set (inorder_list ((sub,sep)#rs) @ inorder t) = (x \\<in> set (inorder sub))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "from assms"], ["proof (chain)\npicking this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x", "have \"x < sep\""], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < sep", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n     sorted_less (inorder (Node ts t)); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x < sep", "from assms"], ["proof (chain)\npicking this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x", "have \"sorted_less (separators ts)\""], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. sorted_less (separators ts)", "by (simp add: sorted_inorder_separators)"], ["proof (state)\nthis:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n     sorted_less (inorder (Node ts t)); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x < sep", "then"], ["proof (chain)\npicking this:\n  sorted_less (separators ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. x < sep", "using split_req(3)"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n  \\<lbrakk>split ?xs ?p = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (separators ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?sep\n\ngoal (1 subgoal):\n 1. x < sep", "using assms"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n  \\<lbrakk>split ?xs ?p = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (separators ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?sep\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < sep", "by fastforce"], ["proof (state)\nthis:\n  x < sep\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < sep\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "moreover"], ["proof (state)\nthis:\n  x < sep\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "have \"sorted_less (inorder_list ((sub,sep)#rs) @ inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder_list ((sub, sep) # rs) @ inorder t)", "using assms sorted_wrt_append split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n  sorted_wrt ?P (?xs @ ?ys) =\n  (sorted_wrt ?P ?xs \\<and>\n   sorted_wrt ?P ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. ?P x y))\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. sorted_less (inorder_list ((sub, sep) # rs) @ inorder t)", "by fastforce"], ["proof (state)\nthis:\n  sorted_less (inorder_list ((sub, sep) # rs) @ inorder t)\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "ultimately"], ["proof (chain)\npicking this:\n  x < sep\n  sorted_less (inorder_list ((sub, sep) # rs) @ inorder t)", "show ?thesis"], ["proof (prove)\nusing this:\n  x < sep\n  sorted_less (inorder_list ((sub, sep) # rs) @ inorder t)\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "using isin_sorted[of \"inorder sub\" \"sep\" \"inorder_list rs @ inorder t\" x]"], ["proof (prove)\nusing this:\n  x < sep\n  sorted_less (inorder_list ((sub, sep) # rs) @ inorder t)\n  sorted_less\n   (inorder sub @ sep # inorder_list rs @ inorder t) \\<Longrightarrow>\n  (x \\<in> set (inorder sub @ sep # inorder_list rs @ inorder t)) =\n  (if x < sep then x \\<in> set (inorder sub)\n   else x \\<in> set (sep # inorder_list rs @ inorder t))\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n    (x \\<in> set (inorder sub))", "by simp"], ["proof (state)\nthis:\n  (x \\<in> set (inorder_list ((sub, sep) # rs) @ inorder t)) =\n  (x \\<in> set (inorder sub))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem isin_set_inorder: \"sorted_less (inorder t) \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    isin t x = (x \\<in> set (inorder t))", "proof(induction t x rule: isin.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       isin Leaf y = (y \\<in> set (inorder Leaf))\n 2. \\<And>ts t y.\n       \\<lbrakk>\\<And>x ya.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> isin t y = (y \\<in> set (inorder t));\n        \\<And>x ya x21 x22 xa yaa.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> isin xa y = (y \\<in> set (inorder xa));\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> isin (Node ts t) y =\n                         (y \\<in> set (inorder (Node ts t)))", "case (2 ts t x)"], ["proof (state)\nthis:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> isin ?xa x = (x \\<in> set (inorder ?xa))\n  sorted_less (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       isin Leaf y = (y \\<in> set (inorder Leaf))\n 2. \\<And>ts t y.\n       \\<lbrakk>\\<And>x ya.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> isin t y = (y \\<in> set (inorder t));\n        \\<And>x ya x21 x22 xa yaa.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> isin xa y = (y \\<in> set (inorder xa));\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> isin (Node ts t) y =\n                         (y \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> isin ?xa x = (x \\<in> set (inorder ?xa))\n  sorted_less (inorder (Node ts t))", "obtain ls rs where list_split: \"split ts x = (ls, rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> isin ?xa x = (x \\<in> set (inorder ?xa))\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       isin Leaf y = (y \\<in> set (inorder Leaf))\n 2. \\<And>ts t y.\n       \\<lbrakk>\\<And>x ya.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> isin t y = (y \\<in> set (inorder t));\n        \\<And>x ya x21 x22 xa yaa.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> isin xa y = (y \\<in> set (inorder xa));\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> isin (Node ts t) y =\n                         (y \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have list_conc: \"ts = ls @ rs\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ts = ls @ rs", "using split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. ts = ls @ rs", "by auto"], ["proof (state)\nthis:\n  ts = ls @ rs\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       isin Leaf y = (y \\<in> set (inorder Leaf))\n 2. \\<And>ts t y.\n       \\<lbrakk>\\<And>x ya.\n                   \\<lbrakk>(x, ya) = split ts y; ya = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> isin t y = (y \\<in> set (inorder t));\n        \\<And>x ya x21 x22 xa yaa.\n           \\<lbrakk>(x, ya) = split ts y; ya = x21 # x22; (xa, yaa) = x21;\n            y \\<noteq> yaa; sorted_less (inorder xa)\\<rbrakk>\n           \\<Longrightarrow> isin xa y = (y \\<in> set (inorder xa));\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> isin (Node ts t) y =\n                         (y \\<in> set (inorder (Node ts t)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  rs = []", "have \"isin (Node ts t) x = isin t x\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = isin t x", "by (simp add: list_split)"], ["proof (state)\nthis:\n  isin (Node ts t) x = isin t x\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "also"], ["proof (state)\nthis:\n  isin (Node ts t) x = isin t x\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "have \"\\<dots> = (x \\<in> set (inorder t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isin t x = (x \\<in> set (inorder t))", "using \"2.IH\"(1) list_split Nil"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\n  split ts x = (ls, rs)\n  rs = []\n\ngoal (1 subgoal):\n 1. isin t x = (x \\<in> set (inorder t))", "using \"2.prems\" sorted_inorder_induct_last"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = [];\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> isin t x = (x \\<in> set (inorder t))\n  split ts x = (ls, rs)\n  rs = []\n  sorted_less (inorder (Node ts t))\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?t)\n\ngoal (1 subgoal):\n 1. isin t x = (x \\<in> set (inorder t))", "by auto"], ["proof (state)\nthis:\n  isin t x = (x \\<in> set (inorder t))\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "also"], ["proof (state)\nthis:\n  isin t x = (x \\<in> set (inorder t))\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "have \"\\<dots> = (x \\<in> set (inorder (Node ts t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder t)) = (x \\<in> set (inorder (Node ts t)))", "using isin_sorted_split[of ts t x ls rs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_less (inorder (Node ts t)); split ts x = (ls, rs)\\<rbrakk>\n  \\<Longrightarrow> (x \\<in> set (inorder (Node ts t))) =\n                    (x \\<in> set (inorder_list rs @ inorder t))\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder t)) = (x \\<in> set (inorder (Node ts t)))", "using \"2.prems\" list_split list_conc Nil"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_less (inorder (Node ts t)); split ts x = (ls, rs)\\<rbrakk>\n  \\<Longrightarrow> (x \\<in> set (inorder (Node ts t))) =\n                    (x \\<in> set (inorder_list rs @ inorder t))\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  ts = ls @ rs\n  rs = []\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder t)) = (x \\<in> set (inorder (Node ts t)))", "by simp"], ["proof (state)\nthis:\n  (x \\<in> set (inorder t)) = (x \\<in> set (inorder (Node ts t)))\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "finally"], ["proof (chain)\npicking this:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "show ?thesis"], ["proof (prove)\nusing this:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "."], ["proof (state)\nthis:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "case (Cons a list)"], ["proof (state)\nthis:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  rs = a # list", "obtain sub sep where a_split: \"a = (sub,sep)\""], ["proof (prove)\nusing this:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  a = (sub, sep)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "proof (cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  x = sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "using list_conc Cons a_split list_split"], ["proof (prove)\nusing this:\n  x = sep\n  ts = ls @ rs\n  rs = a # list\n  a = (sub, sep)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "by auto"], ["proof (state)\nthis:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "have \"isin (Node ts t) x = isin sub x\""], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = isin sub x", "using list_split Cons a_split False"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n  split ts x = (ls, rs)\n  rs = a # list\n  a = (sub, sep)\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = isin sub x", "by auto"], ["proof (state)\nthis:\n  isin (Node ts t) x = isin sub x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "also"], ["proof (state)\nthis:\n  isin (Node ts t) x = isin sub x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "have \"\\<dots> = (x \\<in> set (inorder sub))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isin sub x = (x \\<in> set (inorder sub))", "using \"2.IH\"(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> isin ?xa x = (x \\<in> set (inorder ?xa))\n\ngoal (1 subgoal):\n 1. isin sub x = (x \\<in> set (inorder sub))", "using \"2.prems\" False a_split list_conc list_split local.Cons sorted_inorder_induct_subtree"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?ya) = split ts x; ?ya = ?x21.0 # ?x22.0;\n   (?xa, ?yaa) = ?x21.0; x \\<noteq> ?yaa; sorted_less (inorder ?xa)\\<rbrakk>\n  \\<Longrightarrow> isin ?xa x = (x \\<in> set (inorder ?xa))\n  sorted_less (inorder (Node ts t))\n  x \\<noteq> sep\n  a = (sub, sep)\n  ts = ls @ rs\n  split ts x = (ls, rs)\n  rs = a # list\n  sorted_less\n   (inorder (Node (?ls @ (?sub, ?sep) # ?rs) ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?sub)\n\ngoal (1 subgoal):\n 1. isin sub x = (x \\<in> set (inorder sub))", "by fastforce"], ["proof (state)\nthis:\n  isin sub x = (x \\<in> set (inorder sub))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "also"], ["proof (state)\nthis:\n  isin sub x = (x \\<in> set (inorder sub))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "have \"\\<dots> = (x \\<in> set (inorder (Node ts t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder sub)) = (x \\<in> set (inorder (Node ts t)))", "using isin_sorted_split[OF \"2.prems\" list_split]"], ["proof (prove)\nusing this:\n  (x \\<in> set (inorder (Node ts t))) =\n  (x \\<in> set (inorder_list rs @ inorder t))\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder sub)) = (x \\<in> set (inorder (Node ts t)))", "using isin_sorted_split_right \"2.prems\" list_split Cons a_split False"], ["proof (prove)\nusing this:\n  (x \\<in> set (inorder (Node ts t))) =\n  (x \\<in> set (inorder_list rs @ inorder t))\n  \\<lbrakk>split ?ts ?x = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (inorder (Node ?ts ?t)); ?sep \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> (?x \\<in> set (inorder_list ((?sub, ?sep) # ?rs) @\n                                   inorder ?t)) =\n                    (?x \\<in> set (inorder ?sub))\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  rs = a # list\n  a = (sub, sep)\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. (x \\<in> set (inorder sub)) = (x \\<in> set (inorder (Node ts t)))", "by simp"], ["proof (state)\nthis:\n  (x \\<in> set (inorder sub)) = (x \\<in> set (inorder (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> isin (Node ts t) x =\n                      (x \\<in> set (inorder (Node ts t)))", "finally"], ["proof (chain)\npicking this:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "show ?thesis"], ["proof (prove)\nusing this:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal (1 subgoal):\n 1. isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))", "."], ["proof (state)\nthis:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isin (Node ts t) x = (x \\<in> set (inorder (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       isin Leaf y = (y \\<in> set (inorder Leaf))", "qed auto"], ["", "(* TODO way to use this for custom case distinction? *)"], ["", "lemma node\\<^sub>i_cases: \"length xs \\<le> k \\<or> (\\<exists>ls sub sep rs. split_half xs = (ls,(sub,sep)#rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> k \\<or>\n    (\\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length xs \\<le> k \\<or>\n    (\\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs))", "have \"\\<not> length xs \\<le> k \\<Longrightarrow> length xs \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> length xs \\<le> k \\<Longrightarrow> 1 \\<le> length xs", "by linarith"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> k \\<Longrightarrow> 1 \\<le> length xs\n\ngoal (1 subgoal):\n 1. length xs \\<le> k \\<or>\n    (\\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs))", "then"], ["proof (chain)\npicking this:\n  \\<not> length xs \\<le> k \\<Longrightarrow> 1 \\<le> length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> k \\<Longrightarrow> 1 \\<le> length xs\n\ngoal (1 subgoal):\n 1. length xs \\<le> k \\<or>\n    (\\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs))", "using split_half_not_empty"], ["proof (prove)\nusing this:\n  \\<not> length xs \\<le> k \\<Longrightarrow> 1 \\<le> length xs\n  1 \\<le> length ?xs \\<Longrightarrow>\n  \\<exists>ls sub sep rs. split_half ?xs = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. length xs \\<le> k \\<or>\n    (\\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs))", "by blast"], ["proof (state)\nthis:\n  length xs \\<le> k \\<or>\n  (\\<exists>ls sub sep rs. split_half xs = (ls, (sub, sep) # rs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma root_order_tree\\<^sub>i: \"root_order_up\\<^sub>i (Suc k) t = root_order (Suc k) (tree\\<^sub>i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i (Suc k) t = root_order (Suc k) (tree\\<^sub>i t)", "apply (cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = T\\<^sub>i x1 \\<Longrightarrow>\n       root_order_up\\<^sub>i (Suc k) t = root_order (Suc k) (tree\\<^sub>i t)\n 2. \\<And>x21 x22 x23.\n       t = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       root_order_up\\<^sub>i (Suc k) t = root_order (Suc k) (tree\\<^sub>i t)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma node\\<^sub>i_root_order:\n  assumes \"length ts > 0\"\n    and \"length ts \\<le> 4*k+1\"\n    and \"\\<forall>x \\<in> set (subtrees ts). order k x\"\n    and \"order k t\"\n  shows \"root_order_up\\<^sub>i k (node\\<^sub>i k ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "proof (cases \"length ts \\<le> 2*k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "case True"], ["proof (state)\nthis:\n  length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "then"], ["proof (chain)\npicking this:\n  length ts \\<le> 2 * k", "show ?thesis"], ["proof (prove)\nusing this:\n  length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "using assms"], ["proof (prove)\nusing this:\n  length ts \\<le> 2 * k\n  0 < length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "by (simp add: node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (node\\<^sub>i k ts t)\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "case False"], ["proof (state)\nthis:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "then"], ["proof (chain)\npicking this:\n  \\<not> length ts \\<le> 2 * k", "obtain ls sub sep rs where split_half_ts:\n    \"take (length ts div 2) ts = ls\"\n    \"drop (length ts div 2) ts = (sub,sep)#rs\""], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        \\<lbrakk>take (length ts div 2) ts = ls;\n         drop (length ts div 2) ts = (sub, sep) # rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_half_not_empty[of ts]"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n  1 \\<le> length ts \\<Longrightarrow>\n  \\<exists>ls sub sep rs. split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        \\<lbrakk>take (length ts div 2) ts = ls;\n         drop (length ts div 2) ts = (sub, sep) # rs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "then"], ["proof (chain)\npicking this:\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs", "have length_rs: \"length rs = length ts - (length ts div 2) - 1\""], ["proof (prove)\nusing this:\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. length rs = length ts - length ts div 2 - 1", "using length_drop"], ["proof (prove)\nusing this:\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n  length (drop ?n ?xs) = length ?xs - ?n\n\ngoal (1 subgoal):\n 1. length rs = length ts - length ts div 2 - 1", "by (metis One_nat_def add_diff_cancel_right' list.size(4))"], ["proof (state)\nthis:\n  length rs = length ts - length ts div 2 - 1\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "also"], ["proof (state)\nthis:\n  length rs = length ts - length ts div 2 - 1\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "have \"\\<dots> \\<le> 4*k - ((4*k + 1) div 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts - length ts div 2 - 1 \\<le> 4 * k - (4 * k + 1) div 2", "using assms(2)"], ["proof (prove)\nusing this:\n  length ts \\<le> 4 * k + 1\n\ngoal (1 subgoal):\n 1. length ts - length ts div 2 - 1 \\<le> 4 * k - (4 * k + 1) div 2", "by simp"], ["proof (state)\nthis:\n  length ts - length ts div 2 - 1 \\<le> 4 * k - (4 * k + 1) div 2\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "also"], ["proof (state)\nthis:\n  length ts - length ts div 2 - 1 \\<le> 4 * k - (4 * k + 1) div 2\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "have \"\\<dots> = 2*k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * k - (4 * k + 1) div 2 = 2 * k", "by auto"], ["proof (state)\nthis:\n  4 * k - (4 * k + 1) div 2 = 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "finally"], ["proof (chain)\npicking this:\n  length rs \\<le> 2 * k", "have \"length rs \\<le> 2*k\""], ["proof (prove)\nusing this:\n  length rs \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. length rs \\<le> 2 * k", "by simp"], ["proof (state)\nthis:\n  length rs \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "moreover"], ["proof (state)\nthis:\n  length rs \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "have \"length rs \\<ge> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length rs", "using False length_rs"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n  length rs = length ts - length ts div 2 - 1\n\ngoal (1 subgoal):\n 1. k \\<le> length rs", "by simp"], ["proof (state)\nthis:\n  k \\<le> length rs\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "moreover"], ["proof (state)\nthis:\n  k \\<le> length rs\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "have \"set ((sub,sep)#rs) \\<subseteq> set ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ((sub, sep) # rs) \\<subseteq> set ts", "by (metis split_half_ts(2) set_drop_subset)"], ["proof (state)\nthis:\n  set ((sub, sep) # rs) \\<subseteq> set ts\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "ultimately"], ["proof (chain)\npicking this:\n  length rs \\<le> 2 * k\n  k \\<le> length rs\n  set ((sub, sep) # rs) \\<subseteq> set ts", "have o_r: \"order k sub\" \"order k (Node rs t)\""], ["proof (prove)\nusing this:\n  length rs \\<le> 2 * k\n  k \\<le> length rs\n  set ((sub, sep) # rs) \\<subseteq> set ts\n\ngoal (1 subgoal):\n 1. order k sub &&& order k (Node rs t)", "using split_half_ts assms"], ["proof (prove)\nusing this:\n  length rs \\<le> 2 * k\n  k \\<le> length rs\n  set ((sub, sep) # rs) \\<subseteq> set ts\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n  0 < length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n\ngoal (1 subgoal):\n 1. order k sub &&& order k (Node rs t)", "by auto"], ["proof (state)\nthis:\n  order k sub\n  order k (Node rs t)\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "moreover"], ["proof (state)\nthis:\n  order k sub\n  order k (Node rs t)\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "have \"length ls \\<ge> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<le> length ls", "using length_take assms split_half_ts False"], ["proof (prove)\nusing this:\n  length (take ?n ?xs) = min (length ?xs) ?n\n  0 < length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. k \\<le> length ls", "by auto"], ["proof (state)\nthis:\n  k \\<le> length ls\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "moreover"], ["proof (state)\nthis:\n  k \\<le> length ls\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "have  \"length ls \\<le> 2*k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ls \\<le> 2 * k", "using assms(2) split_half_ts"], ["proof (prove)\nusing this:\n  length ts \\<le> 4 * k + 1\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. length ls \\<le> 2 * k", "by auto"], ["proof (state)\nthis:\n  length ls \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "ultimately"], ["proof (chain)\npicking this:\n  order k sub\n  order k (Node rs t)\n  k \\<le> length ls\n  length ls \\<le> 2 * k", "have o_l: \"order k (Node ls sub)\""], ["proof (prove)\nusing this:\n  order k sub\n  order k (Node rs t)\n  k \\<le> length ls\n  length ls \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. order k (Node ls sub)", "using set_take_subset assms split_half_ts"], ["proof (prove)\nusing this:\n  order k sub\n  order k (Node rs t)\n  k \\<le> length ls\n  length ls \\<le> 2 * k\n  set (take ?n ?xs) \\<subseteq> set ?xs\n  0 < length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n  take (length ts div 2) ts = ls\n  drop (length ts div 2) ts = (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. order k (Node ls sub)", "by fastforce"], ["proof (state)\nthis:\n  order k (Node ls sub)\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "from o_r o_l"], ["proof (chain)\npicking this:\n  order k sub\n  order k (Node rs t)\n  order k (Node ls sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  order k sub\n  order k (Node rs t)\n  order k (Node ls sub)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (node\\<^sub>i k ts t)", "by (simp add: node\\<^sub>i.simps False split_half_ts)"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (node\\<^sub>i k ts t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node\\<^sub>i_order_helper:\n  assumes \"length ts \\<ge> k\"\n    and \"length ts \\<le> 4*k+1\"\n    and \"\\<forall>x \\<in> set (subtrees ts). order k x\"\n    and \"order k t\"\n  shows \"case (node\\<^sub>i k ts t) of T\\<^sub>i t \\<Rightarrow> order k t | _ \\<Rightarrow> True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "proof (cases \"length ts \\<le> 2*k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "case True"], ["proof (state)\nthis:\n  length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "then"], ["proof (chain)\npicking this:\n  length ts \\<le> 2 * k", "show ?thesis"], ["proof (prove)\nusing this:\n  length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "using assms"], ["proof (prove)\nusing this:\n  length ts \\<le> 2 * k\n  k \\<le> length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n\ngoal (1 subgoal):\n 1. case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "by (simp add: node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n  | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "case False"], ["proof (state)\nthis:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "then"], ["proof (chain)\npicking this:\n  \\<not> length ts \\<le> 2 * k", "obtain sub sep rs where\n    \"drop (length ts div 2) ts = (sub,sep)#rs\""], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep rs.\n        drop (length ts div 2) ts = (sub, sep) # rs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using split_half_not_empty[of ts]"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n  1 \\<le> length ts \\<Longrightarrow>\n  \\<exists>ls sub sep rs. split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep rs.\n        drop (length ts div 2) ts = (sub, sep) # rs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  drop (length ts div 2) ts = (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "then"], ["proof (chain)\npicking this:\n  drop (length ts div 2) ts = (sub, sep) # rs", "show ?thesis"], ["proof (prove)\nusing this:\n  drop (length ts div 2) ts = (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "using assms"], ["proof (prove)\nusing this:\n  drop (length ts div 2) ts = (sub, sep) # rs\n  k \\<le> length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n\ngoal (1 subgoal):\n 1. case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True", "by (simp add: node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  case node\\<^sub>i k ts t of T\\<^sub>i t \\<Rightarrow> order k t\n  | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node\\<^sub>i_order:\n  assumes \"length ts \\<ge> k\"\n    and \"length ts \\<le> 4*k+1\"\n    and \"\\<forall>x \\<in> set (subtrees ts). order k x\"\n    and \"order k t\"\n  shows \"order_up\\<^sub>i k (node\\<^sub>i k ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k ts t)", "apply(cases \"node\\<^sub>i k ts t\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       node\\<^sub>i k ts t = T\\<^sub>i x1 \\<Longrightarrow>\n       order_up\\<^sub>i k (node\\<^sub>i k ts t)\n 2. \\<And>x21 x22 x23.\n       node\\<^sub>i k ts t = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       order_up\\<^sub>i k (node\\<^sub>i k ts t)", "using node\\<^sub>i_root_order node\\<^sub>i_order_helper assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < length ?ts; length ?ts \\<le> 4 * ?k + 1;\n   \\<forall>x\\<in>set (subtrees ?ts). order ?k x; order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> root_order_up\\<^sub>i ?k (node\\<^sub>i ?k ?ts ?t)\n  \\<lbrakk>?k \\<le> length ?ts; length ?ts \\<le> 4 * ?k + 1;\n   \\<forall>x\\<in>set (subtrees ?ts). order ?k x; order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> case node\\<^sub>i ?k ?ts ?t of\n                    T\\<^sub>i t \\<Rightarrow> order ?k t\n                    | Up\\<^sub>i btree1 b btree2 \\<Rightarrow> True\n  k \\<le> length ts\n  length ts \\<le> 4 * k + 1\n  \\<forall>x\\<in>set (subtrees ts). order k x\n  order k t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       node\\<^sub>i k ts t = T\\<^sub>i x1 \\<Longrightarrow>\n       order_up\\<^sub>i k (node\\<^sub>i k ts t)\n 2. \\<And>x21 x22 x23.\n       node\\<^sub>i k ts t = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       order_up\\<^sub>i k (node\\<^sub>i k ts t)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       node\\<^sub>i k ts t = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       order_up\\<^sub>i k (node\\<^sub>i k ts t)", "apply (metis node\\<^sub>i_root_order assms(2,3,4) le0 length_greater_0_conv\n      list.size(3) node\\<^sub>i.simps order_up\\<^sub>i.simps(2) root_order_up\\<^sub>i.simps(2) up\\<^sub>i.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* explicit proof *)"], ["", "lemma ins_order:\n  \"order k t \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order k t \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)", "proof(induction k x t rule: ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       order k Leaf \\<Longrightarrow> order_up\\<^sub>i k (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; order k t\\<rbrakk>\n                   \\<Longrightarrow> order_up\\<^sub>i k (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; order k xb\\<rbrakk>\n           \\<Longrightarrow> order_up\\<^sub>i k (ins k x xb);\n        order k (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       order k Leaf \\<Longrightarrow> order_up\\<^sub>i k (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; order k t\\<rbrakk>\n                   \\<Longrightarrow> order_up\\<^sub>i k (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; order k xb\\<rbrakk>\n           \\<Longrightarrow> order_up\\<^sub>i k (ins k x xb);\n        order k (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)", "obtain ls rs where split_res: \"split ts x = (ls, rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       order k Leaf \\<Longrightarrow> order_up\\<^sub>i k (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; order k t\\<rbrakk>\n                   \\<Longrightarrow> order_up\\<^sub>i k (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; order k xb\\<rbrakk>\n           \\<Longrightarrow> order_up\\<^sub>i k (ins k x xb);\n        order k (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have split_app: \"ls@rs = ts\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "using split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "by simp"], ["proof (state)\nthis:\n  ls @ rs = ts\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       order k Leaf \\<Longrightarrow> order_up\\<^sub>i k (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; order k t\\<rbrakk>\n                   \\<Longrightarrow> order_up\\<^sub>i k (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; order k xb\\<rbrakk>\n           \\<Longrightarrow> order_up\\<^sub>i k (ins k x xb);\n        order k (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = []", "have \"order_up\\<^sub>i k (ins k x t)\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x t)", "using 2 split_res"], ["proof (prove)\nusing this:\n  rs = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x t)", "by simp"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (ins k x t)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x t)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "using Nil 2 split_app split_res Nil node\\<^sub>i_order"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x t)\n  rs = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n  ls @ rs = ts\n  split ts x = (ls, rs)\n  rs = []\n  \\<lbrakk>?k \\<le> length ?ts; length ?ts \\<le> 4 * ?k + 1;\n   \\<forall>x\\<in>set (subtrees ?ts). order ?k x; order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i ?k (node\\<^sub>i ?k ?ts ?t)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "by (auto split!: up\\<^sub>i.splits simp del: node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "case (Cons a list)"], ["proof (state)\nthis:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = a # list", "obtain sub sep where a_prod: \"a  = (sub, sep)\""], ["proof (prove)\nusing this:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  a = (sub, sep)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "proof (cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x = sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "using 2 a_prod Cons split_res"], ["proof (prove)\nusing this:\n  x = sep\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n  a = (sub, sep)\n  rs = a # list\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "by simp"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "have \"order_up\\<^sub>i k (ins k x sub)\""], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x sub)", "using \"2.IH\"(2) \"2.prems\" a_prod local.Cons split_app split_res"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n  a = (sub, sep)\n  rs = a # list\n  ls @ rs = ts\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x sub)", "by auto"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x sub)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> order_up\\<^sub>i k (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (ins k x sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x sub)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "using 2 split_app Cons length_append node\\<^sub>i_order a_prod split_res"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x sub)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; order k t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; order k ?xb\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k (ins k x ?xb)\n  order k (Node ts t)\n  ls @ rs = ts\n  rs = a # list\n  length (?xs @ ?ys) = length ?xs + length ?ys\n  \\<lbrakk>?k \\<le> length ?ts; length ?ts \\<le> 4 * ?k + 1;\n   \\<forall>x\\<in>set (subtrees ?ts). order ?k x; order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i ?k (node\\<^sub>i ?k ?ts ?t)\n  a = (sub, sep)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x (Node ts t))", "by (auto split!: up\\<^sub>i.splits simp del: node\\<^sub>i.simps simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       order k Leaf \\<Longrightarrow> order_up\\<^sub>i k (ins k x Leaf)", "qed simp"], ["", "(* notice this is almost a duplicate of ins_order *)"], ["", "lemma ins_root_order:\n  assumes \"root_order k t\"\n  shows \"root_order_up\\<^sub>i k (ins k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "proof(cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       root_order_up\\<^sub>i k (ins k x t)", "case (Node ts t)"], ["proof (state)\nthis:\n  t = Node ts t\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  t = Node ts t", "obtain ls rs where split_res: \"split ts x = (ls, rs)\""], ["proof (prove)\nusing this:\n  t = Node ts t\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have split_app: \"ls@rs = ts\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "using split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "by fastforce"], ["proof (state)\nthis:\n  ls @ rs = ts\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       root_order_up\\<^sub>i k (ins k x t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  rs = []", "have \"order_up\\<^sub>i k (ins k x t)\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x t)", "using Node assms split_res"], ["proof (prove)\nusing this:\n  rs = []\n  t = Node ts t\n  root_order k t\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x t)", "by (simp add: ins_order)"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (ins k x t)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x t)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "using Nil Node split_app split_res assms node\\<^sub>i_root_order"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x t)\n  rs = []\n  t = Node ts t\n  ls @ rs = ts\n  split ts x = (ls, rs)\n  root_order k t\n  \\<lbrakk>0 < length ?ts; length ?ts \\<le> 4 * ?k + 1;\n   \\<forall>x\\<in>set (subtrees ?ts). order ?k x; order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> root_order_up\\<^sub>i ?k (node\\<^sub>i ?k ?ts ?t)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "by (auto split!: up\\<^sub>i.splits simp del: node\\<^sub>i.simps simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (ins k x t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "case (Cons a list)"], ["proof (state)\nthis:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  rs = a # list", "obtain sub sep where a_prod: \"a  = (sub, sep)\""], ["proof (prove)\nusing this:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  a = (sub, sep)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "proof (cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  x = sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "using assms Node a_prod Cons split_res"], ["proof (prove)\nusing this:\n  x = sep\n  root_order k t\n  t = Node ts t\n  a = (sub, sep)\n  rs = a # list\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "by simp"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (ins k x t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "have \"order_up\\<^sub>i k (ins k x sub)\""], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x sub)", "using Node a_prod assms ins_order local.Cons split_app"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n  t = Node ts t\n  a = (sub, sep)\n  root_order k t\n  order ?k ?t \\<Longrightarrow> order_up\\<^sub>i ?k (ins ?k ?x ?t)\n  rs = a # list\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (ins k x sub)", "by auto"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (ins k x sub)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (ins k x sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x sub)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "using assms split_app Cons length_append Node node\\<^sub>i_root_order a_prod split_res"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (ins k x sub)\n  root_order k t\n  ls @ rs = ts\n  rs = a # list\n  length (?xs @ ?ys) = length ?xs + length ?ys\n  t = Node ts t\n  \\<lbrakk>0 < length ?ts; length ?ts \\<le> 4 * ?k + 1;\n   \\<forall>x\\<in>set (subtrees ?ts). order ?k x; order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> root_order_up\\<^sub>i ?k (node\\<^sub>i ?k ?ts ?t)\n  a = (sub, sep)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. root_order_up\\<^sub>i k (ins k x t)", "by (auto split!: up\\<^sub>i.splits simp del: node\\<^sub>i.simps simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (ins k x t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (ins k x t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  root_order_up\\<^sub>i k (ins k x t)\n\ngoal (1 subgoal):\n 1. t = Leaf \\<Longrightarrow> root_order_up\\<^sub>i k (ins k x t)", "qed simp"], ["", "lemma height_list_split: \"height_up\\<^sub>i (Up\\<^sub>i (Node ls a) b (Node rs t)) = height (Node (ls@(a,b)#rs) t) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (Up\\<^sub>i (Node ls a) b (Node rs t)) =\n    height (Node (ls @ (a, b) # rs) t)", "by (induction ls) (auto simp add: max.commute)"], ["", "lemma node\\<^sub>i_height: \"height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "proof(cases \"length ts \\<le> 2*k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "case False"], ["proof (state)\nthis:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  \\<not> length ts \\<le> 2 * k", "obtain ls sub sep rs where\n    split_half_ts: \"split_half ts = (ls, (sub, sep) # rs)\""], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson node\\<^sub>i_cases)"], ["proof (state)\nthis:\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  split_half ts = (ls, (sub, sep) # rs)", "have \"node\\<^sub>i k ts t = Up\\<^sub>i (Node ls (sub)) sep (Node rs t)\""], ["proof (prove)\nusing this:\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)", "using False"], ["proof (prove)\nusing this:\n  split_half ts = (ls, (sub, sep) # rs)\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)", "by simp"], ["proof (state)\nthis:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)", "show ?thesis"], ["proof (prove)\nusing this:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "using split_half_ts"], ["proof (prove)\nusing this:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "by (metis append_take_drop_id fst_conv height_list_split snd_conv split_half.elims)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    height_up\\<^sub>i (node\\<^sub>i k ts t) = height (Node ts t)", "qed simp"], ["", "lemma bal_up\\<^sub>i_tree: \"bal_up\\<^sub>i t = bal (tree\\<^sub>i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i t = bal (tree\\<^sub>i t)", "apply(cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = T\\<^sub>i x1 \\<Longrightarrow>\n       bal_up\\<^sub>i t = bal (tree\\<^sub>i t)\n 2. \\<And>x21 x22 x23.\n       t = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i t = bal (tree\\<^sub>i t)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bal_list_split: \"bal (Node (ls@(a,b)#rs) t) \\<Longrightarrow> bal_up\\<^sub>i (Up\\<^sub>i (Node ls a) b (Node rs t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (ls @ (a, b) # rs) t) \\<Longrightarrow>\n    bal_up\\<^sub>i (Up\\<^sub>i (Node ls a) b (Node rs t))", "by (auto simp add: image_constant_conv)"], ["", "lemma node\\<^sub>i_bal:\n  assumes \"bal (Node ts t)\"\n  shows \"bal_up\\<^sub>i (node\\<^sub>i k ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k ts t)", "using assms"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k ts t)", "proof(cases \"length ts \\<le> 2*k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node ts t); length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)\n 2. \\<lbrakk>bal (Node ts t); \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)", "case False"], ["proof (state)\nthis:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node ts t); length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)\n 2. \\<lbrakk>bal (Node ts t); \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)", "then"], ["proof (chain)\npicking this:\n  \\<not> length ts \\<le> 2 * k", "obtain ls sub sep rs where\n    split_half_ts: \"split_half ts = (ls, (sub, sep) # rs)\""], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson node\\<^sub>i_cases)"], ["proof (state)\nthis:\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node ts t); length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)\n 2. \\<lbrakk>bal (Node ts t); \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)", "then"], ["proof (chain)\npicking this:\n  split_half ts = (ls, (sub, sep) # rs)", "have \"bal (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\nusing this:\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t)", "using assms append_take_drop_id[where n=\"length ts div 2\" and xs=ts]"], ["proof (prove)\nusing this:\n  split_half ts = (ls, (sub, sep) # rs)\n  bal (Node ts t)\n  take (length ts div 2) ts @ drop (length ts div 2) ts = ts\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t)", "by auto"], ["proof (state)\nthis:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node ts t); length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)\n 2. \\<lbrakk>bal (Node ts t); \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (sub, sep) # rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k ts t)", "using split_half_ts assms False"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub, sep) # rs) t)\n  split_half ts = (ls, (sub, sep) # rs)\n  bal (Node ts t)\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k ts t)", "by (auto simp del: bal.simps bal_up\\<^sub>i.simps dest!: bal_list_split[of ls sub sep rs t])"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (node\\<^sub>i k ts t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bal (Node ts t); length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (node\\<^sub>i k ts t)", "qed simp"], ["", "lemma height_up\\<^sub>i_merge: \"height_up\\<^sub>i (Up\\<^sub>i l a r) = height t \\<Longrightarrow> height (Node (ls@(t,x)#rs) tt) = height (Node (ls@(l,a)#(r,x)#rs) tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (Up\\<^sub>i l a r) = height t \\<Longrightarrow>\n    height (Node (ls @ (t, x) # rs) tt) =\n    height (Node (ls @ (l, a) # (r, x) # rs) tt)", "by simp"], ["", "lemma ins_height: \"height_up\\<^sub>i (ins k x t) = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x t) = height t", "proof(induction k x t rule: ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x. height_up\\<^sub>i (ins k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []\\<rbrakk>\n                   \\<Longrightarrow> height_up\\<^sub>i (ins k x t) =\n                                     height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x\\<rbrakk>\n           \\<Longrightarrow> height_up\\<^sub>i (ins k x xb) =\n                             height xb\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n\ngoal (2 subgoals):\n 1. \\<And>k x. height_up\\<^sub>i (ins k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []\\<rbrakk>\n                   \\<Longrightarrow> height_up\\<^sub>i (ins k x t) =\n                                     height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x\\<rbrakk>\n           \\<Longrightarrow> height_up\\<^sub>i (ins k x xb) =\n                             height xb\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb", "obtain ls rs where split_list: \"split ts x = (ls,rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. \\<And>k x. height_up\\<^sub>i (ins k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []\\<rbrakk>\n                   \\<Longrightarrow> height_up\\<^sub>i (ins k x t) =\n                                     height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x\\<rbrakk>\n           \\<Longrightarrow> height_up\\<^sub>i (ins k x xb) =\n                             height xb\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have split_append: \"ls@rs = ts\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "using split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "by auto"], ["proof (state)\nthis:\n  ls @ rs = ts\n\ngoal (2 subgoals):\n 1. \\<And>k x. height_up\\<^sub>i (ins k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []\\<rbrakk>\n                   \\<Longrightarrow> height_up\\<^sub>i (ins k x t) =\n                                     height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x\\<rbrakk>\n           \\<Longrightarrow> height_up\\<^sub>i (ins k x xb) =\n                             height xb\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  ls @ rs = ts", "show ?case"], ["proof (prove)\nusing this:\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls @ rs = ts; rs = []\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)\n 2. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls @ rs = ts; rs = []\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)\n 2. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  rs = []", "have height_sub: \"height_up\\<^sub>i (ins k x t) = height t\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x t) = height t", "using 2"], ["proof (prove)\nusing this:\n  rs = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x t) = height t", "by (simp add: split_list)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x t) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls @ rs = ts; rs = []\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)\n 2. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (ins k x t) = height t", "show ?thesis"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (ins k x t) = height t\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "proof (cases \"ins k x t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case (T\\<^sub>i a)"], ["proof (state)\nthis:\n  ins k x t = T\\<^sub>i a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  ins k x t = T\\<^sub>i a", "have \"height (Node ts t) = height (Node ts a)\""], ["proof (prove)\nusing this:\n  ins k x t = T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. height (Node ts t) = height (Node ts a)", "using height_sub"], ["proof (prove)\nusing this:\n  ins k x t = T\\<^sub>i a\n  height_up\\<^sub>i (ins k x t) = height t\n\ngoal (1 subgoal):\n 1. height (Node ts t) = height (Node ts a)", "by simp"], ["proof (state)\nthis:\n  height (Node ts t) = height (Node ts a)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height (Node ts t) = height (Node ts a)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node ts t) = height (Node ts a)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "using T\\<^sub>i Nil split_list split_append"], ["proof (prove)\nusing this:\n  height (Node ts t) = height (Node ts a)\n  ins k x t = T\\<^sub>i a\n  rs = []\n  split ts x = (ls, rs)\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "by simp"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  ins k x t = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  ins k x t = Up\\<^sub>i l a r", "have \"height (Node ls t) = height (Node (ls@[(l,a)]) r)\""], ["proof (prove)\nusing this:\n  ins k x t = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. height (Node ls t) = height (Node (ls @ [(l, a)]) r)", "using height_btree_order height_sub"], ["proof (prove)\nusing this:\n  ins k x t = Up\\<^sub>i l a r\n  height (Node (?ls @ [?a]) ?t) = height (Node (?a # ?ls) ?t)\n  height_up\\<^sub>i (ins k x t) = height t\n\ngoal (1 subgoal):\n 1. height (Node ls t) = height (Node (ls @ [(l, a)]) r)", "by (induction ls) auto"], ["proof (state)\nthis:\n  height (Node ls t) = height (Node (ls @ [(l, a)]) r)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x t) = height t;\n        ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height (Node ls t) = height (Node (ls @ [(l, a)]) r)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node ls t) = height (Node (ls @ [(l, a)]) r)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "using 2 Nil split_list Up\\<^sub>i split_append"], ["proof (prove)\nusing this:\n  height (Node ls t) = height (Node (ls @ [(l, a)]) r)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n  rs = []\n  split ts x = (ls, rs)\n  ins k x t = Up\\<^sub>i l a r\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "by (simp del: node\\<^sub>i.simps add: node\\<^sub>i_height)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case (Cons a list)"], ["proof (state)\nthis:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  rs = a # list", "obtain sub sep where a_split: \"a = (sub,sep)\""], ["proof (prove)\nusing this:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ls @ rs = ts; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  a = (sub, sep)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "proof (cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  x = sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "using Cons a_split 2 split_list"], ["proof (prove)\nusing this:\n  x = sep\n  rs = a # list\n  a = (sub, sep)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "by (simp del: height_btree.simps)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "have height_sub: \"height_up\\<^sub>i (ins k x sub) = height sub\""], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x sub) = height sub", "by (metis \"2.IH\"(2) a_split Cons split_list)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x sub) = height sub\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                      height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (ins k x sub) = height sub", "show ?thesis"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (ins k x sub) = height sub\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "proof (cases \"ins k x sub\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case (T\\<^sub>i a)"], ["proof (state)\nthis:\n  ins k x sub = T\\<^sub>i a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  ins k x sub = T\\<^sub>i a", "have \"height a = height sub\""], ["proof (prove)\nusing this:\n  ins k x sub = T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. height a = height sub", "using height_sub"], ["proof (prove)\nusing this:\n  ins k x sub = T\\<^sub>i a\n  height_up\\<^sub>i (ins k x sub) = height sub\n\ngoal (1 subgoal):\n 1. height a = height sub", "by auto"], ["proof (state)\nthis:\n  height a = height sub\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height a = height sub", "have \"height (Node (ls@(sub,sep)#rs) t) = height (Node (ls@(a,sep)#rs) t)\""], ["proof (prove)\nusing this:\n  height a = height sub\n\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub, sep) # rs) t) =\n    height (Node (ls @ (a, sep) # rs) t)", "by auto"], ["proof (state)\nthis:\n  height (Node (ls @ (sub, sep) # rs) t) =\n  height (Node (ls @ (a, sep) # rs) t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height (Node (ls @ (sub, sep) # rs) t) =\n  height (Node (ls @ (a, sep) # rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node (ls @ (sub, sep) # rs) t) =\n  height (Node (ls @ (a, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "using T\\<^sub>i height_sub False Cons 2 split_list a_split split_append"], ["proof (prove)\nusing this:\n  height (Node (ls @ (sub, sep) # rs) t) =\n  height (Node (ls @ (a, sep) # rs) t)\n  ins k x sub = T\\<^sub>i a\n  height_up\\<^sub>i (ins k x sub) = height sub\n  x \\<noteq> sep\n  rs = a__ # list\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n  split ts x = (ls, rs)\n  a__ = (sub, sep)\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "by (auto simp add: image_Un max.commute finite_set_ins_swap)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  ins k x sub = Up\\<^sub>i l a r", "have \"height (Node (ls@(sub,sep)#list) t) = height (Node (ls@(l,a)#(r,sep)#list) t)\""], ["proof (prove)\nusing this:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub, sep) # list) t) =\n    height (Node (ls @ (l, a) # (r, sep) # list) t)", "using height_up\\<^sub>i_merge height_sub"], ["proof (prove)\nusing this:\n  ins k x sub = Up\\<^sub>i l a r\n  height_up\\<^sub>i (Up\\<^sub>i ?l ?a ?r) = height ?t \\<Longrightarrow>\n  height (Node (?ls @ (?t, ?x) # ?rs) ?tt) =\n  height (Node (?ls @ (?l, ?a) # (?r, ?x) # ?rs) ?tt)\n  height_up\\<^sub>i (ins k x sub) = height sub\n\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub, sep) # list) t) =\n    height (Node (ls @ (l, a) # (r, sep) # list) t)", "by fastforce"], ["proof (state)\nthis:\n  height (Node (ls @ (sub, sep) # list) t) =\n  height (Node (ls @ (l, a) # (r, sep) # list) t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i (ins k x sub) = height sub;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height_up\\<^sub>i (ins k x (Node ts t)) =\n                         height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height (Node (ls @ (sub, sep) # list) t) =\n  height (Node (ls @ (l, a) # (r, sep) # list) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node (ls @ (sub, sep) # list) t) =\n  height (Node (ls @ (l, a) # (r, sep) # list) t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "using Up\\<^sub>i False Cons 2 split_list a_split split_append"], ["proof (prove)\nusing this:\n  height (Node (ls @ (sub, sep) # list) t) =\n  height (Node (ls @ (l, a) # (r, sep) # list) t)\n  ins k x sub = Up\\<^sub>i l a r\n  x \\<noteq> sep\n  rs = a__ # list\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> height_up\\<^sub>i (ins k x ?xb) = height ?xb\n  split ts x = (ls, rs)\n  a__ = (sub, sep)\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)", "by (auto simp del: node\\<^sub>i.simps simp add: node\\<^sub>i_height image_Un max.commute finite_set_ins_swap)"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height_up\\<^sub>i (ins k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>k x. height_up\\<^sub>i (ins k x Leaf) = height Leaf", "qed simp"], ["", "(* the below proof is overly complicated as a number of lemmas regarding height are missing *)"], ["", "lemma ins_bal: \"bal t \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal t \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)", "proof(induction k x t rule: ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x. bal Leaf \\<Longrightarrow> bal_up\\<^sub>i (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal_up\\<^sub>i (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal_up\\<^sub>i (ins k x xb);\n        bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k x. bal Leaf \\<Longrightarrow> bal_up\\<^sub>i (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal_up\\<^sub>i (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal_up\\<^sub>i (ins k x xb);\n        bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)", "obtain ls rs where split_res: \"split ts x = (ls, rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. \\<And>k x. bal Leaf \\<Longrightarrow> bal_up\\<^sub>i (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal_up\\<^sub>i (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal_up\\<^sub>i (ins k x xb);\n        bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have split_app: \"ls@rs = ts\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "using split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. ls @ rs = ts", "by fastforce"], ["proof (state)\nthis:\n  ls @ rs = ts\n\ngoal (2 subgoals):\n 1. \\<And>k x. bal Leaf \\<Longrightarrow> bal_up\\<^sub>i (ins k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal_up\\<^sub>i (ins k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal_up\\<^sub>i (ins k x xb);\n        bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "proof (cases \"ins k x t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case (T\\<^sub>i a)"], ["proof (state)\nthis:\n  ins k x t = T\\<^sub>i a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x t = T\\<^sub>i a", "have \"bal (Node ls a)\""], ["proof (prove)\nusing this:\n  ins k x t = T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. bal (Node ls a)", "unfolding bal.simps"], ["proof (prove)\nusing this:\n  ins k x t = T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. (\\<forall>sub\\<in>set (subtrees ls). height sub = height a) \\<and>\n    Ball (set (subtrees ls)) bal \\<and> bal a", "by (metis \"2.IH\"(1) \"2.prems\" append_Nil2 bal.simps(2) bal_up\\<^sub>i.simps(1) height_up\\<^sub>i.simps(1) ins_height local.Nil split_app split_res)"], ["proof (state)\nthis:\n  bal (Node ls a)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (Node ls a)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (Node ls a)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "using Nil T\\<^sub>i 2 split_res"], ["proof (prove)\nusing this:\n  bal (Node ls a)\n  rs = []\n  ins k x t = T\\<^sub>i a\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "by simp"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  ins k x t = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x t = Up\\<^sub>i l a r", "have\n        \"(\\<forall>x\\<in>set (subtrees (ls@[(l,a)])). bal x)\"\n        \"(\\<forall>x\\<in>set (subtrees ls). height r = height x)\""], ["proof (prove)\nusing this:\n  ins k x t = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x &&&\n    \\<forall>x\\<in>set (subtrees ls). height r = height x", "using 2 Up\\<^sub>i Nil split_res split_app"], ["proof (prove)\nusing this:\n  ins k x t = Up\\<^sub>i l a r\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  ins k x t = Up\\<^sub>i l a r\n  rs = []\n  split ts x = (ls, rs)\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x &&&\n    \\<forall>x\\<in>set (subtrees ls). height r = height x", "by simp_all (metis height_up\\<^sub>i.simps(2) ins_height max_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x\n  \\<forall>x\\<in>set (subtrees ls). height r = height x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x\n  \\<forall>x\\<in>set (subtrees ls). height r = height x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x\n  \\<forall>x\\<in>set (subtrees ls). height r = height x\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "unfolding ins.simps"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x\n  \\<forall>x\\<in>set (subtrees ls). height r = height x\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i\n     (case split ts x of\n      (ls, []) \\<Rightarrow>\n        case ins k x t of T\\<^sub>i a \\<Rightarrow> T\\<^sub>i (Node ls a)\n        | Up\\<^sub>i l a x \\<Rightarrow> node\\<^sub>i k (ls @ [(l, a)]) x\n      | (ls, (sub, sep) # rs) \\<Rightarrow>\n          if sep = x then T\\<^sub>i (Node ts t)\n          else case ins k x sub of\n               T\\<^sub>i a \\<Rightarrow>\n                 T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n               | Up\\<^sub>i l a r \\<Rightarrow>\n                   node\\<^sub>i k (ls @ (l, a) # (r, sep) # rs) t)", "using Up\\<^sub>i Nil 2 split_res"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (subtrees (ls @ [(l, a)])). bal x\n  \\<forall>x\\<in>set (subtrees ls). height r = height x\n  ins k x t = Up\\<^sub>i l a r\n  rs = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i\n     (case split ts x of\n      (ls, []) \\<Rightarrow>\n        case ins k x t of T\\<^sub>i a \\<Rightarrow> T\\<^sub>i (Node ls a)\n        | Up\\<^sub>i l a x \\<Rightarrow> node\\<^sub>i k (ls @ [(l, a)]) x\n      | (ls, (sub, sep) # rs) \\<Rightarrow>\n          if sep = x then T\\<^sub>i (Node ts t)\n          else case ins k x sub of\n               T\\<^sub>i a \\<Rightarrow>\n                 T\\<^sub>i (Node (ls @ (a, sep) # rs) t)\n               | Up\\<^sub>i l a r \\<Rightarrow>\n                   node\\<^sub>i k (ls @ (l, a) # (r, sep) # rs) t)", "by (simp del: node\\<^sub>i.simps add: node\\<^sub>i_bal)"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case (Cons a list)"], ["proof (state)\nthis:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = a # list", "obtain sub sep where a_prod: \"a  = (sub, sep)\""], ["proof (prove)\nusing this:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  a = (sub, sep)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "proof (cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>a = (sub, sep); x = sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x = sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "using a_prod 2 split_res Cons"], ["proof (prove)\nusing this:\n  x = sep\n  a = (sub, sep)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n  rs = a # list\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "by simp"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "have \"bal_up\\<^sub>i (ins k x sub)\""], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x sub)", "using 2 split_res"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x sub)", "using a_prod local.Cons split_app"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n  a = (sub, sep)\n  rs = a # list\n  ls @ rs = ts\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x sub)", "by auto"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x sub)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = (sub, sep); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> bal_up\\<^sub>i (ins k x (Node ts t))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "proof (cases \"ins k x sub\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ins k x sub = T\\<^sub>i x1 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "case (T\\<^sub>i x1)"], ["proof (state)\nthis:\n  ins k x sub = T\\<^sub>i x1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ins k x sub = T\\<^sub>i x1 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x sub = T\\<^sub>i x1", "have  \"height x1 = height t\""], ["proof (prove)\nusing this:\n  ins k x sub = T\\<^sub>i x1\n\ngoal (1 subgoal):\n 1. height x1 = height t", "by (metis \"2.prems\" a_prod add_diff_cancel_left' bal_split_left(1) bal_split_left(2) height_bal_tree height_up\\<^sub>i.simps(1) ins_height local.Cons plus_1_eq_Suc split_app)"], ["proof (state)\nthis:\n  height x1 = height t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ins k x sub = T\\<^sub>i x1 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))\n 2. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  height x1 = height t", "show ?thesis"], ["proof (prove)\nusing this:\n  height x1 = height t\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "using split_app Cons T\\<^sub>i 2 split_res a_prod"], ["proof (prove)\nusing this:\n  height x1 = height t\n  ls @ rs = ts\n  rs = a # list\n  ins k x sub = T\\<^sub>i x1\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "(* The only case where explicit reasoning is required - likely due to the insertion of 2 elements in the list *)"], ["proof (state)\nthis:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x sub = Up\\<^sub>i l a r", "have\n          \"\\<forall>x \\<in> set (subtrees (ls@(l,a)#(r,sep)#list)). bal x\""], ["proof (prove)\nusing this:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x", "using Up\\<^sub>i split_app Cons 2 \\<open>bal_up\\<^sub>i (ins k x sub)\\<close>"], ["proof (prove)\nusing this:\n  ins k x sub = Up\\<^sub>i l a r\n  ins k x sub = Up\\<^sub>i l a r\n  ls @ rs = ts\n  rs = a__ # list\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  bal_up\\<^sub>i (ins k x sub)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "have \"\\<forall>x \\<in> set (subtrees (ls@(l,a)#(r,sep)#list)). height x = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)).\n       height x = height t", "using False Up\\<^sub>i split_app Cons 2 \\<open>bal_up\\<^sub>i (ins k x sub)\\<close> ins_height split_res a_prod"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n  ins k x sub = Up\\<^sub>i l a r\n  ls @ rs = ts\n  rs = a__ # list\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  bal_up\\<^sub>i (ins k x sub)\n  height_up\\<^sub>i (ins ?k ?x ?t) = height ?t\n  split ts x = (ls, rs)\n  a__ = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)).\n       height x = height t", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> sep; ins k x sub = Up\\<^sub>i l a r;\n     rs = (sub, sep) # list;\n     \\<And>k x t. height_up\\<^sub>i (ins k x t) = height t;\n     split (ls @ (sub, sep) # list) x = (ls, (sub, sep) # list);\n     a__ = (sub, sep); ts = ls @ (sub, sep) # list; height l = height r;\n     bal t; bal l; bal r; height sub = height t;\n     \\<forall>sub\\<in>set ls \\<union> set list. height (fst sub) = height t;\n     bal sub; \\<forall>x\\<in>set ls \\<union> set list. bal (fst x)\\<rbrakk>\n    \\<Longrightarrow> height r = height t", "by (metis height_up\\<^sub>i.simps(2) sup.idem sup_nat_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)).\n     height x = height t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       ins k x sub = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       bal_up\\<^sub>i (ins k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)).\n     height x = height t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)).\n     height x = height t\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "using Up\\<^sub>i Cons 2 split_res a_prod"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)). bal x\n  \\<forall>x\\<in>set (subtrees (ls @ (l, a) # (r, sep) # list)).\n     height x = height t\n  ins k x sub = Up\\<^sub>i l a r\n  rs = a__ # list\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; bal t\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal_up\\<^sub>i (ins k x ?xb)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n  a__ = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (ins k x (Node ts t))", "by (simp del: node\\<^sub>i.simps add: node\\<^sub>i_bal)"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x. bal Leaf \\<Longrightarrow> bal_up\\<^sub>i (ins k x Leaf)", "qed simp"], ["", "(* ins acts as ins_list wrt inorder *)\n\n(* \"simple enough\" to be automatically solved *)"], ["", "lemma node\\<^sub>i_inorder: \"inorder_up\\<^sub>i (node\\<^sub>i k ts t) = inorder (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (node\\<^sub>i k ts t) = inorder (Node ts t)", "apply(cases \"length ts \\<le> 2*k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length ts \\<le> 2 * k \\<Longrightarrow>\n    inorder_up\\<^sub>i (node\\<^sub>i k ts t) = inorder (Node ts t)\n 2. \\<not> length ts \\<le> 2 * k \\<Longrightarrow>\n    inorder_up\\<^sub>i (node\\<^sub>i k ts t) = inorder (Node ts t)", "apply (auto split!: list.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       \\<lbrakk>\\<not> length ts \\<le> 2 * k;\n        drop (length ts div 2) ts = (a, b) # x22\\<rbrakk>\n       \\<Longrightarrow> inorder_list (take (length ts div 2) ts) @\n                         inorder a @ b # inorder_list x22 =\n                         inorder_list ts", "(* we want to only transform in one direction here.. *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       \\<lbrakk>\\<not> length ts \\<le> 2 * k;\n        drop (length ts div 2) ts = (a, b) # x22\\<rbrakk>\n       \\<Longrightarrow> inorder_list (take (length ts div 2) ts) @\n                         inorder a @ b # inorder_list x22 =\n                         inorder_list ts", "supply R = sym[OF append_take_drop_id, of \"map _ ts\" \"(length ts div 2)\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       \\<lbrakk>\\<not> length ts \\<le> 2 * k;\n        drop (length ts div 2) ts = (a, b) # x22\\<rbrakk>\n       \\<Longrightarrow> inorder_list (take (length ts div 2) ts) @\n                         inorder a @ b # inorder_list x22 =\n                         inorder_list ts", "thm R"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       \\<lbrakk>\\<not> length ts \\<le> 2 * k;\n        drop (length ts div 2) ts = (a, b) # x22\\<rbrakk>\n       \\<Longrightarrow> inorder_list (take (length ts div 2) ts) @\n                         inorder a @ b # inorder_list x22 =\n                         inorder_list ts", "apply(subst R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x22.\n       \\<lbrakk>\\<not> length ts \\<le> 2 * k;\n        drop (length ts div 2) ts = (a, b) # x22\\<rbrakk>\n       \\<Longrightarrow> inorder_list (take (length ts div 2) ts) @\n                         inorder a @ b # inorder_list x22 =\n                         concat\n                          (take (length ts div 2) (map inorder_pair ts) @\n                           drop (length ts div 2) (map inorder_pair ts))", "apply (simp del: append_take_drop_id add: take_map drop_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary node\\<^sub>i_inorder_simps:\n  \"node\\<^sub>i k ts t = T\\<^sub>i t' \\<Longrightarrow> inorder t' = inorder (Node ts t)\"\n  \"node\\<^sub>i k ts t = Up\\<^sub>i l a r \\<Longrightarrow> inorder l @ a # inorder r = inorder (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (node\\<^sub>i k ts t = T\\<^sub>i t' \\<Longrightarrow>\n     inorder t' = inorder (Node ts t)) &&&\n    (node\\<^sub>i k ts t = Up\\<^sub>i l a r \\<Longrightarrow>\n     inorder l @ a # inorder r = inorder (Node ts t))", "apply (metis inorder_up\\<^sub>i.simps(1) node\\<^sub>i_inorder)"], ["proof (prove)\ngoal (1 subgoal):\n 1. node\\<^sub>i k ts t = Up\\<^sub>i l a r \\<Longrightarrow>\n    inorder l @ a # inorder r = inorder (Node ts t)", "by (metis append_Cons inorder_up\\<^sub>i.simps(2) node\\<^sub>i_inorder self_append_conv2)"], ["", "lemma ins_sorted_inorder: \"sorted_less (inorder t) \\<Longrightarrow> (inorder_up\\<^sub>i (ins k (x::('a::linorder)) t)) = ins_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)", "apply(induction k x t rule: ins.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       inorder_up\\<^sub>i (ins k x Leaf) = ins_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "using split_axioms"], ["proof (prove)\nusing this:\n  split split\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       inorder_up\\<^sub>i (ins k x Leaf) = ins_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "apply (auto split!: prod.splits list.splits up\\<^sub>i.splits simp del: node\\<^sub>i.simps\n      simp add:  node\\<^sub>i_inorder node\\<^sub>i_inorder_simps)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>k x ts t x1 x1a.\n       \\<lbrakk>sorted_less (inorder t) \\<Longrightarrow>\n                inorder x1a = ins_list x (inorder t);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, []); ins k x t = T\\<^sub>i x1a\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @ inorder x1a =\n                         ins_list x (inorder_list ts @ inorder t)\n 2. \\<And>k x ts t x1 x21 x22 x23.\n       \\<lbrakk>sorted_less (inorder t) \\<Longrightarrow>\n                inorder x21 @ x22 # inorder x23 = ins_list x (inorder t);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, []); ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @ inorder x21 @ x22 # inorder x23 =\n                         ins_list x (inorder_list ts @ inorder t)\n 3. \\<And>k x ts t x1 a x22 x1a.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, x) # x22); ins k x a = T\\<^sub>i x1a\\<rbrakk>\n       \\<Longrightarrow> inorder_list ts @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)\n 4. \\<And>k x ts t x1 a b x22 x1a.\n       \\<lbrakk>\\<And>y aa xb.\n                   \\<lbrakk>aa = a; y = (a, b) # x22; xb = a;\n                    sorted_less (inorder a)\\<rbrakk>\n                   \\<Longrightarrow> inorder x1a = ins_list x (inorder a);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, b) # x22); ins k x a = T\\<^sub>i x1a;\n        b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @\n                         inorder x1a @ b # inorder_list x22 @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)\n 5. \\<And>k x ts t x1 a x22 x21 x22a x23.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, x) # x22);\n        ins k x a = Up\\<^sub>i x21 x22a x23\\<rbrakk>\n       \\<Longrightarrow> inorder_list ts @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)\n 6. \\<And>k x ts t x1 a b x22 x21 x22a x23.\n       \\<lbrakk>\\<And>y aa xb.\n                   \\<lbrakk>aa = a; y = (a, b) # x22; xb = a;\n                    sorted_less (inorder a)\\<rbrakk>\n                   \\<Longrightarrow> inorder x21 @ x22a # inorder x23 =\n                                     ins_list x (inorder a);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, b) # x22);\n        ins k x a = Up\\<^sub>i x21 x22a x23; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @\n                         inorder x21 @\n                         x22a #\n                         inorder x23 @ b # inorder_list x22 @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)", "(* from here on we prefer an explicit proof, showing how to apply the IH  *)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>k x ts t x1 x1a.\n       \\<lbrakk>sorted_less (inorder t) \\<Longrightarrow>\n                inorder x1a = ins_list x (inorder t);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, []); ins k x t = T\\<^sub>i x1a\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @ inorder x1a =\n                         ins_list x (inorder_list ts @ inorder t)\n 2. \\<And>k x ts t x1 x21 x22 x23.\n       \\<lbrakk>sorted_less (inorder t) \\<Longrightarrow>\n                inorder x21 @ x22 # inorder x23 = ins_list x (inorder t);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, []); ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @ inorder x21 @ x22 # inorder x23 =\n                         ins_list x (inorder_list ts @ inorder t)\n 3. \\<And>k x ts t x1 a x22 x1a.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, x) # x22); ins k x a = T\\<^sub>i x1a\\<rbrakk>\n       \\<Longrightarrow> inorder_list ts @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)\n 4. \\<And>k x ts t x1 a b x22 x1a.\n       \\<lbrakk>\\<And>y aa xb.\n                   \\<lbrakk>aa = a; y = (a, b) # x22; xb = a;\n                    sorted_less (inorder a)\\<rbrakk>\n                   \\<Longrightarrow> inorder x1a = ins_list x (inorder a);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, b) # x22); ins k x a = T\\<^sub>i x1a;\n        b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @\n                         inorder x1a @ b # inorder_list x22 @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)\n 5. \\<And>k x ts t x1 a x22 x21 x22a x23.\n       \\<lbrakk>sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, x) # x22);\n        ins k x a = Up\\<^sub>i x21 x22a x23\\<rbrakk>\n       \\<Longrightarrow> inorder_list ts @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)\n 6. \\<And>k x ts t x1 a b x22 x21 x22a x23.\n       \\<lbrakk>\\<And>y aa xb.\n                   \\<lbrakk>aa = a; y = (a, b) # x22; xb = a;\n                    sorted_less (inorder a)\\<rbrakk>\n                   \\<Longrightarrow> inorder x21 @ x22a # inorder x23 =\n                                     ins_list x (inorder a);\n        sorted_less (inorder_list ts @ inorder t); split split;\n        split ts x = (x1, (a, b) # x22);\n        ins k x a = Up\\<^sub>i x21 x22a x23; b \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> inorder_list x1 @\n                         inorder x21 @\n                         x22a #\n                         inorder x23 @ b # inorder_list x22 @ inorder t =\n                         ins_list x (inorder_list ts @ inorder t)", "oops"], ["", "(* specialize ins_list_sorted since it is cumbersome to express\n \"inorder_list ts\" as \"xs @ [a]\" and always having to use the implicit properties of split*)"], ["", "lemma ins_list_split:\n  assumes \"split ts x = (ls, rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n  shows \"ins_list x (inorder (Node ts t)) = inorder_list ls @ ins_list x (inorder_list rs @ inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "proof (cases ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "case Nil"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "then"], ["proof (chain)\npicking this:\n  ls = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = []\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "using assms"], ["proof (prove)\nusing this:\n  ls = []\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "by (auto dest!: split_conc)"], ["proof (state)\nthis:\n  ins_list x (inorder (Node ts t)) =\n  inorder_list ls @ ins_list x (inorder_list rs @ inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "case Cons"], ["proof (state)\nthis:\n  ls = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "then"], ["proof (chain)\npicking this:\n  ls = a_ # list_", "obtain ls' sub sep where ls_tail_split: \"ls = ls' @ [(sub,sep)]\""], ["proof (prove)\nusing this:\n  ls = a_ # list_\n\ngoal (1 subgoal):\n 1. (\\<And>ls' sub sep.\n        ls = ls' @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.distinct(1) rev_exhaust surj_pair)"], ["proof (state)\nthis:\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "moreover"], ["proof (state)\nthis:\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "have \"sep < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sep < x", "using split_req(2)[of ts x ls' sub sep rs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n\ngoal (1 subgoal):\n 1. sep < x", "using sorted_inorder_separators"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (1 subgoal):\n 1. sep < x", "using assms(1) assms(2) ls_tail_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. sep < x", "by auto"], ["proof (state)\nthis:\n  sep < x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "moreover"], ["proof (state)\nthis:\n  sep < x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "have \"sorted_less (inorder_list ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder_list ls)", "using assms sorted_wrt_append split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n  sorted_wrt ?P (?xs @ ?ys) =\n  (sorted_wrt ?P ?xs \\<and>\n   sorted_wrt ?P ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. ?P x y))\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. sorted_less (inorder_list ls)", "by fastforce"], ["proof (state)\nthis:\n  sorted_less (inorder_list ls)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       ins_list x (inorder (Node ts t)) =\n       inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "ultimately"], ["proof (chain)\npicking this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "using assms(2) split_conc[OF assms(1)]"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "using ins_list_sorted[of \"inorder_list ls' @ inorder sub\" sep]"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n  sorted_less ((inorder_list ls' @ inorder sub) @ [sep]) \\<Longrightarrow>\n  ins_list ?x ((inorder_list ls' @ inorder sub) @ sep # ?ys) =\n  (if ?x < sep then ins_list ?x (inorder_list ls' @ inorder sub) @ sep # ?ys\n   else (inorder_list ls' @ inorder sub) @ ins_list ?x (sep # ?ys))\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) =\n    inorder_list ls @ ins_list x (inorder_list rs @ inorder t)", "by auto"], ["proof (state)\nthis:\n  ins_list x (inorder (Node ts t)) =\n  inorder_list ls @ ins_list x (inorder_list rs @ inorder t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ins_list_split_right_general:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder_list ts)\"\n    and \"sep \\<noteq> x\"\n  shows \"ins_list x (inorder_list ((sub,sep)#rs) @ zs) = ins_list x (inorder sub) @ sep # inorder_list rs @ zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "from assms"], ["proof (chain)\npicking this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder_list ts)\n  sep \\<noteq> x", "have \"x < sep\""], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder_list ts)\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < sep", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n     sorted_less (inorder_list ts); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x < sep", "from assms"], ["proof (chain)\npicking this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder_list ts)\n  sep \\<noteq> x", "have \"sorted_less (separators ts)\""], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder_list ts)\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. sorted_less (separators ts)", "by (simp add: sorted_inorder_list_separators)"], ["proof (state)\nthis:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n     sorted_less (inorder_list ts); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x < sep", "then"], ["proof (chain)\npicking this:\n  sorted_less (separators ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. x < sep", "using split_req(3)"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n  \\<lbrakk>split ?xs ?p = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (separators ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?sep\n\ngoal (1 subgoal):\n 1. x < sep", "using assms"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n  \\<lbrakk>split ?xs ?p = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (separators ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?sep\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder_list ts)\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < sep", "by fastforce"], ["proof (state)\nthis:\n  x < sep\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < sep\n\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "moreover"], ["proof (state)\nthis:\n  x < sep\n\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "have \"sorted_less (inorder_pair (sub,sep))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder_pair (sub, sep))", "by (metis (no_types, lifting) assms(1) assms(2) concat.simps(2) concat_append list.simps(9) map_append sorted_wrt_append split_conc)"], ["proof (state)\nthis:\n  sorted_less (inorder_pair (sub, sep))\n\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "ultimately"], ["proof (chain)\npicking this:\n  x < sep\n  sorted_less (inorder_pair (sub, sep))", "show ?thesis"], ["proof (prove)\nusing this:\n  x < sep\n  sorted_less (inorder_pair (sub, sep))\n\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "using ins_list_sorted[of \"inorder sub\" \"sep\"]"], ["proof (prove)\nusing this:\n  x < sep\n  sorted_less (inorder_pair (sub, sep))\n  sorted_less (inorder sub @ [sep]) \\<Longrightarrow>\n  ins_list ?x (inorder sub @ sep # ?ys) =\n  (if ?x < sep then ins_list ?x (inorder sub) @ sep # ?ys\n   else inorder sub @ ins_list ?x (sep # ?ys))\n\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ zs", "by auto"], ["proof (state)\nthis:\n  ins_list x (inorder_list ((sub, sep) # rs) @ zs) =\n  ins_list x (inorder sub) @ sep # inorder_list rs @ zs\n\ngoal:\nNo subgoals!", "qed"], ["", "(* this fits the actual use cases better *)"], ["", "corollary ins_list_split_right:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n    and \"sep \\<noteq> x\"\n  shows \"ins_list x (inorder_list ((sub,sep)#rs) @ inorder t) = ins_list x (inorder sub) @ sep # inorder_list rs @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "using assms sorted_wrt_append split.ins_list_split_right_general split_axioms"], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n  sorted_wrt ?P (?xs @ ?ys) =\n  (sorted_wrt ?P ?xs \\<and>\n   sorted_wrt ?P ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. ?P x y))\n  \\<lbrakk>split ?split; ?split ?ts ?x = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (inorder_list ?ts); ?sep \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder_list ((?sub, ?sep) # ?rs) @ ?zs) =\n                    ins_list ?x (inorder ?sub) @\n                    ?sep # inorder_list ?rs @ ?zs\n  split split\n\ngoal (1 subgoal):\n 1. ins_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    ins_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "by fastforce"], ["", "(* a simple lemma, missing from the standard as of now *)"], ["", "lemma ins_list_idem_eq_isin: \"sorted_less xs \\<Longrightarrow> x \\<in> set xs \\<longleftrightarrow> (ins_list x xs = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less xs \\<Longrightarrow> (x \\<in> set xs) = (ins_list x xs = xs)", "apply(induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sorted_less [] \\<Longrightarrow> (x \\<in> set []) = (ins_list x [] = [])\n 2. \\<And>a xs.\n       \\<lbrakk>sorted_less xs \\<Longrightarrow>\n                (x \\<in> set xs) = (ins_list x xs = xs);\n        sorted_less (a # xs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<in> set (a # xs)) =\n                         (ins_list x (a # xs) = a # xs)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ins_list_contains_idem: \"\\<lbrakk>sorted_less xs; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> (ins_list x xs = xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> ins_list x xs = xs", "using ins_list_idem_eq_isin"], ["proof (prove)\nusing this:\n  sorted_less ?xs \\<Longrightarrow>\n  (?x \\<in> set ?xs) = (ins_list ?x ?xs = ?xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less xs; x \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> ins_list x xs = xs", "by auto"], ["", "declare node\\<^sub>i.simps [simp del]"], ["", "declare node\\<^sub>i_inorder [simp add]"], ["", "lemma ins_inorder: \"sorted_less (inorder t) \\<Longrightarrow> (inorder_up\\<^sub>i (ins k x t)) = ins_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)", "proof(induction k x t rule: ins.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       inorder_up\\<^sub>i (ins k x Leaf) = ins_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (1 k x)"], ["proof (state)\nthis:\n  sorted_less (inorder Leaf)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       sorted_less (inorder Leaf) \\<Longrightarrow>\n       inorder_up\\<^sub>i (ins k x Leaf) = ins_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sorted_less (inorder Leaf)", "show ?case"], ["proof (prove)\nusing this:\n  sorted_less (inorder Leaf)\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x Leaf) = ins_list x (inorder Leaf)", "by auto"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x Leaf) = ins_list x (inorder Leaf)\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x ?xb) =\n                    ins_list x (inorder ?xb)\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x ?xb) =\n                    ins_list x (inorder ?xb)\n  sorted_less (inorder (Node ts t))", "obtain ls rs where list_split: \"split ts x = (ls,rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x ?xb) =\n                    ins_list x (inorder ?xb)\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split ts x\")"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have list_conc: \"ts = ls@rs\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ts = ls @ rs", "using split.split_conc split_axioms"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  \\<lbrakk>split ?split; ?split ?xs ?p = (?ls, ?rs)\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ls @ ?rs\n  split split\n\ngoal (1 subgoal):\n 1. ts = ls @ rs", "by blast"], ["proof (state)\nthis:\n  ts = ls @ rs\n\ngoal (1 subgoal):\n 1. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = [];\n                    sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) =\n                                     ins_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder_up\\<^sub>i (ins k x xb) =\n                             ins_list x (inorder xb);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ts = ls @ rs", "show ?case"], ["proof (prove)\nusing this:\n  ts = ls @ rs\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = ls @ rs; rs = []\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = ls @ rs; rs = []\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "proof (cases \"ins k x t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (T\\<^sub>i a)"], ["proof (state)\nthis:\n  ins k x t = T\\<^sub>i a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x t = T\\<^sub>i a", "have IH:\"inorder a = ins_list x (inorder t)\""], ["proof (prove)\nusing this:\n  ins k x t = T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. inorder a = ins_list x (inorder t)", "using \"2.IH\"(1) \"2.prems\" list_split local.Nil sorted_inorder_induct_last"], ["proof (prove)\nusing this:\n  ins k x t = T\\<^sub>i a\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  rs = []\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder a = ins_list x (inorder t)", "by auto"], ["proof (state)\nthis:\n  inorder a = ins_list x (inorder t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder a", "using list_split T\\<^sub>i Nil"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  ins k x t = T\\<^sub>i a\n  rs = []\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder a", "by (auto simp add: list_conc)"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ (ins_list x (inorder t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder a = inorder_list ls @ ins_list x (inorder t)", "by (simp add: IH)"], ["proof (state)\nthis:\n  inorder_list ls @ inorder a = inorder_list ls @ ins_list x (inorder t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @ inorder a = inorder_list ls @ ins_list x (inorder t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = ins_list x (inorder (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ ins_list x (inorder t) =\n    ins_list x (inorder (Node ts t))", "using ins_list_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ ins_list x (inorder t) =\n    ins_list x (inorder (Node ts t))", "using \"2.prems\" list_split Nil"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  rs = []\n\ngoal (1 subgoal):\n 1. inorder_list ls @ ins_list x (inorder t) =\n    ins_list x (inorder (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @ ins_list x (inorder t) =\n  ins_list x (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>rs = []; ins k x t = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "."], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  ins k x t = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x t = Up\\<^sub>i l a r", "have IH:\"inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder t)\""], ["proof (prove)\nusing this:\n  ins k x t = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder t)", "using \"2.IH\"(1) \"2.prems\" list_split local.Nil sorted_inorder_induct_last"], ["proof (prove)\nusing this:\n  ins k x t = Up\\<^sub>i l a r\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x t) = ins_list x (inorder t)\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  rs = []\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder t)", "by auto"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r)", "using list_split Up\\<^sub>i Nil"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  ins k x t = Up\\<^sub>i l a r\n  rs = []\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r)", "by (auto simp add: list_conc)"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ ins_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r) =\n    inorder_list ls @ ins_list x (inorder t)", "using IH"], ["proof (prove)\nusing this:\n  inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder t)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r) =\n    inorder_list ls @ ins_list x (inorder t)", "by simp"], ["proof (state)\nthis:\n  inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r) =\n  inorder_list ls @ ins_list x (inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @ inorder_up\\<^sub>i (Up\\<^sub>i l a r) =\n  inorder_list ls @ ins_list x (inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = ins_list x (inorder (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ ins_list x (inorder t) =\n    ins_list x (inorder (Node ts t))", "using ins_list_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ ins_list x (inorder t) =\n    ins_list x (inorder (Node ts t))", "using \"2.prems\" list_split local.Nil"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  rs = []\n\ngoal (1 subgoal):\n 1. inorder_list ls @ ins_list x (inorder t) =\n    ins_list x (inorder (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @ ins_list x (inorder t) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>rs = []; ins k x t = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "."], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (Cons h list)"], ["proof (state)\nthis:\n  rs = h # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = h # list", "obtain sub sep where h_split: \"h = (sub,sep)\""], ["proof (prove)\nusing this:\n  rs = h # list\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        h = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases h)"], ["proof (state)\nthis:\n  h = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  h = (sub, sep)", "have sorted_inorder_sub: \"sorted_less (inorder sub)\""], ["proof (prove)\nusing this:\n  h = (sub, sep)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder sub)", "using \"2.prems\" list_conc local.Cons sorted_inorder_induct_subtree"], ["proof (prove)\nusing this:\n  h = (sub, sep)\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n  rs = h # list\n  sorted_less\n   (inorder (Node (?ls @ (?sub, ?sep) # ?rs) ?t)) \\<Longrightarrow>\n  sorted_less (inorder ?sub)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder sub)", "by fastforce"], ["proof (state)\nthis:\n  sorted_less (inorder sub)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ts = ls @ rs; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sorted_less (inorder sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_less (inorder sub)\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "proof(cases \"x = sep\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "case True"], ["proof (state)\nthis:\n  x = sep\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x = sep", "have \"x \\<in> set (inorder (Node ts t))\""], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. x \\<in> set (inorder (Node ts t))", "using list_conc h_split Cons"], ["proof (prove)\nusing this:\n  x = sep\n  ts = ls @ rs\n  h = (sub, sep)\n  rs = h # list\n\ngoal (1 subgoal):\n 1. x \\<in> set (inorder (Node ts t))", "by simp"], ["proof (state)\nthis:\n  x \\<in> set (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x \\<in> set (inorder (Node ts t))", "have \"ins_list x (inorder (Node ts t)) = inorder (Node ts t)\""], ["proof (prove)\nusing this:\n  x \\<in> set (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) = inorder (Node ts t)", "using \"2.prems\" ins_list_contains_idem"], ["proof (prove)\nusing this:\n  x \\<in> set (inorder (Node ts t))\n  sorted_less (inorder (Node ts t))\n  \\<lbrakk>sorted_less ?xs; ?x \\<in> set ?xs\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x ?xs = ?xs\n\ngoal (1 subgoal):\n 1. ins_list x (inorder (Node ts t)) = inorder (Node ts t)", "by blast"], ["proof (state)\nthis:\n  ins_list x (inorder (Node ts t)) = inorder (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  ins_list x (inorder (Node ts t)) = inorder (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_up\\<^sub>i (ins k x (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (Node ts t) = inorder_up\\<^sub>i (ins k x (Node ts t))", "using list_split h_split Cons True"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  h = (sub, sep)\n  rs = h # list\n  x = sep\n\ngoal (1 subgoal):\n 1. inorder (Node ts t) = inorder_up\\<^sub>i (ins k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder (Node ts t) = inorder_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_less (inorder sub); x = sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))\n 2. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  ins_list x (inorder (Node ts t)) =\n  inorder_up\\<^sub>i (ins k x (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  ins_list x (inorder (Node ts t)) =\n  inorder_up\\<^sub>i (ins k x (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "by simp"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (inorder sub); x \\<noteq> sep\\<rbrakk>\n    \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                      ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> sep", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "proof (cases \"ins k x sub\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (T\\<^sub>i a)"], ["proof (state)\nthis:\n  ins k x sub = T\\<^sub>i a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x sub = T\\<^sub>i a", "have IH:\"inorder a = ins_list x (inorder sub)\""], ["proof (prove)\nusing this:\n  ins k x sub = T\\<^sub>i a\n\ngoal (1 subgoal):\n 1. inorder a = ins_list x (inorder sub)", "using \"2.IH\"(2) \"2.prems\" list_split Cons sorted_inorder_sub h_split False"], ["proof (prove)\nusing this:\n  ins k x sub = T\\<^sub>i a\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x ?xb) =\n                    ins_list x (inorder ?xb)\n  sorted_less (inorder (Node ts t))\n  split ts x = (ls, rs)\n  rs = h # list\n  sorted_less (inorder sub)\n  h = (sub, sep)\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. inorder a = ins_list x (inorder sub)", "by auto"], ["proof (state)\nthis:\n  inorder a = ins_list x (inorder sub)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t", "using h_split False list_split T\\<^sub>i Cons"], ["proof (prove)\nusing this:\n  h = (sub, sep)\n  x \\<noteq> sep\n  split ts x = (ls, rs)\n  ins k x sub = T\\<^sub>i a\n  rs = h # list\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t", "by simp"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ ins_list x (inorder sub) @ sep # inorder_list list @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t =\n    inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t", "using IH"], ["proof (prove)\nusing this:\n  inorder a = ins_list x (inorder sub)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t =\n    inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t", "by simp"], ["proof (state)\nthis:\n  inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t =\n  inorder_list ls @\n  ins_list x (inorder sub) @ sep # inorder_list list @ inorder t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @ inorder a @ sep # inorder_list list @ inorder t =\n  inorder_list ls @\n  ins_list x (inorder sub) @ sep # inorder_list list @ inorder t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = ins_list x (inorder (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n    ins_list x (inorder (Node ts t))", "using ins_list_split ins_list_split_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n  \\<lbrakk>split ?ts ?x = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (inorder (Node ?ts ?t)); ?sep \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x\n                     (inorder_list ((?sub, ?sep) # ?rs) @ inorder ?t) =\n                    ins_list ?x (inorder ?sub) @\n                    ?sep # inorder_list ?rs @ inorder ?t\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n    ins_list x (inorder (Node ts t))", "using list_split \"2.prems\" Cons h_split False"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n  \\<lbrakk>split ?ts ?x = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (inorder (Node ?ts ?t)); ?sep \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x\n                     (inorder_list ((?sub, ?sep) # ?rs) @ inorder ?t) =\n                    ins_list ?x (inorder ?sub) @\n                    ?sep # inorder_list ?rs @ inorder ?t\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n  rs = h # list\n  h = (sub, sep)\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n    ins_list x (inorder (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @\n  ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n  ins_list x (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> sep; ins k x sub = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "."], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  ins k x sub = Up\\<^sub>i l a r", "have IH:\"inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder sub)\""], ["proof (prove)\nusing this:\n  ins k x sub = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder sub)", "using \"2.IH\"(2) False h_split list_split local.Cons sorted_inorder_sub"], ["proof (prove)\nusing this:\n  ins k x sub = Up\\<^sub>i l a r\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder_up\\<^sub>i (ins k x ?xb) =\n                    ins_list x (inorder ?xb)\n  x \\<noteq> sep\n  h = (sub, sep)\n  split ts x = (ls, rs)\n  rs = h # list\n  sorted_less (inorder sub)\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder sub)", "by auto"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder sub)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"inorder_up\\<^sub>i (ins k x (Node ts t)) = inorder_list ls @ inorder l @ a # inorder r  @ sep # inorder_list list @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    inorder_list ls @\n    inorder l @ a # inorder r @ sep # inorder_list list @ inorder t", "using h_split False list_split Up\\<^sub>i Cons"], ["proof (prove)\nusing this:\n  h = (sub, sep)\n  x \\<noteq> sep\n  split ts x = (ls, rs)\n  ins k x sub = Up\\<^sub>i l a r\n  rs = h # list\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    inorder_list ls @\n    inorder l @ a # inorder r @ sep # inorder_list list @ inorder t", "by simp"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  inorder_list ls @\n  inorder l @ a # inorder r @ sep # inorder_list list @ inorder t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  inorder_list ls @\n  inorder l @ a # inorder r @ sep # inorder_list list @ inorder t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ ins_list x (inorder sub) @ sep # inorder_list list @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @\n    inorder l @ a # inorder r @ sep # inorder_list list @ inorder t =\n    inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t", "using IH"], ["proof (prove)\nusing this:\n  inorder_up\\<^sub>i (Up\\<^sub>i l a r) = ins_list x (inorder sub)\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    inorder l @ a # inorder r @ sep # inorder_list list @ inorder t =\n    inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t", "by simp"], ["proof (state)\nthis:\n  inorder_list ls @\n  inorder l @ a # inorder r @ sep # inorder_list list @ inorder t =\n  inorder_list ls @\n  ins_list x (inorder sub) @ sep # inorder_list list @ inorder t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @\n  inorder l @ a # inorder r @ sep # inorder_list list @ inorder t =\n  inorder_list ls @\n  ins_list x (inorder sub) @ sep # inorder_list list @ inorder t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "have \"\\<dots> = ins_list x (inorder (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n    ins_list x (inorder (Node ts t))", "using ins_list_split ins_list_split_right"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n  \\<lbrakk>split ?ts ?x = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (inorder (Node ?ts ?t)); ?sep \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x\n                     (inorder_list ((?sub, ?sep) # ?rs) @ inorder ?t) =\n                    ins_list ?x (inorder ?sub) @\n                    ?sep # inorder_list ?rs @ inorder ?t\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n    ins_list x (inorder (Node ts t))", "using list_split \"2.prems\" Cons h_split False"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    ins_list ?x (inorder_list ?rs @ inorder ?t)\n  \\<lbrakk>split ?ts ?x = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (inorder (Node ?ts ?t)); ?sep \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ins_list ?x\n                     (inorder_list ((?sub, ?sep) # ?rs) @ inorder ?t) =\n                    ins_list ?x (inorder ?sub) @\n                    ?sep # inorder_list ?rs @ inorder ?t\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n  rs = h # list\n  h = (sub, sep)\n  x \\<noteq> sep\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n    ins_list x (inorder (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @\n  ins_list x (inorder sub) @ sep # inorder_list list @ inorder t =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>x \\<noteq> sep;\n        ins k x sub = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> inorder_up\\<^sub>i (ins k x (Node ts t)) =\n                         ins_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i (ins k x (Node ts t)) =\n    ins_list x (inorder (Node ts t))", "."], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder_up\\<^sub>i (ins k x (Node ts t)) =\n  ins_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["", "declare node\\<^sub>i.simps [simp add]"], ["", "declare node\\<^sub>i_inorder [simp del]"], ["", "thm ins.induct"], ["", "thm btree.induct"], ["", "(* wrapped up insert invariants *)"], ["", "lemma tree\\<^sub>i_bal: \"bal_up\\<^sub>i u \\<Longrightarrow> bal (tree\\<^sub>i u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i u \\<Longrightarrow> bal (tree\\<^sub>i u)", "apply(cases u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>bal_up\\<^sub>i u; u = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal (tree\\<^sub>i u)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>bal_up\\<^sub>i u; u = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (tree\\<^sub>i u)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tree\\<^sub>i_order: \"\\<lbrakk>k > 0; root_order_up\\<^sub>i k u\\<rbrakk> \\<Longrightarrow> root_order k (tree\\<^sub>i u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; root_order_up\\<^sub>i k u\\<rbrakk>\n    \\<Longrightarrow> root_order k (tree\\<^sub>i u)", "apply(cases u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>0 < k; root_order_up\\<^sub>i k u; u = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> root_order k (tree\\<^sub>i u)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>0 < k; root_order_up\\<^sub>i k u;\n        u = Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> root_order k (tree\\<^sub>i u)", "apply(auto simp add: order_impl_root_order)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tree\\<^sub>i_inorder: \"inorder_up\\<^sub>i u = inorder (tree\\<^sub>i u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_up\\<^sub>i u = inorder (tree\\<^sub>i u)", "apply (cases u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       u = T\\<^sub>i x1 \\<Longrightarrow>\n       inorder_up\\<^sub>i u = inorder (tree\\<^sub>i u)\n 2. \\<And>x21 x22 x23.\n       u = Up\\<^sub>i x21 x22 x23 \\<Longrightarrow>\n       inorder_up\\<^sub>i u = inorder (tree\\<^sub>i u)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insert_bal: \"bal t \\<Longrightarrow> bal (insert k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal t \\<Longrightarrow> bal (local.insert k x t)", "using ins_bal"], ["proof (prove)\nusing this:\n  bal ?t \\<Longrightarrow> bal_up\\<^sub>i (ins ?k ?x ?t)\n\ngoal (1 subgoal):\n 1. bal t \\<Longrightarrow> bal (local.insert k x t)", "by (simp add: tree\\<^sub>i_bal)"], ["", "lemma insert_order: \"\\<lbrakk>k > 0; root_order k t\\<rbrakk> \\<Longrightarrow> root_order k (insert k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; root_order k t\\<rbrakk>\n    \\<Longrightarrow> root_order k (local.insert k x t)", "using ins_root_order"], ["proof (prove)\nusing this:\n  root_order ?k ?t \\<Longrightarrow> root_order_up\\<^sub>i ?k (ins ?k ?x ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; root_order k t\\<rbrakk>\n    \\<Longrightarrow> root_order k (local.insert k x t)", "by (simp add: tree\\<^sub>i_order)"], ["", "lemma insert_inorder: \"sorted_less (inorder t) \\<Longrightarrow> inorder (insert k x t) = ins_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    inorder (local.insert k x t) = ins_list x (inorder t)", "using ins_inorder"], ["proof (prove)\nusing this:\n  sorted_less (inorder ?t) \\<Longrightarrow>\n  inorder_up\\<^sub>i (ins ?k ?x ?t) = ins_list ?x (inorder ?t)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder t) \\<Longrightarrow>\n    inorder (local.insert k x t) = ins_list x (inorder t)", "by (simp add: tree\\<^sub>i_inorder)"], ["", "text \"Deletion proofs\""], ["", "thm list.simps"], ["", "lemma rebalance_middle_tree_height:\n  assumes \"height t = height sub\"\n    and \"case rs of (rsub,rsep) # list \\<Rightarrow> height rsub = height t | [] \\<Rightarrow> True\"\n  shows \"height (rebalance_middle_tree k ls sub sep rs t) = height (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "proof (cases \"height t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. height t = 0 \\<Longrightarrow>\n    height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "case 0"], ["proof (state)\nthis:\n  height t = 0\n\ngoal (2 subgoals):\n 1. height t = 0 \\<Longrightarrow>\n    height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height t = 0", "have \"t = Leaf\" \"sub = Leaf\""], ["proof (prove)\nusing this:\n  height t = 0\n\ngoal (1 subgoal):\n 1. t = Leaf &&& sub = Leaf", "using height_Leaf assms"], ["proof (prove)\nusing this:\n  height t = 0\n  (height ?t = 0) = (?t = Leaf)\n  height t = height sub\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. t = Leaf &&& sub = Leaf", "by auto"], ["proof (state)\nthis:\n  t = Leaf\n  sub = Leaf\n\ngoal (2 subgoals):\n 1. height t = 0 \\<Longrightarrow>\n    height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  t = Leaf\n  sub = Leaf", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Leaf\n  sub = Leaf\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "by simp"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "case (Suc nat)"], ["proof (state)\nthis:\n  height t = Suc nat\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height t = Suc nat", "obtain tts tt where t_node: \"t = Node tts tt\""], ["proof (prove)\nusing this:\n  height t = Suc nat\n\ngoal (1 subgoal):\n 1. (\\<And>tts tt.\n        t = Node tts tt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using height_Leaf"], ["proof (prove)\nusing this:\n  height t = Suc nat\n  (height ?t = 0) = (?t = Leaf)\n\ngoal (1 subgoal):\n 1. (\\<And>tts tt.\n        t = Node tts tt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases t) simp"], ["proof (state)\nthis:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  t = Node tts tt", "obtain mts mt where sub_node: \"sub = Node mts mt\""], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t = Node tts tt\n  height t = height sub\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases sub) simp"], ["proof (state)\nthis:\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       height t = Suc nat \\<Longrightarrow>\n       height (rebalance_middle_tree k ls sub sep rs t) =\n       height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  sub = Node mts mt", "show ?thesis"], ["proof (prove)\nusing this:\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "proof (cases \"length mts \\<ge> k \\<and> length tts \\<ge> k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)", "case False"], ["proof (state)\nthis:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  rs = []", "have \"height_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#tts) tt) = height (Node (mts@(mt,sep)#tts) tt)\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n    height (Node (mts @ (mt, sep) # tts) tt)", "using node\\<^sub>i_height"], ["proof (prove)\nusing this:\n  rs = []\n  height_up\\<^sub>i (node\\<^sub>i ?k ?ts ?t) = height (Node ?ts ?t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n    height (Node (mts @ (mt, sep) # tts) tt)", "by blast"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  height (Node (mts @ (mt, sep) # tts) tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "also"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  height (Node (mts @ (mt, sep) # tts) tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "have \"\\<dots> = max (height t) (height sub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (mts @ (mt, sep) # tts) tt) = max (height t) (height sub)", "by (metis assms(1) height_up\\<^sub>i.simps(2) height_list_split sub_node t_node)"], ["proof (state)\nthis:\n  height (Node (mts @ (mt, sep) # tts) tt) = max (height t) (height sub)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "finally"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)", "have height_max: \"height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = max (height t) (height sub)\""], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n    max (height t) (height sub)", "by simp"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "proof (cases \"node\\<^sub>i k (mts@(mt,sep)#tts) tt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "case (T\\<^sub>i u)"], ["proof (state)\nthis:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i u\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i u", "have \"height u = max (height t) (height sub)\""], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i u\n\ngoal (1 subgoal):\n 1. height u = max (height t) (height sub)", "using height_max"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i u\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)\n\ngoal (1 subgoal):\n 1. height u = max (height t) (height sub)", "by simp"], ["proof (state)\nthis:\n  height u = max (height t) (height sub)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height u = max (height t) (height sub)", "have \"height (Node ls u) = height (Node (ls@[(sub,sep)]) t)\""], ["proof (prove)\nusing this:\n  height u = max (height t) (height sub)\n\ngoal (1 subgoal):\n 1. height (Node ls u) = height (Node (ls @ [(sub, sep)]) t)", "by (induction ls) (auto simp add: max.commute)"], ["proof (state)\nthis:\n  height (Node ls u) = height (Node (ls @ [(sub, sep)]) t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height (Node ls u) = height (Node (ls @ [(sub, sep)]) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node ls u) = height (Node (ls @ [(sub, sep)]) t)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "using Nil False T\\<^sub>i"], ["proof (prove)\nusing this:\n  height (Node ls u) = height (Node (ls @ [(sub, sep)]) t)\n  rs = []\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i u\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "by (simp add: sub_node t_node)"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = Up\\<^sub>i l a r", "have \"height (Node (ls@[(sub,sep)]) t) =  height (Node (ls@[(l,a)]) r)\""], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. height (Node (ls @ [(sub, sep)]) t) = height (Node (ls @ [(l, a)]) r)", "using assms(1) height_max"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = Up\\<^sub>i l a r\n  height t = height sub\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  max (height t) (height sub)\n\ngoal (1 subgoal):\n 1. height (Node (ls @ [(sub, sep)]) t) = height (Node (ls @ [(l, a)]) r)", "by (induction ls) auto"], ["proof (state)\nthis:\n  height (Node (ls @ [(sub, sep)]) t) = height (Node (ls @ [(l, a)]) r)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                max (height t) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height (Node (ls @ [(sub, sep)]) t) = height (Node (ls @ [(l, a)]) r)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node (ls @ [(sub, sep)]) t) = height (Node (ls @ [(l, a)]) r)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "using Up\\<^sub>i Nil sub_node t_node"], ["proof (prove)\nusing this:\n  height (Node (ls @ [(sub, sep)]) t) = height (Node (ls @ [(l, a)]) r)\n  node\\<^sub>i k (mts @ (mt, sep) # tts) tt = Up\\<^sub>i l a r\n  rs = []\n  sub = Node mts mt\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "by auto"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "case (Cons a list)"], ["proof (state)\nthis:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  rs = a # list", "obtain rsub rsep where a_split: \"a = (rsub, rsep)\""], ["proof (prove)\nusing this:\n  rs = a # list\n\ngoal (1 subgoal):\n 1. (\\<And>rsub rsep.\n        a = (rsub, rsep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (rsub, rsep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  a = (rsub, rsep)", "obtain rts rt where r_node: \"rsub = Node rts rt\""], ["proof (prove)\nusing this:\n  a = (rsub, rsep)\n\ngoal (1 subgoal):\n 1. (\\<And>rts rt.\n        rsub = Node rts rt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) Cons height_Leaf Suc"], ["proof (prove)\nusing this:\n  a = (rsub, rsep)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  rs = a # list\n  (height ?t = 0) = (?t = Leaf)\n  height t = Suc nat\n\ngoal (1 subgoal):\n 1. (\\<And>rts rt.\n        rsub = Node rts rt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rsub) simp_all"], ["proof (state)\nthis:\n  rsub = Node rts rt\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  rsub = Node rts rt", "have \"height_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#rts) rt) = height (Node (mts@(mt,sep)#rts) rt)\""], ["proof (prove)\nusing this:\n  rsub = Node rts rt\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n    height (Node (mts @ (mt, sep) # rts) rt)", "using node\\<^sub>i_height"], ["proof (prove)\nusing this:\n  rsub = Node rts rt\n  height_up\\<^sub>i (node\\<^sub>i ?k ?ts ?t) = height (Node ?ts ?t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n    height (Node (mts @ (mt, sep) # rts) rt)", "by blast"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height (Node (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "also"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height (Node (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "have \"\\<dots> = max (height rsub) (height sub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (mts @ (mt, sep) # rts) rt) =\n    max (height rsub) (height sub)", "by (metis r_node height_up\\<^sub>i.simps(2) height_list_split max.commute sub_node)"], ["proof (state)\nthis:\n  height (Node (mts @ (mt, sep) # rts) rt) = max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "finally"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)", "have height_max: \"height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) = max (height rsub) (height sub)\""], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n    max (height rsub) (height sub)", "by simp"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "proof (cases \"node\\<^sub>i k (mts@(mt,sep)#rts) rt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "case (T\\<^sub>i u)"], ["proof (state)\nthis:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u", "have \"height u = max (height rsub) (height sub)\""], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n\ngoal (1 subgoal):\n 1. height u = max (height rsub) (height sub)", "using height_max"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. height u = max (height rsub) (height sub)", "by simp"], ["proof (state)\nthis:\n  height u = max (height rsub) (height sub)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  height u = max (height rsub) (height sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  height u = max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "using T\\<^sub>i False Cons r_node a_split sub_node t_node"], ["proof (prove)\nusing this:\n  height u = max (height rsub) (height sub)\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  rs = a # list\n  rsub = Node rts rt\n  a = (rsub, rsep)\n  sub = Node mts mt\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "by auto"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r", "have height_max: \"max (height l) (height r) = max (height rsub) (height sub)\""], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. max (height l) (height r) = max (height rsub) (height sub)", "using height_max"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. max (height l) (height r) = max (height rsub) (height sub)", "by auto"], ["proof (state)\nthis:\n  max (height l) (height r) = max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                max (height rsub) (height sub);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                         height (Node (ls @ (sub, sep) # rs) t)", "then"], ["proof (chain)\npicking this:\n  max (height l) (height r) = max (height rsub) (height sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  max (height l) (height r) = max (height rsub) (height sub)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "using Cons a_split r_node Up\\<^sub>i sub_node t_node"], ["proof (prove)\nusing this:\n  max (height l) (height r) = max (height rsub) (height sub)\n  rs = a__ # list\n  a__ = (rsub, rsep)\n  rsub = Node rts rt\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n  sub = Node mts mt\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub sep rs t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "by auto"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> height (rebalance_middle_tree k ls sub sep rs t) =\n                      height (Node (ls @ (sub, sep) # rs) t)", "qed (simp add: sub_node t_node)"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub sep rs t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rebalance_last_tree_height:\n  assumes \"height t = height sub\"\n    and \"ts = list@[(sub,sep)]\"\n  shows \"height (rebalance_last_tree k ts t) = height (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (rebalance_last_tree k ts t) = height (Node ts t)", "using rebalance_middle_tree_height assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>height ?t = height ?sub;\n   case ?rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height ?t\\<rbrakk>\n  \\<Longrightarrow> height (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t) =\n                    height (Node (?ls @ (?sub, ?sep) # ?rs) ?t)\n  height t = height sub\n  ts = list @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. height (rebalance_last_tree k ts t) = height (Node ts t)", "by auto"], ["", "lemma split_max_height:\n  assumes \"split_max k t = (sub,sep)\"\n    and \"nonempty_lasttreebal t\"\n    and \"t \\<noteq> Leaf\"\n  shows \"height sub = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height sub = height t", "using assms"], ["proof (prove)\nusing this:\n  split_max k t = (sub, sep)\n  nonempty_lasttreebal t\n  t \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. height sub = height t", "proof(induction t arbitrary: k sub sep)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k sub sep.\n       \\<lbrakk>split_max k Leaf = (sub, sep); nonempty_lasttreebal Leaf;\n        Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height Leaf\n 2. \\<And>x1 t k sub sep.\n       \\<lbrakk>\\<And>x1a x1aa k sub sep.\n                   \\<lbrakk>x1a \\<in> set x1;\n                    x1aa \\<in> Basic_BNFs.fsts x1a;\n                    split_max k x1aa = (sub, sep);\n                    nonempty_lasttreebal x1aa; x1aa \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> height sub = height x1aa;\n        \\<And>k sub sep.\n           \\<lbrakk>split_max k t = (sub, sep); nonempty_lasttreebal t;\n            t \\<noteq> Leaf\\<rbrakk>\n           \\<Longrightarrow> height sub = height t;\n        split_max k (Node x1 t) = (sub, sep);\n        nonempty_lasttreebal (Node x1 t); Node x1 t \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node x1 t)", "case Node1: (Node tts tt)"], ["proof (state)\nthis:\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n\ngoal (2 subgoals):\n 1. \\<And>k sub sep.\n       \\<lbrakk>split_max k Leaf = (sub, sep); nonempty_lasttreebal Leaf;\n        Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height Leaf\n 2. \\<And>x1 t k sub sep.\n       \\<lbrakk>\\<And>x1a x1aa k sub sep.\n                   \\<lbrakk>x1a \\<in> set x1;\n                    x1aa \\<in> Basic_BNFs.fsts x1a;\n                    split_max k x1aa = (sub, sep);\n                    nonempty_lasttreebal x1aa; x1aa \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> height sub = height x1aa;\n        \\<And>k sub sep.\n           \\<lbrakk>split_max k t = (sub, sep); nonempty_lasttreebal t;\n            t \\<noteq> Leaf\\<rbrakk>\n           \\<Longrightarrow> height sub = height t;\n        split_max k (Node x1 t) = (sub, sep);\n        nonempty_lasttreebal (Node x1 t); Node x1 t \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node x1 t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf", "obtain ls tsub tsep where tts_split: \"tts = ls@[(tsub,tsep)]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. (\\<And>ls tsub tsep.\n        tts = ls @ [(tsub, tsep)] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tts = ls @ [(tsub, tsep)]\n\ngoal (2 subgoals):\n 1. \\<And>k sub sep.\n       \\<lbrakk>split_max k Leaf = (sub, sep); nonempty_lasttreebal Leaf;\n        Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height Leaf\n 2. \\<And>x1 t k sub sep.\n       \\<lbrakk>\\<And>x1a x1aa k sub sep.\n                   \\<lbrakk>x1a \\<in> set x1;\n                    x1aa \\<in> Basic_BNFs.fsts x1a;\n                    split_max k x1aa = (sub, sep);\n                    nonempty_lasttreebal x1aa; x1aa \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> height sub = height x1aa;\n        \\<And>k sub sep.\n           \\<lbrakk>split_max k t = (sub, sep); nonempty_lasttreebal t;\n            t \\<noteq> Leaf\\<rbrakk>\n           \\<Longrightarrow> height sub = height t;\n        split_max k (Node x1 t) = (sub, sep);\n        nonempty_lasttreebal (Node x1 t); Node x1 t \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node x1 t)", "then"], ["proof (chain)\npicking this:\n  tts = ls @ [(tsub, tsep)]", "show ?case"], ["proof (prove)\nusing this:\n  tts = ls @ [(tsub, tsep)]\n\ngoal (1 subgoal):\n 1. height sub = height (Node tts tt)", "proof (cases tt)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Leaf\\<rbrakk>\n    \\<Longrightarrow> height sub = height (Node tts tt)\n 2. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "case Leaf"], ["proof (state)\nthis:\n  tt = Leaf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Leaf\\<rbrakk>\n    \\<Longrightarrow> height sub = height (Node tts tt)\n 2. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "then"], ["proof (chain)\npicking this:\n  tt = Leaf", "have \"height (Node (ls@[(tsub,tsep)]) tt) = max (height (Node ls tsub)) (Suc (height tt))\""], ["proof (prove)\nusing this:\n  tt = Leaf\n\ngoal (1 subgoal):\n 1. height (Node (ls @ [(tsub, tsep)]) tt) =\n    max (height (Node ls tsub)) (Suc (height tt))", "using height_btree_last height_btree_order"], ["proof (prove)\nusing this:\n  tt = Leaf\n  height (Node ((?sub, ?x) # ?ts) ?t) =\n  max (height (Node ?ts ?sub)) (Suc (height ?t))\n  height (Node (?ls @ [?a]) ?t) = height (Node (?a # ?ls) ?t)\n\ngoal (1 subgoal):\n 1. height (Node (ls @ [(tsub, tsep)]) tt) =\n    max (height (Node ls tsub)) (Suc (height tt))", "by metis"], ["proof (state)\nthis:\n  height (Node (ls @ [(tsub, tsep)]) tt) =\n  max (height (Node ls tsub)) (Suc (height tt))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Leaf\\<rbrakk>\n    \\<Longrightarrow> height sub = height (Node tts tt)\n 2. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "moreover"], ["proof (state)\nthis:\n  height (Node (ls @ [(tsub, tsep)]) tt) =\n  max (height (Node ls tsub)) (Suc (height tt))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Leaf\\<rbrakk>\n    \\<Longrightarrow> height sub = height (Node tts tt)\n 2. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "have \"split_max k (Node tts tt) = (Node ls tsub, tsep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_max k (Node tts tt) = (Node ls tsub, tsep)", "using Leaf Node1 tts_split"], ["proof (prove)\nusing this:\n  tt = Leaf\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n  tts = ls @ [(tsub, tsep)]\n\ngoal (1 subgoal):\n 1. split_max k (Node tts tt) = (Node ls tsub, tsep)", "by auto"], ["proof (state)\nthis:\n  split_max k (Node tts tt) = (Node ls tsub, tsep)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Leaf\\<rbrakk>\n    \\<Longrightarrow> height sub = height (Node tts tt)\n 2. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "ultimately"], ["proof (chain)\npicking this:\n  height (Node (ls @ [(tsub, tsep)]) tt) =\n  max (height (Node ls tsub)) (Suc (height tt))\n  split_max k (Node tts tt) = (Node ls tsub, tsep)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node (ls @ [(tsub, tsep)]) tt) =\n  max (height (Node ls tsub)) (Suc (height tt))\n  split_max k (Node tts tt) = (Node ls tsub, tsep)\n\ngoal (1 subgoal):\n 1. height sub = height (Node tts tt)", "using Leaf Node1 height_Leaf max_def"], ["proof (prove)\nusing this:\n  height (Node (ls @ [(tsub, tsep)]) tt) =\n  max (height (Node ls tsub)) (Suc (height tt))\n  split_max k (Node tts tt) = (Node ls tsub, tsep)\n  tt = Leaf\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n  (height ?t = 0) = (?t = Leaf)\n  max ?a ?b = (if ?a \\<le> ?b then ?b else ?a)\n\ngoal (1 subgoal):\n 1. height sub = height (Node tts tt)", "by auto"], ["proof (state)\nthis:\n  height sub = height (Node tts tt)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "case Node2: (Node l a)"], ["proof (state)\nthis:\n  tt = Node l a\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "then"], ["proof (chain)\npicking this:\n  tt = Node l a", "obtain subsub subsep where sub_split: \"split_max k tt = (subsub,subsep)\""], ["proof (prove)\nusing this:\n  tt = Node l a\n\ngoal (1 subgoal):\n 1. (\\<And>subsub subsep.\n        split_max k tt = (subsub, subsep) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_max k tt\")"], ["proof (state)\nthis:\n  split_max k tt = (subsub, subsep)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "then"], ["proof (chain)\npicking this:\n  split_max k tt = (subsub, subsep)", "have \"height subsub = height tt\""], ["proof (prove)\nusing this:\n  split_max k tt = (subsub, subsep)\n\ngoal (1 subgoal):\n 1. height subsub = height tt", "using Node1 Node2"], ["proof (prove)\nusing this:\n  split_max k tt = (subsub, subsep)\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n  tt = Node l a\n\ngoal (1 subgoal):\n 1. height subsub = height tt", "by auto"], ["proof (state)\nthis:\n  height subsub = height tt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "moreover"], ["proof (state)\nthis:\n  height subsub = height tt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "have \"split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)", "using Node1 Node2 tts_split sub_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n  tt = Node l a\n  tts = ls @ [(tsub, tsep)]\n  split_max k tt = (subsub, subsep)\n\ngoal (1 subgoal):\n 1. split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)", "by auto"], ["proof (state)\nthis:\n  split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>tts = ls @ [(tsub, tsep)]; tt = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> height sub = height (Node tts tt)", "ultimately"], ["proof (chain)\npicking this:\n  height subsub = height tt\n  split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)", "show ?thesis"], ["proof (prove)\nusing this:\n  height subsub = height tt\n  split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)\n\ngoal (1 subgoal):\n 1. height sub = height (Node tts tt)", "using rebalance_last_tree_height Node1 Node2"], ["proof (prove)\nusing this:\n  height subsub = height tt\n  split_max k (Node tts tt) = (rebalance_last_tree k tts subsub, subsep)\n  \\<lbrakk>height ?t = height ?sub; ?ts = ?list @ [(?sub, ?sep)]\\<rbrakk>\n  \\<Longrightarrow> height (rebalance_last_tree ?k ?ts ?t) =\n                    height (Node ?ts ?t)\n  \\<lbrakk>?x1a \\<in> set tts; ?x1aa \\<in> Basic_BNFs.fsts ?x1a;\n   split_max ?k ?x1aa = (?sub, ?sep); nonempty_lasttreebal ?x1aa;\n   ?x1aa \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?x1aa\n  \\<lbrakk>split_max ?k tt = (?sub, ?sep); nonempty_lasttreebal tt;\n   tt \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height tt\n  split_max k (Node tts tt) = (sub, sep)\n  nonempty_lasttreebal (Node tts tt)\n  Node tts tt \\<noteq> Leaf\n  tt = Node l a\n\ngoal (1 subgoal):\n 1. height sub = height (Node tts tt)", "by auto"], ["proof (state)\nthis:\n  height sub = height (Node tts tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height sub = height (Node tts tt)\n\ngoal (1 subgoal):\n 1. \\<And>k sub sep.\n       \\<lbrakk>split_max k Leaf = (sub, sep); nonempty_lasttreebal Leaf;\n        Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> height sub = height Leaf", "qed auto"], ["", "lemma order_bal_nonempty_lasttreebal: \"\\<lbrakk>k > 0; root_order k t; bal t\\<rbrakk> \\<Longrightarrow> nonempty_lasttreebal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n    \\<Longrightarrow> nonempty_lasttreebal t", "proof(induction k t rule: order.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "case (2 k ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (subtrees ts); 0 < k; root_order k ?x;\n   bal ?x\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal ?x\n  \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal t\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?x \\<in> set (subtrees ts); 0 < k; root_order k ?x;\n   bal ?x\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal ?x\n  \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal t\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)", "have \"length ts > 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (subtrees ts); 0 < k; root_order k ?x;\n   bal ?x\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal ?x\n  \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal t\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. 0 < length ts", "by auto"], ["proof (state)\nthis:\n  0 < length ts\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "then"], ["proof (chain)\npicking this:\n  0 < length ts", "obtain ls tsub tsep where ts_split: \"ts = (ls@[(tsub,tsep)])\""], ["proof (prove)\nusing this:\n  0 < length ts\n\ngoal (1 subgoal):\n 1. (\\<And>ls tsub tsep.\n        ts = ls @ [(tsub, tsep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis eq_fst_iff length_greater_0_conv snoc_eq_iff_butlast)"], ["proof (state)\nthis:\n  ts = ls @ [(tsub, tsep)]\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "moreover"], ["proof (state)\nthis:\n  ts = ls @ [(tsub, tsep)]\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "have \"height tsub = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height tsub = height t", "using \"2.prems\"(3) ts_split"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n  ts = ls @ [(tsub, tsep)]\n\ngoal (1 subgoal):\n 1. height tsub = height t", "by auto"], ["proof (state)\nthis:\n  height tsub = height t\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "moreover"], ["proof (state)\nthis:\n  height tsub = height t\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "have \"nonempty_lasttreebal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonempty_lasttreebal t", "using 2 order_impl_root_order"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> set (subtrees ts); 0 < k; root_order k ?x;\n   bal ?x\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal ?x\n  \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal t\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  \\<lbrakk>0 < ?k; order ?k ?t\\<rbrakk> \\<Longrightarrow> root_order ?k ?t\n\ngoal (1 subgoal):\n 1. nonempty_lasttreebal t", "by auto"], ["proof (state)\nthis:\n  nonempty_lasttreebal t\n\ngoal (2 subgoals):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf\n 2. \\<And>k ts t.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set (subtrees ts); 0 < k;\n                    root_order k x; bal x\\<rbrakk>\n                   \\<Longrightarrow> nonempty_lasttreebal x;\n        \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n        \\<Longrightarrow> nonempty_lasttreebal t;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal (Node ts t)", "ultimately"], ["proof (chain)\npicking this:\n  ts = ls @ [(tsub, tsep)]\n  height tsub = height t\n  nonempty_lasttreebal t", "show ?case"], ["proof (prove)\nusing this:\n  ts = ls @ [(tsub, tsep)]\n  height tsub = height t\n  nonempty_lasttreebal t\n\ngoal (1 subgoal):\n 1. nonempty_lasttreebal (Node ts t)", "by simp"], ["proof (state)\nthis:\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> nonempty_lasttreebal Leaf", "qed simp"], ["", "lemma bal_sub_height: \"bal (Node (ls@a#rs) t) \\<Longrightarrow> (case rs of [] \\<Rightarrow> True | (sub,sep)#_ \\<Rightarrow> height sub = height t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (ls @ a # rs) t) \\<Longrightarrow>\n    case rs of [] \\<Rightarrow> True\n    | (sub, sep) # x \\<Rightarrow> height sub = height t", "by (cases rs) (auto)"], ["", "lemma del_height: \"\\<lbrakk>k > 0; root_order k t; bal t\\<rbrakk> \\<Longrightarrow> height (del k x t) = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; root_order k t; bal t\\<rbrakk>\n    \\<Longrightarrow> height (del k x t) = height t", "proof(induction k x t rule: del.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> height (del k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> height (del k x t) = height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> height (del k x xb) = height xb;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> height (del k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> height (del k x t) = height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> height (del k x xb) = height xb;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)", "obtain ls list where list_split: \"split ts x = (ls, list)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>ls list.\n        split ts x = (ls, list) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split ts x\")"], ["proof (state)\nthis:\n  split ts x = (ls, list)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> height (del k x Leaf) = height Leaf\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> height (del k x t) = height t;\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> height (del k x xb) = height xb;\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, list)", "show ?case"], ["proof (prove)\nusing this:\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "proof(cases list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "case Nil"], ["proof (state)\nthis:\n  list = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  list = []", "have \"height (del k x t) = height t\""], ["proof (prove)\nusing this:\n  list = []\n\ngoal (1 subgoal):\n 1. height (del k x t) = height t", "using 2 list_split order_bal_nonempty_lasttreebal"], ["proof (prove)\nusing this:\n  list = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal ?t\n\ngoal (1 subgoal):\n 1. height (del k x t) = height t", "by (simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  height (del k x t) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "moreover"], ["proof (state)\nthis:\n  height (del k x t) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "obtain lls sub sep where \"ls = lls@[(sub,sep)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lls sub sep.\n        ls = lls @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using split_conc 2 list_split Nil"], ["proof (prove)\nusing this:\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n  list = []\n\ngoal (1 subgoal):\n 1. (\\<And>lls sub sep.\n        ls = lls @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Nil2 nonempty_lasttreebal.simps(2) order_bal_nonempty_lasttreebal)"], ["proof (state)\nthis:\n  ls = lls @ [(sub, sep)]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "moreover"], ["proof (state)\nthis:\n  ls = lls @ [(sub, sep)]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "have \"Node ls t = Node ts t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Node ls t = Node ts t", "using split_conc Nil list_split"], ["proof (prove)\nusing this:\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n  list = []\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. Node ls t = Node ts t", "by auto"], ["proof (state)\nthis:\n  Node ls t = Node ts t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "ultimately"], ["proof (chain)\npicking this:\n  height (del k x t) = height t\n  ls = lls @ [(sub, sep)]\n  Node ls t = Node ts t", "show ?thesis"], ["proof (prove)\nusing this:\n  height (del k x t) = height t\n  ls = lls @ [(sub, sep)]\n  Node ls t = Node ts t\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "using rebalance_last_tree_height 2 list_split Nil split_conc"], ["proof (prove)\nusing this:\n  height (del k x t) = height t\n  ls = lls @ [(sub, sep)]\n  Node ls t = Node ts t\n  \\<lbrakk>height ?t = height ?sub; ?ts = ?list @ [(?sub, ?sep)]\\<rbrakk>\n  \\<Longrightarrow> height (rebalance_last_tree ?k ?ts ?t) =\n                    height (Node ?ts ?t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n  list = []\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "by (auto simp add: max.assoc sup_nat_def max_def)"], ["proof (state)\nthis:\n  height (del k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "case (Cons a rs)"], ["proof (state)\nthis:\n  list = a # rs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  list = a # rs", "have rs_height: \"case rs of [] \\<Rightarrow> True | (rsub,rsep)#_ \\<Rightarrow> height rsub = height t\""], ["proof (prove)\nusing this:\n  list = a # rs\n\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # x \\<Rightarrow> height rsub = height t", "(* notice the difference if rsub and t are switched *)"], ["proof (prove)\nusing this:\n  list = a # rs\n\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # x \\<Rightarrow> height rsub = height t", "using \"2.prems\"(3) bal_sub_height list_split split_conc"], ["proof (prove)\nusing this:\n  list = a # rs\n  bal (Node ts t)\n  bal (Node (?ls @ ?a # ?rs) ?t) \\<Longrightarrow>\n  case ?rs of [] \\<Rightarrow> True\n  | (sub, sep) # x \\<Rightarrow> height sub = height ?t\n  split ts x = (ls, list)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # x \\<Rightarrow> height rsub = height t", "by blast"], ["proof (state)\nthis:\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "from Cons"], ["proof (chain)\npicking this:\n  list = a # rs", "obtain sub sep where a_split: \"a = (sub,sep)\""], ["proof (prove)\nusing this:\n  list = a # rs\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        a = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "consider (sep_n_x) \"sep \\<noteq> x\" |\n      (sep_x_Leaf) \"sep = x \\<and> sub = Leaf\" |\n      (sep_x_Node) \"sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using btree.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Leaf \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = Node x21 x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "case sep_n_x"], ["proof (state)\nthis:\n  sep \\<noteq> x\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "have height_t_sub: \"height t = height sub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = height sub", "using \"2.prems\"(3) a_split list_split local.Cons split.split_set(1) split_axioms"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n  a = (sub, sep)\n  split ts x = (ls, list)\n  list = a # rs\n  \\<lbrakk>split ?split; ?split ?ts ?z = (?ls, (?a, ?b) # ?rs)\\<rbrakk>\n  \\<Longrightarrow> (?a, ?b) \\<in> set ?ts\n  split split\n\ngoal (1 subgoal):\n 1. height t = height sub", "by fastforce"], ["proof (state)\nthis:\n  height t = height sub\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "have height_t_del: \"height (del k x sub) = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (del k x sub) = height t", "by (metis \"2.IH\"(2) \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) a_split bal.simps(2) list_split local.Cons order_impl_root_order root_order.simps(2) sep_n_x some_child_sub(1) split_set(1))"], ["proof (state)\nthis:\n  height (del k x sub) = height t\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height (del k x sub) = height t", "have \"height (rebalance_middle_tree k ls (del k x sub) sep rs t) = height (Node (ls@((del k x sub),sep)#rs) t)\""], ["proof (prove)\nusing this:\n  height (del k x sub) = height t\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    height (Node (ls @ (del k x sub, sep) # rs) t)", "using rs_height rebalance_middle_tree_height"], ["proof (prove)\nusing this:\n  height (del k x sub) = height t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<lbrakk>height ?t = height ?sub;\n   case ?rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height ?t\\<rbrakk>\n  \\<Longrightarrow> height (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t) =\n                    height (Node (?ls @ (?sub, ?sep) # ?rs) ?t)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    height (Node (ls @ (del k x sub, sep) # rs) t)", "by simp"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  height (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "also"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  height (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "have \"\\<dots> = height (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (ls @ (del k x sub, sep) # rs) t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "using height_t_sub \"2.prems\" height_t_del"], ["proof (prove)\nusing this:\n  height t = height sub\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  height (del k x sub) = height t\n\ngoal (1 subgoal):\n 1. height (Node (ls @ (del k x sub, sep) # rs) t) =\n    height (Node (ls @ (sub, sep) # rs) t)", "by auto"], ["proof (state)\nthis:\n  height (Node (ls @ (del k x sub, sep) # rs) t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "also"], ["proof (state)\nthis:\n  height (Node (ls @ (del k x sub, sep) # rs) t) =\n  height (Node (ls @ (sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "have \"\\<dots> = height (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub, sep) # rs) t) = height (Node ts t)", "using 2 a_split sep_n_x list_split Cons split_set(1) split_conc"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  a = (sub, sep)\n  sep \\<noteq> x\n  split ts x = (ls, list)\n  list = a # rs\n  split ?ts ?z = (?ls, (?a, ?b) # ?rs) \\<Longrightarrow>\n  (?a, ?b) \\<in> set ?ts\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub, sep) # rs) t) = height (Node ts t)", "by auto"], ["proof (state)\nthis:\n  height (Node (ls @ (sub, sep) # rs) t) = height (Node ts t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "finally"], ["proof (chain)\npicking this:\n  height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  height (Node ts t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  height (Node ts t)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "using sep_n_x Cons a_split list_split 2"], ["proof (prove)\nusing this:\n  height (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  height (Node ts t)\n  sep \\<noteq> x\n  list = a # rs\n  a = (sub, sep)\n  split ts x = (ls, list)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "by simp"], ["proof (state)\nthis:\n  height (del k x (Node ts t)) = height (Node ts t)\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "case sep_x_Leaf"], ["proof (state)\nthis:\n  sep = x \\<and> sub = Leaf\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  sep = x \\<and> sub = Leaf", "have \"height (Node ts t) = height (Node (ls@rs) t)\""], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n\ngoal (1 subgoal):\n 1. height (Node ts t) = height (Node (ls @ rs) t)", "using bal_split_last(2) \"2.prems\"(3) a_split list_split Cons split_conc"], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n  bal (Node (?ls @ (?sub, ?sep) # ?rs) ?t) \\<Longrightarrow>\n  height (Node (?ls @ (?sub, ?sep) # ?rs) ?t) = height (Node (?ls @ ?rs) ?t)\n  bal (Node ts t)\n  a = (sub, sep)\n  split ts x = (ls, list)\n  list = a # rs\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. height (Node ts t) = height (Node (ls @ rs) t)", "by metis"], ["proof (state)\nthis:\n  height (Node ts t) = height (Node (ls @ rs) t)\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height (Node ts t) = height (Node (ls @ rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (Node ts t) = height (Node (ls @ rs) t)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "using a_split list_split Cons sep_x_Leaf 2"], ["proof (prove)\nusing this:\n  height (Node ts t) = height (Node (ls @ rs) t)\n  a = (sub, sep)\n  split ts x = (ls, list)\n  list = a # rs\n  sep = x \\<and> sub = Leaf\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "by auto"], ["proof (state)\nthis:\n  height (del k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "case sep_x_Node"], ["proof (state)\nthis:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)", "obtain sts st where sub_node: \"sub = Node sts st\""], ["proof (prove)\nusing this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>sts st.\n        sub = Node sts st \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sub = Node sts st\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "obtain sub_s max_s where sub_split: \"split_max k sub = (sub_s, max_s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub_s max_s.\n        split_max k sub = (sub_s, max_s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_max k sub\")"], ["proof (state)\nthis:\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  split_max k sub = (sub_s, max_s)", "have \"height sub_s = height t\""], ["proof (prove)\nusing this:\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. height sub_s = height t", "by (metis \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) a_split bal.simps(2) btree.distinct(1) list_split Cons order_bal_nonempty_lasttreebal order_impl_root_order root_order.simps(2) some_child_sub(1) split_set(1) split_max_height sub_node)"], ["proof (state)\nthis:\n  height sub_s = height t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "then"], ["proof (chain)\npicking this:\n  height sub_s = height t", "have \"height (rebalance_middle_tree k ls sub_s max_s rs t) = height (Node (ls@(sub_s,sep)#rs) t)\""], ["proof (prove)\nusing this:\n  height sub_s = height t\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub_s max_s rs t) =\n    height (Node (ls @ (sub_s, sep) # rs) t)", "using rs_height rebalance_middle_tree_height"], ["proof (prove)\nusing this:\n  height sub_s = height t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<lbrakk>height ?t = height ?sub;\n   case ?rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height ?t\\<rbrakk>\n  \\<Longrightarrow> height (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t) =\n                    height (Node (?ls @ (?sub, ?sep) # ?rs) ?t)\n\ngoal (1 subgoal):\n 1. height (rebalance_middle_tree k ls sub_s max_s rs t) =\n    height (Node (ls @ (sub_s, sep) # rs) t)", "by simp"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub_s max_s rs t) =\n  height (Node (ls @ (sub_s, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "also"], ["proof (state)\nthis:\n  height (rebalance_middle_tree k ls sub_s max_s rs t) =\n  height (Node (ls @ (sub_s, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "have \"\\<dots> = height (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub_s, sep) # rs) t) = height (Node ts t)", "using 2 a_split sep_x_Node list_split Cons split_set(1) \\<open>height sub_s = height t\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  a = (sub, sep)\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n  split ts x = (ls, list)\n  list = a # rs\n  split ?ts ?z = (?ls, (?a, ?b) # ?rs) \\<Longrightarrow>\n  (?a, ?b) \\<in> set ?ts\n  height sub_s = height t\n\ngoal (1 subgoal):\n 1. height (Node (ls @ (sub_s, sep) # rs) t) = height (Node ts t)", "by (auto simp add: split_conc[of ts])"], ["proof (state)\nthis:\n  height (Node (ls @ (sub_s, sep) # rs) t) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    height (del k x (Node ts t)) = height (Node ts t)", "finally"], ["proof (chain)\npicking this:\n  height (rebalance_middle_tree k ls sub_s max_s rs t) = height (Node ts t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height (rebalance_middle_tree k ls sub_s max_s rs t) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "using sep_x_Node Cons a_split list_split 2 sub_node sub_split"], ["proof (prove)\nusing this:\n  height (rebalance_middle_tree k ls sub_s max_s rs t) = height (Node ts t)\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n  list = a # rs\n  a = (sub, sep)\n  split ts x = (ls, list)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> height (del k x t) = height t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> height (del k x ?xb) = height ?xb\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sub = Node sts st\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. height (del k x (Node ts t)) = height (Node ts t)", "by auto"], ["proof (state)\nthis:\n  height (del k x (Node ts t)) = height (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height (del k x (Node ts t)) = height (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  height (del k x (Node ts t)) = height (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> height (del k x Leaf) = height Leaf", "qed simp"], ["", "(* proof for inorders *)\n\n(* note: this works (as it should, since there is not even recursion involved)\n  automatically. *yay* *)"], ["", "lemma rebalance_middle_tree_inorder:\n  assumes \"height t = height sub\"\n    and \"case rs of (rsub,rsep) # list \\<Rightarrow> height rsub = height t | [] \\<Rightarrow> True\"\n  shows \"inorder (rebalance_middle_tree k ls sub sep rs t) = inorder (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls sub sep rs t) =\n    inorder (Node (ls @ (sub, sep) # rs) t)", "apply(cases sub; cases t)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>sub = Leaf; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                      inorder (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>sub = Leaf; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                         inorder (Node (ls @ (sub, sep) # rs) t)\n 3. \\<And>x21 x22.\n       \\<lbrakk>sub = Node x21 x22; t = Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                         inorder (Node (ls @ (sub, sep) # rs) t)\n 4. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>sub = Node x21 x22; t = Node x21a x22a\\<rbrakk>\n       \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                         inorder (Node (ls @ (sub, sep) # rs) t)", "using assms"], ["proof (prove)\nusing this:\n  height t = height sub\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (4 subgoals):\n 1. \\<lbrakk>sub = Leaf; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                      inorder (Node (ls @ (sub, sep) # rs) t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>sub = Leaf; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                         inorder (Node (ls @ (sub, sep) # rs) t)\n 3. \\<And>x21 x22.\n       \\<lbrakk>sub = Node x21 x22; t = Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                         inorder (Node (ls @ (sub, sep) # rs) t)\n 4. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>sub = Node x21 x22; t = Node x21a x22a\\<rbrakk>\n       \\<Longrightarrow> inorder (rebalance_middle_tree k ls sub sep rs t) =\n                         inorder (Node (ls @ (sub, sep) # rs) t)", "apply (auto\n      split!: btree.splits up\\<^sub>i.splits list.splits\n      simp del: node\\<^sub>i.simps\n      simp add: node\\<^sub>i_inorder_simps\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rebalance_last_tree_inorder:\n  assumes \"height t = height sub\"\n    and \"ts = list@[(sub,sep)]\"\n  shows \"inorder (rebalance_last_tree k ts t) = inorder (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts t) = inorder (Node ts t)", "using rebalance_middle_tree_inorder assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>height ?t = height ?sub;\n   case ?rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height ?t\\<rbrakk>\n  \\<Longrightarrow> inorder\n                     (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t) =\n                    inorder (Node (?ls @ (?sub, ?sep) # ?rs) ?t)\n  height t = height sub\n  ts = list @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts t) = inorder (Node ts t)", "by auto"], ["", "lemma butlast_inorder_app_id: \"xs = xs' @ [(sub,sep)] \\<Longrightarrow> inorder_list xs' @ inorder sub @ [sep] = inorder_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = xs' @ [(sub, sep)] \\<Longrightarrow>\n    inorder_list xs' @ inorder sub @ [sep] = inorder_list xs", "by simp"], ["", "lemma split_max_inorder:\n  assumes \"nonempty_lasttreebal t\"\n    and \"t \\<noteq> Leaf\"\n  shows \"inorder_pair (split_max k t) = inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_pair (split_max k t) = inorder t", "using assms"], ["proof (prove)\nusing this:\n  nonempty_lasttreebal t\n  t \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k t) = inorder t", "proof (induction k t rule: split_max.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)\n 2. \\<And>a.\n       \\<lbrakk>nonempty_lasttreebal Leaf; Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max a Leaf) = inorder Leaf", "case (1 k ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; nonempty_lasttreebal t;\n   t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder_pair (split_max k t) = inorder t\n  nonempty_lasttreebal (Node ts t)\n  Node ts t \\<noteq> Leaf\n\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)\n 2. \\<And>a.\n       \\<lbrakk>nonempty_lasttreebal Leaf; Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max a Leaf) = inorder Leaf", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; nonempty_lasttreebal t;\n   t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder_pair (split_max k t) = inorder t\n  nonempty_lasttreebal (Node ts t)\n  Node ts t \\<noteq> Leaf", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; nonempty_lasttreebal t;\n   t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder_pair (split_max k t) = inorder t\n  nonempty_lasttreebal (Node ts t)\n  Node ts t \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                 t \\<noteq> Leaf\\<rbrakk>\n                \\<Longrightarrow> inorder_pair (split_max k t) = inorder t;\n     nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n     t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                      inorder (Node ts t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "case Leaf"], ["proof (state)\nthis:\n  t = Leaf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                 t \\<noteq> Leaf\\<rbrakk>\n                \\<Longrightarrow> inorder_pair (split_max k t) = inorder t;\n     nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n     t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                      inorder (Node ts t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "then"], ["proof (chain)\npicking this:\n  t = Leaf", "have \"ts = butlast ts @ [last ts]\""], ["proof (prove)\nusing this:\n  t = Leaf\n\ngoal (1 subgoal):\n 1. ts = butlast ts @ [last ts]", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  t = Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. ts = butlast ts @ [last ts]", "by auto"], ["proof (state)\nthis:\n  ts = butlast ts @ [last ts]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                 t \\<noteq> Leaf\\<rbrakk>\n                \\<Longrightarrow> inorder_pair (split_max k t) = inorder t;\n     nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n     t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                      inorder (Node ts t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "moreover"], ["proof (state)\nthis:\n  ts = butlast ts @ [last ts]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                 t \\<noteq> Leaf\\<rbrakk>\n                \\<Longrightarrow> inorder_pair (split_max k t) = inorder t;\n     nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n     t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                      inorder (Node ts t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "obtain sub sep where \"last ts = (sub,sep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        last ts = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  last ts = (sub, sep)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                 t \\<noteq> Leaf\\<rbrakk>\n                \\<Longrightarrow> inorder_pair (split_max k t) = inorder t;\n     nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n     t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                      inorder (Node ts t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "ultimately"], ["proof (chain)\npicking this:\n  ts = butlast ts @ [last ts]\n  last ts = (sub, sep)", "show ?thesis"], ["proof (prove)\nusing this:\n  ts = butlast ts @ [last ts]\n  last ts = (sub, sep)\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)", "using Leaf"], ["proof (prove)\nusing this:\n  ts = butlast ts @ [last ts]\n  last ts = (sub, sep)\n  t = Leaf\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)", "apply (auto split!: prod.splits btree.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ts = butlast ts @ [(sub, sep)]; last ts = (sub, sep);\n     t = Leaf\\<rbrakk>\n    \\<Longrightarrow> inorder_list (butlast ts) @ inorder sub @ [sep] =\n                      inorder_list ts", "by (simp add: butlast_inorder_app_id)"], ["proof (state)\nthis:\n  inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "case (Node tts tt)"], ["proof (state)\nthis:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "then"], ["proof (chain)\npicking this:\n  t = Node tts tt", "have IH: \"inorder_pair (split_max k t) = inorder t\""], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k t) = inorder t", "using \"1.IH\" \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  t = Node tts tt\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; nonempty_lasttreebal t;\n   t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder_pair (split_max k t) = inorder t\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k t) = inorder t", "by auto"], ["proof (state)\nthis:\n  inorder_pair (split_max k t) = inorder t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "obtain sub sep where split_sub_sep: \"split_max k t = (sub,sep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        split_max k t = (sub, sep) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "then"], ["proof (chain)\npicking this:\n  split_max k t = (sub, sep)", "have height_sub: \"height sub = height t\""], ["proof (prove)\nusing this:\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. height sub = height t", "by (metis \"1.prems\"(1) Node btree.distinct(1) nonempty_lasttreebal.simps(2) split_max_height)"], ["proof (state)\nthis:\n  height sub = height t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "have \"inorder_pair (split_max k (Node ts t)) = inorder (rebalance_last_tree k ts sub) @ [sep]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_pair (split_max k (Node ts t)) =\n    inorder (rebalance_last_tree k ts sub) @ [sep]", "using Node 1 split_sub_sep"], ["proof (prove)\nusing this:\n  t = Node tts tt\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; nonempty_lasttreebal t;\n   t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder_pair (split_max k t) = inorder t\n  nonempty_lasttreebal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k (Node ts t)) =\n    inorder (rebalance_last_tree k ts sub) @ [sep]", "by auto"], ["proof (state)\nthis:\n  inorder_pair (split_max k (Node ts t)) =\n  inorder (rebalance_last_tree k ts sub) @ [sep]\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "also"], ["proof (state)\nthis:\n  inorder_pair (split_max k (Node ts t)) =\n  inorder (rebalance_last_tree k ts sub) @ [sep]\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "have \"\\<dots> = inorder_list ts @ inorder sub @ [sep]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts sub) @ [sep] =\n    inorder_list ts @ inorder sub @ [sep]", "using rebalance_last_tree_inorder height_sub \"1.prems\""], ["proof (prove)\nusing this:\n  \\<lbrakk>height ?t = height ?sub; ?ts = ?list @ [(?sub, ?sep)]\\<rbrakk>\n  \\<Longrightarrow> inorder (rebalance_last_tree ?k ?ts ?t) =\n                    inorder (Node ?ts ?t)\n  height sub = height t\n  nonempty_lasttreebal (Node ts t)\n  Node ts t \\<noteq> Leaf\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts sub) @ [sep] =\n    inorder_list ts @ inorder sub @ [sep]", "by (auto simp del: rebalance_last_tree.simps)"], ["proof (state)\nthis:\n  inorder (rebalance_last_tree k ts sub) @ [sep] =\n  inorder_list ts @ inorder sub @ [sep]\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "also"], ["proof (state)\nthis:\n  inorder (rebalance_last_tree k ts sub) @ [sep] =\n  inorder_list ts @ inorder sub @ [sep]\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "have \"\\<dots> = inorder (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ts @ inorder sub @ [sep] = inorder (Node ts t)", "using IH split_sub_sep"], ["proof (prove)\nusing this:\n  inorder_pair (split_max k t) = inorder t\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. inorder_list ts @ inorder sub @ [sep] = inorder (Node ts t)", "by simp"], ["proof (state)\nthis:\n  inorder_list ts @ inorder sub @ [sep] = inorder (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; nonempty_lasttreebal t;\n                    t \\<noteq> Leaf\\<rbrakk>\n                   \\<Longrightarrow> inorder_pair (split_max k t) =\n                                     inorder t;\n        nonempty_lasttreebal (Node ts t); Node ts t \\<noteq> Leaf;\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max k (Node ts t)) =\n                         inorder (Node ts t)", "finally"], ["proof (chain)\npicking this:\n  inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)\n\ngoal (1 subgoal):\n 1. inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)", "."], ["proof (state)\nthis:\n  inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder_pair (split_max k (Node ts t)) = inorder (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>nonempty_lasttreebal Leaf; Leaf \\<noteq> Leaf\\<rbrakk>\n       \\<Longrightarrow> inorder_pair (split_max a Leaf) = inorder Leaf", "qed simp"], ["", "lemma height_bal_subtrees_merge: \"\\<lbrakk>height (Node as a) = height (Node bs b); bal (Node as a); bal (Node bs b)\\<rbrakk>\n \\<Longrightarrow> \\<forall>x \\<in> set (subtrees as) \\<union> {a}. height x = height b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>height (Node as a) = height (Node bs b); bal (Node as a);\n     bal (Node bs b)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set (subtrees as) \\<union> {a}.\n                         height x = height b", "by (metis Suc_inject Un_iff bal.simps(2) height_bal_tree singletonD)"], ["", "lemma bal_list_merge:\n  assumes \"bal_up\\<^sub>i (Up\\<^sub>i (Node as a) x (Node bs b))\"\n  shows \"bal (Node (as@(a,x)#bs) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "have \"\\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x", "using subtrees_split assms"], ["proof (prove)\nusing this:\n  set (subtrees (?l @ (?a, ?b) # ?r)) =\n  set (subtrees ?l) \\<union> set (subtrees ?r) \\<union> {?a}\n  bal_up\\<^sub>i (Up\\<^sub>i (Node as a) x (Node bs b))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x\n\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x\n\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "have \"bal b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal b", "using assms"], ["proof (prove)\nusing this:\n  bal_up\\<^sub>i (Up\\<^sub>i (Node as a) x (Node bs b))\n\ngoal (1 subgoal):\n 1. bal b", "by auto"], ["proof (state)\nthis:\n  bal b\n\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "moreover"], ["proof (state)\nthis:\n  bal b\n\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "have \"\\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union> set (subtrees bs). height x = height b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union>\n                   set (subtrees bs).\n       height x = height b", "using assms height_bal_subtrees_merge"], ["proof (prove)\nusing this:\n  bal_up\\<^sub>i (Up\\<^sub>i (Node as a) x (Node bs b))\n  \\<lbrakk>height (Node ?as ?a) = height (Node ?bs ?b); bal (Node ?as ?a);\n   bal (Node ?bs ?b)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (subtrees ?as) \\<union> {?a}.\n                       height x = height ?b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union>\n                   set (subtrees bs).\n       height x = height b", "unfolding bal_up\\<^sub>i.simps"], ["proof (prove)\nusing this:\n  height (Node as a) = height (Node bs b) \\<and>\n  bal (Node as a) \\<and> bal (Node bs b)\n  \\<lbrakk>height (Node ?as ?a) = height (Node ?bs ?b); bal (Node ?as ?a);\n   bal (Node ?bs ?b)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (subtrees ?as) \\<union> {?a}.\n                       height x = height ?b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union>\n                   set (subtrees bs).\n       height x = height b", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union> set (subtrees bs).\n     height x = height b\n\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x\n  bal b\n  \\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union> set (subtrees bs).\n     height x = height b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (subtrees (as @ (a, x) # bs)). bal x\n  bal b\n  \\<forall>x\\<in>set (subtrees as) \\<union> {a} \\<union> set (subtrees bs).\n     height x = height b\n\ngoal (1 subgoal):\n 1. bal (Node (as @ (a, x) # bs) b)", "by auto"], ["proof (state)\nthis:\n  bal (Node (as @ (a, x) # bs) b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma node\\<^sub>i_bal_up\\<^sub>i:\n  assumes \"bal_up\\<^sub>i (node\\<^sub>i k ts t)\"\n  shows \"bal (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node ts t)", "using assms"], ["proof (prove)\nusing this:\n  bal_up\\<^sub>i (node\\<^sub>i k ts t)\n\ngoal (1 subgoal):\n 1. bal (Node ts t)", "proof(cases \"length ts \\<le> 2*k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)\n 2. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "case False"], ["proof (state)\nthis:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)\n 2. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "then"], ["proof (chain)\npicking this:\n  \\<not> length ts \\<le> 2 * k", "obtain ls sub sep rs where split_list: \"split_half ts = (ls, (sub,sep)#rs)\""], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using node\\<^sub>i_cases"], ["proof (prove)\nusing this:\n  \\<not> length ts \\<le> 2 * k\n  length ?xs \\<le> ?k \\<or>\n  (\\<exists>ls sub sep rs. split_half ?xs = (ls, (sub, sep) # rs))\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep rs.\n        split_half ts = (ls, (sub, sep) # rs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)\n 2. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "then"], ["proof (chain)\npicking this:\n  split_half ts = (ls, (sub, sep) # rs)", "have \"node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\""], ["proof (prove)\nusing this:\n  split_half ts = (ls, (sub, sep) # rs)\n\ngoal (1 subgoal):\n 1. node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)", "using False"], ["proof (prove)\nusing this:\n  split_half ts = (ls, (sub, sep) # rs)\n  \\<not> length ts \\<le> 2 * k\n\ngoal (1 subgoal):\n 1. node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)", "by auto"], ["proof (state)\nthis:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)\n 2. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "moreover"], ["proof (state)\nthis:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)\n 2. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "have \"ts = ls@(sub,sep)#rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts = ls @ (sub, sep) # rs", "by (metis append_take_drop_id fst_conv local.split_list snd_conv split_half.elims)"], ["proof (state)\nthis:\n  ts = ls @ (sub, sep) # rs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)\n 2. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     \\<not> length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "ultimately"], ["proof (chain)\npicking this:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n  ts = ls @ (sub, sep) # rs", "show ?thesis"], ["proof (prove)\nusing this:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n  ts = ls @ (sub, sep) # rs\n\ngoal (1 subgoal):\n 1. bal (Node ts t)", "using bal_list_merge[of ls sub sep rs t] assms"], ["proof (prove)\nusing this:\n  node\\<^sub>i k ts t = Up\\<^sub>i (Node ls sub) sep (Node rs t)\n  ts = ls @ (sub, sep) # rs\n  bal_up\\<^sub>i\n   (Up\\<^sub>i (Node ls sub) sep (Node rs t)) \\<Longrightarrow>\n  bal (Node (ls @ (sub, sep) # rs) t)\n  bal_up\\<^sub>i (node\\<^sub>i k ts t)\n\ngoal (1 subgoal):\n 1. bal (Node ts t)", "by (simp del: bal.simps bal_up\\<^sub>i.simps)"], ["proof (state)\nthis:\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bal_up\\<^sub>i (node\\<^sub>i k ts t);\n     length ts \\<le> 2 * k\\<rbrakk>\n    \\<Longrightarrow> bal (Node ts t)", "qed simp"], ["", "lemma node\\<^sub>i_bal_simp: \"bal_up\\<^sub>i (node\\<^sub>i k ts t) = bal (Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k ts t) = bal (Node ts t)", "using node\\<^sub>i_bal node\\<^sub>i_bal_up\\<^sub>i"], ["proof (prove)\nusing this:\n  bal (Node ?ts ?t) \\<Longrightarrow>\n  bal_up\\<^sub>i (node\\<^sub>i ?k ?ts ?t)\n  bal_up\\<^sub>i (node\\<^sub>i ?k ?ts ?t) \\<Longrightarrow>\n  bal (Node ?ts ?t)\n\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k ts t) = bal (Node ts t)", "by blast"], ["", "lemma rebalance_middle_tree_bal: \"bal (Node (ls@(sub,sep)#rs) t) \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t) \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t);\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "case t_node: (Node tts tt)"], ["proof (state)\nthis:\n  t = Node tts tt\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t);\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "assume assms: \"bal (Node (ls @ (sub, sep) # rs) t)\""], ["proof (state)\nthis:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t);\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (sub, sep) # rs) t)", "obtain mts mt where sub_node: \"sub = Node mts mt\""], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases sub) (auto simp add: t_node)"], ["proof (state)\nthis:\n  sub = Node mts mt\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t);\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have sub_heights: \"height sub = height t\" \"bal sub\" \"bal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height sub = height t &&& bal sub &&& bal t", "using assms"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. height sub = height t &&& bal sub &&& bal t", "by auto"], ["proof (state)\nthis:\n  height sub = height t\n  bal sub\n  bal t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t);\n        t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "proof (cases \"length mts \\<ge> k \\<and> length tts \\<ge> k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> length mts \\<and> k \\<le> length tts \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<not> (k \\<le> length mts \\<and> k \\<le> length tts) \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)", "case True"], ["proof (state)\nthis:\n  k \\<le> length mts \\<and> k \\<le> length tts\n\ngoal (2 subgoals):\n 1. k \\<le> length mts \\<and> k \\<le> length tts \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<not> (k \\<le> length mts \\<and> k \\<le> length tts) \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  k \\<le> length mts \\<and> k \\<le> length tts", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> length mts \\<and> k \\<le> length tts\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "using t_node sub_node assms"], ["proof (prove)\nusing this:\n  k \\<le> length mts \\<and> k \\<le> length tts\n  t = Node tts tt\n  sub = Node mts mt\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "by (auto simp del: bal.simps)"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<not> (k \\<le> length mts \\<and> k \\<le> length tts) \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (k \\<le> length mts \\<and> k \\<le> length tts) \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)", "case False"], ["proof (state)\nthis:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (1 subgoal):\n 1. \\<not> (k \\<le> length mts \\<and> k \\<le> length tts) \\<Longrightarrow>\n    bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"height_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#tts) tt) = height (Node (mts@(mt,sep)#tts) tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n    height (Node (mts @ (mt, sep) # tts) tt)", "using node\\<^sub>i_height"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i ?k ?ts ?t) = height (Node ?ts ?t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n    height (Node (mts @ (mt, sep) # tts) tt)", "by blast"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  height (Node (mts @ (mt, sep) # tts) tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "also"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n  height (Node (mts @ (mt, sep) # tts) tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"\\<dots> = Suc (height tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (mts @ (mt, sep) # tts) tt) = Suc (height tt)", "by (metis height_bal_tree height_up\\<^sub>i.simps(2) height_list_split max.idem sub_heights(1) sub_heights(3) sub_node t_node)"], ["proof (state)\nthis:\n  height (Node (mts @ (mt, sep) # tts) tt) = Suc (height tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "also"], ["proof (state)\nthis:\n  height (Node (mts @ (mt, sep) # tts) tt) = Suc (height tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"\\<dots> = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (height tt) = height t", "using height_bal_tree sub_heights(3) t_node"], ["proof (prove)\nusing this:\n  bal (Node ?ts ?t) \\<Longrightarrow> height (Node ?ts ?t) = Suc (height ?t)\n  bal t\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. Suc (height tt) = height t", "by fastforce"], ["proof (state)\nthis:\n  Suc (height tt) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "finally"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t", "have \"height_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#tts) tt) = height t\""], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t", "by simp"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "moreover"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"bal_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#tts) tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "by (metis bal_list_merge bal_up\\<^sub>i.simps(2) node\\<^sub>i_bal sub_heights(1) sub_heights(2) sub_heights(3) sub_node t_node)"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "ultimately"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) = height t\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "apply (cases \"node\\<^sub>i k (mts@(mt,sep)#tts) tt\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                height t;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                height t;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "using assms Nil sub_node t_node"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub, sep) # rs) t)\n  rs = []\n  sub = Node mts mt\n  t = Node tts tt\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                height t;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt) =\n                height t;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "by auto"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "case (Cons r rs)"], ["proof (state)\nthis:\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  rs = r # rs", "obtain rsub rsep where r_split: \"r = (rsub,rsep)\""], ["proof (prove)\nusing this:\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. (\\<And>rsub rsep.\n        r = (rsub, rsep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = (rsub, rsep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  r = (rsub, rsep)", "have rsub_height: \"height rsub = height t\" \"bal rsub\""], ["proof (prove)\nusing this:\n  r = (rsub, rsep)\n\ngoal (1 subgoal):\n 1. height rsub = height t &&& bal rsub", "using assms Cons"], ["proof (prove)\nusing this:\n  r = (rsub, rsep)\n  bal (Node (ls @ (sub, sep) # rs) t)\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. height rsub = height t &&& bal rsub", "by auto"], ["proof (state)\nthis:\n  height rsub = height t\n  bal rsub\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  height rsub = height t\n  bal rsub", "obtain rts rt where r_node: \"rsub = (Node rts rt)\""], ["proof (prove)\nusing this:\n  height rsub = height t\n  bal rsub\n\ngoal (1 subgoal):\n 1. (\\<And>rts rt.\n        rsub = Node rts rt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases rsub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n     height rsub = height t; bal rsub; rsub = Leaf\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n        height rsub = height t; bal rsub; rsub = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> thesis", "using t_node"], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n     height rsub = height t; bal rsub; rsub = Leaf\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n        height rsub = height t; bal rsub; rsub = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  rsub = Node rts rt\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"height_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#rts) rt) = height (Node (mts@(mt,sep)#rts) rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n    height (Node (mts @ (mt, sep) # rts) rt)", "using node\\<^sub>i_height"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i ?k ?ts ?t) = height (Node ?ts ?t)\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n    height (Node (mts @ (mt, sep) # rts) rt)", "by blast"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height (Node (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "also"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height (Node (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"\\<dots> = Suc (height rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (Node (mts @ (mt, sep) # rts) rt) = Suc (height rt)", "by (metis Un_iff  \\<open>height rsub = height t\\<close> assms bal.simps(2) bal_split_last(1) height_bal_tree height_up\\<^sub>i.simps(2) height_list_split list.set_intros(1) Cons max.idem r_node r_split set_append some_child_sub(1) sub_heights(1) sub_node)"], ["proof (state)\nthis:\n  height (Node (mts @ (mt, sep) # rts) rt) = Suc (height rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "also"], ["proof (state)\nthis:\n  height (Node (mts @ (mt, sep) # rts) rt) = Suc (height rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have \"\\<dots> = height rsub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (height rt) = height rsub", "using height_bal_tree r_node rsub_height(2)"], ["proof (prove)\nusing this:\n  bal (Node ?ts ?t) \\<Longrightarrow> height (Node ?ts ?t) = Suc (height ?t)\n  rsub = Node rts rt\n  bal rsub\n\ngoal (1 subgoal):\n 1. Suc (height rt) = height rsub", "by fastforce"], ["proof (state)\nthis:\n  Suc (height rt) = height rsub\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "finally"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub", "have 1: \"height_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#rts) rt) = height rsub\""], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n\ngoal (1 subgoal):\n 1. height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n    height rsub", "."], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "moreover"], ["proof (state)\nthis:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "have 2: \"bal_up\\<^sub>i (node\\<^sub>i k (mts@(mt,sep)#rts) rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)", "by (metis bal_list_merge bal_up\\<^sub>i.simps(2) node\\<^sub>i_bal r_node rsub_height(1) rsub_height(2) sub_heights(1) sub_heights(2) sub_node)"], ["proof (state)\nthis:\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "ultimately"], ["proof (chain)\npicking this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)", "show ?thesis"], ["proof (prove)\nusing this:\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "proof (cases \"node\\<^sub>i k (mts@(mt,sep)#rts) rt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "case (T\\<^sub>i u)"], ["proof (state)\nthis:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u", "have \"bal (Node (ls@(u,rsep)#rs) t)\""], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (u, rsep) # rs) t)", "using 1 2 Cons assms t_node subtrees_split sub_heights r_split rsub_height"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n  rs = r # rs\n  bal (Node (ls @ (sub, sep) # rs) t)\n  t = Node tts tt\n  set (subtrees (?l @ (?a, ?b) # ?r)) =\n  set (subtrees ?l) \\<union> set (subtrees ?r) \\<union> {?a}\n  height sub = height t\n  bal sub\n  bal t\n  r = (rsub, rsep)\n  height rsub = height t\n  bal rsub\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (u, rsep) # rs) t)", "unfolding bal.simps"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n  rs = r # rs\n  (\\<forall>sub\\<in>set (subtrees (ls @ (sub, sep) # rs)).\n      height sub = height t) \\<and>\n  Ball (set (subtrees (ls @ (sub, sep) # rs))) bal \\<and> bal t\n  t = Node tts tt\n  set (subtrees (?l @ (?a, ?b) # ?r)) =\n  set (subtrees ?l) \\<union> set (subtrees ?r) \\<union> {?a}\n  height sub = height t\n  bal sub\n  bal t\n  r = (rsub, rsep)\n  height rsub = height t\n  bal rsub\n\ngoal (1 subgoal):\n 1. (\\<forall>sub\\<in>set (subtrees (ls @ (u, rsep) # rs)).\n        height sub = height t) \\<and>\n    Ball (set (subtrees (ls @ (u, rsep) # rs))) bal \\<and> bal t", "by (auto simp del: height_btree.simps)"], ["proof (state)\nthis:\n  bal (Node (ls @ (u, rsep) # rs) t)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (u, rsep) # rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (u, rsep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "using Cons assms t_node sub_node r_split r_node False T\\<^sub>i"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (u, rsep) # rs) t)\n  rs = r # rs\n  bal (Node (ls @ (sub, sep) # rs) t)\n  t = Node tts tt\n  sub = Node mts mt\n  r = (rsub, rsep)\n  rsub = Node rts rt\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i u\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "by (auto simp del: node\\<^sub>i.simps bal.simps)"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "case (Up\\<^sub>i l a r)"], ["proof (state)\nthis:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r", "have \"bal (Node (ls@(l,a)#(r,rsep)#rs) t)\""], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (l, a) # (r, rsep) # rs) t)", "using 1 2 Cons assms t_node subtrees_split sub_heights r_split rsub_height"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n  rs = r__ # rs\n  bal (Node (ls @ (sub, sep) # rs) t)\n  t = Node tts tt\n  set (subtrees (?l @ (?a, ?b) # ?r)) =\n  set (subtrees ?l) \\<union> set (subtrees ?r) \\<union> {?a}\n  height sub = height t\n  bal sub\n  bal t\n  r__ = (rsub, rsep)\n  height rsub = height t\n  bal rsub\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (l, a) # (r, rsep) # rs) t)", "unfolding bal.simps"], ["proof (prove)\nusing this:\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n  height_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n  height rsub\n  bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n  rs = r__ # rs\n  (\\<forall>sub\\<in>set (subtrees (ls @ (sub, sep) # rs)).\n      height sub = height t) \\<and>\n  Ball (set (subtrees (ls @ (sub, sep) # rs))) bal \\<and> bal t\n  t = Node tts tt\n  set (subtrees (?l @ (?a, ?b) # ?r)) =\n  set (subtrees ?l) \\<union> set (subtrees ?r) \\<union> {?a}\n  height sub = height t\n  bal sub\n  bal t\n  r__ = (rsub, rsep)\n  height rsub = height t\n  bal rsub\n\ngoal (1 subgoal):\n 1. (\\<forall>sub\\<in>set (subtrees (ls @ (l, a) # (r, rsep) # rs)).\n        height sub = height t) \\<and>\n    Ball (set (subtrees (ls @ (l, a) # (r, rsep) # rs))) bal \\<and> bal t", "by (auto simp del: height_btree.simps)"], ["proof (state)\nthis:\n  bal (Node (ls @ (l, a) # (r, rsep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>height_up\\<^sub>i\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt) =\n                height rsub;\n        bal_up\\<^sub>i (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (l, a) # (r, rsep) # rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (l, a) # (r, rsep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "using Cons assms t_node sub_node r_split r_node False Up\\<^sub>i"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (l, a) # (r, rsep) # rs) t)\n  rs = r__ # rs\n  bal (Node (ls @ (sub, sep) # rs) t)\n  t = Node tts tt\n  sub = Node mts mt\n  r__ = (rsub, rsep)\n  rsub = Node rts rt\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  node\\<^sub>i k (mts @ (mt, sep) # rts) rt = Up\\<^sub>i l a r\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub sep rs t)", "by (auto simp del: node\\<^sub>i.simps bal.simps)"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_middle_tree k ls sub sep rs t)", "qed (simp add: height_Leaf)"], ["", "lemma rebalance_last_tree_bal: \"\\<lbrakk>bal (Node ts t); ts \\<noteq> []\\<rbrakk> \\<Longrightarrow> bal (rebalance_last_tree k ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bal (Node ts t); ts \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_last_tree k ts t)", "using rebalance_middle_tree_bal append_butlast_last_id[of ts]"], ["proof (prove)\nusing this:\n  bal (Node (?ls @ (?sub, ?sep) # ?rs) ?t) \\<Longrightarrow>\n  bal (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t)\n  ts \\<noteq> [] \\<Longrightarrow> butlast ts @ [last ts] = ts\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bal (Node ts t); ts \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> bal (rebalance_last_tree k ts t)", "apply(cases \"last ts\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>bal (Node ts t); ts \\<noteq> [];\n        \\<And>ls sub sep rs t k.\n           bal (Node (ls @ (sub, sep) # rs) t) \\<Longrightarrow>\n           bal (rebalance_middle_tree k ls sub sep rs t);\n        ts \\<noteq> [] \\<Longrightarrow> butlast ts @ [last ts] = ts;\n        last ts = (a, b)\\<rbrakk>\n       \\<Longrightarrow> bal (rebalance_last_tree k ts t)", "apply(auto simp del: bal.simps rebalance_middle_tree.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma split_max_bal:\n  assumes \"bal t\"\n    and \"t \\<noteq> Leaf\"\n    and \"nonempty_lasttreebal t\"\n  shows \"bal (fst (split_max k t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (fst (split_max k t))", "using assms"], ["proof (prove)\nusing this:\n  bal t\n  t \\<noteq> Leaf\n  nonempty_lasttreebal t\n\ngoal (1 subgoal):\n 1. bal (fst (split_max k t))", "proof(induction k t rule: split_max.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>a.\n       \\<lbrakk>bal Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max a Leaf))", "case (1 k ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>a.\n       \\<lbrakk>bal Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max a Leaf))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. bal (fst (split_max k (Node ts t)))", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                 nonempty_lasttreebal t\\<rbrakk>\n                \\<Longrightarrow> bal (fst (split_max k t));\n     bal (Node ts t); Node ts t \\<noteq> Leaf;\n     nonempty_lasttreebal (Node ts t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "case Leaf"], ["proof (state)\nthis:\n  t = Leaf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                 nonempty_lasttreebal t\\<rbrakk>\n                \\<Longrightarrow> bal (fst (split_max k t));\n     bal (Node ts t); Node ts t \\<noteq> Leaf;\n     nonempty_lasttreebal (Node ts t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  t = Leaf", "obtain sub sep where last_split: \"last ts = (sub,sep)\""], ["proof (prove)\nusing this:\n  t = Leaf\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        last ts = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  t = Leaf\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        last ts = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  last ts = (sub, sep)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                 nonempty_lasttreebal t\\<rbrakk>\n                \\<Longrightarrow> bal (fst (split_max k t));\n     bal (Node ts t); Node ts t \\<noteq> Leaf;\n     nonempty_lasttreebal (Node ts t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  last ts = (sub, sep)", "have \"height sub = height t\""], ["proof (prove)\nusing this:\n  last ts = (sub, sep)\n\ngoal (1 subgoal):\n 1. height sub = height t", "using 1"], ["proof (prove)\nusing this:\n  last ts = (sub, sep)\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. height sub = height t", "by auto"], ["proof (state)\nthis:\n  height sub = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                 nonempty_lasttreebal t\\<rbrakk>\n                \\<Longrightarrow> bal (fst (split_max k t));\n     bal (Node ts t); Node ts t \\<noteq> Leaf;\n     nonempty_lasttreebal (Node ts t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  height sub = height t", "have \"bal (Node (butlast ts) sub)\""], ["proof (prove)\nusing this:\n  height sub = height t\n\ngoal (1 subgoal):\n 1. bal (Node (butlast ts) sub)", "using 1 last_split"], ["proof (prove)\nusing this:\n  height sub = height t\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n  last ts = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal (Node (butlast ts) sub)", "by auto"], ["proof (state)\nthis:\n  bal (Node (butlast ts) sub)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x21 x22.\n                \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                 nonempty_lasttreebal t\\<rbrakk>\n                \\<Longrightarrow> bal (fst (split_max k t));\n     bal (Node ts t); Node ts t \\<noteq> Leaf;\n     nonempty_lasttreebal (Node ts t); t = Leaf\\<rbrakk>\n    \\<Longrightarrow> bal (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  bal (Node (butlast ts) sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (Node (butlast ts) sub)\n\ngoal (1 subgoal):\n 1. bal (fst (split_max k (Node ts t)))", "using 1 Leaf last_split"], ["proof (prove)\nusing this:\n  bal (Node (butlast ts) sub)\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n  t = Leaf\n  last ts = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal (fst (split_max k (Node ts t)))", "by auto"], ["proof (state)\nthis:\n  bal (fst (split_max k (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "case (Node tts tt)"], ["proof (state)\nthis:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  t = Node tts tt", "obtain sub sep where t_split: \"split_max k t = (sub,sep)\""], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        split_max k t = (sub, sep) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_max k t\")"], ["proof (state)\nthis:\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  split_max k t = (sub, sep)", "have \"height sub = height t\""], ["proof (prove)\nusing this:\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. height sub = height t", "using 1 Node"], ["proof (prove)\nusing this:\n  split_max k t = (sub, sep)\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. height sub = height t", "by (metis btree.distinct(1) nonempty_lasttreebal.simps(2) split_max_height)"], ["proof (state)\nthis:\n  height sub = height t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "moreover"], ["proof (state)\nthis:\n  height sub = height t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "have \"bal sub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal sub", "using \"1.IH\" \"1.prems\"(1) \"1.prems\"(3) Node t_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  nonempty_lasttreebal (Node ts t)\n  t = Node tts tt\n  split_max k t = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal sub", "by fastforce"], ["proof (state)\nthis:\n  bal sub\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "ultimately"], ["proof (chain)\npicking this:\n  height sub = height t\n  bal sub", "have \"bal (Node ts sub)\""], ["proof (prove)\nusing this:\n  height sub = height t\n  bal sub\n\ngoal (1 subgoal):\n 1. bal (Node ts sub)", "using 1 t_split Node"], ["proof (prove)\nusing this:\n  height sub = height t\n  bal sub\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n  split_max k t = (sub, sep)\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. bal (Node ts sub)", "by auto"], ["proof (state)\nthis:\n  bal (Node ts sub)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; bal t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> bal (fst (split_max k t));\n        bal (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t); t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  bal (Node ts sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (Node ts sub)\n\ngoal (1 subgoal):\n 1. bal (fst (split_max k (Node ts t)))", "using rebalance_last_tree_bal t_split Node 1"], ["proof (prove)\nusing this:\n  bal (Node ts sub)\n  \\<lbrakk>bal (Node ?ts ?t); ?ts \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> bal (rebalance_last_tree ?k ?ts ?t)\n  split_max k t = (sub, sep)\n  t = Node tts tt\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; bal t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max k t))\n  bal (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. bal (fst (split_max k (Node ts t)))", "by (auto simp del: bal.simps rebalance_middle_tree.simps)"], ["proof (state)\nthis:\n  bal (fst (split_max k (Node ts t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal (fst (split_max k (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>bal Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (fst (split_max a Leaf))", "qed simp"], ["", "lemma del_bal:\n  assumes \"k > 0\"\n    and \"root_order k t\"\n    and \"bal t\"\n  shows \"bal (del k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (del k x t)", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  root_order k t\n  bal t\n\ngoal (1 subgoal):\n 1. bal (del k x t)", "proof(induction k x t rule: del.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (del k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal (del k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal (del k x xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (del k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal (del k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal (del k x xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)", "obtain ls rs where list_split: \"split ts x = (ls,rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split ts x\")"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (del k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> bal (del k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> bal (del k x xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "show ?case"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = []", "have \"bal (del k x t)\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. bal (del k x t)", "using 2 list_split"], ["proof (prove)\nusing this:\n  rs = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. bal (del k x t)", "by (simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  bal (del k x t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  bal (del k x t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "have \"height (del k x t) = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (del k x t) = height t", "using 2 del_height"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> height (del ?k ?x ?t) = height ?t\n\ngoal (1 subgoal):\n 1. height (del k x t) = height t", "by (simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  height (del k x t) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  height (del k x t) = height t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "have \"ts \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<noteq> []", "using 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. ts \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ts \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  bal (del k x t)\n  height (del k x t) = height t\n  ts \\<noteq> []", "have \"bal (rebalance_last_tree k ts (del k x t))\""], ["proof (prove)\nusing this:\n  bal (del k x t)\n  height (del k x t) = height t\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. bal (rebalance_last_tree k ts (del k x t))", "using 2 Nil order_bal_nonempty_lasttreebal rebalance_last_tree_bal"], ["proof (prove)\nusing this:\n  bal (del k x t)\n  height (del k x t) = height t\n  ts \\<noteq> []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  rs = []\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal ?t\n  \\<lbrakk>bal (Node ?ts ?t); ?ts \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> bal (rebalance_last_tree ?k ?ts ?t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_last_tree k ts (del k x t))", "by simp"], ["proof (state)\nthis:\n  bal (rebalance_last_tree k ts (del k x t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (rebalance_last_tree k ts (del k x t))", "have \"bal (rebalance_last_tree k ls (del k x t))\""], ["proof (prove)\nusing this:\n  bal (rebalance_last_tree k ts (del k x t))\n\ngoal (1 subgoal):\n 1. bal (rebalance_last_tree k ls (del k x t))", "using list_split split_conc Nil"], ["proof (prove)\nusing this:\n  bal (rebalance_last_tree k ts (del k x t))\n  split ts x = (ls, rs)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n  rs = []\n\ngoal (1 subgoal):\n 1. bal (rebalance_last_tree k ls (del k x t))", "by fastforce"], ["proof (state)\nthis:\n  bal (rebalance_last_tree k ls (del k x t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, rs); rs = []\\<rbrakk>\n    \\<Longrightarrow> bal (del k x (Node ts t))\n 2. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (rebalance_last_tree k ls (del k x t))", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (rebalance_last_tree k ls (del k x t))\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "using 2 list_split Nil"], ["proof (prove)\nusing this:\n  bal (rebalance_last_tree k ls (del k x t))\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, rs)\n  rs = []\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  bal (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs); rs = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "case (Cons r rs)"], ["proof (state)\nthis:\n  rs__ = r # rs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs__); rs__ = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs__ = r # rs", "obtain sub sep where r_split: \"r = (sub,sep)\""], ["proof (prove)\nusing this:\n  rs__ = r # rs\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        r = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs__); rs__ = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  r = (sub, sep)", "have sub_height: \"height sub = height t\" \"bal sub\""], ["proof (prove)\nusing this:\n  r = (sub, sep)\n\ngoal (1 subgoal):\n 1. height sub = height t &&& bal sub", "using 2 Cons list_split split_set(1)"], ["proof (prove)\nusing this:\n  r = (sub, sep)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  rs__ = r # rs\n  split ts x = (ls, rs__)\n  split ?ts ?z = (?ls, (?a, ?b) # ?rs) \\<Longrightarrow>\n  (?a, ?b) \\<in> set ?ts\n\ngoal (1 subgoal):\n 1. height sub = height t &&& bal sub", "by fastforce+"], ["proof (state)\nthis:\n  height sub = height t\n  bal sub\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs__); rs__ = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "consider (sep_n_x) \"sep \\<noteq> x\" |\n      (sep_x_Leaf) \"sep = x \\<and> sub = Leaf\" |\n      (sep_x_Node) \"sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using btree.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Leaf \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = Node x21 x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>split ts x = (ls, rs__); rs__ = a # list\\<rbrakk>\n       \\<Longrightarrow> bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "case sep_n_x"], ["proof (state)\nthis:\n  sep \\<noteq> x\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep \\<noteq> x", "have \"bal (del k x sub)\" \"height (del k x sub) = height sub\""], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. bal (del k x sub) &&& height (del k x sub) = height sub", "using sub_height"], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n  height sub = height t\n  bal sub\n\ngoal (1 subgoal):\n 1. bal (del k x sub) &&& height (del k x sub) = height sub", "apply (metis \"2.IH\"(2) \"2.prems\"(1) \"2.prems\"(2) list_split local.Cons order_impl_root_order r_split root_order.simps(2) some_child_sub(1) split_set(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. height (del k x sub) = height sub", "by (metis \"2.prems\"(1) \"2.prems\"(2) list_split Cons order_impl_root_order r_split root_order.simps(2) some_child_sub(1) del_height split_set(1) sub_height(2))"], ["proof (state)\nthis:\n  bal (del k x sub)\n  height (del k x sub) = height sub\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  bal (del k x sub)\n  height (del k x sub) = height sub\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "have \"bal (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t)", "using \"2.prems\"(3) list_split Cons r_split split_conc"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n  split ts x = (ls, rs__)\n  rs__ = r # rs\n  r = (sub, sep)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t)", "by blast"], ["proof (state)\nthis:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  bal (del k x sub)\n  height (del k x sub) = height sub\n  bal (Node (ls @ (sub, sep) # rs) t)", "have \"bal (Node (ls@(del k x sub,sep)#rs) t)\""], ["proof (prove)\nusing this:\n  bal (del k x sub)\n  height (del k x sub) = height sub\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (del k x sub, sep) # rs) t)", "using bal_substitute_subtree[of ls sub sep rs t \"del k x sub\"]"], ["proof (prove)\nusing this:\n  bal (del k x sub)\n  height (del k x sub) = height sub\n  bal (Node (ls @ (sub, sep) # rs) t)\n  \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t);\n   height sub = height (del k x sub); bal (del k x sub)\\<rbrakk>\n  \\<Longrightarrow> bal (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (del k x sub, sep) # rs) t)", "by metis"], ["proof (state)\nthis:\n  bal (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (del k x sub, sep) # rs) t)", "have \"bal (rebalance_middle_tree k ls (del k x sub) sep rs t)\""], ["proof (prove)\nusing this:\n  bal (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls (del k x sub) sep rs t)", "using rebalance_middle_tree_bal[of ls \"del k x sub\" sep rs t k]"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (del k x sub, sep) # rs) t)\n  bal (Node (ls @ (del k x sub, sep) # rs) t) \\<Longrightarrow>\n  bal (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls (del k x sub) sep rs t)", "by metis"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (rebalance_middle_tree k ls (del k x sub) sep rs t)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "using 2 list_split Cons r_split sep_n_x"], ["proof (prove)\nusing this:\n  bal (rebalance_middle_tree k ls (del k x sub) sep rs t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, rs__)\n  rs__ = r # rs\n  r = (sub, sep)\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  bal (del k x (Node ts t))\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "case sep_x_Leaf"], ["proof (state)\nthis:\n  sep = x \\<and> sub = Leaf\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  sep = x \\<and> sub = Leaf\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "have \"bal (Node (ls@rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (ls @ rs) t)", "using bal_split_last(1) list_split split_conc r_split"], ["proof (prove)\nusing this:\n  bal (Node (?ls @ (?sub, ?sep) # ?rs) ?t) \\<Longrightarrow>\n  bal (Node (?ls @ ?rs) ?t)\n  split ts x = (ls, rs__)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n  r = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ rs) t)", "by (metis \"2.prems\"(3) Cons)"], ["proof (state)\nthis:\n  bal (Node (ls @ rs) t)\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow> bal (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  sep = x \\<and> sub = Leaf\n  bal (Node (ls @ rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n  bal (Node (ls @ rs) t)\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "using 2 list_split Cons r_split"], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n  bal (Node (ls @ rs) t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, rs__)\n  rs__ = r # rs\n  r = (sub, sep)\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  bal (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "case sep_x_Node"], ["proof (state)\nthis:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)", "obtain sts st where sub_node: \"sub = Node sts st\""], ["proof (prove)\nusing this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>sts st.\n        sub = Node sts st \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sub = Node sts st\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sub = Node sts st", "obtain sub_s max_s where sub_split: \"split_max k sub = (sub_s, max_s)\""], ["proof (prove)\nusing this:\n  sub = Node sts st\n\ngoal (1 subgoal):\n 1. (\\<And>sub_s max_s.\n        split_max k sub = (sub_s, max_s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_max k sub\")"], ["proof (state)\nthis:\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split_max k sub = (sub_s, max_s)", "have \"height sub_s = height sub\""], ["proof (prove)\nusing this:\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. height sub_s = height sub", "using split_max_height"], ["proof (prove)\nusing this:\n  split_max k sub = (sub_s, max_s)\n  \\<lbrakk>split_max ?k ?t = (?sub, ?sep); nonempty_lasttreebal ?t;\n   ?t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?t\n\ngoal (1 subgoal):\n 1. height sub_s = height sub", "by (metis \"2.prems\"(1) \"2.prems\"(2) btree.distinct(1) list_split Cons order_bal_nonempty_lasttreebal order_impl_root_order r_split root_order.simps(2) some_child_sub(1) split_set(1) sub_height(2) sub_node)"], ["proof (state)\nthis:\n  height sub_s = height sub\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  height sub_s = height sub\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "have \"bal sub_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal sub_s", "using split_max_bal"], ["proof (prove)\nusing this:\n  \\<lbrakk>bal ?t; ?t \\<noteq> Leaf; nonempty_lasttreebal ?t\\<rbrakk>\n  \\<Longrightarrow> bal (fst (split_max ?k ?t))\n\ngoal (1 subgoal):\n 1. bal sub_s", "by (metis \"2.prems\"(1) \"2.prems\"(2) btree.distinct(1) fst_conv list_split local.Cons order_bal_nonempty_lasttreebal order_impl_root_order r_split root_order.simps(2) some_child_sub(1) split_set(1) sub_height(2) sub_node sub_split)"], ["proof (state)\nthis:\n  bal sub_s\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  bal sub_s\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "have \"bal (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t)", "using \"2.prems\"(3) list_split Cons r_split split_conc"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n  split ts x = (ls, rs__)\n  rs__ = r # rs\n  r = (sub, sep)\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub, sep) # rs) t)", "by blast"], ["proof (state)\nthis:\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  height sub_s = height sub\n  bal sub_s\n  bal (Node (ls @ (sub, sep) # rs) t)", "have \"bal (Node (ls@(sub_s,sep)#rs) t)\""], ["proof (prove)\nusing this:\n  height sub_s = height sub\n  bal sub_s\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub_s, sep) # rs) t)", "using bal_substitute_subtree[of ls sub sep rs t \"sub_s\"]"], ["proof (prove)\nusing this:\n  height sub_s = height sub\n  bal sub_s\n  bal (Node (ls @ (sub, sep) # rs) t)\n  \\<lbrakk>bal (Node (ls @ (sub, sep) # rs) t); height sub = height sub_s;\n   bal sub_s\\<rbrakk>\n  \\<Longrightarrow> bal (Node (ls @ (sub_s, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub_s, sep) # rs) t)", "by metis"], ["proof (state)\nthis:\n  bal (Node (ls @ (sub_s, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (sub_s, sep) # rs) t)", "have \"bal (Node (ls@(sub_s,max_s)#rs) t)\""], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub_s, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub_s, max_s) # rs) t)", "using bal_substitute_separator"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub_s, sep) # rs) t)\n  bal (Node (?ls @ (?a, ?b) # ?rs) ?t) \\<Longrightarrow>\n  bal (Node (?ls @ (?a, ?c) # ?rs) ?t)\n\ngoal (1 subgoal):\n 1. bal (Node (ls @ (sub_s, max_s) # rs) t)", "by metis"], ["proof (state)\nthis:\n  bal (Node (ls @ (sub_s, max_s) # rs) t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (Node (ls @ (sub_s, max_s) # rs) t)", "have \"bal (rebalance_middle_tree k ls sub_s max_s rs t)\""], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub_s, max_s) # rs) t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub_s max_s rs t)", "using rebalance_middle_tree_bal[of ls sub_s max_s rs t k]"], ["proof (prove)\nusing this:\n  bal (Node (ls @ (sub_s, max_s) # rs) t)\n  bal (Node (ls @ (sub_s, max_s) # rs) t) \\<Longrightarrow>\n  bal (rebalance_middle_tree k ls sub_s max_s rs t)\n\ngoal (1 subgoal):\n 1. bal (rebalance_middle_tree k ls sub_s max_s rs t)", "by metis"], ["proof (state)\nthis:\n  bal (rebalance_middle_tree k ls sub_s max_s rs t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    bal (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  bal (rebalance_middle_tree k ls sub_s max_s rs t)", "show ?thesis"], ["proof (prove)\nusing this:\n  bal (rebalance_middle_tree k ls sub_s max_s rs t)\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "using 2 list_split Cons r_split sep_x_Node sub_node sub_split"], ["proof (prove)\nusing this:\n  bal (rebalance_middle_tree k ls sub_s max_s rs t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> bal (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> bal (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, rs__)\n  rs__ = r # rs\n  r = (sub, sep)\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n  sub = Node sts st\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. bal (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  bal (del k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal (del k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bal (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> bal (del k x Leaf)", "qed simp"], ["", "lemma rebalance_middle_tree_order:\n  assumes \"almost_order k sub\"\n    and \"\\<forall>s \\<in> set (subtrees (ls@rs)). order k s\" \"order k t\"\n    and \"case rs of (rsub,rsep) # list \\<Rightarrow> height rsub = height t | [] \\<Rightarrow> True\"\n    and \"length (ls@(sub,sep)#rs) \\<le> 2*k\"\n    and \"height sub = height t\"\n  shows \"almost_order k (rebalance_middle_tree k ls sub sep rs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "proof(cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow>\n    almost_order k (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "case Leaf"], ["proof (state)\nthis:\n  t = Leaf\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow>\n    almost_order k (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  t = Leaf", "have \"sub = Leaf\""], ["proof (prove)\nusing this:\n  t = Leaf\n\ngoal (1 subgoal):\n 1. sub = Leaf", "using height_Leaf assms"], ["proof (prove)\nusing this:\n  t = Leaf\n  (height ?t = 0) = (?t = Leaf)\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. sub = Leaf", "by auto"], ["proof (state)\nthis:\n  sub = Leaf\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow>\n    almost_order k (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  sub = Leaf", "show ?thesis"], ["proof (prove)\nusing this:\n  sub = Leaf\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "using Leaf assms"], ["proof (prove)\nusing this:\n  sub = Leaf\n  t = Leaf\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "case t_node: (Node tts tt)"], ["proof (state)\nthis:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  t = Node tts tt", "obtain mts mt where sub_node: \"sub = Node mts mt\""], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t = Node tts tt\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases sub) (auto)"], ["proof (state)\nthis:\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  sub = Node mts mt", "show ?thesis"], ["proof (prove)\nusing this:\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "proof(cases \"length mts \\<ge> k \\<and> length tts \\<ge> k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "case True"], ["proof (state)\nthis:\n  k \\<le> length mts \\<and> k \\<le> length tts\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  k \\<le> length mts \\<and> k \\<le> length tts", "have \"order k sub\""], ["proof (prove)\nusing this:\n  k \\<le> length mts \\<and> k \\<le> length tts\n\ngoal (1 subgoal):\n 1. order k sub", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> length mts \\<and> k \\<le> length tts\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. order k sub", "by (simp add: sub_node)"], ["proof (state)\nthis:\n  order k sub\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  order k sub", "show ?thesis"], ["proof (prove)\nusing this:\n  order k sub\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "using True t_node sub_node assms"], ["proof (prove)\nusing this:\n  order k sub\n  k \\<le> length mts \\<and> k \\<le> length tts\n  t = Node tts tt\n  sub = Node mts mt\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "case False"], ["proof (state)\nthis:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "have \"order_up\\<^sub>i k (node\\<^sub>i k (mts@(mt,sep)#tts) tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "using node\\<^sub>i_order[of k \"mts@(mt,sep)#tts\" tt] assms(1,3) t_node sub_node"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<le> length (mts @ (mt, sep) # tts);\n   length (mts @ (mt, sep) # tts) \\<le> 4 * k + 1;\n   \\<forall>x\\<in>set (subtrees (mts @ (mt, sep) # tts)). order k x;\n   order k tt\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k\n                     (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n  almost_order k sub\n  order k t\n  t = Node tts tt\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "by (auto simp del: order_up\\<^sub>i.simps node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n     rs = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "apply(cases \"node\\<^sub>i k (mts@(mt,sep)#tts) tt\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "using assms t_node sub_node False Nil"], ["proof (prove)\nusing this:\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n  t = Node tts tt\n  sub = Node mts mt\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  rs = []\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "apply (auto simp del: node\\<^sub>i.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "case (Cons r rs)"], ["proof (state)\nthis:\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  rs = r # rs", "obtain rsub rsep where r_split: \"r = (rsub,rsep)\""], ["proof (prove)\nusing this:\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. (\\<And>rsub rsep.\n        r = (rsub, rsep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = (rsub, rsep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  r = (rsub, rsep)", "have rsub_height: \"height rsub = height t\""], ["proof (prove)\nusing this:\n  r = (rsub, rsep)\n\ngoal (1 subgoal):\n 1. height rsub = height t", "using assms Cons"], ["proof (prove)\nusing this:\n  r = (rsub, rsep)\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. height rsub = height t", "by auto"], ["proof (state)\nthis:\n  height rsub = height t\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  height rsub = height t", "obtain rts rt where r_node: \"rsub = (Node rts rt)\""], ["proof (prove)\nusing this:\n  height rsub = height t\n\ngoal (1 subgoal):\n 1. (\\<And>rts rt.\n        rsub = Node rts rt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases rsub)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n     height rsub = height t; rsub = Leaf\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n        height rsub = height t; rsub = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> thesis", "using t_node"], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n     height rsub = height t; rsub = Leaf\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<And>rts rt. rsub = Node rts rt \\<Longrightarrow> thesis;\n        height rsub = height t; rsub = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  rsub = Node rts rt\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "have \"order_up\\<^sub>i k (node\\<^sub>i k (mts@(mt,sep)#rts) rt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)", "using node\\<^sub>i_order[of k \"mts@(mt,sep)#rts\" rt] assms(1,2) t_node sub_node r_node r_split Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<le> length (mts @ (mt, sep) # rts);\n   length (mts @ (mt, sep) # rts) \\<le> 4 * k + 1;\n   \\<forall>x\\<in>set (subtrees (mts @ (mt, sep) # rts)). order k x;\n   order k rt\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k\n                     (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  t = Node tts tt\n  sub = Node mts mt\n  rsub = Node rts rt\n  r = (rsub, rsep)\n  rs = r # rs\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)", "by (auto simp del: order_up\\<^sub>i.simps node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<not> (k \\<le> length mts \\<and> k \\<le> length tts);\n        rs = a # list\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # rts) rt)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "apply(cases \"node\\<^sub>i k (mts@(mt,sep)#rts) rt\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "using assms t_node sub_node False Cons r_split r_node"], ["proof (prove)\nusing this:\n  almost_order k sub\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  order k t\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n  t = Node tts tt\n  sub = Node mts mt\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  rs = r # rs\n  r = (rsub, rsep)\n  rsub = Node rts rt\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # rts) rt);\n        node\\<^sub>i k (mts @ (mt, sep) # rts) rt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "apply (auto simp del: node\\<^sub>i.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* we have to proof the order invariant once for an underflowing last tree *)"], ["", "lemma rebalance_middle_tree_last_order:\n  assumes \"almost_order k t\"\n    and  \"\\<forall>s \\<in> set (subtrees (ls@(sub,sep)#rs)). order k s\"\n    and \"rs = []\"\n    and \"length (ls@(sub,sep)#rs) \\<le> 2*k\"\n    and \"height sub = height t\"\n  shows \"almost_order k (rebalance_middle_tree k ls sub sep rs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow>\n    almost_order k (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "case Leaf"], ["proof (state)\nthis:\n  t = Leaf\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow>\n    almost_order k (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  t = Leaf", "have \"sub = Leaf\""], ["proof (prove)\nusing this:\n  t = Leaf\n\ngoal (1 subgoal):\n 1. sub = Leaf", "using height_Leaf assms"], ["proof (prove)\nusing this:\n  t = Leaf\n  (height ?t = 0) = (?t = Leaf)\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. sub = Leaf", "by auto"], ["proof (state)\nthis:\n  sub = Leaf\n\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow>\n    almost_order k (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  sub = Leaf", "show ?thesis"], ["proof (prove)\nusing this:\n  sub = Leaf\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "using Leaf assms"], ["proof (prove)\nusing this:\n  sub = Leaf\n  t = Leaf\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "case t_node: (Node tts tt)"], ["proof (state)\nthis:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  t = Node tts tt", "obtain mts mt where sub_node: \"sub = Node mts mt\""], ["proof (prove)\nusing this:\n  t = Node tts tt\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  t = Node tts tt\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. (\\<And>mts mt.\n        sub = Node mts mt \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases sub) (auto)"], ["proof (state)\nthis:\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       almost_order k (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  sub = Node mts mt", "show ?thesis"], ["proof (prove)\nusing this:\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "proof(cases \"length mts \\<ge> k \\<and> length tts \\<ge> k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "case True"], ["proof (state)\nthis:\n  k \\<le> length mts \\<and> k \\<le> length tts\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  k \\<le> length mts \\<and> k \\<le> length tts", "have \"order k sub\""], ["proof (prove)\nusing this:\n  k \\<le> length mts \\<and> k \\<le> length tts\n\ngoal (1 subgoal):\n 1. order k sub", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> length mts \\<and> k \\<le> length tts\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. order k sub", "by (simp add: sub_node)"], ["proof (state)\nthis:\n  order k sub\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sub = Node mts mt;\n     k \\<le> length mts \\<and> k \\<le> length tts\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  order k sub", "show ?thesis"], ["proof (prove)\nusing this:\n  order k sub\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "using True t_node sub_node assms"], ["proof (prove)\nusing this:\n  order k sub\n  k \\<le> length mts \\<and> k \\<le> length tts\n  t = Node tts tt\n  sub = Node mts mt\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "case False"], ["proof (state)\nthis:\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "have \"order_up\\<^sub>i k (node\\<^sub>i k (mts@(mt,sep)#tts) tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "using node\\<^sub>i_order[of k \"mts@(mt,sep)#tts\" tt] assms t_node sub_node"], ["proof (prove)\nusing this:\n  \\<lbrakk>k \\<le> length (mts @ (mt, sep) # tts);\n   length (mts @ (mt, sep) # tts) \\<le> 4 * k + 1;\n   \\<forall>x\\<in>set (subtrees (mts @ (mt, sep) # tts)). order k x;\n   order k tt\\<rbrakk>\n  \\<Longrightarrow> order_up\\<^sub>i k\n                     (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n  t = Node tts tt\n  sub = Node mts mt\n\ngoal (1 subgoal):\n 1. order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "by (auto simp del: order_up\\<^sub>i.simps node\\<^sub>i.simps)"], ["proof (state)\nthis:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sub = Node mts mt;\n     \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\\<rbrakk>\n    \\<Longrightarrow> almost_order k\n                       (rebalance_middle_tree k ls sub sep rs t)", "then"], ["proof (chain)\npicking this:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)", "show ?thesis"], ["proof (prove)\nusing this:\n  order_up\\<^sub>i k (node\\<^sub>i k (mts @ (mt, sep) # tts) tt)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub sep rs t)", "apply(cases \"node\\<^sub>i k (mts@(mt,sep)#tts) tt\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "using assms t_node sub_node False Nil"], ["proof (prove)\nusing this:\n  almost_order k t\n  \\<forall>s\\<in>set (subtrees (ls @ (sub, sep) # rs)). order k s\n  rs = []\n  length (ls @ (sub, sep) # rs) \\<le> 2 * k\n  height sub = height t\n  t = Node tts tt\n  sub = Node mts mt\n  \\<not> (k \\<le> length mts \\<and> k \\<le> length tts)\n  ([], []) \\<in> listrel ?r\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt = T\\<^sub>i x1\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>order_up\\<^sub>i k\n                 (node\\<^sub>i k (mts @ (mt, sep) # tts) tt);\n        node\\<^sub>i k (mts @ (mt, sep) # tts) tt =\n        Up\\<^sub>i x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> almost_order k\n                          (rebalance_middle_tree k ls sub sep rs t)", "apply (auto simp del: node\\<^sub>i.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub sep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rebalance_last_tree_order:\n  assumes \"ts = ls@[(sub,sep)]\"\n    and \"\\<forall>s \\<in> set (subtrees (ts)). order k s\" \"almost_order k t\"\n    and \"length ts \\<le> 2*k\"\n    and \"height sub = height t\"\n  shows \"almost_order k (rebalance_last_tree k ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_order k (rebalance_last_tree k ts t)", "using rebalance_middle_tree_last_order assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>almost_order ?k ?t;\n   \\<forall>s\\<in>set (subtrees (?ls @ (?sub, ?sep) # ?rs)). order ?k s;\n   ?rs = []; length (?ls @ (?sub, ?sep) # ?rs) \\<le> 2 * ?k;\n   height ?sub = height ?t\\<rbrakk>\n  \\<Longrightarrow> almost_order ?k\n                     (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t)\n  ts = ls @ [(sub, sep)]\n  \\<forall>s\\<in>set (subtrees ts). order k s\n  almost_order k t\n  length ts \\<le> 2 * k\n  height sub = height t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_last_tree k ts t)", "by auto"], ["", "lemma split_max_order:\n  assumes \"order k t\"\n    and \"t \\<noteq> Leaf\"\n    and \"nonempty_lasttreebal t\"\n  shows \"almost_order k (fst (split_max k t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k t))", "using assms"], ["proof (prove)\nusing this:\n  order k t\n  t \\<noteq> Leaf\n  nonempty_lasttreebal t\n\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k t))", "proof(induction k t rule: split_max.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; order k t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> almost_order k (fst (split_max k t));\n        order k (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))\n 2. \\<And>a.\n       \\<lbrakk>order a Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order a (fst (split_max a Leaf))", "case (1 k ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; order k t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (fst (split_max k t))\n  order k (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; order k t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> almost_order k (fst (split_max k t));\n        order k (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))\n 2. \\<And>a.\n       \\<lbrakk>order a Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order a (fst (split_max a Leaf))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; order k t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (fst (split_max k t))\n  order k (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)", "obtain ls sub sep where ts_not_empty: \"ts = ls@[(sub,sep)]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; order k t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (fst (split_max k t))\n  order k (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>ls sub sep.\n        ts = ls @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ts = ls @ [(sub, sep)]\n\ngoal (2 subgoals):\n 1. \\<And>k ts t.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>t = Node x21 x22; order k t; t \\<noteq> Leaf;\n                    nonempty_lasttreebal t\\<rbrakk>\n                   \\<Longrightarrow> almost_order k (fst (split_max k t));\n        order k (Node ts t); Node ts t \\<noteq> Leaf;\n        nonempty_lasttreebal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))\n 2. \\<And>a.\n       \\<lbrakk>order a Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order a (fst (split_max a Leaf))", "then"], ["proof (chain)\npicking this:\n  ts = ls @ [(sub, sep)]", "show ?case"], ["proof (prove)\nusing this:\n  ts = ls @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k (Node ts t)))", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = ls @ [(sub, sep)]; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "case Leaf"], ["proof (state)\nthis:\n  t = Leaf\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ts = ls @ [(sub, sep)]; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))\n 2. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  t = Leaf", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Leaf\n\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k (Node ts t)))", "using ts_not_empty 1"], ["proof (prove)\nusing this:\n  t = Leaf\n  ts = ls @ [(sub, sep)]\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; order k t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (fst (split_max k t))\n  order k (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k (Node ts t)))", "by auto"], ["proof (state)\nthis:\n  almost_order k (fst (split_max k (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "case (Node)"], ["proof (state)\nthis:\n  t = Node x21_ x22_\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  t = Node x21_ x22_", "obtain s_sub s_max where sub_split: \"split_max k t = (s_sub, s_max)\""], ["proof (prove)\nusing this:\n  t = Node x21_ x22_\n\ngoal (1 subgoal):\n 1. (\\<And>s_sub s_max.\n        split_max k t = (s_sub, s_max) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_max k t\")"], ["proof (state)\nthis:\n  split_max k t = (s_sub, s_max)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "moreover"], ["proof (state)\nthis:\n  split_max k t = (s_sub, s_max)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "have \"height sub = height s_sub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height sub = height s_sub", "by (metis \"1.prems\"(3) Node Pair_inject append1_eq_conv btree.distinct(1) nonempty_lasttreebal.simps(2) split_max_height sub_split ts_not_empty)"], ["proof (state)\nthis:\n  height sub = height s_sub\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "ultimately"], ["proof (chain)\npicking this:\n  split_max k t = (s_sub, s_max)\n  height sub = height s_sub", "have \"almost_order k (rebalance_last_tree k ts s_sub)\""], ["proof (prove)\nusing this:\n  split_max k t = (s_sub, s_max)\n  height sub = height s_sub\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_last_tree k ts s_sub)", "using rebalance_last_tree_order[of ts ls sub sep k s_sub]\n        1 ts_not_empty Node sub_split"], ["proof (prove)\nusing this:\n  split_max k t = (s_sub, s_max)\n  height sub = height s_sub\n  \\<lbrakk>ts = ls @ [(sub, sep)];\n   \\<forall>s\\<in>set (subtrees ts). order k s; almost_order k s_sub;\n   length ts \\<le> 2 * k; height sub = height s_sub\\<rbrakk>\n  \\<Longrightarrow> almost_order k (rebalance_last_tree k ts s_sub)\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; order k t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (fst (split_max k t))\n  order k (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n  ts = ls @ [(sub, sep)]\n  t = Node x21_ x22_\n  split_max k t = (s_sub, s_max)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_last_tree k ts s_sub)", "by force"], ["proof (state)\nthis:\n  almost_order k (rebalance_last_tree k ts s_sub)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>ts = ls @ [(sub, sep)]; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> almost_order k (fst (split_max k (Node ts t)))", "then"], ["proof (chain)\npicking this:\n  almost_order k (rebalance_last_tree k ts s_sub)", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_last_tree k ts s_sub)\n\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k (Node ts t)))", "using Node 1 sub_split"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_last_tree k ts s_sub)\n  t = Node x21_ x22_\n  \\<lbrakk>t = Node ?x21.0 ?x22.0; order k t; t \\<noteq> Leaf;\n   nonempty_lasttreebal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (fst (split_max k t))\n  order k (Node ts t)\n  Node ts t \\<noteq> Leaf\n  nonempty_lasttreebal (Node ts t)\n  split_max k t = (s_sub, s_max)\n\ngoal (1 subgoal):\n 1. almost_order k (fst (split_max k (Node ts t)))", "by auto"], ["proof (state)\nthis:\n  almost_order k (fst (split_max k (Node ts t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_order k (fst (split_max k (Node ts t)))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>order a Leaf; Leaf \\<noteq> Leaf;\n        nonempty_lasttreebal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order a (fst (split_max a Leaf))", "qed simp"], ["", "lemma del_order:\n  assumes \"k > 0\"\n    and \"root_order k t\"\n    and \"bal t\"\n  shows \"almost_order k (del k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_order k (del k x t)", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  root_order k t\n  bal t\n\ngoal (1 subgoal):\n 1. almost_order k (del k x t)", "proof (induction k x t rule: del.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> almost_order k (del k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> almost_order k (del k x xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> almost_order k (del k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> almost_order k (del k x xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)", "obtain ls list where list_split: \"split ts x = (ls, list)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>ls list.\n        split ts x = (ls, list) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split ts x\")"], ["proof (state)\nthis:\n  split ts x = (ls, list)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t\\<rbrakk>\n                   \\<Longrightarrow> almost_order k (del k x t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb\\<rbrakk>\n           \\<Longrightarrow> almost_order k (del k x xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t)\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, list)", "show ?case"], ["proof (prove)\nusing this:\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "proof (cases list)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "case Nil"], ["proof (state)\nthis:\n  list = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  list = []", "have \"almost_order k (del k x t)\""], ["proof (prove)\nusing this:\n  list = []\n\ngoal (1 subgoal):\n 1. almost_order k (del k x t)", "using 2 list_split"], ["proof (prove)\nusing this:\n  list = []\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x t)", "by (simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  almost_order k (del k x t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  almost_order k (del k x t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "obtain lls lsub lsep where ls_split: \"ls = lls@[(lsub,lsep)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lls lsub lsep.\n        ls = lls @ [(lsub, lsep)] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 2 Nil list_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  list = []\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. (\\<And>lls lsub lsep.\n        ls = lls @ [(lsub, lsep)] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Nil2 nonempty_lasttreebal.simps(2) order_bal_nonempty_lasttreebal split_conc)"], ["proof (state)\nthis:\n  ls = lls @ [(lsub, lsep)]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  ls = lls @ [(lsub, lsep)]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "have \"height t = height (del k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = height (del k x t)", "using del_height 2"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> height (del ?k ?x ?t) = height ?t\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. height t = height (del k x t)", "by (simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  height t = height (del k x t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  height t = height (del k x t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "have \"length ls = length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ls = length ts", "using Nil list_split"], ["proof (prove)\nusing this:\n  list = []\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. length ls = length ts", "by (auto dest: split_length)"], ["proof (state)\nthis:\n  length ls = length ts\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  almost_order k (del k x t)\n  ls = lls @ [(lsub, lsep)]\n  height t = height (del k x t)\n  length ls = length ts", "have \"almost_order k (rebalance_last_tree k ls (del k x t))\""], ["proof (prove)\nusing this:\n  almost_order k (del k x t)\n  ls = lls @ [(lsub, lsep)]\n  height t = height (del k x t)\n  length ls = length ts\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_last_tree k ls (del k x t))", "using rebalance_last_tree_order[of ls lls lsub lsep k \"del k x t\"]"], ["proof (prove)\nusing this:\n  almost_order k (del k x t)\n  ls = lls @ [(lsub, lsep)]\n  height t = height (del k x t)\n  length ls = length ts\n  \\<lbrakk>ls = lls @ [(lsub, lsep)];\n   \\<forall>s\\<in>set (subtrees ls). order k s; almost_order k (del k x t);\n   length ls \\<le> 2 * k; height lsub = height (del k x t)\\<rbrakk>\n  \\<Longrightarrow> almost_order k (rebalance_last_tree k ls (del k x t))\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_last_tree k ls (del k x t))", "by (metis \"2.prems\"(2) \"2.prems\"(3) Un_iff append_Nil2 bal.simps(2) list_split Nil root_order.simps(2) singletonI split_conc subtrees_split)"], ["proof (state)\nthis:\n  almost_order k (rebalance_last_tree k ls (del k x t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>split ts x = (ls, list); list = []\\<rbrakk>\n    \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  almost_order k (rebalance_last_tree k ls (del k x t))", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_last_tree k ls (del k x t))\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "using 2 list_split Nil"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_last_tree k ls (del k x t))\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n  list = []\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  almost_order k (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "case (Cons r rs)"], ["proof (state)\nthis:\n  list = r # rs\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "from Cons"], ["proof (chain)\npicking this:\n  list = r # rs", "obtain sub sep where r_split: \"r = (sub,sep)\""], ["proof (prove)\nusing this:\n  list = r # rs\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        r = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "have inductive_help:\n      \"case rs of [] \\<Rightarrow> True | (rsub,rsep)#_ \\<Rightarrow> height rsub = height t\"\n      \"\\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\"\n      \"Suc (length (ls @ rs)) \\<le> 2 * k\"\n      \"order k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case rs of [] \\<Rightarrow> True\n     | (rsub, rsep) # x \\<Rightarrow> height rsub = height t &&&\n     \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s) &&&\n    Suc (length (ls @ rs)) \\<le> 2 * k &&& order k t", "using Cons r_split \"2.prems\" list_split split_set"], ["proof (prove)\nusing this:\n  list = r # rs\n  r = (sub, sep)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n  split ?ts ?z = (?ls, (?a, ?b) # ?rs) \\<Longrightarrow>\n  (?a, ?b) \\<in> set ?ts\n  \\<lbrakk>split ?ts ?z = (?ls, (?a, ?b) # ?rs);\n   (?x, ?y) \\<in> set ?ls\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> set ?ts\n  \\<lbrakk>split ?ts ?z = (?ls, (?a, ?b) # ?rs);\n   (?x, ?y) \\<in> set ?rs\\<rbrakk>\n  \\<Longrightarrow> (?x, ?y) \\<in> set ?ts\n  split ?ts ?z = (?ls, (?a, ?b) # ?rs) \\<Longrightarrow>\n  set ?ls \\<union> set ?rs \\<union> {(?a, ?b)} = set ?ts\n  split ?ts ?z = (?ls, (?a, ?b) # ?rs) \\<Longrightarrow>\n  \\<exists>x\\<in>set ?ts. ?b \\<in> Basic_BNFs.snds x\n\ngoal (1 subgoal):\n 1. (case rs of [] \\<Rightarrow> True\n     | (rsub, rsep) # x \\<Rightarrow> height rsub = height t &&&\n     \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s) &&&\n    Suc (length (ls @ rs)) \\<le> 2 * k &&& order k t", "by (auto dest: split_conc split!: list.splits)"], ["proof (state)\nthis:\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  Suc (length (ls @ rs)) \\<le> 2 * k\n  order k t\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "consider (sep_n_x) \"sep \\<noteq> x\" |\n      (sep_x_Leaf) \"sep = x \\<and> sub = Leaf\" |\n      (sep_x_Node) \"sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using btree.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Leaf \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = Node x21 x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a lista.\n       \\<lbrakk>split ts x = (ls, list); list = a # lista\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "case sep_n_x"], ["proof (state)\nthis:\n  sep \\<noteq> x\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep \\<noteq> x", "have \"almost_order k (del k x sub)\""], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. almost_order k (del k x sub)", "using 2 list_split Cons r_split order_impl_root_order"], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  split ts x = (ls, list)\n  list = r # rs\n  r = (sub, sep)\n  \\<lbrakk>0 < ?k; order ?k ?t\\<rbrakk> \\<Longrightarrow> root_order ?k ?t\n\ngoal (1 subgoal):\n 1. almost_order k (del k x sub)", "by (metis bal.simps(2) root_order.simps(2) some_child_sub(1) split_set(1))"], ["proof (state)\nthis:\n  almost_order k (del k x sub)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  almost_order k (del k x sub)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "have \"height (del k x sub) = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height (del k x sub) = height t", "by (metis \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) bal.simps(2) list_split Cons order_impl_root_order r_split root_order.simps(2) some_child_sub(1) del_height split_set(1))"], ["proof (state)\nthis:\n  height (del k x sub) = height t\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  almost_order k (del k x sub)\n  height (del k x sub) = height t", "have \"almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)\""], ["proof (prove)\nusing this:\n  almost_order k (del k x sub)\n  height (del k x sub) = height t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)", "using rebalance_middle_tree_order[of k \"del k x sub\" ls rs t sep]"], ["proof (prove)\nusing this:\n  almost_order k (del k x sub)\n  height (del k x sub) = height t\n  \\<lbrakk>almost_order k (del k x sub);\n   \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s; order k t;\n   case rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height t;\n   length (ls @ (del k x sub, sep) # rs) \\<le> 2 * k;\n   height (del k x sub) = height t\\<rbrakk>\n  \\<Longrightarrow> almost_order k\n                     (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)", "using inductive_help"], ["proof (prove)\nusing this:\n  almost_order k (del k x sub)\n  height (del k x sub) = height t\n  \\<lbrakk>almost_order k (del k x sub);\n   \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s; order k t;\n   case rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height t;\n   length (ls @ (del k x sub, sep) # rs) \\<le> 2 * k;\n   height (del k x sub) = height t\\<rbrakk>\n  \\<Longrightarrow> almost_order k\n                     (rebalance_middle_tree k ls (del k x sub) sep rs t)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  Suc (length (ls @ rs)) \\<le> 2 * k\n  order k t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)", "using Cons r_split sep_n_x list_split"], ["proof (prove)\nusing this:\n  almost_order k (del k x sub)\n  height (del k x sub) = height t\n  \\<lbrakk>almost_order k (del k x sub);\n   \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s; order k t;\n   case rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height t;\n   length (ls @ (del k x sub, sep) # rs) \\<le> 2 * k;\n   height (del k x sub) = height t\\<rbrakk>\n  \\<Longrightarrow> almost_order k\n                     (rebalance_middle_tree k ls (del k x sub) sep rs t)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  Suc (length (ls @ rs)) \\<le> 2 * k\n  order k t\n  list = r # rs\n  r = (sub, sep)\n  sep \\<noteq> x\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow> almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "using 2 Cons r_split sep_n_x list_split"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_middle_tree k ls (del k x sub) sep rs t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  list = r # rs\n  r = (sub, sep)\n  sep \\<noteq> x\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  almost_order k (del k x (Node ts t))\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "case sep_x_Leaf"], ["proof (state)\nthis:\n  sep = x \\<and> sub = Leaf\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep = x \\<and> sub = Leaf", "have \"almost_order k (Node (ls@rs) t)\""], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n\ngoal (1 subgoal):\n 1. almost_order k (Node (ls @ rs) t)", "using inductive_help"], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  Suc (length (ls @ rs)) \\<le> 2 * k\n  order k t\n\ngoal (1 subgoal):\n 1. almost_order k (Node (ls @ rs) t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (Node (ls @ rs) t)\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  almost_order k (Node (ls @ rs) t)", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_order k (Node (ls @ rs) t)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "using 2 Cons r_split sep_x_Leaf list_split"], ["proof (prove)\nusing this:\n  almost_order k (Node (ls @ rs) t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  list = r # rs\n  r = (sub, sep)\n  sep = x \\<and> sub = Leaf\n  split ts x = (ls, list)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  almost_order k (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "case sep_x_Node"], ["proof (state)\nthis:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)", "obtain sts st where sub_node: \"sub = Node sts st\""], ["proof (prove)\nusing this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. (\\<And>sts st.\n        sub = Node sts st \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  sub = Node sts st\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sub = Node sts st", "obtain sub_s max_s where sub_split: \"split_max k sub = (sub_s, max_s)\""], ["proof (prove)\nusing this:\n  sub = Node sts st\n\ngoal (1 subgoal):\n 1. (\\<And>sub_s max_s.\n        split_max k sub = (sub_s, max_s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"split_max k sub\")"], ["proof (state)\nthis:\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split_max k sub = (sub_s, max_s)", "have \"height sub_s = height t\""], ["proof (prove)\nusing this:\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. height sub_s = height t", "using split_max_height"], ["proof (prove)\nusing this:\n  split_max k sub = (sub_s, max_s)\n  \\<lbrakk>split_max ?k ?t = (?sub, ?sep); nonempty_lasttreebal ?t;\n   ?t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?t\n\ngoal (1 subgoal):\n 1. height sub_s = height t", "by (metis \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) bal.simps(2) btree.distinct(1) list_split Cons order_bal_nonempty_lasttreebal order_impl_root_order r_split root_order.simps(2) some_child_sub(1) split_set(1) sub_node)"], ["proof (state)\nthis:\n  height sub_s = height t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "moreover"], ["proof (state)\nthis:\n  height sub_s = height t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "have \"almost_order k sub_s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. almost_order k sub_s", "using split_max_order"], ["proof (prove)\nusing this:\n  \\<lbrakk>order ?k ?t; ?t \\<noteq> Leaf; nonempty_lasttreebal ?t\\<rbrakk>\n  \\<Longrightarrow> almost_order ?k (fst (split_max ?k ?t))\n\ngoal (1 subgoal):\n 1. almost_order k sub_s", "by (metis \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) bal.simps(2) btree.distinct(1) fst_conv list_split local.Cons order_bal_nonempty_lasttreebal order_impl_root_order r_split root_order.simps(2) some_child_sub(1) split_set(1)  sub_node sub_split)"], ["proof (state)\nthis:\n  almost_order k sub_s\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "ultimately"], ["proof (chain)\npicking this:\n  height sub_s = height t\n  almost_order k sub_s", "have \"almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)\""], ["proof (prove)\nusing this:\n  height sub_s = height t\n  almost_order k sub_s\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)", "using rebalance_middle_tree_order[of k sub_s ls rs t max_s] inductive_help"], ["proof (prove)\nusing this:\n  height sub_s = height t\n  almost_order k sub_s\n  \\<lbrakk>almost_order k sub_s;\n   \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s; order k t;\n   case rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height t;\n   length (ls @ (sub_s, max_s) # rs) \\<le> 2 * k;\n   height sub_s = height t\\<rbrakk>\n  \\<Longrightarrow> almost_order k\n                     (rebalance_middle_tree k ls sub_s max_s rs t)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # x \\<Rightarrow> height rsub = height t\n  \\<forall>s\\<in>set (subtrees (ls @ rs)). order k s\n  Suc (length (ls @ rs)) \\<le> 2 * k\n  order k t\n\ngoal (1 subgoal):\n 1. almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)", "by auto"], ["proof (state)\nthis:\n  almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    almost_order k (del k x (Node ts t))", "then"], ["proof (chain)\npicking this:\n  almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)", "show ?thesis"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "using 2 Cons r_split list_split sep_x_Node sub_split"], ["proof (prove)\nusing this:\n  almost_order k (rebalance_middle_tree k ls sub_s max_s rs t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t;\n   bal t\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb;\n   bal ?xb\\<rbrakk>\n  \\<Longrightarrow> almost_order k (del k x ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  list = r # rs\n  r = (sub, sep)\n  split ts x = (ls, list)\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n  split_max k sub = (sub_s, max_s)\n\ngoal (1 subgoal):\n 1. almost_order k (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  almost_order k (del k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_order k (del k x (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  almost_order k (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf\\<rbrakk>\n       \\<Longrightarrow> almost_order k (del k x Leaf)", "qed simp"], ["", "(* sortedness of delete by inorder *)\n(* generalize del_list_sorted since its cumbersome to express inorder_list ts as xs @ [a]\nnote that the proof scheme is almost identical to ins_list_sorted\n *)"], ["", "thm del_list_sorted"], ["", "lemma del_list_split:\n  assumes \"split ts x = (ls, rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n  shows \"del_list x (inorder (Node ts t)) = inorder_list ls @ del_list x (inorder_list rs @ inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "proof (cases ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "case Nil"], ["proof (state)\nthis:\n  ls = []\n\ngoal (2 subgoals):\n 1. ls = [] \\<Longrightarrow>\n    del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)\n 2. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "then"], ["proof (chain)\npicking this:\n  ls = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = []\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "using assms"], ["proof (prove)\nusing this:\n  ls = []\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "by (auto dest!: split_conc)"], ["proof (state)\nthis:\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ del_list x (inorder_list rs @ inorder t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "case Cons"], ["proof (state)\nthis:\n  ls = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "then"], ["proof (chain)\npicking this:\n  ls = a_ # list_", "obtain ls' sub sep where ls_tail_split: \"ls = ls' @ [(sub,sep)]\""], ["proof (prove)\nusing this:\n  ls = a_ # list_\n\ngoal (1 subgoal):\n 1. (\\<And>ls' sub sep.\n        ls = ls' @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis list.distinct(1) rev_exhaust surj_pair)"], ["proof (state)\nthis:\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "moreover"], ["proof (state)\nthis:\n  ls = ls' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "have \"sep < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sep < x", "using split_req(2)[of ts x ls' sub sep rs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n\ngoal (1 subgoal):\n 1. sep < x", "using assms(1) assms(2) ls_tail_split sorted_inorder_separators"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls' @ [(sub, sep)], rs);\n   sorted_less (separators ts)\\<rbrakk>\n  \\<Longrightarrow> sep < x\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n  ls = ls' @ [(sub, sep)]\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (1 subgoal):\n 1. sep < x", "by blast"], ["proof (state)\nthis:\n  sep < x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "moreover"], ["proof (state)\nthis:\n  sep < x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "have \"sorted_less (inorder_list ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder_list ls)", "using assms sorted_wrt_append split_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  sorted_less (inorder (Node ts t))\n  sorted_wrt ?P (?xs @ ?ys) =\n  (sorted_wrt ?P ?xs \\<and>\n   sorted_wrt ?P ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. ?P x y))\n  split ?xs ?p = (?ls, ?rs) \\<Longrightarrow> ?xs = ?ls @ ?rs\n\ngoal (1 subgoal):\n 1. sorted_less (inorder_list ls)", "by fastforce"], ["proof (state)\nthis:\n  sorted_less (inorder_list ls)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ls = a # list \\<Longrightarrow>\n       del_list x (inorder (Node ts t)) =\n       inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "ultimately"], ["proof (chain)\npicking this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "using assms(2) split_conc[OF assms(1)]"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "using del_list_sorted[of \"inorder_list ls' @ inorder sub\" sep]"], ["proof (prove)\nusing this:\n  ls = ls' @ [(sub, sep)]\n  sep < x\n  sorted_less (inorder_list ls)\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n  sorted_less\n   ((inorder_list ls' @ inorder sub) @ sep # ?ys) \\<Longrightarrow>\n  del_list ?x ((inorder_list ls' @ inorder sub) @ sep # ?ys) =\n  (if ?x < sep then del_list ?x (inorder_list ls' @ inorder sub) @ sep # ?ys\n   else (inorder_list ls' @ inorder sub) @ del_list ?x (sep # ?ys))\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ del_list x (inorder_list rs @ inorder t)", "by auto"], ["proof (state)\nthis:\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ del_list x (inorder_list rs @ inorder t)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* del sorted requires sortedness of the full list so we need to change the right specialization a bit *)"], ["", "lemma del_list_split_right:\n  assumes \"split ts x = (ls, (sub,sep)#rs)\"\n    and \"sorted_less (inorder (Node ts t))\"\n    and \"sep \\<noteq> x\"\n  shows \"del_list x (inorder_list ((sub,sep)#rs) @ inorder t) = del_list x (inorder sub) @ sep # inorder_list rs @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "from assms"], ["proof (chain)\npicking this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x", "have \"x < sep\""], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < sep", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n     sorted_less (inorder (Node ts t)); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x < sep", "from assms"], ["proof (chain)\npicking this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x", "have \"sorted_less (separators ts)\""], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. sorted_less (separators ts)", "using sorted_inorder_separators"], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n  sorted_less (inorder (Node ?ts ?t)) \\<Longrightarrow>\n  sorted_less (separators ?ts)\n\ngoal (1 subgoal):\n 1. sorted_less (separators ts)", "by blast"], ["proof (state)\nthis:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n     sorted_less (inorder (Node ts t)); sep \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> x < sep", "then"], ["proof (chain)\npicking this:\n  sorted_less (separators ts)", "show ?thesis"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n\ngoal (1 subgoal):\n 1. x < sep", "using split_req(3)"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n  \\<lbrakk>split ?xs ?p = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (separators ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?sep\n\ngoal (1 subgoal):\n 1. x < sep", "using assms"], ["proof (prove)\nusing this:\n  sorted_less (separators ts)\n  \\<lbrakk>split ?xs ?p = (?ls, (?sub, ?sep) # ?rs);\n   sorted_less (separators ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> ?sep\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. x < sep", "by fastforce"], ["proof (state)\nthis:\n  x < sep\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x < sep\n\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "moreover"], ["proof (state)\nthis:\n  x < sep\n\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "have \"sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)", "using assms sorted_wrt_append[where xs=\"inorder_list ls\"]"], ["proof (prove)\nusing this:\n  split ts x = (ls, (sub, sep) # rs)\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n  sorted_wrt ?P (inorder_list ls @ ?ys) =\n  (sorted_wrt ?P (inorder_list ls) \\<and>\n   sorted_wrt ?P ?ys \\<and>\n   (\\<forall>x\\<in>set (inorder_list ls). \\<forall>y\\<in>set ?ys. ?P x y))\n\ngoal (1 subgoal):\n 1. sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)", "by (auto dest!: split_conc)"], ["proof (state)\nthis:\n  sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)\n\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "ultimately"], ["proof (chain)\npicking this:\n  x < sep\n  sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)", "show ?thesis"], ["proof (prove)\nusing this:\n  x < sep\n  sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)\n\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "using del_list_sorted[of \"inorder sub\" \"sep\"]"], ["proof (prove)\nusing this:\n  x < sep\n  sorted_less (inorder sub @ sep # inorder_list rs @ inorder t)\n  sorted_less (inorder sub @ sep # ?ys) \\<Longrightarrow>\n  del_list ?x (inorder sub @ sep # ?ys) =\n  (if ?x < sep then del_list ?x (inorder sub) @ sep # ?ys\n   else inorder sub @ del_list ?x (sep # ?ys))\n\ngoal (1 subgoal):\n 1. del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "by auto"], ["proof (state)\nthis:\n  del_list x (inorder_list ((sub, sep) # rs) @ inorder t) =\n  del_list x (inorder sub) @ sep # inorder_list rs @ inorder t\n\ngoal:\nNo subgoals!", "qed"], ["", "thm del_list_idem"], ["", "lemma del_inorder:\n  assumes \"k > 0\"\n    and \"root_order k t\"\n    and \"bal t\"\n    and \"sorted_less (inorder t)\"\n  shows \"inorder (del k x t) = del_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (del k x t) = del_list x (inorder t)", "using assms"], ["proof (prove)\nusing this:\n  0 < k\n  root_order k t\n  bal t\n  sorted_less (inorder t)\n\ngoal (1 subgoal):\n 1. inorder (del k x t) = del_list x (inorder t)", "proof (induction k x t rule: del.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf;\n        sorted_less (inorder Leaf)\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x Leaf) = del_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t; sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder (del k x t) =\n                                     del_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb;\n            sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder (del k x xb) = del_list x (inorder xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x (Node ts t)) =\n                         del_list x (inorder (Node ts t))", "case (2 k x ts t)"], ["proof (state)\nthis:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t; bal t;\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder (del k x t) = del_list x (inorder t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb; bal ?xb;\n   sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder (del k x ?xb) = del_list x (inorder ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sorted_less (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf;\n        sorted_less (inorder Leaf)\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x Leaf) = del_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t; sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder (del k x t) =\n                                     del_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb;\n            sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder (del k x xb) = del_list x (inorder xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x (Node ts t)) =\n                         del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t; bal t;\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder (del k x t) = del_list x (inorder t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb; bal ?xb;\n   sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder (del k x ?xb) = del_list x (inorder ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sorted_less (inorder (Node ts t))", "obtain ls rs where list_split: \"split ts x = (ls, rs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = []; 0 < k; root_order k t; bal t;\n   sorted_less (inorder t)\\<rbrakk>\n  \\<Longrightarrow> inorder (del k x t) = del_list x (inorder t)\n  \\<lbrakk>(?xa, ?y) = split ts x; ?y = ?x21.0 # ?x22.0;\n   (?xb, ?ya) = ?x21.0; ?ya \\<noteq> x; 0 < k; root_order k ?xb; bal ?xb;\n   sorted_less (inorder ?xb)\\<rbrakk>\n  \\<Longrightarrow> inorder (del k x ?xb) = del_list x (inorder ?xb)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. (\\<And>ls rs.\n        split ts x = (ls, rs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson surj_pair)"], ["proof (state)\nthis:\n  split ts x = (ls, rs)\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf;\n        sorted_less (inorder Leaf)\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x Leaf) = del_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t; sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder (del k x t) =\n                                     del_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb;\n            sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder (del k x xb) = del_list x (inorder xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x (Node ts t)) =\n                         del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  split ts x = (ls, rs)", "have list_conc: \"ts = ls @ rs\""], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n\ngoal (1 subgoal):\n 1. ts = ls @ rs", "using split.split_conc split_axioms"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  \\<lbrakk>split ?split; ?split ?xs ?p = (?ls, ?rs)\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ls @ ?rs\n  split split\n\ngoal (1 subgoal):\n 1. ts = ls @ rs", "by blast"], ["proof (state)\nthis:\n  ts = ls @ rs\n\ngoal (2 subgoals):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf;\n        sorted_less (inorder Leaf)\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x Leaf) = del_list x (inorder Leaf)\n 2. \\<And>k x ts t.\n       \\<lbrakk>\\<And>xa y.\n                   \\<lbrakk>(xa, y) = split ts x; y = []; 0 < k;\n                    root_order k t; bal t; sorted_less (inorder t)\\<rbrakk>\n                   \\<Longrightarrow> inorder (del k x t) =\n                                     del_list x (inorder t);\n        \\<And>xa y x21 x22 xb ya.\n           \\<lbrakk>(xa, y) = split ts x; y = x21 # x22; (xb, ya) = x21;\n            ya \\<noteq> x; 0 < k; root_order k xb; bal xb;\n            sorted_less (inorder xb)\\<rbrakk>\n           \\<Longrightarrow> inorder (del k x xb) = del_list x (inorder xb);\n        0 < k; root_order k (Node ts t); bal (Node ts t);\n        sorted_less (inorder (Node ts t))\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x (Node ts t)) =\n                         del_list x (inorder (Node ts t))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "proof (cases rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "case Nil"], ["proof (state)\nthis:\n  rs = []\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs = []", "have IH: \"inorder (del k x t) = del_list x (inorder t)\""], ["proof (prove)\nusing this:\n  rs = []\n\ngoal (1 subgoal):\n 1. inorder (del k x t) = del_list x (inorder t)", "by (metis \"2.IH\"(1) \"2.prems\" bal.simps(2) list_split order_impl_root_order root_order.simps(2) sorted_inorder_induct_last)"], ["proof (state)\nthis:\n  inorder (del k x t) = del_list x (inorder t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"inorder (del k x (Node ts t)) = inorder (rebalance_last_tree k ts (del k x t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) =\n    inorder (rebalance_last_tree k ts (del k x t))", "using list_split Nil list_conc"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs)\n  rs = []\n  ts = ls @ rs\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) =\n    inorder (rebalance_last_tree k ts (del k x t))", "by auto"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) =\n  inorder (rebalance_last_tree k ts (del k x t))\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) =\n  inorder (rebalance_last_tree k ts (del k x t))\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ts @ inorder (del k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "obtain ts' sub sep where ts_split: \"ts = ts' @ [(sub, sep)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ts' sub sep.\n        ts = ts' @ [(sub, sep)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) nonempty_lasttreebal.simps(2) order_bal_nonempty_lasttreebal)"], ["proof (state)\nthis:\n  ts = ts' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "then"], ["proof (chain)\npicking this:\n  ts = ts' @ [(sub, sep)]", "have \"height sub = height t\""], ["proof (prove)\nusing this:\n  ts = ts' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. height sub = height t", "using \"2.prems\"(3)"], ["proof (prove)\nusing this:\n  ts = ts' @ [(sub, sep)]\n  bal (Node ts t)\n\ngoal (1 subgoal):\n 1. height sub = height t", "by auto"], ["proof (state)\nthis:\n  height sub = height t\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "moreover"], ["proof (state)\nthis:\n  height sub = height t\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "have \"height t = height (del k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = height (del k x t)", "by (metis \"2.prems\"(1) \"2.prems\"(2) \"2.prems\"(3) bal.simps(2) del_height order_impl_root_order root_order.simps(2))"], ["proof (state)\nthis:\n  height t = height (del k x t)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "ultimately"], ["proof (chain)\npicking this:\n  height sub = height t\n  height t = height (del k x t)", "show ?thesis"], ["proof (prove)\nusing this:\n  height sub = height t\n  height t = height (del k x t)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "using rebalance_last_tree_inorder"], ["proof (prove)\nusing this:\n  height sub = height t\n  height t = height (del k x t)\n  \\<lbrakk>height ?t = height ?sub; ?ts = ?list @ [(?sub, ?sep)]\\<rbrakk>\n  \\<Longrightarrow> inorder (rebalance_last_tree ?k ?ts ?t) =\n                    inorder (Node ?ts ?t)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "using ts_split"], ["proof (prove)\nusing this:\n  height sub = height t\n  height t = height (del k x t)\n  \\<lbrakk>height ?t = height ?sub; ?ts = ?list @ [(?sub, ?sep)]\\<rbrakk>\n  \\<Longrightarrow> inorder (rebalance_last_tree ?k ?ts ?t) =\n                    inorder (Node ?ts ?t)\n  ts = ts' @ [(sub, sep)]\n\ngoal (1 subgoal):\n 1. inorder (rebalance_last_tree k ts (del k x t)) =\n    inorder_list ts @ inorder (del k x t)", "by auto"], ["proof (state)\nthis:\n  inorder (rebalance_last_tree k ts (del k x t)) =\n  inorder_list ts @ inorder (del k x t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder (rebalance_last_tree k ts (del k x t)) =\n  inorder_list ts @ inorder (del k x t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder (rebalance_last_tree k ts (del k x t)) =\n  inorder_list ts @ inorder (del k x t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ts @ del_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ts @ inorder (del k x t) =\n    inorder_list ts @ del_list x (inorder t)", "using IH"], ["proof (prove)\nusing this:\n  inorder (del k x t) = del_list x (inorder t)\n\ngoal (1 subgoal):\n 1. inorder_list ts @ inorder (del k x t) =\n    inorder_list ts @ del_list x (inorder t)", "by blast"], ["proof (state)\nthis:\n  inorder_list ts @ inorder (del k x t) =\n  inorder_list ts @ del_list x (inorder t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ts @ inorder (del k x t) =\n  inorder_list ts @ del_list x (inorder t)\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = del_list x (inorder (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ts @ del_list x (inorder t) =\n    del_list x (inorder (Node ts t))", "using \"2.prems\"(4) list_conc list_split Nil del_list_split"], ["proof (prove)\nusing this:\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs\n  split ts x = (ls, rs)\n  rs = []\n  \\<lbrakk>split ?ts ?x = (?ls, ?rs);\n   sorted_less (inorder (Node ?ts ?t))\\<rbrakk>\n  \\<Longrightarrow> del_list ?x (inorder (Node ?ts ?t)) =\n                    inorder_list ?ls @\n                    del_list ?x (inorder_list ?rs @ inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder_list ts @ del_list x (inorder t) =\n    del_list x (inorder (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder_list ts @ del_list x (inorder t) =\n  del_list x (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. rs = [] \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "."], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "case (Cons h rs)"], ["proof (state)\nthis:\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs__ = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  rs__ = h # rs", "obtain sub sep where h_split: \"h = (sub,sep)\""], ["proof (prove)\nusing this:\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. (\\<And>sub sep.\n        h = (sub, sep) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases h)"], ["proof (state)\nthis:\n  h = (sub, sep)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs__ = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  h = (sub, sep)", "have node_sorted_split:\n      \"sorted_less (inorder (Node (ls@(sub,sep)#rs) t))\"\n      \"root_order k (Node (ls@(sub,sep)#rs) t)\"\n      \"bal (Node (ls@(sub,sep)#rs) t)\""], ["proof (prove)\nusing this:\n  h = (sub, sep)\n\ngoal (1 subgoal):\n 1. sorted_less (inorder (Node (ls @ (sub, sep) # rs) t)) &&&\n    root_order k (Node (ls @ (sub, sep) # rs) t) &&&\n    bal (Node (ls @ (sub, sep) # rs) t)", "using \"2.prems\" h_split list_conc Cons"], ["proof (prove)\nusing this:\n  h = (sub, sep)\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sorted_less (inorder (Node ts t))\n  h = (sub, sep)\n  ts = ls @ rs__\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. sorted_less (inorder (Node (ls @ (sub, sep) # rs) t)) &&&\n    root_order k (Node (ls @ (sub, sep) # rs) t) &&&\n    bal (Node (ls @ (sub, sep) # rs) t)", "by blast+"], ["proof (state)\nthis:\n  sorted_less (inorder (Node (ls @ (sub, sep) # rs) t))\n  root_order k (Node (ls @ (sub, sep) # rs) t)\n  bal (Node (ls @ (sub, sep) # rs) t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs__ = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "consider (sep_n_x) \"sep \\<noteq> x\" | (sep_x_Leaf) \"sep = x \\<and> sub = Leaf\" |  (sep_x_Node) \"sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using btree.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = Leaf \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = Node x21 x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> thesis;\n     sep = x \\<and> sub = Leaf \\<Longrightarrow> thesis;\n     sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       rs__ = a # list \\<Longrightarrow>\n       inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>sep \\<noteq> x \\<Longrightarrow> ?thesis;\n   sep = x \\<and> sub = Leaf \\<Longrightarrow> ?thesis;\n   sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "case sep_n_x"], ["proof (state)\nthis:\n  sep \\<noteq> x\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep \\<noteq> x", "have IH: \"inorder (del k x sub) = del_list x (inorder sub)\""], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. inorder (del k x sub) = del_list x (inorder sub)", "by (metis \"2.IH\"(2) \"2.prems\"(1) \"2.prems\"(2) bal.simps(2) bal_split_left(1) h_split list_split local.Cons node_sorted_split(1) node_sorted_split(3) order_impl_root_order root_order.simps(2) some_child_sub(1) sorted_inorder_induct_subtree split_set(1))"], ["proof (state)\nthis:\n  inorder (del k x sub) = del_list x (inorder sub)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "from sep_n_x"], ["proof (chain)\npicking this:\n  sep \\<noteq> x", "have \"inorder (del k x (Node ts t)) = inorder (rebalance_middle_tree k ls (del k x sub) sep rs t)\""], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) =\n    inorder (rebalance_middle_tree k ls (del k x sub) sep rs t)", "using list_split Cons h_split"], ["proof (prove)\nusing this:\n  sep \\<noteq> x\n  split ts x = (ls, rs__)\n  rs__ = h # rs\n  h = (sub, sep)\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) =\n    inorder (rebalance_middle_tree k ls (del k x sub) sep rs t)", "by auto"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) =\n  inorder (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) =\n  inorder (rebalance_middle_tree k ls (del k x sub) sep rs t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder (Node (ls@(del k x sub, sep)#rs) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "have \"height t = height (del k x sub)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = height (del k x sub)", "using del_height"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> height (del ?k ?x ?t) = height ?t\n\ngoal (1 subgoal):\n 1. height t = height (del k x sub)", "using order_impl_root_order \"2.prems\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> height (del ?k ?x ?t) = height ?t\n  \\<lbrakk>0 < ?k; order ?k ?t\\<rbrakk> \\<Longrightarrow> root_order ?k ?t\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. height t = height (del k x sub)", "by (auto simp add: order_impl_root_order Cons list_conc h_split)"], ["proof (state)\nthis:\n  height t = height (del k x sub)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "moreover"], ["proof (state)\nthis:\n  height t = height (del k x sub)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "have \"case rs of [] \\<Rightarrow> True | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # list \\<Rightarrow> height rsub = height t", "using \"2.prems\"(3) bal_sub_height list_conc Cons"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n  bal (Node (?ls @ ?a # ?rs) ?t) \\<Longrightarrow>\n  case ?rs of [] \\<Rightarrow> True\n  | (sub, sep) # x \\<Rightarrow> height sub = height ?t\n  ts = ls @ rs__\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # list \\<Rightarrow> height rsub = height t", "by blast"], ["proof (state)\nthis:\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "ultimately"], ["proof (chain)\npicking this:\n  height t = height (del k x sub)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t", "show ?thesis"], ["proof (prove)\nusing this:\n  height t = height (del k x sub)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "using rebalance_middle_tree_inorder"], ["proof (prove)\nusing this:\n  height t = height (del k x sub)\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  \\<lbrakk>height ?t = height ?sub;\n   case ?rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height ?t\\<rbrakk>\n  \\<Longrightarrow> inorder\n                     (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t) =\n                    inorder (Node (?ls @ (?sub, ?sep) # ?rs) ?t)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n    inorder (Node (ls @ (del k x sub, sep) # rs) t)", "by simp"], ["proof (state)\nthis:\n  inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  inorder (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  inorder (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder (rebalance_middle_tree k ls (del k x sub) sep rs t) =\n  inorder (Node (ls @ (del k x sub, sep) # rs) t)\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ del_list x (inorder sub) @ sep # inorder_list rs @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (Node (ls @ (del k x sub, sep) # rs) t) =\n    inorder_list ls @\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "using IH"], ["proof (prove)\nusing this:\n  inorder (del k x sub) = del_list x (inorder sub)\n\ngoal (1 subgoal):\n 1. inorder (Node (ls @ (del k x sub, sep) # rs) t) =\n    inorder_list ls @\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t", "by simp"], ["proof (state)\nthis:\n  inorder (Node (ls @ (del k x sub, sep) # rs) t) =\n  inorder_list ls @\n  del_list x (inorder sub) @ sep # inorder_list rs @ inorder t\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder (Node (ls @ (del k x sub, sep) # rs) t) =\n  inorder_list ls @\n  del_list x (inorder sub) @ sep # inorder_list rs @ inorder t\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = del_list x (inorder (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t =\n    del_list x (inorder (Node ts t))", "using del_list_split[of ts x ls \"(sub,sep)#rs\" t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n   sorted_less (inorder (Node ts t))\\<rbrakk>\n  \\<Longrightarrow> del_list x (inorder (Node ts t)) =\n                    inorder_list ls @\n                    del_list x (inorder_list ((sub, sep) # rs) @ inorder t)\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t =\n    del_list x (inorder (Node ts t))", "using del_list_split_right[of ts x ls sub sep rs t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n   sorted_less (inorder (Node ts t))\\<rbrakk>\n  \\<Longrightarrow> del_list x (inorder (Node ts t)) =\n                    inorder_list ls @\n                    del_list x (inorder_list ((sub, sep) # rs) @ inorder t)\n  \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n   sorted_less (inorder (Node ts t)); sep \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> del_list x\n                     (inorder_list ((sub, sep) # rs) @ inorder t) =\n                    del_list x (inorder sub) @\n                    sep # inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t =\n    del_list x (inorder (Node ts t))", "using list_split list_conc h_split Cons \"2.prems\"(4) sep_n_x"], ["proof (prove)\nusing this:\n  \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n   sorted_less (inorder (Node ts t))\\<rbrakk>\n  \\<Longrightarrow> del_list x (inorder (Node ts t)) =\n                    inorder_list ls @\n                    del_list x (inorder_list ((sub, sep) # rs) @ inorder t)\n  \\<lbrakk>split ts x = (ls, (sub, sep) # rs);\n   sorted_less (inorder (Node ts t)); sep \\<noteq> x\\<rbrakk>\n  \\<Longrightarrow> del_list x\n                     (inorder_list ((sub, sep) # rs) @ inorder t) =\n                    del_list x (inorder sub) @\n                    sep # inorder_list rs @ inorder t\n  split ts x = (ls, rs__)\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  sorted_less (inorder (Node ts t))\n  sep \\<noteq> x\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    del_list x (inorder sub) @ sep # inorder_list rs @ inorder t =\n    del_list x (inorder (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @\n  del_list x (inorder sub) @ sep # inorder_list rs @ inorder t =\n  del_list x (inorder (Node ts t))\n\ngoal (3 subgoals):\n 1. sep \\<noteq> x \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 3. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "."], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "case sep_x_Leaf"], ["proof (state)\nthis:\n  sep = x \\<and> sub = Leaf\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  sep = x \\<and> sub = Leaf", "have \"del_list x (inorder (Node ts t)) = inorder (Node (ls@rs) t)\""], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) = inorder (Node (ls @ rs) t)", "using list_conc h_split Cons"], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) = inorder (Node (ls @ rs) t)", "using del_list_split[OF list_split \"2.prems\"(4)]"], ["proof (prove)\nusing this:\n  sep = x \\<and> sub = Leaf\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ del_list x (inorder_list rs__ @ inorder t)\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) = inorder (Node (ls @ rs) t)", "by simp"], ["proof (state)\nthis:\n  del_list x (inorder (Node ts t)) = inorder (Node (ls @ rs) t)\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  del_list x (inorder (Node ts t)) = inorder (Node (ls @ rs) t)\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder (del k x (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (Node (ls @ rs) t) = inorder (del k x (Node ts t))", "using list_split sep_x_Leaf list_conc h_split Cons"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs__)\n  sep = x \\<and> sub = Leaf\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. inorder (Node (ls @ rs) t) = inorder (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder (Node (ls @ rs) t) = inorder (del k x (Node ts t))\n\ngoal (2 subgoals):\n 1. sep = x \\<and> sub = Leaf \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n 2. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  del_list x (inorder (Node ts t)) = inorder (del k x (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  del_list x (inorder (Node ts t)) = inorder (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "by simp"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "case sep_x_Node"], ["proof (state)\nthis:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "obtain ssub ssep where split_split: \"split_max k sub = (ssub, ssep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ssub ssep.\n        split_max k sub = (ssub, ssep) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  split_max k sub = (ssub, ssep)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "from sep_x_Node"], ["proof (chain)\npicking this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)", "have \"x = sep\""], ["proof (prove)\nusing this:\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. x = sep", "by simp"], ["proof (state)\nthis:\n  x = sep\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "then"], ["proof (chain)\npicking this:\n  x = sep", "have \"del_list x (inorder (Node ts t)) = inorder_list ls @ inorder sub @ inorder_list rs @ inorder t\""], ["proof (prove)\nusing this:\n  x = sep\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ inorder sub @ inorder_list rs @ inorder t", "using list_split list_conc h_split Cons \"2.prems\"(4)"], ["proof (prove)\nusing this:\n  x = sep\n  split ts x = (ls, rs__)\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  sorted_less (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ inorder sub @ inorder_list rs @ inorder t", "using del_list_split[OF list_split \"2.prems\"(4)]"], ["proof (prove)\nusing this:\n  x = sep\n  split ts x = (ls, rs__)\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  sorted_less (inorder (Node ts t))\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ del_list x (inorder_list rs__ @ inorder t)\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ inorder sub @ inorder_list rs @ inorder t", "using del_list_sorted1[of \"inorder sub\" sep \"inorder_list rs @ inorder t\" x]\n          sorted_wrt_append"], ["proof (prove)\nusing this:\n  x = sep\n  split ts x = (ls, rs__)\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  sorted_less (inorder (Node ts t))\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ del_list x (inorder_list rs__ @ inorder t)\n  \\<lbrakk>sorted_less (inorder sub @ sep # inorder_list rs @ inorder t);\n   sep \\<le> x\\<rbrakk>\n  \\<Longrightarrow> del_list x\n                     (inorder sub @ sep # inorder_list rs @ inorder t) =\n                    inorder sub @\n                    del_list x (sep # inorder_list rs @ inorder t)\n  sorted_wrt ?P (?xs @ ?ys) =\n  (sorted_wrt ?P ?xs \\<and>\n   sorted_wrt ?P ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. ?P x y))\n\ngoal (1 subgoal):\n 1. del_list x (inorder (Node ts t)) =\n    inorder_list ls @ inorder sub @ inorder_list rs @ inorder t", "by auto"], ["proof (state)\nthis:\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ inorder sub @ inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  del_list x (inorder (Node ts t)) =\n  inorder_list ls @ inorder sub @ inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ inorder_pair (split_max k sub) @ inorder_list rs @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder sub @ inorder_list rs @ inorder t =\n    inorder_list ls @\n    inorder_pair (split_max k sub) @ inorder_list rs @ inorder t", "using sym[OF split_max_inorder[of sub k]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>nonempty_lasttreebal sub; sub \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder sub = inorder_pair (split_max k sub)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder sub @ inorder_list rs @ inorder t =\n    inorder_list ls @\n    inorder_pair (split_max k sub) @ inorder_list rs @ inorder t", "using order_bal_nonempty_lasttreebal[of k sub] \"2.prems\"\n          list_conc h_split Cons sep_x_Node"], ["proof (prove)\nusing this:\n  \\<lbrakk>nonempty_lasttreebal sub; sub \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> inorder sub = inorder_pair (split_max k sub)\n  \\<lbrakk>0 < k; root_order k sub; bal sub\\<rbrakk>\n  \\<Longrightarrow> nonempty_lasttreebal sub\n  0 < k\n  root_order k (Node ts t)\n  bal (Node ts t)\n  sorted_less (inorder (Node ts t))\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder sub @ inorder_list rs @ inorder t =\n    inorder_list ls @\n    inorder_pair (split_max k sub) @ inorder_list rs @ inorder t", "by (auto simp del: split_max.simps simp add: order_impl_root_order)"], ["proof (state)\nthis:\n  inorder_list ls @ inorder sub @ inorder_list rs @ inorder t =\n  inorder_list ls @\n  inorder_pair (split_max k sub) @ inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @ inorder sub @ inorder_list rs @ inorder t =\n  inorder_list ls @\n  inorder_pair (split_max k sub) @ inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @\n    inorder_pair (split_max k sub) @ inorder_list rs @ inorder t =\n    inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t", "using split_split"], ["proof (prove)\nusing this:\n  split_max k sub = (ssub, ssep)\n\ngoal (1 subgoal):\n 1. inorder_list ls @\n    inorder_pair (split_max k sub) @ inorder_list rs @ inorder t =\n    inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @\n  inorder_pair (split_max k sub) @ inorder_list rs @ inorder t =\n  inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @\n  inorder_pair (split_max k sub) @ inorder_list rs @ inorder t =\n  inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder (rebalance_middle_tree k ls ssub ssep rs t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "have \"height t = height ssub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. height t = height ssub", "using split_max_height"], ["proof (prove)\nusing this:\n  \\<lbrakk>split_max ?k ?t = (?sub, ?sep); nonempty_lasttreebal ?t;\n   ?t \\<noteq> Leaf\\<rbrakk>\n  \\<Longrightarrow> height ?sub = height ?t\n\ngoal (1 subgoal):\n 1. height t = height ssub", "by (metis \"2.prems\"(1,2,3) bal.simps(2) btree.distinct(1) h_split list_split local.Cons order_bal_nonempty_lasttreebal order_impl_root_order root_order.simps(2) sep_x_Node some_child_sub(1) split_set(1) split_split)"], ["proof (state)\nthis:\n  height t = height ssub\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "moreover"], ["proof (state)\nthis:\n  height t = height ssub\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "have \"case rs of [] \\<Rightarrow> True | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # list \\<Rightarrow> height rsub = height t", "using \"2.prems\"(3) bal_sub_height list_conc local.Cons"], ["proof (prove)\nusing this:\n  bal (Node ts t)\n  bal (Node (?ls @ ?a # ?rs) ?t) \\<Longrightarrow>\n  case ?rs of [] \\<Rightarrow> True\n  | (sub, sep) # x \\<Rightarrow> height sub = height ?t\n  ts = ls @ rs__\n  rs__ = h # rs\n\ngoal (1 subgoal):\n 1. case rs of [] \\<Rightarrow> True\n    | (rsub, rsep) # list \\<Rightarrow> height rsub = height t", "by blast"], ["proof (state)\nthis:\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "ultimately"], ["proof (chain)\npicking this:\n  height t = height ssub\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t", "show ?thesis"], ["proof (prove)\nusing this:\n  height t = height ssub\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "using rebalance_middle_tree_inorder"], ["proof (prove)\nusing this:\n  height t = height ssub\n  case rs of [] \\<Rightarrow> True\n  | (rsub, rsep) # list \\<Rightarrow> height rsub = height t\n  \\<lbrakk>height ?t = height ?sub;\n   case ?rs of [] \\<Rightarrow> True\n   | (rsub, rsep) # list \\<Rightarrow> height rsub = height ?t\\<rbrakk>\n  \\<Longrightarrow> inorder\n                     (rebalance_middle_tree ?k ?ls ?sub ?sep ?rs ?t) =\n                    inorder (Node (?ls @ (?sub, ?sep) # ?rs) ?t)\n\ngoal (1 subgoal):\n 1. inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n    inorder (rebalance_middle_tree k ls ssub ssep rs t)", "by auto"], ["proof (state)\nthis:\n  inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n  inorder (rebalance_middle_tree k ls ssub ssep rs t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n  inorder (rebalance_middle_tree k ls ssub ssep rs t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "also"], ["proof (state)\nthis:\n  inorder_list ls @ inorder ssub @ ssep # inorder_list rs @ inorder t =\n  inorder (rebalance_middle_tree k ls ssub ssep rs t)\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "have \"\\<dots> = inorder (del k x (Node ts t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls ssub ssep rs t) =\n    inorder (del k x (Node ts t))", "using list_split sep_x_Node list_conc h_split Cons split_split"], ["proof (prove)\nusing this:\n  split ts x = (ls, rs__)\n  sep = x \\<and> (\\<exists>ts t. sub = Node ts t)\n  ts = ls @ rs__\n  h = (sub, sep)\n  rs__ = h # rs\n  split_max k sub = (ssub, ssep)\n\ngoal (1 subgoal):\n 1. inorder (rebalance_middle_tree k ls ssub ssep rs t) =\n    inorder (del k x (Node ts t))", "by auto"], ["proof (state)\nthis:\n  inorder (rebalance_middle_tree k ls ssub ssep rs t) =\n  inorder (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. sep = x \\<and> (\\<exists>ts t. sub = Node ts t) \\<Longrightarrow>\n    inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "finally"], ["proof (chain)\npicking this:\n  del_list x (inorder (Node ts t)) = inorder (del k x (Node ts t))", "show ?thesis"], ["proof (prove)\nusing this:\n  del_list x (inorder (Node ts t)) = inorder (del k x (Node ts t))\n\ngoal (1 subgoal):\n 1. inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))", "by simp"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inorder (del k x (Node ts t)) = del_list x (inorder (Node ts t))\n\ngoal (1 subgoal):\n 1. \\<And>k x.\n       \\<lbrakk>0 < k; root_order k Leaf; bal Leaf;\n        sorted_less (inorder Leaf)\\<rbrakk>\n       \\<Longrightarrow> inorder (del k x Leaf) = del_list x (inorder Leaf)", "qed auto"], ["", "lemma reduce_root_order: \"\\<lbrakk>k > 0; almost_order k t\\<rbrakk> \\<Longrightarrow> root_order k (reduce_root t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; almost_order k t\\<rbrakk>\n    \\<Longrightarrow> root_order k (reduce_root t)", "apply(cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < k; almost_order k t; t = Leaf\\<rbrakk>\n    \\<Longrightarrow> root_order k (reduce_root t)\n 2. \\<And>x21 x22.\n       \\<lbrakk>0 < k; almost_order k t; t = Node x21 x22\\<rbrakk>\n       \\<Longrightarrow> root_order k (reduce_root t)", "apply(auto split!: list.splits simp add: order_impl_root_order)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reduce_root_bal: \"bal (reduce_root t) = bal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal (reduce_root t) = bal t", "apply(cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow> bal (reduce_root t) = bal t\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow> bal (reduce_root t) = bal t", "apply(auto split!: list.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reduce_root_inorder: \"inorder (reduce_root t) = inorder t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inorder (reduce_root t) = inorder t", "apply (cases t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. t = Leaf \\<Longrightarrow> inorder (reduce_root t) = inorder t\n 2. \\<And>x21 x22.\n       t = Node x21 x22 \\<Longrightarrow>\n       inorder (reduce_root t) = inorder t", "apply (auto split!: list.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma delete_order: \"\\<lbrakk>k > 0; bal t; root_order k t\\<rbrakk> \\<Longrightarrow> root_order k (delete k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; bal t; root_order k t\\<rbrakk>\n    \\<Longrightarrow> root_order k (delete k x t)", "using del_order"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> almost_order ?k (del ?k ?x ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; bal t; root_order k t\\<rbrakk>\n    \\<Longrightarrow> root_order k (delete k x t)", "by (simp add: reduce_root_order)"], ["", "lemma delete_bal: \"\\<lbrakk>k > 0; bal t; root_order k t\\<rbrakk> \\<Longrightarrow> bal (delete k x t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; bal t; root_order k t\\<rbrakk>\n    \\<Longrightarrow> bal (delete k x t)", "using del_bal"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t\\<rbrakk>\n  \\<Longrightarrow> bal (del ?k ?x ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; bal t; root_order k t\\<rbrakk>\n    \\<Longrightarrow> bal (delete k x t)", "by (simp add: reduce_root_bal)"], ["", "lemma delete_inorder: \"\\<lbrakk>k > 0; bal t; root_order k t; sorted_less (inorder t)\\<rbrakk> \\<Longrightarrow> inorder (delete k x t) = del_list x (inorder t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; bal t; root_order k t; sorted_less (inorder t)\\<rbrakk>\n    \\<Longrightarrow> inorder (delete k x t) = del_list x (inorder t)", "using del_inorder"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?k; root_order ?k ?t; bal ?t;\n   sorted_less (inorder ?t)\\<rbrakk>\n  \\<Longrightarrow> inorder (del ?k ?x ?t) = del_list ?x (inorder ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < k; bal t; root_order k t; sorted_less (inorder t)\\<rbrakk>\n    \\<Longrightarrow> inorder (delete k x t) = del_list x (inorder t)", "by (simp add: reduce_root_inorder)"], ["", "(* TODO (opt) runtime wrt runtime of split *)\n\n(* we are interested in a) number of comparisons b) number of fetches c) number of writes *)\n(* a) is dependent on t_split, the remainder is not (we assume the number of fetches and writes\nfor split fun is 0 *)\n\n\n(* TODO simpler induction schemes /less boilerplate isabelle/src/HOL/ex/Induction_Schema *)"], ["", "subsection \"Set specification by inorder\""], ["", "interpretation S_ordered: Set_by_Ordered where\n  empty = empty_btree and\n  insert = \"insert (Suc k)\" and\n  delete = \"delete (Suc k)\" and\n  isin = \"isin\" and\n  inorder = \"inorder\"   and\n  inv = \"invar_inorder (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set_by_Ordered empty_btree (local.insert (Suc k)) (delete (Suc k)) isin\n     inorder (invar_inorder (Suc k))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (7 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (inorder t))\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (local.insert (Suc k) x t) = ins_list x (inorder t)\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 5. invar_inorder (Suc k) empty_btree\n 6. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 7. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "case (2 s x)"], ["proof (state)\nthis:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (7 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       isin t x = (x \\<in> set (inorder t))\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (local.insert (Suc k) x t) = ins_list x (inorder t)\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 5. invar_inorder (Suc k) empty_btree\n 6. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 7. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "then"], ["proof (chain)\npicking this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)", "show ?case"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (1 subgoal):\n 1. isin s x = (x \\<in> set (inorder s))", "by (simp add: isin_set_inorder)"], ["proof (state)\nthis:\n  isin s x = (x \\<in> set (inorder s))\n\ngoal (6 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (local.insert (Suc k) x t) = ins_list x (inorder t)\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 4. invar_inorder (Suc k) empty_btree\n 5. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 6. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (local.insert (Suc k) x t) = ins_list x (inorder t)\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 4. invar_inorder (Suc k) empty_btree\n 5. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 6. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "case (3 s x)"], ["proof (state)\nthis:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (6 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (local.insert (Suc k) x t) = ins_list x (inorder t)\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 4. invar_inorder (Suc k) empty_btree\n 5. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 6. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "then"], ["proof (chain)\npicking this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)", "show ?case"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (1 subgoal):\n 1. inorder (local.insert (Suc k) x s) = ins_list x (inorder s)", "using insert_inorder"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n  sorted_less (inorder ?t) \\<Longrightarrow>\n  inorder (local.insert ?k ?x ?t) = ins_list ?x (inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder (local.insert (Suc k) x s) = ins_list x (inorder s)", "by simp"], ["proof (state)\nthis:\n  inorder (local.insert (Suc k) x s) = ins_list x (inorder s)\n\ngoal (5 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 3. invar_inorder (Suc k) empty_btree\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 5. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 3. invar_inorder (Suc k) empty_btree\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 5. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "case (4 s x)"], ["proof (state)\nthis:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (5 subgoals):\n 1. inorder empty_btree = []\n 2. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       inorder (delete (Suc k) x t) = del_list x (inorder t)\n 3. invar_inorder (Suc k) empty_btree\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 5. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "then"], ["proof (chain)\npicking this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)", "show ?case"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (1 subgoal):\n 1. inorder (delete (Suc k) x s) = del_list x (inorder s)", "using delete_inorder"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n  \\<lbrakk>0 < ?k; bal ?t; root_order ?k ?t;\n   sorted_less (inorder ?t)\\<rbrakk>\n  \\<Longrightarrow> inorder (delete ?k ?x ?t) = del_list ?x (inorder ?t)\n\ngoal (1 subgoal):\n 1. inorder (delete (Suc k) x s) = del_list x (inorder s)", "by auto"], ["proof (state)\nthis:\n  inorder (delete (Suc k) x s) = del_list x (inorder s)\n\ngoal (4 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "case (6 s x)"], ["proof (state)\nthis:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (4 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (local.insert (Suc k) x t)\n 4. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "then"], ["proof (chain)\npicking this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)", "show ?case"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (1 subgoal):\n 1. invar_inorder (Suc k) (local.insert (Suc k) x s)", "using insert_order insert_bal"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n  \\<lbrakk>0 < ?k; root_order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> root_order ?k (local.insert ?k ?x ?t)\n  bal ?t \\<Longrightarrow> bal (local.insert ?k ?x ?t)\n\ngoal (1 subgoal):\n 1. invar_inorder (Suc k) (local.insert (Suc k) x s)", "by auto"], ["proof (state)\nthis:\n  invar_inorder (Suc k) (local.insert (Suc k) x s)\n\ngoal (3 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "case (7 s x)"], ["proof (state)\nthis:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (3 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree\n 3. \\<And>t x.\n       invar_inorder (Suc k) t \\<and>\n       sorted_less (inorder t) \\<Longrightarrow>\n       invar_inorder (Suc k) (delete (Suc k) x t)", "then"], ["proof (chain)\npicking this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)", "show ?case"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n\ngoal (1 subgoal):\n 1. invar_inorder (Suc k) (delete (Suc k) x s)", "using delete_order delete_bal"], ["proof (prove)\nusing this:\n  invar_inorder (Suc k) s \\<and> sorted_less (inorder s)\n  \\<lbrakk>0 < ?k; bal ?t; root_order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> root_order ?k (delete ?k ?x ?t)\n  \\<lbrakk>0 < ?k; bal ?t; root_order ?k ?t\\<rbrakk>\n  \\<Longrightarrow> bal (delete ?k ?x ?t)\n\ngoal (1 subgoal):\n 1. invar_inorder (Suc k) (delete (Suc k) x s)", "by auto"], ["proof (state)\nthis:\n  invar_inorder (Suc k) (delete (Suc k) x s)\n\ngoal (2 subgoals):\n 1. inorder empty_btree = []\n 2. invar_inorder (Suc k) empty_btree", "qed (simp add: empty_btree_def)+"], ["", "(* if we remove this, it is not possible to remove the simp rules in subsequent contexts... *)"], ["", "declare node\\<^sub>i.simps[simp del]"], ["", "end"], ["", "end"]]}