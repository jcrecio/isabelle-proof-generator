{"file_name": "/home/qj213/afp-2021-10-22/thys/BTree/BTree_Split.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BTree", "problem_names": ["lemma linear_split_alt: \"linear_split xs x = (takeWhile (\\<lambda>(_,s). s<x) xs, dropWhile (\\<lambda>(_,s). s<x) xs)\"", "lemma some_child_sm: \"linear_split_help t y xs = (ls,(sub,sep)#rs) \\<Longrightarrow> y \\<le> sep\"", "lemma linear_split_append: \"linear_split_help xs p ys = (ls,rs) \\<Longrightarrow> ls@rs = ys@xs\"", "lemma linear_split_sm: \"\\<lbrakk>linear_split_help xs p ys = (ls,rs); sorted_less (separators (ys@xs)); \\<forall>sep \\<in> set (separators ys). p > sep\\<rbrakk> \\<Longrightarrow> \\<forall>sep \\<in> set (separators ls). p > sep\"", "lemma linear_split_gr:\n  \"\\<lbrakk>linear_split_help xs p ys = (ls,rs); sorted_less (separators (ys@xs)); \\<forall>(sub,sep) \\<in> set ys. p > sep\\<rbrakk> \\<Longrightarrow> \n(case rs of [] \\<Rightarrow> True | (_,sep)#_ \\<Rightarrow> p \\<le> sep)\"", "lemma linear_split_req:\n  assumes  \"linear_split xs p = (ls,(sub,sep)#rs)\"\n    and \"sorted_less (separators xs)\"\n  shows  \"p \\<le> sep\"", "lemma linear_split_req2:\n  assumes  \"linear_split xs p = (ls@[(sub,sep)],rs)\"\n    and \"sorted_less (separators xs)\"\n  shows  \"sep < p\"", "lemma \"binary_split_help as bs cs x = (ls,rs) \\<Longrightarrow> (as@bs@cs) = (ls@rs)\"", "lemma \"\\<lbrakk>sorted_less (separators (as@bs@cs)); binary_split_help as bs cs x = (ls,rs); \\<forall>y \\<in> set (separators as). y < x\\<rbrakk>\n\\<Longrightarrow> \\<forall>y \\<in> set (separators ls). y < x\""], "translations": [["", "lemma linear_split_alt: \"linear_split xs x = (takeWhile (\\<lambda>(_,s). s<x) xs, dropWhile (\\<lambda>(_,s). s<x) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_split xs x =\n    (takeWhile (\\<lambda>(uu_, s). s < x) xs,\n     dropWhile (\\<lambda>(uu_, s). s < x) xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linear_split xs x =\n    (takeWhile (\\<lambda>(uu_, s). s < x) xs,\n     dropWhile (\\<lambda>(uu_, s). s < x) xs)", "have \"linear_split_help xs x prev = (prev @ takeWhile (\\<lambda>(_, s). s < x) xs, dropWhile (\\<lambda>(_, s). s < x) xs)\"\n    for prev"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_split_help xs x prev =\n    (prev @ takeWhile (\\<lambda>(uu_, s). s < x) xs,\n     dropWhile (\\<lambda>(uu_, s). s < x) xs)", "apply (induction xs arbitrary: prev)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>prev.\n       linear_split_help [] x prev =\n       (prev @ takeWhile (\\<lambda>(uu_, s). s < x) [],\n        dropWhile (\\<lambda>(uu_, s). s < x) [])\n 2. \\<And>a xs prev.\n       (\\<And>prev.\n           linear_split_help xs x prev =\n           (prev @ takeWhile (\\<lambda>(uu_, s). s < x) xs,\n            dropWhile (\\<lambda>(uu_, s). s < x) xs)) \\<Longrightarrow>\n       linear_split_help (a # xs) x prev =\n       (prev @ takeWhile (\\<lambda>(uu_, s). s < x) (a # xs),\n        dropWhile (\\<lambda>(uu_, s). s < x) (a # xs))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  linear_split_help xs x ?prev =\n  (?prev @ takeWhile (\\<lambda>(uu_, s). s < x) xs,\n   dropWhile (\\<lambda>(uu_, s). s < x) xs)\n\ngoal (1 subgoal):\n 1. linear_split xs x =\n    (takeWhile (\\<lambda>(uu_, s). s < x) xs,\n     dropWhile (\\<lambda>(uu_, s). s < x) xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  linear_split_help xs x ?prev =\n  (?prev @ takeWhile (\\<lambda>(uu_, s). s < x) xs,\n   dropWhile (\\<lambda>(uu_, s). s < x) xs)\n\ngoal (1 subgoal):\n 1. linear_split xs x =\n    (takeWhile (\\<lambda>(uu_, s). s < x) xs,\n     dropWhile (\\<lambda>(uu_, s). s < x) xs)", "by auto"], ["proof (state)\nthis:\n  linear_split xs x =\n  (takeWhile (\\<lambda>(uu_, s). s < x) xs,\n   dropWhile (\\<lambda>(uu_, s). s < x) xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "global_interpretation btree_linear_search: split linear_split\n  (* the below definitions are required to be set here for evaluating example code... *)\n  defines btree_ls_isin = btree_linear_search.isin \n    and btree_ls_ins = btree_linear_search.ins\n    and btree_ls_insert = btree_linear_search.insert\n    and btree_ls_del = btree_linear_search.del\n    and btree_ls_delete = btree_linear_search.delete"], ["proof (prove)\ngoal (1 subgoal):\n 1. split linear_split", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs p ls rs.\n       linear_split xs p = (ls, rs) \\<Longrightarrow> xs = ls @ rs\n 2. \\<And>xs p ls sub sep rs.\n       \\<lbrakk>linear_split xs p = (ls @ [(sub, sep)], rs);\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> sep < p\n 3. \\<And>xs p ls sub sep rs.\n       \\<lbrakk>linear_split xs p = (ls, (sub, sep) # rs);\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> sep", "unfolding linear_split_alt"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xs p ls rs.\n       (takeWhile (\\<lambda>(uu_, s). s < p) xs,\n        dropWhile (\\<lambda>(uu_, s). s < p) xs) =\n       (ls, rs) \\<Longrightarrow>\n       xs = ls @ rs\n 2. \\<And>xs p ls sub sep rs.\n       \\<lbrakk>(takeWhile (\\<lambda>(uu_, s). s < p) xs,\n                 dropWhile (\\<lambda>(uu_, s). s < p) xs) =\n                (ls @ [(sub, sep)], rs);\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> sep < p\n 3. \\<And>xs p ls sub sep rs.\n       \\<lbrakk>(takeWhile (\\<lambda>(uu_, s). s < p) xs,\n                 dropWhile (\\<lambda>(uu_, s). s < p) xs) =\n                (ls, (sub, sep) # rs);\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> sep", "apply (auto split: list.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xs p ls sub sep.\n       \\<lbrakk>takeWhile (\\<lambda>(uu_, s). s < p) xs = ls @ [(sub, sep)];\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> sep < p\n 2. \\<And>xs p sub sep rs.\n       \\<lbrakk>dropWhile (\\<lambda>(uu_, s). s < p) xs = (sub, sep) # rs;\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> sep", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>takeWhile (\\<lambda>(uu_, s). s < p_) xs_ =\n             ls_ @ [(sub_, sep_)];\n     sorted_less (separators xs_)\\<rbrakk>\n    \\<Longrightarrow> sep_ < p_", "by (metis (no_types, lifting) case_prodD in_set_conv_decomp takeWhile_eq_all_conv takeWhile_idem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs p sub sep rs.\n       \\<lbrakk>dropWhile (\\<lambda>(uu_, s). s < p) xs = (sub, sep) # rs;\n        sorted_less (separators xs)\\<rbrakk>\n       \\<Longrightarrow> p \\<le> sep", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dropWhile (\\<lambda>(uu_, s). s < p_) xs_ = (sub_, sep_) # rs_;\n     sorted_less (separators xs_)\\<rbrakk>\n    \\<Longrightarrow> p_ \\<le> sep_", "by (metis case_prod_conv hd_dropWhile le_less_linear list.sel(1) list.simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"Some examples follow to show that the implementation works\n      and the above lemmas make sense. The examples are visualized in the thesis.\""], ["", "abbreviation \"btree\\<^sub>i \\<equiv> btree_ls_insert\""], ["", "abbreviation \"btree\\<^sub>d \\<equiv> btree_ls_delete\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      root_order k x\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      bal x\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      sorted_less (inorder x)\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      x\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      btree\\<^sub>i k 9 x\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      btree\\<^sub>i k 1 (btree\\<^sub>i k 9 x)\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      btree\\<^sub>d k 10 (btree\\<^sub>i k 1 (btree\\<^sub>i k 9 x))\""], ["", "value \"let k=2::nat; x::nat btree = (Node [(Node [(Leaf, 3),(Leaf, 5),(Leaf, 6)] Leaf, 10)] (Node [(Leaf, 14), (Leaf, 20)] Leaf)) in\n      btree\\<^sub>d k 3 (btree\\<^sub>d k 10 (btree\\<^sub>i k 1 (btree\\<^sub>i k 9 x)))\""], ["", "text \"For completeness, we also proved an explicit proof of the locale\nrequirements.\""], ["", "lemma some_child_sm: \"linear_split_help t y xs = (ls,(sub,sep)#rs) \\<Longrightarrow> y \\<le> sep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_split_help t y xs = (ls, (sub, sep) # rs) \\<Longrightarrow>\n    y \\<le> sep", "apply(induction t y xs rule: linear_split_help.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x prev.\n       linear_split_help [] x prev = (ls, (sub, sep) # rs) \\<Longrightarrow>\n       x \\<le> sep\n 2. \\<And>suba sepa xs x prev.\n       \\<lbrakk>\\<lbrakk>sepa < x;\n                 linear_split_help xs x (prev @ [(suba, sepa)]) =\n                 (ls, (sub, sep) # rs)\\<rbrakk>\n                \\<Longrightarrow> x \\<le> sep;\n        linear_split_help ((suba, sepa) # xs) x prev =\n        (ls, (sub, sep) # rs)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> sep", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>suba sepa xs x prev.\n       \\<lbrakk>\\<lbrakk>sepa < x;\n                 linear_split_help xs x (prev @ [(suba, sepa)]) =\n                 (ls, (sub, sep) # rs)\\<rbrakk>\n                \\<Longrightarrow> x \\<le> sep;\n        (if sepa < x then linear_split_help xs x (prev @ [(suba, sepa)])\n         else (prev, (suba, sepa) # xs)) =\n        (ls, (sub, sep) # rs)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> sep", "by (metis Pair_inject le_less_linear list.inject)"], ["", "lemma linear_split_append: \"linear_split_help xs p ys = (ls,rs) \\<Longrightarrow> ls@rs = ys@xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_split_help xs p ys = (ls, rs) \\<Longrightarrow> ls @ rs = ys @ xs", "apply(induction xs p ys rule: linear_split_help.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x prev.\n       linear_split_help [] x prev = (ls, rs) \\<Longrightarrow>\n       ls @ rs = prev @ []\n 2. \\<And>sub sep xs x prev.\n       \\<lbrakk>\\<lbrakk>sep < x;\n                 linear_split_help xs x (prev @ [(sub, sep)]) =\n                 (ls, rs)\\<rbrakk>\n                \\<Longrightarrow> ls @ rs = (prev @ [(sub, sep)]) @ xs;\n        linear_split_help ((sub, sep) # xs) x prev = (ls, rs)\\<rbrakk>\n       \\<Longrightarrow> ls @ rs = prev @ (sub, sep) # xs", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sub sep xs x prev.\n       \\<lbrakk>\\<lbrakk>sep < x;\n                 linear_split_help xs x (prev @ [(sub, sep)]) =\n                 (ls, rs)\\<rbrakk>\n                \\<Longrightarrow> ls @ rs = prev @ (sub, sep) # xs;\n        (if sep < x then linear_split_help xs x (prev @ [(sub, sep)])\n         else (prev, (sub, sep) # xs)) =\n        (ls, rs)\\<rbrakk>\n       \\<Longrightarrow> ls @ rs = prev @ (sub, sep) # xs", "by (metis Pair_inject)"], ["", "lemma linear_split_sm: \"\\<lbrakk>linear_split_help xs p ys = (ls,rs); sorted_less (separators (ys@xs)); \\<forall>sep \\<in> set (separators ys). p > sep\\<rbrakk> \\<Longrightarrow> \\<forall>sep \\<in> set (separators ls). p > sep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>linear_split_help xs p ys = (ls, rs);\n     sorted_less (separators (ys @ xs));\n     \\<forall>sep\\<in>set (separators ys). sep < p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>sep\\<in>set (separators ls). sep < p", "apply(induction xs p ys rule: linear_split_help.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x prev.\n       \\<lbrakk>linear_split_help [] x prev = (ls, rs);\n        sorted_less (separators (prev @ []));\n        \\<forall>sep\\<in>set (separators prev). sep < x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sep\\<in>set (separators ls). sep < x\n 2. \\<And>sub sep xs x prev.\n       \\<lbrakk>\\<lbrakk>sep < x;\n                 linear_split_help xs x (prev @ [(sub, sep)]) = (ls, rs);\n                 sorted_less (separators ((prev @ [(sub, sep)]) @ xs));\n                 \\<forall>sep\\<in>set (separators (prev @ [(sub, sep)])).\n                    sep < x\\<rbrakk>\n                \\<Longrightarrow> \\<forall>sep\\<in>set (separators ls).\n                                     sep < x;\n        linear_split_help ((sub, sep) # xs) x prev = (ls, rs);\n        sorted_less (separators (prev @ (sub, sep) # xs));\n        \\<forall>sep\\<in>set (separators prev). sep < x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sep\\<in>set (separators ls). sep < x", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sub sep xs x prev.\n       \\<lbrakk>\\<lbrakk>linear_split_help xs x (prev @ [(sub, sep)]) =\n                         (ls, rs);\n                 sep < x\\<rbrakk>\n                \\<Longrightarrow> \\<forall>sep\\<in>set ls. snd sep < x;\n        (if sep < x then linear_split_help xs x (prev @ [(sub, sep)])\n         else (prev, (sub, sep) # xs)) =\n        (ls, rs);\n        sorted_less (separators prev @ sep # separators xs);\n        \\<forall>sep\\<in>set prev. snd sep < x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>sep\\<in>set ls. snd sep < x", "by (metis prod.inject)+"], ["", "value \"linear_split [((Leaf::nat btree), 2)] (1::nat)\""], ["", "(* TODO still has format for older proof *)"], ["", "lemma linear_split_gr:\n  \"\\<lbrakk>linear_split_help xs p ys = (ls,rs); sorted_less (separators (ys@xs)); \\<forall>(sub,sep) \\<in> set ys. p > sep\\<rbrakk> \\<Longrightarrow> \n(case rs of [] \\<Rightarrow> True | (_,sep)#_ \\<Rightarrow> p \\<le> sep)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>linear_split_help xs p ys = (ls, rs);\n     sorted_less (separators (ys @ xs));\n     \\<forall>(sub, sep)\\<in>set ys. sep < p\\<rbrakk>\n    \\<Longrightarrow> case rs of [] \\<Rightarrow> True\n                      | (x, sep) # xa \\<Rightarrow> p \\<le> sep", "apply(cases rs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>linear_split_help xs p ys = (ls, rs);\n     sorted_less (separators (ys @ xs));\n     \\<forall>(sub, sep)\\<in>set ys. sep < p; rs = []\\<rbrakk>\n    \\<Longrightarrow> case rs of [] \\<Rightarrow> True\n                      | (x, sep) # xa \\<Rightarrow> p \\<le> sep\n 2. \\<And>a list.\n       \\<lbrakk>linear_split_help xs p ys = (ls, rs);\n        sorted_less (separators (ys @ xs));\n        \\<forall>(sub, sep)\\<in>set ys. sep < p; rs = a # list\\<rbrakk>\n       \\<Longrightarrow> case rs of [] \\<Rightarrow> True\n                         | (x, sep) # xa \\<Rightarrow> p \\<le> sep", "by (auto simp add: some_child_sm)"], ["", "lemma linear_split_req:\n  assumes  \"linear_split xs p = (ls,(sub,sep)#rs)\"\n    and \"sorted_less (separators xs)\"\n  shows  \"p \\<le> sep\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> sep", "using assms linear_split_gr"], ["proof (prove)\nusing this:\n  linear_split xs p = (ls, (sub, sep) # rs)\n  sorted_less (separators xs)\n  \\<lbrakk>linear_split_help ?xs ?p ?ys = (?ls, ?rs);\n   sorted_less (separators (?ys @ ?xs));\n   \\<forall>(sub, sep)\\<in>set ?ys. sep < ?p\\<rbrakk>\n  \\<Longrightarrow> case ?rs of [] \\<Rightarrow> True\n                    | (x, sep) # xa \\<Rightarrow> ?p \\<le> sep\n\ngoal (1 subgoal):\n 1. p \\<le> sep", "by fastforce"], ["", "lemma linear_split_req2:\n  assumes  \"linear_split xs p = (ls@[(sub,sep)],rs)\"\n    and \"sorted_less (separators xs)\"\n  shows  \"sep < p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sep < p", "using linear_split_sm[of xs p \"[]\" \"ls@[(sub,sep)]\" rs]"], ["proof (prove)\nusing this:\n  \\<lbrakk>linear_split_help xs p [] = (ls @ [(sub, sep)], rs);\n   sorted_less (separators ([] @ xs));\n   \\<forall>sep\\<in>set (separators []). sep < p\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sep\\<in>set (separators (ls @ [(sub, sep)])).\n                       sep < p\n\ngoal (1 subgoal):\n 1. sep < p", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>linear_split_help xs p [] = (ls @ [(sub, sep)], rs);\n   sorted_less (separators ([] @ xs));\n   \\<forall>sep\\<in>set (separators []). sep < p\\<rbrakk>\n  \\<Longrightarrow> \\<forall>sep\\<in>set (separators (ls @ [(sub, sep)])).\n                       sep < p\n  linear_split xs p = (ls @ [(sub, sep)], rs)\n  sorted_less (separators xs)\n\ngoal (1 subgoal):\n 1. sep < p", "by (metis Nil_is_map_conv Un_iff append_self_conv2 empty_iff empty_set linear_split.elims prod_set_simps(2) separators_split snd_eqD snds.intros)"], ["", "interpretation split linear_split"], ["proof (prove)\ngoal (1 subgoal):\n 1. split linear_split", "by (simp add: linear_split_req linear_split_req2 linear_split_append split_def)"], ["", "subsection \"Binary split\""], ["", "text \"It is possible to define a binary split predicate.\n      However, even proving that it terminates is uncomfortable.\""], ["", "function (sequential) binary_split_help:: \"(_\\<times>'a::linorder) list \\<Rightarrow> (_\\<times>'a) list \\<Rightarrow> (_\\<times>'a) list \\<Rightarrow> 'a \\<Rightarrow>  ((_\\<times>_) list \\<times> (_\\<times>_) list)\" where\n  \"binary_split_help ls [] rs x = (ls,rs)\" |\n  \"binary_split_help ls as rs x = (let (mls, mrs) = split_half as in (\n  case mrs of (sub,sep)#mrrs \\<Rightarrow> (\n    if x < sep then binary_split_help ls mls (mrs@rs) x\n    else if x > sep then binary_split_help (ls@mls@[(sub,sep)]) mrrs rs x\n    else (ls@mls, mrs@rs)\n    )\n  )\n)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>ls rs xa. x = (ls, [], rs, xa) \\<Longrightarrow> P;\n        \\<And>ls v va rs xa.\n           x = (ls, v # va, rs, xa) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>ls rs x lsa rsa xa.\n       (ls, [], rs, x) = (lsa, [], rsa, xa) \\<Longrightarrow>\n       (ls, rs) = (lsa, rsa)\n 3. \\<And>ls rs x lsa v va rsa xa.\n       (ls, [], rs, x) = (lsa, v # va, rsa, xa) \\<Longrightarrow>\n       (ls, rs) =\n       (let (mls, mrs) = split_half (v # va)\n        in case mrs of\n           (sub, sep) # mrrs \\<Rightarrow>\n             if xa < sep\n             then binary_split_help_sumC (lsa, mls, mrs @ rsa, xa)\n             else if sep < xa\n                  then binary_split_help_sumC\n                        (lsa @ mls @ [(sub, sep)], mrrs, rsa, xa)\n                  else (lsa @ mls, mrs @ rsa))\n 4. \\<And>ls v va rs x lsa vaa vaaa rsa xa.\n       (ls, v # va, rs, x) = (lsa, vaa # vaaa, rsa, xa) \\<Longrightarrow>\n       (let (mls, mrs) = split_half (v # va)\n        in case mrs of\n           (sub, sep) # mrrs \\<Rightarrow>\n             if x < sep then binary_split_help_sumC (ls, mls, mrs @ rs, x)\n             else if sep < x\n                  then binary_split_help_sumC\n                        (ls @ mls @ [(sub, sep)], mrrs, rs, x)\n                  else (ls @ mls, mrs @ rs)) =\n       (let (mls, mrs) = split_half (vaa # vaaa)\n        in case mrs of\n           (sub, sep) # mrrs \\<Rightarrow>\n             if xa < sep\n             then binary_split_help_sumC (lsa, mls, mrs @ rsa, xa)\n             else if sep < xa\n                  then binary_split_help_sumC\n                        (lsa @ mls @ [(sub, sep)], mrrs, rsa, xa)\n                  else (lsa @ mls, mrs @ rsa))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All binary_split_help_dom", "apply(relation \"measure (\\<lambda>(ls,xs,rs,x). length xs)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. wf (measure (\\<lambda>(ls, xs, rs, x). length xs))\n 2. \\<And>ls v va rs x xa xb y x21 x22 xaa ya.\n       \\<lbrakk>xa = split_half (v # va); (xb, y) = xa; y = x21 # x22;\n        (xaa, ya) = x21; x < ya\\<rbrakk>\n       \\<Longrightarrow> ((ls, xb, y @ rs, x), ls, v # va, rs, x)\n                         \\<in> measure (\\<lambda>(ls, xs, rs, x). length xs)\n 3. \\<And>ls v va rs x xa xb y x21 x22 xaa ya.\n       \\<lbrakk>xa = split_half (v # va); (xb, y) = xa; y = x21 # x22;\n        (xaa, ya) = x21; \\<not> x < ya; ya < x\\<rbrakk>\n       \\<Longrightarrow> ((ls @ xb @ [(xaa, ya)], x22, rs, x), ls, v # va,\n                          rs, x)\n                         \\<in> measure (\\<lambda>(ls, xs, rs, x). length xs)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b va x ab bb x22.\n       \\<lbrakk>(ab, bb) # x22 = drop (Suc (length va) div 2) ((a, b) # va);\n        bb < x\\<rbrakk>\n       \\<Longrightarrow> length x22 < Suc (length va)", "by (metis append_take_drop_id length_Cons length_append lessI trans_less_add2)"], ["", "fun binary_split where\n  \"binary_split as x = binary_split_help [] as [] x\""], ["", "text \"We can show that it will return sublists that concatenate to\n      the original list again but will not show that it fulfils sortedness properties.\""], ["", "lemma \"binary_split_help as bs cs x = (ls,rs) \\<Longrightarrow> (as@bs@cs) = (ls@rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_split_help as bs cs x = (ls, rs) \\<Longrightarrow>\n    as @ bs @ cs = ls @ rs", "apply(induction as bs cs x arbitrary: ls rs rule: binary_split_help.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ls rs x lsa rsa.\n       binary_split_help ls [] rs x = (lsa, rsa) \\<Longrightarrow>\n       ls @ [] @ rs = lsa @ rsa\n 2. \\<And>ls v va rs x lsa rsa.\n       \\<lbrakk>\\<And>xa xb y x21 x22 xaa ya lsa rsa.\n                   \\<lbrakk>xa = split_half (v # va); (xb, y) = xa;\n                    y = x21 # x22; (xaa, ya) = x21; x < ya;\n                    binary_split_help ls xb (y @ rs) x = (lsa, rsa)\\<rbrakk>\n                   \\<Longrightarrow> ls @ xb @ y @ rs = lsa @ rsa;\n        \\<And>xa xb y x21 x22 xaa ya lsa rsa.\n           \\<lbrakk>xa = split_half (v # va); (xb, y) = xa; y = x21 # x22;\n            (xaa, ya) = x21; \\<not> x < ya; ya < x;\n            binary_split_help (ls @ xb @ [(xaa, ya)]) x22 rs x =\n            (lsa, rsa)\\<rbrakk>\n           \\<Longrightarrow> (ls @ xb @ [(xaa, ya)]) @ x22 @ rs = lsa @ rsa;\n        binary_split_help ls (v # va) rs x = (lsa, rsa)\\<rbrakk>\n       \\<Longrightarrow> ls @ (v # va) @ rs = lsa @ rsa", "apply (auto simp add: drop_not_empty split!: list.splits )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ls a b va rs x lsa rsa aa ba x22.\n       \\<lbrakk>\\<And>ab y ac xaa lsa rsa.\n                   \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                    ac = aa; y = (aa, ba) # x22; xaa = aa; x < ba;\n                    binary_split_help ls\n                     (take (Suc (length va) div 2) ((a, b) # va))\n                     ((aa, ba) # x22 @ rs) x =\n                    (lsa, rsa)\\<rbrakk>\n                   \\<Longrightarrow> ls @\n                                     take (Suc (length va) div 2)\n((a, b) # va) @\n                                     (aa, ba) # x22 @ rs =\n                                     lsa @ rsa;\n        \\<And>ab y ac xaa lsa rsa.\n           \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n            ac = aa; y = (aa, ba) # x22; xaa = aa; ba < x;\n            binary_split_help\n             (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)])\n             x22 rs x =\n            (lsa, rsa)\\<rbrakk>\n           \\<Longrightarrow> ls @\n                             take (Suc (length va) div 2) ((a, b) # va) @\n                             (aa, ba) # x22 @ rs =\n                             lsa @ rsa;\n        drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n        (if x < ba\n         then binary_split_help ls\n               (take (Suc (length va) div 2) ((a, b) # va))\n               (drop (Suc (length va) div 2) ((a, b) # va) @ rs) x\n         else if ba < x\n              then binary_split_help\n                    (ls @\n                     take (Suc (length va) div 2) ((a, b) # va) @\n                     [(aa, ba)])\n                    x22 rs x\n              else (ls @ take (Suc (length va) div 2) ((a, b) # va),\n                    drop (Suc (length va) div 2) ((a, b) # va) @ rs)) =\n        (lsa, rsa)\\<rbrakk>\n       \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa", "subgoal for ls a b va rs  x lsa rsa aa ba x22"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ab y ac xaa ls rs.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; x < ba;\n                 binary_split_help ls\n                  (take (Suc (length va) div 2) ((a, b) # va))\n                  ((aa, ba) # x22 @ rs) x =\n                 (ls, rs)\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rs;\n     \\<And>ab y ac xaa ls rs.\n        \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va); ac = aa;\n         y = (aa, ba) # x22; xaa = aa; ba < x;\n         binary_split_help\n          (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22\n          rs x =\n         (ls, rs)\\<rbrakk>\n        \\<Longrightarrow> ls @\n                          take (Suc (length va) div 2) ((a, b) # va) @\n                          (aa, ba) # x22 @ rs =\n                          ls @ rs;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     (if x < ba\n      then binary_split_help ls (take (Suc (length va) div 2) ((a, b) # va))\n            (drop (Suc (length va) div 2) ((a, b) # va) @ rs) x\n      else if ba < x\n           then binary_split_help\n                 (ls @\n                  take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)])\n                 x22 rs x\n           else (ls @ take (Suc (length va) div 2) ((a, b) # va),\n                 drop (Suc (length va) div 2) ((a, b) # va) @ rs)) =\n     (lsa, rsa)\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa", "apply(cases \"cmp x ba\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>ab y ac xaa ls rs.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; x < ba;\n                 binary_split_help ls\n                  (take (Suc (length va) div 2) ((a, b) # va))\n                  ((aa, ba) # x22 @ rs) x =\n                 (ls, rs)\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rs;\n     \\<And>ab y ac xaa ls rs.\n        \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va); ac = aa;\n         y = (aa, ba) # x22; xaa = aa; ba < x;\n         binary_split_help\n          (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22\n          rs x =\n         (ls, rs)\\<rbrakk>\n        \\<Longrightarrow> ls @\n                          take (Suc (length va) div 2) ((a, b) # va) @\n                          (aa, ba) # x22 @ rs =\n                          ls @ rs;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     (if x < ba\n      then binary_split_help ls (take (Suc (length va) div 2) ((a, b) # va))\n            (drop (Suc (length va) div 2) ((a, b) # va) @ rs) x\n      else if ba < x\n           then binary_split_help\n                 (ls @\n                  take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)])\n                 x22 rs x\n           else (ls @ take (Suc (length va) div 2) ((a, b) # va),\n                 drop (Suc (length va) div 2) ((a, b) # va) @ rs)) =\n     (lsa, rsa);\n     cmp x ba = LT\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa\n 2. \\<lbrakk>\\<And>ab y ac xaa ls rs.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; x < ba;\n                 binary_split_help ls\n                  (take (Suc (length va) div 2) ((a, b) # va))\n                  ((aa, ba) # x22 @ rs) x =\n                 (ls, rs)\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rs;\n     \\<And>ab y ac xaa ls rs.\n        \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va); ac = aa;\n         y = (aa, ba) # x22; xaa = aa; ba < x;\n         binary_split_help\n          (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22\n          rs x =\n         (ls, rs)\\<rbrakk>\n        \\<Longrightarrow> ls @\n                          take (Suc (length va) div 2) ((a, b) # va) @\n                          (aa, ba) # x22 @ rs =\n                          ls @ rs;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     (if x < ba\n      then binary_split_help ls (take (Suc (length va) div 2) ((a, b) # va))\n            (drop (Suc (length va) div 2) ((a, b) # va) @ rs) x\n      else if ba < x\n           then binary_split_help\n                 (ls @\n                  take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)])\n                 x22 rs x\n           else (ls @ take (Suc (length va) div 2) ((a, b) # va),\n                 drop (Suc (length va) div 2) ((a, b) # va) @ rs)) =\n     (lsa, rsa);\n     cmp x ba = EQ\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa\n 3. \\<lbrakk>\\<And>ab y ac xaa ls rs.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; x < ba;\n                 binary_split_help ls\n                  (take (Suc (length va) div 2) ((a, b) # va))\n                  ((aa, ba) # x22 @ rs) x =\n                 (ls, rs)\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rs;\n     \\<And>ab y ac xaa ls rs.\n        \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va); ac = aa;\n         y = (aa, ba) # x22; xaa = aa; ba < x;\n         binary_split_help\n          (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22\n          rs x =\n         (ls, rs)\\<rbrakk>\n        \\<Longrightarrow> ls @\n                          take (Suc (length va) div 2) ((a, b) # va) @\n                          (aa, ba) # x22 @ rs =\n                          ls @ rs;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     (if x < ba\n      then binary_split_help ls (take (Suc (length va) div 2) ((a, b) # va))\n            (drop (Suc (length va) div 2) ((a, b) # va) @ rs) x\n      else if ba < x\n           then binary_split_help\n                 (ls @\n                  take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)])\n                 x22 rs x\n           else (ls @ take (Suc (length va) div 2) ((a, b) # va),\n                 drop (Suc (length va) div 2) ((a, b) # va) @ rs)) =\n     (lsa, rsa);\n     cmp x ba = GT\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>ab y ac xaa ls.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; lsa = ls\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rsa;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     binary_split_help ls (take (Suc (length va) div 2) ((a, b) # va))\n      ((aa, ba) # x22 @ rs) x =\n     (lsa, rsa);\n     x < ba\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa\n 2. \\<lbrakk>drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     x = ba; lsa = ls @ take (Suc (length va) div 2) ((a, b) # va);\n     rsa = (aa, ba) # x22 @ rs\\<rbrakk>\n    \\<Longrightarrow> (a, b) # va =\n                      take (Suc (length va) div 2) ((a, b) # va) @\n                      (aa, ba) # x22\n 3. \\<lbrakk>\\<And>ab y ac xaa ls.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; lsa = ls\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rsa;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     binary_split_help\n      (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22 rs\n      x =\n     (lsa, rsa);\n     ba < x\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa", "apply (metis Cons_eq_appendI append_eq_appendI append_take_drop_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     x = ba; lsa = ls @ take (Suc (length va) div 2) ((a, b) # va);\n     rsa = (aa, ba) # x22 @ rs\\<rbrakk>\n    \\<Longrightarrow> (a, b) # va =\n                      take (Suc (length va) div 2) ((a, b) # va) @\n                      (aa, ba) # x22\n 2. \\<lbrakk>\\<And>ab y ac xaa ls.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; lsa = ls\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rsa;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     binary_split_help\n      (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22 rs\n      x =\n     (lsa, rsa);\n     ba < x\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa", "apply (metis append_take_drop_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ab y ac xaa ls.\n                \\<lbrakk>ab = take (Suc (length va) div 2) ((a, b) # va);\n                 ac = aa; y = (aa, ba) # x22; xaa = aa; lsa = ls\\<rbrakk>\n                \\<Longrightarrow> ls @\n                                  take (Suc (length va) div 2)\n                                   ((a, b) # va) @\n                                  (aa, ba) # x22 @ rs =\n                                  ls @ rsa;\n     drop (Suc (length va) div 2) ((a, b) # va) = (aa, ba) # x22;\n     binary_split_help\n      (ls @ take (Suc (length va) div 2) ((a, b) # va) @ [(aa, ba)]) x22 rs\n      x =\n     (lsa, rsa);\n     ba < x\\<rbrakk>\n    \\<Longrightarrow> ls @ (a, b) # va @ rs = lsa @ rsa", "by (metis Cons_eq_appendI append_eq_appendI append_take_drop_id)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<lbrakk>sorted_less (separators (as@bs@cs)); binary_split_help as bs cs x = (ls,rs); \\<forall>y \\<in> set (separators as). y < x\\<rbrakk>\n\\<Longrightarrow> \\<forall>y \\<in> set (separators ls). y < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_less (separators (as @ bs @ cs));\n     binary_split_help as bs cs x = (ls, rs);\n     \\<forall>y\\<in>set (separators as). y < x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set (separators ls). y < x", "oops"], ["", "end"]]}